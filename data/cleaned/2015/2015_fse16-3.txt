anti patterns in search based program repair shin hwei tan hiroaki y oshida mukul r. prasad abhik roychoudhury national university of singapore singapore fujitsu laboratories of america inc. sunnyvale ca usa shinhwei abhik comp.nus.edu.sg hyoshida mukul us.fujitsu.com abstract search based program repair automatically searches for a program fix within a given repair space.
this may be accomplishedbyretrofittingagenericsearchalgorithmforprogram repair as evidenced by the genprog tool or by building a customized search algorithm for program repair as in spr.
unfortunately automated program repair approaches may produce patches that may be rejected by programmers because of which past works have suggested using humanwritten patches to produce templates to guide program repair.
in this work we take the position that we will not provide templates to guide the repair search because that may unduly restrict the repair space and attempt to overfit the repairs into one of the provided templates.
instead we suggest the use of a set of anti patterns a set of generic forbidden transformations that can be enforced on top of any search based repair tool.
we show that by enforcing ouranti patterns we obtain repairs that localize the correct lines or functions involve less deletion of program functionality and are mostly obtained more efficiently.
since our set of anti patterns are generic we have integrated them into existing search based repair tools including genprog and spr thereby allowing us to obtain higher quality program patches with minimal effort.
ccs concepts software and its engineering software testing and debugging search based software engineering computing methodologies genetic programming keywords debugging fault localization and repair .
introduction automated program repair techniques have gained prominence in recent years .
these techniques bear this author was an intern at fujitsu laboratories of america during part of this work.the promise of automatically suggesting fixes to easy tofix programming errors thereby relieving substantial burden from programmers on the manual effort of debugging and generating fixes.
a major challenge in automated program repairs arises from the incomplete specification of intended behavior.
indeed any repair technique tries to patch errors so as to achieve the intended behavior.
yet in reality the intended behavior is incompletely specified often through a set of test cases.
thus repair methods attempt to patch a given buggy program so that the patched program passes all tests in a given test suite t. unsurprisingly this may not only lead to incomplete fixes but the patched program may also end up introducing new errors because the patched program may fail tests outside t which were previously passing .
several recent research articles have pointed out the pitfalls of using test suites as specification to drive program repair .
furthermore if the test oracles of the tests in the test suite are not strong enough simple program modifications such as deletion of program functionality have been shown to be sufficient to repair programs .
the situation presents us with an unenviable dilemma we want to avoid incomplete or incorrect fixes but it is not practical to assume the presence of formal specifications to drive program repair towards correct fixes.
in this paper we propose to use anti patterns to help alleviate the problem of incorrect or incomplete fixes resulting from program repair.
we present our technique in the context ofsearch based program repair systems also referred to as generate and validate systems in the literature .
these repair tools seek to repair a buggy program one failing at least one test in a given test suite t by searching among possible fixes by applying fix templates.
a proposed fix is validated if it passes all the tests in the given testsuitet.
one key problem faced in the resulting fixes is that they often boil down to program modifications like deletion of functionality which though sufficient to pass tests in given test suite t may fail tests outside tand can be unacceptable to developers in general.
our main idea is simple for any search based repair technique which is searching for a plausible repair we define a set of anti patterns that essentially capture disallowed modifications to the buggy program.
in other words even if such a modification results in the modified program passing all tests in the given test suite we do not count them as repairs.
our set of anti patterns is generic and does not vary across application domains.
this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication fse november seattle wa usa c acm.
... 727conceptually our idea is different from the strategy of using human patch templates to guide program repair .
generally speaking the use of human patch templates is geared towards producing patches close to human patches the underlying assumption being that by going close to human patches we will avoid incorrect or incomplete fixes.
however this requires providing human patch templates which is limited by a fixed set of templates and hence the produced repair may overfit the provided set of templates.
furthermore there is a strong assumption that by fitting patches to human patch templates we have a greater chance of the fix being accepted by developers an assumption that may or may not be true e.g.
argues that fix acceptability may be an unanswerable question .
instead of gearing our repair towards human patches by providing human patch templates we ask ourselves the following research question is it possible to drive the repair search towards correct and complete fixes simply by providing a generic set of anti patterns ?many of our antipatterns are at the level of the control flow graph forbidding certain manipulations to the control flow graph.
a few of the anti patterns involve assignments affecting branch outcomes and one anti pattern forbids adding tautologies as branch conditions.
overall our anti patterns are generic.
furthermore and more importantly we are not proposing a separate repair method based on anti patterns .
our proposed set of anti patterns can be integrated into any existing search based repair tool and we can then compare the repair produced after enforcing anti patterns with the original repairs produced by the search based repair tool.
indeed we propose a small set of anti patterns and we have integrated them into two existing search based program repair tools genprog and spr .
any automated program repair system is driven by a correctness criterion to which we repair to and since formal specifications are usually absent test suites are used as correctness criteria.
as a fully automatedderivation of a formal correctness criterion is often impossible our anti patterns are not meant to solve the problem of deriving better correctness criteria.
instead the value of our anti patterns lies in their ability to provide more precise repair hints to developers which is illustrated through our evaluation on patch quality.
we evaluated our anti patterns on real bugs obtained from subjects.
results from our experiments indicate that anti patterns could lead search based programrepair tools to producingpatchesthat localizes betterbyisolatingeitherthecorrectlineorthecorrectfunction.
moreover anti patterns could also reduce the destructive effect of search based repair tools by producing patches that removes less functionality.
our anti patterns also provide considerable amount of speedup in obtaining the final repair because our anti patterns prune the repair search space.
all experimental data are available at the following web site .
.
related work search based repair.
one of the earliest and most wellknown representative of search based repair systems genprog uses genetic programming to search its repair space.
its repairs consist of code snippets copied from elsewhere in the program.
rsrepair searches a similar repair space but using random search instead.
ae uses a deterministic search strategy but exploits program equiv alence relations to prune equivalent patches.
however recent work has shown that the vast majority of patches produced by genprog rsrepair and ae are semantically equivalenttofunctionalitydeletionandthattheirkalirepair tool that exclusively relies on a small set of functionality deletion repair schemas can achieve similar results.
par re uses genprog s basic search strategy but proposes a set of specialized repair templates manually derived from human written patches and show that they are more successful in identifying correct and meaningful patches than genprog.
relifix addresses the repair of software regression errors in a search based repair framework.
it proposes the use of previous versions of a buggy program and a set of novel contextual repair operators operating on multiple versions of the program to define the repair space.
spr recognizes bug fixes based on manipulation or insertion of conditional statements as an important subset of machine generatable patches.
it proposes a heuristic strategy to search the repair space defined by its rich set of repair schemas patch patterns instead of anti patterns .
a key innovation is the use of abstract repair conditions to evaluate and prune away the vast majority of condition repair candidates staging before concretizing and evaluating them against the full test suite.
the recent work of prophet uses machine learning to characterize previously known correct human patches and uses the learned characterization to prioritize candidate repairs in an effort to avoid plausible patches incorrect patches that pass the test suite.
however for the majority of bugs when the correct repair is outside the search space of the tool such plausible patches might still be generated.
ourapproachsharespar sgoalofgeneratingmoremeaningful patches and spr and prophet s goal of avoiding plausible but incorrect patches.
however it is in essence orthogonal to all of the above search based repair approaches in that it seeks to analyze a repair schema as instantiated in the context of a specific program and bug and disallow ones that result in unreasonable changes to the original program s behavior.
our anti patterns form a simple set of do not rules in the style of software development or software design anti patterns which can guide an automated repair tool.
thus our approach is rather independent of the repair schemas and search strategies being used and can be integrated into any of the above repair tools.
oracle based repair.
semfix uses symbolic execution to capture and implicity express the values that an expression under repair must assume under various test executions.
it then uses program synthesis to synthesize a repaired statement compatiblewith this oracle .
minthint also uses symbolic execution to synthesize an oracle but then uses statistical analysis to guide the choice for a repair.
nopol addresses the repair of branch conditions and uses instrumented test suite executions to synthesize an oracle which is then converted into a suitable smt formula representing feasible repairs and solved to generate a patch.
directfix generates minimal repairs to obtain human readable and comprehensible repairs.
the idea is to encode the problem as a partial maximum satisfiability problem over smt formulas partial maxsat and solve it using a suitably modified smt solver.
angelix solves the scalability problems of directfix by using a lightweight repair constraint.
since the above techniques do not directly tackle the problem of the incompleteness of the repair speci728table prevalence of anti patterns in plausible patches anti delete cfg exit node anti delete control statementanti delete single statement cfganti delete set before ifanti delete loop counter updateanti append early exitanti append trivial conditions delete exitdelete returndelete gotodelete error codedelete if statementdelete loopdelete only statement within ifdelete conditiondelete loop counter updateinsert early returninsert early exitinsert early gotoinsert tautologyinsert contradiction genprog .
.
.
.
.
.
.
.
.
.
.
spr .
.
.
.
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
.
.
.
.
fication i.e.
the test suite they could in theory benefit from our technique.
however the appropriate integration of our technique in these tools is non obvious and would require further investigation.
specification based repair.
autofixe usesdeveloperprovided software contracts e.g.
invariants pre conditions and post conditions to automatically repair faulty eiffel classes.
gopinath et al.
s approach encodes constraints on program behavior derived from a specification as a sat formula and uses the sat solution to construct a repair .
more recently samanta et al.
proposed the notion of costaware program repair whereby repairs are generated on a boolean abstraction of a c program based on a cost model and then concretized back to a repaired c program .
however human intervention is required to define the cost model and for the concretization.
as in the case of oraclebased techniques our ideas could benefit specification based repair techniques as well but would require further research.
domain specific repair.
automatic repair techniques have also been developed for specific application domains such as for data structure repair the vejovis system for repairing dom related faults in javascript code and the clearview system to fix security vulnerabilities .
patterns and anti patterns.
anti patterns are commonly occurring solutions to a problem that generate decidedly negative consequences .
we refer to our proposed set of forbidden transformations as anti patterns because they capture transformations which are solutions to the repair problem but generate decidedly negative consequences such as introducing regressions.
one notable difference between repair patterns in pattern based automatic program repair i.e par and our anti patterns is that repair patterns are derived from common bug fix patterns in human generated patches wheareas our anti patterns are derived from machine generated patches.
nevertheless as a subset of spr transformation schemas e.g.
add initialization are essentially repair patterns as in par checking the effectiveness of anti patterns in spr helps us to understand the characteristic of patches produced by a pattern based approach.
prior studies on the common patterns of incorrect human fixes are orthogonal to our work as our study focuses on the common problems in machine generated patches.
.
prev alence of anti patterns although various search based program repair techniques show promising results in generating a large number of patches prior studies show that most of these patches are often only plausible but incorrect .
specifically spr generates out of i.e plausible but incorrectpatches whilegenproggenerates50outof i.e.
.
plausiblepatches forthegenprogbenchmarks .
to better understand the nature of the plausible patches see definition for definition of plausible patches we performed a manual inspection on all the machine generatedpatches produced by spr and genprog including plausible and correct patches as well as on the correct developerprovided patches for these bugs.
specifically we manually analyzed each patch and attempted to answer two questions q1 what makes a given patch plausible?
why is it incorrect i.e.
does not capture the semantics of the developerprovided patch ?
q2 do the plausible patches as a whole share any common syntactic features that explain their plausibility as well as distinguish them from the pool of correct patches human as well as machine generated ?
the aim was to find a compact set of syntactic features that are independent of the repair templates used by the tool.
table shows the results of our manual inspection.
interestingly our manual inspection identified a set of simple features shown in the second row of table one or more of which appear in eachof the plausible patches produced by spr and genprog and almost none of the correct patches1.
they correspond to various modifications to the control flow or the data flow of the program.
each column corresponds to a specific feature and denotes the percentage of plausible patches bearing that feature.
note that our calculation considers the fact that one plausible patch may exhibit several features.
for example delete if statement column deletes an if statement and appears in of plausible genprog patches and .
of plausible spr patches.
similarly insert tautology column inserts a trivial tautological condition into the program and appears in .
of the plausible spr patches but none of the plausible genprog patches.
we further generalize and consolidate these features into transformations shown in the first row of table which we chose to further develop as anti patterns in our approach.
table lists the anti patterns that we identified through our manual inspection .
in each example patch in table and in patches presented throughout the paper code with a leading denotes statements deleted by the patch while code with a leading marks statements added.
code without any leading symbol denotes unchanged statements.
.
how anti patterns may help we illustrate how anti patterns can improve program repair by showing two examples of fixes in two projects.
the first example shows the effect of applying anti patterns for improvement in fix localization while the second example demonstrates the benefit of anti patterns in reducing patch generation time.
example improving fix localization.
listing9shows the genprog patch for findutils 84aef0ea 07b941b1 generated by genprog.
the genprog patch deletes the only return statement in parse noop ... .
this patch violates our anti delete cfg exit node pattern.
in contrast our version of genprog modified with anti patterns 1except for one php defect and one python defect.
729table our proposed set of anti patterns with examples that illustrate the usage of each antipattern anti patterns example a1 anti delete cfg exit node.
this pattern disallows removal of return statements exit calls functions with the word error i.e.
ignoring letter case and assertions.ex1 the example below shows a patch generated by genprog for libtiff 8f6338a 4c5a9ec .
the patch removes the erroneous exit call.
static void badppm char file fprintf stderr s not a ppm file.
n file exit listing example patch for anti delete cfg exit node a2 anti delete control statement thispatterndisallowsremovalofcontrolstatements e.g.
if statements switch statements and loops.ex2 the example below shows a patch generated by genprog forphp .
the patch removes the whole if thenelse statement that checks for the return value of a function call.
call result call user function ex ... if call result success retval !
null ... if success statbuf from array ... ret else if call result failure php error docref ... listing example patch for anti delete control statement a3 anti delete single statement cfg this pattern disallows deletion of the statement within a cfg node that has only one statement.ex3 the example below presents a candidate patch generated by genprog for libtiff 90d136e4 4c66680f .
the patch removes the statement that assigns the return value of which indicates a failure.
fail ret listing example patch for anti delete single statement cf g a4 anti delete set before if this pattern disallows deletion of a variable definition if the variable in the definition is used in subsequent if statement.ex4 the example shows a genprog generated candidate patch for libtiff d13be72c ccadf48a .
the patch removes the statement that stores the value of the expression estimatestripbytecounts ... .
tmp estimatestripbytecounts tif dir dircount if tmp!
goto bad listing example patch for anti delete set before if a5 anti delete loop counter update although more sophiscated techniques are needed to ensure termination in patched program we implement an approximation of this pattern by disallowing deletion of an assignment statement inside a loop if the set of variables used in the terminating condition intersects with the set of variables used in the lhs of the assignment statement.ex5 the example belows shows a patch that delete the increment statement with in a loop.
while x x listing example anti delete loop counter update a6 anti append early exit this pattern disallows insertion of return statement and goto statement at any location except for after the last statement in a cfg node.ex6 the example shows a spr s patch for php .
the patch adds a conditional return statement before a function call that throw s an error.
if type !
return zend error 3l uninitialized string offset ... listing example patch for anti append early exit a7 anti append trivial conditions this expression level pattern disallows insertion of trivial conditions.
a condition is trivial iff it is either true or false constant e.g.
if if it is evaluated to true or false by any assignment of the program variables e.g.
if x y !y and it is always evaluated to true or false by any values that program variables can take according to results of static analysis e.g.
if x y !
in which y is initialized .ex7 the following example shows two spr patches for lighttpd .
the patch in listing appends the condition !
to the existing condition which is semantically equivalent to disabling the branch containing the co ntinue statement.
the patch in listing loosens the original condition with the expr ession1 which is semantically equivalent to deleting the condition fields size .
if fmap .key !
format ptr if fmap .key !
format ptr !
continue listing example patch with contradiction for anti append t rivial conditions if fields size if fields size fields size fields used fields ptr malloc fields size sizeof format field listing example patch with tautology for anti append trivi al conditions 730table problems in search based program repairs and the corresp onding anti patterns aim to solve these problems problem anti patterns weak oracle.
instead of checking for the actual output of a program devel opers may validate the outcome of a failing test by relying on the exit status or a ssertions of the program.
such statements serve as proxies for verifying the correctness o f a program and thus they should not be manipulated by machine generated patches.
however suc h restrictions are not imposed on automatically generated patches.
in fact patches that sim ply remove such statements may be more preferable for test driven program repair techniques as they can be generated faster .a1 anti delete cfg exit node.
inadequate test coverage.
if the program under test has low code coverage test driven program repair tools could incorrectly remove a logical blo ck of statements as they are seen as redundant code to the test suite.
this may lead to regression s in the patched program a2 anti delete control statement a3 anti delete single statement cfg a4 anti delete set before if mask existing vulnerabilities.
a patched program may mask previously exposed vulnerability by removing certain branches through implicit data flow.a4 anti delete set before if non termination.
program repair tools may incorrectly remove a loop update st atement causing infinite loop in the patched program.
if no timeout is specified search based repair tools may spend the entire repair session to validate the pat ched program.
worst still such patches could be mistakenly treated as a repair if the test on ly checks if an error is thrown within a time limit.a5 anti delete loop counter update trivial patch.
an incorrectly patched program may bypass an important func tionality or an error check through insertions of premature exit calls.
t he worst scenario happens when repair tools produce trivial patches that simply insert ret urn statements based on the value of the expected output of the failing test e.g.
a trivial pa tch that insert if test1 return expected out a6 anti append early exit functionality removal repair tools like spr may produce patches that are semantica lly equivalent to functionality removal by inserting tautolog ical condition or contradition.
a tautology will cause the elimination of the check condition whi le a contradiction will cause the entire branch to be removed.a7 anti append trivial conditions genprog ae patch for findutils 84aef0ea 07b941b1 static boolean parse noop const struct parser table entry char argv int arg ptr void entry return parse true get noop argv arg ptr listing example patch generated by genprog mgenprog patch for findutils 84aef0ea 07b941b1 static boolean insert regex char argv int arg ptr const struct parser table entry int regex options ... if error message error s error message arg ptr our pred est success rate estimate pattern match rate argv return true developer patch for findutils 84aef0ea 07b941b1 insert regex char argv int arg ptr const struct parser table entry int regex options ... if error message error s error message arg ptr our pred est success rate estimate pattern match rate argv arg ptr return true listing example patches generated by mgenprog and findutils developer called mgenprog removes the statement that assigns the return value of estimate pattern match rate to the fieldour pred est success rate .
meanwhile findutils developer moved the statement arg ptr to the locationaftertheproblematicstatement our pred est success rate estimate pattern match rate ... that throws segmentation fault error due to out of bound access of the argvarray listing .
we argue that in this example our mgenprog patch is preferable to genprog s because mgenprog localizes the correct function compared to the genprog patch which is applied inside a completely different function parse noop mgenprog genprog mgenprog developer patch for php if p memchr s ?
ue s pp strchr s if pp pp p if pp s ret path estrndup s pp s php replace controlchars ex ret path pp s p pp goto label parse listing example patch generated by genprog mgenprog and php developers correctly pinpoints the function call that causes the error while the genprog patch completely removes the functionality encapsulated by the parse noop function.
this example shows that anti patterns can improve fix localization and eliminate nonsensical patches that remove functionality.
example accelerating program repair.
listing shows a patch that inserts a conditional statement that can be copied from other places within the same file.
while both genprog and mgenprog generate the patch in listing that is in fact equivalent to the correct patch mgenprog takes only .
hours compared to .
hours taken by genprog i.e.
mgenprog achieves a .
.
.5x speedup .
thus if the correct repair can be found within the repair space our anti patterns can serve as a search space pruning mechanism that reduces the time taken to find the correct repair through filtering of invalid patches.
table shows the common problems in the patches generated by search based program repair tools together with theanti patterns that solve these problems.
.
integrating anti patterns we integrate our anti patterns directly into two searchbased repair tools i.e.
genprog ae and spr .
procedure isantipattern shows our anti patterns filtering algorithm.
the function issinglecfgstmt e.stmtk corresponds to the anti delete single statement cfg pattern.
similarly issetbefif e.stk checks for the anti delete set731procedure isantipattern input p program input m transformations functions output isanti indicates if m violates any anti paterns 1isanti false 2ifm.type deletethen 3ifissinglecfgstmt m.stmtk then isanti true 5else ifisexitnode m.stk iscondition m.stk then isanti true 7else ifisassignment m.stmtk then isanti issetbfif m.stk issetinloop m.stk 9end 10else ifm.type appendthen 11isanti isexitnode m.stk islaststmt m 12end 13return isanti m.stk the ast node type of m. m.type the edit type of m before if pattern while issetinloop e.stk corresponds to theanti delete loop counter update pattern.
the functioniscondition e.stk indicateswhetheranedit einvolves a conditional statement which is used in the anti delete control statement .
the function isexitnode e.stk checks if the statement in edit eis a cfg exit node.
both antidelete cfg exit node andanti append early exit use this function.
the function islaststmt e checks if a statement will be inserted as the last statement in a cfg block to fulfill the requirement for the anti append early exit pattern.
as many search based approaches are based on evolutionary algorithm in which a population is reproduced evaluated and selected we recommend integrating ouranti patterns filtering algorithm before the initial population is generated to reduce the time spent in evaluating each individual in a population.
modification of spr and genprog.
algorithm shows the pseudo code of the mspr repair generation algorithm.
we implement our anti patterns on two parts of mspr first box .
for candidate repairs that do not require condition synthesis we apply similar modifications to mspr and mgenprog refer to procedure isantipattern .
second box .
for candidate repairs that require condition synthesis in mspr we apply the anti append trivial conditionspattern to each synthesized condition.
the function istrivialcondition c checks if the given condition cis a trivial condition refer to table for definition of trivial conditions .
as our modifications on genprog is similar to the changes on mspr for repairs that do not require condition synthesis we leave out the details for mgenprog.
.
experiments we compare the effectiveness of anti patterns on genprog and spr using two sets of benchmarks the corebench benchmarks and the genprog benchmarks .
we use the corebench benchmarks for the evaluation set because it contains real errors in widely used c programs.
although our manual inspection for deriving anti patterns in section was based on plausible patches from the genprog benchmarks this study used just onegenerated patch per buggy program.
a recent study has shown that the typical repair search space for these bugs contains up to thousands of plausible patches .
thus we feel it is still meaningful to study the impact of anti patterns on the complete repairalgorithm mspr repair generation algorithm input p program input positive and negative test cases negt and post input m transformation functions.
output the repaired program p or if failed 1forp inm p do if isantipattern p m then m m p end end 2forp inm p do 3ifp contains abstc then c condsynthesis p negt post 5forcincdo if istrivialcondition c then c c c iftest p negt post then return p end end end 6else iftest p negt post then return p 8end 9end condsynthesis p negt post searches for a sequence of values in p that pass all tests in negt and post.
the output of this funct ion is c the set of all synthesized conditions in the repair spac e. p the result of replacing every occurrence of abstcin p with the condition c. test p negt post check if the program p passes all tests.
space of these bugs.
our evaluation studies the following research questions rq1howdoanti patterns affectthequalityofpatchesgenerated by search based program repair tools?
rq2how many nonsensical patches can our anti patterns eliminate to reduce manual inspection costs?
rq3when our modified tools produce the same patch what is the speedup that we achieve?
rq4how does the use of anti patterns compare to an approach that simply prohibits deletion?
table subject programs and their basics statistics subjects description kloctests coreutils file shell and text manipulation utility .
findutils directory searching utility .
grep pattern matching utility .
make program executable generation utilities .
php programming language libtiff image processing library python programming language gmp math library gzip data compression utility wireshark network packet analyzer fbc compiler lighthttpd web server .
experimental setup we evaluate the effects of anti patterns on defects from thecorebenchbenchmarksandatleast37defectsfromthe genprogbenchmarks.
weexcludesomeversionsinourevaluation due to specific technical difficulties such as benchmarks that require specificsystem configurationsto be built.
specifically we exclude defects from the corebench benchmarks.
for the genprog benchmarks we manage to reproduce the bugs for defects in the original genprog experiment and defects in the original spr experiments.
732table overall results on genprog ae versus mgenprog mae subjects same patchdifferent patch localizes better less functionality removalno repair othersaverage speeduplocalizes correct linelocalizes correct function but incorrect line same patch ae mae ae mae ae mae ae mae coreutils findutils .
grep .
make .
php .
libtiff .
python .
gmp gzip .
wireshark fbc lighthttpd .
total .
.
.
table overall results on spr versus mspr subjects same patchdifferent patch localizes better less functionality removalno repair othersaverage speeduplocalizes correct linelocalizes correct function but incorrect line same patch spr mspr spr mspr spr mspr spr mspr coreutils .
findutils .
grep .
make php .
libtiff .
python .
gmp .
gzip .
wireshark .
fbc lighthttpd total .
.
.
table lists information about these subjects.
the first fourrowsofthetablelistthedetailsforthefourcorebench subjects while the remaining rows show relevant statistics aboutthegenprogsubjects.
foreachbug werungenprog mgenprog spr and mspr to produce repairs.
many of our anti patterns block functionality deletion so it is natural to ask if the same effect could be achieved by simply disallowing deletion in repair.
to answer rq4 we implement a customized version of genprog called dgenprog where we disallow the usage of the deletion mutation operator.
we reuse the same parameters listed in previous work for running genprog.
one significant difference is that we switch to the deterministic adaptive search algorithm ae to control potential randomness.
each run of genprog mgenprog dgenprog spr and mspr terminates either after all candidate repairs have been evaluated or when a patch is found i.e.
each tool runs to completion withouttimeout .
all experiments for genprog mgenprog and dgenprog were performed by distributing the load on virtual machines with single core intel xeon .40ghz processor and 19gb of memory.
all experiments for spr and mspr were performed on a core intel xeon e5 .40ghz processor and 408gb of memory.
after collecting all the repairs we manually inspect each of these patches and compare the quality of patches generatedbygenprogversusmgenprog mgenprogversusdgenprog and spr versus mspr.
definition .
we measure the quality of patches generated by search based repair tools using the criteria defined below q1 same patch.
ageneratedrepairisconsidered same patch if both the original tool and the modified tool generate exactly the same repair.
q2 localizes correct line.
a generated repair is considered localizescorrectline ifboththegeneratedpatch andthehumanpatchgeneraterepairsthatmodifythesame line.
for example we categorize the mgenprog patch in listing as localizes correct line .
q3 localizes correct function but incorrect line.
a generated repair is considered a patch that localizes the correct function if both the generated patch and the human patch modify statements within the same function.
q4 removes less functionality.
a generated repair is considered a repair that removes less functionality if the repairremovesorskipsover e.g.
byinsertingreturn fewer lines of source code from the original program.
q5 no repair.
we label a benchmark as no repair when the original tool generates a repair but the modified tool has iterated through the entire repair space and produce no final patch.
we categorize the patch quality of each repair according to the order listed above i.e we first check if a patch is same patch and only categorize a patch as removes less functionality if it does not satisfy other more preferable cr iteria e.g localizes correct function but incorrect line .
we eliminate the potential discrepancies on categorization by ensuring that each defined criteria can be measured through comparisons of the syntactic differences between two patche s. 733table patch correctness analysis result on mgenprog and mspr subjectsgenprog mgenprog spr mspr correct plausible correct plausible correct plausible correct plausible coreutils findutils grep make php libtiff python gmp gzip wireshark fbc lighthttpd total each column in tables and corresponds to the criteria defined above.
the others column denotes the cases where the patch does not fulfill any of the defined criteria.
numbers in the last row in tables and are of the form x y z wherexrepresents the number of patches in the corebench benchmarks ydenotes the number of patches in the genprog benchmarks and zis the total number of patches in both benchmarks.
we also manually classify and compute the number of correct repairs and the number of plausible repairs.
definition .
we use the definition below for our patch correctness analysis correct repair.
a repair ris acorrectrepair if r passes all test cases in the test suite and ris semantically equivalent to the repair issued by the developer.
plausible repair.
a repair ris aplausible repair if r passes all test cases in the test suite but risnotsemantically equivalent to the repair issued by the developer.
.
evaluation on corebench benchmarks the first four rows of table and show the evaluation results for the corebench benchmarks.
.
.
patch quality rq1 table shows that both genprog and mgenprog produce the same patch for defects in the corebench benchmarks.
mgenprog could localize the correct line in more defects than genprog.
mgenprog also generates patches that remove less functionality in defects.
table shows that both spr and mspr produce the same patch in defects.
mspr localizes the correct line in more defects than spr.
for defects mspr generates patches that removes less functionality.
table7showstheoverallpatchcorrectnessanalysisresults for genprog mgenprog spr and mspr for each subject.
genprog generates plausible patches while mgenprog produces plausible patches for the corebench benchmarks.
specifically mgenprog does not produce any repair forfindutils e8bd5a2c 66c536b because the patch violates our anti patterns .
both spr and mspr generate plausible patches for the corebench benchmarks.
improvement on fix localization.
our results show that anti patterns could lead both mgenprog and mspr to producingpatchesthatlocalizeeitherthecorrectlineorthecorrectfunction.
anti pattern enhancedtechniquesmayachieve this improvement because anti patterns may filter all invalid repairs on a given location forcing fixes to be generated at other locations.
we claim that the ability to localize more precisely is important because when the repair tools fail to generate the correct repair the next best thing is to checkwhether they can still generate hints that may lead developers to the repair faster.
less functionality removal.
under the presence of weak oracles search based repair tools may generate patches that pass the test suite by removing untested functionality.
our results shows that anti patterns help in producing patches that remove less functionality and thus reduce the potential destructive effects of generated patches.
comparison between mgenprog and mspr.
ourantipatterns integration achieves greater improvement of patch quality on genprog compared to spr.
we think that this difference may be due to spr being innately restricted by its set of transformation schemas which contain transformations that are often used in human patches.
predominance of plausible patches.
bothgenprogand spr do not generate any correct patch for the corebench benchmarks.
one possible explanation is that the defects in the corebench have higher error complexity than other benchmarks.
thus more substantial patches are required to fix the errors in these benchmarks .
these results also agree with our earlier observation in section that there is a clear predominance of plausible but incorrect patches among all automatically generated patches.
rq1 anti patterns direct repair tools towards generating patches that pinpoint the buggy location more accurately.
anti patterns also reduce the potential destructive effect of automatically generated patches by producing patches that remove less functionality.
.
.
reducing manual inspection cost rq2 spr may produce multiple patches in one repair session due to the use of batch compilation and its staged repair algorithm.
given several candidate repairs developers need to manually inspect and verify each individual patch.
figure shows the total number of patches generated by spr versus mspr for the corebench subjects.
as spr and mspr can produce multiple patches for a given bug figure reports the total number of patches while the data in tables and uses a single best patch according to the order in definition among all generated patches for a particular bug.
overall spr generates patches while mspr only generates patches.
our patch analysis reveals that all additional patches generated by spr not generated by mspr are indeeed plausible but incorrect patches.
discussion on number of plausible patches.
though prior evaluation of search based repair focuses on measuringthenumberofsuccessfulrepairs ourresultsshowthat mspr actually produces less number of candidate repairs than spr because some of the plausible patches produced by spr are actually nonsensical patches that are eliminated 734coreutils findutils grep make102030 6number of patchesspr mspr figure number of patches found by spr vs. mspr by ouranti patterns .
producing less plausible patches could save the time spent on manual filtering of invalid patches which would eventually be rejected by developers.
rq2 anti patterns reduce manual inspection cost by eliminating nonsensical candidate repairs.
.
.
speedup rq3 the average speedup same patch column in tables and denotes the average speedup obtained when we only considered the subjects where both the original tool and the modified tool produce the same patch.
we use the formula below for our speedup calculation repair time is defined as the time taken for a repair to be generated repair time speedup original repair time modified repair time when genprog and mgenprog produce the same patch mgenprog obtain an average repair time speedup of .39x while mspr obtain an average repair time speedup of .78x for the corebench benchmarks.
table subject programs and repair space reduction results for mgenprog and mspr subjectrepair space reduction mgenprog mspr coreutils findutils grep make php libtiff python gmp gzip wireshark fbc lighthttpd average table shows the overall reduction in the total number of repair candidates generated for mgenprog and mspr.
the last row is of the form x y zwherexdenotes average for corebench subjects ydenotes average for genprog subjects and zdenotes the average for all subjects.
we calculate the repair space reduction according to the formula below where totcrefers to the total number of repair candidates within the entire repair search space repair space reduction modified totc orig totc on average mgenprog achieves repair space reduction compared to genprog while mspr obtains repair space reduction compared to spr for corebench subjects.
discussion on speedup.
tables and show that by enforcinganti patterns weproducepatchesfasterduetorepair space reduction shown in table .
one conceptual argument against the idea of anti patterns may be that it might makethe repair search unduly inefficient.
these results show that it is not so.
in fact the anti patterns skip irrelevant parts of the repair space i.e.
repairs that causes undesirable behavior such as the deletion of the symptoms of a bug .
rq3 anti patterns reduce the overall repair time by pruning significant portion of the repair space.
.
.
comparison with dgenprog rq4 table shows the results for dgenprog versus mgenprog for the corebench benchmarks.
while both mgenprog and dgenprog produce same patches mgenprog localizes better compared to dgenprog in seven more subjects than dgenprog.
although dgenprog explicitly prohibits deletions our results show that mgenprog actually removes less functionality in five subjects compared to dgenprog.
our analysis reveals that dgenprog may produce patches that skip over many source lines of code by introducing early return.
for make 73e7767f d584d0c1 mgenprog localizes the correct line while dgenprog do not produce any repair.
when mgenprog and dgenprog produce the same patch mgenprog achieves an overall speedup of .20x over dgenprog in the corebench benchmarks.
improvement over dgenprog.
our results on the core bench benchmarks show that genprog with anti patterns produce patches of better quality and faster than genprog that simply prohibits deletions.
rq4 anti patterns produce patches of better quality and faster than an tool that simply prohibits deletions.
.
evaluation on genprog benchmarks the 12th rows of tables and show the experimental results for the genprog benchmarks.
tables and illustratethatour anti patterns achievesimilarimprovement on patch quality on the genprog benchmarks.
in particular mgenprog localizes better than genprog in seven more defects.
mgenprog also removes less functionality in defects.
in contrast mspr removes less functionality than spr in three defects on genprog benchmarks.
table shows that genprog produces correct repairs and plausible repairs while mgenprog produces two correct repairs and plausible repairs for the genprog benchmarks.
mgenprog does not generate any repair for three subjects due to their violations of anti patterns .
instead of producingcorrectrepairasingenprog mgenprogonlygenerates plausible repairs for php because thecorrectrepairactuallyinvolvesdeletionofaif statement which violates our anti delete control statement pattern.
in contrast mspr produces one more correct patch than spr and plausible repairs.
specifically mspr produces correctpatchfor php whilespronlygeneratesplausiblepatchforthisversion.
for libtiff 1ba752 mspr does not generate any repair while spr generatespatchwithtrivialconditionthatdisablesabranch.
as the correct repair for this libtiff defect requires modifications of multiple statements our analysis reveals that the correct repair is indeed outside of spr s repair space.
we also achieve similar reduction on repair time on the genprog benchmarks as in the corebench benchmarks.
restrictiveness of anti patterns .anotherconceptualargument against the idea of anti patterns may be that anti735table overall results on mgenprog mae versus dgenprog dae subjects same patchdifferent patch localizes better less functionality removalno repair othersaverage speeduplocalizes correct linelocalizes correct function but incorrect line same patch dae mae dae mae dae mae dae mae coreutils .
findutils .
grep .
make .
total .
patterns will be overly restrictive and will rule out any repair in many cases whereas if an existing search based tool produces some repair it still helps the developers to some extent.
our results on the genprog benchmarks show that anti patterns are not overly restrictive and in the few cases where it ruled out any repair indeed no valid repair existed.
weak proxies.
our experiments for spr and mspr use the updated proxies in previous work which modifies the test harness and the developer test script for phpand libtiff .
in contrast we reuse the weak proxies for our experiments on genprog and mgenprog.
we used the weak oracles for genprog and the strong oracles for spr because they are provided together with the original tool distribution.
if we compare the row of tables and in which different set of proxies are used we observe that having a stronger proxy does not help spr substantially in terms of fix localization.
indeed the improvement of mspr over spr in terms of localizing the correct line is similar to the improvement of mgenprog over genprog.
discussion on patch correctness.
ourresultsshowthat enforcing anti patterns does not necessarily lead to patches thatareexactlyequivalenttothehumanpatches.
thisisnot entirelyunexpected because we only mark a generated patch as correct if it is near identical to the developer provided patch.our repair method is driven by a suite of test cases and aims to pass the test suite while not inserting any of the anti patterns.
it frees the developers from providing different human patch patterns for different defect classes exception types vulnerabilities etc.
nevertheless mspr still generates one more correct repair than spr while mgenprog generates one plausible repair that removes a branch from the original program.
anti patterns provides repair space reduction yet are not overly restrictive.
.
threats to v alidity we identify the threats to validity of our experiments.
set ofanti patterns .ouranti patterns merely represent bug tool and language agnostic patterns that we found frequently occurred in bad patches and seldom in correct ones.
though our experimental results show that our proposed anti patterns are effective in eliminating invalid patches we do not claim that our proposed set is a complete set.
search.
we terminate the search for repairs in both genprog and spr after a repair has been found due to limited resources.
while both tools support full exploration that may generate similar patches as in our modified versions such exploration may also lead to increase in the number of invalid patches and longer manual inspection time.
as we usethedeterministicadaptivesearchalgorithm ae tocontrol potential randomness section .
we will re evaluate the savings for the stochastic algorithm in future work.patch correctness analysis.
whilewetriedtoassessrepair quality across multiple dimensions our check for semantic equivalence is inherently incomplete and many fixes exist for a particular fault.
our conservative patch analysis classifies a patch as correct only when near identical to the human patch.
hence the number of repairs reported as correct may be an underestimate because a plausible patch marked as not correct could very well be semantically equivalent to the developers provided patch.
generality of anti patterns .as we only evaluate the effect ofanti patterns on corebench benchmarks and the genprog benchmarks our anti patterns may have different effects on other benchmarks.
nevertheless our experimental results show that anti patterns provide similar benefits at least in both these benchmarks.
.
conclusions and future work in this paper we proposed integrating anti patterns to search basedprogramrepair.
ourexperimentalresultsshow that by enforcing anti patterns we produce patches with more pleasant properties such as patches that delete less functionality and localize better.
tools integrated with anti patterns also could generate patches faster due to repair space reduction.
a recent study shows the abundance of plausible patches and sparsity of correct patches thereby arguing for rich specifications beyond test suites to guide the repair process.
our results indicate that our anti patterns while they are not correctness specifications form one such set of specifications whose enforcement can improve patch quality.
while in this work we explicitly specified a set of antipatterns as prohibited code transformations in future it is feasible to implicitly specify anti patterns as selected code smells .
thus duringtherepairsearch anyprogrammodification that produces a program with a bad code smell could be effectively prohibited.
our work opens the possibility of adapting the idea of anti patterns to other search based software engineering activities beyond program repair.
for example specific code anti patterns identifying energy hot spots may be employed for energy reduction.
in future we are unlikely to have programming environments that automatically patch all errors without sufficient intervention or domain knowledge.
meanwhile it might be possible to have programming environments which attempt to patch programs so as to pass a given test suite and point the developers to likely error locations and likely fixes.
our proposal of anti patterns is a step in this direction.