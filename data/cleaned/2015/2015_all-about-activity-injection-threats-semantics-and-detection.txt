all about activity injection threats semantics and detection sungho lee kaist korea eshaj kaist.ac.krsungjae hwang lg electronics korea sungje.hwang lge.comsukyoung ryu kaist korea sryu.cs kaist.ac.kr abstract android supports seamless user experience by maintaining activities from different apps in the same activity stack.
while such close inter app communication is essential in the android framework the powerful inter app communication contains vulnerabilities that can inject malicious activities into avictim app s activity stack to hijack user interaction flows.
in this paper we demonstrate activity injection attacks with a simple malware and formally specify the activity activation mechanismusing operational semantics.
based on the operational semantics we develop a static analysis tool which analyzes android apps to detect activity injection attacks.
our tool is fast enough to analyze real world android apps in seconds on average and our experiments found that apps out of real worldandroid apps inject their activities into other apps tasks.
i. i ntroduction smartphones have changed many facets of everyday life immensely.
people read books listen to music browse websites purchase goods and send emails via smartphones withoutrestrictions of locations or time.
researchers report that morethan a half of smartphone users have used phones for online banking apps and for monitoring their health conditions .
thus smartphones maintain various kinds of sensitive data which makes the security of smartphones very important.
compared to desktop apps smartphone apps provide diverse functionalities with seamless user experience by heavily inter acting with other apps.
for example the gallery app uses theemail app to email pictures rather than having its own emailfunctionality.
while users may think that a single app managespictures and sends emails the actual implementation consistsof two independent apps using inter app communication.
tosupport frequent transitions between apps android providespowerful multitasking by managing app activities in a stackcalled a task and it refers the task to find an activity to display.
the task is an essential component to support userinteraction transitions smoothly by maintaining activities fromdifferent apps in the same activity stack.
however the powerful inter app communication contains vulnerabilities that may break the sandbox environment ofandroid.
even though each android app resides in its ownsecurity sandbox the ability of starting another app introducesa vulnerability that can inject malicious activities into thevictim app s activity stack to hijack user interaction flows.
the injected malicious activities can run in the context of avulnerable victim app and thus can launch various attacksincluding phishing .recently researchers reported security issues in task behaviors with a proof of concept implementation of task hijacking attacks .
they define these attacks as malware reside side by side with the victim apps in the same task and hijack the user sessions of the victim apps task hijacking.
while thetask hijacking attacks include true malicious actions they iden tify too many normal actions as vulnerable among the mostpopular apps from google play they identified .
of them as vulnerable because they consider as vulnerable aswell even such cases where users intentionally select particularactivities.
more importantly because they used a simplifiedtask state transition model considering only two activities perapp and one instantiation per activity the model does notcapture the actual task and activity behaviors correctly whichleads to missing true malicious attacks.
in this paper we present a class of critical task hijacking attacks activity injection attacks.
to reduce the amount of false alarms from identified task hijacking attacks we defineattacks that inject malicious activities into normal tasks asactivity injection attacks.
to understand the root cause of theattacks we formally specify the operational semantics of ac tivity activation.
the formalized semantics captures every taskbehavior described in the android developers reference without any constraints to limit the scope of task behaviors.as a showcase of activity injection attacks we developed amalware targeting the facebook app.
our malware injects amalicious activity into the task of facebook so that androiddisplays the malicious activity when users execute facebookby clicking the facebook icon.
this kind of attacks is ex tremely powerful because it does not require any permission and it is difficult for users to detect them because the attacksare launched when the users click legitimate apps icons.
based on our thorough understanding of the activity activation semantics we developed a static analyzer that detectactivity injection attacks in android apps.
our experimentsshow that the tool is fast enough to analyze real world androidapps in seconds on average.
we found that apps outof android apps have possible injection attacks.
the contributions of this paper include the following we present the first formal semantics of the android activity activation mechanism.
considering all the status ofactivity attributes and flags for inter app communication we specify all possible task behaviors rigorously andexhaustively.
.
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research252 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we identify the root causes of activity injection attacks.
the formal semantics specifies all possible ways of activity injection attacks and we show an example malwarethat injects a malicious activity into a benign app s task.
we developed a static analysis tool that detects possible activity injection attacks based on the formal semantics.
the tool is efficient enough to detect possible activity injection attacks in a large number of android apps.
we found and analyzed a number of possible activity injection cases in real world android apps.
in the rest of this paper we first provide a brief background about how android apps communicate with other apps by sharing activities section ii .
after formally specifying theactivity activation mechanism in android and showing itssecurity vulnerability with a sample malware section iii we present a tool that detects activity injection attacks au tomatically section iv .
we show that our tool can detectactivity injection attacks from real world android apps effi ciently section v .
we discuss related work section vi andconclude section vii .
ii.
b ackground a. android app overview android apps reside in their own security sandboxes within an android system .
android treats each app as a differentuser so that each app executes in isolation from others.
itprovides a secure environment because each app has ac cess only to its components with permission.
an app hasits own manifest file androidmanifest.xml that declares components and required device features for permission.
anandroid app consists of app components that can be invoked individually.
an app component is one of four types activities services content providers and broadcast receivers.
each type serves a different role and has a different lifecycle.for example an activity denotes a single screen with a userinterface like one for reading and one for writing emails.android apps communicate with others via intents.
an intent is an asynchronous message that activates activities services and broadcast receivers.
intents can start one component from another even in a different app.
for example gallery can start anactivity in email to send emails by calling startactivity .
to share data with others and to access system services android apps can request permission to access them.
b. activities and tasks among four types of components we focus on activities.
an activity is an instance of android.content.activity .
an app consists of multiple activities when a user launches an app one designated main activity starts and it can start another activities.
the android system manages runningactivities in a stack called a back stack and it calls a pair of a name and a back stack a task.
when obvious we use back stacks and tasks interchangeably.
the main activity is pushed at the bottom of the task as the root activity.
whenever anew activity starts the previous activity is stopped the newactivity is pushed onto the task and the user focus is with fig.
.
when gallery com.android.gallery starts an activity to email a picture the autosendactivity activity of email com.google.android.gm is pushed onto the task of gallery.
the new activity.
when the user presses the back button the current activity is popped from the task and the previousactivity resumes.
the topmost activity in the task is calleda top activity and it is the screen that a device displays.
figure illustrates that gallery com.android.gallery email com.google.android.gm and a chat app com.google.android.talk are executing on an android device.
each app has its own task gallery receives userinteraction in the foreground while the other email andchat apps are suspended in the background waiting tobe resumed.
each task has its own root activity and topactivity.
when gallery is launched the main activity gallerypicker is pushed onto the task of gallery as its root activity.
when a user navigates images gallery starts the imagegallery activity and pushes it onto its task suspending thegallerypicker activity which makes imagegallery a new top activity.
then a user emails a picture by starting autosendactivity which becomes a new top activity.
note that autosendactivity is an activity of email gallery uses an activity of email to email pictures rather than having itsown email functionality.
the android system provides various ways to manage activities using attributes in the activity manifest element and flags in the intent that are passed to the startactivity function.
for example the launchmode attribute in the activity manifest element specifies one of four modes to launch an activity standard singletop singletask andsingleinstance .
the default mode is standard and the manifest file may define launch modes of activities.
a standard orsingletop activity can be instantiated multiple times leading to duplicated activities in a task.
in contrast anactivity with the singletask orsingleinstance launch mode should be instantiated only once.
furthermore an ac tivity with the singleinstance launch mode is always the root activity of a task.
while a singletask activity can contain other standard orsingletop activities in its task a singleinstance activity does not contain any other activities in its task.
it is the only activity in its task if itstarts another activity that activity is assigned to a differenttask.
because the singletask andsingleinstance launch modes provide a different interaction model from most other apps they are not appropriate for most apps.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the malicious app cinjects its malicious activities into the tasks of victim apps aandbby specifying taskaffinity of the malicious activities with the victim apps package names and setting the flag activity new task intent flag.
c. activity injection attacks ren et al.
reported that the android multitasking features allow task hijacking attacks letting malware reside side by side with the victim apps in the same task and hijack the user sessions of the victim apps.
because their definition of task hijacking attacks is too broad they conservatively identifynormal actions as vulnerable which leads to impracticallymany false positives.
for example .
of the most popular apps from google play are identified as vulnerable because they take activities of other apps to their tasks which is a normal inter app communication in android.
in this paper we focus on activity injection attacks which inject activities of one app into another app s task.
unlike task hijacking attacks that consider activities in different apps tasks activity injection attacks focus on injection cases forphishing.
for example figure shows two tasks for the apps aandb.
every app has its own task and by default the name of the task is the app s package name a s activities are stored in the task com.example.a a s package name and b s activities are stored in the task com.example.b .
while each app maintains its own task it is possible for adversaries to injecttheir malicious activities into other legitimate app s task.
as we discuss in the next section there are ways to make activity injection attacks.
one such a way is to first spec ify the special attributes taskaffinity andlaunchmode of a malicious activity in the activity manifest element with a victim app s package name and standard respectively.
then to call the startactivity function for the malicious activity with the flag activity new task intent flag set.
because the android system refers taskaffinity to decide where to put activities adversaries can use the legitimate app s package name for taskaffinity of the malicious activity.
figure depicts that a malicious app cinjects its malicious activities into the tasks of aandbby specifying taskaffinity with the victim apps package names and setting the flag activity new task intent flag.
note that activity injection attacks do not require any permission.table i four kinds of the launchmode a ttribute launchmode description standardmake a new instance whenever this activity is activated.
singletopmake a new instance only when the top activity of the target task is not an instance ofthis activity.
singletaskmake a new instance when there does not existany instance of this activity in any task.
singleinstancemake a new instance when there does not existany instance of this activity in any task.
it is always the single activity in the task.
iii.
a ctivity activ a tion mechanism in this section we describe the overview of the activity activation mechanism and specify the mechanism as an operational semantics which spells out all possible task behaviorsrigorously and exhaustively.
using the semantics we presentthe threats of activity injection attacks with an example mal ware that injects a malicious activity into facebook app s task.
a. activity activation overview tasks and task stack the android system may have multiple tasks and one task stack.
a task is a logical component for showing a job to users and a task stack is astack for managing the current foreground task and previousbackground tasks.
a task has its own back stack to manageactivities.
when the task comes to the foreground the topactivity in its back stack is displayed on the device screen.when an activity finishes the android system pops it fromthe back stack of the task.
if the back stack is not empty thenew top activity is displayed on the screen.
otherwise thetask itself finishes.
the task stack behaves similarly with backstacks but it manages tasks.
the top task in the task stack isthe foreground task which interacts with users.
when a taskfinishes the android system pops it from the task stack andthe new top task if any is displayed on the screen.
if the taskstack is empty the home screen comes to the foreground.also when the home screen comes to the foreground thetask stack is always empty.
tasks may be alive after being popped from the task stack.
the task stack manages which task to display after finishingthe foreground task.
when a user presses the home button the task stack becomes empty and the home screen comes tothe foreground.
then all live tasks popped from the task stackare still pending and they may come back to the task stackwhen a user selects them from the overview screen .
activity activation properties developers can specify how to activate target activities using various androidproperties.
two kinds of properties mainly govern the activ ity activation mechanism the launchmode attribute in the activity manifest element and intent flags used to start activities.
while launchmode is specified in the manifest file for an activity class intent flags are set by caller ac tivities to declare how to activate target activities by calling startactivity with the intent flags as its arguments.
table i describes four kinds of launchmode .
developers may set only one of them for each activity and the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1intent i new intent calleractivity.this targetactivity.class 3i.setflags intent.flag activity new task 4startactivity i a java code for activation of targetactivity .
activity android name .targetactivity android taskaffinity com.facebook.katana android launchmode standard activity b targetactivity staskaffinity andlaunchmode .
fig.
.
code snippet for activity activation s string task name taskaffinity attribute a activityinstance activity instance a activityclass activity class t task string backstack l launchmode standard singletop singletask singleinstance f intentflag flag activity clear task flag activity clear top flag activity multiple task flag activity new task flag activity reorder to front flag activity single top flag activity task on home epsilon1 a l backstack epsilon1 t taskstack epsilon1 t taskpool c homebutton backbutton a l .startactivity a l s f fig.
.
domains stacks and commands default launchmode isstandard .
while the started target activity is put on the task of the caller activity in most cases developers can designate a different task forthe target task.
for example figure a shows java codethat activates targetactivity from calleractivity and figure b shows taskaffinity and launchmode of targetactivity defined in androidmanifest.xml .i nt h e java code an intent object is created with a caller activity and a callee activity and flag activity new task is set to the intent object.
because taskaffinity of targetactivity iscom.facebook.katana andlaunchmode isstandard targetactivity is injected to the task of com.facebook.katana when startactivity is invoked with the intent object.
since the default value of taskaffinity is the package name of the app an activity is not injected to othertask when taskaffinity of the activity is not specified.
among intent flags flags contain activity in their names but only flags listed in intentflag in figure actually manage the activity activation mechanism.
for example if the flag activity no history flag is set the android system does not show the activity on the overview screen and as soon as the user navigates away from it the activityfinishes.
thus the flag does not affect the activity activationmechanism in any ways.
because a caller activity s launchmode also affects activity activation the number of ways to activate activities is of caller activity s launchmode of target activity s launchmode of all combinations of intent flags 0c7 1c7 2c7 3c7 4c7 5c7 6c7 7c7 1024while the activity activation mechanism behaves differentlyfor all kinds of launchmode for target activities it behaves differently for only cases for caller activities whether acaller activity s launchmode issingleinstance or not.
if a caller activity s launchmode issingleinstance the activity activation mechanism behaves as if the intent flags of thetarget activity contain flag activity new task .
for example if a caller activity s launchmode is not singleinstance the flag activity multiple task intent flag is ignored if one of flag activity new task orflag activity new document is not also set .
however if a caller activity s launchmode issingleinstance flag activity multiple task is not ignored even when flag activity new task is not also set.
the android document just describes that singleinstance does not allow other activities to be in the same task.
among ways to activate activities we can remove infeasible or redundant ones by considering dependenciesbetween launchmode and intent flags.
some flags should be used together some flags implicitly imply other flags and some flags should not be used with other flags or some launchmode .
when conflicting flags are used together android selects one of them and ignores the others.
when flagsare used without other required flags android ignores them.figure shows all dependencies between launchmode attributes of target activities and intent flags.
circle nodesdenote launchmode and box nodes denote intent flags.
three types of edges denote dependencies between nodes solidmust edges denote that the property of the from node should be used with the property of the tonode dashed imply edges denote that the from node implies the to node and dotted ignore edges denote that the to node is ignored when it is used with the from node.
because each activity can have only one launchmode no dependency exists between launchmode attributes.
we built the dependency graph via thorough analysis of the android documentation and ourown tests with android devices.
using the dependency graph we removed out of leaving only combinationsto consider.
our manual inspection showed that among ways can inject activities to other tasks if a target activity s taskaffinity does not refer to the caller activity s task.
b. semantics to provide a formal ground to understand the semantics of various activity activation possibilities we specify its opera tional semantics.
figure defines domains stacks and repre sentative commands to describe the operational semantics.
wewriteafor an activity class and afor an activity instance.
a tasktis a pair of its name and its back stack s .
a back authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
standardsingletop flag activity single topsingletask flag activity clear top flag activity multiple task flag activity new task flag activity reoreder to frontsingleinstanceflag activity clear task flag activity task on home fig.
.
dependencies between launchmode attributes of target activities and intent flags gettaskwact a a new a s gettask s removetasktp s removetaskts s t s a singletask a l .startactivity a singletask s t t fig.
.
activity injection semantics used in the sample malware fig.
.
task stack showing that a malicious activity is injected in the task of the legitimate facebook app.
stack is a sequence of activities an activity is a pair of its activity instance and its launch mode a l .
the task stack and task pool are sequences of tasks.
to represent the activity activation concisely we focus on three commands pressing the home button pressing the back button and startingan activity.
the a l .
startactivity a l s f command denotes that the caller activity is a l the target activity is a with the launchmode attributel and the task name sfrom itstaskaffinity and the intent flags are f. the judgments are of the form c which denotes that when the current task pool is and the current task stack is evaluation of the command cresults in the new task pool and the new task stack .
thus homebutton epsilon1 specifies that whenever a user presses the home button the task pool remains the same butthe task stack becomes empty.
all the behaviors of pressingthe back button are epsilon1 backbutton epsilon1 a l epsilon1 removetasktp s s backbutton a l epsilon1 removetasktp s s backbutton s s the first specifies that if a user presses the back button whenthe task stack is empty the display remains the same withoutany changes in the task pool or in the task stack.
the seconddescribes that when the top task on the task stack has only one activity the back button removes the task from both thetask pool and the task stack.
the third describes that when the top task on the task stack has more than one activities theback button removes the top activity from the task both in the task pool and the task stack.
figure in appendix describes all the helper functions.
for the last command the semanticshas rules.
we can split them into cases depending onthe target activity s launchmode .
figure shows one case when the target activity s launchmode issingletask .
due to the space limitation we describe the remaining rules and helper functions in a companion report .
c. implementation of malware activity injection attacks can steal users private data like phishing attacks.
since launching benign apps can run malicious activities it is difficult for users to notice maliciousactivities.
for example if a malware disguises an activity asa login page of a benign app and injects it to the app it cansteal users id and password information.
to demonstrate suchattacks we developed a malware targeting the facebook app.among rules for the startactivity function call in our operational semantics rules specify possible activityinjection attacks.
while we can make malicious apps utilizing any of such rules we developed a malware using the semanticsdescribed by the rule in figure to show its practicality.
figure shows a snapshot of the task stack when we first run the legitimate facebook app execute our malware and let the malware inject a malicious activity in the task offacebook.
the task stack contains two tasks for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
intent data activity injection detector intent analyzer callgraph activity info.
extractor cha callgraph builder activity info.apk injection report fig.
.
overall structure of the static analysis tool f flag activity single top flag activity newtask gettask s a prime new a t newtask s a prime standard angbracketleft angbracketright turnstileleft a l .startactivity a standard s f angbracketleftt t angbracketright f flag activity single top flag activity newtask s gettask s a prime l prime prime instanceof a prime a a prime prime new a prime prime a prime prime standard prime removetaskts s prime removetaskbs s angbracketleft angbracketright turnstileleft a l .startactivity a standard s f angbracketleft s prime prime prime s prime prime prime angbracketright f flag activity single top flag activity newtask s gettask s a prime l prime primeinstanceof a prime a prime removetaskts s prime removetaskbs s angbracketleft angbracketright turnstileleft a l .startactivity a standard s f angbracketleft s prime s prime angbracketright activity info.
intent data com.example.aactivity taskaffinity com.fac.. launchmode standard com.example.bactivity ...com.example.aactivity flag activity new taskflag activity single top com.example.aactivity ... activity activation data com.example.aactivity taskaffinity com.facebook.katanalaunchmode standardintentflags flag activity new task intentflags flag activity single top com.example.aactivity ... fig.
.
example for activity injection detector mechanism facebook com.facebook.katana and for the malware com.example.malicious .
the task of facebook contains two activities for launching a login activity of the facebook app com.facebook.katana .facebookloginactivity and for the malicious activity injected by the malware com.example.malicious .maliciousactivity .
our malware injects the malicious activity when the screen is off because it will be displayed on the screen when the injection occurs.
once the malicious activity is injected intothe facebook task it immediately calls the home activity sothat the screen shows the home screen when the screen isturned on again.
because the malicious activity is the topactivity of the facebook task it will be displayed when a usertouches the facebook icon .
in order to launch the activity injection attack we assume that our malware is installed ona victim s mobile device similarly for .
note that injecting a malicious activity does not requireany permission our malware requires only the internetpermission to send users private data to the attacker s server.
the root cause of this threat is that the android system supports the activity injection feature without any protection policy against malicious apps.
one of the possible mitigations is a system level access control that prohibits apps from inject ing activities into other target apps task without authorizationsof the targets.
we are discussing this issue with the androidsecurity team.
.
a ctivity injection detector based on the formal semantics of activity activation we developed a static analyzer that detects possible activity in jection attacks in android apps.
we implemented it on top ofw ala an open source static analysis framework.
theprototype implementation of the tool is publicly available .
the overall structure of the tool is illustrated in figure .
from a given android apk archive activity info.
extractor builds information about the activities in the app it disas sembles the resource files of the app using apktool andextracts launchmode andtaskaffinity of the activities from the androidmanifest.xml file.
also cha callgraph builder takes the apk and constructs its call graph via class hierarchy analysis cha which is often less precisethan pointer analysis but much faster since it analyzes onlytypes rather than values.
then intent analyzer extracts intent data that activate activities from the call graph.
the intent data contain the target activity names of the intent and the set of intent flags added to the intent.
finally activity injection detector takes the activity information with intent data and produces a report of possible activity injections.
using theactivity information intent data and the activity activationsemantics it analyzes possible activity injection cases.
similar to flowdroid intent analyzer tracks intent data flows via a forward analysis from intent object creation sitesto the startactivity method and detects object aliases via a backward analysis from the locations where intent data are authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
total apps possible to inject impossible to inject analysis in time analysis timeout injection detected injection not detected a analysis results in terms of apps total injections no duplicates duplicates inter flow intent intra flow intent true positives false positives b analysis results in terms of injections fig.
.
analysis results of android apps set to object fields.
while android supports both explicit and implicit intents where the former uses concrete target activities to activate and the latter uses string values to denote target activities our tool analyzes only explicit intents.
becauseanalyzing the targets of implicit intents requires a precisestring analysis the tool does not consider implicit intents.similarly the tool does not analyze flows involving built in method calls and static fields.
even though the prototypeimplementation of the tool does not address such features thatare not the main interests of this paper we believe that we can easily integrate other analyzers that can analyze them.
in addition the tool covers about a half of the activity injection rules in the operational semantics.
while one can inject a target activity without the flag activity new task flag if a caller activity s launchmode issingleinstance because singleinstance is not applicable to most applications the tool does not consider launchmode of caller activities.
figure illustrates how activity injection detector works.
it takes two inputs activity info.
with taskaffinity and launchmode for each activity and intent data with intent flags for each activity activation.
because an activity may be acti vated multiple times intent data in the figure contains multiple entries for com.example.aactivity .
it merges two inputs into activity activation data and matches each entry with the operational semantics rules.
for example because the first entry specifies that launchmode of a target activity is standard and the intent flags are flag activity new task and flag activity single top one of three rules on the right side may be applicable.
note that no matter which rule is ap plied the target activity a always exists in the task pointed by taskaffinity at the activity activation time.
thus the tool detects com.example.aactivity as an injected activity.
v. e v alua tion in this section we evaluate our tool using android apps collected from androzoo with timeout of minutes.
we performed all the experiments on a linux x64 machinewith .0ghz intel core i7 cpu and 8gb memory.
a. experiment results the overall results of our experiments are shown in figure .
as figure a presents we first identified apps that may be open to activity injection.
when an app has anactivity which contains taskaffinity that is different from the package name of the app it is open to activity injection.
otherwise it is not possible to inject activities to such apps.out of android apps apps only about .
of number of apps analysis time sec.
timeout13047 fig.
.
analysis time of android apps the total apps are open to activity injection.
among apps our tool could finish analysis of .
it did notfinish analysis of only apps in minutes.
finally thetool detected activity injection cases from apps whichamounts to about .
of the total apps.
from apps the tool detected possible activity injection cases.
as figure b presents among injec tion cases only cases are unique and the remaining 602cases are duplicated ones.
we identified injection cases usingtheir activity names.
for example when the tool reports that com.example.aactivity is injected multiple times to a single app or multiple apps we count it as one injection case.
toevaluate the precision of the tool we partitioned uniqueinjection cases into the ones with relatively complex data flowsand the others.
more specifically we identified such cases thatrequire inter procedural data flows to detect the injection cases as complex data flows which amounts to injection cases.
we manually investigated them and found that only two casesare false positives and the remaining cases are all truepositives.
thus the false positive rate of the tool is only .
.
the tool reported a very low false positive rate even though its cha based call graph construction produces imprecise callgraphs in general thanks to simple usage patterns of intents.usually intent objects use only simple data flows as shown bythe number of intra procedural data flows in figure b .
ourmanual inspection revealed that most inter procedural intentdata flows are through static methods that do not affect theimprecision of graph construction.
while cha based analysesare generally imprecise for code patterns with complex classinheritance relations most apps do not use complex classhierarchy for activity activation.
thus the simple call graphconstruction did not harm the precision of our tool much.
figure summarizes the analysis time of apps.
the tool can identify the apps not open to activity injection in or2 seconds.
the x axis denotes analysis time and the y axisdenotes the number of apps.
the tool analyzed apps authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii activities injected from multiple apps activity name of apps com startapp android publish appwallactivity com startapp android publish list3d list3dactivity com cmcm picks picksloadingactivity com widdit lockscreen activities termsandconditionsactivity com applift playads playadsactivity com zdworks android zdclock ui alarm alarmactivity org chromium backgroundactivity com igexin getuiext activity getuiextactivity ccc71 at activities at ui progress com csipsimple ui incall incallmediacontrol org saturn stark interstitial comb activity nativeadactivity com tencent mm ui transmit taskredirectui about .
of apps in seconds and the average analysis time is seconds except for timeout apps.
the overallanalysis time shows that our tool detects possible activityinjection attacks in a large number of real world android apps.
we measured the unsoundness effects of our restrictions in analysis of the target apps.
as we discussed in section iv weintentionally ignored analysis of data flows via static fields and built in methods and launchmode of caller activities for the analysis performance.
we investigated how many apps have such features and found that the tool may miss activityinjection cases in apps about .
of apps.
b. case studies we discuss three representative cases of activity injection.
activities injected from multiple apps we observed that some activities are included in multiple apps and injected to another task.
we summarize the activities injected from five or more apps in table ii.among them five activities are for mobile advertisingplatforms appwallactivity and list3dactivity are for startapp picksloadingactivity is for appodeal playadsactivity is for applift and getuiextactivity is for igexin .
mobile advertising platforms use different tasks from their integrated apps so that they can logically separate their advertisement activities fromthe apps activities.
two activities are from app developmentframeworks backgroundactivity is from cordova andtaskredirectui is from tencent .
both frameworks are widely used for android app development.
three activities are included in libraries termsandconditionsactivity is in homebase which supports personalized lock screen of mobile phone at ui progress is in 3c toolbox which supports other apps paid functionalities for free and incallmediacontrol is in csipsimple which is an open source session initiation protocol software.
we foundthat alarmactivity is injected from apps but all the apps have the same package name.
because google play doesnot allow duplicated package names we believe that they arethe same app possibly crawled from different app stores byandrozoo.
finally we failed to find any information about nativeadactivity although the activity name implies a mobile advertising platform.
suspicious activity injection cases to understand the reported activity injection cases in more detail we collected suspicious cases where taskaffinity of the activities are the names of existing applications packages libraries or their subdomains.
out of unique injection cases we collected12 such cases.
the collected cases are highly suspicious butthe other cases may be malicious as well.
we summarize the cases in table iii.
among targets umeng is a mobile advertising platform library andthe others are applications.
for example we found thatthe app com netngroup point has an activity injection to the task com umeng community of the library umeng.
interestingly two cases inject activities into android built inapps tasks com tencent android qqdownloader injects an activity into the task of the android package installer and com lookout injects an activity into the task of google chrome the default browser of android.
thus when userslaunch such built in apps they may use injected activitiesinstead of the built in apps activities.
because the built inapps are installed on every android device and they are highlysensitive to the device security such injected activities mayopen the gate to security threats.
a redundant usage of launchmode and intent flags in some injection cases an intent object has a redundantintent flag for activity activation flag activity new task is unnecessary when launchmode of a target activity is singletask because the target activity is always injected into a task pointed by the taskaffinity .
however we observed that out of activity injection cases haveboth launchmode and the flag.
since the activity activation mechanism is complex and difficult to understand from theandroid document redundant or misused intent flags may be discovered in various real world android apps.
we believe that our formal semantics would be helpful for developers tounderstand the activity activation mechanism clearly.
vi.
r ela ted work recently various attacks for android apps have been reported.
they leverage vulnerabilities in inter and intra app communication content providers permissionsystems push message services oauth hybridweb app frameworks dynamic code loading android public resources vendor customization the webview api and advertisement libraries .
among various android security issues we focus on the android ui security which has been extensively studied.leveraging the adb daemon third party apps can steal users private data by stealthily taking screen shots .
chenet al.
reported the ui state inference attack which exploits the public side channel to demonstrate activity hijack ing attacks.
roesner and kohno demonstrated securityproblems of embedded user interfaces in android.
niemietz and schwenk reported the ui redressing attack which leverages special characteristics of the toast view.
kraunelis et al.
reported the masquerade attack using the accessibility framework in android.
luo et al.
showed launching authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii suspicious injection cases names of their target apps or libraries and their target tasks app with activity injection target app or library target task com dianxinos dxhome 91pandahome2 com nd android pandahome2 manage shop themeshopmainactivity com tencent android qqdownloader android package installer com android packageinstaller com duapps antivirus caller id recorder com whosthat aftercall tips com jushine chouse days money book com bora chouse imageviewactivity cn opda a phonoalbumshoushou du speed booster cleaner com dianxinos optimizer task sevenkey com jiubang goscreenlock go launcher com gau go launcherex com lookout google chrome com android chrome com j3gha mailclient k mail com fsck k9 activity setup prefs com emoji input gif theme keyboard pip launcher cm theme wallpaper launcher locksceen com csms activities power assistant .
.
com zhimahu null com netngroup point umeng com umeng community com goldbean yoyo wechat com tencent mm touchjacking attacks using the webview api.
felt and wagner analyzed phishing attacks on mobile devices.
the most closely related work to ours is taskhijacking attacks which lead users into malicious activities sharing benign apps tasks.
taskhijacking attacks include all the cases where multiple apps share a task many of which are normalinter app communication but we focus on activity injectionattacks where apps inject an activity into another app s task.also our work significantly improved the previous work inthat we specified all the semantic behaviors formally and exhaustively without any restrictions that the previous workmade to build transition diagrams via testing and we detected possible activity injection attacks in real world android apps.
researchers have tried to analyze android apps that utilize inter component communication icc .
scandroid isone of the first static analyzers for android apps.
basedon a formal constraints system for a core icc language scandroid collects constraints for each component and solvesthe collected constraints altogether considering all the callerand callee relations to analyze data flows between compo nents.
comdroid can detect seven kinds of potentialvulnerabilities in android icc and it specifically focuses onimplicit intents.
smartdroid uses both a static analysis and a dynamic analysis.
during static analysis it analyzes intent data flows to construct activity call graphs acgs that present caller and callee activities.
using the graph itautomatically triggers ui events of each activity to detectsensitive behaviors executed by ui interactions.
epicc reduces icc to an instance of the inter procedural distributive environment ide problem and it detects icc vulnerabilitiesvia solving the ide problem with lower false positive ratesthan smartdroid.
apposcopy performs taint analysis oninter component call graph iccg using intent informationto detect privacy leakage in android app.
amandroid constructs inter component data flow graph idfg via a pointer analysis and models various android apis to extractintent information and to link data flows between compo nents.
droidsafe reports sensitive information leakagesin android apps.
it computes the values of intent objects via astring analysis finds the target components of the intent object values and replaces the inter component calls with explicitcall instructions to the target components.
ic3 constructsinter procedural data dependence graph ddg and tracksdata flows on ddgs to collect intent information.
based onic3 iccta instruments android apps bytecode to replace inter component calls with explicit call instructions and trackstaint data to detect sensitive data leakages.
the main difference between the above approaches and ours is the analysis purpose.
while the existing approaches focus onanalysis of control and data flows between components we fo cus on efficient analysis of the activity activation mechanism.unlike other approaches we specified a formal semanticsfor the activity activation mechanism and our tool considers launchmode intent flags and the semantics to detect activity injection attacks that no other tools could detect.
vii.
c onclusion the android multitasking features are extremely powerful and useful but at the same time they are vulnerable toactivity injection attacks.
because there are hundreds waysto launch activities it is very difficult for developers tounderstand the activity activation behaviors clearly.
moreimportantly the complex behaviors contain various ways toinject malicious activities to legitimate apps.
to alleviate theproblem we formally specify the activity activation semanticsexhaustively identify possible places for activity injectionattacks and implement a sample malware to show that theactivity injection attacks are realistic and dangerous.
basedon the formal semantics of activity activation we developed astatic analyzer to detect activity injection attacks in androidapps.
the tool is fast enough to analyze real world androidapps in seconds on average and it is precise enough tohave only .
false positive rate.
our experiments showedthat out of android apps inject their activitiesinto other apps tasks and our manual investigation revealedthat apps inject their activities into the tasks of androidapps including built in apps tasks.
we believe that the formalsemantics of the activity activation mechanism would helpdevelopers to understand the complex mechanism clearly andthe tool would be useful in detecting activity injection attacksin a large number of android apps efficiently.
a cknowledgment this work received funding from national research foundation of korea nrf grant nrf 2017r1a2b3012020 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
helper function type description new activityclass activityinstance returns an instance of a given activity class newtask string activityinstance launchmode task creates a new task with a given task name activity instance and its launch mode removetasktp taskpool task taskpool removes a given task from a given task pool removetaskts taskstack task taskstack removes a given task from a given task stack removeactsuntil backstack activityinstance launchmode removes activity instances on top of and including backstack a given activity instance from a given back stack gettask taskpool string task returns for absence or a task with a given name from a given task pool getactivity backstack activityclass activityinstance returns for absence or an instance of a given activity class from a given back stack gettaskwact taskpool activityclass task returns for absence or a task that contains an instance of a given activity class from a given task pool target activity s launchmode issingletask gettaskwact a a new a gettask s t newtask s a singletask a l .startactivity a singletask s t t gettaskwact a a new a s gettask s removetasktp s removetaskts s t s a singletask a l .startactivity a singletask s t t s gettaskwact a removetasktp s removetaskts s a getactivity a removeactsuntil a singletask t s a singletask a l .startactivity a singletask s t t f flag activity clear task gettaskwact a a new a gettask s t newtask s a singletask a l .startactivity a singletask s f t t f flag activity clear task gettaskwact a a new a t gettask s removetasktp t removetaskts t t newtask s a singletask a l .startactivity a singletask s f t t f flag activity clear task t gettaskwact a removetasktp t removetaskts t a new a t newtask s a singletask a l .startactivity a singletask s f t t f flag activity task on home a l .startactivity a singletask s t a l .startactivity a singletask s f t epsilon1 f flag activity clear task flag activity task on home f flag activity clear task a l .startactivity a singletask s f t a l .startactivity a singletask s f t epsilon1 fig.
.
operational semantics for starting an activity when the target activity s launchmode issingletask .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.