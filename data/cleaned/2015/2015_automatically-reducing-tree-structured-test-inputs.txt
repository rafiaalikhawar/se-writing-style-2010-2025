automatically reducing tree structured test inputs satia herfert department of computer science tu darmstadt germany satiaherfert gmx.dejibesh patra department of computer science tu darmstadt germany jibesh.patra gmail.commichael pradel department of computer science tu darmstadt germany michael binaervarianz.de abstract reducing the test input given to a program while preserving some property of interest is important e.g.
to localize faults or to reduce test suites.
the well known delta debugging algorithm and its derivatives automate this task by repeatedly reducing a given input.
unfortunately these approaches are limited to blindly removing parts of the input and cannot reduce the input by restructuring it.
this paper presents the generalized tree reduction gtr algorithm an effective and efficient technique to reduce arbitrary test inputs that can be represented as a tree such as program code pdf files and xml documents.
the algorithm combines tree transformations with delta debugging and a greedy backtracking algorithm.
to reduce the size of the considered search space the approach automatically specializes the tree transformations applied by the algorithm based on examples of input trees.
we evaluate gtr by reducing python files that cause interpreter crashes javascript files that cause browser inconsistencies pdf documents with malicious content and xml files used to tests an xml validator.
the gtr algorithm reduces the trees of these files to .
.
.
and .
of the original size respectively outperforming both delta debugging and another state of the art algorithm.
i. i ntroduction developers often have a test input that triggers behavior of interest such as inducing a failure in a buggy program or covering particular parts of a program under test.
however the input may be larger than needed to preserve the property of interest.
for example consider a program that crashes the compiler or interpreter when given as an input.
the larger this input program is the more difficult it is to localize the fault making the debugging process unnecessarily cumbersome .
to ease the task of dealing with such overly complex test inputs several automated techniques have been proposed.
given a test input and an oracle that determines whether a reduced version of the input still preserves the property of interest these techniques automatically reduce the input.
with a reduced test input the developer is likely to find the root cause of the bug faster and may even turn the reduced test input into a regression test case after the bug has been fixed.
similar reducing test inputs while preserving some testing goal such as coverage can help to reduce a test suite.
existing techniques for reducing inputs roughly fall into two categories.
on the one hand delta debugging and its derivatives reduce inputs in a language independent way by repeatedly removing parts of the input until no further this work has been supported by the dfg within concsys and by the bmbf and the hmwk within crisp.reduction is possible.
while being simple and elegant these approaches disregard the language of the input and therefore miss opportunities for input reduction.
in particular these techniques cannot restructure inputs which often enables further reductions.
as an example consider the following javascript code and suppose that it triggers a bug e.g.
by crashing the underlying javascript engine.
1for vari i i 2if cond1 cond2 3pa rtofbug 5if cond3 6ot herpartofbug further suppose that the two function calls are sufficient to trigger the bug.
that is the following code is sufficient as a test input to enable a developer to reproduce and localize the bug 1partofbug 2otherpartofbug unfortunately existing language independent techniques are challenged by this example.
the original delta debugging algorithm blindly removes parts of the program which is likely to lead to a syntactically invalid program or to a local minimum that is larger than the fully reduced example.
hierarchical delta debugging a variant of delta debugging that considers the tree structure of the input fails to find the reduced input because it can remove only entire subtrees but it cannot restructure the input.
on the other hand some techniques exploit domain knowledge about the language of the test input.
while being potentially more effective hard coding language knowledge into the approach limits it to a single kind of test input.
this paper presents the generalized tree reduction algorithm gtr a language independent technique to reduce arbitrary tree structured test inputs.
the approach is enabled by two key observations.
first we observe that transformations beyond removing entire parts of the input are beneficial in reducing inputs.
gtr exploits this observation by incorporating tree transformations into the reduction process.
the challenge is how to know which transformations to apply without hard coding knowledge about a particular language.
addressing this challenge improves the effectiveness of test input reduction.
second we observe that for most relevant input formats there are various examples that implicitly encode .
c ieeease urbana champaign il usa technical research861 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
information about the language.
for example there are various programs in public code repositories millions of html files and many publicly available xml documents.
gtr exploits this situation to improve the efficiency of input reduction by automatically pruning the search space of transformations for a particular language after learning from a corpus of example data.
our work focuses on inputs that can be represented as a tree.
this focus is motivated by the fact that the inputs of many programs have an inherent tree structure e.g.
xml documents or can be easily converted into a tree e.g.
the abstract syntax tree of source code.
the input to gtr is a tree with a desirable property such as triggering a bug and an oracle that determines whether a reduced version of the tree still has the desirable property.
the algorithm reduces the tree level by level i.e.
it considers all nodes of a level to minimize the whole tree before continuing with the next level.
the output of the algorithm is a reduced tree that has the desirable property according to the oracle.
at the core of our approach are tree transformations that modify a tree into a new tree with fewer nodes.
we describe two transformation templates that we find to be particularly effective.
the first template removes a node and all its children drastically shrinking the tree s size.
as deleting nodes alone is insufficient for various inputs the second template replaces a node with one of its children i.e.
it pulls up a subtree to the next level of the tree.
while we find these two transformation templates to be effective the algorithm is easily extensible with additional templates.
in principle these transformation templates are applicable to arbitrary kinds of nodes in the tree.
to reduce the size of the search space considered by gtr i.e.
ultimately the time required to reduce an input we specialize the transformation patterns to a specific input language by learning from a corpus of example data.
since the learning is fully automatic the approach remains language independent.
to evaluate gtr we apply the algorithm to a total of inputs in the form of python programs javascript programs pdf documents and xml documents.
the python programs each trigger a bug in the python interpreter while the javascript programs cause inconsistencies between browsers.
the pdf documents contain malicious content.
the xml documents achieve a certain coverage when given to an xml validator and that coverage should be preserved during the reduction.
we find that gtr reduces the inputs to .
.
.
and .
of the original size respectively.
compared to the best existing approach gtr consistently improves efficiency and also significantly improves the effectiveness of reduction in three of four experiments.
to summarize we make the following contributions we identify the lack of restructuring as a crucial limitation of existing language independent input reduction techniques.
we present a novel tree reduction algorithm that transforms trees based on tree transformation templates.
if a set of example inputs is available the approachautomatically specializes the templates to the language of the input.
we show the presented algorithm to be significantly more effective and efficient than two state of the art techniques.
we make our implementation available to the public.
ii.
b ackground a. delta debugging zeller and hildebrandt proposed delta debugging dd a greedy algorithm for isolating failure inducing inputs.
in a nutshell dd splits the input in chunks of decreasing sizes trying to remove some chunks while maintaining a property of the input.
chunk can refer e.g.
to individual characters or lines of a document.
often but not necessarily the property is that the input induces a bug when fed to a program.
dd does not guarantee to find the smallest possible input but instead ensures minimality.
this property guarantees that no single part of the input can be removed without loosing the property of interest.
for example when applying line based delta debugging to reduce a program that triggers a compiler bug minimality means that removing any line of the input will cause the input to not trigger the bug anymore.
dd has an important disadvantage for structured input because it disregards the structure of the input when splitting it into chunks.
as a result dd may generate various invalid inputs and invoke the oracle unnecessarily.
for instance when applying dd to the example from the introduction the algorithm may delete a closing bracket without removing its counterpart generating a syntactically invalid program.
since each candidate input is given to the oracle such invalid inputs increase the execution time of the algorithm.
b. hierarchical delta debugging hierarchical delta debugging hdd addresses the limitation that dd disregards the structure of the input.
the algorithm considers the input to be a tree which is a natural way to interpret various inputs e.g.
code represented as an abstract syntax tree ast .
hdd starts from the root of the tree and visits each level.
at every level the algorithm applies the original dd algorithm to all nodes at this level to find the smallest set of nodes necessary.
the algorithm terminates after running dd on the last level of the tree.
hdd often purges large parts of the input early leading to more reduction than dd while also requiring fewer oracle invocations.
in contrast to dd hdd does not provide minimality.
to guarantee this property hdd repeatedly uses hdd until no more changes to the tree are performed .
a limitation of hdd is that it only removed nodes and all their children but it does not use any other tree transformations.
therefore for an input where the important part is deeply nested in the input tree hdd produces far fromminimal results.
an example is the code excerpt provided in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ifstmt unaryexpr !
ident cblockstmt vardecls vardecl ident lit a 5blockstmt exprstmt callexpr ident lit isnan 2test cons alt operator argument namebody declarations id init name valuebody expression callee arguments name value 1if !c 2vara root cause of failure else 4is nan fig.
.
an abstract syntax tree and code for our running example.
the introduction.
here hdd attempts to remove the entire if branches which yields a program that does not trigger the bug anymore.
the algorithm yields the following code as the reduced input 1for 2if cond1 cond2 3pa rtofbug 5if cond3 6ot herpartofbug iii.
p roblem statement previous approaches for reducing failure inducing inputs miss opportunities for reduction because they ignore the structure of the input and because they are limited to removing parts of the input.
motivated by these limitations we aim for an algorithm that exploits the structure of the inputs and that finds near minimal results even when the root cause of a failure is deeply nested inside the input.
our work focuses on inputs that can be represented as a tree.
definition .
alabeled ordered tree is a recursive data structure l c wherelis a textual label and cis the possibly empty ordered list of outgoing edges.
an edge e cis a tuple l t wherelis a textual label for the edge and tis the child node which itself is a labeled ordered tree.
we use tto refer to the set of all trees.
figure shows an example a small piece of javascript code that triggers a bug e.g.
in a javascript engine.
suppose that the bug is triggered by the statement at line .
the example input can be represented as a tree in this case the ast.
we will refer to a labeled ordered tree hereafter simply as a tree or node depending on the context.
trees have several properties.
the sizeof a tree is the number of its nodes size t n. the tree in figure has a size of .
the context of a tree is a partial function that returns the label of the parentnode and the label of the incoming edge context t string string .
the context of the root node is undefined.
for the example the context of the unaryexpr node on the left side of our tree is ifstmt test .
the level of a node in a tree is the edge distance from the node to the tree s root node.
all nodes of a particular level in a tree can be obtained by a function level t n p t wherep t denotes the power set of t. the depth of a tree is defined as the maximum distance of a leaf node to the root depth t n. the example tree has a depth of .
finally we say that a treet is derived from another tree t written derived t t if one can build t fromtby deleting nodes and edges or by moving nodes and edges within the tree without changing a single label.
definition .
anoracle o is a function that given a tree decides whether the tree provides a desired property o t bool .
we use oto denote the set of all oracles.
a treet isminimal w.r.t.
an oracle oand a source tree tift satisfies the oracle and if there is no smaller derived tree that also satisfies the oracle.
formally t is minimal if derived t t o t true parenleftbig t ne ationslash t derived t t o t true size t size t parenrightbig .
definition .
atree reduction algorithm is a function a t o t that given a tree tand an oracle owhere o t true returns another tree t for which o t true andsize t lessorequalslantsize t .
the algorithm tries to find a smaller tree that still provides a property of interest as decided by the oracle.
if a reduction algorithm cannot further reduce a tree it will return the same tree.
the goal of this work is to provide a tree reduction algorithm that returns near minimal trees with respect to the given oracle while maintaining the number of oracle invocations low.
a small number of oracle invocations is important as they can be costly operations such as running a compiler that significantly increase the overall runtime of the algorithm.
in general finding the minimal tree is impractical because the number of trees to check with the oracle grows exponentially with the size of the input tree.
iv.
t hegeneralized tree reduction algorithm this section introduces a novel tree reduction algorithm called generalized tree reduction or gtr.
figure shows the components of the approach and how they interact with each other.
given an input tree step the algorithm traverses the tree from top to bottom while applying transformations to reduce the tree.
for example a transformation may remove an entire subtree or restructure the nodes of the tree.
the transformations are based on tree transformation templates step that specify a set of candidate transformations step .
to specialize a generic template to a particular input format the approach optionally filters these candidates based on knowledge inferred from a corpus of example inputs step .
the algorithm applies the transformations and queries the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
input tree gtr oracletransformation templatescorpus based filtering output tree12 node3 candidates 4filtered candidates test tree pass fail7 fig.
.
overview of the gtr approach.
oracle to check whether a reduced tree preserves the property of interest e.g.
whether it still triggers a particular bug steps and .
the algorithm repeatedly reduces the tree until no more tree reductions are found.
finally gtr returns the reduced tree step .
we call the gtr algorithm generalized because it can express different tree reduction algorithms depending on the provided tree transformation templates.
for example by providing a single template that reduces entire subtrees gtr is equivalent to the existing hdd algorithm section iv e .
before delving into the details of gtr we illustrate its main ideas using the running example in figure .
given the tree representation of the input the algorithm analyzes the tree level by level starting at the root node.
for example the algorithm considers a transformation that removes the root node ifstmt and all its children but discards this transformation because the reduced tree an empty program does not trigger the bug anymore.
as another example the algorithm considers transformations that replace the root node with one of its children.
replacing the root node with the blockstmt that represents the then branch yields a smaller tree that still triggers the bug.
therefore the algorithm applies this transformation and continues to further reduce the remaining tree.
eventually the algorithm reaches a tree that represents only the statement var a which cannot be reduced without destroying the property of interest.
the remainder of this section explains the gtr algorithm in detail.
at first we present the tree transformations applied by the algorithm sections iv a and iv b .
then we describe how gtr combines different transformations into an effective tree reduction algorithm section iv c .
a. tree transformation templates the core ingredient of gtr are transformations that reduce the size of a tree.
we specify such transformations with templates definition .
atransformation template is a function t p t del that returns a set of candidate trees that are the result of transforming a given input tree.
in addition to candidate trees the template may return the special symbol del which indicates that the tree should be removed rather than modified.algorithm substitute by child template input a treetr ee output a set of candidates nodes function sbc template tr ee candidates fori do c tree.c .t candidates candidates c returncandidates in this paper we focus on two transformation templates which yield a tree reduction algorithm that is more effective than the best existing algorithms.
a deletion template the first template addresses situations where an entire subtree of the input given to gtr is irrelevant for the property of interest.
in our running example figure the subtree rooted at the right most blockstmt node is such a subtree.
to enable gtr to remove such subtrees the deletion template simply suggests for each given tree to delete it by returning the special del symbol.
b substitute by child template the second template addresses situations where simply removing an entire subtree is undesirable because the subtree contains nodes relevant for the property of interest.
we observe that a common pattern is that the root node of a subtree is irrelevant but one of its children is important for the property of interest.
in the running example the tree rooted at the ifstmt matches this pattern because the if statement is irrelevant but the nested variable declaration is crucial.
to address this pattern the substituteby child template algorithm returns each child of a given tree s root node as a candidate for replacing the given tree.
the template iterates over all children of the given tree and adds each of them to the set of candidates.
applying this transformation template to the ifstmt of the running example yields a set of three candidates namely the three subtrees rooted at nodes unaryexpr blockstmt and blockstmt.
beyond these two templates additional templates can be easily integrated into gtr enabling the approach to express different tree reduction algorithms.
b. corpus based filtering the templates defined above are completely language independent.
when applying these templates to a tree that ought to conform to a specific input format many of the candidates may be rejected by the oracle simply because they violate the input format.
for example when the deletion template suggests to remove the unaryexpr from the tree in figure the resulting tree corresponds to syntactically invalid javascript code because every if statement requires a condition.
suggesting such invalid candidates does not influence the effectiveness of our approach because the oracle rejects all invalid candidates.
however a high number of invalid candidates negatively influences the efficiency of the approach since invoking the oracle often imposes a significant runtime cost.
to address the challenge of invalid candidates we enhance the approach with a language specific filtering of candidates trees that rejects invalid trees before invoking the oracle.
to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
preserve the language independence of gtr the filtering is based on knowledge that gets automatically inferred from a corpus of example inputs in the specific input format.
for example the approach learns from a set of javascript programs that if statements require a condition and therefore will filter any candidates that violate this requirement.
a deletion template to specialize the deletion template to a particular language we need to know which edges are mandatory for particular node types.
the approach analyzes the code corpus to find a set of mandatory edge labels for each node label.
an edge is considered mandatory if it appears on all nodes with the label across the whole corpus.
based on the mandatory edges we modify the deletion template so that a node only can be deleted if it is not a mandatory child of its parent node.
for the running example consider again the candidate that suggests to remove from the ifstmt theunaryexpr subtree.
the corpus analysis finds that the set of mandatory edges for anifstmt is test cons .
based on this inferred knowledge the algorithm will not attempt to delete the unaryexpr anymore but discards this candidate before needlessly passing the tree to the oracle.
b substitute by child template to specialize the substitute by child template we gather information on the parent node labels and incoming edge labels of nodes.
specifically for each node label we collect a set of pairs p e where pis the label of the parent and eis the label of the incoming edge.
this set of pairs is equivalent to all distinct contexts of nodes with that label and we call it the allowed contexts.
we then replace line of the substitute by child template algorithm with the following steps ifcontext tree allowedcontexts tree.c .l then candidates candidates c the specialized variant of the template checks if the child that we replace the node with can also appear in the same context as the node.
for example the approach infers that there is one valid context for a vardecl node namely vardecls declarations .
since blockstat body is not a valid context the algorithm will immediately discard a candidate that tries to substitute vardecls with vardecl.
inferring from a corpus of examples how to specialize language independent transformation templates to an input format is optional and automatic.
it is automatic because for most input formats used in practice there are sufficiently many examples to learn from.
an alternative approach could be to use a formal grammar of the input language to filter syntactically invalid trees.
we rejected this idea because i a grammar may not be available e.g.
for proprietary formats ii the checks performed by the specialized transformation templates are more lightweight than parsing the entire input tree with a grammar.
our evaluation measures the effectiveness and efficiency of gtr with and without the corpus based filtering of candidate trees section v d .algorithm generalized tree reduction input treet oracle o setlof templates output reduced tree fori do forl l do t apply template t i o l function apply template t i o l levelnodes level t i all nodes of level i iflreturns at most one transformation then newnodes apply dd to replace levelnodes usingl return tree where newnodes replacelevelnodes else return reducelevelnodes t levelnodes o l alg.
c. gtr algorithm based on the transformation templates described above the gtr algorithm reduces a given tree by applying transformations at each level of the tree.
algorithm summarizes the main steps.
starting at the root node the algorithm considers each level of the tree and applies all available transformation templates to each level using a helper function applytemplate lines to .
a delta debugging based search when applying a template to the nodes at a particular level the algorithm distinguishes between templates that return at most one candidate transformation such as the deletion template and other templates.
in the first case the algorithm needs to decide for which nodes to apply the suggested transformations.
this problem can be reduced to delta debugging dd .
the chunks needed as input for dd are the nodes of the level.
dd then tries to combine as many replacements as possible while querying the oracle to check if a replacement preserves the property of interest.
for each node nfor which the transformation template returns a node n dd will try to replace nwith n .
for each node where the symbol del is returned dd will try to delete n. after deciding on the replacements the result is a new list of nodes for the current level.
the helper functionapplytemplate replaces the nodes on the level with the new nodes and returns the resulting tree to the main loop of the algorithm lines and .
b backtracking based search for templates that may return more than one candidate the algorithm must decide not only whether to apply a candidate replacement but also which of the suggested candidate replacements to apply.
this problem cannot be easily mapped to dd because dd assumes to have exactly one option per chunk typically whether to delete it or not .
instead we present a backtracking based algorithm that searches for a replacement of nodes on a particular level that reduces the overall tree.
similar to dd the algorithm is a greedy search.
algorithm summarizes the main steps of the backtrackingbased search for replacements of nodes on a particular level.
the algorithm is called at line of the main gtr algorithm.
the central idea is to try different configurations that specify which replacements to use for each node.
the algorithm starts with a configuration that replaces each node with itself lines authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm backtracking based reduction of level nodes input treet list ofnodes on the same level oracle o template t output reduced tree maps each node to its current replacement conf empty map forn nodes do conf.put n n repeat improvementfound false forn nodes do currentrep conf.get n forn l n wheresize n size currentrep do t twith each nreplaced by n conf.put n n iforacle t then improvementfound true currentrep n else conf.put n currentrep backtrack until improvementfound returnt to .
then the algorithm iterates through all nodes line and tries all configurations where the replacement candidate is smaller than the currently chosen replacement.
that is the algorithm avoids invoking the oracle for replacements that are less effective than an already found replacement.
if the oracle confirms that replacing a node preserves the property of interest an improvement was found w.r.t.
the current replacement lines and .
otherwise the algorithm must revert the replacement and backtracks to the previous configuration line .
the algorithm repeats the search for a replacement of any of the nodes on the current level until no further improvement is found.
the reason for repeatedly considering the list of nodes is that using an effective replacement at a later node may enable using previously impossible replacements at previous nodes which have already been tested in the current iteration.
for example consider the following input where the crash b call ensures the property of interest 1a b 2if a 3cr ash b during the first iteration of the main loop lines to the algorithm cannot reduce the assignments in the first line but reduces the input by substituting the if statement with thecrash b call.
now during the second iteration the algorithm again considers the assignment statement and successfully reduces it to b which yields the following reduced input 1b 2crash b the search for a reduction of the nodes in the current level guarantees to find a local optimum i.e.
a configuration where using any other replacement that yields a smaller subtree would not satisfy the oracle.
as the search is greedy it may miss a configuration that yields a smaller overall tree satisfying the oracle.
searching for a global optimum would require toalgorithm gtr input treet oracle o setlof templates output transformation minimal tree current t repeat previous current current gtr previous o l untilsize previous size current returncurrent explore all possible configurations which is exponential in the number of candidates suggested.
c example we illustrate gtr on the running example.
recall that only line of figure is relevant for reproducing the bug.
the algorithm starts on level which contains only theifstmt and invokes applytemplate with the deletion template.
deletion returns at most one transformation.
therefore the algorithm applies dd to the node on this level and tries to delete it with all its children.
however this deletion would make bug disappear and is discarded by the oracle.
next applytemplate is invoked with the substitute by child template.
since this template may return multiple candidates the algorithm invokes the backtracking based reducelevelnodes function i.e.
algorithm .
there is only one node to consider in line of algorithm and in line three different candidates are tested.
the first is the unaryexpr on the left side.
this candidate has a size of .
but since the important code piece is removed line reverts this change.
the next candidate is the blockstatement in the middle.
it has a size of .
the oracle returns true for this transformation so currentrep is updated in line .
the third candidate is the blockstatement on the right.
since it also has a size of which is not smaller than the size of currentrep the candidate is not tested.
now that an improvement was found the main loop lines to is repeated.
as there is only one node nothing new will be tested.
after having finished both templates on level gtr will advance to level and continue in the same manner.
d. gtr algorithm the existing dd and hdd algorithms guarantee 1minimality and tree minimality respectively.
in essence this property states that given a reduced input there is no single reduction step that can further reduce the input.
we define a similar minimality property for gtr definition .
a treetis called transformation minimal w.r.t.
an oracle oand a set of templates lifo t true n intand l l there is no candidate n inl n that when replacing nwithn yields a tree t witho t true size t size t .
in other words for transformation minimal trees all trees obtained by single replacements of one node of the tree cause the oracle to return false .
the main difference to the existing minimality and tree minimality properties is to consider arbitrary tree transformations.
the gtr algorithm does not guarantee to find a transformation minimal tree.
the reason is that by optimizing a tree authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i inp ut files used for the evaluation .
format inputs bytes lines nodes min med max min med max min med max python jav ascript pdf xml on one level a transformation on a higher level which had been rejected by the oracle before can become possible.
to guarantee transformation minimality we present a variant of gtr the gtr algorithm algorithm .
gtr repeats gtr until the tree does not change its size anymore which indicates that no transformation can be applied thereafter.
e. generalization of hdd and hdd gtr and gtr generalize the existing hdd and hdd algorithms respectively.
to obtain hdd we configure gtr to include only the deletion template without specializing the template to a particular language.
the resulting algorithm applies dd on every level of the input tree by deleting a subset of the nodes on this level.
this behavior is exactly what hdd does i.e.
the reduced tree is the same as returned by hdd.
this generalization also applies to hdd where we simply run gtr with the variant of gtr that is equivalent to hdd.
v. e valuation we evaluate gtr by applying it to four input formats and usage scenarios including reducing fault inducing inputs for debugging reducing malicious inputs for easier security analysis and reducing test inputs for more efficient testing.
the evaluation compares gtr and gtr to the existing dd hdd and hdd algorithms.
we focus on three research questions rq1 how effective is the approach in reducing trees?
rq2 how efficient is the approach?
rq3 what are the effects of specializing transformation templates to an input format?
a. experimental setup input formats and oracles we consider four sets of inputs that comprise a total of input files that can be represented as a tree.
table i summarizes the inputs and shows their size in terms of bytes lines and number of tree nodes.
for the binary pdf format we do not report lines.
a failure inducing python code we use gtr to reduce python files that cause the python interpreter to crash.
to obtain such files we search the python bug tracker for segmentation faults and stack overflows reported along with code to reproduce it.
because these files have been reported by users or developers they are likely to have been manually reduced presenting a non trivial challenge to any input reduction algorithm.
we use a python parser to represent code as trees.
the oracle to check whether a reduced python file preserves the property of interest is to execute the file and to check the status code returned by the python interpreter.
onlychecking the status code bears the risk of misclassification e.g.
if the program is altered to return that status code without triggering the bug.
given the low number of inputs we could exclude this possibility manually for the given inputs.
as a corpus to specialize the transformation templates we gather files from popular measured by number of stars github projects.
b inconsistency exposing javascript code we also use gtr to reduce javascript files that cause inconsistencies between browsers.
the files are generated by treefuzz an existing fuzz testing technique.
we configure treefuzz to generate files and keep all files that trigger a browser inconsistency which results in files.
since these files are automatically generated they generally contain parts that are not required to trigger a browser inconsistency providing a good data set to complement the manually written python files.
we use esprima to transform code to trees.
as the oracle we compare the runtime behavior of a javascript file in firefox and chrome as described in .
this oracle compares read and written values as well as error types and messages.
the javascript corpus for specializing transformation templates comprises around files .
c malicious pdf documents as a usage scenario beyond reducing inputs for debugging we use gtr to reduce malicious pdf files while preserving their maliciousness which facilitates further security analysis.
we download malicious pdf files from the contagio malware dump .
pdf documents are binary data but have an internal tree structure.
using the pdfminer and itextpdf libraries we convert between pdfs and trees.
we filter the pdfs to keep only those that are classified as malicious according to pdf scrutinizer and that are compatible with our tree conversion.
out of the over remaining files we chose a random subset of files.
as the oracle we check whether pdf scrutinizer classifies a file as malicious.
this oracle may accept a malformed pdf and classify it as malicious.
this behavior is desired since pdf viewers try to display even malformed pdfs and could thus still execute harmful code.
in contrast to the above formats pdf trees have weaker constraints over their nodes and the malicious content contained in embedded objects is typically not spread over the tree.
the pdf corpus for specializing templates are files from the contagio malware dump including both malicious and benign documents.
d test suite of xml files as another usage scenario we use gtr for test suite reduction i.e.
reducing test cases while preserving the code coverage.
we download a corpus of more than xml files that adhere to the same xml document type definition dtd .
from the corpus we select a random subset of xml files and parse them using the xmllint xml validation tool.
subsequently we measure the coverage in xmllint using gcov .
as the oracle the coverage in xmllint using a reduced xml file must be at least the original coverage.
for xml there was no necessity to specialize the templates because both valid and invalid xml files are accepted by xmllint.
therefore we omit the template authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
hddhdd gtrgtr hddhdd gtrgtr hddhdd gtrgtr hddhdd gtrgtr pythonjavascript pdf xml algorithmsremaining nodes fig.
.
effectiveness of reduction measured in terms of the number of the remaining tree nodes.
the boxes indicate the median and the first and third quartiles.
the whiskers include up to .
inter quartile ranges above and below the box.
specialization step.
state of the art approaches we compare our approach to our own implementations of the existing dd hdd and hdd algorithms.
the dd implementation works on the linelevel i.e.
each line of the input is a chunk considered by dd.
the hdd implementation uses the same tree representation of the inputs as the gtr implementation.
b. effectiveness to evaluate the effectiveness in reducing test inputs we apply gtr and gtr to the inputs in table i. to measure effectiveness we compute the remaining size relative to the original inputs measured both in terms of the file size and the tree size.
since dd does not represent inputs as trees we measure only the file size for dd reduced inputs.
table ii summarizes the results.
the table shows for each approach the remaining file sizes and nodes along with the percentage of the original size.
each value is the median over all inputs we consider.
the best approach for a particular measure and input format is highlighted.
overall gtr consistently yields the smallest remaining trees closely followed by gtr with .
.
.
and .
of the original size for python javascript pdfs and xml files respectively.
to better understand the variations in effectiveness across different inputs of a format figure shows the distribution of remaining tree sizes.
the figure shows that even though the effectiveness varies across inputs gtr and gtr outperform the other approaches for most inputs.
we further discuss our results for the different formats python.
for the python data set gtr produces the smallest trees and gtr the second smallest.
the relative reduction is not as high as for other formats.
the reason is that these inputs have been reduced manually before reporting them to the python developers which leaves little room for any subsequently applied tree reduction algorithm.
javascript.
for the javascript data set we observe larger reductions by all algorithms sometimes removing more than of the file.
the main reason is that these files are generated by a fuzz tester and have not been processedby a human.
gtr and gtr consistently outperform all other algorithms.
pdf.
for the pdf data set all tree based algorithms are equally efficient leaving only .
of the nodes in a tree on average.
the reduced file size is about i.e.
larger than the reduced tree size.
the reason is that a few nodes in the tree representation of a pdf are large objects such as images or embedded code and that these large objects often contain the malicious content.
surprisingly dd actually achieves marginally better file size reductions compared to the other algorithms.
however after examining these files manually we noticed they were not valid pdf files anymore even though pdf scrutinizer still flags them as malicious.
these syntactically invalid files would likely not help a security analyst that much.
in contrast removing more than half of a pdf s nodes is a vast improvement for a security analyst who manually inspects the file s content.
xml.
for the xml test suite gtr and gtr achieve the best reductions sometimes removing up to of the trees.
dd is only able to reduce the xml files minimally.
our hypothesis is that when dd removes random lines a malformed xml file result which trigger only the error handling code of xmllint.
in summary gtr and gtr are more or as effective as the best existing input reduction approach with respect to the remaining tree size.
using gtr the median percentage of nodes after reduction for four different input formats is .
.
.
and .
respectively.
c. efficiency we evaluate the efficiency of our approach by measuring the number of oracle invocations required to reduce a tree.
using this metric instead of e.g.
wall clock time is motivated by two reasons.
first invoking the oracle typically is the most important operation during automated input reduction because it often involves running a complex piece of software such as a compiler or interpreter on non trivial inputs such as large programs.
second wall clock time is highly dependent on the implementation of the tree reduction and the oracle.
to check that the number of oracle invocation is a meaningful measure we compare the time spent in the oracle with the time in other parts of the algorithm for the javascript data set.
for each algorithm the oracle invocation time dominates and comprises more than of the total execution time on average.
table ii shows the median number of oracle invocations required by the different approaches to a reduce a single file.
figure illustrates the distributions of this number for each input format.
for three of the four formats gtr and gtr require fewer oracle invocations i.e.
are more efficient than their counterparts hdd and hdd .
the gtr and hdd algorithms both need more invocations than their less counterparts which is unsurprising because they run the algorithm including oracle invocations multiple times.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii effe ctiveness and efficiency of reduction by gtr and gtr compared to baseline approaches .
for each measure the best approach is highlighted .
w e report the median values over all files of a data set .
dd hdd hdd gtr gtr failure inducing python code remaining file size .
.
.
.
.
remaining nodes .
.
.
.
oracle in vocations inconsistency exposing javascript code remaining file size .
.
.
.
.
remaining nodes .
.
.
.
oracle in vocations malicious pdf documents remaining file size .
.
.
.
.
remaining nodes .
.
.
.
oracle in vocations test suite of xml files remaining file size .
.
.
.
.
remaining nodes .
.
.
.
oracle in vocations ddhddhdd gtrgtr ddhddhdd gtrgtr ddhddhdd gtrgtr ddhddhdd gtrgtr pythonjavascript pdf xml algorithmsnumber of oracle invocations fig.
.
number of oracle invocations.
note the logarithmic scale.
the boxes indicate the median and the first and third quartiles.
the whiskers include up to .
inter quartile ranges above and below the box.
we next discuss the results for the different formats python.
gtr needs more invocations than dd but hdd needs more invocations than gtr.
javascript.
gtr is the most efficient approach.
hdd needs more invocations and dd more invocations.
pdf.
gtr is the most efficient approach.
hdd needs more invocations and dd more invocations.
xml.
hdd is the most efficient approach.
gtr needs more invocations and dd more invocations.
the large difference in the results for dd can be explained by the size of the input files.
since the python files are relatively small and cannot be reduced as much as the relatively large javascript files dd reduces them quickly.
in contrast the structure unaware search of dd takes significantly more oracle invocations for larger files.
to summarize gtr is either more efficient or only slightly less efficient than the best existing approach.d.
benefits of corpus based filtering our approach specializes language independent transformation templates to a specific input language by learning filtering rules from a corpus of examples of inputs.
to evaluate how the corpus based filtering influences the effectiveness and efficiency of gtr we compare the approach with a variant of gtr that does not filter any candidate transformations.
for both variants we perform the same experiments as described in sections v b and v c except for the xml format where we do not use any corpus.
we find that the gtr variant without filtering of candidates achieves the same effectiveness for javascript and pdf and slightly higher reductions for python.
the reason is that the corpus does not mirror all facets of the target languages which may cause the filtering to overly constrain the transformations.
for example if the corpus would not contain any if statement without an else branch then gtr would not consider removing the else branch.
fortunately the results show that such overly constrained filtering is very unlikely.
the gtr variant without filtering needs significantly more oracle invocations.
for the python data set the variant needs invocations median whereas the full gtr approach needs only invocations.
for the javascript data set the results are and invocations without and with filtering and for the pdf data set and invocations respectively.
finally we measure how long extracting language specific information from the corpus takes.
in total extracting this knowledge takes around minutes seconds and seconds for the javascript python and pdf data sets respectively.
in summary comparing gtr with and without specialization transformations shows that both variants are roughly equally effective and that the specialization significantly improves the efficiency of the algorithm.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vi.
r elated wo rk a. minimizing test inputs delta debugging dd sets the foundations to automate the process of minimizing test inputs.
in contrast to gtr it cannot handle large structured inputs effectively.
recently parallelization of dd has been explored which is orthogonal to our contributions.
the hierarchical variant hdd applies dd on hierarchical documents.
however hdd fails to restructure trees in a way that allows obtaining significantly smaller results and also is less efficient than gtr.
an improved hdd variant proposed later uses a different kind of grammars .
this targets the conversion of code documents to trees and is complementary to our findings.
c reduce is a variant of dd that applies domain specific transformations to reduce c code.
these transformations include changing identifiers and constants removing pairs of parentheses or curly braces or inlining functions.
one big advantage of c reduce is to never produce any input with nondeterministic or undefined behavior.
there are two big differences in comparison to our approach.
first the transformations are source to source and not tree to tree.
second c reduce loses generality by applying domain specific changes to the document.
however many of the transformation included by c reduce can be expressed in a more general way and are included in our approach.
for example removing an operator and one of its operands e.g.
changing a b into a or b is equivalent to replacing the operator node with one of its children in the tree.
when the input to a program is not as complex as a code document itself more efficient techniques can be employed.
one possibility is to minimize the path constraints of the input that led to a particular failure .
however the set of path constraints grows exponentially for more complex inputs rendering this approach unfeasible for code inputs.
another interesting approach taints parts of each input to identify the parts relevant to a failure .
the default setting taints each byte independently making it possible to also account for complex inputs.
at the same time this disregards the structure of the document similar to dd and thus becomes overly expensive.
another setting tracks inputs on a per entity basis which is insufficient for test input reduction.
test input reduction is particularly important for automatically generated test inputs.
fuzzing is a popular technique to create such inputs.
it has been successfully applied to various kinds of input formats including program code to test compilers and runtime engines program code to test refactoring engines document formats to test word processors and structured text formats for security testing .
all these formats can be represented as a tree and may benefit from reduction via gtr.
b. fault localization various techniques aim at localizing a fault in the buggy program itself instead of the input.
zeller applied dd also to the program with this goal .
there are various otherapproaches for fault localization .
program slicing reduces a program while maintaining its behavior with respect to a particular variable .
ideally the smaller slice contains the bug and eases its localization.
dynamic slicing focuses on the subset of the program that give a variable its value with the current input.
just slicing the variables that appear in the line causing the bug if known does not guarantee to obtain a program that produces the same buggy behavior though.
the combination of dd with dynamic forward and backward slicing has also been explored previously .
another approach is to record traces to find shorter program executions with the observed buggy behavior which ultimately also reveals likely locations for the bug.
fault localization and test input reduction have different goals.
in a first step a tester confronted with a failure needs a small and fast running input to reproduce the failure.
in a second step the bug must be located in the program and fixed.
finally the small input can be turned into a regression test.
thus both techniques complement each other.
c. minimizing test suites while randomly generating tests high code coverage can be achieved.
the tests in randomly generated suites are often rather big and can also benefit from a reduction with dd .
to maintain the good coverage of the test suite the oracle can be modified to account for that instead of testing for particular failures .
d. inference of language constraints our corpus based filtering relates to work on inferring grammars and probabilistic models of structured program inputs .
as an alternative to inferring language constraints from a corpus gtr could reuse inferred grammars and models to prune candidate trees.
vii.
c onclusion we present gtr a novel algorithm to reduce tree structured test inputs in a generalized and language independent way.
our algorithm applies tree transformations hierarchically to reduce a given test input.
the algorithm combines delta debugging and a greedy backtracking based search to choose which transformations to apply.
to specialize generic tree transformation templates to a particular input format gtr automatically infers language specific filters from a corpus of examples.
we compare our approach with three existing algorithms dd hdd and hdd on test inputs.
in three of four experiments gtr outperforms other algorithms in reduction effectiveness.
at the same time gtr is either only slightly less or even more efficient than the best existing approach.
we envision gtr to be applied to various problems that benefit from reduced inputs e.g.
to reduce bug triggering inputs provided by users or fuzz testing techniques to reduce test suites for more efficient test execution or to reduce potentially malicious code or documents before a manual security analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.