srciror a toolset for mutation testing of c source code and llvm intermediate representation farahhariri university ofillinois at urbana champaign illinois usa hariri2 illinois.eduaugust shi university ofillinois aturbana champaign illinois usa awshi2 illinois.edu abstract we present srciror pronounced sorcerer a toolset for performing mutation testing at the levels of c c source code src and the llvm compiler intermediate representation ir .
at the srclevel srciror identifiesprogramconstructsformutationby pattern matching on the clang ast.
at the ir level srciror directly mutates the llvm ir instructions through llvm passes.our implementation enables srciror to handle any program that clang can handle extending to large programs with a minimal overhead and have a small percentage of invalid mutants thatdonotcompile.
srciror enablesperformingmutationtesting using the same classes ofmutationoperatorsat boththesrc and ir levels and it is easily extensible to support more operators.
in addition srciror can collect coverage to generate mutants only forcoveredcodeelements.ourtoolispubliclyavailableongithub .
we evaluate srciror on coreutilssubjects.
ourevaluation shows interesting differences between src and ir demonstrating the value of srcirorinenablingmutationtestingresearchacrossdifferentlevels of coderepresentation.
ccs concepts software and its engineering software testing and debugging keywords softwaretesting mutationtesting acm reference format farah hariri andaugust shi.
.srciror atoolset formutation testing of c source code and llvm intermediate representation.
in proceedingsofthe2018 33rdacm ieeeinternational conferenceonautomatedsoft ware engineering ase september montpellier france.
acm new york ny usa 4pages.
introduction software testing is commonly used in industry for quality assurance.onekeychallengeofsoftwaretestingistoproperlyevaluatethe quality of test suites in terms of their bug finding capability.
permission to make digital or hard copies of all or part of this work for personal or classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed for profit or commercialadvantage and that copies bear this notice and the full citation on thefirstpage.
copyrightsfor components of thiswork owned byothers than acmmustbehonored.abstractingwithcreditispermitted.
tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand or afee.
requestpermissionsfrompermissions acm.org.
ase september montpellier france associationfor computing machinery.
acm isbn978 ... .
test suite with a large number of tests or that achieves a high statement or branch coverage does not necessarily have a high bug finding capability.
mutationtestingiswidelyusedinresearchtoevaluatethequalityoftestsuites andithasrecentlystartedtogainmomentum in industry as well .
mutation testing proceeds in two steps.
thefirststepismutantgeneration.amutantisamodifiedversion oftheoriginalprogramobtainedbyapplyingamutationoperator.
amutationoperatorisaprogramtransformationthatintroducesa smallsyntacticchangetotheoriginalprogram.thesecondstepof mutationtesting is to run the test suite and determine which mutants are killed.
a mutant is killed if the tests behave differently typically in their pass fail status when run on the mutant com paredagainst running thetestsontheoriginalprogram.mutation testing produces a measure of quality of the test suite called the mutationscore.
the mutationscore ofa given test suite is the per centageofmutantskilledbythattestsuiteoutofthetotalnumber ofgenerated mutants.
multiple mutation testing tools were developed that perform mutation at different levels.
traditional mutation testing is performedatthelevelofsourcecode src e.g.
for c and java .
more recently mutation testing has been applied at thelevel ofcompiler intermediate representation ir e.g.
forthe llvmir .however thecurrentlyavailabletoolsdonot meetallresearchers needs.first someofthetoolsapplytransformations on the text of the source code without performing any parsing .suchtoolsgenerate alargenumberofmutantsthat do not compileand can waste a lot ofthe mutant generation time.
theyalsocanmissgeneratingsomemutantsastheyrelyonsyntacticmatchingtodetectmutationopportunities.second sometools implement their own parsing trees and therefore may not sup portalllanguageconstructsandwouldfailtogeneratemutantsoneven moderately sized programs.
lastly there does not exist one framework that supportsmutationat different levels src and ir allowing fair comparison and easy extension for supportingmoreoperators.
wepresent srciror pronounced sorcerer atoolsetforperforming mutation testing at the levels of c c source code src and the llvm compiler intermediate representation ir .
at thesrc level srciror identifies program constructs by performing pattern matchingontheclangast.
srciror thenappliestherelevant mutationoperatorsonthefound constructs.at their level srciror finds the instructions that should be mutated using an llvm pass and then directly mutates those ir instructions.
our implementation enables srciror to handle any program that clang can handle extending to large programs with a minimal overhead and have a small percentage of invalid mutants that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france farah hariri and august shi do notcompile.
srciror enables performing mutationtesting usingthesamemutationoperatorclassesatboththesrcandirlevels andsrciror iseasilyextensibletosupportmoreoperators.in addition srciror can collect coverage to generate mutants only forcoveredcodeelements.
srciror isopen sourceandispublicly available at .
we evaluate srciror onfivesubjectsfromcoreutils.coreutils isalibraryofcommandlineutilitiesforunixthatiswidelyusedinresearch.wearethefirsttoperformmutationtestingontheentirecodeofourfivesubjectsforbothsrcandirlevels.ourevaluation shows interesting results demonstration the value of srciror in enabling mutationtesting research across different levels.
mutation tools implementation inthissectionwedescribethemutationoperatorsin srciror.w e then describe in detail theimplementation of srciror s src and irmutantgenerationcomponents.finally wedescribeusingcode coverage tofilteroutmutantsformutationtesting.
.
mutation operators we define four mutation operators in common at both src and ir levels.
a similar set of mutation operators is often used in theexistingmutationtoolsforthe clanguage e.g.
byandrewsetal.
orjia and harman .thesefourmutationoperatorsare aorreplaces every arithmetic operatorfrom the set w i t hadifferentarithmetic operatorfromthesame set.
atthe src level the aor classalso includes replacingthe arithmetic assignment operators from the set with other operators of that same set.
replacing arithmetic assignment operators does not apply at theirlevelwheresuchassignment operatorsarealreadytranslatedintosimpler instructions.
lcrreplaces every logical connector with another logical connector.atthesrclevel itreplaceseveryoperatorfrom theset oflogical operators theset ofbitwise operators and the set of logical assignment operators w i t hadifferentoperatorfromthesame set.at the ir level only bitwise operators are applicable because the other two sets are translated into different instructions potentiallybitwiseoperatorsorconditional branches .
rorreplaces every relational operator with another relationaloperator.atthesrclevel itreplaces every operator fromthe set of relational operators !
with adifferentoperatorfrom the same set.
it also replaces booleanconditionsinconditionalstatementsandloopswiththeir negations specifically it replaces ewith!efor every expressionfromtheset if e while e for ... e ... .
at the ir level the operatorinvolves replacing every ir instruction from the set eq ne ugt uge ult ule sgt sge slt sle w i t hadifferentpredicate fromthe same set.
icrreplacesevery integer constant cwithavaluefromthe set c c c c .
.
source level mutant generation tool we implement our source src level mutant generation tool as a source to source transformation tool based on clang version figure src mutator architecture figure ir mutator architecture .
.
.thearchitectureofourimplementationisshowninfigure .
we perform the src mutation in three steps.
first we use clang to parse the input files and build an abstract syntax tree ast .
second we use ast matchers c o m b i n e dw i t h libtooling to search for candidate mutation locationsin the ast.
finally for each of these candidates we use these same two libraries to modify the clang ast performing a source to source transformation thatmutatestheastbasedonthemutation generatingadifferentmutatedsourcefilefor eachmutation.
srciror supports generating mutants in different files for a project.
this feature is an essential characteristic of a mutationtool as code is generally organized in multiple files and directories according to its functionality.
for example a significant part ofthefunctionalityusedbythecoreutilstoolsisdefinedinautility directory that gets compiled into a shared library libcoreutils.a that links to the executable.
failing to generate mutants for code fromlibcoreutils.a decreases the confidence in the value of the mutationtestingresults.
.
ir level mutant generation tool forir levelmutantgeneration srciror usestransformationpasses in the llvm compiler infrastructure llvm version .
.
to generate mutants figure .first we useclangwiththeflags s emit llvm to generate llvm bitcode files representing the code.
next weapplytwollvmpasses.thefirstllvmpasstakesinthe bitcodefile and generates as outputthe list of mutationopportunities amutationopportunityisdefinedbyalocation specificllvm instruction and one of its operands that can be mutated and themutation type the mutation operator and the value to substitute the operand for .
the second llvm pass takes as input a bitcode authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
srciror a toolset for mutation testing for c source code and ... ase september montpellier france file and the mutation opportunity to apply and then actually appliesthemutation creatinganewmutatedbitcodefileforeachmutation.finally themutatedbitcodeispassedalongtothecompilerto resume the original compilation resulting in a final compiled mutant.notethatthesecondstepofgeneratingmutantsiscarried by the user a simple loop is needed to go over each mutation op portunitygeneratedinthefirststepandfeeditinto srciror along withtheoriginal bitcodefiletoperformthemutation.
for both src and ir we create python wrapper scripts that are called by the project build scripts instead of clang.
the wrapperscriptsimplementthesameinterfaceasclang performingthe sameoperationsasdescribedearlierforsrcandirmutations andthen delegating theremaining compilationcommands backtothe actual clang.
for example in the case of src the python script callsthemutatoronthecommandsthat have sourcefilesin them.
inthecaseofir thepythonscriptusesthecommandsalongwith some inserted flags to first generate llvm bitcode call the mutator llvm passes on the bitcode and then finish compiling themutatedbitcodebydelegatingbacktotheoriginalclangcompiler.
.
incorporating coverage while we can run tests against all the mutants generated at the srcandirlevel tocomputethemutationscore thetestsmaynotnecessarily cover some of the generated mutants.
if tests do notcover certain mutants then those tests cannot kill such mutants.
while it is important for a developer using the mutation testing toolto know when some mutantsare not even covered as it indi catesaweakness inthetestsuite sometimesadeveloperwantsto know just how good the test suite is on the mutants already covered.
furthermore checking only mutants killed of the mutantscovered leads to faster mutationtesting as fewer mutants are run.
weallowforusingcodecoverage tofilteroutmutantsthatshould not berunwithtests figures 1and2 .
atthesrc level weruntestsfirstoncodeinstrumentedusing llvm cov gcov tocollectsimplecoverage.
thenwefeedinthecovered lines asinput tothemutator thepattern matchinglogic willonly generate mutantsof covered lines.
at their level thereisno existing toollike llvm cov gcov that collects code coverage of ir instructions.
as such we implementour own code coverage tool at the ir level as a new llvm pass.
the pass iterates through each llvm instruction while keeping a counter giving a unique count for each instruction.
at each in struction the pass inserts a call to a helper coverage instrumentation method.
when the tests are executed on the instrumented code executing the call records the instruction count which isthen written into a trace file.
this trace file represents the coverageattheir level.
inthefirstllvmmutatorpassthatdetermines whatinstructionstomutate thepasscountstheinstructionsinthe same way as in the coverage pass and then the pass onlyoutputsa mutation for an instruction if its count matches an instruction countfrom theinput coverage information.
evaluation .
splitting coreutils tests we perform an evaluation of using srciror on programs from coreutilsversion6.
.thetestsformostprogramsincoreutilsaremanually written scripts that invoke the program multiple times whereeachinvocationconceptuallyrepresentsadifferenttest.such scripts are not ideal for evaluating mutation testing.
for example many of the programs have test script files that contains tests.
if we were to execute such a test script for a given program directly ontheoriginalandmutatedversionsoftheprogram itwouldexe cutealltestsandreportafailureifany ofthetestsfails.therefore we would just know if a mutant is killed or not but we would not g e tt h ef u l lt e s t m u t a n tm a t r i x i .
e .
w ew o u l dn o tk n o wf o re a c htest mutantpairwhetherthattestkillsthatmutant.ifonewereto useamutationtestingtooltoevaluatethequalityofatestsuite it is enough to know what mutants are killed by any test in the testsuite.
however it is often desirable to obtain the full test mutant matrix because it can facilitate a further analysis of mutants normally needed in mutation research e.g.
computation of minimalmutant sets .
to get the full matrix for the programs we manually analyzed all the test script files for the coreutils programsused in our evaluation and we split each long script into severalshorterscriptsthat eachrunsanindividual test.
wesplitlongtestscriptsintoshortertestscriptsthroughacombination ofautomatedtransformations whenever it waspossible and manual changes.
to ensure that our process for splitting the test scripts does not affect the validity of the results we executed all shorter test scripts on their respective programs to verify thateach of them gives the expected result on the original code.
more precisely executing a test on a program in coreutils can give one of the three possible results pass fail or skip.
the tests are skipped during execution when their precondition state is not established which can happen for a number ofreasons.
one reason thatwe commonlyfound for skippedtestswasthat they required to be run with the root privilege level.
another reason was that a few tests required the presence of more than one disk partition mounted on the filesystem.
these tests report the skip result for the original program as well as for any mutant generated for the program.
further weinspectedallteststhatweregettingskipped after our splitting of long test scripts into shorter test scripts.
formostcases thetestwasalsooriginallyskippedinthelongerscriptduetounavailableprivileges orresources whichis thecorrectbehavior.
for a few cases the test started being skipped after our splitting.wecarefullyinspectedthelattercasesandfoundoutthatsome tests were getting skipped because their setup was getting skipped this setup usually sets some test environment variables and is performed when all tests are run by invoking make check fromthetop mosttestdirectory ourshorterscriptsdonotinvoke teststhatway.however themostimportantaspectisthatthesame testsareskippedconsistently andthustheydo notaffectmutation testinganalyses usingtheartifact.thecoreutilsartifacts splitted testsalong withthescriptswe wroteto perform thesplitting are available at .
.
results tables1and2showthenumbersofmutantsgeneratedby srciror that are covered by tests at the src and ir levels respectively columns m .
srciror generates many moremutantsat the ir level thanatthesrclevel 15944versus4261 respectively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france farah hariri and august shi table number of src mutants generated and the number percentage of them that are equivalent duplicated program tests overhead src m e e d d nend factor .
.
.
head .
.
.
seq .
.
.
stat .
.
.
unexpand .
.
.
overall .
.
.
table number of ir mutants generated and the number percentage of them that are equivalent duplicated program tests overhead ir m e e d d nend factor .
.
.
head .
.
.
seq .
.
.
stat .
.
.
unexpand .
.
.
overall .
.
.
table raw mutation scores and nend mutation scores program src ir raw nend raw nend factor .
.
.
.
head .
.
.
.
seq .
.
.
.
stat .
.
.
.
unexpand .
.
.
.
overall .
.
.
.
we also compute the number percentage of equivalent duplicatedmutantsforeachofthesrcandirmutantsseparately.equivalent mutants are mutants that are the same as the original pro gram.
duplicated mutants are mutants that are equivalent to one another but not necessarily equivalent to the original program.
all equivalent mutants should be ignored while all but one mutant from an equivalence class of duplicated mutants should beignored.
the remaining mutants are then what we consider nonequivalent non duplicated nend mutants .wedetectequivalent duplicated mutants using trivial compiler equivalence .
we show these number percentage of equivalent duplicated mutantsandthenumberofnendmutantsforsrcandirintables and2.evenwhenconsideringonlynendmutants therearemany more mutants atthe ir level than atthe src level.
table3showstherawmutationscores considering allcovered mutants andthemutationscoreswithonlynendmutantsatthesrc and ir level.
we see that mutation scores at src tend to be higher than scores at ir.
these differences show the value of thetoolinenablingresearchthatasksinteresting questionsaboutmutationtestingat thedifferent levels.
lastly tounderstandtheefficiencyof srciror wemeasurethe timeoverheadformutantgenerationatboththesrcandirlevels.if thecodeis builtfrom scratchfor every mutant theoverhead ofsrciror wouldbeequaltothenumberofmutantsgenerated i.e.
4261x for src and 15944x for ir.
however one can use various optimizations to improve srciror s performance.
in our evaluation weuseasimplesetupthatperformsincrementalcompilationbetween mutants.
columns marked overhead in tables 1and2 s h o wt h eo v e r h e a d sa st h er a t i oo ft h et i m en e e d e dt og e n e r a t e all mutants for a given program to the time needed to perform a clean build of that program without mutation .
the overhead varies from .02x to .50x.
overall srciror incurs an overhead of .14x for src mutants and .35x for irmutants overheads aremuchlower thanthenumber ofmutants.
conclusions we present srciror atoolsetfor performingmutationtesting at thec c source and llvm ir levels.
we evaluate srciror on a subsetofprogramsfromcoreutilsandhowsrcandircomparein terms of number of mutants generated mutation score and num berofequivalentandduplicatedmutants.
srciror opensthedoor for performing mutation testing research for c c programs on multiplelevels and comparingthem.