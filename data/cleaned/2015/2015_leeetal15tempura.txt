tempura temporal dimension for ides yun young lee darko marinov ralph e. johnson department of computer science university of illinois at urbana champaign urbana il usa email flee467 marinov rjohnson g illinois.edu abstract modern integrated development environments ides make many software engineering tasks easier by providing automated programming support such as code completion and navigation.
however such support and therefore ides as a whole operate on one revision of the code at a time and leave handling of code history to external tools or plugins such as egit for eclipse.
for example when a method is removed from a class developers can no longer find the method through code completion.
this forces developers to manually switch across different revisions or resort to using external tools when they need to learn about previous code revisions.
we propose a novel approach of adding a temporal dimension to ides enabling code completion and navigation to operate onmultiple revisions of code at a time .
we previously introduced the idea of temporal code completion and navigation and presented a vision for how that idea may be realized.
this paper realizes that vision by implementing and evaluating a prototype tool called tempura.
we describe our algorithm for processing and indexing historical code information from repositories for tempura and demonstrate tempura s scalability with three large eclipse projects.
we also evaluate tempura s usability through a controlled user study.
the study participants learned about the code history with more accuracy when using tempura compared to egit.
although the sample size was not large enough to provide strong statistical significance the results show a promising outlook for our approach.
i. i ntroduction modern integrated development environments ides provide automated programming support that make many software development tasks easier.
for example many ides offer context specific programming assistance with code completion providing developers with proposals for completing identifiers such as type method or field names from a given prefix of element names.
ides also offer navigation support allowing developers to quickly find and navigate to type method and field declarations.
these ide support features are continuously being studied and improved.
for example code recommenders in eclipse can suggest identifier completion from a given partial name match and suggest completion for longer code snippets.
others have introduced a tool that automatically synthesizes code snippets using program elements available in the current scope of code .
some research prototypes additionally use dynamic program information to improve navigation .
while such automated programming support in ides help developers programming tasks these features and thus the ides as a whole operate on one revision of the code at a time.
however developers working on continuously evolving projects not only have to work with the most current revision of code but also frequently need to understand code changes from past revisions made by colleagues or even by themselves.this is because successful software development relies heavily onimplicit knowledge an important subset of which is understanding the history of the code .
when the developer s implicit knowledge becomes incorrect or outdated their productivity is hindered as they are forced to switch context from writing or fixing code to rebuilding the knowledge.
version control systems vcss build and maintain an explicit knowledge base by recording all changes over the history of a project.
vcss however record all the changes to a project s code whether it is a renaming of a method or a spelling correction in comments.
therefore it is left up to developers to sift through all the recorded changes in order to find pertinent changes that impact their programming tasks.
in addition while most modern ides provide functionality that supports different vcss this functionality mostly exists as add ons or plugins for example egit and subversive for eclipse.
there is a distinct separation between core ide features like code completion and navigation and vcs features.
current ides that restrict core ide features to operate only on one revision of code inherently hamper developers productivity because developers are forced to tediously search through revision history in vcss or manually switch to different revisions when seeking information from past revisions of code.
for example consider a scenario where a field is renamed.
alice one of many developers working on a project tries to access a field called num edges that she used before by invoking code completion on its declaring class lexeratnsimulator .
unbeknownst to alice however the num edges field was renamed by her colleague.
when alice does not find the num edges in the completion proposal list she suspects that the field is either renamed or removed which forces alice to pause her programming task and search through the revision history in the project s vcs.
one of the biggest challenges alice faces in her search is the sheer volume of change history for example by using git s log operation that she has to filter through even before she finds the specific commit that contains the pertinent changes.
for example there may be many commits made by her colleagues since the last time she updated her local git repository.
the declaring class lexeratnsimulator itself may have undergone many changes or been deleted altogether.
also if the commit messages are unclear or if the commits contain multiple unrelated changes alice s task becomes even more complicated and tedious.
her search process will likely become slower as the size duration and number of people involved in her project increases.
while many vcs tools provide operations like blame that show the last person to make changes to the selected file or line of code these operations cannot be performed on deleted lines.
however if alice can still find the num edges field in thefig.
.
tempura s historical code completion proposals for lexeratnsimulator class are shown in gray with historical information displayed in tooltip.
example code is from antlr4 project.
completion proposal list and use it to pinpoint the exact change that removed the field she could complete her task much more efficiently.
we envision a new approach of extending ides by adding atemporal dimension allowing the familiar programming support in ides such as code completion and navigation to work with multiple revisions at a time without resorting to manual revision switching.
this paper builds on our short paper that introduced the idea of temporal code completion and navigation .
our approach locates types and members from past revisions of code that are relevant to the current context and presents them through code completion.
our approach also allows developers to search for and navigate to types in any revision even deleted types.
we implemented our approach in an eclipse plugin called tempura1.
this paper makes the following contributions an algorithm for processing and indexing past revisions of code in vcss in order to support temporal dimension in ides.
an open source prototype eclipse plugin tempura that embodies our approach for temporal dimension supporting the java programming language and git vcs.
an evaluation of tempura that answers the following two research questions rq1 how efficiently can code history information be collected from a project s repository?
how scalable can the computation be for large real world projects?
rq2 does the history information that tempura provides through eclipse s code completion and navigation features help developers to learn code history more accurately and efficiently?
we conducted an experiment with three large eclipse projects to show scalability of tempura rq1 and a controlled user study with participants to evaluate how tempura compares with egit that handles code history separately from the current revision of code rq2 .
the results show that tempura can index the history of projects with over files and revisions in less than minutes with less than second run time response time and that tempura allows developers to learn about code changes with higher accuracy and with higher efficiency in terms of rate of information acquirement compared to egit.
1tempura is a japanese dish but we derived the name from the word temporal for our tool.all materials including tempura s source code and user study materials are publicly available at edu tempura and more details of our work can be found in .
ii.
t empura tool tempura embodies our approach of extending ides with a temporal dimension by allowing eclipse to simultaneously operate on previous revisions of the code as well as the current revision.
tempura processes and indexes historical api information from a project s vcs in order to provide quick feedback in an interactive use and supports two main features temporal code completion and temporal code navigation with type search.
while our tempura implementation focuses on the java programming language and the git vcs our ideas generalize to other languages and vcss.
tempura supports one git repository at a time requiring an eclipse workspace to have projects from a single git repository.
a. temporal code completion tempura augments eclipse s code completion with proposals that were possible in all the previous revisions of the code in the given context.
the context is defined by program elements involved in the code completion invocation their package and inheritance relationships and the access restriction rules between java program elements.
more precisely let us call the element on which code completion is invoked the receiver element a static type reference of lexeratnsimulator type in our example and the element from which the code completion was invoked the caller element thepushmode method in figure .
the receiver element may be a reference variable that can be resolved or a string token that can be used as a prefix of a name.
the caller element can be a method or a type.
the resolved type or name of the receiver element and the resolved type of the caller element s enclosing type together with their package and inheritance relationships form the code completion context c. figure shows the code completion proposals for the lexeratnsimulator class where historical proposals are displayed in gray.
each historical proposal item also displays relevant information from the vcs in its tooltip including the date author message and id of the commit git uses sha hash for commit id that removed the particular method or field.
the historical code completion proposals cannot be used in the same way as the current code completion proposals because they will cause compilation errors if inserted into the current code.
therefore when a developer selects a historical proposal tempura displays a comparison or a diff view between the revision that last contained the historical proposalfig.
.
selecting a historical code completion proposal opens eclipse s diff view comparing the revision that removed the proposal left with the previous revision right .
fig.
.
tempura s open type in history dialog shows historical types including deleted ones listed with a strike through .
selecting a type displays details about the last revision of the type at the bottom of the dialog window.
tempura also identifies and displays the renamed or moved types with arrows.
and the revision that removed it figure i .
it is easy to conjecture that if alice is using tempura when searching for thenum edges field not only could she very quickly learn that num edges was renamed to max dfa edges and assigned a different value in revision 71e0c66 but she could also see other changes that were made in the same commit.
b. temporal code navigation tempura supports temporal code navigation by allowing developers to search for and open any type from any revision of their projects using the open type in history dialog figure ii b including deleted types that are no longer present in the current revision.
when a developer searches for a type the dialog lists all the search matches where deleted types are shown with a strike through.
for example figure ii b shows search results for classes whose names start with parseratn and shows that parseratnfactory and parseratnsimulatorvariationinneroutercontexts are deleted types that no longer exist in the current revision.
selecting a type from the search result displays at the bottom of the dialog window the date and the revision id of the commit that last changed the selected type.
in addition tempura identified that parseratnsimulator was renamed from a type called v2parseratnsimulator and describes the change with an arrow depicting the rename or move change section iii a .
if the developer chooses to open a type from the dialog tempura opens the type in a read only historical editor figure .
the historical editor contains a list of revisions in which the file containing the historical type was modified along withdate commit id author and commit message.
the editor also uses background colors to show changes with respect to a previous revision.
for example figure shows the contents of lexeratnsimulator class in revision 71e0c66 and the line of code highlighted in blue background shows the code that has changed since revision the change corresponds to renaming of the num edges field to max dfa edge shown in figure i .
similarly green background highlights added lines of code.
tempura also allows developers to open a diff view comparing the selected revision in the list and its parent revision figure i with the show diff with previous revision button.
iii.
a lgorithm the goal of tempura is to present developers with all the code completion proposals and type search results that were possible at some point in time in the past.
the most straight forward way of collecting the historical proposals for a context cis to check out every revision of a project and invoke code completion in cin each revision and similarly for collecting type search results.
however this approach proved to be prohibitively expensive as our initial experiment with theantlr4 project took roughly seconds to check out and build each revision of the project.
there were total of revisions of the project at the time of experiment which would have translated to over hours to process all revisions.
in addition eclipse allows developers to use different build systems other than its own and it is impossible for tempura to support every possible build system.
our goal for tempura is to make it usable in terms of computation efficiency and portability therefore we implemented an algorithm that can operate independently of any build system.
our algorithm is a two step algorithm that parses every revision of every class from the vcs and indexes api information of types and members by declaring types fullyqualified names fqns and retrieves and filters code completion proposals and type search results.
parsing past revisions of code different vcss track changes in different ways.
vcss such as cvs and subversion store information as a list of file based changes and track changes made to each file over time.
in contrast git stores a snapshot of added or modified files every time a commit is made.
for files that have not changed git stores a link to thefig.
.
tempura s historical read only editor with a list of revisions on the left hand side.
blue background color highlights the snippet of code that was changed since the last revision similarly green highlights added code .
previous identical file it has already stored for efficiency .
note that this difference does not preclude other vcss or make git more advantageous for tempura.
our decision to support git was based on its popularity and we believe supporting other vcss would require only minor implementation changes.
the following pseudo code describes how we parse historical code revisions.
function processrepository repository foreach commit c in a repository in chronological order foreach file a that is added in this commit parse a foreach file m that is modified in this commit parse post modification revision of m foreach file d that is deleted in this commit parse pre deletion revision of d foreach file r that is renamed in this commit git specific parse post rename revision of r function parse file parse compilation unit in file with astvisitor foreach top level class interface or enum declaration t in file store commit data fcommit id file s next commit id path of file and file id g t s fqn and fqns of t s superclass and interfaces foreach nested class interface or enum declaration t in file store commit data t s fqn t s enclosing type s fqn and fqns of t s superclass and interfaces foreach method declaration m in file store commit data access modifier return type s fqn method signature and m s enclosing type s fqn foreach field declaration f in file store commit data access modifier type fqn and f s enclosing type s fqn tempura uses eclipse s java parser to parse the added modified deleted or renamed files in each commit from a project s git repository.
the rename changes are detected by using git s rename detection capability and section iii a details how tempura uses it to identify renamed or moved types.
tempura extracts api information from each file i.e.
declarations of types defined in a file and their method field and inner class declarations and their members recursively .
the parsed api information is stored in a data object called historyelement which is a simplified abstract syntax tree ast node object that also records the id of the commit sha of the commit object in which the file containing the type or member was modified id of the file s next commit child revision in the current branch id of the file sha of the blob object and the path of the file this is to efficiently support vcss which track files not individual classes .
tempura will store the historyelement s in a set indexed by the enclosing type s fqn.parsing a java file every time it is added modified renamed or deleted effectively records for each type or member the revision in which it was last observed in the file.
for example num edges field was last observed in the lexeratnsimulator class in a file in revision .
the file s child revision 71e0c66 then renamed the field tomax dfa edge effectively removing the num edges field from the class figure i .
therefore by also recording the child revision s id tempura can easily and quickly show a diff view when a historical proposal is selected.
in addition the parsing and indexing of the api information allows tempura to use the information for both code completion and type search.
retrieving and filtering proposals for code completion when a developer invokes code completion in a context c tempura uses eclipse jdt s code completion to resolve and identify the caller and receiver types.
tempura then uses the receiver type s fqn to find the set of historyelement s. while traversing the set of historyelement s tempura uses the caller and receiver types identities to compute access rules and filter the historyelement s. for example any historyelement with private access modifier is excluded unless the caller and receiver types are the same type.
in addition tempura disregards proposals that exist in the current revision of the receiver type so as not to duplicate the proposals.
for type search tempura matches the search phrase to the fqns of all the types indexed from the repository.
unlike temporal code completion however temporal navigation with type search is not restricted to any context and also includes the types that are present in the current revision of code along with deleted types.
this is because the read only historical editor allows developers to choose any revision of the type using the list of revisions on the left hand side.
limiting runtime computations to simple index lookup and filtering for code completion and type search allows for a fast response time regardless of the length of project or receiver type s history.
a. challenges there are a number of important aspects in presenting code history through the current workspace with code completion and navigation that require careful consideration.
we describe what they are and how tempura handles them.
handling complex changes as described earlier tempura collects code completion proposals from all past revisions in the given invocation context which are a set of receiver and caller elements and their resolved types that determine accessible program elements.
those program elements however could also have had complicated history.
while such changes would have little to no impact on temporal code navigationwith type search temporal code completion is more sensitive to them.
we have identified three such cases and their solutions.
firstly consider a type tthat extends a super type t0in the current revision.
when a developer invokes code completion on an element eof type t the proposals include some members fromt0that are accessible through t. however it is possible thattextended a different super type in the past t00 in which case tempura s historical code completion also needs to include accessible members of t00 or otherwise tempura would be ignoring some parts of the code history.
tempura handles the possible changes in inheritance relationships by recording a type s super type and interfaces during indexing.
then while filtering tempura recursively searches a type s all past and current super types and interfaces to collect accessible fields and methods.
filtering however would need to be improved in the future to take into account the possible changes in the past super types and interfaces.
any changes to t00 or more specifically deletion of its members after it was unextended by tshould not affect the temporal code completion results for e. this could be implemented by recording the last revision in which t00was extended and filtering out members that existed only in the subsequent revisions.
secondly changes in non identifying components of an element can also affect the result of temporal code completion.
for example a type in java is identified by its fqn which does not include the value of the type s access modifier.
however changes in the access modifier can change whether or not the type is included in some temporal code completion results.
similarly identifying members of a type simply with their signatures during indexing presents some limitations.
for example while access modifiers and return type are not part of a method s signature any change in them affects the resulting set of code completion proposals.
tempura therefore records such components when indexing.
for example if a field fof a type thad its access modifier changed from protected to public at some point in the past two instances of fwill be indexed with t s fqn one with protected access modifier and the other with public access modifier.
lastly there may be cases where seemingly identical elements in different revisions may in fact be different.
for example consider a type tthat had a method with the following signature setlocaltime localtime t in revision r1.
in a later revision r2 the type twas modified where an import statement import java.time.localtime was changed to org.joda.time.localtime .
while the change in import statements clearly changes the signature of the setlocaltime method simple parsing cannot identify the change of the argument localtime s type.
tempura therefore computes simple type resolution whenever possible to identify actual types by searching in import statements for their simple names.
if an import statement contains a wildcard tempura only uses the simple name of the types.
if the simple name is not found in the import statements or the java.lang package and there is no wildcard import statement then tempura uses the declaring type s package name to resolve types.
supporting branches code history of large projects is rarely linear.
they involve multiple branches throughout their life cycle and they present various challenges when merging the branches.
for example some researchers aim to predict merge conflicts ahead of time by identifying code changes inbranches that relate to code changes in the main development branch .
multiple branches and their merging also pose an important issue when presenting code history information to developers as presenting a code completion proposal or type search result that pertains only to a different branch can confuse developers and lead them to build wrong implicit knowledge of their code.
tempura therefore maintains a separate index for each branch.
as tempura processes the commits in chronological order it checks if a commit is in the log of each branch and updates a branch s index only if it is.
a separate index for each branch is necessary because an index effectively compresses a branch s history and the timestamp on each commit conveys no information about which branch it belongs to.
handling merge commits also present challenges for tempura during indexing most importantly because a nonconflicting merge commit effectively groups and duplicates the changes that were made in individual branches.
for example when tempura processes each commit in the repository in chronological order a field added to a class in one of the branches prior to merging will appear to be added again in the merge commit resulting in an inaccurate commit information being indexed with the field.
this means in a larger scale that the entire history of a project will be represented by few merge commits.
our solution is therefore to skip the merge commits during indexing.
however this is only a partial solution for non conflicting merge commits.
if a merge required developers to manually resolve conflicts which may involve removal or addition of members skipping merge commits may result in loss of valuable information.
one possible solution is to parse the file snapshots in merge commits only if it is a conflicting merge.
however while identifying a future merge commit as either conflicting or non conflicting would be trivial identifying for a past merge commit may require extra computation e.g.
re merging of the involved branches to determine the conflict status.
inferring changes while inferring the nature of changes specifically refactorings is out of scope of our work tempura infers class rename and move refactorings by leveraging git s rename move detection capability.
git can easily detect renaming of a file with no changes in its content because git tracks file contents and not file names.
however because the java syntax requires changes in both the file name and class or package name in the file content in case of a class rename or move tempura uses git s rename detection threshold score to infer class rename or move refactorings.
the threshold score is the minimum byte content similarity in percentage required to pair a deleted and an added files in a commit as a renamed or moved file.
tempura sets the threshold to a conservative .
when parsing tempura keeps a record of pairs of paths indicating pre and post rename or move files and uses the path pairs to identify the fqns of pre and post rename or move classes including non public and inner classes declared in a file .
this information is then displayed to developers in the open type in history dialog figure ii b .
because the rename move detection is based on git s byte comparison and not on syntactic and semantic analysis of java code tempura makes conservative heuristic decisions when required.
for example if git detects that a file containing one class is renamed to a new file containing multiple classes tempura chooses not to report the renametable i. i ndexing of every java file in each revision from git repositories .
project of commits time s of files parsed parsed data size bytes file size bytes org.eclipse.jdt.ui .
org.eclipse.platform.ui .
org.eclipse.jdt.core .
antlr4 .
lansimulation .
table ii.
t emporal code completion invocations .
class revisions hist.
proposals time s org.eclipse.jdt.core.javacore .
org.eclipse.jdt.internal.compiler.problem.problemreporter .
org.eclipse.jdt.internal.compiler.parser.parser .
org.eclipse.jdt.internal.compiler.lookup.referencebinding .
org.eclipse.jdt.internal.compiler.compiler .
org.antlr.v4.runtime.atn.lexeratnsimulator .
change.
similarly if git detects that a file containing nclasses is renamed to a new file containing the same number of classes tempura checks the equality of each class simple name before and after the change.
tempura limits refactoring inference only to class rename and moves because inferring refactorings on members is a non trivial problem and an active research topic.
for example researchers have extracted refactorings from software archive to help detect possible sources of errors and capture intent of changes and proposed a heuristic based algorithm that detects renamed methods between two revisions of code .
tempura may be extended to leverage existing research tools to infer refactorings in the future.
for example negara et al.
s method of assigning unique ids to every ast node when tracking changes suggests a promising approach.
iv.
e valuation we evaluated tempura in two ways.
first we evaluated tempura s efficiency in indexing historical data from a project s repository and runtime computation.
second we conducted a controlled user study to compare and evaluate tempura against egit a widely used git plugin for eclipse in helping developers learn about code history.
through both evaluations we answer the following questions rq1 how efficiently can code history information be collected from a project s repository?
how scalable can the computation be for large real world projects?
rq2 does the history information that tempura provided through code completion and navigation features that are common in ides help developers to learn code history more accurately and efficiently?
a. indexing and runtime efficiency to answer rq1 we evaluated tempura s efficiency in indexing api information from git repositories of three largescale projects.
the experiment was performed on a dual core .
ghz macbook pro with eclipse .
and java .
.
the results are shown in table i. the values for the time s column were calculated by averaging three separate indexing processes for each project.
of files parsed column shows the total number of files that tempura parsed.
we also included antlr4 project and the lansimulation project used in our user study described in section iv b for