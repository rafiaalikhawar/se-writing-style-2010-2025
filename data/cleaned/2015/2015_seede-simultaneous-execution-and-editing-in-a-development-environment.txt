permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be ho nored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.ase september montpellier france association for computing machinery.
acm isbn .
.
.
.
simultaneous execution and editing in a development environment steven p. reiss brown university department of computer science providence ri usa spr cs.brown.eduqi xin brown university department of computer science providence ri usa qx5 cs.brown.edujeff huang brown university department of computer science providence ri usa ase jeffhuang.com abstract we introduce a tool within the code bubbles development environment that allows for continuous execution as the programmer edits.
the tool seede shows both the intermediate and final results of execution in terms of variables control and data flow output and graphics.
these results are updated as the user edits.
the tool can be used to help the user write new code or to find and fix bugs.
the tool is explicitly designed to let the user quickly explore the execution of a method along with all thecode it invokes possibly while writing or modifying the code.
the user can start continuous execution either at a breakpoint or for a test case.
this paper describes the tool its implementation and its user interface.
it presents an initial user study of the tool demonstrating its potential utility.
ccs concepts y software and its engineering integrated and visual development environments interpreters software prototyping keywords continuous execution integrat ed development environments debugging live programming.
acm reference format steven p. reiss qi xin and jeff huang.
.
seede simultaneous execution and editing in a development environment.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 12pages.
introduction the ability to see intermediate results and understand and check the code as it is written is central to spreadsheet programming and is used in interactive enviro nments such as matlab and in dynamic languages such as smal ltalk and python.
for example sharp notes that for smallt alk a useful technique for writing new code is to write most of the code in the debugger .
bret victor claims this type of live coding is the preferred way to code .
this notion of live programming is slowly spreading to other domains such as data visualizatio n and other generally functional languages.
programmers can do live coding but onlyto a very limited extent with today s traditional java program ming environments using hot swapping the ability to reload a class and continue execution.
our goal is to provide live programming for real complex and long running systems in a practical fashion.
we targeted java programs as an example but the techniques could be applied to other languages.
our prototype tool seede prov ides the ability to see immediately the effect of code changes on execution.
it works for com plex java systems and a wide range of different edits.
it essentially provides live programming for real programs.
it lets the programmer explore the execution both to find problems and to investigate the effect of changes.
it does this within the opensource code bubbles programming environment letting the programmer start a new session at a breakpoint or for a test case and showing the updated execution as the programmer edits.
our work offers several contributions including the requirements and insights needed to make live programming possible and practical for real programs.
a methodology and architecture that implements these insights and meets the requirements.
an efficient and powerful initial user interface for browsing over the complete execution of a method.
techniques for displaying graphical output during execution for both paint methods and components.
a user study showing that the tool is usable and effective.
the requirements and insights are discussed in section .
related work is given in section .
an example use of the systemis shown in section .
the implementation is outlined in section .
the user interface provided by code bubbles is described in section .
limitations of the approach are discussed in section .
an initial evaluation of the system is presented in section .
practical live programming live programming involves pr oviding continuous execution feedback as the user edits.
any system that does this needs to meet certain requirements.
these include performance .
the evaluation needs to be fast enough to be run potentially on each keystroke and to provide feedback on the resultant execution within seconds.
if feedback is slower it can either confuse the programmer or cause unnecessary delays.
non obtrusive .
execution feedback should not interfere with or require substantial work on the part of the programmer in order to see the results.
this is especially true if the results can change on each keystroke.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellie r framce s. reiss qi xin j. huang idempotent .
continuous execution should not actually change any values in the running program or the external environment.
any such changes would make running the code multi ple times problematic.
for example a java method that starts with the code if !done.add input return can only be executed once since the next execution would just return.
error tolerant .
the intermediate code created by the user will contain both syntactic errors and semantic faults.
continuous execution must be able to work in such an environment providing output at least up to the first error.
moreover once theuser has an error free program the displayed execution shouldbe comparable to the prior error free version.
complete .
the system needs to be able to handle a large fraction of the underlying language.
this means being able to han dle input output files graphics as well as all the routines thatinvolve native code.
it also means handling a wide variety of edits.
working with large potent ially long running programs that interact with the real world complicates the notion of live programming.
making live programming work in this environment requires a number of insights.
the first insight is that rather than attempting to do live programming over the entire applicatio n it is sufficient to consider only the execution of a single method and all that it calls .
programming or debugging a large application is not done all at once.
instead the programmer will concentrate on a particular feature a particular bug or a part icular test case.
moreover if the programmer needs to make significant changes to the overall system for example a major refactoring live programming is not going to be relevant since there will be few consistent intermediate states between the original and revised system.
for code creation we assume that the user wants to implement a particular method and needs to get that method workingin an appropriate context.
this can include adding or modifyingother methods classes and fields in the system.
in this case they would stop either in that method or in one of its callers.
for debugging we assume the programmer has narrowed the problem to the invocation of a single me thod and all it calls for example the test driver.
concentrating on a particular method and what it calls addresses the requ irements of performance and nonobtrusiveness.
the second insight is that the execution should be triggered from a breakpoint in a debugger run .
the environment needed to run a method i.e.
all the associated data structures and values can be large and complex.
associating a seede run with a particular breakpoint in a debugger session lets seede query the debugger to access this environment.
the environment would typically be too difficult for the user to specify manually and would take too long to recompute on each keystroke.
starting from a breakpoint means that most of the execution is fixed enhancing performance.
it also allows the use of regular execu tion to reach the particular situation for example interacting with other systems or through a user interface so that these are not continually re executed.
the third insight is that the system needs to convey the complete execution including all intermediate results and make it easy for the programmer to navigate within these results.
this is primarily for debugging where the programmer will need to followthe execution and understand where and when problems occurred but is also useful in writing new code.
providing the complete execution simplifies navi gation over time for debugging making the result non ob trusive since the programmer will not have to do that much work to get back to the state they last looked at before an edit.
java already has a form of live programming through the ability to hot swap code in most modern debuggers .
to use this feature the user edits the code and then saves it.
execution then goes back to the start of the current routine and the user can proceed normally.
while this is helpful it is often problematic inpractice as discussed below.
one of our goals was to provide an implementation framework that ca n provide the benefits of hot swapping without the problems.
the first problem is that th e hot swapping operation often fails.
the code has to be error free.
the changed code cannot addor remove any fields or methods or change any method or field signatures.
any routine that has changed can not be executing in an other thread or recursively in the current thread.
changes to static field values are not propagated.
such failures are common when trying to use hot swapping.
moreover on ce hot swapping fails it is difficult to continu e. our approach handles all these changes either automatically or with minor user intervention for example when a new field needs a non default value for existing objects .
the second problem is that the point where execution continues changes from the current stopping point to the start of the method or in some cases the start of some prior method.
the user has to step or continue the execution to the point of interest.
our approach tracks the current position in the execution and automatically restores it after an edit.
a third problem is that hot swapping is not idempotent.
if execution of the function makes a change to the environment or parameters during one execution that change persists when the execution restarts making the re execution different.
we deal with this by executing outside the actual environment.
a fourth problem is that hot swapping execution affects the outside environment.
it re executes external i o each time causing multiple occurrences of output and requiring the user to reenter input each time.
we address these through an i o model forthe console and files.
hot swapping also has problems with synchronization.
for example do ing a hot swap while holding a lock does not release the lock.
this is true both for java synchronization locks and for user defined locks.
with our approach locksare only maintained within the simulation not in the original program.
a fifth problem is that hot swapping cannot be used easily to work on problems involving grap hics.
stopping in a paint routine implies stopping the graphics thread.
changes to graphics are not visible until the graphics thread resumes and control returns to the system routines.
changes to a routine setting up a widget cannot be seen until the overall window has been setup and thegraphics thread runs.
using a graphics model our approach is able to show the intermediate graphics results for both these cases.
related work the idea of providing immediate execution feedback while coding was central to spreadsheet programming introduced by visi271 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
seede simultaneous execution and editing in a development environment ase september montpellier france calc .
the idea was picked up for more traditional p r o g r a m m i n g b y v i s i p r o g a n d m o r e r e c e n t l y i n t h e e g extension to eclipse .
these are both illustrated on simple programs and do not scale to real systems nor do they address the much more complex problems posed by real systems with complex data structures external methods and concurrency.
v i c t o r i n h i s t a l k o n l i v e c o d i n g d e m o n s t r a t e d a s a m p l e framework and challenged the audience to create a real one .
since then there have been numerous attempts at providing similar functionality including an experimental mode of the python tutor choc jsfiddle and schuster s work for javascript eve lambu for haskell unison and liveweave and chickenfoot for web applications among others.
most of these ar e designed for si mple programs not large existing systems.
a more extreme version of live programming involves using examples to create code directly.
this can be seen in the various programming by example systems that have been developed over the years .
more recent examples combine examples with live programming .
the approach is also being used effectively for database interactions using continuous queries and in interactive data exploration tools .
there have been several studies on how programmers debug and on what tools and techniques might be helpful for debugging .
these tend to show that the type of assistance provided by seede can be helpful.
since many of the examples cited for continuous execution are effectively test cases this work is also related to early efforts to integrate testing with code writing as in tinker and more recent efforts involvin g continuous testing .
the work is also related to incremental execution and continuous and incremental program analysis .
a number of systems over the years have been capable of showing a full execution and letting the user move backward orforward in time within that execution.
exdams was perhaps theearliest example .
early graphical environments such as pecan let the user step either forward or backward .
the algorithm animation system balsa provided a time slider similar to the one we offer .
more recent debuggers that include similar features include totalview elm s time traveling debugger and the trace oriented debugger .
ko s whyline provided similar capabili ties in a question answering framework .
recent interest in this area involves time travelor omniscient debugging .
dynamic updating of data structures has been used for maintaining long running applications.
th is involves taking updates and modifying the existing system to use the new code .
these require the programmer to identify safe points for update and concentrate more on migrating object implementations from one version to the other.
while some of these technologies are useful most of them are too heavy weight to be used continuallywhile the programmer is editing.
dynamic object updating has also been at the center of schema updates for object oriented database systems .
our approach uses appropriate techniques from these system to simulate object migration where necessary.
the use of models for simulating the external environment is called mocking and is used in some testing environments .
sandboxing of files is also used extensively for security purposes .
4e x a m p l e u s e in this section we give an example of the use of seede for debugging.
we note the tool can also be used for writing new code in much the same way.
the code bubbles tutorial program is a simulation of the romp toy consisting of a pendulum with a magnet moving chaotically over a surface with movable magnets.
the tutorial includes several tasks involving fixing the display output notably to change the color of the magnets and to center the output on the magnet correctly.
this is difficult to do in the debugger because changes to the graphics parameters are not immediately visible and the exact changes are not obvious.
to use seede on the example we start by setting a breakpoint at th e start of the drawing routine for the board and then start a debugging run up to that breakpoint.
then we right click to bring up the default pop up menu and select start continuous execution .
at this point seede starts the continuous execution process.
after about seconds the initial run is slow because code and debugger data needs to be loaded the system populates the various components of the continuous execution bubble with the resultant values as shown in fig.
1a.
the default view provided is a hierarchical view containing variables and their values from the simulated execution similar to a debugger display.
the scroll bar at the bottom of the displaylets the user scroll over time in the execution.
green areas in the scroll bar represent code in the current method gray areas represent code in called methods.
as the user scrolls the variable values change accordingly and the disp lays at the top left corner are updated to show call stack.
a special variable line shows the current line number at that point.
this line is also highlighted in any editor that is open and includes the method as seen in fig.
1h.
for our example since we are concerned with drawing the magnets we slide the time scroller to the gray area representing one of the drawmagnet calls and then right click to select that context.
this could also have been done using the call graph or stack view.
we next right click again to have seede bring up the corresponding source.
since the top level routine is a paint routine seede includes a graphics panel showing the paint result as computed by inter preter in fig.
1c.
we find the code that sets the color to green and change the reference to red.
wi thin half a second the graphics output changes accordingly.
changing the offset for the and tokens is more complex.
we find the drawstring calls and try out different delta values.
as before immediately after we have set a new value we can see the result.
we eventually find the proper deltas for the token and then repeat the process for the token.
the final results can be seen in fig.
1d.
implementation seede runs as a separate process talking to both an interface within the code bubbles system bicex and to code bubbles eclipse based back end through a messaging interface as seen in fig.
.
it takes requests from code bubbles and sends execution updates back to it asynchronously as they become available.
it uses the back end to query the values of variables tounderstand the java environment and to detect changes both to the execution and to files being edited.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellie r framce s. reiss qi xin j. huang while seede could be made to work with any existing programming environment we found it simplest to make the protot y p e w o r k w i t h c o d e b u b b l e s .
c o d e b u b b l e s m a d e i t e a s y t o create a new display that did not interfere with or take space away from existing displays.
it simplified determining what files the programmer is working on si nce it maintains the programmer s current working set including all relevant source code editors.
the existing message interfaces made it easy to implementthe system as a separate process which facilitated debugging and experimentation and ensured that the system did not interfere with the actual environment.
seede consists of five main co mponents.
the first is a controller that handles all communication and starts and stops thesimulated execution as needed.
the second is a file manager that maintains the current contents of all active files and updates their abstract syntax trees as they change.
the third is a set of three figure views of the continuous execution display bubble.
the main view a shows the variables in the current context.
the methods used in the current context are shown in a call graph or tree view b or in a stack view d .
graphics output for underlying or user selected component can be displayed c and d .
variable dependencies for a user selection is available f as is the output to files or the console g .
the in terface also coordinates with the code bubbles editor h .a variable view showing time slider and values b call graph view of execution c initial graphical output window d graphical output after editing e stack view f data view showing variable dependencies g file output view h editor view showing highlighted line and tool tips authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
seede simultaneous execution and editing in a development environment ase september montpellier france interpreters one for abstract syntax trees to handle code that is or could be edited one for byte code to handle library and other static code and one to handle na tive methods and special cases.
these interpreters utilize the fourth component a value cache that tracks all values over time .
the final component is a suite of models that reflect the external environment.
the seede architecture is engineered to meet the requirements of section .
the architecture is designed to be fast enough to re execute as the user types.
it is capable of restarting execution on each edit.
it minimizes the amount of information that needs to be sent back for display purposes.
the implementation isa simulation that starts with the environment at a breakpoint and values from the debugger are cached.
values are then only changed in the simulation ensuring idempotency.
the simulatoruses the eclipse parser to generate valid abstract syntax trees in the face of errors and detects both syntactic and semantic errors that need to stop execution.
finally by effectively recompiling and reexecuting all changed files it can handle a wide range of edits including adding new fields variables methods classes etc.
the use of models enables it to handle i o and graphics opera tions within the simulator without affecting the external environment.
details of the essential de sign decisions are outlined below.
.
the controller the first component is the controller.
the controller monitors messages both from eclipse via the code bubbles plug in and from code bubbles itself to maintain a set of execution environments each defined by a stopped debugging run.
the controller uses the message interface to determine the threads that are stopped and crea tes an internal execution for these threads without any additional user input.
it assumes thatthe execution has stopped at the beginning of the stopped func tion s .
the system still works if this assumption is not valid i.e.
the user stopped the method with a breakpoint in the middle provided that none of the values relevant to the execution of the function was yet affected i.e.
the function is idempotent up to the stopping point .
for each execution environment the controller tracks the set of files that are active and controls the simulated execution.
theset of active files is maintained automatically by bicex by monitoring changes to the user s working set that contains the seede display a functionality provided by code bubbles.
when the exe cution completes the result is sent asynchronously via the messaging interface to code bubbles and the displays are updated accordingly.
the controller monitors messages from eclipse indicating that a file has been edited.
if th e file is one of those associated with a simulated execution that execution is stopped if it is run ning the changed file is updated the project is recompiled using the change and the execution is restarted.
multiple edits are grouped when possible.
the controller handles requests from code bubbles including changing the initial value of va riables adding variables to be viewed as graphical components.
removing executions whenthey are no longer needed expanding the set of sub values of a value and returning the dependencies of a variable at a particular location.
.
the file manager the file manager is responsible for tracking the current state of all active files and building resolved abstract syntax trees for each execution environment as the fi les change.
compilation is handled using the eclipse java parser to build abstract syntax trees and the fast and forgiving compiler from the open source s6 system to resolve these trees ag ainst other current files and the rest of the project.
.
the interpreters the next component is a combination of three interpreters thatwork off the same value base and the same global clock.
the first is an interpreter for abstract syntax trees that is used for code that the user can change.
the second is an interpreter for byte codes that is used for library methods as well as parts of the system which are not being edited.
the third is an interpreter to handle special cases such as native methods.
the abstract syntax tree interpreter uses the resolved abstract syntax trees generated by the fi le manager.
this interpreter is error tolerant and lets the simulation work without the need to save files or do code generation which could be expensive.
the byte code interpreter uses asm to load class files from the class path.
this interpreter lets seede run real programs that use libraries without their source and to efficiently execute those parts of a larger program the user is not working on.
both inter preters update the special variable line to show the currently executing line.
the special case interpreter is us ed to handle code that cannot be directly interpreted for example native methods to dealwith code that affects the outsid e world and to make the overall process more efficient.
several classes notably string class and file are handled as internal objects rather than run time objects.
strings are handled this way for efficiency classes are handledbecause the interpreter has its ow n type model that needs to be updated dynamically files are handled to accommodate the file model described in section .
the special case interpreter runs in place of the byte code interpreter for specific classes and methods.
where it is possible for example the various native math and string routines the method is handled by appropriate code in the interpreter itself.
in some cases for example hash codes the system will query thefigure overview of the seede architecture.
seede runs as a separate process that talk s to both code bubbles and eclipse.
seede itself consists of components.
the control ler manages the communications and execution.
the filemanager tracks the active files and handles recompilation.
three interpreters are combined to do the simulation one for editable code one for compiled code and one for special cases.
the value cache maintains values over the whole run.
the modeler provides models of graphics files synchronization and i o to mimic the external environment.
eclipse plugin code bubbles bicex controllerseede modeler file manager interpreter value cache authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellie r framce s. reiss qi xin j. huang debugger for an appropriate value.
for other cases the interpreter invokes methods in a small library seede installs in the user s process.
this is used for example to get information aboutresources from a class loader.
all three interpreters utilize a common clock that increments with each write a common run time stack for each interpretedthread and a common context for looking up variables by name or reference.
the choice of which interpreter to use is determined at the start of each method call.
.
the value cache the fourth component in the seede framework is a value cache.
one of seede s innovations is that it returns the complete evaluation.
the value cache is designed to facilitate this by maintaining all values over time.
a simplified version of the cache is then sent to code bubbles where it is used as the basis for the various displays.
the value cache starts with a set of base values which can represent the java primitive types the types that are managedinternally string class and file and generic types for arrays and objects.
the cache also defines a reference value which is a map that yields the actual value of the reference at any particular time.
each variable in the interpreter as well as each field of an object and each element of an a rray is assigned such a reference value.
in addition to these explicit values the value cache provides latent values that can refer to arbitrary expressions or nested variables in the debugger.
when a value from the debugger is accessed the information returned only includes the top levels of any nested structures.
any deeper