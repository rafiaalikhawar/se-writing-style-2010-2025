igen dynamic interaction inference for configurable software thanhvu nguyen ugur koc javran cheng jeffrey s. foster adam a. porter university of maryland college park usa tnguyen ukoc javran jfoster aporter cs.umd.edu abstract to develop analyze and evolve today s highly con gurable software systems developers need deep knowledge of a system s con guration options e.g.
how options need to be set to reach certain locations what con gurations to use for testing etc.
today acquiring this detailed information requires manual e ort that is di cult expensive and error prone.
in this paper we propose igen a novel lightweight dynamic analysis technique that automatically discovers a program s interactions expressive logical formulae that give developers rich and detailed information about how a system s con guration option settings map to particular code coverage.
igen employs an iterative algorithm that runs a system under a small set of con gurations capturing coverage data processes the coverage data to infer potential interactions and then generates new con gurations to further re ne interactions in the next iteration.
we evaluated igen on programs spanning ve languages the breadth of this study would be unachievable using prior interaction inference tools.
our results show that igen nds precise interactions based on a very small fraction of the number of possible con gurations.
moreover igen s results con rm several earlier hypotheses about typical interaction distributions and structures.
ccs concepts software and its engineering !software testing and debugging software con guration management and version control systems dynamic analysis keywords program analysis software testing con gurable systems dynamic analysis .
introduction modern software systems are increasingly designed to be con gurable.
this has many bene ts but it also greatlycomplicates tasks such as testing debugging and impact analysis because the total number of con gurations can be very large.
to carry out such tasks developers must take advantage of task speci c structure in a system s con guration space.
for example a developer may observe that many con gurations are the same in terms of the coverage they achieve under a test suite and thus developers can perform e ective testing using just a small set of con gurations.
in prior work we showed how to automatically infer interactions that concisely describe a system s con gurations.
our focus is coverage and we formally de ne aninteraction to be a formula over con guration options such that a any con guration satisfying covers some locationlunder a given test suite and b is the logically weakest such formula i.e.
if also describes con gurations coveringlthen .
thus by knowing a system s interactions a developer can determine useful information about con gurations e.g.
given a location determine what con gurations cover it given an interaction determine what locations it covers nd important options and compute a minimal set of con gurations to achieve certain coverage etc.
in the literature feature interactions and presence conditions section are similar to interactions and can explain functional e.g.
bug triggers memory leaks and non functional e.g.
performance anomalies power consumption behaviors.
interactions can also aid reverse engineering and impact analysis .
while our prior work was promising it has signi cant limitations.
in our rst e ort we inferred interactions using otter a symbolic executor for c .
however symbolic execution does not scale to large systems even when restricted to con guration options is brittle in the presence of frameworks libraries and native code and is language speci c. in our second e ort we developed itree which infers interactions using dynamic analysis and machine learning.
however itree s focus is on nding con gurations to maximize coverage and in practice it only discovers a small set of interactions.
section discusses these prior systems in more detail.
in this paper we introduce igen a new dynamic analysis tool for automatically discovering a program s interactions.
igen works by iteratively running a subject program under a test suite and set of con gurations inferring potential interactions from the resulting coverage information and then generating new con gurations that aim to re ne the inferred interactions on the next iteration.
by carefully choosing new con gurations in this last step igen is able to quickly converge to a nal precise set of interactions using permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
only a small set of con gurations.
moreover igen s design overcomes the limitations of otter and itree.
the only language speci c portion of igen is obtaining code coverage which is widely available for almost any language.
igen s analysis is also very lightweight and scalable because as we explain later it uses simple computations over coverage information to infer interactions.
finally although we did not mention it earlier our prior work was restricted to inferring interactions that are purely conjunctive.
in contrast igen supports interactions that are purely conjunctive purely disjunctive and speci c mixtures of the two.
section describes igen in more detail.
we evaluated igen by running it on programs far more than we were ever able to use with otter or itree.
our subject programs span ve languages c perl python haskell and ocaml range in size from tens of lines to hundreds of thousands of lines and have between and con guration options.
for most programs we apply igen to run time con guration options but for one program httpd we study compile time con guration options.
section describes our subject programs.
we considered three research questions.
first we evaluated the correctness of igen s inferred interactions.
we found that for a subset of the subject programs the interactions produced by igen s iterative algorithm are largely similar to what igen would produce if it inferred interactions from all possible con gurations.
this suggests igen does converge to the optimal solution.
we also manually inspected a subset of the interactions found by igen and veri ed they match the logic in the code.
second we measured igen s performance and found it explores a very small fraction of the number of possible con gurations.
moreover like the work of reisner et al.
igen generates dramatically more precise interactions than itree.
yet it runs in a small fraction of the time required for reisner et al.
s experiments.
finally we analyzed igen s output to learn interesting properties about the subject programs.
we con rmed several results found in prior work among them the number of interactions is far smaller than what is combinatorially possible yet a few very long interactions are needed for full coverage and enabling options which must be set a certain way to achieve most coverage are common.
we should emphasize that our prior work hypothesized these based cumulatively on just four programs in one language whereas we observe them based on programs in ve languages.
we also observed new phenomena that disjunctive and mixed interactions are less common than conjunctive ones but nonetheless cover a non trivial number of lines.
finally we showed that igen s interactions can be used to compute a small set of con gurations that cover all or most lines of the programs.
section reports on our evaluation.
we believe igen takes an important step forward in the practical understanding of con gurable systems.
.
igen algorithm we begin our presentation by describing the igen algorithm whose pseudo code is shown in figure .
the input to igen is a program pand a test suite t and the output is a set of interactions for locations in pthat were covered when running on t. igen works by iteratively generating a set of con gurations con gs in the algorithm until the coverage cov and interactions ints inferred from that setinput a program pand a test suite t output a set of interactions of p 1cov ints 2con gs onewaycoveringarray fdefault con gg 3whiletruedo oldcov cov oldints ints cov ncov runtestsuite p t con gs returns cov l fcjccoverslg ncov l fcjcdoes not cover lg foreach locationl2covdo conj t cov l disj t ncov l disj0 t fcjc2ncov l c conjg conjdisj conj disj0 conj0 t fcjc2cov l disj cg disjconj disj conj0 ints l conj disj conjdisj disjconj ifcov oldcov ints oldintsthen break con gs gennewconfigs ints 19foreach locationl2covdo ints l check ints l cov l result l selstrongest ints l 22return result figure igen s iterative algorithm for inferring program interactions.
reach a x point.
the algorithm begins on line by initializing con gs to a randomly generated way covering array i.e.
it contains all possible settings of each individual option.
the algorithm also includes a default con guration if one is available.
in our experience such a con guration typically yields high coverage under the test suite and hence is a useful starting point.
on line igen runs the test suite under the current set of con gurations 1producing two coverage maps covmaps each location lto the set of con gurations csuch that at least one test covers lunderc and ncov mapslto the set of con gurations that do not cover l. then for each location lcovered by the test suite under some con guration line igen infers candidate interactions.
although in theory interactions can be arbitrary formulae igen keeps its inference process e cient by assuming interactions follow particular syntactic templates .
as it iterates igen computes the most precise interaction for each location for each template.
at the end of the algorithm igen selects thestrongest in a logical sense interaction per location across the di erent templates.
currently igen supports four templates conj a purely conjunctive interaction disj a purely disjunctive interaction conjdisj a conjunctive interaction where the last conjunct is a disjunct and disjconj a disjunctive interaction where the last disjunct is a conjunct.
we explain the computation of the interactions in detail below.
this particular set 1in practice igen memoizes the coverage information from previous runs and only runs the test suite under the new con gurations.
options s t u v x y z int max z if x y f printf l0nn x y if !
z z max z f printf l1nn x y z2f0 4g g gelsef printf l2nn x y g printf l3nn true if u v f printf l4nn u v if sjjt f printf l5nn u v s t g g figure program with seven con guration options.
locations l0 l5 are annotated with associated interactions.
of templates was chosen partially based on our experience e.g.
we believe conjunctive interactions are very common and partially based on what is e cient to compute e.g.
mixing one disjunction into a conjunction or vice versa is a relatively small cost whereas more complex interleavings of conjunctions and disjunctions would be much less e cient.
after saving candidate interactions line the loop terminates if igen has reached a x point line .
otherwise igen creates additional con gurations line designed to re ne interactions details below and continues iteration.
after the main loop terminates there are two steps remaining.
first because of some heuristics in igen s interaction generation some interactions it computes may not actually cover the expected lines.
thus on line igen iterates through the set of interactions and checks that for any interaction forl it is actually the case that c for all con gurations cthat coverl.
igen eliminates any interaction that fails this check by setting it to true.
second on line igen sets result l to be the logically strongest interaction among conj disj conjdisjm and disjconj .
if there is no single strongest interaction igen eliminates any interactions that are weaker than another and returns the conjunction of the remaining strongest interactions.
running example.
we next use the c program in figure to explain the details of igen.
this program has seven con guration options listed on the rst line of the gure.
the rst six options are boolean valued and the last one z ranges over the set f0 4g.
thus this program has possible con gurations.
the code in figure includes print statements that mark six locations l0 l5.
at each location we list the associated desired interaction.
for example l1 is covered by any conguration in which xandyare true and zis or .
as another example l3 is covered by any con guration hence its interaction is true.
prior approaches to interaction inference are not su cient for this example.
the work of reisner et.
al only supportsconjunctions so it must approximate the interactions for l1 l2 andl5.
itree actually produces no interactions for this example because all lines are covered by itree s initial two way covering array itree stops generating interactions when no new coverage is achieved .
for this example igen initializes con gs to the following covering array there is no default con guration con gs t u v x y z coverage c1 l2 l3 l4 c2 l0 l1 l3 c3 l2 l3 l4 c4 l0 l1 l3 l4 c5 l2 l3 l4 l5 we list the coverage of each con guration on the right.
conjunctive interactions.
the rst interaction template conj supports conjunctions of membership constraints x2s indicating option xranges over set s. for example the interaction for l1in figure is shorthand for x2f1g y2 f1g z2f0 4g .
on line of the algorithm igen infers conj by taking the pointwise union of the covering con gurations option settings and then conjoining them.
we denote this operation by t .
for example the table below shows the pointwise union of the two covering con gurations c2andc4.
here is the universal set for an option.
l1s t u v x y z c21 c40 union thus to form conj c2t c4forl1we simply conjoin the option settings from the above table to yield conj x y z2f0 3g where we write xandyforx2f1gand y2f1g.
note we omit constraints corresponding to since those indicate options that can take any value.
at this point conjis close to but not quite the correct interaction for l1.
the problem is that con gs is missing a con guration where x y 1andz .
thus skipping over the other templates and other locations for the moment for the next iteration igen generates additional con gurations tore ne the set of interactions using the gennewcon gs call on line .
igen derives these new con gurations by systematically changing the settings from one selected interaction from ints.
for example gennewcon gs might generate new con gurations from interaction conjto yield con gs t u v x y z coverage c6 l2 l3 c7 l2 l3 c8 l0 l3 c9 l0 l3 c10 l0 l1 l3 here each con guration disagrees with conj x y z2 f0 3g in one setting e.g.
c6has x c7has y andc8 hasz .
then the next iteration of the x point loop will compute conjforl1fromc2 c4 andc10.
sincec10has x y 1andz which was not covered in the rst set of con gurations igen produces the correct interaction x y z2f0 4g .
in practice we could choose any interaction for any line and use it to generate new con gurations.
currently igen s 657heuristic is to choose the longest current interaction based on our prior experience suggesting long interactions are uncommon and hence likely to be inaccurate.
if there is a tie for longest interaction igen selects randomly among the longest.
if igen selects an interaction that does not fully constrain some con guration options then it assigns random values satisfying whatever constraint in present to those options when creating new con gurations.
disjunctive interactions.
next let us consider the interaction x yforl2in figure .
by construction conjcannot encode this formula although the membership constraints inconjare a form of disjunction e.g.
z2f0 3gis the same asz 0 z they cannot represent disjunctions among di erent variables.
there are a variety of potential ways to infer more general disjunctions but we want to maintain the same e ciency as inferring conjunctive interactions.
to motivate igen s approach to disjunctions observe that l2 s interaction arises because an else branch was taken.
in fact l2 s interaction is exactly the negation of the interaction for l0 from the true branch.
thus igen computes disjunctive interactions by rst computing a non covering interaction which is a conjunctive interaction for the con gurations that do notcover line l2 and then negates it to get a disjunctive interaction forl2 line .
in our running example c2andc4are the only con gurations that do not cover l2 thus igen computesc2t c4 x y z2f0 3g .
negating that yields disj x y z2f1 4g which is close to the correct interaction for l2.
notice this approach to disjunctions is a straightforward extension of conjunctive interaction inference.
also notice that it is heuristic since the computed interaction may not actually cover the given line thus disjunctive interactions may be eliminated on line of the algorithm in figure .
disjunctive interactions can be re ned in two ways.
first they may be re ned by coincidence if gennewcon gs selects a long conjunctive interaction to re ne.
second gennewcongsalso considers the negation of disjas a possible longest interaction to use for re nement essentially re ning an interaction describing con gurations that do not reach the current location .
mixed interactions.
finally some interactions require mixtures of conjunctions and disjunctions such as the interaction u v s t forl5.
looking at figure notice this interaction occurs because a disjunctive condition is nested inside of a conjunctive condition in fact the interaction for l5 is the interaction for l4 with one additional clause.
this motivates igen s approach to inferring mixed interactions by extending shorter interactions.
lines give the code for computing conjdisj .
recall that to compute the pure disjunction disj igen negates the pointwise union of non covering con gurations.
on line we use the same idea to compute disj0 but instead of allnon covering con gurations we only include the non covering con gurations that satisfy conj.
essentially we are projecting the igen algorithm onto just con gurations that satisfy that interaction.
thus when we infer the disjunction disj0 we conjoin it onto conj to compute the nal mixed interaction.
for our running example after several iterations conjfor l5will beu v details not shown .
out of the con gurations that do not cover l5 onlyc1 c3 andc4also satisfy u v.thus disj0will be c1t c3t c4 s t u v z2f0 4g .
thus after some simpli cation we get conj disj0 u v s t z2f0 4g which is almost the interaction for l5.
after further iteration igen eventually reaches the nal fully precise interaction for l5.
using the dual of the above approach lines infer another mixed interaction disjconj by extending the computed disjunctive interaction disjwith a conjunction conj0.
here conj0is generated just like conj but we only include con gurations that disagree in some setting with some clause ofdisj since otherwise the con guration is already included in the left side of the disjunct on line .
notice that igen s approach for inferring mixed interactions maintains the e ciency of computing pure conjunctions and disjunctions.
we could extend the algorithm further to compute conjunctions with nested disjunctions with nested conjunctions etc.
but we have not explored that yet.
lastly in addition to considering conjand disjas potential longest interactions gennewcon gs also considers conj and negated disj .
thus mixed interactions may be re ned whenever one of those four components is re ned.
discussion.
putting this all together after running to completion igen produces the same interactions for our example as in the comments in figure .
moreover igen nds these interactions by analyzing just con gurations instead of possible con gurations.
the experiments in section show that igen analyzes an even smaller fraction of the possible con gurations on programs with a large number of con guration options.
as mentioned above igen has several sources of randomness the one way covering array the interaction used for generating new con gurations and the values of un or underconstrained option settings in those new con gurations.
thus igen is actually a stochastic algorithm that may produce slightly di erent results each time.
however in our experiments we demonstrate that the variance is reasonable.
moreover the computation of each iteration of igen is straightforward and e cient.
pointwise union is linear in the number of con gurations and options.
checking the various implications is done with an smt solver which is very e cient in practice.
as discussed in section .
igen s running time is mostly consumed by running the test suite line .
finally notice that if igen were to iterate until it had generated allcon gurations then it would be guaranteed to produce correct interactions if they fall under the given templates.
for example suppose some location lhas a purely conjunctive interaction x y. then if we consider the set of allcon gurations that cover l they all satisfy x y but the set has con gurations that di er in every possible way for options that are not xandy.
thus pointwise union of this set will yield xandyastrue and every other option as .
hence igen must produce the correct interaction x y. similar arguments follow for the other interaction templates.
in section .
we take advantage of this observation to help evaluate the correctness of igen s inferred interactions.
.
subject programs igen is implemented in approximately lines of python.
it uses the z3 smt solver to reason about implications.
we computed line coverage using gcov for c python cov for python and mdevel cover for perl.
we computed 658table subject programs.
prog lang ver loc opts cspace tests id c .
uname c .
cat c .
mv c .
ln c .
date c .
join c .
sort c .
ls c .
p id perl .
p uname perl .
p cat perl .
p ln perl .
p date perl .
p join perl .
p sort perl .
p ls perl .
cloc perl .
ack perl .
grin python .
.
pylint python .
.
hlint haskell .
.
pandoc haskell .
.
unison ocaml .
.
bibtex2html ocaml .
gzip c .
httpd c .
.
vsftpd c .
.
ngircd c .
.
expression coverage using bisect for ocaml and hpc for haskell.
our experiments were performed on a .40ghz intel xeon cpu with gb ram running redhat enterprise linux .
bit .
the source code for igen is available at https bitbucket.org nguyenthanhvuh igen.
programs.
table lists our subject programs.
for each program we list its name language version and lines of code as measured by sloccount .
note that the line count is typically higher than the number of locations reachable by the test suite.
we also report the number of con guration options opts and the total number of possible con gurations cspace .
finally we list the number of test cases in the program s test suite.
the rst group of programs comes from the widely used gnu coreutils.
these programs are con gured via commandline options.
we selected a subset of coreutils with relatively large con guration spaces at least con gurations each .
the second group comprises coreutils reimplemented in the perl power tools ppt project excluding mvwhich was not implemented in ppt .
these programs are named as the coreutils programs but with a pre x of p .
the third group contains an assortment of programs to demonstrate igen s wide applicability.
brie y cloc is a lines of code counter ackand grinare grep like programs pylint and hlint are static checkers for python and haskell respectively pandoc is a document converter unison is a le synchronizer bibtex2html converts bibtex les to html gzipis a compression tool and nally httpd is the well known apache http server.
cumulatively these programs span ve languages two programs per languages and range from afew thousand to hundreds of thousands of lines.
the last group comprises vsftpd a highly secure ftp server and ngircd an irc daemon.
these programs were also studied by reisner et al.
who used otter a symbolic execution tool to exhaustively compute all possible program executions under all possible settings of certain con guration options.
to make a direct comparison to reisner et al.
s work possible we ran igen on these programs in a special mode in which rather than running a test suite we used otter s output as an oracle of which lines are reachable under which con gurations.
configuration options.
we selected con guration options for study in a variety of ways.
we studied all options for coreutils.
most of these options are boolean valued but nine can take on a wider but nite range of values all of which we included e.g.
we include all possible formats date accepts.
we omit options that range over an unbounded set of values.
for ppt we studied the same options as coreutils when available though ppt only supports a small subset of coreutils options.
for the programs in the third group we used the run time options for httpd the compile time options we could get working correctly.
for example we excluded httpd options that caused compiler errors when we changed them.
we ignore options that can take arbitrary values e.g.
pylint options that take a regexp or python expression as input.
most of the options we selected are boolean valued but several range over a nite set of values e.g.
we consider seven highlight options for formatting in pandoc and three permission modes for modifying les in unison .
we used the same options for vsftpd and ngircd as reisner et al.
to make a direct comparison possible.
test suites.
we manually created tests for coreutils that cover common command usage.
for example for cat we wrote tests that read a text le a binary le a non existent le results piped from other commands etc.
we used the same tests for coreutils and ppt.
for the third group of programs test selection varied.
for httpd hlint pylint and bibtex2html we used the default tests.
for the remaining programs we started from the default tests which were relatively limited and added more tests to cover basic functionality.
.
evaluation we consider three research questions r1 correctness does igen generate correct interactions?
r2 e ciency what are igen s performance characteristics?
r3 analysis what can we learn from inferred interactions?
to investigate these questions we applied igen to the subject programs described in section .
table summarizes the results and reports the medians across runs and their variance2as the semi interquartile range siqr .
for each 2recall from section that igen uses randomness so di erent runs may produce slightly di erent results.
659table igen s results for the benchmark programs shown in table .
numbers in regular font are medians across runs.
numbers in small font are semi interquartile ranges measuring variance among the runs.
time s interactions prog con gs cov search total conj disj mix total id uname cat mv ln date join sort ls p id p uname p cat p ln p date p join p sort p ls cloc ack grin pylint hlint pandoc unison bibtex2html gzip httpd vsftpd ngircd program columns con gs and covshow the number of congurations igen created and the number of locations covered by these con gurations respectively.
the next two columns show igen s running time in seconds total is the total time and search is the time excluding the time to run the test suite.
the remaining columns list the number of inferred interactions divided into conjunctive conj disjunctive disj and mixed interactions mix with the cumulative sum on the right total .
the low siqr for inferred coverage and interactions indicate igen produces relatively stable output across runs.
.
rq1 correctness exhaustive runs.
to measure the correctness of the inferred interactions we rst evaluated whether igen produces the same results with its iterative algorithm as it could produce if it used all con gurations.
recall from section that running igen with all con gurations is guaranteed to nd correct interactions if they match our templates so this essentially gives us ground truth with respect to the test suite.
to perform this evaluation we selected the fourteen programs with the smallest con guration spaces and ran one loop of igen with con gs figure initialized to the set of all con gurations.
we also used exhaustive symbolic execu table comparing igen to exhaustive runs.
prog cov f score id .
uname .
cat .
mv .
ln .
date .
join .
vsftpd .997prog cov f score p id .
p uname .
p cat .
p ln .
p date .
p join .
p sort .
ngircd .
tion information for vsftpd and ngircd to simulate igen running with all con gurations of those programs.
table shows these comparisons.
the second column cov reports the di erences between the number of lines covered by igen s regular runs and those covered by the exhaustive runs.
overall we see igen generates interactions with coverage very similar to the exhaustive runs.
in total igen missed one line injoinand two lines in p date .
we investigated and found these three uncovered lines are guarded by long conjunctive interactions.
for example igen missed join.c which is guarded by an interaction with conjuncts.
column f score measures the accuracy of igen s runs compared to the exhaustive runs using a balanced f score 660which ranges between and with representing perfect agreement.
in more detail the f score is based on comparing for every location whether settings in the interaction for that location match between the standard and exhaustive runs.
notice this is a very strict test.
table shows that igen generates mostly the same interactions for most programs as the exhaustive runs.
we investigated the two outliers p date and p join and found the low f scores are due to two factors.
first these programs have few interactions for p date and for p join so a few di erences cause a large score change.
second igen almost but does not quite infer the right interactions which still results in an f score penalty.
for example for p date instead of inferring the correct interaction g d r iso8601 igen infers the less precise interaction g d. similar nearmatches account for most of the f score di erences of the remaining programs e.g.
in ngircd igen generates several mixed interactions where it should generate conjunctive interactions.
manual inspection.
we also manually analyzed the program source code to make sure certain interesting or nonobvious interactions generated by igen are correct.
we focused on coreutils because these programs are small enough for careful manual inspection and they allow for interesting comparisons to ppt.
forp uname igen discovers an interaction a mcovering the line uname.pl which prints the machine name.
this interaction thus speci es correctly that the machine name is printed when given either option aorm.
igen also discovers other similar interactions for p uname including a o which prints the operating system name a nto print the hostname etc.
for the corresponding uname command igen found similar but longer interactions such as help verbose a m which prints the machine name but only when help and verbose are not given note these options are not supported by ppt .
we refer to options like helpasenabling options since they must be set a certain way to achieve signi cant coverage.
notice also that this is a mixed interaction which cannot be inferred by our prior work.
another interesting interaction igen found is a t t e v covering line cat.c ofcat.
reviewing the source code we found this line is only executed when the global variables showtab and shownonprinting are false and true respectively.
further examination reveals that showtab is false by default but any of options a t ortcause it to be true thus all of these options must not be given to cover the considered line.
moreover shownonprinting is only true when either e t v or aset thus one of these options must be given to cover the considered line.
putting this logic together and simplifying yields the interaction igen discovered.
we were surprised that for uname igen generates a purely conjunctive interaction containing the negation of all options.
inspection of the source code reveals this is correct one line of code is only invoked when no options are given.
interestingly p uname does not have this interaction and indeed does not behave as uname when run with no options.
finally we investigated the cases of non zero siqrs in table and found that most di erences involve disjunctions.
for example of uname runs found the interaction a s n r v m p i o help version by taking a shorter conjunctive interaction e.g.
i a help version modifying its settings yielding among others i a help iterations normalized f scoreid uname cat mv ln date join figure progress of igen on generating interactions for gnu coreutils programs.
version and randomly assigning remaining options to get a s n r v m p i o help version which is then negated.
while igen performs random assignment for many di erent short interactions the chance of getting that exact conjunction are still low overall and in of uname runs igen misses that interaction.
in general non zero siqrs arise from lower probability events like this.
.
rq2 performance table shows that for most programs igen s running time is dominated by running the test suite.
thus programs with larger con guration spaces tend to take longer because igen has to create more con gurations to analyze these programs.
nonetheless comparing to table we see that igen scales well to large programs because it only explores a small fraction of the total possible number of con gurations.
interestingly table shows the number of explored con gurations is not directly proportional to the con guration space size.
for example lshas eight orders of magnitude more possible con gurations than sort but igen only explores .
more con gurations.
we believe that igen represents a good trade o between correctness and e ciency compared to previous work.
on the one hand igen generates more con gurations and hence is slower than itree.
for vsftpd and ngircd igen generates and con gurations respectively while itree creates around con gurations each .
however igen generates much more precise interaction information itree reports only interactions for vsftpd and interactions for ngircd compared to igen s and interactions respectively.
on the other hand igen runs dramatically faster than the experiments by reisner et al.
which took two weeks to analyze just a few programs using a specialized cluster.
moreover although igen is not guaranteed to produce precise interactions the results discussed in section .
suggest igen is as precise as reisner et al.
s work in practice.
convergence.
figure shows how igen converges to its nal results on a subset of coreutils.
the x axis is the iteration count normalized such that represents all iterations for that particular program and the y axis is the f score compared to the exhaustive runs.
these results show that igen converges fairly quickly.
after approximately of 661table comparing random search to exhaustive runs.
prog cov f score id .
uname .
cat .
mv .
ln .
date .
join .
vsftpd .58prog cov f score p id .
p uname .
p cat .
p ln .
p date .
p join .
p sort .
ngircd .
the iterations igen s f score has reached .
or more.
this suggests an igen user could potential cut o iteration early and still achieve reasonable results.
igen s convergence relies critically on gennewcon gs figure line generating useful con gurations.
table demonstrates this by showing igen runs on randomly selected con gurations.
more speci cally for each program in table we generated the same number of random con gurations as the number of con gurations igen used .
we also include the default con guration if it exists.
we next ran the igen main loop once on these con gurations to compute the results and then compared coverage information and f score to the exhaustive runs.
comparing to table we see igen generates much more precise interactions and has better coverage than random search.
the di erences are most signi cant for larger programs e.g.
the most extreme case is ngircd where random search has f score .
and covers fewer lines than exhaustive run while igen has f score .
and has the same coverage as the exhaustive run.
.
rq3 analysis we analyzed igen s results in detail to learn interesting properties of the subject programs.
in the following an interaction s length is the number of options it contains.
disjunctive and mixed interactions.
we observe that many programs require non conjunctive interactions.
table shows that approximately of the inferred interactions are disjunctions or mixed interactions.
furthermore the analysis in section .
shows that mixed interactions though rare do exist in real world software.
thus these interactions which were omitted from prior work are important.
interaction length and coverage.
in prior work we observed that the total number of interactions found is far fewer than the number of possible interactions .
we observe the same trend in table .
for example p cat has7 binary options yielding 128possible con gurations and at least possible interactions.
however igen nds four interactions which is less than of4373.
the same trend can be seen throughout the table.
we also observed in prior work that longer conjunctive interactions tend to contain shorter conjunctive interactions 3it is more typical to refer to this as the strength of an interaction.
however in our setting longer conjunctive formulae are logically stronger than shorter conjunctive formulae but longer disjunctive formulae are logically weaker than shorter disjunctive formulae.
hence we use length to avoid confusion.e.g.
ifa b c d eis an interaction it is likely that a shorter formula like a bis an interaction .
we manually examined igen s interactions and found that this pattern also holds.
for most programs conjunctive interactions of length at least three include a shorter interaction.
this is likely due to nested guards e.g.
such as the interaction on l5 of figure but with a non disjunctive inner condition.
table looks at the interactions in more detail by showing the number of interactions igen infers and the covered lines at each interaction length.
the last column max reports the length of the longest interaction.
we observe that the maximum interaction length for most programs is significantly smaller than the number of con guration options.
however there are ve programs id uname cat p join and httpd that have interactions that include all options.
we discussed the uname case in section .
.
although some non trivial coverage is achieved by large interactions e.g.
conjunctions of all options of the coverage is obtained by interactions of length less than three.
these observations are similar to our prior work .
one exceptional case is ack in which most coverage is achieved by large interactions.
investigating further we found ackhas many options that must be disabled for most of its functionality to be exercised.
enabling options.
in addition to the enabling option help mentioned for uname and the enabling options just mentioned for ack we found many other examples of enabling options including the following.
for id option zmust be disabled for most coverage because that option is only applicable to a secured linux kernel .
for httpd option enablehttpmust be enabled for almost all coverage and enable so which allows for shared modules must be enabled for a majority of the coverage.
for vsftpd disabling ssland local and enabling anon are important to coverage.
finally for ngircd options listenipv4 and conf predefchannelsonly are important to coverage.
notice these results depend on the test suite and environment.
for example an enabled option zforidcould be useful on a secured kernel and sslforvsftpd can be enabled when running with ssl certi cates.
this shows how igen naturally adapts the inferred interactions to the current setting.
minimal covering configurations.
finally we used inferred interactions to compute a minimal set of con gurations that achieve the full coverage found by igen.
to do so we used the following greedy algorithm.
given a set of interactions we rst remove any interactions implied by others.
for example if x yandxare interactions we remove x because a con guration satisfying x ywill also satisfy x. next we randomly conjoin interactions whose conjunction is satis able e.g.
we combine x yandz wto yield x y z w .
this operation is greedy because it tries to combine as many compatible interactions as possible.
finally we generate con gurations that are compatible with the combined interactions thus producing a small set of congurations that covers the same locations as the interactions.
note that this algorithm may not produce an optimal result but in practice it is e ective.
table summarizes the results.
for each program we list the full con guration space from table and the size of the minimal con guration set computed with our algorithm again the coverage of these sets are similar as those as shown 662table number of interactions and covered lines per interaction length.
results are medians of runs.
prog max id uname cat mv ln date join sort ls p id p uname p cat p ln p date p join p sort p ls cloc ack grin pylint hlint pandoc unison bibtex2html gzip httpd vsftpd ngircd table using igen s interactions to compute minimal covering con gurations.
min prog cspace cspace id uname cat mv ln date join sort ls p id p uname p cat p ln p date p join 4min prog cspace cspace p sort p ls cloc ack grin pylint hlint pandoc unison bibtex2html gzip httpd vsftpd ngircd in table .
our results show that the minimal con guration set is dramatically smaller than the full con guration space.
in prior work we found similar results we constructed a minimal line covering set of con gurations for vsftpd and for ngricd .
we believe the small di erences between those results and table are due to igen supporting richer interactions and randomness in the greedy algorithm.
.
threats to validity like any empirical study our conclusions are limited by potential threats to validity.
as a result our ndings may not generalize in certain ways or to certain systems.in this work we examined several subject systems covering a range of di erent sizes from to 238k lines of code written in ve di erent languages.
although each of these systems is realistic and widely used the whole set of systems represents only a sample of all possible software systems.
in addition we focused on subsets of con guration options the number of options was substantial but we did not include every possible option as discussed earlier.
another potential threat is that igen relies on running test suites to draw its conclusions.
the test sets we used have reasonable but not complete coverage.
individually the test cases tend to focus on speci c functionality rather than combining multiple activities in a single test case.
in that sense they are more like a typical regression suite than a customer acceptance suite.
systems whose test suites are less or more complete could have di erent results.
finally igen misses interactions that are not in one of the forms discussed in section .
however from table we see that interactions with disjunctions are much less common than those solely composed of conjunctions.
hence we speculate even more complex interaction forms are uncommon.
we intend to explore each of these issues in future studies.
.
related work there are several threads of related work.
interaction discovery.
as discussed earlier reisner et al.
use the symbolic executor otter to fully explore the con guration space of a software system and extract interactions from the resulting information.
in that work interactions were limited to conjunctions while igen supports much richer interaction templates.
moreover while symbolic 663execution is powerful it su ers major limitations.
first experience shows it has limited scalability.
for example the otter experiments required several days on a large cluster and analyzed only a few programs.
in contrast table shows that igen is much more e cient.
second symbolic executors are language speci c e.g.
otter could not be applied to c or haskell.
in contrast the only language speci c tools igen relies on are code coverage tools which are easy to use and widely available for many languages.
finally symbolic execution is very hard to apply to programs that use frameworks libraries and or native code.
typically symbolic execution users must replace these parts of a system with painstakingly developed stub code that implements the functionality in a more symbolic executor friendly way.
needless to say this process is time consuming error prone and hard to maintain as systems evolve.
as also discussed earlier to address some limitations of otter we developed itree which uses dynamic analysis and machine learning techniques to generate a set of con gurations that achieve high coverage.
itree works by constructing an interaction tree where each node of the tree is a formula and conjoining the formulae on a path from the root to a node yields a potential interaction.
however while itree does infer some interactions its main goal is to achieve high coverage.
as a result as we saw in section .
itree does not actually infer very many or very useful interactions.
moreover as with otter itree s interactions are limited to conjunctions although itree has some support for membership like constraints to improve e ciency.
feature interactions and presence conditions.
the concepts of feature interactions and presence conditions are similar to our use of interactions .
th um et al classify problems in software product line research and surveys existing static analysis to solve them.
our use of interactions belongs to the feature based classi cation and we propose a new dynamic analysis to generate them.
apel et al study the number of feature interactions in a system and their e ects including bug triggering power consumption etc.
our work complements these results by studying interactions that a ect line or expression coverage.
lillack et al use language speci c taint analysis to nd interactions in android applications.
in contrast igen uses a dynamic analysis that is language agnostic but potentially unsound .
nadi et al and von rhein et al propose tools that work with presence conditions that are already provided.
in contrast igen discovers interactions.
czarnecki and pietroszek check for well formness errors in uml featured based model templates using an sat solver.
we intend to explore smt based techniques to verify correctness of igen s inferred interactions.
combinatorial interaction testing.
many researchers have explored combinatorial interaction testing cit a family of techniques for testing a program under a systematically generated set of con gurations.
one particularly popular approach is called t way covering arrays which given an interaction strengtht generate a set of con gurations containing all t way combinations of option settings at least once.
over last years many studies have focused on improving the speed quality and exibility of covering arrays .
however as pointed out in fouche et al.
because developers must choose ta priori andbecause generating covering arrays quite expensive developers will often set tto be small causing higher strength interactions to be ignored.
invariant generation.
interactions can also be considered invariants that hold at particular locations i.e.
speci c option must have speci c settings whenever execution reaches that location.
thus igen can be seen as a likely invariant generator that works for one particular class of invariants those restricted to con guration options and with speci c forms quanti er free expressions involving only equalities and certain conjunctions and disjunctions .
other researchers have proposed general purpose invariant generators.
daikon is a well known dynamic invariant generation system that works by hypothesizing many potential invariants and then using run time monitoring to eliminate those that do not hold.
daikon includes a large list of invariant templates.
dig is a more recent invariant generator that supports more expressive invariants including nonlinear arithmetic disjunctive polynomials and relations among arrays .
dysy is another invariant generator that uses symbolic execution for invariant inference .
igen di ers from daikon dig and dysy in three main ways.
first igen can compute potentially long disjunctive invariants very e ciently via pointwise union and negation .
in contrast daikon requires users to provide splitting conditions to nd disjunctive invariants such as ifcthenaelseb and dig uses complex and expensiveto compute convex hulls to represent disjunctions.
dysy is bounded by the limitations of symbolic execution the language speci city and the di cult of analyzing frameworks libraries and native code.
second daikon dig and dysy do not attempt to search for more executions to re ne invariants.
finally igen tries to nd interactions for every location while previous work only considers speci c locations e.g.
loops and function entrance and exit to reduce run time overhead.
.
conclusion we presented igen a new lightweight approach to infer interactions which are formulae that describe the con gurations covering a location.
igen discovers interactions by running the subject program under a set of con gurations to determine coverage information computing the pointwise union of various sets of covering and non covering con gurations and then combining the resulting formulae to produce an interaction.
igen repeats this process iteratively re ning the set of con gurations until no new coverage is achieved and no new interactions are produced.
we applied igen to programs written in ve di erent languages and demonstrated that igen infers precise interactions it does so using a small fraction of the number of possible con gurations igen con rms several observations made by prior work and the disjunctive and mixed interactions inferred by igen occur with nontrivial frequency.
we believe igen takes an important step forward in the practical understanding of con gurable systems.
.