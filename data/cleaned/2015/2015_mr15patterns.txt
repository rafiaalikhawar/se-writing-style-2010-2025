king s research portal .
.
document version peer reviewed version link to publication record in king s research portal citation for published version apa maoz s. ringert j. o. .
gr synthesis for ltl specification patterns.
acm.
citing this paper please note that where the full text provided on king s research portal is the author accepted manuscript or post print version this may differ from the final published version.
if citing it is advised that you check and use the publisher s definitive version for pagination volume issue and date of publication details.
and where the final published version is provided on the research portal if citing you are again advised to check the publisher s website for any subsequent corrections.
general rights copyright and moral rights for the publications made accessible in the research portal are retained by the authors and or other copyright owners and it is a condition of accessing publications that users recognize and abide by the legal requirements associated with these rights.
users may download and print one copy of any publication from the research portal for the purpose of private study or research.
you may not further distribute the material or use it for any profit making activity or commercial gain you may freely distribute the url identifying the publication in the research portal take down policy if you believe that this document breaches copyright please contact librarypure kcl.ac.uk providing details and we will remove access to the work immediately and investigate your claim.
download date .
aug. 2025gr synthesis for ltl specification patterns shahar maoz school of computer science tel aviv university israeljan oliver ringert school of computer science tel aviv university israel abstract reactive synthesis is an automated procedure to obtain a correct by construction reactive system from its temporal logic speci cation.
two of the main challenges in bringing reactive synthesis to software engineering practice are its very high worst case complexity for linear temporal logic ltl it is double exponential in the length of the formula and the di culty of writing declarative speci cations using basic ltl operators.
to address the rst challenge piterman et al.
have suggested the general reactivity of rank gr fragment of ltl which has an e cient polynomial time symbolic synthesis algorithm.
to address the second challenge dwyer et al.
have identi ed ltl speci cation patterns which are common in industrial speci cations and make writing speci cations easier.
in this work we show that almost all of the ltl specication patterns identi ed by dwyer et al.
can be expressed as assumptions and guarantees in the gr fragment of ltl.
speci cally we present an automated sound and complete translation of the patterns to the gr form which e ectively results in an e cient reactive synthesis procedure for any speci cation that is written using the patterns.
we have validated the correctness of the catalog of gr templates we have created.
the work is implemented in our reactive synthesis environment.
it provides positive promising evidence for the potential feasibility of using reactive synthesis in practice.
categories and subject descriptors d. .
design tools and techniques general terms languages design keywords linear temporal logic synthesis speci cation patterns1.
introduction reactive synthesis is an automated procedure to obtain a correct by construction reactive system from its temporal logic speci cation .
rather than manually constructing a system and using model checking to verify its compliance with its speci cation synthesis o ers an approach where a correct implementation of the system is automatically obtained for a given speci cation if such an implementation exists.
in the case of reactive synthesis an implementation is typically given as an automaton that accepts input from the environment e.g.
from sensors and produces the system s output e.g.
on actuators .
by construction the input and output assignments of every in nite run of the automaton satisfy the speci cation it was synthesized from.
two of the main challenges in bringing reactive synthesis to software engineering practice are its very high worst case complexity for linear temporal logic ltl it is double exponential in the length of the formula and the di culty of writing declarative speci cations using basic ltl operators.
to address the rst challenge piterman et al.
have suggested the general reactivity of rank gr fragment of ltl which has an e cient polynomial time symbolic synthesis algorithm.
gr is a strict assume guarantee subset of ltl comprised of constraints for initial states safety propositions over the current and successor state and justice constraints ji i.e.
assertions about what should hold in nitely often .
intuitively if the assumptions e e andje iare satis ed by the environment the system has to satisfy the guarantees s s andjs i i.e.
valid runs satisfy e g e i jgfje i !
s g s i kgfjs i gr synthesis has been used in various application domains and contexts including robotics scenario based speci cations aspect languages and event based behavior models to name a few.
to address the second challenge dwyer et al.
have identi ed ltl speci cation patterns which are common in industrial speci cations and make writing speci cations easier.
the patterns are organized by kind e.g.
absence or existence of properties and are ordered by scope e.g.
globally or before.
their semantics is de ned by a mapping to basic ltl formulas.
an example pattern of kind existence with scope between is poccurs between qandr wherep q andrare parameters of the pattern which can be instantiated with non temporal propositions.
this pattern is this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... 96forkliftcontroller boolean atstation distance obstacle distance cargo motorcmd lmot motorcmd rmot liftcmd lift figure a forklift and its controller component forkliftcontroller numbered p09 and its semantics expressed in ltl according to is q !r !r w p !r in this work we show that almost all of the ltl speci cation patterns identi ed by dwyer et al.
can be used as assumptions and guarantees in the gr fragment of ltl.
speci cally we present an automated sound and complete translation of the patterns to the gr form which e ectively results in an e cient reactive synthesis procedure for any speci cation that is written using the patterns.
technically the translation starts from the ltl formula of the pattern translates it to a minimal deterministic b uchi automaton dbw if one exists and then translates the automaton to a gr assumption or guarantee formula while possibly adding auxiliary variables to the gr synthesis problem.
in case no dbw exists the pattern is not supported.
critical to the usefulness of our approach is that the costly translation of ltl to dbw is done only once for every pattern.
in fact we have already done it and saved the result as a set of templates inside our synthesis tool.
this works because patterns are instantiated only with propositions not with nested temporal operators .
we further show that patterns can even be instantiated with past ltl formulas but not with nested future temporal operators.
to summarize our contribution our work answers the following three questions is gr expressive enough to support the dwyer et al.
patterns which are well recognized as common in industrial speci cations?
can the translation be done automatically and correctly ?
and what s the extra cost of it e.g.
in number of auxiliary variables ?
to answer the rst two questions we have implemented and automated the translation and our ndings show that of the patterns from the original work of dwyer et al.
can be expressed as assumptions and guarantees in the gr fragment.
thus we have indeed embedded the results of the translation into our reactive synthesis environment.
moreover as our translation is complete our work shows that the remaining patterns are indeed not expressible as assumptions or guarantees in the gr fragment by our approach.
to answer the third question our pattern representation in gr requires at most auxiliary variables per pattern instance.
this gives an upper bound for the complexity of a gr synthesis problem where patterns are used as assumptions or guarantees.
note that this is a very satisfying result since based on the translation via a dbw one could enum motorcmd fwd stp bwd enum liftcmd lift drop nil enum distance close far figure enumeration datatypes of inputs and outputs of component forkliftcontroller expect in the worst case an exponential number of auxiliary variables per pattern.
the remainder of this paper is structured as follows.
in sect.
we start with a running example.
sect.
provides required formal background on ltl and gr .
sect.
presents the main technical contribution of our work i.e.
the translation from ltl speci cation patterns to equivalent expressions in the gr fragment.
sect.
describes the implementation and sect.
presents our results.
the paper concludes with a discussion in sect.
related work in sect.
and future work in sect.
.
.
running example we start o with a running example adapted from our speci cation of a lego forklift shown in fig.
see .
the forklift has sensors one sensor to determine whether it is at a station and two distance sensors to detect obstacles and cargo.
it also has motors to turn the left and right wheels and to lift the fork.
values read by the sensors are provided as inputs to component forkliftcontroller and its outputs are commands controlling the motors.
all inputs and outputs are typed e.g.
the input obstacle has type distance .
the datatypes are de ned as enumerations in fig.
.
an engineer speci es the behavior of the forklift controller to synthesize an implementation.
a simple safety guarantee is that if the forklift detects an obstacle both motors are stopped see ll.
in listing .
another part of the speci cation is the liveness guarantee to always eventually deliver cargo expressed as lift drop in ll.
.
a property more complicated to express in pure ltl is that the forklift has to leave its pick up station between lifting and dropping cargo.
the engineer expresses this guarantee for the controller in ll.
using a higher level speci cation pattern instantiated with values read by the sensors.
a second engineer assists in de ning assumptions on the environment of the forklift.
one assumption is that going forward with both motors will lead to reaching a station unless the motors are not going forward anymore see pattern used in ll.
.
it turns out that in order to satisfy this assumption an adversary environment can prevent the forklift from reaching a cargo station by presenting obstacles forcing the forklift to stop ll.
.
hence an additional assumption for a well behaved environment is added by the engineers in the given setting it is reasonable to expect that between two stations the forklift may be blocked by obstacles at most twice.
this assumption is expressed using another speci cation pattern shown in ll.
of listing .
the patterns used by the engineers in the forklift speci cation are ltl speci cation patterns as identi ed by dwyer et al.
.
their formal semantics in ltl taken from 1note that this is a real lego robot that we have built.
we use our synthesis tool and code generation to run it.
97specification 1guarantee always stop if detect obstacle g obstacle close lmot stp rmot stp 4guarantee keep on delivering cargo gf lift drop 7guarantee be not at station before delivery !
atstation occurs between lift lift and lift drop p09 11assumption forwarding leads to station globally lmot fwd rmot fwd leads to atstation !
lmot fwd rmot fwd p26 15assumption at most blocked twice after !
atstation have at most two obstacle close until atstation p15 listing excerpt of a speci cation for the forklift controller is given in eqn.
below.
however most importantly for our work is that these ltl formulas are not written in the syntactically restricted fragment of gr .
poccurs between qandr q !r !r w p !r globallypleads toq p q afterqhave at most two puntilr q !p !r u r p !r u r !p !r u r p !r u r !p w r p the engineers are interested in using e cient gr synthesis to obtain a correct by construction controller for the forklift robot one which satis es all guarantees if all assumptions are satis ed by the environment.
can a speci cation including these patterns be written in a way that allows the application of gr synthesis?
our work gives a positive answer to the above question.
indeed we show that all patterns used in the speci cation of the forklift in listing and actually almost all patterns from see sect.
can be translated to the gr fragment.
the translation is fully automated and requires the addition of auxiliary boolean variables to the synthesis problem a total of variables in our example.
although the translation time may be double exponential in the length of the formula we have already done it o line so that the patterns are added to our speci cation language and their instantiation in a given speci cation takes constant time in our tool.
as an example the gr representation of pattern p09 eqn.
requires two auxiliary variables to encode a new variable sand is shown in listing in smv like syntax as used by our implementation.
.
preliminaries we repeat some of the standard de nitions of b uchi automata and linear temporal logic ltl e.g.
as found in .
b uchi word automata are nite automata that accept in nite words over a nite alphabet.
de nition .
a b uchi automaton is a tuple b q i f where smv 1var auxiliary variables states of dbw s s1 s2 bot 3init initial assignments initial state s s1 5trans safety this and next state s s1 lift drop atstation lift !
lift x s s1 s s1 lift !
drop !
atstation lift lift x s s2 s s2 lift !
drop !
atstation x s s2 s s2 lift drop x s bot s s2 lift !
drop atstation x s s1 s bot true x s bot 14ltlspec justice part accepting states g f s s1 s s2 listing the instance of ltl speci cation pattern p09 from listing ll.
written in gr smvlike syntax as used in our implementation qis the set of states is the alphabet q qis the transition relation i qis the set of initial states f qis the set of repeated states b uchi condition a b uchi automaton is deterministic a dbw i jij and8q u jfq0s.t.
q u q0 gj .
a b uchi automaton is complete i 8q u9q0 q u q0 .
an accepting run of bon a word u0u1 !is a sequenceq0q1 of states from qsuch thatq02i 8i qi ui qi and some q2fappears in nitely often in the run.
the set of words accepted by bis denotedl b .
we now repeat the de nition of ltl a modal temporal logic with modalities referring to time.
ltl allows engineers to express properties of executions of reactive systems.
the syntax of ltl formulas is typically de ned over a set of atomic propositions apwith the future temporal operators x next and u until and the past time temporal operators y previous and s since .
de nition .
the syntax of ltl formulas over apis pj j jx j u jy j s forp2ap.
for 2apa computation u u0u1 !is a sequence whereuiis the set of atomic propositions that hold at the i th position.
for position iwe useu ij to denote that holds at position i inductively de ned as u ij pi p2ui u ij i u i6j u ij 1 2i u ij 1oru ij u ij x i u i 1j u ij 1u 2i 9k i u kj 2and 8j i j k u jj u ij y i u i 1j u ij 1s 2i 9k k i u kj 2and 8j k j i u jj we denote u 0j byuj .
additional ltl operators are de ned as abbreviations of the above f trueu nally g f globally 1w 1u g weak until h trues historically 98ltl formulas can be used as speci cations of reactive systems where atomic propositions are interpreted as environment input and system output variables.
an ltl speci cation is realizable if a fairness free automaton b uchi automaton without acceptance condition exists such that all runs of the automaton are accepted by .
this automaton is called a controller.
the goal of ltl synthesis is given an ltl speci cation to nd a controller that realizes it if such a controller exists.
gr synthesis handles a fragment of ltl where speci cations contain assertions over initial states safety constraints relating the current and next state and justice goals requiring that an assertion holds in nitely many times during a computation.
a gr synthesis problem is de ned as a game between a system player and an environment player with the following game structure x input variables controlled by the environment youtput variables controlled by the system eassertion overxcharacterizing initial states of the environment sassertion overx y characterizing initial states of the system e x y x transition relation of the environment s x y x y transition relation of the system gfje!gfjswinning condition as implication between justice goals jeof the environment and jsof the system.
the game has a winning strategy for the system i.e.
the system player can always win following this strategy i the following ltl speci cation gis realizable g e!
s e!g h e !
s e g e!
speci cations for gr synthesis have to be expressible in the above game structure and thus do not cover the complete ltl.
e cient symbolic algorithms for gr realizability checking and controller synthesis have been presented in .
.
from ltl specification patterns to gr we are now ready to present the main technical contribution of our work i.e.
the translation from ltl speci cation patterns to equivalent expressions in the gr fragment if such an expression exists.
the main idea of our approach is to translate the ltl formula of a speci cation pattern to a dbw if such dbw exists.
we then translate the dbw to an ltl formula in the gr fragment.
this translation may add auxiliary variables.
this approach enables us to use existing algorithms for gr synthesis to solve the syntactically enriched synthesis problem of speci cations containing ltl speci cation patterns as assumptions and guarantees.
we show that our translation if dbws for all patterns exist is correct for the synthesis problem realizing the speci cation e g e i jgfje i j i m e i !
s g s i kgfjs i k i n s i s1 s2 r p !q !r !
p q !r !p!r ps1 s2 true rfigure dbw for the ltl speci cation pattern p09 in eqn.
where e s e and sare in the gr fragment je iare jjustice assumptions js iarekjustice guarantees e iare m jltl speci cation patterns used as assumptions and s iaren kpatterns used as guarantees.
in our running example the speci cation shown in listing is represented in the above format where the rst guarantee l. is a conjunct of s the second guarantee l. is ajs i the pattern of the third guarantee ll.
is a s i and the two patterns used as assumptions ll.
appear as two e i. we show the translation prove its correctness and discuss the time complexity for solving the synthesis problem using existing algorithms which depends on the auxiliary variables added during our translation.
.
translation our translation of the speci cation given in eqn.
combines two constructions from a for solving the gr implication speci cation i.e.
eqn.
without ltl speci cation patterns e iand s i and b for solving the implication speci cation between dbws with additional variables representing their states.
construction a adds two boolean monitor variables sfe observing historical satisfaction of e and e and sfs observing sand s the justice assumption gfsfe and the justice guarantee gfsfs .
intuitively this construction turns safety violations into justice violations.
we apply a directly to eqn.
without the patterns e iand s i which are handled by b .
construction b adds variables representing the states of each complete dbw its initial states transitions and acceptance condition to the game construction .
to apply construction b we rst translate each ltl speci cation pattern into a corresponding dbw if such a dbw exists for the pattern and then transform this dbw into the initial safety and justice constraints for the construction of the gr game.
the problem of translating an ltl formula into a dbw if one exists is well studied and algorithms and tools are available .
as an example the ltl speci cation pattern in eqn.
has a corresponding dbw with three states shown in fig.
.
we now show how to translate a dbw into the parts required for the gr construction.
.
.
dbw2gr1 construction given a dbwb q fqig f with alphabet 2x ywe obtain an ltl formula in the gr fragment over the alphabet 2x y vwherexandyare sets of boolean input and output variables resp.
and vis a set of auxiliary boolean variables added by the translation to encode the states of the dbw.
our translation creates using three subformulas where encodes the initial state 99smv 1var auxiliary variables states of dbw s s1 s2 bot 3init initial assignments initial state s s1 5trans safety this and next state s s1 r p !q x s s1 s s1 !r !p q x s s2 s s2 !r !p x s s2 s s2 r x s bot s s2 !r p x s s1 s bot true x s bot 12ltlspec justice part accepting states g f s s1 s s2 listing output of dbw2gr1 for the dbw of the ltl speci cation pattern p09 in eqn.
shown in fig.
encodes the transition relation as safety properties over the current and next state and jencodes the acceptance condition of the dbw as a justice constraint.
the injective function mapv q!2vmaps states of the dbw to valuations of the auxiliary variables introduced by the translation.
formally varvis set ofk dlog2jqjefresh boolean variables init mapv qi trans q u q0 mapv q u x mapv q0 justice j q2fmapv q the ltl formula that characterizes the acceptance of the dbwb ifor 2fe sgresulting from the pattern i is the conjunction i i g i gfj iobtained from the translation above.
note that this translation from dbw to gr is linear in the size of the dbw.
in our running example the dbw shown in fig.
which represents the pattern p09 is translated to a formula with the structure of iin the gr fragment as shown in listing in the smv like syntax used by our implementation.
the rst part of the translation creates a set of auxiliary variables to represent the states of the dbw.
in listing we use a single variable s l. for better readability instead of two boolean variables encoding the values of s. the translation part init sets the initial assignment of the auxiliary variable encoded in l. to represent the initial state of the dbw from fig.
.
the part trans lists the transition relation as constraints over current state current input and next state g encoded in ll.
.
finally the acceptance of the dbw is translated in part justice to the disjunction of always eventually visiting one of the accepting states gfjencoded in l. .
note that the result of dbw2gr1 as shown in listing is a template where variables p q and rcan be instantiated with non temporal assertions.
this is the same instantiation mechanism used for the original ltl patterns.
.
.
game construction the game for gr synthesis based on this translation combining constructions a and b has the following structure for speci cations as shown in eqn.
x0 x y0 y f sfe sfsg s j i mve i s k i nvs i e true s e sfe s sfs v j i m e i v k i n s i e true s e sfe xsfe s sfs xsfs v j i m e i v k i n s i gfsfe gfje v j i mgfje i !
gfsfs gfjs v k i ngfjs i we use the gr synthesis algorithm of to solve this game.
theorem below states that a winning strategy for the system player in the above game indeed implements the speci cation in eqn.
and that such a strategy is found if it exists.
note that for each speci cation pattern the translation above depends on the existence of a dbw for the pattern.
some ltl formulas cannot be expressed as a dbw and our translation thus handles only a subset of ltl.
as we show in sect.
almost all ltl patterns from do have a corresponding dbw and hence are supported by our translation.
.
translation correctness for two words w2 !andv2 2v !we denote as w v2 2v !the word where w v i wi vi.
lemma dbw2gr1 is correct .given a complete dbw b the ltl formula g gfjresulting from the translation in sect.
.
is in the gr fragment and satis es 8w2 !
w2l b 9v2 2v !
w vj .
proof.
by construction andjhave no temporal operators and uses only the next operator so is in the supported gr fragment.
we show bidirectional acceptance !
8w w0w1 !
w2l b the dbw has by de nition of determinism a unique run q q0q1 2q!with qi q0and8i qi wi qi .
forv2 2v !with 8i vi mapv qi we have w vj by construction and de nition of v0.
analogously 8i qi wi qi yields w v ij thus w v j g .
since some qi2f appears in nitely often in the run qit is encoded in nitely often invand thusw vj gfj.
given8w w0w1 !
9v2 2v !
w vj fromw vj we know that map v v0 qiand from 8i w v ij we know that vmust encode an in nite runqofbwith8i qi map v vi and qi wi qi .
due to determinism of band injectiveness of mapvthe run is unique and exists i w v j g .
since the run is unique from w v j gfjwe know that a state in fofbis visited in nitely often and bacceptsw.
theorem .
given a speci cation in the form of eqn.
where e iand s ican be translated into dbws our construction synthesizes a controller implementing the speci cation if one exists.
proof.
the correctness of construction a is shown in thm.
.
the correctness of construction b is shown in .
the proof of b requires completeness and determinism of the b uchi automata.
the dbw we use are complete and in lemma we showed that our translation from sect.
.
correctly represents the dbw in the gr fragment.
.
complexity analysis it is known that the worst case time complexity for the synthesis of a controller for an open reactive system from a general ltl speci cation is double exponential in the length of the input formula i.e.
in o 22j j .
in contrast the worst case time complexity of synthesizing a controller for a gr speci cation is in o nmn2 wherenandmare the number of justice goals of the environment and system players respectively and nis the size of the state space.
since we use gr synthesis the algorithm s complexity is not changed.
however our construction increases the state space for the algorithm.
instead of a state space n of sizeo 2jxj jyj wherexandyare the sets of boolean environment and system variables we have a state space of sizeo 2jxj jyj jvj wherejvjis the total number of additional auxiliary variables.
each supported pattern may add a justice goal to either m orn anddlog2jqjevariables where qis the set of states of the dbw corresponding to the pattern.
in general the size of a dbw corresponding to an ltl formula if one exists may be double exponential in the length of the formula .
thus the number of variables added per pattern is in the worst case exponential in the length of the pattern.
most importantly however this high worst case complexity does not apply to the ltl patterns of .
our results presented in sect.
show that of these patterns have a corresponding dbw with at most states the remaining patterns do not have a corresponding dbw at all so only at most variables need to be added for each of these patterns.
.
implementation .
overview we have implemented the translation dbw2gr1 and set up a toolchain to check for all patterns from whether they can be supported by our approach and at what cost in terms of auxiliary variables and provide fully automated support of patterns in our gr synthesis environment.
the cost of supporting an ltl speci cation pattern in gr synthesis following the translation in sect.
.
depends on the size of the dbw found for .
given a pattern we are thus interested in a smallest dbw representing it.
however the smallest dbw is not necessarily unique and dbw minimization is np hard .
given the high cost of obtaining a gr representation of an ltl pattern we decided to do this computation ofine i.e.
independent of the instantiation of a pattern and the speci cation it is used in.
this works because patterns are only instantiated with non temporal propositions in sect.
.
we second this limitation and show that they can be instantiated also with past ltl formulas and their gr representations can thus be used as templates.
thus the output of applying our toolchain to the patterns from is a catalog of gr templates available from together with the dbw2gr1 tool.
when preparing a pattern based ltl3dra dbaminimizer dbw2gr1 ltl specification pattern template for gr synthesis dra spot ltlfilt ltl dbw support unknown pattern not supported fail no checking correctness of toolchain output using nusmvfigure the toolchain we have used per pattern to create the gr templates the dashed parts are used for validation see sect.
.
speci cation for synthesis we do not need to recompute the translation of each pattern to an equivalent gr formula but only to look up the gr template that corresponds to the pattern in the catalog.
below we give additional details about the toolchain we have used to create the catalog.
.
toolchain to decide whether an ltl speci cation pattern can be supported and to nd the minimal dbw we use a combination of tools.
fig.
shows our toolchain.
the input is an ltl speci cation pattern and the output is either a template for synthesis in gr format a negative result that no such template exists or an indeterminate result that the existence of such a template is unknown.
we start with the tool ltlfilt ofspot to syntactically preprocess the ltl formula of the pattern to a format readable by the next tool ltl3dra .
we use ltl3dra to compute a deterministic rabin automaton drw from an ltl formula.
ltl3dra is a competitor of ltl2dstar that often yields smaller drw for ltl formulas e.g.
when trying the two tools we saw that a drw for pattern p45 found by ltl2dstar version .
.
with ltl3ba has states while a drw for the same pattern found by ltl3dra has states.
both tools rely on heuristics to create smaller drws.
next given a drw we use dbaminimizer to determine whether a corresponding dbw exists and to nd a minimal one.
dbaminimizer uses a sat solver to nd a minimal dbw.
finally we feed the minimal dbw found by dbaminimizer to our tool dbw2gr1 to obtain a template for instantiating ltl speci cation patterns in gr speci cations as described in sect.
.
.
.
results and observations table presents our main result of the patterns of are supported by our approach.
the cost per supported pattern instance is at most auxiliary variables.
the remaining patterns p23 p50 and p55 do not have a corresponding dbw.
the table contains all ltl patterns from grouped by kind e.g.
absence or existence and ordered by scope second column e.g.
globally or before following the classi cation presented in .
for each pattern we report the length third column of the ltl formula that de nes the semantics of the pattern number of characters including spaces e.g.
p01 de ned as !p has length .
the fourth column of the table reports the number of states of a minimal dbw for the pattern if one exists and n.a.
otherwise the fth indicates whether the minimal dbw has a sink state a complete dbw without a sink state expresses a pure liveness 101table the ltl speci cation patterns from with ltl formula length number of states of minimal dbw whether dbw has a sink and number of auxiliary variables in gr template.
ltl dbw dbw gr p scope j jmin jqjsink?
jvj absence p is false p01 globally p02 before r p03 after q p04 between q and r p05 after q until r existence p becomes true p06 globally p07 before r p08 after q p09 between q and r p10 after q until r bounded existence p states occur at most times p11 globally p12 before r p13 after q p14 between q and r p15 after q until r universality p is true p16 globally p17 before r p18 after q p19 between q and r p20 after q until r precedence s precedes p p21 globally p22 before r p23 after q n.a.
n.a.
n.a.
p24 between q and r p25 after q until r response s responds to p p26 globally p27 before r p28 after q p29 between q and r p30 after q until r precedence chain s t precedes p p31 globally p32 before r p33 after q p34 between q and r p35 after q until r precedence chain p precedes s t p36 globally p37 before r p38 after q p39 between q and r p40 after q until r response chain p responds to s t p41 globally p42 before r p43 after q p44 between q and r p45 after q until r response chain s t responds to p p46 globally p47 before r p48 after q p49 between q and r p50 after q until r n.a.
n.a.
n.a.
constrained chain s t without z responds to p p51 globally p52 before r p53 after q p54 between q and r p55 after q until r n.a.
n.a.
n.a.property .
finally the last column reports on the number of auxiliary variables necessary to support the pattern following our dbw2gr1 construction described in sect.
.
some examples of the ltl patterns and the gr templates we have computed for them are detailed in table .
based on this table our synthesis tool accepts speci cations with assumptions and guarantees written using patterns as shown in the second column of the table and automatically instantiate them in a form that allows gr synthesis based on the template in the fourth column.
list.
is an example of a speci cation handled by our environment.
.
unsupported patterns the three ltl patterns where a dbw does not exist are theprecedence pattern p23 with scope after q and ltl semantics !q q !p w s theresponse chain pattern p50 with scope after q until rand ltl semantics q p !r u s !r x !r u t u r p s x t and theconstrained chain pattern p55 with scope after q until r and ltl semantics q p !r u s !r !z x !r !z u t u r p s !z x !z u t .
it is important to note however that these three patterns which we cannot support are among the least frequent patterns according to the survey reported in .
speci cally out of pattern instances examined in only one was in the form of p23.
the other two patterns p50 and p55 are listed in in order to make the matrix of pattern scope combinations complete but in the survey of were not found at all.
this further strengthens the positive promising nature of our results.
.
validation the correctness of the gr templates resulting from ltl patterns relies on a toolchain with four tools of which some are prototypical implementations and proofs of concept.
these may have bugs or we might have used them incorrectly.
it is thus advised to validate the correctness of the generated gr templates.
to address this we have implemented a correctness check that takes the original ltl pattern and the generated gr template augments it for veri cation and automatically checks correctness using the model checker nusmv .
we generate two checks for each generated gr template.
the rst check asserts the equivalence of the satisfaction of the generated justice formulajand the satisfaction of the original ltl semantics of the pattern with gr representation g gfj.
by construction of our translation see e.g.
list.
this check relies on the assignments to auxiliary variables in the blocks init encoding and trans encoding g .
the construction of for supporting a dbw in gr speci cations requires that the dbw is complete i.e.
that the automaton has an enabled transition for every source state and input.
we thus generate a second check which asserts that all combinations of values assigned to variables representing the parameters of the pattern are accepted in every state of the automaton de ned in the generated gr template.
initially our validation reported incorrect templates for three out of the supported patterns and their sup102ported negations see sect.
.
speci cally for pattern p51 and the negations of p15 and p42.
inspection revealed incorrect translation by ltl3dra .
for at least out of the provided ltl formulas ltl3dra produced an incorrect drw!
this issue appears in version .
.
used for our experiments and persists in version .
.
of ltl3dra .2to bypass this bug in ltl3dra we reran all nonvalidated ltl to drw translations using ltl2dstar for the incorrect drws and the cases where an equivalent dbw could not be found.
this second experiment conrmed the non existence of a dbw in all cases established using ltl3dra and produced correct drws so we were nally able to successfully validate our gr templates for the three remaining cases.
thus we have successfully validated the nal output of our toolchain for all templates produced and embedded in our tool.
the generated templates and checks used for veri cation are available for inspection and reproduction from .
.
threats to validity we brie y discuss threats to the internal and external validity of our results.
first the computation of the results that we present in table relies on a toolchain with four tools of which some are prototypical implementations and proofs of concept.
these may have bugs or we might have used them incorrectly.
to mitigate this and validate the correctness of our results and generated catalog of gr templates we validated our results as described in sect.
.
above.
second the origin of the speci cation patterns of dwyer et al.
may be viewed as another threat to the validity of our approach.
these patterns were extracted from industrial and academic speci cations used for model checking not for synthesis.
it may be the case that speci cations written for synthesis have or should better have di erent characteristics or use other patterns.
we are unaware of any comparable studies for synthesis or studies analyzing the di erence between speci cations for veri cation and for synthesis.
thus we believe using the dwyer et al.
patterns in our context is reasonable.
.
discussion and extensions we now discuss several important features as well as extensions of our work.
.
completeness we are interested in the completeness of results provided by our toolchain i.e.
if a dbw for an ltl pattern exists is it found by our toolchain?
the rst tool in our toolchain spot performs purely syntactic preprocessing and preserves completeness.
while a drw can express any ltl formula the second tool in our toolchain ltl3dra only supports the translation of a fragment of ltl to drw .
thus in theory the second step is incomplete if the translation fails it is not known whether the pattern can be supported or not see fig.
.
however as our results show see sect.
2a formula outside the ltl fragment supported by ltl3dra see might result in an incorrect drw.
starting from version .
.
the fragment is checked.for all patterns from this case never happened ltl3dra always produced a drw.
in the third step in the toolchain if a dbw exists for the given drw it is found by dbaminimizer .
in case dbaminimizer gives a negative result no dbw exists and the pattern cannot be supported.
in our results this negative result was returned for only three of the patterns as presented in sect.
.
finally our own tool dbw2gr1 always computes a gr template for a dbw.
thus overall although the toolchain is theoretically incomplete due to the second tool ltl3dra on our data of patterns it was complete.
two more remarks are of interest.
first to address the potential incompleteness of the analyses by ltl3dra e.g.
if using the toolchain with additional ltl formulas as input one can use general ltl synthesis tools such as lily or acacia to synthesize a dbw directly.
this dbw can again be minimized using dbaminimizer .
in practice we did not need this alternative toolchain because for all the patterns from our toolchain provided a de nite result.
second from a practical point of view if a dbw is found it might be too big for e cient analysis by dbaminimizer .
we have encountered this problem for patterns p49 and p54 where the sat formula generated by dbaminimizer in dimacs cnf format was exceeding a size of 110gb.
to solve this problem we modi ed the search strategy and dbw reconstruction of dbaminimizer to handle these cases.
technically the modi cation allowed us to guess and check a small size dbw resulting in smaller sat problems small enough for e cient analysis by dbaminimizer .
.
generalized rabin synthesis and remaining patterns ehlers has extended gr synthesis where assumptions and guarantees can be expressed as dbws to generalized rabin synthesis where assumptions and guarantees can be expressed as drws with one acceptance pair.
drws with one acceptance pair are more expressive than dbws.
we now discuss how our results from sect.
directly transfer to grabin synthesis.
the complexity of grabin synthesis depends on the size of the drws used as assumptions and guarantees.
for of the patterns from we have computed minimal dbws which directly translate to drws of the same structure and size by adapting their acceptance condition .
drws are dbw type i.e.
given a drw for language l if a dbw for lexists the dbw has the same structure as the drw.
thus a minimal dbw has the size of a minimal drw accepting the same language since the existence of smaller drw would contradict minimality of the dbw.
thus for the supported patterns our approach provides not only minimal dbws but also minimal drws for grabin synthesis.
.
incorporating the past in it was shown how to incorporate past ltl formulas into the gr fragment.
speci cally this is done by translating each past ltl formula into a deterministic temporal tester .
this requires the addition of auxiliary variables to encode the states of the temporal tester and its acceptance i.e.
satisfaction of the past ltl formula.
the acceptance expression is a non temporal formula that replaces the past ltl subformula.
the approach is compo103table patterns p09 p15 and p26 used in the forklift speci cation shown in listing their ltl semantics from and the corresponding gr templates we have generated for them.
pattern english kind and scope ltl semantics gr template p09poccurs between qandr q !r !r w p !r s s1 s s1 r p !q x s s1 s s1 !r !p q x s s2 s s2 !r !p x s s2 s s2 r x s bot s s2 !r p x s s1 s bot true x s bot j s s1 s s2 p15 afterqhave at most two p untilr q !p !r u r p !r u r !p !r u r p !r u r !p w r p s s1 s s1 !q !r r x s s1 s s1 q !p !r x s s2 s s1 q p !r x s s3 s s2 r x s s1 s s2 !p !r x s s2 s s2 p !r x s s3 s s3 r x s s1 s s3 p !r x s s3 s s3 !p !r x s s4 s s4 r x s s1 s s4 !p !r x s s4 s s4 p !r x s s5 s s5 r x s s1 s s5 p !r x s s5 s s5 !p !r x s s6 s s6 r x s s1 s s6 !p !r x s s6 s s6 p !r x s bot s bot true x s bot j s s1 s s2 s s3 s s4 s s5 s s6 p26 globallypleads toq p q s s1 s s1 p q !p x s s1 s s1 p !q x s s2 s s2 !q x s s2 s s2 q x s s1 j s s1 sitional as long as only past ltl operators are nested within a gr formula.
it is important to note that the incorporation of the past extends into our support for patterns.
speci cally one may use past ltl formulas within patterns.
as an example consider a speci cation that says that the forklift has loaded cargo when it leaves a station and does not drop it until it arrives at a station.
our speci cation expresses this guarantee using pattern p20 instantiated in the rst parameter with the past ltl formula lift!
drop s lift lift globally lift!
drop s lift lift after !atstation until atstation p20 the past subformula is satis ed i cargo has not been dropped since it was last lifted.
technically our construction shown in sect.
.
is extended to support past by translating past formulas to temporal testers and then instantiating the pattern of each template with the expression denoting the acceptance of the tester.
we omit the details from this version of the paper.
.
pattern negations and boolean combinations our translation goes through a dbw but dbws are not closed under complement i.e.
the existence of a dbw for pattern gives no information about the existence of a dbw for its negation .
thus it is interesting to check whether these dbws exist and whether our framework may support the negation of patterns.
we examined the negation of all patterns using our toolchain and found that negated patterns have a dbw and thus a gr template representation.
the maximalsize of the minimal dbw for all pattern negations is again states and so at most auxiliary variables are required to support a negated pattern instantiation.
pattern p23 without a corresponding dbw is supported in its negated form.
for the two other unsupported patterns p50 and p55 the negation does not have a corresponding dbw.
so in our synthesis tool we support pattern negations.
finally as dbws are closed not only under intersection conjunction but also under union disjunction our work opens the way to support speci cations that include intersections and unions over the supported patterns and supported pattern negations.
we omit the details on how this can be done from this version of the paper.
conjunction disjunction and negation of patterns allow for much exibility and expressiveness in writing the specication on the way to the symbolic gr synthesis.
as an example consider an extended forklift with an emergency o switch and the conditional guarantee to always eventually get to a station if the emergency o switch is never pressed between stations.
the absence of the property emgoff between stations can be expressed using pattern p04 and the above guarantee can be written as an implication between an instance of pattern p04 and pattern p26 emgoff never occurs between !atstation and atstation p04 implies globally !atstation leads to atstation p26 note that the implication is supported by our approach because it translates to a disjunction of the negation of pattern p04 which has a corresponding gr template and pattern p26.
.
related work speci cation patterns aim to assist engineers in the difcult task of formally writing a speci cation.
the work of dwyer et al.
on temporal property speci cations which we relate to in this paper is the most well known work in this area.
the patterns have been used and extended in many tools and contexts including e.g.
property elucidation and natural language interfaces in smith et al.
work runtime veri cation in bauer et al.
work and ocl in dou et al.
work to list a few.
related and extended patterns have been investigated and proposed for service based applications by bianculli et al.
for real time speci cations by konrad and cheng and for probabilistic speci cations by grunske .
a comprehensive framework for all of these patterns have been recently suggested by autili et al.
.
several ltl synthesis tools were presented in recent years e.g.
lily anzu ratsy unbeast and acacia .
some of these tools handle general ltl speci cations while others focus on the gr fragment.
our own implementation of gr synthesis is written on top of jtlv but the contribution of our present work does not depend on a speci c implementation of gr synthesis.
some of these tools support a combination of ltl formulas and automata as input.
to the best of our knowledge none of these synthesis tools and the works using them supports high level speci cation patterns as input.
gr synthesis has been used and extended in di erent contexts and for di erent application domains including robotics scenario based speci cations aspect languages and event based behavior models to name a few.
many works including some by the rst listed author have presented case studies based on gr or dealt with unrealizability in the context of gr e.g.
and some of the works listed in the previous paragraph.
all these works claimed that gr is expressive enough to support most speci cations written in practice.
to the best of our knowledge our work is the rst to examine this claim against a concrete list of well known patterns and thus to strengthen it with evidence and practically integrate these patterns into a synthesis tool.
.
conclusion and future work in this paper we have showed that almost all of the ltl speci cation patterns of dwyer et al.
can be used as assumptions and guarantees in gr speci cations which have an e cient polynomial symbolic synthesis algorithm.
we have automated the process of translating the patterns into corresponding gr templates and have integrated them into our synthesis tool.
we further proved that the translation is correct showed that it is complete for the patterns of dwyer et al.
and validated its results using model checking.
the work provides evidence for the strength of the gr fragment.
we consider the following future work directions.
first we plan to systematically examine possible support for additional speci cation patterns on top of the gr fragment by reusing our toolchain and template generator and applying them to other forms of ltl speci cations.
these include for example extensions of the dwyer et al.
patterns counting patterns after q pbecomes true in at most exactly at least ksteps occurrences of r trigger patterns which use regular expressions as de ned in kupferman and vardi s trigger logic di erent variants of scenarios etc.
furthermore many recent works in the area of synthesis deal with quantitative and probabilistic speci cations see e.g.
.
we plan to investigate if and how can quantitative and probabilistic patterns as identi ed e.g.
in be supported within the symbolic algorithm of gr .
our work is part of a larger project on bridging the gap between the theory and algorithms of reactive synthesis on the one hand and software engineering practice on the other.
in this project we are building engineer friendly tools around reactive synthesis for example to identify and x unrealizability as in e.g.
and to provide two way traceability between the assumptions and guarantees in the speci cation and the states and transitions of the synthesized implementation.
both problems dealing with unrealizability and providing traceability become more challenging in the presence of patterns in the language used for speci cation.
the dbw2gr1 tool the generated patterns catalog and the means to validate its correctness using model checking all available from have been successfully evaluated by the replication packages evaluation committee and found to meet expectations.
.