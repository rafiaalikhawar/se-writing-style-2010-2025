intpti automatic integer error repair with proper type inference xi cheng min zhou xiaoyu song ming gu jiaguang sun school of software tnlist kliss tsinghua university china electrical and computer engineering portland state university usa chengxi13 mails.tsinghua.edu.cn mzhou guming sunjg tsinghua.edu.cn song ece.pdx.edu abstract integer errors in c c are caused by arithmetic operations yielding results which are unrepresentable in certain type.
they can lead to serious safety and security issues.
due to the complicated semantics of c c integers integer errors are widely harbored in real world programs and it is errorprone to repair them even for experts.
an automatic tool isdesired to automatically generate fixes which assist developers to correct the buggy code and provide sufficient hints to help developers review the generated fixes and better understand integer types in c c .
in this paper we present a tool intpti that implements the desired functionalities for c programs.intpti infers appropriate types for variables and expressions to eliminate representation issues and then utilizes the derived types with fix patterns codified from the successful human written patches.
intpti provides a user friendly web interface which allows users to review and manage the fixes.
we evaluate intpti on real world projects and the results show its competitive repair accuracy and its scalability on large code bases.
the demovideo for intpti is available at index t erms integer error type inference fix pattern i. i ntroduction in c c programs integer arithmetic operations e.g.
addition and assignment may produce results that the certain expression type cannot represent and such values are conver ted somehow to fit the target type.
some conversions are well defined e.g.
unsigned wraparound by the language standardbut others are undefined e.g.
signed overflow .
integer errorsare generally caused by misuse of well defined conversions orundefined behaviors due to developer s empirical certainty ofexpected outcomes.
integer error is known to be one of themain threats to the safety and security of software system.
apotential total power loss in boeing dreamliners wascaused by the signed overflow of a bit counter.
multipleinteger errors in linux kernel can be exploited for denial of service attacks or privilege escalations .
a cve reportin suggests that integer overflow error is the secondmost common vulnerability in the advisories for os vendor.
challenge.
it is error prone to correctly repair integer errors even for experts due to the complicated semantics of integersin c c .
the machine representation of an integer is a fixed size bit vector restricted by its type specific characteristics signedness and width.
generally the semantics over fixed size bit vectors and zare inconsistent.
for example x y x y holds over z but no longer holds over fixedsize bit vectors owing to the overflow in x y. even worse not all integer arithmetic operations are well defined.
althoughundefinedness grants compilers freedom to generate efficientcode by exploiting specific properties of a certain instructionset it could lead to unexpected runtime behaviors acrossdifferent architectures or optimization levels.
for example anoverflow in signed addition silently wraparounds on x86 buttraps on mips .
related work.
numerous automatic solutions for integer errors have been proposed but they have various limitationsin real world applicability.
one thread of the related workfocuses on integer error detection by symbolic execution static analysis or code instrumentation .
these tools produce reports on where integer errors areand how to trigger them but they are unable to guide deve lopers to correct the buggy implementation.
generic programrepair techniques are proposed to automatically correct theimplementation with its specifications.
they generate patchesthat address certain defects by typically validating heuristi cally generated patches with test suites or synthesizing desired expressions with respect to constraints derived from test suites .
theeffectiveness of these tools however heavily relies on specifications which are often insufficient in practice.
moreover even the state of the art generate and validate systems do not scaleto large software systems with thousands of potential defects as they generally require hours to find a plausible patch for one real world bug.
some tools are designed for integer errorsspecifically .
they transform the internal integer model of a program towards a safer model but an excessive number of unnecessary changes are made in the program.
approach.
we present intpti an automatic tool that generates and applies fixes for integer errors in c programs.
it aims to assist developers and testers to improve code qualityagainst integer errors.
first intpti preprocesses the source files on the fly in the building process.
next intpti computes the appropriate types i.e.
proper types for variables and expressions to eliminate representation issues and generates fixes by utilizing proper types.
then users interact with intpti via a web interface to review fixes.
finally accepted fixes arecollected and applied to the source code.
users can benefitfrom intpti as it proposes fixes for possible integer errors with proper explanations which helps users to locate the new integer errors in code and repair them correctly better understand the integer types in c language.
our key approach is proper type inference which finds appropriate types for expressions and variables such that each expression has the type that covers all its possible values.
the goal of proper type inference is achieved by static value analysis ii b which approximates possible values of ex978 .
c circlecopyrt2017 ieeease urbana champaign il usa t ool demonstrations996 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
void struct c1 ... cn ... e n x e.c e e e e e e e f e ...e fig.
.
the core language syntax.
pressions and type inference ii a which computes types for expressions and variables with respect to the proper typeproperty and the well typedness of program .
inferred typesare utilized to generate fixes ii c by common fix patternscodified from the real world sanity check explicit type castingand declared type changing.
for the scalability in real world projects intpti adopts multi entry analysis ii d to run proper type inference in the compositional manner.
to demonstrate the accuracy and runtime efficiency of intpti we apply it to widely used open source projects withknown integer vulnerabilities.
the results show that intpti succeeds in repairing out of defects.
furthermore intpti substantially addresses the limitations of existing tools as it does not rely on specifications such as test suites generatesfixes with proper explanations of why the fix is generatedand how it transforms the code reduces false positives i.e.
fixes that correspond to no genuine bugs on the critical program sites where attacks are typically performed on the subject programs by .
compared to the state of the artapproach and scales to large code bases as it spends no more than minutes on vim with over kloc.
contribution.
main contributions are summarized as we propose a novel approach that automatically generates fixes under appropriate patterns via type inference.
we implement our approach as a tool intpti.i ti sd e signed for complex realistic c code bases and provides auser friendly interface for users who are unfamiliar withprogram analysis techniques.
we evaluate intpti on open source projects.
the results show its competitive repair accuracy and runtime efficiency which substantiates that our tool is of practical concern.
ii.
a pproach overview generally intpti repairs c integer errors by three main steps static value analysis proper type inference and3 fix generation.
for the scalability of intpti multi entry analysis is employed to divide and conquer the fix generationtask on the whole program.
a. proper type inference we present a c like kernel language shown in fig.
to formalize our discussion.
the language models expressions including integer literals variables structure members binaryexpressions the operator can be arithmetic or logical cast expressions pointer dereferences address of expressions assignments and library calls.
there can be multiple kinds of integer types varying on length and or signedness.
each expression has a type which can be integer type pointer type structured type and function type.
a program consists of variable declarations and expressions.
let llbracket rrbracket e zmap an expression to its possible values and llparenthesis rrparenthesis t 2zmap a type to values that it can represent.
we say that is the proper type of an arithmetic expression eif llbrackete rrbracket llparenthesis rrparenthesis.to derive proper types we scan the program and collect constraints on the types of expressions and variables by proper type inference rules.
all non arithmetic expressions keep theiroriginal types.
rules for arithmetic expressions are listed infig.
.
the type judgment turnstilelefte mapsto cdenotes that given the context the type of eis inferred as along with the constraint set c. the context consists of the typing hypothesis which maps variables to their declared types that assigns arithmetic expressions with their enforced types and llbracket rrbracket llparenthesis rrparenthesis where the former is computed by value analysis ii b and the latter is given by c language datamodel e.g.
data type width schemes including lp32 ilp32 lp64 etc.
in use.
the notation precedesequal 2denotes that the byte length of 2is no less than that of 1 namely 2elevates 1 .
emaps expressions to their original types.
we give brief explanations for some rules.
in the b inary arith rule the type is required to be eligible to represent possible values of e1 e2 be the common type of 1and 2 namely 1 2 to preserve well typedness.
in the b inary logical rule however operands of logical operation are enforced to have their common type in order to prevent implicit conversion in comparison and overflow bug in eachoperand.
the a ssign var rule elevates the declared type of the variable to be assigned with respect to the right operand while the a ssign n onvar rule enforces the non variable l value to have its original type.
in the l ibrary call rule argument expression is enforced to fit its parameter type.
theoperand of an address of operation keeps its original type toprevent memory issues after repair.
the collected constraints need further processing.
first for each arithmetic variable xwe add a constraint d x precedesequal x denoting that the new type of xelevates its original type wheredmaps variables to their original declared types .
second constraints of value inclusion such as n llparenthesis rrparenthesisand llbrackete rrbracket llparenthesis prime rrparenthesisare allowed to be violated with penalty wvsince built in integer types can only represent a limited range of inte gers.
third for each type elevation constraint precedesequal 2 w ea d d a matching equality constraint 1 2with violation penalty wpto minimize changes on types.
generally wvshould be substantially larger than wpto not overshadow necessary type elevations.
the conjunction of processed constraints is a partial weighted maxsmt problem .
a maxsmt solver such asz3 finds a solution that satisfies all hard constraints i.e.
ones with no penalties while minimizing the total penaltyof violated constraints albeit a local minima is derived in general or reports unsatisfiable otherwise.
there alwaysexists a solution isuch that i d i e e e andi e e e where eis the type variable for e. b. static v alue analysis static value analysis approximates values of expressions and gives llbracket rrbracketfor proper type inference.
three analyses are mainly used interval analysis which captures lower and upper boundsof expressions pointer analysis which analyzes points torelations and reaching definition analysis which builds usedef chains .
analyses share the derived information to achievebetter precision.
for example points to relations are exploited to approximate pointer dereferences more precisely.
in interval analysis we extend the basic interval arithmetic by authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
var turnstileleftx mapsto x precedesequal const turnstileleftn mapsto n llparenthesis rrparenthesis e n precedesequal binary a rith turnstilelefte1 1 mapsto c1 turnstilelefte2 2 mapsto c2 is an arithmetic operator turnstilelefte1 e2 mapsto c1 c2 llbrackete1 e2 rrbracket llparenthesis rrparenthesis 1 2 binary logical turnstilelefte1 1 mapsto c1 turnstilelefte2 2 mapsto c2 is a logical operator turnstilelefte1 e2 mapsto c1 c2 e e1 e2 prime 1 2 llbrackete1 rrbracket negationslash llparenthesis prime rrparenthesis e1 prime llbrackete2 rrbracket negationslash llparenthesis prime rrparenthesis e2 prime assign var x e turnstilelefte mapsto c turnstileleftx prime mapsto c x prime llbrackete rrbracket llparenthesis prime rrparenthesis assign n onvar e1 e2 turnstilelefte2 mapsto ce 1is not a variable turnstilelefte1 prime mapsto c prime e e1 llbrackete2 rrbracket negationslash llparenthesis prime rrparenthesis e2 prime deref turnstilelefte 1 mapsto c turnstileleft e 2 mapsto c 1 precedesequal 2 address o f turnstilelefte mapsto c turnstileleft e mapsto c e e library call turnstileleftf mapsto c0 turnstilelefte prime mapsto c1 turnstileleftf e mapsto c0 c1 llbrackete rrbracket negationslash llparenthesis rrparenthesis e fig.
.
rules of proper type inference.
t able i the distribution of fix pa tterns for cve bugs .
pattern sc etc dtc et other id count implementing semantics of library calls relevant to numerical operations such as abs and refining intervals with respect to path conditions and the use def chain.
pointer analysis is based on andersen s algorithm and reaching definitionanalysis is based on classical data flow analysis .
c. repair generation a case study is conducted on selected cve identifiers as they contain sufficient information on buggy code security impacts and upstream fixes.
they come from differentapplications ranging from to .
we identify recurringsimilar patches i.e.
fix patterns and summarize them in tablei.
the total occurrence of patterns is larger than the numberof identifiers because some contain multiple patterns.
thereare totally four common patterns.
sanity check sc .
guards a critical operation against erroneous values.
explicittype casting etc .
enforces the type of an expression.declared type changing dtc .
adjusts the declaredtype for a variable.
expression transformation et .
rewrites an expression as an equivalent form under integerarithmetic such as transforming x y 8tox y. only .
of fixes have no common patterns.
from the perspectiveof repair mechanism sc restricts the expression to haverepresentable values while etc and dtc elevate the precisionof expression and variable respectively.
et can be reduced to the combination of etc and dtc since it is a workaround to prevent overflow without adjusting the precision.
hence proper types are utilized to generate sc etc and dtc fixes.
letibe the derived solution of proper type constraints and fbe the set of candidate fixes.
we have f dtc x f iff i x negationslash d x fsc e f for e i fetc e f iffi e negationslash e e .
the notation f e is used to collectively denote a sc fix or an etc fix on e. we define the dependency relation triangleleftoverf such that f e1 triangleleftf e2 iffe1is a descendant of e2in the ast fetc e triangleleftfsc e fdtc x triangleleftfetc x .f1 triangleleftf2implies that the application result of f2depends on that of f1.m fetc e1 e2 m fetc e1 m fetc e2 m fetc prime e e m fetc e e m fsc e1 e2 check m fsc e1 m fsc e2 m fsc e braceleftbigg check e precedesequal e negationslash e e otherwise fig.
.
the expression transformation function m. to apply the candidate fixes in f we iteratively choose a fixfthat depends on no other fixes in fand remove it from f.i ffis a dtc fix we change the certain declared type otherwise fis applied by expression transformation function m shown in fig.
which lists the expression transformation schemes ordered by the priority of application.
note that sc fixes can introduce two kinds of check functions conversioncheck check n that returns niff it is representable in arithmetic check check n1 n2 that returns the result of n1 n2in mathematical arithmetic iff it is representable in .
d. multi entry analysis the scalability of our approach is restricted by static analysis and the capability of solver on complicated constraints.
to make our approach scale to large code bases we adopt multi entry analysis to divide and conquer the whole programreasoning.
firstly the code base is decomposed into multiple call graph components each of which has an entry function from which other functions in the component are reachable by function calls.
next we perform proper type inference on each component starting from its entry and then combine their results.
to guarantee the compatibility of sub results we enforce variables spanning multiple scopes e.g.
global variables to keep their original types.
furthermore to reducethe precision loss brought by compositional analysis weperform a function wise pre analysis to derive function callcontext function and loop summary and loop invariant.they are all based on interval abstract domain.
iii.
i mplement a tion the architecture of intpti is shown in fig.
.
given a c project intpti firstly preprocesses it and constructs its control flows for analysis.
next intpti approximates values of expressions and collects proper type constraints by running bounded cpa algorithm with several analyses.
candidate authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
qw37 surmhfwsuhsurfhvv uhsdluhg frghfrqwuro iorz exlogerxqghg fdqglgdwh il hvsurshu w sh lqihuhqfh il lqir vhuldol dwlrqil lqir vwruhdffhswhg il hvil dssolfdwlrq zhe lqwhuidfh xvhuil uhylhzorfdo vhuyhu fig.
.
the architecture of intpti.
fixes are derived by solving the proper type constraints using z3 .
then intpti starts a web interface for users to review candidate fixes.
finally intpti transforms the code to apply accepted fixes.
preprocessing.
first the compilation commands in makefile are captured by invocation order.
next source files are preprocessed by in the case that the compiler in use is gcc adding the eflag to make the compiler stop after preprocessing and replacing the output .o files by the corresponding .i files which are self contained source files with macros expandedand necessary declarations included.
the .i files compiled into an executable or a library are organized as a task.
bounded cpa algorithm.
the static analysis algorithm used inintpti is extended from cpa algorithm for multi entry analysis.
when the analysis reaches the boundary of currentcall graph component or maximum loop iteration or maximumloop nesting level we summarize the upcoming functionor loop.
the algorithm runs multiple analysis componentsincluding but not limited to the three main analyses.
eachanalysis is implemented under the cpa framework .
syntactic elements of the standard c language need to be handled carefully.
bitwise shift operations are approximatedcarefully for possible intentional wraparounds.
for example a left shift of an unsigned integer is always representablein its type as this kind of wraparound is usually served formodulo operation.
the possible targets of a function pointerare derived by combining pointer analysis with type matching.if no targets can be found certain function call is treated asa library call without implemented semantics.
type enforce ments are imposed on critical program sites including functionarguments array indexes return values and the operands ofcondition expressions.
furthermore memory regions allocatedby alloc family are treated as arrays whose identifiers have the format.
the heuristic for call graph decomposition in multi entry analysis is configurable by specifying the maximum levels ofcall stack loop unrolling and loop nesting in the configuration.
proper type inference.
proper type constraints are encoded under an extended smt lib .
format over quantifierfree equality logic with uninterpreted functions .
morespecifically we use the declare datatype command to define an enumeration iof integer types plus a dummy typeoverlong which can represent every value in z declare fun commands to define a binary function over ito model two binary predicates p qoveriwherepmodels the uuid 536335ff f0a9 4b6b aca0 358606f1fe9e mode cast type long int startline endline startoffset endoffset defect overflow ary op1 i op2 o optr sign children fig.
.
an example of a serialized fix.
fig.
.
the web interface for fix review.
containment relation over llparenthesist rrparenthesisandqmodels precedesequal and variables also0 ary functions over iencoding type variables such as x and e .
llbrackete rrbracketis encoded as the corresponding value of iniwhere is the type with the shortest byte length such that llbrackete rrbracket llparenthesis rrparenthesis o roverlong if such does not exist.
llparenthesis rrparenthesisis encoded as the corresponding value of ini.
we assert additional constraints such that every type variable is prohibited to be overlong.
to add a constraint with violation penalty w w e use the command assert soft weight w and for others without violation penalty the assert command is used.
penalty values wpandwvcan be configured by users and their default values are 1and100 respectively based on pilot experiments.
fix info serialization.
the candidate fixes are serialized as json data to be interchanged across a local server and web interface.
fig.
shows a serialized fix.
the json objectfor a fix stores its uuid its mode specifier for dtc cast for etc check arith for arithmetic check and check conv for conversion check its specified type the location of target code characterized by line number and offset and the fixes depending on the current fix as the value of children .
keys starting with are mode specific fields providing more details on this fix.
for example the reason forthe fix shown in fig.
is as follows there is an overflow issueon the signed addition of iando.
web interface.
end users review candidate fixes via the web interface shown in fig.
.
the file explorer circlecopyrt lists source files of the current project.
when a user selects a file the code viewer circlecopyrt displays its contents while the relevant candidate fixes are loaded in the fix list circlecopyrt .
indentions are used to visualize the dependency relations over fixes.
the user canaccept or reject a fix by toggling its button.
for two fixesf 1andf2such that f1 triangleleftf2 the interface enforces that f2 is toggled on only if f1is toggled on.
by selecting a fix the code viewer highlights the target code and scrolls to the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
certain line while the detail panel circlecopyrt shows the description of the proposed fix and the reason in natural language.
for now two working modes are supported and can be selected by thedropdown list at circlecopyrt.
in the global mode all the candidate fixes are accepted and their statuses are locked.
in the manual mode however all the candidate fixes are rejected by default andusers can manually accept some of them.
finally by clickingthe confirmation button at circlecopyrt accepted fixes are submitted to intpti for code transformation.
code transformation.
arithmetic checks and conversion checks are implemented as a library libtsmartintfix.
to apply a sc fix we insert the corresponding check function with its declaration introduced.
it is necessary to link this library tocompile the repaired code.
iv .
e xperiment al ev alua tion the effectiveness of intpti can be assessed in the terms of the following aspects what is the accuracy of intpti in repairing integer errors?
what is the runtime efficiency of intpti?
intpti is evaluated on open source projects gzip .
.
vim .
grep .
postgresql .
.
jasper .
.
libarchive .
.
and openssl .
.1r.
they are chosen for evaluation because they are written in c and contain known integer vulnerabilities in the cve database they coversvarious application domains including encoding and decoding text processing database system graphics and cryptography.
repair accuracy should be measured by recall and precision.the former is evaluated by checking how many vulnerability are successfully repaired after running intpti in the global mode.
the latter cannot be evaluated directly because we have no complete knowledge on integer errors in realistic codebases.
thus we compare the numbers of critical program sites which are typical locations for fixes applied with fixes byvarious tools.
all experiments are conducted on a workstation under 64bit ubuntu .
using intel core i7 6820hq .70ghz cpuand 32gb memory.
the maximum levels of the call stack and loop nesting are set to while loops are not unrolled thusloop bodies are always reasoned by loop invariants .
constraint penalties are set as default values.
the data model employedis configured as ilp32 only if the target defects can only be triggered under ilp32 or lp64 otherwise.
the experimentalresults of intpti are shown in table ii.
columns show general information about the evaluation programs.
for postgresql and openssl intpti directly analyzes all source files under the specified location such as crypto bn because the target defects are not included in any preprocessed task.
kloc and kloc p refer to the lines of code before or after preprocessing respectively.
kloc excludes all header files.
columns assess the recall.
column cve id lists cve identifiers for the defects.
some identifiers such as cve2014 contain multiple buggy code fragments with similar defect patterns.
column dm reports under which data model for ilp32 and for lp64 certain defect can be triggered.
column op lists buggy operations e.g.
udenotes unsigned multiplication while u2s denotes the conversionfrom unsigned to signed .
the following three columns count the different kinds of fixes.
column freports whether certain defect is correctly repaired.
the results show that out of defects are repaired correctly.
two missed bugs are dueto flow insensitivity of proper type inference.
for example the bug belonging to cve involves an signedmultiplication yielding an overflowed bit integer which isthen passed to a critical site and the proper type inferencecannot capture the sequence of the overflowed multiplicationand the critical site.
columns report runtime efficiency results.
columns cf su va ti and fa report the time costs of controlflow build summary computation static value analysis typeinference and fix application respectively.
static value analysiscosts the majority of total time .
on average .
it isremarkable that type inference costs only .
of total time and this result can be achieved because multi entry analysis decomposes the complicated whole program proper typeconstraints into fragments which can be solved efficiently.
furthermore intpti spends no more than minutes on vim the largest project over kloc used in the evaluation.
the last columns evaluate the precision.
the baseline column lists the total number of critical sites of integer type.
we compare intpti s precision with cintfix and coker s because they work on source code only without requiring additional inputs they support various kinds of integer errors.
cintfix changes every critical site as the column baseline shows because it needs to make sure whether a multi precision integer value fits the target built in type on every critical site.
since we are unable to obtainthe artifact of coker s work after our request to authors we count the number of critical sites applied with fixes as if the add integer cast transformation is applied to all local variables array subscripts and field access expressions and the replace arithmetic operator transformation is applied to all arithmeticexpressions and assignments as the experimental settings inthe paper.
the results show that coker s and ours makechanges on .
and .
of all critical sites respectively.in fact by considering user s feedbacks our false positiverate can be further reduced.
coker s and cintfix focus on transforming the internal integer model to a safer model thusmassive false positives could be generated.
cintfix is also evaluated on the chosen projects.
the results show that cintfix succeeds in repairing all target defects while the total time cost is .268s.
it is insufficient toconclude that cintfix has better real world applicability for its superior performance on the recall and runtime efficiencybecause precision is crucial to user experience as the criteriafor static code analyzers.
in fact the recall and runtimeefficiency of our tool could be improved by changing all integer types to bit unsigned signed integers and inserting sanity checks on every arithmetic operations which wouldmake it much more difficult for users to review the fixes and find possible integer defects in programs.
v. c onclusion in this paper we present intpti an automatic repair tool for integer errors in c programs.
it integrates type inferencesynergically with static value analysis to compose constraints authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able ii ev alua tion results of intpti.
general info accuracy performance s critical sites project task kloc kloc p cve id dm op etc sc dtc f cf su va ti fa baseline coker s intpti gzip gzip .
.
u .
.
.
.
.
.
vim vim .
.
u .
.
.
.
.
.
u u .
.
.
.
.
.
grep grep .
.
s .
.
.
.
.
.
u2s postgresql contrib hstore .
.
u .
.
.
.
.
.
u u u jasperjasper .
.
s .
.
.
.
.
.
lessmuchs lessmuchs s s imgcmp .
.
s .
.
.
.
.
.
libarchive bsdtar .
.
s .
.
.
.
.
.
s s u opensslcrypto mdc2 .
.
u .
.
.
.
.
.
crypto evp .
.
s .
.
.
.
.
.
s crypto bn .
.
s .
.
.
.
.
.
s on the types of variables and expressions for preventing representation issues.
it utilizes the solution of constraintswith common fix patterns etc sc and dtc codified fromthe successful human written patches.
we have designed aweb interface which fills the gap between end users andthe tool to help users better understand integer bugs and2 reduce unnecessary fixes with user feedback.
intpti is evaluated on real world projects and the results show thatit is effective to repair various kinds of integer errors with high runtime efficiency while avoiding unnecessary changeson critical program sites.
the source code and experimental data are publicly available at a cknowledgment we thank the anonymous reviewers for their insightful comments.
this research was supported in part by nsfc program no.
national science and technology major project no.
2016zx01038101 miit it funds research and application of tcn key technologies of china and the natio nal key technology r d program no.
2015bag14b01 .
r eferences n. y .
times f.a.a.
orders fix for possible power loss in boeing .
.
available business faa orders fix for possible power loss in boeing .html cve cve .
.
available org cgi bin cvename.cgi?name cve cve .
.
available org cgi bin cvename.cgi?name cve s. christey b. martin m. brown a. paller and d. kirby cwe sans top most dangerous software errors .
.available c. price mips iv instruction set.
mips technologies .
y .
moy n. bj rner and d. sielaff modular bug finding for integer overflows in the large sound efficient bit precise static analysis tech.rep.
msr tr .
d. molnar x. c. li and d. wagner dynamic test generation to find integer bugs in x86 binary linux programs in usenix security symposium pp.
.
s. sidiroglou douskos e. lahtinen n. rittenhouse p .
piselli f. long d. kim and m. c. rinard targeted automatic integer overflow disco very using goal directed conditional branch enforcement in asplos pp.
.
x. wang h. chen z. jia n. zeldovich and m. f. kaashoek improving integer security for systems with kint in osdi pp.
.
d. brumley d. x. song t. chiueh r. johnson and h. lin rich automatically protecting against integer based vulnerabilities in ndss .
w. dietz p .
li j. regehr and v .
s. adve understanding integer overflow in c c acm trans.
softw.
eng.
methodol.
vol.
no.
pp.
.
r. b. dannenberg w. dormann d. keaton r. c. seacord d. svoboda a. v olkovitsky t. wilson and t. plum as if infinitely ranged integermodel in issre pp.
.
c. le goues t. nguyen s. forrest and w. weimer genprog a generic method for automatic software repair ieee trans.
software eng.
vol.
no.
pp.
.
w. weimer z. p .
fry and s. forrest leveraging program equivalence for adaptive program repair models and first results in ase pp.
.
y .
qi x. mao y .
lei z. dai and c. wang the strength of random search on automated program repair in icse pp.
.
d. kim j. nam j. song and s. kim automatic patch generation learned from human written patches in icse pp.
.
f. long and m. rinard staged program repair with condition synthesis in esec fse pp.
.
automatic patch generation by learning correct code in popl pp.
.
h. d. t. nguyen d. qi a. roychoudhury and s. chandra semfix program repair via semantic analysis in icse pp.
.
s. kaleeswaran v .
tulsian a. kanade and a. orso minthint automated synthesis of repair hints in icse pp.
.
s. mechtaev j. yi and a. roychoudhury directfix looking for simple program repairs in icse pp.
.
z. coker and m. hafiz program transformations to fix c integers in icse pp.
.
x. cheng m. zhou x. song m. gu and j. sun automatic fix for c integer errors by precision improvement in compsac pp.
.
c. ans tegui m. l. bonet and j. levy a new algorithm for weighted partial maxsat in aaai .
l. m. de moura and n. bj rner z3 an efficient smt solver in tacas pp.
.
t. j. hickey q. ju and m. h. van emden interval arithmetic from principles to implementation j. acm vol.
no.
pp.
.
l. o. andersen program analysis and specialization for the c programming language ph.d. dissertation university of cophenhagen .
f. nielson h. r. nielson and c. hankin principles of program analysis.
springer .
d. beyer t. a. henzinger and g. th oduloz configurable software verification concretizing the convergence of model checking and pro gram analysis in ca v pp.
.
c. barrett a. stump and c. tinelli the smt lib standard version .
smt lib initiative tech.
rep. .
d. kroening and o. strichman equality logic and uninterpreted functions in decision procedures an algorithmic point of view.
springer berlin heidelberg pp.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.