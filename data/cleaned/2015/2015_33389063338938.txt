automatically detecting missing cleanup for ungraceful exits zhouyang jia shanshan li college of computer science national university of defense technology china jiazhouyang shanshanli nudt.edu.cntingting yu department of computer science university of kentucky usa tyu cs.uky.eduxiangke liao ji wang college of computer science national university of defense technology china xkliao wj nudt.edu.cn abstract software encounters ungraceful exits due to either bugs in the interrupt signal handler code or the intention of developers to debug the software.
users may su er from weird problems caused by leftovers of the ungraceful exits.
a common practice to x these problems is rebooting which wipes away the stale state of the software.
this solution however is heavyweight and often leads to poor user experience because it requires restarting other normal processes.
in this paper we design safeexit a tool that can automatically detect and pinpoint the root causes of the problems caused by ungraceful exits which can help users x the problems using lightweight solutions.
speci cally safeexit checks the program exit behaviors in the case of an interrupted execution against its expected exit behaviors to detect the missing cleanup behaviors required for avoiding the ungraceful exit.
the expected behaviors are obtained by monitoring the program exit under a normal execution.
we apply safeexit to programs across domains.
safeexit nds types of cleanup behaviors from programs and detects missing behaviors from interrupted executions.
to predict missing behaviors for unseen input scenarios safeexit trains prediction models using a set of sampled input scenarios.
the results show that safeexit is accurate with an average f measure of .
.
ccs concepts software and its engineering software reliability software testing and debugging dynamic analysis.
keywords ungraceful exit software signal missing cleanup acm reference format zhouyang jia shanshan li tingting yu xiangke liao and ji wang.
.
automatically detecting missing cleanup for ungraceful exits.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa 12pages.
also with department of computer science university of kentucky usa.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci c permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
execution graceful exit interrupted execution graceful exit interrupted execution ungraceful exit signals hardware failuressignals hardware failuresfigure di erent types of executions and exits.
introduction aninterrupted execution is de ned as a program execution interrupted by a software signal e.g.
a sigterm signal issued by a user or asigsegv signal triggered by a program bug or a hardware failure e.g.
power o .
this is di erent from a normal execution where the program terminates naturally without experiencing an internal or external abnormal event.
a graceful exit is the ability to terminate the program at the end of interrupted execution leaving the system in a consistent state.
to achieve this programs usually perform some cleanup behaviors at the exit stage such as terminating children processes releasing resources and writing state les.
graceful exit is advocated in many operating systems because if it is not correctly done the consequence would be data corruption of program and operating system les which can negatively impact the stability or the correctness of the system.
in contrast an ungraceful exit represents a program exit under an interrupted execution and that the program does not perform any or part of the cleanup behaviors.
figure 1illustrates the types of executions and exits.
an ungraceful exit can be caused by software bugs in signal handlers in which developers do not correctly clean up the system state developers intentionally retain certain system resources e.g.
processes after program terminations in order to attach a debugger or collect important information such as a core dump or stack trace for diagnosing the software failure hardware failure which means the program has no chance to clean up.
in any case users may su er from weird problems due to the ungraceful exits.
taking nginx a server program as an example if a fatal error e.g.
dereference of a null pointer happens in its main process nginx will exit ungracefully because the children processes are not cleaned up and thus become orphan processes.
as a result users may encounter the following problems nginx and any other web server using the same networking port fail to start because the port is occupied by an orphan process nginx fails to stop because the main process does not exist anymore.
we refer to the problems esec fse august tallinn estonia zhouyang jia shanshan li tingting yu xiangke liao and ji wang caused by ungraceful exits ue as ue problems.
to x ue problems the most common advice from technical supporters is rebooting the computer .
this is because a reboot wipes away the stale state of the software .
however sometimes simply rebooting the computer may still not x the problems such as when les are left inconsistent in the computer s hard drive during an ungraceful exit .
in these cases a hard reset is required users have to reset the computer to its factory default state or even reinstall the operating system.
the above solutions e.g.
reboot reset to ue problems are often heavyweight and thus lead to poor user experience because other normal processes have to restart at the same time especially for the server programs such as web servers or database servers .
the main reason for using the heavyweight solutions is that users do not understand the cause of the problems and thus not able to x them speci cally.
for example to x the ue problems of nginx instead of rebooting the operating system users can manually kill the orphan processes if they know where the root cause is.
therefore techniques on identifying the causes of ue problems are needed.
there has been much research on addressing problems involving software interruptions or hardware failures.
for examples many techniques are targeted at studying and detecting exception handling bugs such as checking if an exception handler is correctly implemented with respect to the speci cation.
however these techniques cannot detect ue problems that may or may not be handled by exception handlers.
there have been some works focusing on preventing and detecting persistency bugs in storage systems such as le systems and database systems .
for example if a storage system crashes during the process of writing data the system has to carefully roll back the operation to avoid data corruption.
however rollback aims to recover the data in storage system but does not target at cleaning up the system state in the case of ungraceful exit.
other works have studied the crash recovery mechanism especially in distributed systems such as recovering failed nodes.
these techniques target at addressing problems during system recovery but not the exit of programs.
in this paper we design and implement safeexit a tool that can automatically detect and pinpoint the root causes of ue problems which can help users to x the problems with lightweight solutions without having to reboot the system.
safeexit focuses on detecting and localizing ue problems instead of recovering the system or rollback.
the key insight of safeexit is to check the program exit behaviors in the case of an interrupted execution against expected exit behaviors.
a behavior consists of a sequence of system calls because a program interacts with the operating system through system calls which can change the state of the system and in uence other programs.
we assume that the expected exit behaviors can be obtained by monitoring the behaviors of the program exit in anormal execution i.e.
an execution without interrupts .
the intuitions are that developers often carefully test the program under normal execution and it does not require reserving system resources for debugging under normal execution.
thus we assume all necessary cleanup operations are performed when a program exits normally.
for example when nginx exits normally the main process will notify its children processes who will stop listening to the port and exit then the main process deletes the nginx.pid le and exits.
finally any inconsistencies between the actual and expected behaviors are reported as the causes of ue problems.
safeexit involves two phases o ine learning andonline monitoring .
given a program the o ine learning phase rst generates a diverse set of input scenarios i.e.
combinations of con guration options and workload values .
for each input scenario safeexit obtains one normal execution and multiple interrupted executions by simulating di erent interruption triggers e.g.
a particular software signal .
from each normal and interrupted execution safeexit traces its exit state and extracts the cleanup behaviors from the trace.
after that safeexit selects the expected behaviors for each interrupted execution from the behaviors of the normal execution.
it then compares the actual and expected behaviors of the interrupted execution to determine if any missing behaviors are detected.
the output of the comparison is a behavior vector in a binary format where each element in the vector indicates a normal behavior.
the behavior vector is initialized with all zero values and whenever a missing behavior for a particular interrupted execution is detected the corresponding behavior is set to .
therefore safeexit learns a behavior vector for each interrupted execution.
finally safeexit builds a prediction model which can predict the missing cleanup behaviors for an unseen input scenario and an interruption trigger.
in the online monitoring phase safeexit is deployed in the production environment such that given a real input scenario.
safeexit monitors the state of the target program and once an interruption is detected it predicts if an ungraceful exit occurs and reports the missing cleanup behaviors to users.
based on the reported behaviors users can manually clean up the system state e.g.
delete a le change an option or kill a process without rebooting the system.
to evaluate safeexit we conduct experiments on widely used programs from software domains.
all programs are open source mature active and written in c c .
the results showed that safeexit identi es types of cleanup behaviors from the normal executions of programs under default con gurations while programs do not perform any cleanup behavior when exiting normally.
next safeexit simulates interruption triggers for the programs i.e.
interrupted executions and detects missing behaviors from interrupted executions.
the results also showed that safeexit is e ective and e cient in training prediction models for detecting missing cleanup behaviors in ungraceful exits given unseen input scenarios.
on average it samples only .
input scenarios in the learning phase and achieves .
accuracy in terms of f measure.
in summary the contributions of this paper are as follows we conduct the rst research to de ne and study ungraceful exit ue problems.
the study builds a taxonomy of cleanup behaviors which helps people better understand ue problems and design tools to handle them.
we design and develop safeexit an automated tool to detect ungraceful exits and pinpoint the root causes of the ue problems.
safeexit provides lightweight solutions for users to x ue problems.
we evaluate safeexit on widely used programs from software domains.
the results show that safeexit is e ective and e cient in detecting and predicting missing behaviors in ungraceful exits.
752automatically detecting missing cleanup for ungraceful exits esec fse august tallinn estonia sudo nginx try to start nginx nginx bind to ip failed address already in use sudo nginx s quit try to stop nginx nginx kill pid failed no such process figure users could neither start nor stop nginx after a fatal signal is issued to the main process.
ungraceful exit problem in this section we rst present two illustrative examples then introduce preliminaries and de nitions of ue problems.
.
illustrative examples the rst example is nginx a popular open source web server.
when a fatal bug signal e.g.
sigill sigbus sigfpe sigsegv is issued to the main process it causes an ungraceful exit.
speci cally a few orphan processes are left when the program terminates.
as a consequence users could neither start nor stop nginx .
as shown in figure nginx fails to start since the port is used by the orphan processes and fails to stop since the main process does not exist anymore.
at the same time any other web server using the same port will fail to start too.
to x these problems users need to restart the operating system or kill the orphan processes manually.
another example is an industrial proxy program.
the program turns on a system con guration option i.e.
socks proxy at the startup stage.
in a normal execution the program will turn o this option at the exit stage.
but when the program is killed by users through the system monitor this often happens when users su er from performance issues the option will still be on and the operating system will be in a corrupted state.
as a result users cannot access the internet anymore.
to x this problem users can either set the con guration option back to o or reset the computer to its factory default state.
the problem is with the les on hard drive thus can not be xed by restarting.
for problems in both examples users can solve them by restarting the computer or resetting the computer to its factory default state.
at the same time however the problems can also be solved by simply killing some processes or changing a con guration option.
the latter solutions are obviously more lightweight for users compared with the former ones.
motivated by these examples we design an automated tool that pinpoints the root causes of the problems caused by ungraceful exits and helps users to x the problems with lightweight solutions.
safeexit s solution.
in the case of nginx safeexit rst generates a set of input scenarios for nginx .
each scenario contains a combination of con guration options e.g.
worker processes and workload values e.g.
http request .
for each input scenario safeexit uses the command nginx s quit to get the normal execution and uses software signals e.g.
sigsegv sigterm sigkill to trigger the interrupted executions.
safeexit then extracts exit behaviors from the normal execution e.g.
deleting pid le and terminating children processes as the expected behaviors.
for each interrupted execution safeexit selects the expected behaviors from the normal behaviors according to the interruption trigger i.e.
software signal .
after that safeexit extracts exit behaviors from the interruptedtable category of interruption triggers.
category interruption triggers fatal bugsigill sigabrt sigbus sigfpe sigsegv sigpipe sigxcpu sigxfsz user termination sighup sigint sigquit sigterm non term.
signal sigstop sigtstp sigttin sigttot sigchld hard exitsigkill kernel panic hard restart hardware failure power failure other signalsigtrap sigusr1 sigusr2 sigalrm sigvtalrm sigprof sigpoll execution and compares them against the expected ones.
for each input scenario and each interruption trigger safeexit outputs a vector of missing behaviors.
finally safeexit builds a prediction model in which the features are the input scenarios and the interruption triggers and the labels are the missing behavior vectors.
challenges.
there are three main challenges in the design of safeexit .
first it is non trivial to extract the cleanup behaviors from a system call trace since one behavior may consist of multiple system calls and there can be a number of noisy system calls.
to address this challenge we use a combination of static and dynamic approach.
speci cally safeexit rst extracts dynamic system call sequences according to the resources used by the calls then clusters sequences according to static source code semantics.
the second challenge is that program behaviors are often a ected by environments such as con gurations and workloads.
safeexit needs to predict the missing behaviors in production environments.
in this regard we apply machine learning techniques to predict the missing behaviors for an unseen input scenario.
third the expected behaviors of an interrupted execution may not be exactly the same as the ones in a normal execution.
safeexit has to select the necessary behaviors in interrupted executions.
to achieve this we study real world cleanup behaviors from programs and build a taxonomy section which helps to design heuristic rules for selecting expected behaviors.
.
triggers of program interruptions an interruption can be triggered by various reasons which often require di erent cleanup behaviors at the exit stage.
these triggers can be summarized into ve categories fatal bug e.g.
dereference of a null pointer.
the operating system noti es programs of the bugs in the form of signals user termination e.g.
an user input ctrl c will lead to a sigint signal non termination signal.
the signals that do not terminate the programs e.g.
sigstop hard exit which means the exit situation can not be handled by programs e.g.
hard restart or sigkill signal other signal signals for speci c purposes e.g.
sigtrap is often used for debug while sigusr1 is used for program speci c purpose.
table 1shows di erent types of triggers.
safeexit focuses on the types of user termination fatal bug andhard exit .
the other types of triggers do not require cleanup because the other signals are issued for speci c purposes while the non termination signals will not terminate the programs.
for interruptions caused by user terminations and hard exits a program can use the exit behaviors of its normal execution to clean up the stale states.
suppose the stale state set at the time of interruption is s and the exit behavior set of the normal execution is 753esec fse august tallinn estonia zhouyang jia shanshan li tingting yu xiangke liao and ji wang table taxonomy of cleanup behaviors.
id behavior type abbreviation impact of missing behavior fix advise delete pid le d pid the users or other programs believe the program is still running delete the .pid le delete sock fo les d sock the next startup may fail since failing to create the le delete the les delete temp le d tmp the silent consuming of disk resource delete the temp le delete shared memory d shm the silent consuming of memory resource delete the shared memory delete lock le d lck the other programs may fail since failing to obtain the lock delete the lock le unlock lock le u lck the next startup may fail since failing to obtain the lock unlock the lock le kill child process k chld the child process does not properly exit and consumes resources kill the child process write program con g le w pcfg the program con g is in corruption state change the program con g write system con g le w scfg the system con g is in corruption state change the system con g write program state le w pstat the next startup may encounter feature failures delete the state le write system state le w sstat the other programs may encounter feature failures warning write log le w log the log le is incomplete a ecting users or log analyzing tools warning sendmsg to child process s chld the target process may fail warning sendmsg to other program s prog the target program may fail warning sendmsg to network socket s net the target socket may fail warning cleanup behaviors of this type can potentially a ect other programs or the operating system.
b. if we assume that a normal exit command is issued at the time of interruption the behavior set bis enough to clean up the state set s. therefore we regard the exit behaviors of the normal execution as expected behaviors of user termination and hard exit interruptions.
for user termination interruptions we also need to extract their actual behaviors which are used to compare against the expected behaviors.
for hard exit interruptions the expected behaviors are regarded as missing behaviors directly since the program can not handle these interruptions.
for interruptions caused by fatal bugs we can not regard the exit behaviors of the normal execution as expected behaviors since the program is in an error and unknown state at the time of interruption.
for example a database program may sync its data in the exit stage of a normal execution.
when fatal bugs happen the data may be corrupted and should not be synced.
in this regard we need to select necessary behaviors from the exit behaviors of the normal execution as expected behaviors of fatal bug interruptions.
.
de nitions for the ease of presenting the design of safeexit we introduce some key concepts that will be used throughout the rest of the paper.
normal interrupted execution.
anormal execution ne is a program execution ended with a normal exit such as clicking an exit button of a graphical user interface gui program or issuing an exit command of a command line interface cli program.
in contrast an interrupted execution ine is ended by one of the trigger listed in table .
an inecan be either graceful or ungraceful.
normal interrupted trace.
atrace is the sequence of system calls of a program execution.
a normal trace nt is from a ne while an interrupted trace int is from an ine.
normal interrupted behavior.
abehavior is a sequence of syscall calls that are together to perform a high level task.
a normal behavior nb is a sub sequence of a nt while a interrupted behavior inb is a sub sequence of an int.
expected cleanup behaviors to detect ungraceful exits and localize their root causes we need to obtain the expected behaviors at the exit states of interruptedexecutions.
as discussed in section .
interrupted executions may require di erent cleanup behaviors at the exit stages according to the categories of the interruption triggers.
for interrupted executions triggered by user terminations and hard exits safeexit uses all cleanup behaviors of the normal execution as expected behaviors.
for interrupted executions triggered by fatal bugs safeexit select the expected behaviors from the cleanup behaviors of the normal execution.
we use the following heuristic rule to determine the expected behaviors in fatal bug cases the program at least cannot a ect other programs or the operating system.
according to this rule safeexit needs to select the behaviors that can potentially a ect other programs or operating system as the expected behaviors.
to achieve this we study the real world cleanup behaviors and classify them into di erent types.
these behavior types are de ned once and broadly applicable to any interrupted executions.
then we manually select the behavior types that can potentially a ect other programs or operating system.
finally safeexit automatically classi es each normal behavior into one of the types.
the behaviors belong to the selected types will be regarded as expected behaviors for fatal bug executions.
the target programs of the study include widely used realworld programs across software domains.
the programs have di erent types i.e.
gui and cli server and client.
all programs are open source mature about years or longer development history active released in the last year committed in the last month and written in c c .
the full list is shown in table .
the process to automatically extract cleanup behaviors is in section .
.
.
we totally summarize behavior types according to their system calls and resource types.
the result is shown in table as well as their impact and x suggestions.
for example a program may delete a pid le type or send a message to the xorg daemon type at its exit stage.
we nd out of the types can potentially a ect other programs or operating system.
for example if a program fails to delete the pid le when exits users or other programs may believe the program is still running type .
if a program does not kill its children processes properly the processes would still occupy the system resources type .
754automatically detecting missing cleanup for ungraceful exits esec fse august tallinn estonia algorithm pseudo code of learning prediction models.
require input scenario variables v interruption triggers i taxonomy of cleanup behaviors t ensure m msb s i s samplesinputscenario v foreach iin do nti tracesystemcall si null nb i extractbehaviorsfromtrace nti foreach jin do int i j tracesystemcall si ij inb i j extractbehaviorsfromtrace int i j end for end for unb nb nb ... nb s foreach iin do foreach jin do exb i j filterexpectedbehaviors nb i ij t msb i j where msb i j unb foreach kin do ifunb k2exb i jandunb k inb i jthen msb i j end if end for end for end for m trainpredictionmodel s i msb i j 4safeexit approach safeexit contains two phases o ine learning and online monitoring.
the rst phase trains a missing behavior predictor that given an input scenario it can predict if an ungraceful exit occurs as well as the missing behaviors.
in the second phase the predictor is deployed in the production environment to monitor the exit state of an interrupted execution for detecting ungraceful exit and its root cause i.e.
the missing behaviors .
.
learning prediction models in the rst phase safeexit trains prediction models to predict ungraceful exit and the associated missing behaviors with respect to an input scenario and a particular trigger of interrupted execution e.g.
sigint .
the input scenario is modeled as c w u where cis a list of con guration options w contains the workload values and u includes user input parameters.
algorithm 1summarizes the main steps of training prediction models.
to build the dataset for training safeexit rst generates a set of input scenarios susing a well known n wise sampling method line .
it then runs each input scenario siagainst the program to collect a system call trace ntiat the exit stage of the normal execution and extracts the normal cleanup behaviors nbi lines .
next for each interrupted execution with respect to a signal type ij e.g.
sigint safeexit collects a system call trace inti jat the exit state and extracts its interrupted cleanup behaviors inbi j lines .
safeexit obtains a list of union cleanup behaviors unb from normal executions for all input scenarios.
after that by using the taxonomy of cleanup behaviors section safeexit extracts the expect behaviors exb for each interrupted execution with respect to an input scenario and a triggers1s2s3......nb1 nb2nb1 nb3nb1 nb4......nb1nb2nb3nb4nb5... .........s1 i1 msb1 s1 i2 msb1 s2 i1 msb2 s2 i2 msb2 s1 i1 msb1 s1 i2 msb1 s2 i1 msb1 s2 i2 msb1 traindecisiontree1 traindecisiontree5inputscenariosnormalbehaviorsunionnormalbehaviorsoutputvector figure overview of the prediction model.
line .
for each behavior in unb it will be regarded as a missing behavior msb for the input scenario and the trigger if it is their expected behavior and does not appear in the corresponding interrupted behaviors lines .
finally safeexit collects the variables of the input scenario and interruption triggers as features and the missing behavior vector as labels.
the dataset is fed to decision trees implemented by scikit learn line .
the overview of the prediction model is shown in figure .
each bit of the output vector indicates a normal behavior and safeexit will train unb decision trees in total.
.
.
input sampling.
the input scenario of a program contains con guration options workloads values and user input parameters.
an exhaustive search of all combinations of these variables will lead to an exponential explosion problem.
to avoid this we sample the combinations of the input variables.
there are two factors that will a ect the sampling process the sampling method the sampling density of one variable.
sampling method.
in combinatorial sampling a well known method is pair wise or wise sampling.
for each pair of input parameters the method uses carefully chosen samples to test all possible combinations of those parameters.
similarly n wise sampling can be considered as the generalized form of pair wise sampling .
we will compare di erent sampling methods in section .
and apply the optimal method in safeexit .
sampling density of one variable.
for integer type variables safeexit needs to sample certain values instead of enumerating all possible values e.g.
the number of http request may range from to .
the sampling density can also a ect the predicting accuracy and training e ciency.
in this regard we evaluate di erent sampling density in section .
and apply the optimal parameter insafeexit .
the sampling process is implemented by the pict tool.
users need to provide the input variables and their value ranges.
users can also input the constraints across variables and safeexit can avoid the combinations that break the constraints.
all the user inputs are optional.
in the case that no variable is provided safeexit only generates one input scenario including the default con guration and an empty workload.
.
.
exit stage tracing.
an ungraceful exit potentially a ects the system state which can in turn a ect the execution of other program processes.
since the interaction between programs and the system is often performed by system calls safeexit traces system 755esec fse august tallinn estonia zhouyang jia shanshan li tingting yu xiangke liao and ji wang calls of the target program to extract cleanup behaviors at the exit stage for both the normal execution and the interrupted executions and only focuses on the system calls happening after issuing the exit command.
there are two problems in obtaining the exit traces.
first an exit trace can be long such as when the system is performing certain repetitive actions e.g.
delete a large number of les .
therefore tracing all system calls can be expensive.
the second is determining when to issue an interruption event i.e.
signals to obtain an interrupted execution since exiting before the program reaches a stable state i.e.
after the workload is processed and after that may signi cantly a ect exit behaviors.
tracing relevant system calls.
to reduce the overhead of tracing safeexit traces only the system calls that may a ect the state of the operating system which is the root cause of ue problems.
speci cally a relevant system call satis es the following two properties the call has side e ects beyond the current process and the side e ects are still e ective after the process exits.
for example the system call read can a ect the variables inside the process while write can a ect les or other processes and the e ects are still e ective after the process exits.
therefore only write is a system call of interest and thus traced.
another example is close .close will delete a le descriptor which will be deleted when the process exits anyway.
failing to close cannot a ect the operating system or other processes after the process exits.
safeexit also considers the arguments within a system call.
for example when calling open with the argument o creat it will create a new le which is a long term side e ect.
otherwise open only creates a le descriptor which will be closed when the process exits.
another example is fu te x it will change the lock state when calling with wake and do nothing when calling with wait .
toward this end we use strace to collect the system calls of the programs in table and nd system calls are used in their exit stages.
finally we summarize out of system calls that as relevant system calls.
safeexit only traces the relevant system calls with relevant arguments.
the points of exit.
in general there are three options for programs when exiting during workload.
the simplest option is to exit immediately which means the program tries to quit quickly without any operation on the current workload.
another option is to exit after serving.
in this situation the program will rst nish the workload then exit.
for example a web server will nish serving the current request before exiting.
the last option is to exit after rollback.
typical examples are database servers which can rollback the current operation for some problem situations.
when exiting immediately programs only perform some necessary cleanup behaviors.
when exiting after serving programs perform cleanup behaviors as well as workload behaviors.
when exiting after rollback programs perform rollback behaviors before cleanup behaviors.
among the above behaviors the rollback behaviors have been well studied by existing works that focus on persistency bugs.
the task of safeexit is to lter out the workload behaviors.
this problem can be solved by simply issuing the exit commands after the workload so the workload behaviors are wiped out naturally.
in this case all exit behaviors can be regarded as cleanup behaviors for safeexit .
shutdownshutdownxlogwalsndwaitstopping perform a checkpointcreatecheckpointshutdowncloggetvirtualxidsdelayingchkpt flush all datacheckpointgutsxlogbegininsertcheckpointsubtrans flush dirty pagescheckpointmultixactcheckpointpredicates2 open x write x fsync x x pg multixact offsets 0000s1 ...s3 ...figure example of the task tree in postgresql.
.
.
extracting cleanup behaviors.
reporting missing system calls is too low level to help users understand the root cause of ue problems.
safeexit extracts high level behaviors from the system calls that perform the same task.
for example in the exit stage of mysql there is the following sequence .open ib bu er pool.incomplete o creat... .write ib bu er pool.incomplete ... .unlink ib bu er pool .rename ib bu er pool.incomplete ib bu er pool .
the system call open creates a temp le which will be written by write .
after that unlink deletes the le ib bu er pool to which the temp le will be renamed.
this is a common practice to write an important le since writing the le directly may lead to data loss if the writing operation fails.
there are two steps to extract behaviors.
first safeexit extracts the system call sequence that have related resources e. .
the le names in above example.
second multiple system call sequences may perform a higher level task and safeexit needs to cluster the sequences.
extract system call sequence.
programs may have multiple threads of which the system calls may interleave.
safeexit rst classi es the system calls according to their threads identi ers tids .
second for the trace of each thread safeexit splits it into segments each of which contains the same resources e. .
le name.
third safeexit scans the trace again and detect related resources e.g.
ib bu er pool.incomplete andib bu er pool and related since they both are arguments of rename .
fourth safeexit joints the serial segments that have related sources as a sequence.
for above example safeexit will get the sequence open x write x unlink y rename x y where x ib bu er pool.incomplete y ib bu er pool .
finally safeexit removes loops in the sequences.
for example the sequence creat x write x fsync x write x fsync x rename x y will become creat x write x fsync x rename x y cluster sequences optional .
safeexit clusters sequences that perform a high level task if provided the source code.
for example in figure the system calls in the sequence s2are invoked by checkpointmultixact which is further invoked by checkpointguts .
at the same time both checkpointsubtrans andcheckpointpredicate are invoked by checkpointguts and each of them invokes its own sequence i.e.
s1ands3.
in this situation safeexit clusters sequences for di erent levels of tasks and nally build a task tree.
for example the higher level task of s2ischeckpointmultixact which ushes dirty pages while the higher level task of s1 s2and s3ischeckpointguts which ushes all data.
to build the task tree safeexit rst collects the call stack of each system call and get the longest common call stack pre x for 756automatically detecting missing cleanup for ungraceful exits esec fse august tallinn estonia table examples of execution speci c information.
before normalization after normalization open chromium.viwttl... open chromium.rwedbr... open chromium.
... writev unix ... writev unix ... writev .x11 unix x0... kill ... kill ... kill pid 1... each sequence.
second safeexit nds the longest common pre x for di erent sequences and clusters the sequences that have a common pre x. this process will be repeated recursively until the top task.
third for each node of the task tree safeexit records its function name and comments as the semantics of this task.
.
.
detecting missing cleanup behaviors.
safeexit detects the missing behaviors in an interrupted execution ineby comparing the extracted cleanup from inewith the expected behaviors section in the normal execution ne.
there are two main tasks to achieve this.
first a program may not exit when an interruption trigger happens.
for example mysql will ignore the sigint signal.
in this case mysql will not cause any ue problem even all expected behaviors are missing since mysql does not exit at all.
safeexit needs to recognize the reactions of the programs for interruption triggers.
second the traces of two executions may be di erent even under the same input scenario.
for example in the rst example of table the le names have random su xes which are di erent in two executions.
safeexit needs to eliminate the execution speci c information when comparing behaviors from two executions.
program reactions of interruptions.
we classify program reactions of interruptions into two categories good practices and bad practices.
in good practices the program may survive from the situation in this case the main process of the program will still exist after the trigger happens.
also the program can recover from the situation which means all processes exit and new processes will be generated instead.
another good practice is graceful exit which means all necessary behaviors have been performed successfully before the program exits.
on the other hand the bad practice is ungraceful exit which means any or part of cleanup behaviors are missing after the program exits.
for the cases of survive andrecover safeexit does not report any missing behavior which means all bits of the missing behavior vector are zeroes.
system call normalization.
safeexit normalizes the following execution speci c information when comparing the system calls of interrupted behaviors and expected behaviors a file name.
safeexit keeps the common substring of the le names and changes the random su x into a string of with the same length.
b output target.
in the second example of table the rst argument ofwritev is a unix type socket whose target is an inode number.
safeexit uses the utility lsof to get the responding le of the inode number and replaces the number with a real le name.
c process identi er.
the pids always change in di erent executions.
safeexit sorts the pids of each execution in ascending order and normalizes the pids to their ranks.
in the last example the pid of the rst argument in killis normalized to pid 1 which means the process with the smallest pid in the current program.
.
online monitoring and predicting the online monitoring component is a system level monitor which is implemented by the auditd tool used to record system calls and signals .
safeexit does not do any form of program instrument thus the overhead is very limited.
when an interruption is detected safeexit predicts the missing behaviors by using the real input scenario and detected interruption trigger.
if the input scenario variables are not provided in the o ine training phase safeexit will report the missing behaviors of default con guration and empty workload.
otherwise safeexit can report the predicted missing behaviors to users.
evaluation to evaluate safeexit we consider three research questions rq1 what behaviors are done when programs exit normally?
rq2 what are the root causes of ungraceful exits?
rq3 how accurate does safeexit predict missing behaviors?
insafeexit there are two main functions.
the rst is detecting missing behaviors for a given input scenario.
this includes two steps recognize normal behaviors rq1 and detect missing behaviors rq2 .
the second is predicting missing behaviors for an unseen input scenario rq3 .
in this section we evaluate safeexit on mature and active programs across domains shown in table .
.
missing behavior of a given input scenario .
.
rq1 exit behaviors in normal executions.
the insight of safeexit is to extract behaviors that are done during the exit stage of normal execution and use these behaviors as oracles for detecting the missing behaviors in the interrupted executions so as to localize the root causes of ungraceful exits.
therefore we need to know what have been done when programs exit normally.
we run the benchmark programs under the default con guration and empty workload then obtain the exit behaviors from the normal executions using the approach described in section .
.
.
the results are shown in the fourth column of table .
for example apache performs four types of behaviors at the exit stage when exiting normally i.e.
deleting the pid le killing children processes writing log les and sending messages to its children processes.
one program may perform multiple behaviors that belong to the same behavior type.
for example apache writes to di erent log les i.e.
access lo anderror lo .
in total safeexit detects types of behaviors from the programs about .
for each program .
besides every program will stop its main process at the exit stage for space reason we do not list the behavior.
two out of the programs do not perform any cleanup behaviors at their exit stages i.e.
bftpd andmpv .
most programs with gui will send messages to other daemons including xorg dbus and ibus while most servers will delete pid les .
these results indicate that most programs have cleanup behaviors at their exit stages supporting our assumption that the expected exit behaviors can be obtained from the behavior of the 1for ease of reproducing the safeexit source code and all data will be available in 757esec fse august tallinn estonia zhouyang jia shanshan li tingting yu xiangke liao and ji wang table exit behaviors of normal execution and reactions of interrupted executions.
domain program version type exit behaviors of normal executions program reactions1 missing behaviors web serverapache .
.
cli server d pid k chld w log s chld s g b g b b b b b s b s lighttpd .
.
cli server d pid w log s g b g b b b b b s b b nginx .
.
cli server d pid s chld s g g g b b b b b s b b broswerbrave .
.
gui client d shm d lck u lck k chld w pcfg w pstat s chld s prog g g b g b b b b b s b b chromium .
.
gui client d shm d lck u lck k chld w pcfg w pstat s chld s prog g g b g b b b b b s b b firefox .
.
gui client d tmp d shm d lck u lck w pcfg w pstat s prog s net b b b b r r r r r s b b gnomeweb .
.
gui client d tmp d shm u lck w pcfg w scfg w pstat s prog s net b g b g b b b b b s b b databasemonetdb .
cli server d pid d sock u lck w log s g g g b b b b b s b b mysql .
.
cli server d pid d sock d tmp d lck w pstat s s g g b b b b b s b b postgresql 11rc1 cli server d pid d sock d tmp d shm d lck k chld w pstat s g b g b b b b b s b s sqlite3 .
.
cli client w pstat b s b b b b b b b b b b emailgeary .
dev gui client s prog b b b b b b b b b s b b opensmtpd .
.
cli server d pid d sock s prog b g b g b b b b b s b b post x .
.
cli server s prog s g g g g b g b g s b b thunderbird .
.
gui client d tmp d lck u lck w pcfg w pstat s prog s net b b b b r r r r r s b b ftpbftpd .
cli server filezilla .
.
gui client d tmp u lck w pcfg s prog b b b b b b b b b s b b gcommander .
.
gui client w pcfg s prog b s b b b b b b b s b s proftpd .
.5e cli server d pid d lck u lck w log w pstat s g g g g g g g g s g b pure ftpd .
.
cli server d pid g g g g b b b b b s g b text editoremacs .
.
gui client d tmp w pstat s prog g g g g g g g g g s g g gedit .
.
gui client w pcfg w sstat s prog b b b b b b b b b s b b vim .
.
cli client d tmp w pstat b b b b g g g g g s g g image editordarktable .
.
gui client d lck w pcfg s prog b b b b b b b b b s b b graphicmagick .
.
gui client s prog b b b b b b b b b b b b gthumb .
.
gui client w pcfg w scfg w pstat s prog b b b b b b b b b s b b kolourpaint .
.
gui client s prog b b b b b b b b b s b b syn gstudio .
.
gui client d sock w pcfg w pstat s prog b b b b b b b b b s b b playeraudacious .
gui client w pstat s prog g g g g b b b b b s b b mpv .
.
cli client rhythmbox .
.
gui client w pcfg w pstat s prog b b b b b b b b b s b b smplayer .
.
gui client d tmp d lck u lck w pcfg w pstat s prog b b b b b b b b b s b b totem .
.
gui client w pstat s prog b b b b b b b b b s b b vlc .
.
gui client u lck w pcfg w pstat s prog g g g g b b b b b s b b network monitornetsni ng .
.
cli client w scfg s g g g b b b b b b b b wireshark .
.
gui client w pstat s prog b b b b b b b b b s b b o ce suite2libreo ce .
.
.
gui client d tmp d lck w pcfg w pstat w log s prog s b b b b r r r r s b b openo ce .
.
gui client d tmp d lck w pcfg w log s prog s b b b b r r r r s b b s r g b mean the di erent reactions where s for survival r for recovery g for graceful exit and b for missing behaviors.
the reactions of interrupted executions are listed in the order of sighup sigint sigquit sigterm user terminations and sigill sigabrt sigbus sigfpe sigsegv sigpipe sigxcpu sigxfsz fatal bugs .
2each o ce suit contains multiple programs e.g.
writer calc impress whose exit behaviors are exactly the same.
therefore we regard them as one program.
program exit in a normal execution.
as for the other two programs safeexit cannot determine whether there is an ungraceful exit.
there is no false positive or false negative with regard to detecting exit behaviors since the behaviors of a program are xed for a given input scenario we do not consider the order of behaviors in case of concurrency programs .
.
.
rq2 root causes of ungraceful exits.
the goal of rq2 is to evaluate whether safeexit can detect ungraceful exits and the root causes i.e.
missing behaviors of the ungraceful exits.
there are four reactions when programs encounter interruptions i.e.
survive recover graceful exit and ungraceful exit according to section .
.
.
safeexit rst detects the reactions of the programs then reports missing behaviors for ungraceful exits.
the results are shown in the rightmost two columns of table .
in the table s r g b indicate the reactions of the program for different interruption triggers where s for survival r for recovery g for graceful exit and b for missing behaviors i.e.
ungraceful exit .
the reactions are listed in the order of user terminations sighup sigint sigquit sigterm and fatal bugs sigill sigabrt sigbus sigfpe sigsegv sigpipe sigxcpu sigxfsz .
for hard exits e.g.
sigkill programs always exit ungraceful thus we do not list them.for example apache will read the con guration les and restart the server children processes when receiving sighup .safeexit reports that apache can survive from si hup since the main process still exist after the signal.
for sigint andsigterm all processes will exit and safeexit detects all necessary behaviors are successfully performed.
as for some fatal signals and sigquit safeexit nds apache exit ungracefully and reports missing behaviors.
for example the main process will send termination signals to its children processes k chld during normal exit.
in interruptions triggered by bugs like sigsegv the behavior is missing and the children processes become orphan processes.
for space reason we do not list the behaviors.
in the programs that perform cleanup behaviors safeexit evaluates their reactions for interruption triggers i.e.
interrupted executions.
safeexit nds out of the or .
executions exit ungracefully about .
on average for each program .
among the ungraceful exits safeexit detects missing behaviors in total i.e.
.
for each ungraceful exit .
speci cally servers i.e.
web server database server ftp server and email server handle user terminations .
better than other situations including clients for user terminations .
servers for fatal 758automatically detecting missing cleanup for ungraceful exits esec fse august tallinn estonia table target programs for the accuracy evaluation.
program var.
dep.
program var.
dep.
apache yes gedit no chromium yes gthumb no mysql yes smplayer yes thunderbird yes wireshark no filezilla no libreo ce no var.
number of input scenario variables con g options and workload variables.
dep.
dependence whether the exit behaviors are dependent on its input scenario.
bugs .
and clients for fatal bugs .
.
this is because many server functions e.g start stop restart or update con g are implemented by user termination signals.
there is one program i.e.
emacs that handles all interruptions well and one program i.e.
graphicmagick that exits ungracefully for any interruption.
most programs survive a sigpipe signal.
these results suggest that ungraceful exit is the most common reaction .
when programs encounter interruptions.
safeexit can be widely used to help users to solve problems caused by ungraceful exits.
in safeexit the accuracy of detecting missing behaviors is dependent on the quality of code in the normal exit.
for example if developers perform an unnecessary behavior in normal exit code safeexit will report a false positive when the behavior is missing.
if developers miss a necessary behavior in normal exit code safeexit will report a corresponding false negative.
.
rq3 accuracy of behavior prediction program behaviors are a ected by input scenarios like con gurations and workloads.
for default con guration and empty workload safeexit can precisely report the missing behaviors when ungraceful exit happens since the program behaviors are xed.
as for other scenarios safeexit needs to sample input scenarios build a prediction model and predict the missing behaviors.
to achieve this safeexit implements a script for each target program to execute its input scenarios automatically.
in general for programs from one domain their input scenarios are similar.
therefore we select one highly con gurable program from each domain to evaluate.
table 5shows the target programs.
for each program due to the large input space we manually choose some con guration options and workload variables.
during this process we avoid choosing con guration options that will not a ect the exit behaviors of the program.
for example in apache the con guration servername gives the name and port that the server uses to identify itself which can not a ect the exit behaviors.
nevertheless the exit behaviors of ve programs are still independent of the chosen variables.
in these cases safeexit always achieves prediction accuracy.
as for the programs whose exit behaviors are dependent on their input scenarios we evaluate the predicting accuracy and training e ciency when using di erent sampling methods and sampling densities as discussed in section .
.
.
for each program we randomly sample input scenarios and interruption triggers as the test set.
input scenarios in the test set are di erent from the ones in the training phase.
then safeexit outputs a vector of missing behaviors for each test case i.e.
an input scenario and an interruption trigger.
we use two widely used metrics i.e.
precision andrecall to evaluate the prediction accuracy.table accuracy and e ciency of di erent sampling methods and sampling densities.
programsampling method sampling density wise wise wise d d d apache66.
.
.
.
.
.
chromium57.
.
.
.
.
.
mysql88.
.
.
.
.
.
thunderbird95.
.
.
.
.
.
smplayer82.
.
.
.
.
.
average78.
.
.
.
.
.
.
.
.
.
fscore of missing behavior prediction.
number of training samples.
suppose there are nbehaviors in the vector i.e.
b1 b2 .
.
.
bn.
let x i denote the total number of test cases that miss bi y i denote the number of test cases that safeexit predicts biwill miss and y0 i denote the number of test cases that biis truly missed.
the predicting precision of bi p i is the ratio of y0 i toy i while the predicting recall r i is the ratio of y0 i tox i .
we further calculate the averaged precision pand recall rof all behaviors.
if a cleanup behavior is missed in the test set but never happens in the training stage its precision and recall rates are regarded as zeroes.
for the ease of comparison we nally calculate fscore which is the harmonic mean of pand r. as shown in table we evaluate three sampling methods i.e.
wise wise and wise and three sampling densities i.e.
d d d .
for an integer variable safeexit samples dvalues bmax min d i c min i2 where max andmin are the ranges of the variable.
for example given a variable the sampled values are when d .
in table we rst evaluate the sampling methods using d .
for each method we provide the fscore and the number of training samples.
in term of the averaged accuracy the wise .
is much higher than wise .
and the wise .
is close to wise .
.
while the numbers of samples are increasing linearly thus the wise takes much more time.
therefore safeexit chooses wise as the optimal method.
next we evaluate di erent sampling densities using wise .
the accuracy improvements from d to d and from d to d are similar.
safeexit uses d as the default density since its high accuracy while users can choose custom values according to their preference on predicting accuracy or training e ciency.
these results show that the exit behaviors of a program may or may not be dependent on its input scenarios.
for programs whose exit behaviors are dependent on their input scenarios di erent parameters sampling method and sampling density can a ect the predicting accuracy and training e ciency.
under the optimal parameters wise and d safeexit can achieve a high accuracy .
on predicting missing behaviors while using limited inputscenario samples .
on average in the training phase.
759esec fse august tallinn estonia zhouyang jia shanshan li tingting yu xiangke liao and ji wang discussion bugs during normal exiting.
insafeexit the key insight is to learn the expected behaviors of ungraceful exits from normal exits.
we assume that developers carefully designed the work ow of normal exit and the behaviors during normal exiting can server as oracles.
in the cases that there are bugs during normal exit safeexit cannot eliminate the e ects of the bugs resulting in false positives or false negatives.
in section .
we summarized several patterns that what behaviors should be performed at the exit stage for a certain type of programs.
inspired by these patterns we can detect the bugs of normal exit by mining exit rules across programs.
we leave this feature to further work.
recover at the next startup.
some programs may exit ungracefully when fatal situations happen and recover the corrupted states at the next startup.
for example if there is a fatal bug in postgresql the cleanup behaviors will be performed at the next startup after version .
.
another example is the o ce suite which can recover both user terminations and fatal bugs at the next startup.
safeexit does not analyze the program behaviors of the startup stage thus still reports the missing behaviors in this situation.
the results of safeexit are valid until the next startup since the operating system contains corrupted states between the time of the crash and the next startup.
long term running programs only.
safeexit needs to learn the behaviors that should be performed at the exit stage.
the beginning of the exit stage is the time when clicking an exit button of gui program or issuing an exit command of a cli program.
this exit mechanism is used in long term running programs meaning there is an explicit exit action performed by users the operating system or other programs.
for some programs however there is no such exit action.
taking the compiler program as an example a compiler starts when issuing the start command and exits when nish compiling.
in this case there is no explicit exit action thus safeexit cannot recognize the exit stage of a compiler.
related work exception handling bugs.
there is a long line of research focusing on exception handling mechanisms .
for example ebert et al .
conducted a survey of developers and an analysis of exception handling bugs.
oliveira et al .
presented an empirical study on the relationship between the usage of android abstractions and uncaught exceptions.
filho et al .
presented a study of the adequacy of the aspectj language for modularizing exception handling code.
jakobus et al .
contrasted exception handling code across languages from open source projects.
rahman et al .
proposed a context aware code recommendation approach that recommends exception handling code examples.
barbosa et al .
presented a tool to recommend repairs of exception handling violations with aware of the global context.
weimer et al .
presented a data ow analysis for nding exception handling bugs in java programs.
exception handling does not always end up with an exit for example programs may create a new le when the library function fopen cannot nd the target le.
therefore existing work does not focus on cleanup behaviors on the exit stage.
safeexit is a complementary tool to the existing exception handling techniques.data corruption and crash recovery.
prior e orts on persistent data consistency have looked at nding storage or distributed system errors .
gao et al .
presented a comprehensive study on crash recovery bugs from four distributed systems.
gunawi et al .
proposed a testing framework for cloud recovery.
subramanian et al .
injected faults into the mysql dbms and found corruption can greatly harm the system.
yang et al .
built a system fisc for model checking le systems.
ganesan et al .
analyzed how modern distributed storage systems behave in the presence of le system faults.
wang et al .
presented a comprehensive study on real world data corruption incidents reported in hadoop bug repositories.
some works focus on persistency bugs in storage systems which help to clean data corruption caused by problem situations.
while safeexit is designed to clean general states under ungraceful exit conditions.
other works are targeting errors during recovery but can not help when programs try to exit.
while we nd the majority programs will exit ungracefully in problem situations.
other related work.
there has been some other research related to safeexit .
similar to safeexit many works mined software traces for various purposes but few work focuses on missing behaviors of ungraceful exits.
wang et al .
presented an automated framework that can detect and validate race conditions hardware interrupt.
while safeexit focuses on the ungraceful exit problems caused by software interrupts.
shan et al .
addressed the problems of data loss failure to resume restart or resuming restarting in the wrong state in android applications.
these problems are caused by incorrect handling of instance data and are easily triggered by just pressing the home or back buttons.
while safeexit is targeting the problems caused by ungraceful exits in pc programs.
conclusions this paper presented safeexit a tool that can automatically detect and pinpoint the root causes of ue problems which can help users to x the problems with lightweight solutions without having to reboot the system.
safeexit learned the missing behaviors of interrupted executions under di erent input scenarios and interruption triggers and built a prediction model to predict the missing behaviors of an unseen input scenario.
during the learning phase we studied the real world cleanup behaviors to help safeexit select the expected behaviors for di erent interrupted executions.
finally we evaluated safeexit by using widely used programs from domains.
the experimental results showed that safeexit can e ectively extract the cleanup behaviors for normal executions and detect the missing behaviors for interrupted executions.
we also evaluated the e ects of sampling method and sampling density for the training e ciency and predicting accuracy helping safeexit to choose the optimal parameters.