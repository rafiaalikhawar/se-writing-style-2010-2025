grey box concolic testing on binary code jaeseung choi kaist daejeon republic of korea jschoi17 kaist.ac.krjoonun jang samsung research seoul republic of korea joonun.jang samsung.comchoongwoo han naver labs seongnam republic of korea cwhan.tunz gmail.comsang kil cha kaist daejeon republic of korea sangkilc kaist.ac.kr abstract we present grey box concolic testing a novel pathbased test case generation method that combines the best of both white box and grey box fuzzing.
at a high level our techniquesystematically explores execution paths of a program under testas in white box fuzzing a.k.a.
concolic testing while not giving up the simplicity of grey box fuzzing it only uses a lightweightinstrumentation and it does not rely on an smt solver.
weimplemented our technique in a system called eclipser andcompared it to the state of the art grey box fuzzers includingaflfast laf intel steelix and vuzzer as well as a symbolicexecutor klee .
in our experiments we achieved higher codecoverage and found more bugs than the other tools.
index t erms software testing concolic testing fuzzing i. i ntroduction fuzz testing fuzzing for short has been the de facto standard for finding security vulnerabilities in closed binary code .
security practitioners appreciate fuzzing because italways finds bugs along with proof.
major software companiessuch as microsoft and google employ fuzzing nowadays intheir software development life cycle as a means of assuringthe security of their products .
most notably grey box fuzzers such as afl aflfast steelix vuzzer angora collafl and t fuzz are emerging as the state of the art in bugfinding.
grey box fuzzing generates test cases with an evolu tionary process.
specifically it executes test cases and eval uates them based on a fitness function a.k.a.
an objective function .
it then prioritizes those with better fitness evolvesthem to find test cases that meet the objective and continues toiterate the entire process with the hope of exercising a buggypath that triggers program crashes.
current grey box fuzzers use code coverage as their fitness function.
accordingly they are sometimes referred to ascoverage based fuzzers .
for example afl and its successors employ an approximated form ofbranch coverage while vuzzer uses weighted basic blockhit counts as its fitness function.
it is plain that the likelihoodof exercising interesting execution paths of the program undertest put increases by maximizing the code coverage.
however existing grey box fuzzers suffer from exercising new branches even with the coverage based guidance as codecoverage does not change sensitively over input mutations.
in particular two program executions with two different inputsmay achieve the same code coverage even though the com pared values of a conditional branch in the executions aredistinct.
in other words code coverage can provide feedbackonly if a conditional branch is penetrated with a randomlygenerated input but it does not directly help generate suchinput.
this lack of sensitivity makes it difficult for grey box fuzzers to generate high coverage test cases in somecircumstances for example when the put compares input toa specific magic value.
even the current state of the art grey box fuzzers such as aflgo steelix and vuzzer have more or less the same problem.
consequently it is widely believed that grey box fuzzing cannot be a sole test case generation algorithm despite itseffectiveness at finding vulnerabilities.
therefore grey boxfuzzers are often augmented by heavy cost white box analysessuch as dynamic symbolic execution and fine grained taint analyses or by providing initialseed inputs to direct the test case generation process .for example angora and driller leverage fine grainedtaint analysis and dynamic symbolic execution respectively toimprove code coverage of grey box fuzzing.
meanwhile white box fuzzing a.k.a.
dynamic symbolic execution or concolic testing can systematicallygenerate test cases by solving branch conditions but it is fun damentally limited by the scalability leaving aside the classicpath explosion problem.
first white box fuzzers analyze everysingle instruction of the put.
because it instruments everysingle instruction of the put every fuzzing iteration entailsa significant computational cost.
second symbolic executionbuilds up symbolic path constraints for every execution path.solving such constraints with an smt solver is computa tionally expensive.
furthermore storing symbolic expressionsfor every single memory cell affected by symbolic inputsrequires significant memory space.
in this paper we propose a novel test case generation technique called grey box concolic testing and implement it in a tool referred to here as eclipser.
grey box concolic testingefficiently generates test cases satisfying branch conditions asin white box fuzzing while not losing simplicity it does notrely on expensive program analysis techniques.
thus it scalesto real world applications as in grey box fuzzing.
our approach resembles generational search which is a search strategy widely used in white box fuzzing where a single program execution produces a generation of test cases by resolving every conditional branch encounteredduring the execution.
grey box concolic testing performs apath based test case generation too but it tries to resolveconditional branches in a grey box manner it instruments the ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
put and observes its execution behavior to generate test cases.
the key difference between grey box concolic testing and white box fuzzing is that our approach relies on an approximated form of path constraint which partially describes input conditions to exercise each execution path of the put.
the approximated path constraints help us find inputs that can penetrate conditional branches without resorting to cpu or memory intensive operations such as smt solving.
naturally the path constraints generated from grey box concolic testing are imprecise but in practice they are precise enough to quickly explore diverse execution paths.
the primary design decision here is to trade off simplicity for precision.
of course the lack of precision introduces incomplete exploration of paths in the put but eclipser compensates this by alternating between grey box concolic testing and classic grey box fuzzing as in driller .
even though grey box concolic testing does not fully cover conditional branches of the put the grey box fuzzing module continues to cover new paths and branches and vice versa.
we found that in practice this design decision effectively expands the capability of eclipser beyond that of the current state of the art grey and white box fuzzers in terms of both finding vulnerabilities and reaching high code coverage.
we evaluated eclipser against current state of the art fuzzers.
the practicality of our system as a test case generator was confirmed by an experiment we performed against klee a state of the art symbolic executor known to excel in generating tests with high coverage from given source code .
in the experiment eclipser achieved .
higher code coverage than klee on gnu coreutils which is a wellknown benchmark used for evaluating test case generation algorithms without the help of smt solvers.
to evaluate eclipser as a bug finding tool we compared eclipser against several state of the art grey box fuzzers such as aflfast laf intel steelix and vuzzer .
we also ran eclipser on binaries extracted from debian .
and found unique bugs from programs.
we have reported all the bugs we found to the developers.
in summary this paper has the following contributions.
we introduce a novel path based test case generation algorithm called grey box concolic testing which leverages lightweight instrumentation to generate highcoverage test cases.
we implement eclipser and evaluate it on various benchmarks against state of the art fuzzers including aflfast laf intel steelix and vuzzer.
according to the evaluation eclipser excels in terms of both code coverage and bug finding compared to them.
we ran eclipser on real world linux applications and found previously unknown bugs.
cve identifiers were assigned for of them.
we make the source code of eclipser public for open science b ackground and motiv ation a. grey box fuzzing fuzzing is essentially a process of repeatedly executing a program under test put with generated test cases.
greybox fuzzing evolves test cases within a feedback loop in which executions of the put with each test case are evaluated by a criterion that we call a fitness function .
most grey box fuzzers use code coverage as their fitness function although specific implementations may differ.
afl for instance uses branch coverage modulo some noise to determine which input should be fuzzed next.
despite their recent success coverage based grey box fuzzers are linked to a major drawback in that their fuzzing process involves too many unnecessary trials to find a test case that exercises a specific branch.
this is mainly due to the insensitivity of the fitness function used for fuzzing.
informally speaking a fitness function is sensitive if the fitness can be varied easily by a small modification of the input value.
any code coverage metric e.g.
node coverage and branch coverage is insensitive because there is no intermediate fitness between two executions that cover the true and the false branch.
therefore it is difficult to find an input that flips a given branch condition.
the necessity of sensitive fitness function is widely recognized in search based software testing where test case generation is considered as an optimization problem.
one notable fitness function is branch distance which is a distance between the operand values of a conditional branch.
fuzzing community has been recently started to employ the idea angora leveraged branch distance to improve its fuzzing performance.
eclipser leverages the similar insight but uses the sensitivity to directly infer and solve approximated branch conditions not leaning on metaheuristics.
both approaches are orthogonal and complementary to each other.
b. notation and terminologies we let an execution be a finite sequence of instructions we do not consider a program execution with an infinite loop for instance.
this is not an issue in fuzzing because fuzzers will forcefully terminate the put after a certain period of time which is typically a parameter to fuzzers.
we denote an execution of a program pwith an input iby p i .
in our model an input is a byte sequence although we can easily extend it to represent a bit string.
for a given input i w el e t i be thenth byte value of i. we denote an input derived by modifying i to become vbyi .
throughout the paper we interchangeably use the terms test case and test input .
we let an input field be a consecutive subsequence of an input.
there can be many input fields for a given input and input fields may overlap.
approximate path constraint.
in symbolic execution a path constraint is a predicate on the input such that if an execution path is feasible then the corresponding path condition is satisfiable.
since our approach tries to be lightweight we do not trace the exact path conditions but an approximated version that we call an approximate path constraint .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1int vulnfunc int32 t intinput char strinput if intinput if strcmp strinput bad!
crash 6int main int argc char argv char buf int fd open argv o rdonly read fd buf sizeof buf buf vulnfunc int32 t buf buf return a an example program written in c. error handling routines are intentionally not shown for simplicity.
fuzzer version release class binary hit time eclipser .
leftcircle circle .64s klee .
.
circle .32s laf intel 8b0265 leftcircle circle 430s afl .51b leftcircle circle aflfast 15894a leftcircle circle aflgo d650de leftcircle circle b comparison between state of the art fuzzers in our example program.
leftcircle circleand circlerepresent grey box and white box methodology respectively.
the fifth column shows whether a fuzzer can handle binary code or not.
the sixth column indicates whether a fuzzer has found the crash in hour.
fig.
.
our motivating example and a comparison of different fuzzers.
seed.
in this paper we let seed be a data structure that represents an input for a specific program.
we denote a seed for a program passp and the execution of pwith the seed spas p sp .
thenth byte of the seed spis denoted by sp .
every byte of a seed is tagged with a field constr which is an independent subset of an approximate path constraint with regard to the byte.
we can access an approximate path constraint of the nth byte of a seed spwith the dot notation sp .constr .
for a given seed sp thenth byte of the seed sp should satisfy sp .constr in order to exercise the same execution path as p sp .
c. motivation figure 1a shows an example program that motivates our research.
note that we use c representation for ease of explanation although our system works on raw binary executables.
it takes in a file as input and uses the first bytes of the file as an integer and the rest bytes as a byte string by appending a null character at the end line .
these two values are used as parameters to the function vulnfunc .i n order to find the crash in line we need to provide the bit integer and the string bad!
as input to the function.
can current grey box fuzzers find the test input that triggers this crash?
how effective are grey box fuzzers at finding such a simple bug?
to answer these questions we fuzzed our example program with state of the art fuzzers as well as with eclipser for hour each on a single core of intel xeon e3 v3 processor .
ghz .
we selected four open sourced greybox fuzzers including afl aflfast aflgo and laf intel1 .
we also chose a popular symbolic executor 1we selected laf intel instead of steelix because steelix is not opensourced.
one may consider steelix as an improved version of laf intel.i.e.
a white box fuzzer klee .
notice some of the fuzzers i.e.
klee laf intel and aflgo can only operate on source code.
thus we ran them with the source while we ran the other fuzzers on the compiled binary.
for example we ran afl in a qemu mode .
to run aflgo we gave line as a target location to give it a guidance.
figure 1b summarizes the result.
all the grey box fuzzers except laf intel failed to find the buggy test case.
laf intel succeeded because it breaks down the multi byte comparison statement into multiple single byte comparisons which effectively makes code coverage metric sensitive to input mutations.
note however laf intel was slower than eclipser in finding the bug even with source based instrumentation which entails lower overhead than binary level instrumentation.
notably the result was even comparable to klee.
eclipser was twice slower than klee in finding the bug but eclipser runs directly on binary code whereas klee requires source code.
furthermore symbolic execution quickly slows down as it encounters more conditional branches because of smt solving while complex path conditions do not significantly affect the performance of eclipser.
indeed eclipser achieved even higher code coverage than klee on gnu coreutils as we discuss in v c and we also show that eclipser can scale to handle large real world applications in v e. this example highlights the potential of grey box concolic testing.
while our technique compromises the precision of white box fuzzing it quickly produces test cases for exercising various distinct execution paths of the put without relying on any heavy cost analyses.
iii.
g rey box concolic testing grey box concolic testing is a way of producing test cases from a given seed input.
at a high level it behaves similarly to dynamic symbolic execution using the generational search strategy where an execution of the put with a seed produces a generation of test cases by expanding all feasible branch conditions in the execution path.
grey box concolic testing operates in a similar manner but it selectively solves branch conditions encountered in the path while not relying on smt solving.
the key aspect of our approach is to maintain an independent subset of an approximate path constraint per each input byte of a seed.
the constraints help generate distinct test cases that can be used to exercise the same or similar execution path of the put by resolving the constraints.
with such test cases we can see that some of the conditional branches in the path compare distinct input values even though they take the same execution path.
we use such an execution behavior to penetrate conditional branches in a grey box manner.
our technique effectively resolves branch conditions like whitebox fuzzing i.e.
concolic testing while keeping our system lightweight and scalable like grey box fuzzing.
a. overview grey box concolic testing operates with four major functions s pawn identify select and s earch .
the crux authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm grey box concolic testing.
1function greyconc p sp k pc approximate path constraint seeds execs spawn p sp k conds identify p execs forcond inselect conds do s prime p c search p k pc execs cond seeds seeds s prime p pc pc c merge two constraints return seeds of grey box concolic testing is expressed in algorithm with these functions.
spawn p s p k execs spawn takes in a program p a seedspand a byte offset kas input.
it first generates a set of nspawn distinct inputs by modifying the kth byte of sp wherenspawn is a user parameter.
it then executes pwith the generated inputs and returns the executions execs see iii c .
identify p execs conds identify takes in a program pand a set of executions execs as input.
it identifies a sequence of conditional statements conds that are affected by the kth input byte see iii d .
select conds conds prime select returns a subsequence from the given sequence of conditional statements.
in our current implementation of eclipser this step simply returns a subsequence of maximum nsolve randomly selected conditional statements where nsolveis a user parameter see iii e .
search p k pc execs cond s prime p c search seeks to penetrate a given conditional statement cond and returns a new seed s prime pthat can exercise the new branch at cond i.e.
the branch not taken by p sp along with a constraint c. the constraint crepresents input conditions to follow the current execution p sp .
the generated seed takes the same execution up to cond as p sp and exercises the opposite branch at cond see iii f .
at a high level grey box concolic testing takes in a program p a seed input sp and a byte position kas input and outputs a set of test cases that cover execution paths different than p sp .
unlike typical concolic testing our approach takes in an additional parameter kto specify which input byte position we are interested in.
this is to simplify the process of greybox concolic testing by focusing only on a single input field located at the offset k. although our focus is on a single input field it is still possible to penetrate conditional branches where the condition is affected by multiple input fields because our strategy may find a satisfying assignment for each one input field at a time.
furthermore even if s earch cannot find a satisfying solution eclipser performs random mutation to compensate for the error iv .
handling such cases in a general fashion is beyond the scope of this paper.
the variable pcrepresents an approximate path constraint2if intinpu t if strcmp strinput bad!
add eax eax eax intinput inc eax cmp eax jelabel 1call strcmp cmp eax jelabel 2 fig.
.
our running example snippet.
for the execution p sp .
specifically pcis a map from a byte inspto an independent constraint for the corresponding byte which is initially an empty map in line of algorithm .
the approximate path constraint grows as we encounter conditional statements in the execution.
note that this data structure is inspired by independent formulas used in .
grey box concolic testing instruments every comparison instruction in the execution but selects only a subset of them in line for building the constraint pc thereby it generates an approximate path constraint.
for each of the selected conditional statements we add the corresponding formula to pc line .
note that this process is the same as dynamic symbolic execution except that we maintain an approximated subset of the path constraint.
b. example to describe our technique let us revisit the motivating example in ii c. figure presents a code snippet taken from the example and the corresponding binary code.
we assume that the initial seed file spconsists of eight consecutive zeros nspawn is set to and the current offset kis zero.
eclipser operates by moving around this offset kthroughout a fuzzing campaign as we describe in iv.
suppose s pawn generates three inputs sp sp andsp and executes pwith the inputs to produce three executions p sp p sp and p sp .identify then observes from the executions that the first cmp instruction compares the integer with three different values in eax and .
from the overlapping execution prefix of the three i dentify returns a pair of the comparison instruction and the following conditional jump instruction.
next s elect takes the pair and simply returns it as there is only one item to consider.
finally search checks the relationship between the three values and and the corresponding compared values and in the overlapping execution.
in this case s earch infers the following linear relationship eax sp .
by solving this equation we obtain 0x3d34 which is the value of intinput satisfying the first condition.
however the solution does not fit in one byte.
thus we have to infer the size of the corresponding input field which includes the first byte since k and its neighboring bytes.
we consider input sizes up to bytes starting from size .
in this case the byte solution works and it will be used to generate a test case s prime p by replacing the first two bytes of sp which results in the following byte file authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in a hexadecimal representation 3d .search executes the put with this input to see if we can penetrate the conditional branch.
since we can exercise the new branch it returns the generated seed that contains the approximate path constraint for this branch sp mapsto sp mapsto where the square brackets represent a closed interval.
we describe how we encode an approximate path constraint in iv c. eclipser now repeats the above processes by using s prime pas a new seed while incrementing k. whenk spawn returns the following three executions p s prime p p s prime p and p s prime p .identify finds the correspondence between the fifth input byte k and eax.
search then figures out that the eax value monotonically increases with regard to s prime p .
it performs binary search by mutating the kth input byte and finds out that eax changes from to when the input byte changes from 0x42 b to0x43 c .
since we did not find a solution which makes eax be zero we extend the input field size by one and perform another binary search between 0x4200 and 0x4300 .
we repeat this process until we find the solution bad!
which makes the put exercise the true branch of the conditional statement.
finally s earch produces a seed that contains the string bad!
.
c.spawn spawn generates test inputs by mutating the kth byte of the seed spbased on the constraint sp .constr and returns executions of pwith regard to the generated inputs.
the primary goal here is to produce a set of ntest inputs i1 i2 in such that p i1 p i2 p in .
finding such inputs with an smt solver is feasible in practice but recall that one of our design goals is to be able to solve approximate path constraints in a lightweight manner.
eclipser uses an interval to represent approximate path constraint see iv c .
therefore finding inputs that satisfy an approximate path constraint is as easy as choosing a value within an interval.
if the constraint sp .constr was precise as in symbolic execution then we could always generate distinct test inputs that can be used to exercise the exact same path of the put i.e.
we could generate inputs such that p i1 p i2 p in .
however our approach can produce false inputs that do not satisfy the actual path constraint due to the incompleteness of sp .constr .w e note that this is not a serious issue as our focus in i dentify is on the overlapping execution prefix.
we denote the maximum number of executions to return in spawn bynspawn i.e.
n nspawn.
this is a configurable parameter by an analyst.
in the current implementation of eclipser we set this value to by default which is chosen based on our empirical study in v b. s pawn executes the put nspawn times for a given seed whereas traditional symbolic execution runs the put only once.
this is the major trade off that we have to accept for designing a scalable fuzzer.b1 b2 b3 b4 if i 0x7f if i 0x49 if i 0x70 pathexercised withi path exercised with i prime fig.
.
a cfg where b1 ... b 4are conditional branches.
two execution paths p i and p i prime diverge at the conditional branch b3.
the left and the right branches correspond to true and false branches respectively.
d.identify the primary goal of i dentify is to determine the correspondence between an input byte at the offset kand conditional statements in p sp .
it returns a subsequence of p sp which contains all the conditional statements affected by sp .
to achieve the goal one may use fine grained taint analysis.
however it is a memory hungry process because it assigns an identifier for each input byte and maintains a set of such ids for every expression affected by a given input.
there are several studies on reducing the space efficiency of finegrained taint analysis but they assume significant overlaps between set elements.
furthermore taint analysis instruments every single instruction of the put which can be computationally expensive and too slow for fuzzing.
we use a simple and scalable approach that involves executing the put multiple times.
recall that s pawn returns nspawn executions based on test inputs generated by mutating thekth byte of s. by observing the behavioral difference in the executions we can identify the correspondence between thekth byte and conditional branches in the executions.
specifically we first extract a set of conditional statements at the same position of the overlapping execution prefixes.
we then determine whether a conditional statement bis affected by thekth byte of the seed by observing the difference in the decisions of b. this simple approach provides sensitive feedback about which conditional branches in the executions are affected by the input byte.
note that the imprecision of approximate path constraints is not an issue here since we can always have executions that partially overlap.
furthermore since s pawn generates inputs by mutation some of the produced executions may exercise totally distinct execution paths and thereby cover interesting paths of the put.
eclipser can benefit from such by products.
figure illustrates a case where we execute a program p with two inputs iandi primethat are different only by the byte value at the offset .
there are three conditional statements b1 b2 andb3in the overlapping prefixes of the executions p i and p i prime .
in this example we can observe that the compared values for b1andb3are different in the executions.
therefore we conclude that the eleventh input byte i and i prime has a correspondence with b1andb3.
e.select during i dentify we may end up having too many conditional statements to handle.
this phenomenon is often referred authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mov ebx f input 2cmp ebx 3jelabel input020ebx fig.
.
monotonic input output relationship.
to as a path explosion problem in dynamic symbolic execution.
for example consider the following for loop where inp indicates a user supplied input.
for i i inp i omitted in this case we can encounter an arbitrary number of conditional statements depending on the user input.
if we handle every single statement returned from i dentify our system may not explore interesting paths for given time.
to cope with this challenge s elect randomly selects nsolve conditional statements from the given sequence of conditional statements while preserving the order of their appearance.
the order should remain the same because we need to build an approximate path constraint along the program execution.
in the current implementation of eclipser we usensolve which is determined empirically v b .
note that dynamic symbolic executors such as sage and klee also employ several path selection heuristics to handle the same challenge.
f.search search resolves a branch condition to cover a new branch in the given conditional statement cond .
as a result it returns a new seed as well as a branch condition which is approximated with an interval iv c in order for following the current execution path p sp .
the primary challenge here is on solving approximate path constraints without the help of an smt solver.
recall that i dentify returns conditional statements that have a relationship with the kth input byte.
we can represent this relationship as a data flow abstraction where sp is an input and one of operands in each of the conditional statements is an output.
the key intuition of s earch is that by realizing such an input output relationship we can deduce a potential solution of an approximate path constraint.
specifically s earch focuses on cases where the inputoutput relationship is either linear or monotonic.
this design choice is supported by various previous research works as well as our own empirical observation.
we observed that many conditional branches in real world programs tend to have a linear or monotonic constraint see v c1 .
search runs in three steps formulating and solving the current branch condition iii f1 recognizing a corresponding input field iii f2 and generating a new seed that can penetrate the conditional statement iii f3 .
solving branch condition let us assume w.l.o.g.
that only one of the two operands of cond is affected by input i and the operand is denoted by oprnd i .w e can decide that the branch condition of cond is linear if there exist i1 i2 andi3such thatoprnd i1 oprnd i2 i1 i2 fig.
.
input field recognition.
oprnd i2 oprnd i3 i2 i3.
in this case we can directly construct and solve a linear equation or inequality.
on the other hand cond has a monotonic branch condition if oprnd is a monotonic function over all the observed inputs i1 i2 ... i n n that executed cond .
figure illustrates an example where we have a monotonic input output relationship between a twobyte input field input and the compared value ebx .
for such a monotonic relationship we perform a binary search to find out a solution.
recognizing input field note that our focus so far has been on an input byte i.e.
sp .
however many branch conditions are constrained not only by an input byte but by an input field e.g.
a bit integer or a bit integer.
this means s earch should be able to handle input fields of arbitrary size.
moreover our equation solving in s earch operates on arbitrary precision integers which may give us a solution that does not fit in a byte.
we can naturally expand the capability of s earch by executing the put with several more input candidates.
specifically we replace the seed with the solution we obtained while considering the solution to have a specific size.
when solving linear equations or inequalities we consider maximum seven cases to try all possible candidates as figure describes.
for binary search on monotonic conditions we start the search by considering the size of the input field to be one and then gradually increase the size until a threshold which is set to in current implementation.
seed generation to generate a new seed that executes a new path we should first approximate the constraint from the current branch and encode it to the constr field of the newly generated seed.
specifically we turn the branch condition into a dictionary c which maps an input byte position ito an approximated constraint c which is represented by an interval.
for every byte position iinc we update sp .constr with c pc where represents a conjunction of two intervals.
the concrete value of the sp is also updated with a value that is within the interval c .
we take the negation of each of the branch condition c because we want to follow the path that is not taken by the current execution.
that is the new seed should take the opposite branch when executed with the put.
s earch returnsc and uses it to build up pc.
we refer to iv c for more details on how to approximate the branch conditions found.
iv .
e clipser architecture although grey box concolic testing itself enables systematic test case generation for pfrom a given seed spand a byte positionk one needs to devise a way to run grey box concolic testing with varying byte positions as well as with different authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm main algorithm of eclipser.
p put seeds initial seeds t time limit 1function eclipser p seeds t 2q initqueue seeds 3t while gettime tdo rg rr schedule q t greyconcolicloop p q t rg q t randomfuzzloop p q t rr return t seeds in order to explore interesting paths.
this section describes how we tackle such problems in the design of eclipser.
a. main algorithm recall from iii f grey box concolic testing currently focuses on linear and monotonic constraints and it may not be able to handle some complex branch conditions that involve multiple input fields.
to cope with these challenges eclipser employs a classic grey box fuzzing strategy.
our goal is to maximize the ability of both grey box concolic testing and grey box fuzzing by alternating them.
the idea of alternating between fuzzing strategies has been previously proposed and is complementary to ours.
algorithm describes the overall procedure of eclipser.
eclipser takes in as input a program p a time limit t and a set of initial seeds seeds and returns a set of test casestgenerated during a fuzzing campaign.
eclipser first initializes the priority queue qwith the provided initial seeds seeds and runs in a while loop until the time limittexpires.
in line schedule allocates resources for grey box concolic testing rg and grey box fuzzing rr .
then the two fuzzing strategies i.e.
grey box concolic testing greyconcolicloop and grey box fuzzing randomfuzzloop alternately generate new test cases until they consume all the allocated resources.
we refer to iv b for details about the resource management.
eclipser updates qandtingreyconcolicloop andrandomfuzzloop it simply adds newly generated test cases i.e.
seeds to q andt respectively.
tis later returned by the main algorithm when the fuzzing campaign is over line .
priority queue.
for each test input generated eclipser evaluates its fitness based on the code coverage and add it toq.
specifically we give high priority to seeds that cover any new node and low priority to seeds that cover a new path.
we drop seeds that do not improve the code coverage.
eclipser inserts a seed to the queue along with the next value ofkto use.
eclipser currently makes kto be both k andk and pushes the seed twice with both positions.
one important aspect of the priority queue is that it allows two fuzzing strategies to share their seeds.
note that grey box concolic testing currently does not extend the size of a given seed when generating new test cases while grey box fuzzing can.
if the grey box fuzzing module generates an interesting seed by extending its length it is shared with the grey box concolic testing module through the priority queue q.b.
resource scheduling when alternating between the two fuzzing strategies we need to decide how much resource we should allocate for each strategy.
in eclipser our resource is the number of allowed program executions.
if a strategy runs the put more than the allowed number eclipser switches the strategy.
to decide when to switch eclipser evaluates the efficiency of each fuzzing strategy and allocates time proportionally to the efficiency.
let nexec be the total number of program executions for one iteration of the while loop in line of algorithm .
we define the efficiency f npath nexec wherenpath is the number of unique test cases that executed a new execution path.
in other words eclipser allocates more resource to the strategy that explores more new paths.
c. approximate path constraint recall that grey box concolic testing approximates path constraints with intervals.
an approximate path constraint is a map from an input byte to its corresponding interval constraint we represent each constraint with a closed interval.
let be a constraint l x u. then we can express a logical conjunction of two constraints with an intersection of the two intervals .
let us assume that s earch has resolved a branch condition associated with an n byte input field x and obtained an equality condition x kas a result.
this condition can be expressed with intervals for each byte without any loss of precision x0 mapsto x1 mapsto xn mapsto whereki k greatermuch i 0xff andx0 xn 1are the least and the most significant byte of x respectively.
suppose that the resolved branch condition is an inequality condition l x u. in this case the condition is approximated as an interval constraint over the most significant byte ofx xn mapsto .
we only choose the most significant byte here in order to over approximate the interval represented in integer type.
eclipser adds this approximated constraint to pcin line of algorithm by performing an element wise conjunction.
d. implementation we implemented the main algorithm of eclipser in .4k lines of f code and binary instrumentation logic of eclipser by adding lines of c code to qemu .
.
.
we wrote the grey box fuzzing module of eclipser in f which is essentially a simplified version of afl .
we employed the mutation operations used in afl and a greedyset cover algorithm for minimizing the number of seeds during a fuzzing campaign.
to obtain execution feedback from an execution of a binary we used qemu user mode emulation because it can easily extend eclipser to handle various architectures.
currently eclipser supports three widely used architectures x86 x86 and armv7.
our implementation of eclipser is publicly available on github 2the armv7 version will not be open sourced due to an ip issue.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
v. e v aluation we evaluated eclipser to answer the following questions how does the configuration parameter of eclipser affect its performance?
v b can grey box concolic testing be a general test case generation algorithm?
if so how does it compare to existing white box fuzzers?
v c can eclipser beat the state of the art grey box fuzzers in finding bugs?
v d can eclipser find new bugs from real world applications?
is grey box concolic testing scalable enough to handle such large and complex programs?
v e a. experimental setup we ran our experiments on a private cluster of vms.
each vm was equipped with a single intel xeon e5 v4 .
ghz core and 8gb of memory.
we performed our experiments on three benchmarks programs from gnu coreutils .
programs from la v a m benchmark and real world programs included in debian .
packages.
first we selected gnu coreutils to compare eclipser against klee because klee and other white box fuzzers use this benchmark to evaluate their performance.
second we evaluated the bug finding ability of eclipser against grey box fuzzers on la v a m benchmark as it is used to evaluate many existing fuzzers .
finally we fuzzed real world applications chosen from debian .
to measure the practical impact of eclipser.
comparison targets.
we chose two existing grey box fuzzers for comparison which are available at the time of writing aflfast and laf intel .
we omitted driller as its current support for elf binary is limited.
we were not able to run vuzzer as it is dependent on ida pro which is a commercial product.
we also omitted steelix t fuzz and angora as they are not publicly available.
b. eclipser configuration recall from iii eclipser uses two user configurable parameters nspawn andnsolve.
these parameters decide how many branches to identify and to penetrate with grey box concolic testing respectively.
to estimate the impact of the parameters we ran eclipser on each of the programs in the first benchmark coreutils .
for one hour with varying configurations and measured code coverage differences.
in particular we chose five exponentially increasing values for each parameter.
figure summarizes the results.
when nspawn is too small i dentify failed to identify some interesting conditional branches and the coverage decreased as a result but when nspawn is too large eclipser ended up consuming too much time on unnecessary program executions.
similarly by making nsolve too small eclipser started to miss some interesting conditional branches but by making it too large we started to cover less nodes due to path explosion.
from these results we decided to use nspawn and nsolve as a default set of parameter values for eclipser and used them for the rest of our experiments.
0line coverage a nspawn in log scale 5000line coverage b nsolve in log scale fig.
.
the impact of nspawn andnsolve.
time minute line coverage eclipser klee grey box concolic grey box fuzzing fig.
.
line coverage achieved by eclipser and klee over time for coreutils.
c. comparison against white box fuzzing to evaluate the effectiveness of grey box concolic testing as a test case generation algorithm we compared it against klee version .
.
which was the latest at the time of writing.
we chose coreutils as our benchmark as it is used in the original paper of klee .
out of programs in coreutils .
we excluded programs that can affect the fuzzing process itself e.g.
kill andrm and programs that raised unhandled exceptions with klee.
we tested each of the remaining programs for one hour.
additionally we used the command line options reported in klee website to run klee.
for a fair comparison we set the same limitation on the input size when running eclipser.
all the numbers reported here are averaged over iterations.
we seek to answer the three questions here can grey box concolic testing itself without the grey box fuzzing module beat klee in terms of code coverage?
can we benefit from alternating between grey box fuzzing and greybox concolic testing?
and can eclipser find realistic bugs in coreutils?
how does it compare to klee?
grey box concolic testing effectiveness we ran eclipser in two different modes only with grey box concolic testing and only with grey box fuzzing.
the blue and the pink line in figure present the coverage for each case respectively.
out of a total source lines grey box concolic testing covered lines .
and solely using the grey box fuzzing module covered lines .
while klee covered lines .
.
this result clearly indicates that grey box concolic testing alone is comparable to klee.
note that our tool runs directly on binary executables while klee runs on source code.
this 3we note that a sharp increase of klee s line coverage around minute does not mean that klee starts to rapidly explore code around that point.
when a time limit expires klee outputs the test cases remaining in the memory even if their symbolic executions are not finished.
indeed we further ran klee for more than hours but the coverage increased only by .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
programs in coreutilsdi erence in covered line fig.
.
difference in the number of lines covered by eclipser and klee.
table i number of bugs found on la v a m. program aflfast laf intel vuzzer steelix eclipser base64 md5sum uniq who total result empirically justifies our design choice of focusing on solving linear or monotonic branch conditions.
alternation between two strategies the green line in figure shows the source line coverage achieved by eclipser while alternating between the two different strategies.
it is obvious from the figure that our design choice indeed achieved a synergy eclipser covered lines .
outperforming klee in terms of code coverage.
the standard deviation of eclipser s coverage was .
while that of klee s coverage was .
.
additionally figure shows the coverage difference between eclipser and klee for each program.
the x axis represents tested programs and the y axis indicates how many additional lines eclipser covered more than klee.
the leftmost program is stty where klee covered more lines and the rightmost program is vdir where eclipser covered more lines.
real bugs from coreutils the programs in gnu coreutils are heavily tested.
can eclipser still find some meaningful bugs in them?
during the course of our experiments eclipser found two previously unknown bugs each of which can crash b2sum andstty respectively.
on the other hand klee was able to find only one of the bugs during our experiments.
this result indeed highlights the practicality of our system.
d. comparison against grey box fuzzers how does eclipser compare to modern grey box fuzzers?
to answer this question we compared the bug finding ability of eclipser against state of the art grey box fuzzers on la v a m. recall from v a we were not able to run steelix and vuzzer for this experiment.
instead we used the numbers reported in their papers to compare with the other fuzzers.
to be fair we ran the fuzzers with a similar setting that steelix used.
we used the same initial seeds used in and ran our experiment for the same amount of time hours .
table i shows the number of bugs found from la v a m benchmark.
the numbers are averaged over repeated experiments.
eclipser found .
.
and .
more bugs than laf intel vuzzer and steelix respectively.
aflfastdid not find any bug during the experiment.
note that in some programs eclipser was even able to find bugs that the authors of la v a failed to reproduce.
for example in base64 the authors of la v a could reproduce only bugs in .
we note that laf intel is a source based tool which incurs less instrumentation overhead compared to binary based tools.
for example when we ran afl on the la v a m benchmark the number of executions per second with the source based instrumentation was .
higher than it with the binary based instrumentation on average.
despite such a disadvantage eclipser found far more bugs than laf intel.
this result shows that grey box concolic testing can effectively resolve complex conditions to trigger bugs injected by la v a. e. fuzzing in the real world we further evaluated our system on a variety of programs in the real world.
specifically we collected programs from debian os with the following steps.
first we used debtags to search for packages containing c programs which deal with image audio or video via a command line interface.
next we selected the top popular packages based on the debian popularity contest .
we then manually picked only the packages that take in a file as input can be compiled with laf intel and can be fuzzed with aflfast without an error.
finally we extracted at most two programs from each of those packages to obtain a total of programs.
we fuzzed each of the programs for hours with a dummy seed composed of consecutive null bytes.
table ii shows the results.
overall eclipser covered .
.
and .
.
more nodes branches than aflfast and laf intel respectively.
while investigating the result we confirmed that grey box concolic testing of eclipser indeed played a vital role in achieving high coverage.
in oggenc for instance eclipser covered .
more nodes than aflfast as grey box concolic testing successfully produced valid signatures for flac or riff format from scratch.
we further investigated the crashes found and manually identified unique bugs.
in total eclipser aflfast and laf intel found and unique bugs respectively.
we further analyzed the result and found that grey box concolic testing indeed played a critical role in finding bugs.
if we ran the same experiment only with the grey box fuzzing module of eclipser which is close to vanilla afl we obtained only eight unique bugs after hours.
this means grey box concolic testing helped eclipser find more unique bugs.
we reported all the bugs eclipser found to the developers and a total of new cves were assigned at the time of writing.
we believe this result confirms the practical impact of eclipser.
vi.
d iscussion the current design of grey box concolic testing focuses on solving branch conditions when the operands of the comparison can be expressed as a linear or monotonic function of an input field.
recall that eclipser currently resorts to traditional grey box fuzzing to penetrate branches with complex constraints.
this is not a significant drawback since solving authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii code coverage achieved and the number of unique bugs found in debian programs .
program package locaflfast laf intel eclipser node cov.
branch cov.
uniq.
bugs node cov.
branch cov.
uniq.
bugs node cov.
branch cov.
uniq.
bugs advmng advzipadvancecomp dcparse dcrawdcraw fig2dev fig2dev gifdiff gifsiclegifsicle gnuplot gnuplot gocr gocr icotool wrestoolicoutils jhead jhead optipng optipng ldactoasc sextractor sndfile info sndfile playsndfile programs ufraw batch ufraw batch oggenc vorbiscommentvorbis tools wavpack wvunpackwavpack x264 x264 total non linear constraints is difficult anyways.
however one may adopt a metaheuristic based algorithm we discuss in vii.
note that eclipser currently employs binary based instrumentation to test a wide variety of programs without source code.
however binary based instrumentation incurs substantial overhead as we have observed from one of our experiments in v d. it is straightforward to improve the performance of eclipser by adopting source based instrumentation.
vii.
r elated work eclipser is not a fuzzer per se but it employs a fuzzing module.
therefore all the great research works on fuzzing are indeed complementary to ours.
since grey box concolic testing is inspired by white box fuzzing it naturally suffers from the path explosion problem.
various search strategies have been proposed to cope with the problem.
klee for instance adopts random path selection while others prioritize less traveled execution paths or nodes or leverage static analyses to guide the search .
although eclipser follows the similar approach as in we believe adopting more complex strategies is a promising future work.
meanwhile there are several attempts to increase the scalability of whitebox fuzzing for example by state merging .
in contrast our work mainly focuses on relieving the fundamental overhead for constructing and solving symbolic formulas.
the idea of analyzing programs without expensive data flow analysis has been studied in various contexts.
for example mutaflow detects information flow without taint analysis by simply mutating input data at a source point and observing if it affects the output data at sink points.
helium uses regression analysis to infer the relationship between the input and the output of a code segment.
such dynamic analysis is used to complement symbolic executionin the presence of unknown library functions or loops.
our work extends these ideas and applies them more aggressively to devise a general test case generation algorithm.
angora and sbf are the closest fuzzers to ours.
they adapt the idea of search based software testing to tackle the branch penetration issue discussed in ii c. specifically angora tries to find an input that minimizes the branch distance of a conditional branch.
however it uses fine grained taint analysis to identify input bytes affecting a target conditional branch whereas eclipser repeatedly executes the put to dynamically infer such relationships.
thus we believe both approaches are complementary to each other.
for example one may first apply grey box concolic testing to penetrate simple branch conditions and then turn to angora s strategy to handle more complex conditions.
viii.
c onclusion this paper presents a new point in the design space of fuzzing.
the proposed technique grey box concolic testing effectively darkens white box fuzzing without relying on smt solving while still performing path based testing.
we implemented our technique in a system called eclipser and evaluated it on various benchmarks including coreutils la v a m as well as programs in debian.
we showed our technique is effective compared to the current state of the art tools in terms of both code coverage and the number of bugs found.
acknowledgement we thank anonymous reviewers for their feedback.
this work was partly supported by institute for information communications technology promotion iitp grant funded by the korea government msit no.b0717 building a platform for automated reverse engineering and vulnerability detection with binary code analysis and a grant funded by samsung research binary smart fuzzing .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.