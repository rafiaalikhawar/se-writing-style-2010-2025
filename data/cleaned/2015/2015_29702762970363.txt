mining revision histories to detect cross language clones without intermediates xiao cheng1 zhiming peng2 lingxiao jiang2 hao zhong1 haibo yu3 jianjun zhao4 1department of computer science and engineering shanghai jiao tong university china 2school of information systems singapore management university singapore 3school of software shanghai jiao tong university china 4department of advanced information technology kyushu university japan fx.cheng zhonghao haibo yug sjtu.edu.cn fzmpeng lxjiangg smu.edu.sg zhao ait.kyushu u.ac.jp abstract to attract more users on di erent platforms many projects release their versions in multiple programming languages e.g.
java and c .
they typically have many code snippets that implement similar functionalities i.e.
cross language clones.
programmers often need to track and modify crosslanguage clones consistently to maintain similar functionalities across di erent language implementations.
in literature researchers have proposed approaches to detect crosslanguage clones mostly for languages that share a common intermediate language such as the .net language family so that techniques for detecting single language clones can be applied.
as a result those approaches cannot detect cross language clones for many projects that are not implemented in a .net language.
to overcome the limitation in this paper we propose a novel approach clcminer that detects cross language clones automatically without the need of an intermediate language.
our approach mines such clones from revision histories which re ect how programmers maintain cross language clones in practice.
we have implemented a prototype tool for our approach and conducted an evaluation on ve open source projects that have versions in java and c .
the results show that clcminer achieves high accuracy and point to promising future work.
ccs concepts software and its engineering !software libraries and repositories software maintenance tools keywords cross language clone di revision history .
introduction due to various considerations many projects are implemented in di erent programming languages.
for example antlr releases its versions in java c javascript and python.
as another example lucene release its versions in java and c .
when maintaining such projects if a codesnippet is modi ed programmers often copy their modi cations to proper locations in other language versions and conduct further editions according to the syntactic and semantic requirements of the target programming language.
as a result released versions can have similar code snippet in di erent programming languages.
in literature kraft et al.
call such code snippets as cross language code clones .
cross language clones can be inevitable and bene cent for a project even though sometimes code clones may be harmful and could be removed .
it also becomes necessary for programmers to locate and maintain cross language clones.
for example after a developer d1 develops a crosslanguage project another developer d2 who is not familiar with the source code joins the project.
if d2 modi es a code snippet in a programming language all the clone instances of the code snippet in another language may require similar modi cations.
in particular when a bug is reported in a programming language d2 often needs to check versions in other languages.
it can be tedious for d2 to locate the clones manually.
an automated cross language clone detection tool can be useful for d2 and reduce overlooks.
researchers have proposed various detection approaches for code clones in one programming language.
recently researchers start to detect crosslanguage code clones for the .net language family.
however their approaches are limited to the languages that share a common intermediate language while many projects are implemented in other programming languages that cannot be addressed by existing approaches.
without a common intermediate language it becomes more challenging to detect cross language clones.
in this paper we need to overcome the following challenges to detect such clones challenge .
existing approaches can detect cross language clones for the .net language family which is built on the microsoft intermediate language.
these approaches assume that di erent programming languages share a common intermediate language.
as a result it is feasible to reduce source code to the intermediate language and to detect clones based on such intermediates.
however most languages do not have such a common intermediate language which makes the task challenging.
challenge .
di erent programming languages have different grammars and apis.
as a result even if code snippets in di erent programming languages implements the same functionality their structures even their lines of code can be di erent.
it becomes more challenge to determine crosslanguage clones than clones in a single language.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
public class machineprobe 2if !t.isepsilon !t.label.getset .and label .isnil next.contains t.target 3if p.associatedastnode !
null antlr.token oldtoken p.associatedastnode.token token oldtoken p.associatedastnode.token 6commontoken token new commontoken oldtoken.gettype oldtoken.gettext 7token.setline oldtoken.getline token.setcolumn oldtoken.getcolumn token.setcharpositioninline oldtoken.getcharpositioninline 10tokens.add token 11break nfaconfigloop found path move to next12 nfastate set13...... a machineprobe.java namespaceantlr3.analysis2 3itokenoldtoken p.associatedastnode.token 4commontokentoken newcommontoken oldtoken.type oldtoken.text token.line oldtoken.line token.charpositioninline oldtoken.charpositioninline token.line oldtoken.line token.charpositioninline oldtoken.charpositioninline 9tokens.add token gotoendnfaconfigloop foundpath moveto next11 nfastateset12 foundpath moveto nextnfastateset13 gotoendnfaconfigloop ...... b machineprobe.cs figure a pair of matched di s in this paper we propose a new approach clcminer which detects cross language clones without intermediate languages.
our approach is based on comparing revision histories that are recorded in repository logs.
here di is a change log tool that is widely used in version control systems vcs such as git svn and mercurial.
in this paper we also call its generated delta as a di .
each di describes changes of a code fragment in the source code.
the rationale for our approach is that in multi language projects versions in di erent languages can have similar di s since di erent versions should have similar functionalities and developers may change all versions in similar ways i.e.
di s to perform similar tasks.
based on this insight our approach detects cross language clones through comparing the similarity among pieces of di s in di erent programming languages and aligning each di with the most similar one which is called di matching.
meanwhile as a di contains both its changed lines of code and surrounding code lines it becomes easier to determine the granularity of crosslanguage clones based on di s. this paper makes the following contributions to the best of our knowledge we proposed the rst approach that detects cross language clones for programming languages that do not have an intermediate language.
our approach is based on comparing change histories and thus reduces cross language clone detection into a di matching problem.
we conducted an evaluation on ve open source projects that release versions in java and c .
our results show that our approach achieves an average precision of and recall of .
.
running example figure shows an example of two matched di s in java and c code fragments.
we use the example to illustrate the problem and how our approach works.
the di on the left records two lines of changes in an if block in java class machineprobe while the one on the right records four lines of changes in a block in c class machineprobe .
the matched di pair indicates a cross language clone which has similar functionality.
both of the code fragments intend to set the elds i.e.
line and charpositioninline of the object token .
the java code achieves this through method invocations i.e.
setline and setcharpositioninline while the c code achieves this through assigning them directly.
in addition the java jumps out of theif block through a break statement while the c code uses a goto statement.
our approach extracts all the di s from the project in both java and c and matches each di in java code to a di in c code according to the class log parsing matching normalizing ranking reportinggit logs author commit idcommit datefile name token stream clonesdiffs matched diffscommit messageprocessingentity figure approach overview name e.g.
machineprobe and the text similarity e.g.
the identi er names and the words .
thus our approach is able to detect the cross language clone in figure .
the detailed algorithm to match the di s will be presented in section .
.
approach and implementation .
overview the same functionality implemented in di erent languages may diverge in the syntax but the functionality in one language e.g java can be used as a reference for implementation in another language e.g.
c .
as a result similar variable or method names can be used in such cases.
to detect cross language clones clcminer adapts natural language processing nlp techniques to calculate the similarity among pieces of di s in di erent programming languages and selects the most similar one for each di as a pair of matched di s. each pair of matched di s refers to a pair of potential clones.
base on the most similar one we expect that other similar ones can be further detected by singlelanguage clone detection tools.
therefore clcminer so far does not report the second most similar or other similar ones for each di .
finally clcminer ranks the matched pairs of di s according to their di similarity and reports top ones as potential cross language clones.
figure shows an overview of clcminer .
each blue rectangle represents a processing step and each red rounded rectangle represents an entity.
the input of clcminer is git logs and its output is a ranked list of detected potential cross language clones.
the approach has four main steps .log parsing.
this step extracts di s and their attributes from revision logs.
.normalizing.
this step normalizes di s and prepares for the comparison in the next step.
.di matching.
this step matches di s in di erent languages by comparing their similarity values.
for each di its matched one is the most similar one.
.ranking reporting.
this step ranks matched di s according to their similarity and reports crosslanguage clones.
697table attributes of example di s fn machineprobe.java machineprobe.cs cid 7288ec550b52a1b969ce6f1db62377241c36ed66 e589c63956a9e06aec08b146c2871211c13b1d56 ca sharwell sharwell cd mon mar tue may cmconvert all tool grammars to antlr v3.
the only remaining dependency on v2 is the stringtemplate .
s use of the v2 runtime c code cleanup tsif t is epsilon t label get set and label is nil next contains t target if p associated ast node null antlr token oldtoken p associated ast node token token oldtoken p associated ast node token common token token new common token oldtoken get type oldtoken get text token set line oldtoken get line token set column oldtoken get column token set char position in line oldtoken get char position in line tokens add token break nfa con g loopi token oldtoken p associated ast node token common token token new common token oldtoken type oldtoken text token line oldtoken line token char position in line oldtoken char position in line token line oldtoken line token char position in line oldtoken char position in line tokens add token goto end nfa con g loop goto end nfa con g loop .
log parsing in a version control system vcs repository logs record code evolution histories.
for example the structure of git logs is organized as follows a git log consists of several commits each commit is related to one or more les each le is related to one or more di s each di records one or more change hunks that occur in a code fragment .
log parsing is a preparation step that extracts useful information from repository logs.
clcminer parses a log into a list of di s and attaches each di with a set of attributes including commit date cd commit author ca commit id cid file name fn and commit message cm .
for example table lists the attributes of the di s in figure .
some attributes e.g.
fn are useful for matching di s and others e.g.
cid help to uniquely locate the code.
.
normalizing normalizing is to remove uninteresting contents from the di s and transform the rest contents into normalized comparison units.
clcminer uses the token streams of the di s as the comparison unit and normalizes them as follows .removing comments.
to relieve the impact of comments in natural language clcminer removes the comments from the di rstly.
.lexing.
clcminer employs a lexer to lex the code in thedi without comments into a token stream.
.removing punctuations.
punctuations and numbers are removed from the token stream as they often do not indicate signi cant semantics.
.post processing.
camel case tokens are split by the uppercase letters and tokens with underscores are split by the underscores.
after that all tokens are transformed to lowercases.
this step paves di erence between programming styles.
in table column ts lists the two normalized token streams of the di s in the running example.
.
diff matching di matching is the process to align a di in a language e.g.
java to the di in the other language e.g.
c according to their similarity.
bag of words bow represents a piece of text as a bag multiset of its words disregarding grammar and the ordering of words.
clcminer adopts bow to build a characteristic vector each dimension of which represents the number of times that a word appears in the token stream of a di to calculate the similarity between two di s. table shows the characteristic vectors for the token streams in table .
column token lists the words appearing in the token streams.
columns java and c list the numbers of times that each word occurs in the di ofmachineprobe.java and machineprobe.cs respectively.
column di erence lists the absolute value of the di erence between the numbers of occurrence.
for example table characteristic vectors token java c di erence add and antlr associated ast break token tokens type total token break appears in the di of java code once but does not appear in the c code and the di erence is j1 0j .
we use the distance between two vectors to measure the similarity of two di s. for two vectors vi vi1 vi2 v in andvj vj1 vj2 v jn their distance is de ned as distance vi vj pn k 1jvik vjkjpn k vik vjk in the example the distance is .
the smaller the distance is the more similar two di s appear.
algorithm shows the details for matching di s. it takes as input two lists of di s each of which represents changes of the code fragments in a programming language.
the output is a list of matched di pairs each of which is from di erent input lists.
clcminer compares the sizes of the two di lists and sets the small one and the large one as source and target respectively lines .
the di s whose le names are the same are called neighbors of each other.
for each di insource ds clcminer searches target for its nearest neighbors by comparing the distances from dsto all of itsneighbors intarget lines .
the shortest distance indicates the nearest one.
as long as there exists a neighbor intarget fords dscan be matched otherwise it cannot.
clcminer only matches a di to its nearest neighbor to report clone pairs instead of reporting all its top k nearest neighbors to form clone groups .
this takes into consideration that with the nearest neighbor the other top k nearest neighbors and even clones in les with di erent names can be detected by a single language clone detector to build more comprehensive clone groups.
section discusses more about this setting for future work.
.
ranking and reporting each pair of matched di s is called clone candidates.
we rank all such pairs according to their distances.
the pairs whose di distances are lower than .
are to be reported as code clones because it is empirically determined cf.section that such short distance pairs of di s are highly likely to be cross language clones.
.
evaluation we implemented clcminer and conducted evaluations to answer the following research questions 698algorithm di matching input list dlist jdlist cs output list dpair 1source minimumlist dlist j dlist cs 2target maximunlist dlist j dlist cs 3foreach ds2source do distance foreach dt2target do ifdt filename equals ds filename then ifdistance ds dt distance then pairs add ds dt end ifdistance ds dt distance then pairs clean pairs add ds dt distance distance ds dt end end end dpair addall pairs 18end 19return dpair rq .
what is the clone ratio distribution with respect to the di distances?
rq .
what is the accuracy of clcminer ?
rq .
what is the impact of the other attributes on cross language clones?
.
setup in our evaluation we use ve open source projects implemented in both java and c i.e.
antlr3 fpml log4j log4net spring lucene.
table shows the projects and lists locs log sizes numbers of commits and di s. we apply our approach to each project to obtain the ranked list of cross language clone pairs as the report.
column matched di pairs in table lists the number of matched di pairs according to the le name and di similarity.
due to the large number of clone candidates and limited manpower we randomly sampled in a uniform way a small percentage of the clone candidates in the reported ranked lists and manually labelled whether they were actual clones.
as listed in table for antlr3 fpml log4j log4net and spring we sampled over of all the reported clone candidates in each project for lucene we sampled about .
two co authors manually labelled whether they were actual clones separately based on the clone definition of bellon and the functionality equivalence.
if there exists a di erence between the labels given by the two co authors it will be labelled and decided by a third co author.
we calculated the clone ratio and its distribution w.r.t.
the distances where the clone ratio is de ned as cr clones candidates .
.
result .
.
rqs .
distribution and accuracy figure shows the clone ratio distribution and the accumulated clone ratio w.r.t.
di distances.
the clone ratio distribution in figure a indicates almost all the candidates whose di distances are lower than .
are clones almost none of the candidates whose di distances are larger than .
is clone when distances increase from .
to .
the clone ratio decreases gradually when distances increase from .
to .
the clone ratio decreases greatly.
the accumulated clone ratio in figure b also decreases with the increasing of the di distance.
when the di dis table characteristics of subject projects projects loclogs commit di s matched samples mb di pairs antlr3java 710c fpmljava 259c log4j 166log4net springjava 400c lucenejava 908c tance is lower than .
the clone ratio decreases slowly and when the di distance is larger than .
the clone ratio decreases greatly.
based on the above observation it is reasonable to set .
as the proper threshold distance.
if the di distance is lower than .
its related clone candidate is considered as a clone if the di distance is larger than .
its related clone candidate is not considered as a clone.
in other words we only report as clones the pairs of code fragments in the ranked list whose di distance is lower than .
.
we use precision and recall to evaluate the accuracy of clcminer .
in this way for antlr3 fpml log4j log4net spring and lucene w.r.t.
the manually labelled clone samples the report precisions are and respectively and the average precision is about .
for the clone candidates in the ve projects whose di distance is between .
and the clone ratios are and respectively.
since it is impossible to know how many actual cross language clones in the projects we calculate the recall based on the number of the missed clones whose distance is larger than .
.
in this way the recalls of the ve projects are and respectively and the average recall is about .
.
.
rq3.
impact of more attributes of diffs for matching di s bow is not the only choice.
we identify the following attributes that may be used to improve the e ectiveness of matching cross language clones in future.
author.
as a developer may have a programming style that may persist even across di erent languages we hypothesize that a pair of di s from di erent language versions of a project may be more likely to be clones if they are authored by the same developer.
to investigate the hypothesis we look into the labels for the clone reports sampled in the way mentioned in section .
.
among these ve projects all sampled pairs of di s in spring and log4j log4net were committed by di erent persons about only .
of the di pairs in lucene were committed by the same developer and about only in fpml were committed by the same developer.
antlr3 has a more pronounced di erence about of di pairs were made by di erent authors.
so for each pair of di s in the sampled reports we have a variable indicating whether it is clones and another variable indicating whether it is made by the same author.
a simple t test showed that di pairs made by the same author are statistically more likely to be clones than those made by di erent authors but the correlation between the two variables is very weak pearson s correlation coe cient is about .
.
commit time.
as the functionalities in di erent language versions of a project are likely to remain consistent changes in one language version may induce similar changes in another within a short period of time.
similarly we investigate whether the commit time di erence between the .
.
.
.
.
.
.
.
.91clone ratio diff distanceantlr3 fpml log4j log4net lucene spring a clone distribution .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1clone ratio diff distance antlr3 fpml log4j log4net lucene spring b accumulated clone distribution figure clone ratio distribution two di s in a reported pair is correlated with whether the pair is a clone with t test and pearson s correlation.
we noticed that ve projects exhibit di erent correlations between commit time di erences and clones.
in fpml and spring thedi pairs with shorter time di erences are statistically more likely to be clones but the correlation coe cients between these the two variables are very weak .
and .
.
in log4j log4net the e ect is reversed the di pairs with longer time di erences are statistically more likely to be clones although the correlation is still weak .
.
in antlr3 and lucene whether di pairs are clones statistically has no e ect on their time di erences.
commit message.
as a commit message often summarizes the changes in the commit a di pair may be more likely to be clones if they share similar commit messages.
so we also investigate whether the distance between the commit messages of a di pair is correlated with whether the pair is a clone.
we calculate the distance between commit messages via the same technique we used for code section .
and we check the relationship with t test and pearson s correlation.
we found mixed results too as many commit messages are empty or very brief and non informative in fpml antlr3 and spring clone pairs have statistically shorter commit message distance while in log4j log4net and lucene clone pairs have statistically longer distance and the correlation coe cients are all weak.
as a summary there is no clear deciding attribute for di pairs to be clones besides the code itself.
it could be a combined e ect of various attributes even some contexts beyond di s. in our future work we plan to investigate whether the combination of more attributes together with additional ones discussed in section can be used to improve cross language clone detection.
.
discussion and future work using comments in code.
in di normalization section .
code comments were removed as we hypothesizedthat comments in natural language may be too high level and appear similar even for non clones and thus are not accurate enough for clone detection.
however during the manual labelling of the sampled di pair reports we noticed that many clone pairs either contain quite di erent comments for di erent parts of the two code fragments in the pair or contain almost exactly the same comments which may indicate an actual copying pasting operation .
in our future work we plan to more systematically investigate how comments in code are related with clones.
relaxing le names.
di matching section .
used a requirement that potentially matched di s should be from les of the same name and thus all code in every reported clone pair has the same le name.
however cross language clones can appear in les with di erent names especially if they are from di erent projects.
the requirement was added to reduce the pair wise matching time for projects involving too many commits it is a trade o between e ciency and recall.
in the future work we will optimize our matching algorithm and analyze how the le names impact cross language clones that may be from di erent projects.
detecting clone groups and change propagation.
clcminer matches a di in one language to its nearest neighbors in another language only as we focus on the feasibility of using di s for detecting cross language clones.
we can change the setting to return all the neighbors of a di whose distance is within a small threshold which can enable us to detect cross language clone groups in addition to pairs.
also by linking clone groups based on clone transitivity within a threshold and complemented with a singlelanguage detector we will be able to study how changes are propagated even through di erent languages extending similar studies within the same language .
detecting clones beyond revision histories.
based on revision histories clcminer is limited to detect crosslanguage clones that have been changed in the past in the same project.
for clones that are never changed we can explore more language attributes that can identify clone relations e.g.
using deep learning to build vector representation of programs across languages.
this limitation can also be compensated by a single language detector that can detect cross project and same language clones based on certain clone transitivity across projects and languages.
crossing more languages.
increasing demands for crossplatform mobile applications e.g.
ios and android raise the need for quick development that can reuse code across more diverse kinds of languages e.g.
objective c swift and java .
in our future work we plan to adapt clcminer to more languages and explore more attributes that can identify co change relations and be used to detect clones and facilitate code reuse across di erent languages.
handling false positives.
although clcminer reports high precisions there is still space for improvement.
we investigated the false positives and found various characteristics causing accidental similarity among di s a short method is de ned in one di but invoked in the other di the di s contain code that handles exceptions or errors the di s contain a large number of same string constants used di erently the di s contain a number of di erent numeric values which were excluded by our normalizing step the di s contain code that uses the same set of library functions e.g.
file i o httpheaders in di erent ways.
in future work we will re ne clcminer to handle such cases.
700comparing with token based clone detection.
some token based clone detection techniques can run in plain text mode to detect some cross language clones.
for example ccfinder lexes each line of source les into token sequence and utilizes su x tree based substring matching algorithm to search for similar subsequences.
di erent from ccfinder clcminer splits each camel case identi er e.g.
the variable name and utilizes the statistical method to calculate the distance between di s and search for similar di s. we will compare clcminer with ccfinder in future work.
.
related work cross language clone detection.
the number of various software systems implemented in multiple languages is increasing considerably but cross language clone detection is limited.
kraft et al.
conduct the rst study on code clones that span over multiple languages.
they implemented a tool called c2d2 based on the codedom library in the microsoft .net framework which uses nrefactory library to generate the uni ed codedom graph for both c and vb.net.
al omari et al.
present a clone detection approach for the .net language family too based on the common intermediate language cil .
it can detect cross language clone pairs in c j and vb.net.
compared with these work our approach focuses on detecting cross language clone detection on di erent platforms without common intermediate languages.
data mining in vcs.
there are considerable studies of data mining in version control systems vcs .
zimmermann et al.
apply data mining on version histories to recommend related syntactic changes.
g rba et al.
apply concept analysis on vcs to identify groups of co changes.
mcintosh et al.
mine source and test code for accompanying build changes.
meng et al.
mine revision histories to identify updated api interfaces.
we mine vcs for a di erent purpose i.e.
detecting cross language clones.
.
conclusion this paper proposes a novel approach clcminer that detects cross language clones without common intermediate languages.
our key idea is to utilize di similarity.
we have implemented and evaluated its prototype on ve open source projects.
the results show that clcminer can detect many cross language code clones with a high precision of and recall of on average w.r.t.
distance threshold .
.
to improve clcminer in our future work we plan to re ne the handling of false positives detect more crosslanguage clones not captured in revision histories by incorporating in single language clone detectors and detect more clone groups across more languages e.g.
objective c swift and java as described in section .
.