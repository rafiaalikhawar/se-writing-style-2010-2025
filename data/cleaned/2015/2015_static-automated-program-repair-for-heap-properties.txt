static automated program repair for heap properties rijnard van tonder school of computer science carnegie mellon university rvt cs.cmu.educlaire le goues school of computer science carnegie mellon university clegoues cs.cmu.edu abstract static analysis tools have demonstrated effectiveness at finding bugsinrealworldcode.suchtoolsareincreasinglywidelyadopted toimprovesoftwarequalityinpractice.automatedprogramrepair apr hasthepotentialtofurthercutdownonthecostofimproving software quality.
however there is a disconnect between these effectivebug findingtoolsandapr.recentadvancesinaprrely on test cases making them inapplicable to newly discovered bugs or bugs difficult to test for deterministically like memory leaks .
additionally thequalityofpatchesgeneratedtosatisfyatestsuiteis akeychallenge.weaddressthesechallengesbyadaptingadvances inpracticalstaticanalysisandverificationtechniquestoenablea newtechniquethatfindsandthenaccuratelyfixesrealbugswithout test cases.
we present a newautomated program repair technique using separation logic.
at a high level our technique reasonsover semantic effects of existing program fragments to fix faults relatedtogeneralpointersafetyproperties resourceleaks memoryleaks andnulldereferences.theprocedureautomaticallytranslates identifiedfragmentsintosource levelpatches andverifiespatch correctnesswithrespecttoreportedfaults.inthisworkweconduct the largest study of automatically fixing undiscovered bugs in realworld code to date.
we demonstrate our approach by correctly fixing bugs including previously undiscovered bugs in real world projects.
ccs concepts software and its engineering error handling and recovery maintaining software software defect analysis keywords automated program repair separation logic acm reference format rijnardvantonderandclairelegoues.
.staticautomatedprogramrepair for heap properties.
in icse icse 40th international conference onsoftwareengineering may27 june3 gothenburg sweden.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
introduction software bugs are expensive and time consuming motivating research to find and fix them automatically.
research in automatedprogramrepair apr holdspromiseforreducingsoftware maintenance costs due to buggy code.
considered broadly a programrepair issimplyatransformationthatimprovesaprogram with respect to some abstract domain that describes correct versus incorrect program behavior.
the vast majority of modern repair techniques e.g.
usetestcasestoconstruct this domain.
tests are appealing because they are intuitive and widely usedinpractice moresothan e.g.
formalspecifications and can straightforwardly indicate whether a given change improvestheprograminquestion i.e.
byturningapreviouslyfailing test case into a passing one .
however testsarelimitinginseveralways especially though not exclusively for apr.
writing good tests is nontrivial renderingsomereal worldsuitesaweakproxyforpatchcorrectness .
apr techniques and humans alike can overfit to even high quality tests producing patches that do not generalize to the true desired functionality change .
developers must write a deterministic reproducible test case corresponding to a bug under repairtousetest drivenapr.thisusecaseisparticularlyapplicable to e.g.
regressions but is limiting for previously unknown defects.
morefundamentally testsare onlysuitable forfinding and guiding the repair of certain kinds of bugs.some bug types are simply difficult to test for in a finite deterministic way .
consider concurrencyerrorsorresourceormemoryleaks figure1ashowsan example memory leak from swoole1 line which may be fixed by adding a call to the project specific resource allocation wrapper sw free figure 1b .
alternatively consider the code in figure 2a from error prone .2the call to resolvemethod on line can return null leading to a possible null pointer exception on line .
a developercommittedafix withatest thatinsertsacalltoacustomerrorhandler checkguardedby line5 .however the verysame mistakehadbeenmadeonlines10 inthesame switchstatement butwasnotfixedforanother18months.evenwhenbugsaredeterministicallyreproducible testsusuallycannotidentifyrecurring mistakes like this.
findingandfixingthesetypesofbugsmotivatetheuseofqa techniques beyond testing.
considerable recent progress has been made in expressive high quality static analyses that can cost effectively find real bugs like these examples in real programs .
companies like ebay microsoft facebook and others are publicizing their development and use of static analysis 1swooleis a popular event driven networking engine for php swoole swoole src 2error prone is an open source static analysis tool error prone acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden rijnard van tonder and claire le goues 1swhashmap hmap sw malloc sizeof swhashmap 3if !hmap swwarn malloc failed.
return null 7swhashmap node root sw malloc sizeof swhashmap node 9if !root swwarn malloc failed.
return null returns hmap not freed a memoryleak forgettingtofreememorybeforereturnin swoole.
define sw free ptr 2if ptr 3free ptr 4ptr null 5swwarn free b sw freewraps a call to free.
figure fixing a memory leak in the swooleproject tools in engineering practice.
some bug finding tools like errorproneorfindbugs evenprovide quickfix suggestionsforcertain bug classes simplifying the process of repairing them.
developers find such suggestions very useful and indeed their absence has beenidentifiedasabarriertouptakeandutilityofstaticanalysis tools .
however the suggestions present in current tools are simple generic andusuallysyntactic e.g.
recommendingtheadditionof staticorfinalmodifierstovariableorfunctiondeclarations .
moreover they provide no semantic correctness guarantees.
weproposeanewtechniquethatautomaticallygeneratespatches forbugsinlargeprojectswithoutaneedforeithertestsordeveloperannotation forasemanticallyrichclassofbugsthatcanbeidentified by recent sophisticated static bug finding techniquesbased onseparation logic .
our key insightlies in thenovelwayweadapt localreasoning theworkhorse of a number of automated reasoning tools to pull out relevant parts of program state and then search for repairing code fromelsewhereinthesameprogram.atahighlevel ourtechnique searches for and adapts program fragments satisfying a generic pre specifiedsemanticeffectthataddressagivenbugclass such as if the file is open in the precondition of a program fragment it shouldbeclosedinthepostcondition toaddressresourceleaks liketheoneshowninfigure1a .thesefixeffectsaregeneric andneed onlybespecifiedonceperbugclass.theyarealsolanguage and api agnostic which means our approach applies off the shelf to multiplesourcelanguages anditspatchesautomaticallyconformto the programming conventions in a given project e.g.
constructing apatchusingaproject specificcustomresourcehandlerlike sw free for memory leaks if available or free if not without requiring any additional customization.
we instantiateourapproach inatoolcalled footpatch an extension to the infer 3static analysis tool.
infer finds bugs by automatically inferring separation logic assertionsover program 2methodsymbol mtd resolver.resolvemethod node id.getname method may be null checkguardedby mtd !
null id.tostring 6return bindselect computebase c ontext mtd mtd 8casemember select ... 10methodsymbol mtd resolver.resolvemethod node id.getname same problem!
13return bindselect computebase c ontext mtd mtd a developers fixed the potential null pointer exception on line 18monthslater theyaddressedtheverysimilarbugonlines12 .
1public static void checkguardedby boolean cnd 2string fmtstr object... fmtargs 3if !cnd throw new illegalguardedby s tring.format fmtstr fmtargs b error prone s custom guard handler.
figure fixing a null dereference in google s error prone tool.
statements.infer reasonsovera semantic analysis orientedintermediatelanguage il andappliestolarge real worldprograms written in multiple source languages.
separation logic can be used to encode a variety of desirable correctness properties .
we situateourapproachbyextendinganalysesthatfindbugsrelated totheviolationofpointersafetyproperties thefocusofinfer.in thispaper werestrictourfocustoconstructingadditivepatchesfor resource leaks memory leaks and null dereferences.
we discuss directions for generalizing our technique in section .
.
our approach provides several important benefits over previous techniques for automatic patch generation or fix suggestion.
by integrating directly into the static analysis workflow our approachaddressesdifferenttypesofbugsthanarehandledbymostdynamic aprtechniques andcanencouragetheadoptionoftheserobust static bug finding tools in practice .
because of the way our approach uses compositional specifications it can produce fixes that are significantly semantically richer than existing static quick fix suggestions.
footpatch can construct repairs that cross procedure boundaries entail multiline fixes and are robust to programspecificcustomizationlikewrapperapis.thesebenefitsareevident in the above examples both of which footpatch can repair automatically.note forexample acallto checkguardedby doesnoton its own constitute a repair as it simply checks the results of a boolean expression.
footpatch can determine that the function implements the desired behavior because it searches over composi tional function call results.
additionally both bug fixes use custom resource wrappers which are often desirable as fixes because they areconsistentwiththeconventioninotherpartsoftheprogram.
for example sw freewraps the freefunction and performs additional non interfering operations by setting the pointer to null authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static automated program repair for heap properties icse may june gothenburg sweden andloggingadebugmessage.finally unlikepreviousrepairtechniques that build on more formal abstract domains our approach scales to real world programs automatically instantiatesandappliesitspatches andreliesonaprincipledsemantic treatment to argue patch correctness and prevent patch overfitting.
thatis footpatchdemonstratesapromisingandpreviouslyunderdeveloped application of end to end identification and repair of previously undiscovered bugs in real programs.
our contributions are the following program repair with separation logic.
we present a repair technique using separation logic to ensure a desired correctnesspropertybasedonpointersafety.theabstract domainprovidesabasisforreasoningaboutexplicitsemantic effects introduced by patch fragments and enables a formal argument for semantic patch correctness.
repairextractionandapplicationformalism.
weformalize the search and extraction of program fragments with respect to a repair specification and define the conditions forpatchgenerationandautomaticpatchapplicationwith respect to a detected bug.
evaluation.
we present an evaluation on popular software projects.
our approach fixes resource leaks memory leaks and null dereferences in popular java and c programs including11previouslyundiscoveredbugs.weare unaware of any prior repair tool that supports multiple languages under a single analysis.
our implementation runs onbig projects klocs .
run time ranges from seconds to21minutesperproject toperformbothfindingandfixing bugswithintheproject.forapplicableprojects ourexperiments show that the majority of correct patches are found by searching for repair candidates that are callgraphlocal to the bug and expanding repair search to the project globally fixes additional bugs.
we observe a false positive rate of only for fixes.
moreover we demonstrate anecdotalevidencethatourtechniquecanleadtheoriginalstatic analysis to discover more bugs after performing repair.
open source repair tool.
we implement our technique inatool calledfootpatch builton topoftheopensource infer static analyzer.
section provides background theory underpinning our approach.
section details our repair approach using separation logic.section4evaluatesfootpatch atoolthatimplementsour approach.
section discusses related work section concludes.
preliminaries we build our approach on top of the analysis engine used in infer an open source framework that uses separation logic and hoare stylereasoning toscalablyfindbugs particularlythose relatedtoheaporpointererrors.thisanalysisabstractsaprogram to an intermediate language and then symbolically interprets it to find paths that may lead to particular property violations like null pointerdereferences .thissectionoutlinesbackgroundconcepts underpinning our approach and the analysis it extends the abstract program model and separationlogic assertions section .
b e e e nequale s x e x e x new dispose e c s c c if b c else c while b c x f e p f e local e c return e p a a simplified smallfoot grammar for illustration.
h e mapsto e h1 hn emp b1 bn true false p q ifbthen pelsep b the assertion language grammar.
figure theframeinferenceprocedurefordiscoveringspecifications section .
and an overview of how theconcepts fit together to findbugs statically in real world programs section .
.
.
program model and assertion language infer and our analysis both begin by abstracting a source program in one of several languages e.g.
java c c to the smallfoot intermediatelanguage sil .silisanintermediateanalysis language that represents source programs in a simpler instruction set describing the program s effect on symbolic heaps.
this is particularlysuitableforstaticanalysesthatfindbugsrelatedtopointer safety properties.
program model.
figure 3a shows a simplifed smallfoot grammar to illustrate the overall program model.
a sil program pis a set of procedures .
sil procedures have single return values and do not access global variables.
procedures consist of a series ofcommands c infigure3a whichmodelactionsthatgenerate assertionsoversymbolicheaps describednext .thestoragemodel is fairly standard heapis a partial function from locations loctovalues val forsimplicity locationsarepositiveintegersand valuesareintegers heapdef loc arrowrighttophalfval.stackisafunctionfrom variables to values stackdef var lvar arrowrighttophalfval.
variables are twodisjointsets asetofprogramvariables varandasetoflogical variables lvar.aprogram stateissimplythecombinationofits heap and stack statedef stack heap.
assertions.
silcommandsprimarilycaptureeffectsoversymbolic heaps whichcomprisetheabstractdomainfordetectingfaulting conditions e.g.
memory leaks resource leaks null dereferences .
theseeffectscanbedescribedviapre andpostconditionsexpressed inseparationlogic whichdecoratethesilcommandsaccordingly.
figure 3b shows the assertion language grammar.
the grammar encodesheapfactsusingpoints toheappredicatesoverprogram andlogicalvariables i.e.
e mapsto e .heappredicatesareconsidered separate sub heaps or heaplets whose separation is denoted by 5symbolicheapsenableadecidableproofsystemforentailmentsunderaprescribed semantics we elide details for brevity.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden rijnard van tonder and claire le goues theseparatingconjunction read andseparately .theseparatingconjunctionimpliesthatthetwosub heapsaredisjoint.pure booleanpredicatesoftheform b1 bnassertconditionalfacts over heap predicates e.g.
e nil .
givenourfocusonrepair assertionsarerelevantinsofarasthey describe semantic effects of statements as predicates on the heap.
we denote by e mapstochar alloceda predicate allocedone e.g.
we may represent it in the grammar by the assertion e mapsto x trueforx fresh .
for simplicity this notation may assume a program variable evaluates to a heap location such as hmap we do this with the understandingthatstoresandheapsaretypicallytreatedseparately in the storage model .
.
frame inference akeynoveltyinourworkisthewayweextend frameinference to find bug repairs we thus briefly overview frames and frame inferenceinthiscontext.infer sseparationlogic basedanalysisuses hoare stylereasoningtofindspecificationviolations.itdoesthisatscalebysummarizingtheeffectsofindividualtermsinaprocedure andthencomposingthemintoprocedure levelspecifications.
local reasoning is used to summarize the effects of those individual terms.
local reasoning is enabled by the fact that a programcommand can often affect only a sub part of the heap.
for example the statement hmap sw malloc sizeof swhashmap is modeled as affecting only hmap the rest of the heap is unaffected by the allocation.
the fact that sub states can change in isolation is modeled by theseparatingconjunction.theunchangedpartoftheheapfora command is its frame the parts of the heap a command changes is known as its footprint.
thus frame inference which automatically infers command frames such that they can be composed efficiently into proceduresummaries 6iskeytoanumberofautomatedreasoning tools .
by discovering the unchanged heap portion of an operation frame inference discovers footprints expressed as small specifications of program terms .
moreformally theframerulecodifiesthenotionofreasoning over local behavior p c q p f c q f frame rule theframeruleallowsanalysisofacommand cwithaspecification p c q and a heap state hto proceed without considering unaffectedpartsof h theframe f ifitcanbeseparatedintoparts p f .frameinference discoversaframe fthatallows the frame rule to fire enabling local reasoning over the footprint.
we can summarize frame inference as follows.
let frame h s be theframeinferenceprocedurethatreturnsaframe f ifitsucceeds for a given heap state hand a specification sof a command expressed in the grammar of figure 3b .
the procedure consists of a proofsystemusingsubtractionandnormalizationrulestopartition the heaphintos f. we refer to previous work for the complete algorithm and proof system .
6for completeness this compositional analysis also infers anti frames or the missing partsoftheheapsstate.anti frameinferenceallowstheanalysistodealwithunknown calling contexts and increases precision by propagating intermediate results.
antiframe inference is not critical to our approach.
.
finding bugs using separation logic thepreviouslydescribedreasoningenablesscalable compositional static bug finding with minimal developer effort in the form of e.g.
annotationsorcustomization overreal worldcodebases.infer implements these by ideas by converting source programs into sil and then infers specifications described as symbolic heaps for sil programfragments.itdiscoversbugsbysymbolicallyexecutingsil commandsoversymbolicheaps accordingtoasetofoperational rulesthatupdatesymbolicheapassertions .thegeneralgoal ofthisstaticanalysisistodiscoverprogrampathswithsymbolic heaps that violate heap based properties.
infercurrentlysupportsdetectingawidenumberofheap related bugs using separation logic resource leaks memory leaks null dereferences aswellasexperimentalsupportforbufferoverflow detection thread safety and taint style information flow bugs e.g.
detecting sql injections for unsanitized values .
while we believeourapproachgeneralizestothesebugtypes inthiswork focusonpointer safetypropertiesofheapsforrepair specifically resourceleaks memoryleaks andnulldereferences asthesupport forthemininferismostmature.weleaveextensionofourapproach to further classes of bugs for future work.
toillustrate considerthememoryleakdescribedinfigure1a.
infer disovers this error by identifying the path through line where the variable hmapis allocated but notfreed before becoming dead.
when it discovers such an error the symbolic interpreter entersaspecialstate fault.wedenotethisformallyby c lscript leadsto fault meaning that the interpretation step leadstofor instruction cat location lscriptin symbolic state results in a fault.
for this example hmapisstillallocatedinthesymbolicheap denotedbythepredicate alloced i.e.
hmap mapstochar alloced at the location lscript when it becomes dead return lscript hmap mapstochar alloced leadstofault.7at this point our approach takes over from the bug finding analysis to seek a potential fix.
repair with separation logic thissectionpresentsourprogramrepairtechniqueusingseparation logic.
section .
formalizes our notion of repair with respect to heap based property violations.
in section .
we formalize the search procedure to discover candidate patch code drawn from existingprogramfragments i.e.
fromelsewhereintheprogramunder repair .
in section .
we describe the application of candidate fragments in source code in terms of where to introduce a change and how we filter out invalid candidates.
we illustrate throughout by referring to the motivating example in figure .
.
formulating repair fundamentally anyprogramtransformation forrepairorotherwise is composed of either one or a combination of two primitive operations addition and removal of program terms.
taking separation logic as the abstract domain a bug fix corresponds to a program transformation that leads to a fault avoiding interpretationin the analysis with respect to the property in question.
we presentlyconsider only additiveprogram transformations anddo not perform removal operations because the types of bugs we consideraretypicallycausedbythe lackofcertainoperationson 7forillustration weconsideronlythepredicateon hmap ignoringtherestofthestate.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static automated program repair for heap properties icse may june gothenburg sweden explicit heap content e.g.
resource release freeing memory or checking nullness of return values .
for instance developers oftenforgettoinsertmissingchecks .bug fixingchangesfor thesetypesofbugsthuscorrespondtoinsertingmissingstatements e.g.
checks initializations or cleanup handlers .
other types of repairs are certainly valuable in this domain and others but we leave discovery of them to future work.
the central repair question is thus does there exist a fragment ?cthat can be used to transform the program such that the fault state is no longer triggered?
we express this formally as follows definition3.
.
programrepair.
lethbadbetheheapconfigurationthatresultsinafaultunderinterpretationofacommand cat location lscript.arepairisanadditivetransformation tonaprogram p thattransitionsthefault inducingpredicateintheheapstate hbad toaheapstate hgoodthatpreservesafault avoidinginterpretation forcat lscript.
a repair satisfies c lscript hbad leadstofault t lscript prime h leadstoc lscript hgood negationslash leadstofault the additive transformation tis a program fragment operating on the program heap hat some point lscript prime that induces a desired fix effecton the heap producing hgoodat lscript.
the fix effect precisely defines what it means to avoid the faultstate.
weencodethetransformation t i.e.
thefixeffect asahoarestyletriplethatwecallarepairspecification.wespecify tas twosingletonheaps i.e.
asinglepoints torelationasinfigure3b fmappingtoa fixablepredicateoveraplaceholdervariable pvarin the precondition and a corresponding f primemapping to a fixedpredicate over that placeholder pvarvariable in the postcondition.
f andf primeexpressthedesiredsymbolictransitionontheabstractpredicates.
for example f pvar mapstochar alloced f prime pvar mapstochar freed specifies a generic fix effect for memory leaks over placeholder variablepvar.
note that such fix effects are generic to entire bug classes.byexpressingrepairovertheabstractdomaindescribing whatthecode does thisfixeffectspecificationapproachismultilanguage and resilient to syntactic customizations like apis or wrapper functions .
definition .
.
repair specification .
a repair specificationris a specification containing a program term repair fragmentcr acommand cinthesmallfootgrammar thateffectsa state transition from an error heap configuration fto a fixed heap configuration f prime denoted f cr f prime viaanatomicupdateofan abstract predicate.
inthispaper wemanuallyspecifyappropriate fandf primecorresponding to the general bug classes in question.
defining a mechanismtoautomaticallydetermine fandf prime e.g.
byformallyderiving it from a violation reported by an analysis is an interesting andplausible research direction that we leave for future work.
note however thatfixeffectsaregenerictoanentirebugclass andthus need only be specified once per analysis type to be applied to a givenprogram.moreover thestaticanalysisprovidesadegreeof confidence in the choice of fandf prime a poor choice will not ensure a fault avoiding interpretation for a particular fault and will be detected by analysis of the transformed program.
our implementation provides default fix effects for the bug classes we consider that suffice for many off the shelf projects requiringcustomization onlywhen aprojectuses aparticularorunique paradigm for handling e.g.
custom exceptions.
extend ing our technique to new static checkers employing automated semantic reasoning as found in infer could similarly involve specifying default fix effects for patching them eliminating the need for developer provided specifications for many real world projects.
.
searching for repairs repairqueries.
differentautomatedtechniquescandiscoverrepairs includingprogramsynthesis orsyntacticprogrammutation .ourtechniquedoessobysearchingoverexistingprogram fragments whichcan oftenexhibit thedesired semantic effectsto fix faults .
using existing program fragments also preserves program specific syntactic structure and semantic shapethat accompany a fix and may decrease the risk of overfitting repairs .wethussearchforprogramfragments crinthesmallfoot il from across the rest of the program with a repair query.a repair query encodes the desired semantic transition and returns satisfying repair specifications.
we illustrate this overall framing with respect to our running example in figure the computation in shows the semantic change that must be induced by some ?
c lscriptto preserve a faultavoiding interpretation fixing the memory leak bug in question.
thecomputationin informstherepairquestionlabeled in figure .
the specification in describesa desired program fragment ?cthat induces the desired fix effect on symbolic variable pvar whichisallocatedonpreconditionto?
c andfreedonpostcondition.
note that this fix effect is flexible and could describe fix code such as freemodeled in generic c or the custom sw free function.
a repair query seeking to repair a file resource leak ontheotherhand couldfindfragmentssuchas closeorfclosein c or f.close for a file fmodeled in java.
although the fix effects must be either inferred or specified their portability across mul tiple programs and languages amortizes the manual burden andrepresents an important improvement over the labor required to usetest basedaprtechniques whichrequireatriggeringtestcase per bug under repair.
?c lscript prime map mapstochar alloced leadstoreturn lscript map mapstochar freed negationslash leadstofault pvar mapstochar alloced ?c pvar mapstochar freed figure modeling repair search.
we call the repair query a hoare triple containing a hole foraninstruction cthatinducesthedesiredsemanticchangeunder the standard partial correctness interpretation.
for example the fixingfragment sw free map correspondsintheiltoacommand cof the form map mapstochar alloced call map mapstochar freed with the concrete program variable mapbound to pvar.
semanticsearchconstraints.
arepairqueryexpressesa symbolictransitiononthe abstractpredicates providingabasic structure that expresses fixes in terms of desired semantic heap prop erties.
so far our example repair query specifies crprogram fragments that perform strictly the desired symbolic transition authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden rijnard van tonder and claire le goues disallowingany crthatmayintroduceextrasemanticeffects.however as apracticalconsideration it maybedesirable tosearchfor program fragments that introduce extra semantic effects in addition to the fixing effect.
for example sw freeperforms cleanup and logging in addition to resource freeing in other cases such side effects may be benign or undesirable.
fortunately separation logic allowsus toelegantly relaxstrict repair queries by explicitly allowing for and then capturing extra semanticeffectsbeyondthedesiredfixeffect.thisproducesarepair search method that can be parameterized by extra semantic effects explicitly partitioning such effects from the fixing effect absent a priori knowledge to the fixing effect .
such a search returns re laxed repair specifications of the form f p cr f prime q where potential extrasemanticeffectsareboundinthepre p or postcondition q respectively.
finding satisfying repair specifications comes with an analogous extension of a repair query i.e.
f p ?c f prime q .
pertinently wecanuse frameinference inanovel waytosolve twoimportant anddistinct purposesintheprogramrepairsearch problem checkwhether agiven specificationsatisfiesa repair query and discover the extra semantic effects not part of the fix.thatis supposesomecommand chasafootprint expressedas sp c sq .ourfirstgoalistocheckwhetherthefootprintsatisfies the repair query which we do with respect to corresponding preand postconditions fandf prime.
our second goal is to partition the footprintintothefixingtransitionsandextrasemanticeffectsfor pre and postconditions respectively.
our key insight is to perform the frame inference procedure frame section2 onthe footprintprecondition resp.postcondition withrespecttothe repairquery precondition resp.postcondition .
formally cis a candidate repair fragment when the following entailments hold in the precondition frame sp f p sp turnstileleftf p respectively in the postcondition frame sq f prime q sq turnstileleftf prime q we achieve becausethe entailmentdoesnothold frameinferencefails when fisnotsatisfiedbythequery.ifframeinference succeeds it pulls out p resp.q discovering the extra semantic effectsinthefootprintof c achieving .ourapproachissound and decidable by the frame inference procedure .
assume fcontainsthespecificationsinferredoverallindividualcommandsinaprogram.algorithm1 findcandidates r f soundlyreturnsallcandidaterepairspecificationsforquery r. inline4and5ofalgorithm1 weusetheframeinferenceprocedureframe tomatchcandidatefragmentswitharepairqueryas theconjunctionofmatchingpre andpostconditions.notethattheprocedurereturnstheentirerepairspecificationbecauseweuse assertions in the precondition for repair application section .
.
.
applying repairs from logic to programs a repair specification in the abstract domain must be translated to a syntactic program fragment in the source program.
every intermediate language il instruction corresponds to a line in the originalprogramsource.whenacandidateprogramfragmentis translatedfromiltosource werenametheprogramvariableboundalgorithm find candidate repair fragments 1match s r 2let rf ?cr rf prime rin 3let sp c sq sin 4ifframe sp rf rp nequalfail sp turnstileleftrf rp frame sq rf prime rq nequalfail sq turnstileleftrf prime rqthen return rf rp ?cr rf prime rq 7else returnfail 9end 11findcandidates r f 12c candidates 13foreach s fdo ifmatch s r c nequalfailthen c c c end 17end 18return c topvarinthefixingfragmenttothatofthefault inducingvariable if necessary.
this substitution is the only syntactic transformation that we apply on source fragments.
beyond this renaming we must decide where to insert repairs and check translated code for compatibility given associated heap assumptions and available variables and type information available in the il .
determining repair location.
repairtechniques typicallyrely ondynamicfaultlocalizationtechniquestodetermineplacementor manipulationofcode .bycontrast werelyonthestaticanalysis to localize faults when the symbolic interpreter enters a fault state it provides a location lscriptwhere the fault occurs.
in general the fault class bears on the choice of where to apply a repair fragment.
for null dereferences we speculate that a developermighttypicallyexpectachangebeforethenulldereference e.g.
a check whereas for resource leaks we expect a change after the point at which the resource is last used e.g.
closing a file .
usinginfer anulldereferencereportsthelocation lscriptimmediately precedingthedereference.forresourceleaksandmemoryleaks the location lscriptis the point where the resource resp.
memory goes out of scope without being closed resp.
freed .
we make the design choice to insert a repair fragment crdirectly preceding the program term at location lscript satisfying cr lscript prime hbad leadstoc lscript hgood negationslash leadstofault werefertotheexampleinsection1tomotivateourchoice.our approach places the sw freecall at line in figure 1a.
the first motivationisthatrepairlocationistypicallyrestrictedtofewalternatives theonlyothercorrectchoiceofplacementisline10.the location lscriptthus offers the most immediate and sometimes strictly correctchoice.thesecondmotivationisthatamongmultipleplacement locations the semantic effects of repair remain the same.
for example placing sw freeat line in figure 1a.
produces the same effectsincethe swwarn ... statementdoesnotaffecttheheap.thus althoughthereisnouniversallycorrectchoiceforrepairplacement ourdomainofrepairbenefitsfromageneralstrategythatpreserves semantic correctness.
determining the ideal placement of patches authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static automated program repair for heap properties icse may june gothenburg sweden withrespect tonon semanticattributes mayvaryby context and maybesubjecttostylisticconventionsandhumanjudgmentthat go beyond the scope of this work.
determining patch compatibility.
patch compatibility determines whether we caninsert a syntactic program fragment at a particular program point lscript in our case .
footpatch performs two compatibility checks.
the first addresses bugs that can have multiple candidates.
for example memory may be freed by the standardclibrary freecall orawrapperfunctionsuchas sw free asinlisting1b.whenmultiplecandidatefragmentsinsilmatches the desired semantic effect based on predicates that do not considertypes footpatchprioritizespatchgenerationbymatching type informationof acandidate fragment s variableand thefaultinducing variable.
this means that footpatch prefers sw freeover freein our example because we can infer the type of hmapto be swhashmap which matches the same type of mapin the candidate fixing fragment sw free map .
footpatch falls through to matching candidateswithgenerictypes i.e.
void forc ifitcannotmatch specifictypes.althoughtypinginformationcouldbeusedtorefine patches for null dereferences we ignore typing information in this case since any object can be compared to null.
recompilation serves as our second compatibility check ensuring a that syntactically malformed patches fail due to pooril to source translation or fault locations and b that program fragmentswithunboundfreevariablesareinvalidated.forinstance the fix for the bugs in figure binds to the variable idthat is in scope.
if idwerenotin scope patch generation fails.
relatedly footpatch allows capture of program variables beyond the faultinducing variable in fixing fragments if they are available such as idwhich is in scope .
evaluation this section describes our the results of using footpatch to fix bugsinreal worldprograms.section4.1describesourexperimental setup.
section .
describes overall repair results where we use footpatchtofix55bugsin11projects.insection4.3wediscuss patch quality and particularlyits relationship to infer s underlying static analysis and our other design decisions.
section .
analyzes footpatch srepairdiscoveryforresourceleaks memoryleaks and nulldereferencesinthecontextofourgeneralformalism section3 .
section .
provides limitations and further discussion.
.
setup implementation.
based on the techniques described above we implemented an automatic bug repair tool called footpatch extending the infer static analyzer.
footpatch works on multiplesource languages we evaluate on programs in c and java inferalso supports c and objectivec because like infer it reasons over programs translated into sil.
footpatch uses the same predi catesintheilirrespectiveofsourcelanguage meaningitcanapply directly to new languages as support for them is added to infer.
footpatchusesthreegeneralspecificationsforrepairingnull dereferences resource leaks and memory leaks figure provides a simplified representation.
the specifications are implemented as ocaml functions that match pre post conditions on heap state and pvar mapstochar null ?c mapstochar exne pvar mapstochar angbracketleftfile acquired angbracketright ?c pvar mapstochar angbracketleftfile release angbracketright pvar mapstochar angbracketleftmemory acquired angbracketright ?c pvar mapstochar angbracketleftmemory release angbracketright figure repair specifications.
predicates referencing infer s datatypes .
note that this specifi cation mechanism is not intrinsic to the technique i.e.
it is possiblewriteadslforexpressingsuchspecifications .footpatch performs type matching for determining patch compatibility section .
by extending specifications and in figure with an optionalguardclause whenpvar.type t ifwecandeterminethe typetofafaultingvariable.ingeneral sincesimpleexpressionsdo not model semantic effects of interest to the bug types in question we restrict repair queries to calls and branch statements in the il.
data and experimental parameters we ran our experiments on an ubuntu .
lts server with xeon e5 cpus and 20gbofram.table1includesprojectswhich a successfullybuilt on our system b could be analyzed by infer and c generatedpatches.
our project selection represents a convenience sample intended to substantiate our claims about footpatch applicability to real bugs in real and actively developed open source systems we include discussion of sources of failures and other technique limitations in section .
.
we evaluate on c programs and java programsaveraging64kloc.weinitiallydevelopedfootpatch basedonexistingbugsin error prone and jfreechart andnewbugs found in swoole.
the rest of the projects are c and java repositories ongithubthatareeither a randomlysampledfromthetopone thousandmostpopularrepositories byuserfavorites stars forc and java respectively or b contain any combination of the terms leak resource memory file or fix intheircommitmessages.
projects in our sample are excluded if they fail to compile in our environment if they cannot be analyzed by infer or if footpatch did not find patches either because no bugs were found or due to some other failure .
weevaluatedfootpatchintwomodestocharacterizeitssearch behavior.in callgraph local mode footpatchsearchesovercandidatesfromthecallgraphoffunctionswhereinferreportsabug.
thismodetrackswhethercandidatesarefoundlocaltothefunction containing the bug local to the file containing the bug or from an external file.
in global mode footpatch searches over all disjoint callgraphs.
global mode subsumes callgraph local mode and inour experiments only discovers additional repair candidates inexternal files not included in the local callgraph.
global mode is naturally more time intensive but may identify additional patches comparing the two modes allows a more precise understanding of the importance of locality in searching for bug fixes within a given program.
in all results discussion gl indicates the increment searching globally has over searching locally.
.
repair results table show results for each project.
bugs indicates the number ofbugsdetectedbyinferofthegiventype.itispossibleformultiple semanticfragmentstorepaireachtypeofbug foundatdifferent locationsinthesilcallgraph.foreachbugtypeperprogram maxcands shows maximum number of il repair candidates before the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden rijnard van tonder and claire le goues time bug max project lang kloc s gl type bugscands glfixes glfp gl swoole c .
83res.
leak mem.
leak lxc c .
res.
leak 0mem.
leak 1apktool java .
res.
leak dablooms c .
res.
leak php cp c .
res.
leak armake c .
res.
leak sysstat c .
res.
leak redis c .
res.
leak rappel c .
mem.
leak error prone java .
null deref jfreechart java .
null deref 0table bugs repaired with footpatch.
bugs is the number of bugs detected by infer s static analysis.
max cands is the maximumnumberofilrepaircandidatesforthebug pre compatibilitycheck .
fixes arethenumberofuniquepatchesfixinguniquebugs postcheck .
indicatesoneormorefixesforpreviouslyundiscoveredbugs.
gl isthechangeinassociated column when using the global search space.
compatibilitycheckwhichdetermineswhetherapatchcandidateis suitable syntactically.
footpatch emits the first compatible patch producedfromthecandidates.
fixes showsthenumberofunique patches that fix true semantic errors.
conversly fp shows thenumber of unique patches that fix false positive bug reports we discuss patch quality and correctness in section .
.
in total we discover fixes for resource leaks fixes for memoryleaks and24fixesfornulldereferences.the time columns oftable1shows totaltimerequiredtobothfindandpatchallbugs ofalltypesconsideredinthatprogram.performancerangesfrom 7secondsto22minutesoverallprojects notethatfootpatchperformance is intertwined with infer s analysis time .
the jfreechart experiment failed to terminate in global mode because the infer analysisphase ranoutofmemory lxcfailedto buildintheglobal configuration.
global mode gl discovers only additional fixing patches.
this patch fixes a resource leak due to discovering a close like function that is not present in the local search.
our results suggest thatlocalizingsearchforfixingfragmentsisaneffectivestrategy forrepair.thisisconsistentwithempiricalresultsthatsuggestthat code is redundant locally especially within a module .
.
patch quality patch correctness and success.
all produced patches ensure a fault avoiding interpretation in practice we apply each patch generatedbyfootpatchandrerunthestaticanalyzertoseeifthepatch removesthebug alldid .wherepossible weranaproject stest suiteafterapplyingourpatchestovalidatethatourchangesdonot breaktests.wesuccessfullyranthetestsuitesfor apk tool armake and error prone whichpass.twoprojectscontainednotests andthe remaining six test suites could not be successfully configured built.
a fix in table produces a patch that addresses a true positivebug report from the static analysis.
to be useful in practice analyses approximate .
infer is no exception and it sometimes1 fp fopen rdbfilename r ... if memcmp buf redis !
rdbcheckerror wrong signature t rying to load db from file fclose fp return rdbver atoi buf if rdbver rdbver rdb version rdbcheckerror can t handle rdb format version d rdbver fclose fp return ... figure6 fpcanbeleakedonatleasttwopaths lines6and12 but infer short circuits the analysis and only reports the leak on line bydefault.withfootpatch theleakisfixedatline6 allowsinfer tofindtheanotherresourceleak whichisthenalsofixedatline11.
skipsinferringspecificationsforafunctionduetoananalysistimeout continuing with partial results.
this can lead to false positives.
footpatch uses infer s results to perform patching and cannot distinguish between true and false positives if it could it wouldbe a better analysis than infer this task is outside its scope .
a manual inspection of infer s reports indicate that its false positives generallyarosewhenitfailedtoanalyzeloopsorcleanupfunctionsdue to time out.
due to the complexity of jfreechart it is difficult to preciselydeterminehowmanyoftheinfer reportednulldereferencesarefalsepositives.however ourmanualinspectionofdidnot reveal obvious errors in reasoning behind the produced patches.
false positives that produced patched bugs are listed in column fp oftable1.ingeneral thefalsepositiverateislow intheorder of5 wherefixesareproducedforfalsepositiveerrorreports fp column compared to fixes for true positives fixes column .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static automated program repair for heap properties icse may june gothenburg sweden 1intfd open filename o rdonly ... 3swstring content swstring new filesize 4if !content close fd footpatch repair return null function returns with fd not closed ... continues with norm al operation figure resource leak forgetting to close a file.
ontheotherhand infermayfindbugsthatdonotresultinafix therearetypicallymore bugs than fixes intable1 .footpatch finds fixes out of bugs excluding false positives .
patch generationfailswhennorepaircandidatecanbefoundforthebug.
generally this happens when a infer s analysis times out e.g.
duetoloops leadingtoincompletefunctionspecificationsorshort circuited analysis that miss fixing fragments b infer does not resolve program variables associated with a bug report c no type compatiblefragmentsarediscovered or d memorytimeoutsoccur for parallel analysis processes short circuiting analysis results.
patchlocation.
as motivated in section .
footpatch heuristically places fix code at the line where infer reports the violation.
forresourceandmemoryleaks feasiblerepairlocationsareconstrained by the number of lines at which the resource is no longer in use but before it is officially dead.
in our data the maximum numberofpossiblecorrectlocationsacrossall31fixingpatchesfor resource memory leaks is3 while the average is1.
.
this implies littleopportunitytovaryplacementoutsideofourconvention similartoourmotivatingexampleinfigure1a.fornulldereferences checks may plausibly be placed anywhere between the point at whichanobjectbecomesnullanditsdereference.ourinspection based on infer s bug reports revealed that the number of locations ranges from to which poses more variability for placement.patches reveal more bugs.
an especially interesting implication ofunifyingbugdetectionandrepairisthepotentialforthelatter to extend the capabilities of the former.
in our experiments footpatch generated patches for the redisproject that then allowed infertofindtwoadditionaluniquebugs.figure6showsasnippetof the code in question.
the fpfile pointer leaks on at least two paths lines and .
before patching infer only reports a resource leak forthevariable fp becauseit shortcircuits itsanalysisoncethe first leak is detected.
after footpatch inserts fclose fp on line inferreportsthesecondleakonline11.rerunningfootpatch yieldsanadditionalfixonline11.tothebestofourknowledge this isthefirstdemonstrationthatautomatedpatchinghasthepotential to improve static analysis.
.
fixing by semantic effects resourceandmemoryleaks.
resourceleaksoftenoccurwhena functionreturnsprematurelyduetoanerror .figure7shows aleakofanunreleasedfilehandleinthe swoole8project.footpatch uses the repair query pvar mapstochar angbracketleftfile acquired angbracketright ?c pvar mapstochar angbracketleftfile release angbracketright from figure5 todiscovera close fd elsewhere in the program.
this demonstrates the importance of the compatibilitycheck whichguardsagainstapplyingalternative close operations e.g.
fclose by using typing information.
the pull request 8swooleis the 34th most popular c project on github at the time of writing.basedonthepatchinfigure7wasaccepted 9animportantmilestone for end to end automatic repair of a previously undiscovered bug.
notethat althoughconceptuallysimilartoresourceleaks memoryleaksdeserveseparatesemantictreatmentbecausetheytend to occur in programs written in languages that are not garbagecollected.
anecdotally memory leaks may entail more complexfixes in terms of semantic effects.
all resource leak patches conformtostrictrepairspecifications meaningtheyonlyaffectthe heaplocationofinterest .however fixingfragmentsformemory leaksmayentailextrasemanticeffects.oneexamplefragmentis swhashmap node free hmap root fromthe swooleproject whichfrees a data member rootthat is in the table hmap.
a necessary preconditiontoinsertingthisfragmentforfreeing rootisthat hmapbein scope which it is where it is used in our produced patches .
weobtain such a fragment by relaxing the repair query to allow extrasemanticeffects.oneimplicationofrelaxingrepairsisthat applicationmaybecontextual andsubjecttoadditionalcompatibilitychecks e.g.
scopeandvariablecapture withrespecttoextrasemanticeffects.insummary ourresultsshowthatfootpatchthemajority of leak fixes conform to strict repair specifications but enables more complex fixes when relaxing the repair constraint.
null dereferences.
the footpatch patch for the null dereference s in figure throws an exception when an object is null.
however in general multiple semantic fix effects may address a givennulldereference initializinganullobject returningorthrow inganexceptionwhenanobjectisnull orpredicatingexecutionona conditionthat anobjectis notnull.
more thanone ofthese forms may be correct with respect to a preserving a non null property and in general we cannot decide which one is preferred .
we therefore experimented with repair specification queries infootpatchovermultiplesilcommandstodiscovernulldereference fixes i.e.
function calls entailing nullness checks conditional expressions .ourapproachalleviatestheproblemofmultiplepotentialfixesbyrelyingonexistingcodetoguiderepair.forexample for jfreechart footpatch produces patches from a candidate which throws an exception when the object is null.
this may be thedesirablefix aswitnessedbyhuman writtenfixesforthe errorpronebug .
regardless from a semantic perspective footpatch finds candidate fixes from the existing project that removes the fault with respect to the analysis.
.
limitations and discussion footpatch currently fixes resource leaks memory leaks and null dereferences thesebugsareamaturefocusofinfer sanalysisdomainandarecommoninpractice .givenbothourunderlying technique which addresses general heap based properties and the continual addition of new analyses to infer weexpect footpatch to generalize to for example information flow bugs.
footpatch currently requires a simple manual fix specification generally per bug type.
this formulation provides flexibility to addressparticularattributesoverdiversebugclassesandlanguages.
the manual effort is competitivewith effort required to produce a test per bug required by dynamic repair techniques.
moreover we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden rijnard van tonder and claire le goues recognize an opportunity for automatically inferring fixing effects with the aid of a static analyzer for future work.
footpatch does not consider the full diversity of possible fixes for theconsidered defects especiallyfor nulldereferences we investigated checking nullness and throwing an exception accepted ways forfixing thesebugs but notinstantiating newobjects generally .
our approach currently inspects only semantic patch characteristics ignoring forexample stringconstantsinanerrormessage.
we leave such considerations to future work.
beyondfalsepositives infercanproduceinaccuratefaultlocations impacting the validity of footpatch patches.
approximate locations are acceptable for bug reports and approximate patches maystillbeinformative buttrulyautomatedprogramrepair requires precise locations.
this can be addressed practically by improving the accuracy of il to source translation during analysis.
we do not explicitly compare our technique to prior repair techniques.overall footpatchisorthogonal andthusdifficulttocompare topriordynamicrepairtechniques.twoofourbugclasses resourceandmemoryleaks aredifficulttotestfordeterministically andthusunderaddressedinthecurrentrepairliterature.theredoes exist work addressing repair of null dereferences which are easier to expose via tests.
we attempted to run and fix the null deref erences in apache commons math considered by nopol .
however infer s analysis skips a number of intermediate calls and failstodetectthenulldereferencescoveredintheassociatedtest suite.practically speaking we findthat testsfor nulldereferences considered in prior work such as defects4j simply cover differentnulldereferencebugsfrominfer.thishighlightsoneproperty of static analysis for repair analysis may miss bugs that could becoveredbytests butmaysimultaneouslyfindthoseincorner casesthathumansneglectedtotest.relatedtechniquesbasedon verification lack detailed breakdown of bugs to inform a comparative study and is intended to provide patch suggestions to adeveloper which lacks automatic patch application.
we are unaware of quick fix suggestions from existing static tools that target semantic bugs like those we consider.
related work workinautomaticprogramrepairoverthepastdecadepredominantly use test cases to validate correctness.
generate and validate orheuristicrepairtechniquesexploresearchspacesoftemplated repairs as applied to the abstract syntax tree program level this includes techniques like genprog rsrepair and hdrepair whichtraversethespaceusingclassicsearchalgorithmslikegeneticprogrammingorrandomsearch.othertechniqueslikeae spr and prophet use predefined transformation schemas andprobabilisticmodelsontheasttodiscoverandapplycandidate syntacticfragments.
ata highlevel such techniquesoperate on asts to indirectly achieve a desired semantic effect that fixes abugwithrespecttoatestsuite.constraint orsemantics based approaches reason about semantics more directly synthesizing fragmentsusinginput output pairstocodifyanotion ofprogram semantics .
searchrepair lies between these approaches using input output pairs to search over a semantic encodingofcandidaterepairfragments andisperhapsclosestin spirittoourapproach .thesetechniquesallsharethepropertythattheyusetestcasestodefinepatchcorrectnessandguideasearch towardsasemantically desirablefix asaresult theyalsorequire developer labor to specify those tests are limited to fixing bugs that are deterministically testable and may overfit to the provided tests .
the main point of contrast with our work is that our approachisstatic andthereforecannotoverfittoprovideddynamic witnessesofdesiredbehavior.inthepreviousbodyofwork propertiesarenotspecifiedformally butimpliedbytestcases.footpatch instead considers a logic encoding and semantic implications ofusing a program fragment for satisfying repair specification.
we argue that our focus on explicitly codifying semantic effects offers additional protection against patch overfitting.
verification based approaches using formal specifications have used ltl specifications sat approaches deductive synthesis contracts and model checking for boolean programs to perform repair.
at a high level our approach relates to the approach by logozzo et al.
which uses automaticallyinferredassertionsoverabstractdomains andrelieson an abstract interpretation basedstatic analyzer to discoverfaults however they do not consider automatically applyingpatches.
in contrast ourapproachisnewinreasoningoveranabstractdomain based in separation logic repairing pointer safety violations and formalizesamechanismforautomaticpatchapplication.overall verification basedprogramrepairlackapplicationtocommonbugs in real world programs.
conclusion wepresentedanewstaticaprtechniqueusingseparationlogic to reasonaboutsemantic effectsof programfragments including a novel application of local reasoning and the frame rule to find bug fixingpatchesfromexistingcode.ourtechniqueovercomes significant challenges compared to test based repair techniques including the ability to repair previously undiscovered bugs bugs that are difficult to expose via testing and repeated semantic er rors.
we implemented our approach in a tool called footpatchthat builds on top of a separation logic based analysis to target bugrepairforheap relatedproperties wedemonstrateonresource leaks memory leaks and null dereferences and anticipate that the approach is extendable.
footpatch correctly fixes bugs including undiscovered bugs in projects.
moreover footpatch achieves significant speedup over test based repair works on large codebases and targets multiple source languages.
unlike other formal approaches for program repair footpatch works end to end onexistingcodebasesanddoesnotrequireformalannotationor special coding practices.
its reliance on principled semantic reasoning provides additional evidence of generated patch correctness.
footpatchthusrepresentsanimportantstepinbridgingthegap betweengroundedverificationtechniquesandtrustworthyautomatic program repair for real world software opening potentially promising avenues in automatic program improvement.