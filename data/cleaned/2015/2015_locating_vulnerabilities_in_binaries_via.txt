116locating vulnerabilities in binaries via memorylayout recovering haijun wang shenzhenuniversity chinaxiaofei xie nanyang technologicaluniversity singaporeshang wei lin nanyang technologicaluniversity singapore yun lin national universityof singapore singaporeyuekang li nanyang technologicaluniversity singaporeshengchaoqin teesside university unitedkingdom yang liu nanyang technologicaluniversity singaporetingliu xi anjiaotong university china abstract locatingvulnerabilitiesisanimportanttaskforsecurityauditing exploit writing and code hardening.
however it is challenging to locate vulnerabilities in binary code because most program semantics e.g.
boundariesofanarray ismissingaftercompilation.
withoutprogramsemantics itisdifficulttodeterminewhethera memory access exceeds its valid boundaries in binary code.
in this work we propose an approach to locate vulnerabilities based on memorylayoutrecovery.first wecollectasetofpassedexecutions andonefailedexecution.then forpassedandfailedexecutions we restoretheirprogramsemanticsbyrecoveringfine grainedmemory layouts based on the memory addressing model.
with the memory layouts recovered in passed executions as reference we can locate vulnerabilities in failed execution by memory layout identification andcomparison.ourexperimentsshowthattheproposedapproach iseffectivetolocatevulnerabilitieson24outof25darpa scgc programs and can effectively classifies program crashes in5linux programs into19 groupsbasedontheirroot causes.
introduction for memory unsafe languages like c c memory corruption vulnerability is one of the most severe defects as it can lead to software crash or even allows adversaries to take full control of the software.
buffer overflow is one of the most common memory corruption vulnerabilities which is also the focus of this paper.
in the remaining of this paper by vulnerability we mean buffer overflowvulnerability.
therehavebeenanumberoftechniques thatcanlocate bufferoverflows andmostofthemareinthesourcecodelevel such as addresssanitizer .
however the source code is not always available e.g.
closed sourcesoftwareandoff the shelfcomponents in iot devices .
further it is shown that the semantics of binary code may be different from its source code .
for the purpose of binary securityauditing exploit writing and code hardening it is highly significant to locate buffer overflows in binary code directly.
however it is much more challenging to locate buffer overflows in binaries than in source code.
when the source code is compiled into binaries its program semantics is missing i.e.
we are not able to identify variables of program and their memory boundariesanymore.
without the memory boundaries locating buffer overflowsinbinarycodebecomesverydifficult.althoughtherehave beensometechniquesworkingonthebinarycode e.g.
valgrind memchecks noneofthemcanlocatebufferoverflowswithin thestack globalmemoryregions e.g.
overflowbeyondanarray but still within its resident stack frame .
to address these issues recoveringtheprogramsemantics i.e.
memoryboundaries of variables is necessary to locate buffer overflows inbinary code.
in addition locating vulnerabilities highly benefits triaging programcrashesinbinaries .itiswell knownthatthesamevulnerabilitycanproducevarioussymptoms leadingtocrashesatdifferent locations.forexample thefuzzingsystem e.g.
fairfuzz aflfastand aflgo usuallygeneratesalargenumberofcrashes.however not all of these crashes are unique.
many of them are due to the samevulnerability.ifthecrashescanbegroupedaccordingtotheir root causes itwouldgreatly improve the efficiency of analysis.
aimingataddressingtheabovechallenges weproposeanapproach basedondynamicexecutioninformation tolocatebuffer overflowsinbinaries.ourapproachmainlyconsistsoftwoparts recoveringmemorylayout andlocating vulnerabilities .
recoveringmemorylayout .amemorylayoutrepresentsthe staticdatastructureofavariableinsourcecode e.g.
adatastructure with its members.
in our approach we actually use the dynamic executioninformationinbinarycodetorestorestaticdatastructure information of variables in source code.
to recover the memory layout first we identify the relevant addressing instructions for each memory access in dynamic execution information.
second we recover a memory layout for each memory access based on the memory addressing model.
third if multiple memory layouts e.g.
recoveredfrommultipleexecutions accessthesamevariable we merge them into a memory layout generating a more complete staticdatastructureforthatvariable.comparedtoexistingtechniques our approach can precisely recover fine grained memory layoutsofvariables c.f.section .
.
locatingvulnerabilities .basedonrecoveredmemorylayouts we locate buffer overflows in a failed execution.
to achieve this goal we need to determine whether the recovered memory layout infailedexecutionexceedsitsvalidboundaries.toinfertheboundaries wecollectafailedexecutionandasetofpassedexecutions.in this paper the failed execution means to cause the program crash 174esec fse2019 30august tallinn estonia haijun wang xiaofeixie shang wei lin yun lin yuekang li shengchaoqin yang liu andting liu identify relevant instructions2 recover memory layout on single access3 merge memory layouts on multiple accesses4 locate vulnerabilitiesreportsstatic memory layout recoverypassed and failed test cases binary programpassed and failed execution informationdynamic execution informationfigure overview ofour approach ptr stu .name typedef struct int name void func void stu typedef struct stu stu int a info static int num void f void ... void test int a int b info ptr info malloc sizeof info char str char malloc b for int i i b i str a str str ptr stu .func f for int i i b i ptr stu .name ptr stu .name ptr stu .func ...... l1 mov 0x3c ebp eax l2 movb 0x61 eax l3 addl 0x1 0x3c ebp ...... m1 mov 0xc ebp eax m2 mov 0x8 ebp edx m3 shl 0x4 edx m4 add edx eax m5 add 0xc eax m6 movl 0x804843b eax ...... p1 mov 0xc ebp eax p2 mov 0x8 ebp edx p3 lea 0x0 edx ecx p4 mov 0x10 ebp edx p5 add ecx edx p6 movl 0x29 eax edx ...... q1 mov 0x804a020 edx q2 mov edx eax q3 shl 0x2 eax q4 add edx eax q5 lea 0x3 eax ecx q6 mov 0xc ebp eax q7 mov 0x8 ebp edx q8 shl 0x2 edx q9 add ecx edx q10 movl 0x2a eax edx ...... 28real memory layout recovered memory layout ptr stu .func f ptr stu .name ptr stu .name a source code d merged memory layout c memory layout on single access b identified relevant instructionsstr str str str l1 l216 ptr stu ptr stu aname name func func ptr stu ptr stu aname func func24 name l416 ptr stu ptr stu aname func func24 name 0memory block 36x1 x1 l3lp 3228overflow e reported root cause lf3228 failed memory layoutpassed memory layout32step 1step step step figure illustrationexample forour approach whilethepassedexecutionwouldnot.thefailedexecutionisthe inputtoourapproach andpassedexecutionscanbeobtainedeasily fromexistingtoolsortestsuites c.f.section5.
.forpassedexecutions werecover theirmemorylayouts calledpassedmemory layouts which are considered as the memory layouts within valid boundaries.forthefailedexecution wealsorecoveritsmemory layouts calledfailedmemorylayouts whichmayincludememory layouts exceeding valid boundaries called vulnerable memory layouts .
with the memory layouts recovered in passed executions as reference we can locate vulnerable memory layout i.e.
candidatebufferoverflow inthefailedexecutionbymemorylayout identification andcomparison see section .
we have implemented the proposed approach in a prototype tool and evaluateditseffectivenessintwo differentaspects locating vulnerabilities and triaging program crashes.
in locating vulnerabilities ourapproachiseffectivetolocatebufferoverflow vulnerabilities on out of darpa s cgc programs .
in triagingexperiments ourapproachisabletoclassifythe453program crashes in widely used linux programs into groups whileafl reports 320unique crashes groups .
the contributionsofthis work are summarizedas follows we formalize a memory addressing model based on which togetherwiththedynamicexecutioninformation wepropose a general approach to precisely recover the static finegrainedhierarchical memory layoutsofprogram variables.
with the memory layouts recovered in passed executions as reference weproposeanapproachtolocatebufferoverflows infailedexecutionbymemorylayoutidentificationandcomparison.tothebestofourknowledge byusingfine grained memory layouts our approach is the first work to locatebufferoverflowswithinstack globalmemoryregions and data structures inbinary code.
we implemented a prototype of the proposed approach and evaluated its effectiveness on binary programs with diverse kindsofvulnerabilities.
approachoverview .
motivating example fig.
a showsaprogramwithabufferoverflowvulnerability.if theinputoffunction testis theprogramcrashesatline14.
the buffer overflow is triggered in the loop line .
the variable ptr stu .namecontains three elements but is assigned with four elements.
as a result the variable ptr stu .funcis overwritten and the program crashes when line is executed where ptr stu .funcisaccessed .
after being compiled into binaries the program semantics is missing makingitdifficulttoidentifythevariablesandtheirboundaries.
for example the variable ptr stu .nameand its memory boundaries its size is bytes are missing in binaries.
without thisinformation thebufferoverflowcannotbeidentifiedwhenit iswritten with16 bytes.
.
overviewofourapproach to address this issue we propose an approach to locate buffer overflowsinbinaries.theoverallflowoftheproposedapproach isshowninfig.
.theinputtoourapproachisasetofconcrete1 executioninformation eitherpassedorfailed .
1noticethatwecalltheobtainedexecutions concrete becausetheyarerealtraces from dynamic executions.
thus there are no loop or recursive function issues any morein ourapproach as theyhavebeen unrolled during dynamicexecutions.
290locatingvulnerabilities in binaries via memorylayoutrecovering esec fse2019 30august tallinn estonia 348theproposedapproachconsistsoffoursteps.inthefirststep givenpassedandfailedexecutions weidentifyrelevantaddressing instructionsforeachmemoryaccess.inthesecondstep werecover thememorylayoutforeachmemoryaccess.sinceoneexecution may have multiple memory accesses we may have more than one memory layout recovered.
if some of the recovered memory layouts access the same variable we merge them into one in the thirdstep.afterthisstep wehaverecoveredmemorylayoutsfor each execution either passed orfailed .
in the fourth step we use the memory layouts of passed executions as reference to locate buffer overflows in the failedexecution.in the following we walk throughthesesteps using the motivatingexample infig.
.
step1.
we identify relevant addressing instructions for each memory access.
to access a variable the program first determines its memory address.
for a memory access instruction we perform a backward taint analysis to identify the relevant instructions used to compute its memory address.
fig.
b shows several sets of identifiedinstructions.forexample m6isamemoryaccessinstruction we perform backward taint analysis and identify the relevant instructions m1...m6 whichcorrespondto line10 infig.
a .
step2.werecovermemorylayoutbasedonidentifiedinstructions for each memory access.
in general the memory address of a variable is computed by iterativelyadding an offset tothe address ofitsenclosingvariable.basedonthisiterativeprocess weidentify thememory blocks c.f.
definition which represent the enclosed variables.inaddition weconstructtheirhierarchicalstructure and finally form amemory layout.
forexample considerinstructions p1...p6 whichcorrespondto line e.g.
ptr stu .name .
the recovered memory layout is l3 as shown in fig.
c where the red part is the real memorylayoutofthevariable andthebluepartistherecovered memory layout double headed arrows below indicate memory blocks .
based on identified instructions we can infer that the memoryaddressiscomputedbyaddingtwooffsets 16and8 tothe baseaddress andtheniswrittenwithfourbytes .basedonthisinformation we identify two memory blocks and where represents a relative base address.
in addition we construct their hierarchicalstructures.thememoryblock isenclosedin .
the identified memory blocks actually correspond to the variablesinsourcecode.forexample and represents arraysptr stuandptr stu .name respectively.thehierarchical structures reflect the enclosing enclosed relationships of variables.
the variable ptr stu .nameis enclosed in ptr stu.
step3.
when multiple memory accesses operate on the same variableintheexecutions e.g.
intheunrolledloop corresponding recovered memory layouts should be merged.
for example the memory layouts l2andl3in fig.
c represent the same variable we merge them into a more complete memory layout lp as shown in fig.
d which reflects not only the variable ptr stu .func but alsoptr stu .name.
step4.withabovethreesteps werecovermemorylayoutsof variables.
to locate vulnerabilities we need to determine whether therecoveredmemorylayoutinfailedexecutionexceedsitsvalid boundaries.withthememorylayoutsrecoveredinpassedexecutions as reference we locate buffer overflows in failed execution by memory layout identification and comparison.
for example we recoverapassedmemorylayout i.e.
test andafailedmemorylayout i.e.
test asshownin lpandlfoffig.
d .bymemory layout identification memory blocks in lpand inlfare compared and i.e.
ptr stu .func inlfis consideredto be overflowed as showninfig.
e .
the proposed approach can help users in two scenarios onewantstodisassembleordebugthebinaryprogram.withthe recoveredfine grainedmemorylayoutsasdebugsymbols he she caninterpretsomekeydatastructures.
onehasabinaryprogram crashed andhe shewantstofigureoutwhetherthecrashisdue to buffer overflow and its root causes.
given the failed crashed execution togetherwithasetofpassedexecutions ourapproach can diagnose whether there is a buffer overflow and its root causes.
memorylayoutrecovery we first formalize a memory addressing model and then introduce the memory layoutrecovery basedonmemory addressing model.
.
memoryaddressingmodel beforea variableis accessed itsmemory addressneedsto bedeterminedfirst.inbinarycode thereareusuallytwoaddressingmodes for memory access direct and indirect addressing .
in direct addressing the address is encoded in the instruction itself usually usedto access ascalar variable.
theindirectaddressingmodeistypicallyusedtoaccessanarrayoradatastructure.generally theaddressiscomputedbyan equation address base index scale offset whereindexrepresentstheindexofanarray scaleisthesizeofunitelementinthe array and offsetimpliestheoffsetcalculationforthememberofa data structure.
theequationforindirectaddressingdependsonthehierarchical structureofavariable.forexample adatastructuremaycontain an array as its member or the element of an array can be a data structure.
hence there could be more than one index scaleand offset.a more generalequation is address base n summationdisplay i indexi scalei offset ingeneral offsetmaybeanoptimizedvalueduetothecompilation i.e.
offset summationtextn i 1offseti where each offseticorresponds to one indexi scaleiandoffseti .theaddressingequation isthe key insightfor recoveringmemory layoutsof variables inthis paper.
example1.
considerptr stu .name infig.
a thememoryaddressiscalculatedby base offset1 index1 scale1 offset2 index2 scale2 wherebase ptris the base address offset1 0istheoffsetof stuindatastructure ptr index1 scale1 calculates the address of the index1thelement of stu offset2 istheoffsetof nameindatastructure stu index2 scale2 calculatesthe addressofthe index2thelement of name.
.
definition ofmemorylayout definition1.
amemoryblock misatuple m m tildewidem where m isthestartaddressand m istheendaddress.ifitrepresentsan array tildewidemisthesizeofitsunitelement otherwise tildewidemiszero.weuse mto denote thesizeof m. definition .
a memory layout l m m e is a directed acyclic graph dag where mis the root memory block mis a set of 406esec fse2019 30august tallinn estonia haijun wang xiaofeixie shang wei lin yun lin yuekang li shengchaoqin yang liu andting liu 464memory blocks and e m mis a set of directed edges connecting memoryblocks suchthat m1 m2 eifm m m m .
definition3.
giventwomemoryblocks m1andm2 ifm1and m2represent the same variable they are the aliasmemory blocks if thevariable representedby m1is enclosed inthatrepresentedby m2 thenm1is aninnermemoryblockof m2.
specifically adirectededge m1 m2 inmemorylayout lrepresents thatm2istheinnermemoryblockof m1.amemorylayoutactually reflectsthestatichierarchicaldatastructureofavariable i.e.
the enclosing enclosedrelationship .
theorem .
given two memory blocks m1andm2 if they are intersected i.e.
m m m m and0 tildewiderm2 tildewiderm1istrue m2 is thealias orinnermemoryblockof m1.
theorem .
given two memory blocks m1andm2 if they are intersected i.e.
m m m m and0 tildewiderm2 tildewiderm1 m2 tildewiderm1 is true m2is thealias memoryblockof m1.
theorems and present two basic approaches to determine therelationshipbetweentwomemoryblocks.theirdetailedproofs can be foundinthe website .
.
memorylayoutrecoveryon single memoryaccess memorylayoutsarerecoveredbasedonmemoryaddressingmodel.
forthedirectaddressing therecoveredmemorylayoutcontains only one memory block m i.e.
the accessed memory block and its unit element size is zero i.e.
tildewidem .
for the indirect addressing the memory layout is recovered based on the following four steps .
.
identifying relevant instructions.
we first identify the relevant instructions which compute the address for the memory access.
to achieve this goal we perform a backward taint analysis inwhichthememoryaccessinstructionisregardedasthe sink.different from traditional taint analysis we only propagate the taints among the registers not including registers espandebp since the memory address is computed by registers .
for example infig.
b line m6isamemoryaccessinstruction.basedonthe taintpropagationamongregisters wecontinuetoidentifylines m1 m5.
at lines m1andm2 we stop the taint propagation as their source operands are memory not registers.
as a result the identifiedaddressing instructionsare lines m1 m6.
.
.
recoveringaddressingequation.
afteridentifyingrelevant instructions werecovertheaddressingequation basedontheaddresscalculationinidentifiedinstructions intheformofequation1.
for example we identify instructions lines m1 m6 in fig.
b whereline m6isamemoryaccessinstruction.atline m1 itstores theaddresspointedby ptrtoregister eax whichisthebaseaddress.
atlinem2 itstoresthevalueofvariable atoregister edx whichis index1.then index1ismultipliedby16atline m3 andthus scale1 is16.atline m4 itaddsindex1 scale1tothebaseaddress.atline m5 itaddsoffset i.e.
0xc tocomputethememoryaddress.thus the recoveredaddressing equation is eax edx .
.
.
optimizing addressing equation.
the addressing equation is optimized as follows sorting ntermsindexi scaleibasedalgorithm1 generatelayout input address base summationtextn i indexi scalei offset output amemory layout l m m e 1letoffset summationtextn ixi wherexirepresents offsetiandxi 2start base 3end address sizeof accessed memory 4if i n indexi scalei 0then 5m e 6fori ndo start start xi mi start end scalei m m mi ifi 2then e e mi mi start start indexi scalei 13m m1 14else 15m start end 16m m e 17returnl on the descending order of scaleifori ... n .
merging some terms of indexi scaleiif possible.
for two adjacent terms indexi scaleiandindexi scalei i n ifscalei indexi scalei they are merged into one term index scale wherescale gcd scalei scalei i.e.
greatestcommondivisor andindex indexi scalei indexi scalei scale.
in fact these two terms are used together to access the same array.
the detailed explanation can be found in the website .
for example the equation for array access inta is recovered as base p sizeof int q sizeof int wherep sizeof int andq sizeof int are used together to access an array.
hence they should be merged.
.
.
recoveringmemorylayout.
basedontheoptimizedaddressingequation werecoverthememorylayoutinalgorithm1.ittakes the addressing equation as input and outputs a recovered memory layout.
as described in section .
offsetin the equation may be an optimized value.
thus at line we introduce the parameter xi torepresenteachpossible offseti.werecoverthememorylayout based on two cases if every indexi scaleiin the equation is greater than or equal to zero the memory layout can be recovered normally lines4 13 .weiterativelyidentifythememoryblocks and construct their hierarchical structure lines 6 12 .
in this loop we first compute the start address of a memory block by adding the offset xi line .
then we recover this memory block miat line8 anditsunitsizeis scalei.atline11 weaddadirectededge mi mi .last wecalculatetheaddressofthe indexithelement andcontinuetorecoverthenextmemoryblock line12 .
ifthere is anindexi scaleithat is negative i.e.
indexiis negative it may be used to access an array with other indexj scalejtogether.
for example in ptr stu .name i.e.
indexi isused to access array namewith num i.e.
indexj together.
however we cannot determine whether aor numis used to access an array together.
in this case we adopt a conservative strategy to only recover the largestmemory block line .
522locatingvulnerabilities in binaries via memorylayoutrecovering esec fse2019 30august tallinn estonia 580example .
in fig.
a we assume that the address pointed bypointer ptris0andthevalueofvariable ais1.basedonlines m1 m6infig.
b wecanrecoveranequation .weuse x1andx2torepresenttheoptimizedoffsets i.e.
x1 x2 .based online8ofalgorithm1 amemoryblock x1 isidentified.
hence we recover a memory layout as l2in fig.
c .
for lines q1 q10 werecoveranequation .since index3 scale3 i.e.
is negative we only recover the largest memory block asl4infig.
c .
.
memorylayoutrecoveryon multiple memoryaccesses whenmultiplememoryaccessesoperateonthesamevariable e.g.
in the unrolled loop corresponding recovered memory layouts should be merged to generate a more complete one.
notice that multiple memory accessescould happeninthe same ordifferent executions.itisnon trivialto inferwhichmemory layoutscan be mergedbecausetheirconcretememoryaddressescannotbeusedas a uniqueidentification.
hence we first index the memorylayouts to make their memory addresses in a relative coordinate system so that we can determinewhether they can be merged.
.
.
indexingmemorylayout.
assumethattheaddressspaceofa program consistsofseveralnon overlappingmemory regions stack heap andglobal whichcorrespondtofunctions heapallocationstatementsandglobal staticvariables respectively.specifically each function has a memory region i.e.
its stack frame one heap allocationstatementhasamemory region thedatasectionis a memory region including global static variables.
hence the concretememoryaddresscanbeindexedbyapair memory region offset .
the indexing processisdescribedas follows for variable awhich is a local variable in a function f stack memory we index its memory address by the pair f a fp wherefrepresents the memory region associated with f ais the concrete memory address of a andfpis the frame pointer of f e.g.
register ebp .
for variable awhich is an enclosed variable e.g.
the member of a data structure in heap memory allocated at statement s we indexitsmemoryaddressbythepair s a ptr s wheresrepresents the memory regionassociated withthe heap allocation statement s ais the concrete memory address of a andptr s isthe baseaddressofmemory allocatedat statement s. for variable awhich is a global static variable in global memory we index its memory address by the pair a ds where is thememoryregion associatedwithdatasection oftendenoted .datain binary code ais the concrete memory address of a anddsisthe baseaddressofdata section.
afterindexing theaddressesofmemorylayoutsareinthesame coordinate i.e.
they are relative to the beginning of a memoryregion.hence we can merge the memory layouts.
.
.
mergingmemorylayouts.
giventwomemorylayouts l1and l2 wemergethembasedontwocases asshowninalgorithm2.
the first case is that their root memory blocks m1andm2are intersected line .
we first merge the root memory blocks of l1andl2bymergeblock i.e.
algorithm3 andconstructanew memorylayout l .then wecontinuetomergethechildrenof l algorithm2 mergelayout input memory layouts l1 m1 m1 e1 andl2 m2 m2 e2 output merged memory layout l m m e 1ifm m m m 2then 2l mergeblock l1 l2 3l updatelayout l 4returnl 5else return nil algorithm3 mergeblock input memory layouts l1 m1 m1 e1 andl2 m2 m2 e2 output merged memory layout l m m e 1if0 tildewiderm1 tildewiderm2thenswap l1 l2 m m e m1 m1 m2 e1 e2 m m tildewidem min m m max m m tildewiderm1 4status determinelevel m m2 5ifm2is the inner memory block of m instatusthen 6e e m m2 7else 8foreachmc child m2 do e e m2 mc e e m mc 11m m m2 12if tildewiderm2 0then tildewidem 13returnl byupdatelayout i.e.
algorithm .
the second case is that m1 andm2are not intersected.
they represent different variables and cannot be merged.
next we introduce the merging in the first case.
algorithm3introduceshowtomergerootmemoryblocks m1 andm2ofl1andl2.
at line it makes sure that tildewiderm2 tildewiderm1is true.
thus m2is the alias or inner memory block of m1 c.f.
theorem .
at lines it merges m1andm2as a new memory block m and constructsanewmemorylayout l .then itdetermineswhether m2is the inner memory block of m bydeterminelevel i.e.
algorithm .
if so m2is added as the inner memory block of m line .
otherwise m2andm are alias memory blocks or their relationshipcannotbedetermined.itaddstheinnermemoryblocks i.e.
children of m2as the inner memory blocks of m lines and deletes m2 line .
note that when the relationship between m2andm cannot be determined the algorithm ignores the case thatm2is the inner memory block of m .
as a result it may lose some precision but is still correct.
if the unit size of m2is zero the unitsize of m isupdatedas zero line .
given two memory blocks m1andm2such that tildewiderm2 tildewiderm1 c.f.
algorithm algorithm determines whether m2is the alias or innermemoryblockof m1.atlines1 itdecidesthat m2isthe aliasmemoryblockof m1 c.f.theorem2 .ifitcannotdetermine m2isthealiasmemoryblockof m1 weconsidertheinnermemory blockmcofm1at lines .
it first checks whether m2andmc areintersected line6 .then itcheckswhether tildewiderm2 tildewidermcistrue line .
if so m2is the alias or inner memory layout of mc c.f.
theorem1 .basedontransitivity m2istheinnerblockof m1.at line10 itcheckswhether m2isthealiasblockof mc c.f.theorem2 .
if so m2isalsothe innerblockof m1basedontransitivity.
638esec fse2019 30august tallinn estonia haijun wang xiaofeixie shang wei lin yun lin yuekang li shengchaoqin yang liu andting liu 696algorithm4 determinelevel input memory blocks m1andm2 output determining relationshipbetween m1andm2 1if tildewiderm1 nequal0and tildewiderm2 nequal0then 2if m2 tildewiderm1then returnm2is aliasmemory block of m1 4else foreachmc child m1 do ifm c m 2andm c m 2then if tildewiderm2 tildewidestmcthen returnm2is inner memory block of m1 else if mc tildewiderm2then returnm2is inner block of m1 12returnitis unknown algorithm5 updatelayout input memory layout l m m e output updated memory layout l m m e 1l l 2letqbean empty queue 3q.enqueue m 4whileqis notempty do 5mq q.dequeue 6foreach m1 m2 s.t.m1 m2 child mq do letl1 m1 m1 e1 andl2 m2 m2 e2 betwosub layoutsof l whoserootsare m1andm2 ifm m 2andm m 2then l3 m3 m3 e3 mergeblock l1 l2 m m m1 m2 m3 e e e1 e2 e3 e e mq m1 mq m2 mq m3 l updatelayout l returnl 15foreachmc child mq do q.enqueue mc 17returnl .
.
update memory layout.
algorithm iteratively merges submemorylayoutsbyaqueue q.theinputisamemorylayout land the outputis anupdated one l .
for the memory block mq itfirst identifiestwosub memorylayouts l1andl2 line6 .iftheirroot memoryblocks m1andm2areintersected line8 wemergethem toconstructanewmemorylayout l3bymergeblock line9 .at lines10 itreplaces l1andl2withl3.sincethememorylayout is updated we continue to update l byupdatelayout line .
if sub memory layouts of mqcannot be merged it adds children ofmqintoq lines and continues to merge the children iteratively.
if there is no merging between any two sub memory layouts the algorithm terminates.
example .
fig.
shows the process of merging two memory layouts whichcorrespondto l2andl3infig.
c .wecaninferthat m1 x1 andm2 are intersected where x1 tildewiderm1 tildewiderm2 and m2 .
based on lines in algorithm m1 x m2 m3 m m3 l2 l3 lpfigure example to illustratemerging memory layouts.
we know m1andm2are the aliasmemoryblocks.hence theyare merged as m andm3is added as the inner memory blockofm .
.
.
merging for pointer arithmetics.
the pointer arithmetic generallyyieldsanewpointerthatstillpointsthesamememoryallocation .multiplememoryaccessesbydereferencingthesepointers canleadtomanymemorylayouts whichcannotbemergedwith algorithm because they are not intersected .
however these memory layouts belong to the same memory allocation and should be merged together.
to improve the precision we merge them togetheras follows given such two memory layouts l1 m1 m1 e1 andl2 m2 m2 e2 they are merged into a new memory layout l3 m3 m3 e3 wherem3 min m m max m m m3 m1 m2 m3 ande3 e1 e2 m3 m1 m3 m2 .
example .
in fig.
b lines l1 l3are executed four times in the unrolled loop and we recover four memory layouts which cannotbemergedwithalgorithm2.duetothepointerarithmetics thesefourmemory layoutsare then mergedas l1infig.
c .
.
discussion ofspecial cases based on the memory addressing model our approach can recover memorylayoutsofvariablesgenerally.inthissection wediscuss specialcasesduringmemory layoutrecovery.
address space layout randomization.
addressspacelayout randomization aslr is a memory protection technique by randomizingthelocationsofmodulesandcertaindata .current aslr techniques usually randomize the base address of a memory region e.g.
stackframe .inthiscase itdoesnotaffectourmemory layout indexing c.f.
section .
.
and our approach can still work.
memory allocation alloca.the function allocaallocates the memory in the stack.
in our approach the stack memory allocated byallocaistreatedas the heapmemory allocation.
differentmemorylayoutsinoneallocationstatement.
the layouts of memory allocated in one allocation statement may be differentindifferentcontexts.forexample if size sizeof structa elsesize sizeof structb ptr malloc size thevariable ptrcanrepresenttwodatastructures i.e.
structaandstructb .forthiscase we associate its context with the allocation statement to index the memory layout.
specifically we adopt the technique in memory indexing whichusescontrolflowstructuretoindexallocation point as the contextofallocation statement.
data structure union.aunioncan hold only one of its data members at a time.
in multiple accesses of a union it may hold differentmembers.thus ourapproachmaymergedifferentmembers.
if different members have different unit sizes we only recover the maximum memory range and discard the internal memory layout.
hence the recovered memory layout is still consistent with the semantics of union.
754locatingvulnerabilities in binaries via memorylayoutrecovering esec fse2019 30august tallinn estonia locating vulnerabilities inthissection weintroducehowtolocatebufferoverflowvulnerabilitiesbyleveragingrecoveredmemory layouts.
.
locating vulnerabilities by leveraging recoveredmemorylayouts abufferoverflowoccurswhendereferencingapointerthatgoes outoftheboundsofitspointedobject.tolocatethebufferoverflow wecollectasetofpassedexecutionsandafailedexecution.with thefine grainedmemorylayoutsrecoveredinpassedexecutions as reference the vulnerable memory layout in failed execution can be identifiedbymemory layoutidentification andcomparison.
it is worth noting that the size of a memory block may not be fixed as we introduce the parameters in algorithm i.e.
xi atline1 .tolocatethebufferoverflow weadoptaconservative strategytodeterminetheirvalues letthesizeofthepassedmemory layout be the maximum and the size of the failed memory layoutbetheminimum.specifically inamemorylayout l m m e the size of each memory block mi mis end base xi indexi scalei xi c.f.
algorithm .
forthe passed memorylayout wemakethesizeofeach mi mmaximum i.e.
i n xi xn offset.
for the failed memory layout wemakethesizeofeach mi mminimum i.e.
x1 offset i n xi .
algorithm shows how to locate the buffer overflow.
it takes a failed memory layout l1and a passed memory layout l2as inputs.
its intuition is as follows for each memory block m 1ofl1 ifm 1is thealiasorinnermemoryblockofsomememoryblock m 2ofl2 andm 1isbeyond m then itisacandidate buffer overflow.
atline5 itcheckswhether tildewidem 1iszero.ifso itcannotdetermine the relationship between m 1andm .
thus it only compares m withtherootmemoryblock m2ofl2.ifm 1is beyond m2 line6 thereisacandidatebufferoverflowin m .atline9 itchecks m 1witheachmemoryblock m 2ofl2.ifm 1isbeyond m line13 the algorithm checks the relationship between m 1andm .
ifm 1is thealiasorinnermemoryblockof m line14 thereisacandidate buffer overflowin m .
notice that for the heap memory whose size is controlled by inputs its memory layout is not fixed with different inputs.
although we recoverthemaximum memoryrangeaftermerging it still cannot be used to locate vulnerabilities.
for example in the statement p malloc input if the maximum value of inputin passedtestcasesis5 werecoveramemoryblockwhosesizeis5 bytes the maximum .
if the value of inputin the failed test case is we recover a memory block whose size is bytes.
comparing thesetwomemoryblocksintroducesafalsepositive.inthiscase wedynamicallyrecordthememoryrangeofallocatedmemory not to index and merge their memory layouts.
to locate vulnerabilities wecheckwhethertheusedmemoryisbeyondtheallocated memory whichisthe same as valgrindmemcheck .
.
falsepositivereduction passedexecutionsmayonlycoverpartialprogrambehaviors.thus thepassedmemorylayoutmayalsobeunder approximated.locating vulnerabilities by comparing failed memory layout with underapproximated memory layout may introduce false positives.
foralgorithm6 comparelayout input memory layouts l1 m1 m1 e1 andl2 m2 m2 e2 output determining the bufferoverflow 1letq1bean empty queue 2q1.enqueue m1 3whileq1is notempty do 4m q1.dequeue 5if tildewidem 0then ifm m m 1orm m m 1then returnfind buffer overflow 8else letq2bean empty queue q2.enqueue m2 whileq2is notempty do m q2.dequeue ifm m m 1orm m m 1then ifm 1is aliasorinner block of m 2then returnfind buffer overflow foreachmc child m do q2.enqueue mc 18foreachmc child m do q1.enqueue mc 20returnnotfind buffer overflow thisproblem wereducefalsepositivesbasedontwoaccompanying phenomena data corruption or abnormal memory address whichincreasethe confidence of our results.
.
.
datadependencemismatch.
bufferoverflowtypicallyincurs data corruption overflowed by another data .
data corruption can lead to data dependence mismatch describing a data dependence that is not supposed to exist in the code.
for example in fig.
a assume that the value of variable bis .
the program executes four times at line .
as a result the value of variable ptr stu .funciscorruptedby ptr stu .name.atline14 it usesptr stu .func.thus thereisadatadependencebetween lines and which does not exist in the code.
hence a data dependencemismatchoccurs.toincreasetheconfidence wereporta buffer overflow vulnerability only if it conducts a data dependence mismatchas well.
toobtaindatadependencerelationsthatdoexistinthecode we usedynamicanalysisasinwork .weexecuteasetofpassed test cases and compute data dependence relations.
similarly we also compute the data dependence relations in the failed execution.
if a data dependence relation only occurs in failed execution but not in any passedexecution there is a datadependence mismatch.
.
.
abnormalmemory address.
when thebuffer isoverflowed toomuch itmayreachanmemoryaddressthatcannotbeaccessed e.g.
unallocatedmemory .thissituationisconsideredasanabnormal memory address access.
usually an abnormal memory access directlyleadstoaprogramcrash.thus ifabufferoverflowleads to an abnormal memory address access it is a true buffer overflow.
870esec fse2019 30august tallinn estonia haijun wang xiaofeixie shang wei lin yun lin yuekang li shengchaoqin yang liu andting liu evaluation we have implemented a prototype tool for our approach and evaluateditseffectiveness.alltheexperimentsareperformedonthe bit linux system with .
ghz intel xeon e5 cpu and gb ram.sinceourmemoryaddressingmodelisgeneral ourapproach can be easily extendedto bitsystem.
.
experiment setup we selected binary programs from the benchmarks of darpa s cgc whichisacompetitiontoautomaticallydetectvulnerabilities.
instead of contrived simple situations they approximate real vulnerabilities with enough complexities and diversities ideal for evaluating our approach .
however not all programs are selectedbecause theyrununderdarpadecree whileourtool runs on the linux system.
although the team trailofbits has migratedthemintolinuxsystem notallofthemarereproducible weonlyconsiderthebufferoverflow theprogramswithother types e.g.
nullpointerdereferenceanduseafterfree areoutofour consideration.inaddition weselectedfourbinaryprograms objdump readelf ldandc filtfrombinutils about 690k loc which arewidelyusedinfuzzingsystem andonebinaryprogram tiff2bwfromlibtiff about 100k loc .
in these five programs we generated453programcrashes whichconstitutereal worldbenchmarks.the25cgcprogramsshowthediversitiesofvulnerabilities andthe5real worldprogramsshowthescalabilityofourapproach.
.
experiment design intheexperiments weusethefuzzingsystem togeneratethe passed test cases2and use the dynamic binary analysis framework pin tocollectthedynamicexecutioninformation.ingeneral afl generates a large number of passed test cases with different code coverage.
for efficiency we select the passed test cases by adopting additionalcoveragestrategy .itselectsthenextpassed testcase whichcoversmorecodesthatarecoveredbythefailed test case but not covered by already selected passed test cases until vulnerabilities are located.
due to the lack of ground truth inourexperiments wemanuallyvalidatetheresults.intotal we manually check program crashes in programs and their recoveredmemory layouts.
.
experimentalresults we evaluated the effectiveness of our approach in three aspects recovering memory layouts locating vulnerabilities and triaging program crashes.
.
.
recovering memory layout.
table shows the experimental results on recovering memory layouts.
column namelists the programnames.incolumn passedinputs theheading totalliststhe total number of generatedpassed test cases and selectshows the numberofselectedpassedtestcases.thedetails ofgeneration selectionofpassedtestcasescanrefertosection5.
.column trace lengthlists the number of instructions in the execution where passedand failedrepresent the average numbers of instructions inselectedpassedexecutionsandfailedexecution respectively.
2there could be a situation where a passed execution accesses a memory location beyond the boundary but does not lead to any crash.
this would not produce false positives not misleading analyst to wrong investigation.
see for moredetails.sinceaprogrammaycontainmorethanonevulnerablememory layout in column vulnerable memory layout the heading no.lists each of them.
for example there are three vulnerable memory layoutsinthe program stack vm .
theheading statusshowsthestatusof recoveredpassedmemory layout which isusedfor comparisonto identifythe vulnerable memorylayout.itindicateswhetherthepassedmemorylayoutrepresents the hierarchical structure of variables where undermeans thatweunder approximatelyrecoverthememorylayout and completemeansthatwerecoveritscompletememorylayouts.notice that we got a large number of passed memory layouts recovered in passed executions.
we manually check and report only of them columnstatus because the numberofrecovered memory layouts is too large to manually check all these memory layouts are compared to identify vulnerable memory layouts andwe need to checkits status under approximatedorcomplete .
summary.
among thereported36 passedmemorylayouts memory layouts are completely recovered i.e.
the recovered static hierarchical data structures for variables are the same with their static hierarchical data structures in source code and are underapproximatelyrecovered e.g.
someinternaldatastructuresofvariables are not recovered .
memory layouts are under approximately recoveredbecausesomeelementsofarrayormembersofdatastructurearenotaccessedindynamicexecutioninformation.thatis our approachachieves100 successratetorecovermemorylayouts that are covered in dynamic execution information.
despite the under approximatememorylayoutrecovery theyarestilluseful to locate buffer overflow vulnerabilities which is shown in the following experiments.
.
.
locating vulnerabilities.
table also shows the results of locatingbufferoverflowvulnerabilities.therearemultipletypesof bufferoverflowvulnerabilitiesintheprograms asshownincolumn type.thesymbols stack heap globalrepresentstack heap and globalbufferoverflow respectively.inaddition weconsideranother specialtypeofbufferoverflow overflowwithinadatastructure as indicatedby internal.inbinarycode valgrindmemcheck cannot locatebufferoverflowswithinstack globalmemoryregions and data structures .
valgrind s extension sgcheck tries to locate stackbufferoverflows however itstill needsdebuginformation.
even in sourcecode addresssanitizer cannot detect thebuffer overflowwithin the data structures as well.
columnbuffer overflow shows whether the vulnerable memory layouts are the root causes of crash.
since one vulnerable memory layoutmaybeoverflowedatdifferentinstructions theheading ins representsthenumberofinstructionsproducingbufferoverflowsin vulnerable memory layouts.
the heading rootshows whether it is a real buffer overflow.
our approach may report false positives.
to reduce them we adopt two strategies data dependence mismatch denotedbym andabnormalmemoryaddress denotedbya in the column plusaccompanying .
after our investigation we found that the false positives are generated in two cases some instructions do lead to the buffer overflow but do not lead to the crash.
for example in the programsample shipgame there are instructions leading to a buffer overflow.
however one is assigned with and it is not the root causeofcrash.thiscanbeeliminatedbyourstrategies andthus 986locatingvulnerabilities in binaries via memorylayoutrecovering esec fse2019 30august tallinn estonia 1044table experimentalresults on programs fromdarpa scybergrand challenge name typepassed inputs trace lengthvulnerablebufferoverflow plusaccompanying time s memory layout total select passed failed no.
status ins root mismatch abnormal ins root select locate sample shipgame stack under m valvechecks stack under 6 complete m a bloomy sunday stack complete m a the longest road stack under m a thermal controller v2 stack under m xstore stack under 163 under m a casino games stack under m a palindrom stack complete m cablegrind stack under m a stack vm heap under under a complete m street map service heap complete m humaninterface heap complete m ais lite heap under 203 complete m matrices for sale heap complete a cotton swab arithmetic heap complete a lms heap complete m budgit heap under 123 complete a pkk steganography heap complete a ascii content serve heap complete a electronictrading internal under m internal under scuba dive logging under under m internal under 432cgc planet mark under language parser under under square rabbit global complete a taintedlove global under a stream vm global complete a total avg.
.
.
.
thenumberofinstructionsisreducedfrom2 insinbufferoverflow to1 insinplusaccompanying .
someinstructionsindeed do not produce the buffer overflow.
for example in the program cgc planet mark language parser allthefalsepositivesarereduced insinplusaccompanying .
since our approach requires passed and failed executions its effectiveness depends on the testcases.
for example in program cgc planet markup language parser our approach fails to locate buffer overflow vulnerabilities.
this is because the program contains many specialchecks in the markup language parser and afl does not generate passed test cases to cover the data structure overflowed i.e.
struct city .sinceour approach does notrecover the memory layoutofstruct cityinpassed executions we fails to locate its buffer overflowinfailedexecution.
columntimeshowsthetimeoverhead.theheading selectshows the time for selecting passed test cases while locatefor locating bufferoverflowvulnerabilities includingrecoveringmemorylayouts computing data dependencies andlocating vulnerabilities .
summary.
ourexperimentalprogramsinclude4typesofvulnerabilities column type stack buffer overflows heap buffer overflows internal data structure overflows global memory bufferoverflows whichshowthediversityofvulnerabilities.fortable triageprogram crash on five real world programs nametestcases tracelengthafl our approach passed failed passed failed objdump .
readelf .
ld .
c filt .
tiff2bw .
.
each vulnerable memory layout we locate .
instructions on average.
in the beginning we reports true positives and false positives rootinbuffer overflow .
after applying the proposed eliminationstrategies 25errorsareconfirmed andallof11false positives are eliminated rootinplus accompanying .
the average time for selecting passed test cases and locating vulnerabilities are 221and225seconds.theresultsshowthatourapproachiseffective to locate buffer overflowvulnerabilities.
.
.
triageprogramcrashes.
asdescribedinsection1 triaging program crashes is very important in the program analysis and debugging.intheexperiments weusethefuzzingsystemtogenerate a number of program crashes many of which are caused by the same vulnerability but afl is not able to distinguish them.
our 1102esec fse2019 30august tallinn estonia haijun wang xiaofeixie shang wei lin yun lin yuekang li shengchaoqin yang liu andting liu 1160approach can help to triage program crashes based on the root causes ofvulnerabilities.
since multiple instructions may lead to the same vulnerable memory layout e.g.
insinbuffer overflow we decided to use a more coarse grained granularity i.e.
we use functions where blamed instructions reside as blamed functions.
thus in our experiment we identify the root causes based on vulnerable memory layoutsandblamedfunctions .
table shows the results of five real world programs with total program crashes.
column nameshows the program name.
columntest cases lists the number of test cases where passed and failedrepresent the number of passed and failed test cases respectively.
column trace length lists the average number of instructionsintheexecution.thelasttwocolumnsshowtheresults oftriaging program crashes.
summary.
columnafllists the number of unique program crashestriagedbyafl.column ourapproach showstriagingresults of our approach where the first number is the number of groups and the numbers in the brackets represent the number of crashes in each group.
for example represents crashes are classified into groups which include and crashes respectively.wemanuallycheckthecrashesforallgroups andconfirmthatourtriagingresultsarecorrect.comparedtoafl ourapproachhelpstoreducethenumberofuniqueprogramcrashes significantly.thus itcansavemanualresourcesforanalyzingthem.
there are crashes that are not grouped in program ld .
as ourapproachfailsto locatetheirvulnerabilities.
we lookclosely into this program and these crashes are due to the null pointer dereference whichisoutofthe scope ofthis work.
related work .
reverse engineering reverseengineeringofdatastructuresisanactiveareainbinary code analysis .
thomas and gogul also proposed an approachtorecovermemory ranges of variablesinbinary code.
its maindifferencefromoursisthattheyrecovermemoryinformation using static analysis value set analysis while we use dynamic execution information.
our results are under approximated and theirs are over approximated.
our under approximated memory layoutintroduceslessfalsenegativesandfalsepositivesinlocating buffer overflow vulnerabilities.
built on the work brumley et al.developed tie which recovers the memory information ofdatastructuresandtheirtypes.tiehasthesamelimitationsas work when usedfor locating buffer overflowvulnerabilities.
linetal.proposedrewards thereverseengineeringofdata structures using dynamic analysis.
it infers the types of data structures basedon arguments ofwell knownfunctions e.g.
asystem call .however ourapproachrecoversmemorylayoutsbasedonthe memoryaddressingmodel.hence rewardsonlyrecoversasmall portionofdatastructures andourapproachismoregeneral for data structures.
slowinska et al.developed howard which is the closest worktoours.however therearestilltwomaindifferences.thefirst isthathowardmaymissinternallayoutsofdatastructuresinsome cases even they are accessed in the execution.
howard onlyrecords a base pointer for each memory access.
it may miss the internallayoutsinthecasewherememoryaddressiscomputedbased onmultiplebaseaddresses.takethememoryaccessatline12in fig2forexample howardconsidersitsbasepointeris ptr.however itsmemoryaddressiscomputedbasedon ptr stuandname.
hence howard misses the internal layouts.
thesecond difference is that howard detects arrays which are accessed in loops while ourapproachcanrecoverarraysgenerallybasedonthememory addressingmodel.thus ourapproachismoregeneraltorecover the fine grainedlayoutsof data structures.
.
locating vulnerabilities sourcecodeanalysis.
therehasbeenlotsofworkaimingatlocatingvulnerabilitiesinsourcecode e.g.
.addresssanitizer is a widely used tool inpractice.
it instruments aprogram inserts undefined memory i.e.
redzones between the objects and detects an access to the undefined memory.
diehard and its successor dieharder populate newly allocated memory and freed memorywithmagicvalues.theyalsoaddredzonesaroundtheallocated memoryregiontodetectthespatialerrors.thetoolssoftbound cets and lowfat keep track of per pointer capability andcheckscapability when accessingan object.
althoughthesetechniquescanalsolocatebufferoverflows they are applicable to different scenarios i.e.
source code vs.binary code .sincethesourcecode isnotalwaysavailable ourapproach isapplicabletomorescenarios.inaddition somesourcecodebased techniquesdonotrecognizetheinternalstructuresofdatastructures such as addresssanitizer.
hence they cannot locate internal overflow within a data structure.
since our approach recovers finegrainedmemory layouts of variables this is not anissue anymore.
binarycodeanalysis.
locatingvulnerabilitiesinbinarycode has also been widely studied .
valgrind memchecks usesthe validvaluebitand addressbitin shadowmemorytocapture reading undefined memory and out of bounds access.
besides valgrind s extension sgcheck also wants to locate stack buffer overflows however itstillneedsthehelpofdebuginformation.dr.
memory is similar to valgrind memchecks in many ways.
it is further equipped with a multi threaded binary translation system.
purify shadowseverybyteofmemorywithatwo bitvaluethat encodesone ofthree states unaddressable writable andreadable.
these techniques locate heap buffer overflow without false positives whichisachievedbyourapproachaswell.duetothelackof programsemanticsinbinarycode itisverydifficulttoidentifythe boundaries of variables in stack and global memory regions.
thus noneofthesetechniquescanlocatebufferoverflowwithinthestack and globalmemory regions .
to the best of our knowledge our approach isthe firstwork to achieve this goalinbinary code.
conclusion in this work we propose an approach to locate buffer overflows in binarycode.wefirstrecoversthememorylayoutsbasedonmemory addressing model together with dynamic execution information.
then based on the recovered memory layouts we locate buffer overflowvulnerabilities.
1218locatingvulnerabilities in binaries via memorylayoutrecovering esec fse2019 30august tallinn estonia 1276references k. serebryany d. bruening a. potapenko and d. vyukov addresssanitizer a fast address sanity checker.
in usenix annual technical conference pp.
309 318. s. nagarakatte j. zhao m. m. martin and s. zdancewic softbound highly compatible and complete spatial memory safety for c acm sigplan notices vol.
no.
pp.
245 258 .
n.nethercoteandj.seward valgrind aframeworkforheavyweightdynamic binary instrumentation in acm sigplan notices vol.
no.
.
acm pp.
89 100. s.nagarakatte j.zhao m.m.martin ands.zdancewic cets compilerenforced temporal safety for c in acm sigplan notices vol.
no.
.
acm pp.
31 40. x. meng and b. p. miller binary code is not easy in proceedings of the 25th international symposium on software testing and analysis .
acm pp.
24 35. w. cui m. peinado s. k. cha y. fratantonio and v. p. kemerlis retracer triagingcrashesbyreverseexecutionfrompartialmemorydumps in proceedings of the 38th international conference on software engineering .
acm pp.
820 831. afl american fuzzylop.
c. lemieux r. padhye k. sen and d. song perffuzz automatically generatingpathologicalinputs in proceedingsofthe27thacmsigsoftinternational symposiumonsoftwaretestingand analysis .
acm pp.
254 265. c. lemieux and k. sen fairfuzz a targeted mutation strategy for increasing greybox fuzztestingcoverage in proceedings ofthe33rdacm ieee international conference onautomatedsoftwareengineering .
acm pp.
475 485. m. b hme v. t. pham m. d. nguyen and a. roychoudhury directed greybox fuzzing in proceedings of the acm sigsac conference on computer and communications security .
acm pp.
2329 2344. m. b hme v. t. pham and a. roychoudhury coverage based greybox fuzzing asmarkovchain in proceedingsofthe2016acmsigsacconferenceoncomputer and communications security .
acm pp.
1032 1043. g.balakrishnanandt.reps analyzingmemoryaccessesinx86executables ininternationalconference oncompiler construction .
springer pp.
5 23. j.lee t.avgerinos andd.brumley tie principledreverseengineeringoftypes in binaryprograms 2011. z.lin x.zhang andd.xu automaticreverseengineeringofdatastructures from binary execution in proceedings of the 11th annual information security symposium .
cerias purdue university p. .
a.slowinska t.stancescu andh.bos howard adynamicexcavatorforreverse engineeringdatastructures.
in proceedingsofthenetworkanddistributedsystem securitysymposium year organization citeseer .
bodyarmorforbinaries preventingbufferoverflowswithoutrecompilation.
inusenixannual technicalconference pp.
125 137. proof j.devietti c.blundell m.m.martin ands.zdancewic hardbound architectural support for spatial safety of the c programming language acm sigarch computer architecturenews vol.
no.
pp.
103 114 .
w.n.sumnerandx.zhang memoryindexing canonicalizingaddressesacross executions in proceedings of the eighteenth acm sigsoft international symposium onfoundationsofsoftwareengineering .
acm pp.
217 226. j. seo b. lee s. m. kim m. w. shih i. shin d. han and t. kim sgx shield enablingaddressspacelayoutrandomizationforsgxprograms.
in proceedings ofthe network and distributedsystemsecuritysymposium .
y.chen m.khandaker andz.wang pinpointingvulnerabilities in proceedings ofthe2017acmonasiaconferenceoncomputerandcommunicationssecurity .
acm pp.
334 345. darpa cyber grand challenge repository.
y.li b.chen m.chandramohan s. w.lin y.liu anda.tiu steelix programstate based binary fuzzing in proceedings of the 11th joint meeting on foundationsofsoftwareengineering .
acm pp.
627 637. c. k. luk r. cohn r. muth h. patil a. klauser g. lowney s. wallace v. j. reddi and k. hazelwood pin building customized program analysis tools with dynamic instrumentation in acm sigplan notices vol.
no.
.
acm pp.
190 200. y. lu y. lou s. cheng l. zhang d. hao y. zhou and l. zhang how does regression test prioritization perform in real world software evolution?
in ieee acm38thinternationalconferenceonsoftwareengineering .
ieee pp.
535 546. d.hao l.zhang l.zang y.wang x.wu and t.xie to beoptimalornotin test case prioritization ieee transactions on software engineering vol.
no.
pp.
490 505 .
l.zhang d.hao l.zhang g.rothermel andh.mei bridgingthegapbetween thetotalandadditionaltest caseprioritizationstrategies in proceedingsofthe international conference on software engineering .
ieee press pp.192 201. s. a. khalek ands.
khurshid efficientlyrunning testsuites using abstractundo operations in 2011ieee22ndinternationalsymposiumonsoftwarereliability engineering .
ieee pp.
110 119. w. masri and f. a. zaraket coverage based software testing beyond basic test requirements in advancesincomputers .
elsevier vol.
pp.
79 142. a. filieri c. s. p s reanu and w. visser reliability analysis in symbolic pathfinder in 201335thinternationalconferenceonsoftwareengineering .
ieee pp.
622 631. s.person g. yang n. rungta and s.khurshid directed incremental symbolic execution in acm sigplannotices vol.
no.
.
acm pp.
504 515. j. h. siddiqui and s. khurshid staged symbolic execution in proceedings of the 27thannualacmsymposiumonappliedcomputing .
acm pp.1339 1346. y. li z. su l. wang and x. li steering symbolic execution to less traveled paths in acmsigplannotices vol.
no.
.
acm pp.
19 32. t. xie n. tillmann j. de halleux and w. schulte fitness guided path exploration indynamic symbolicexecution in ieee ifipinternationalconferenceon dependablesystems networks .
citeseer pp.
359 368. b.c.parrino j.p.galeotti d.garbervetsky andm.f.frias tacoflow optimizing satprogramverificationusingdataflowanalysis software systemsmodeling vol.
no.
pp.
45 63 .
c.cadar d.dunbar d.r.engler etal.
klee unassistedandautomaticgeneration of high coverage tests for complex systems programs.
in usenix symposium on operatingsystemsdesignand implementation vol.
pp.
209 224. w. visser c. s. pasareanu and s. khurshid test input generation with java pathfinder acm sigsoft software engineering notes vol.
no.
pp.
97 107 .
s.anand c.s.p s reanu andw.visser jpf se asymbolicexecutionextension to java pathfinder in international conference on tools and algorithms for the construction and analysisofsystems .
springer pp.
134 138. g.balakrishnanandt.reps divine discoveringvariablesinexecutables in internationalworkshoponverification modelchecking andabstractinterpretation .
springer pp.
1 28. a. cozzie f. stratton h. xue and s. t. king digging for data structures.
in usenixsymposiumonoperatingsystemsdesignandimplementation vol.
pp.
255 266. e. dolgova and a. chernov automatic reconstruction of data types in the decompilation problem programming and computer software vol.
no.
pp.
105 119 .
x. chen a. slowinska d. andriesse h. bos and c. giuffrida stackarmor comprehensive protection from stack based memory error vulnerabilities for binaries.
in proceedingsofthenetworkanddistributedsystemsecuritysymposium .
citeseer .
v.braberman d.garbervetsky s.hym ands.yovine summary basedinference ofquantitativeboundsofliveheapobjects scienceofcomputerprogramming vol.
pp.
56 84 .
j.a.jonesandm.j.harrold empiricalevaluationofthetarantulaautomatic fault localizationtechnique in proceedingsofthe20thieee acminternational conference onautomatedsoftwareengineering .
acm pp.
273 282. d.hao t.xie l.zhang x.wang j.sun andh.mei testinputreductionfor result inspection to facilitate fault localization automated software engineering vol.
no.
p. .
j.clauseanda.orso leakpoint pinpointingthecausesofmemoryleaks in proceedings of the 32nd acm ieee international conference on software engineering .
acm pp.
515 524. r. santelices j. a. jones y. yu and m. j. harrold lightweight fault localization usingmultiplecoveragetypes in proceedingsofthe31stinternationalconference onsoftwareengineering .
ieee computer society pp.
56 66. g. k. baah a. podgurski and m. j. harrold causal inference for statistical fault localization in proceedings of the 19th international symposium on software testingand analysis .
acm pp.
73 84. b.liblit m.naik a.x.zheng a.aiken andm.i.jordan scalablestatisticalbug isolation in proceedingsof programminglanguagedesign andimplementation pp.
15 26. f.keller l.grunske s.heiden a.filieri a.vanhoorn andd.lo acriticalevaluation of spectrum based fault localization techniques on a large scale software system in 2017ieeeinternationalconferenceonsoftwarequality reliabilityand security.
ieee pp.
114 125. x.li m.damorim anda.orso iterativeuser drivenfaultlocalization in haifa verification conference .
springer pp.
82 98. a. perez r. abreu and m. d amorim prevalence of single fault fixes and its impactonfaultlocalization in 2017ieeeinternationalconferenceonsoftware testing verification and validation .
ieee pp.
12 22. e. d. berger and b. g. zorn diehard probabilistic memory safety for unsafe languages in acm sigplan notices vol.
no.
.
acm pp.
158 168. g. novark and e. d. berger dieharder securing the heap in proceedings of the 17th acm conference on computer and communications security .
acm pp.
573 584.
1334esec fse2019 30august tallinn estonia haijun wang xiaofeixie shang wei lin yun lin yuekang li shengchaoqin yang liu andting liu g. j. duck and r. h. yap heap bounds protection with low fat pointers in proceedingsofthe25thinternationalconferenceoncompilerconstruction .
acm pp.
132 142. g. j. duck r. h. yap and l. cavallaro stack bounds protection with low fat pointers in symposiumonnetwork and distributedsystemsecurity .
d.andriesse x.chen v.vanderveen a. slowinska andh.bos an in depth analysis of disassembly on full scale x86 x64 binaries.
in usenix security symposium pp.
583 600. f.peng z.deng x.zhang d.xu z.lin andz.su x force force executing binary programs for security applications.
in usenix security symposium pp.
829 844. d. bruening and q. zhao practical memory checking with dr. memory in proceedingsofthe9thannualieee acminternationalsymposiumoncodegeneration and optimization .
ieee computer society pp.
213 223. r. hastings and b. joyce purify fast detection of memory leaks and access errors in proceedingsofthe usenixconference .
citeseer .
intel intel inspector.
oracle sun memory error discovery tool.