synergistic debug repair of heap manipulations sahil verma department of electrical engineering indian institute of technology kanpur india vsahil iitk.ac.insubhajit roy department of computer science and engineering indian institute of technology kanpur india subhajit cse.iitk.ac.in abstract we present wolverine an integrated debug repair environment for heap manipulating programs.
wolverine facilitates stepping through a concrete program execution provides visualizations of the abstract program states as box and arrow diagrams and integrates a novel proof directed repair algorithm to synthesize repair patches.
to provide a seamless environment wolverine supports hot patching of the generated repair patches enabling the programmer to continue the debug session without requiring an abort compile debug cycle.
we also propose new debug repair possibilities specification refinement andspecification slicing made possible by wolverine.
we evaluate our framework on buggy programs generated using fault injection on a variety of data structures like singly doubly and circular linked lists binary search trees avl trees red black trees and splay trees wolverine could repair all the buggy instances within reasonable time less than sec in most cases .
we also evaluate wolverine on buggy student submissions wolverine could repair more than of programs where the student had made a reasonable attempt.
ccs concepts software and its engineering software testing and debugging formal software verification integrated and visual development environments keywords program debugging program repair heap manipulations acm reference format sahil verma and subhajit roy.
.
synergistic debug repair of heap manipulations.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction we present wolverine an integrated debugging and repair tool for heap manipulating programs.
wolverine hooks into gdb to control the concrete execution of the buggy program and extracts the concrete program state via gdb to provide visualizations of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
abstract program states as box and arrow diagrams .
such boxand arrow diagrams are routinely used by programmers to plan heap manipulations and in online education .
wolverine includes common debugging facilities like stepping through an execution setting breakpoints fast forwarding to a breakpoint we provide the important wolverine commands in table .
whenever the programmer detects an unexpected program state or control flow indicating a buggy execution she can repairthe box and arrow diagram to the expected state or force the expected control flow like forcing another execution of a while loop though the loop exit condition is satisfied during the debugging session.
these expectations from programmer are captured bywolverine as constraints to build a partial specification.
when the programmer feels that she has communicated enough constraints to the tool she can issue a repair command requestingwolverine to attempt automated repair.
instead of aborting the current execution and restarting it wolverine simulates hotpatching of the repair patch generated by its repair module allowing the debugging session to continue from the same point.
as the repair patch is guaranteed to have met all the user expectations till this point the programmer can seamlessly continue the debugging session with the repair patch applied without requiring an abort compile debug cycle.
wolverine by virtue of this seamless integration of debugging and repair allows advanced debug repair strategies wherein a skilled developer can communicate her domain knowledge of the program to wolverine thereby facilitating significant speedups during repair if the programmer has confidence that a set of statements cannot have a bug she can use specification refinement to eliminate these statements from the repair search space.
similarly if the programmer understands that a part of the symbolic state is irrelevant for the current debug target she can use specification slicingto eliminate them from the repair specification.
hence rather than eliminating human expertise wolverine allows a synergistic human machine interaction.
wolverine bundles a novel proof directed repair strategy it generates a repair constraint that underapproximates the potential repair search space via additional underapproximation constraints .
if the repair constraint is satisfiable a repair patch is generated.
if a table wolverine cheatsheet command action start starts execution enter leave enter exit loop next executes next statement step step into a function change esvs set entity esto valuevs spec add program state to specification repair return repaired code rewrite rewrite the patched file as a c program esec fse september paderborn germany sahil verma and subhajit roy 1s t r u c t node head 2vo id r e v e r s e s t r u c t node c u r r e n t temp1 null temp2 null c u r r e n t head while temp1 !
null fix1 c u r r e n t !
null temp1 c u r r e n t prev temp2 c u r r e n t prev fix2 c u r r e n t next c u r r e n t prev temp2 c u r r e n t next temp1 c u r r e n t c u r r e n t prev head temp1 prev fix3 i n s e r t stmt .
.
.
.
15i n t main push push push push r e v e r s e figure our motivating example proof of unsatisfiability is found indicating a failed repair attempt that does not depend on an underapproximation constraint it indicates a buggy specification or a structural limitation in the tool s settings else the respective underapproximation constraint that appears in the proof indicates the widening direction.
we evaluate wolverine on a set of buggy files randomly generated faulty versions over four fault configurations of benchmark programs collected from online sources spanning multiple data structures like singly doubly and circular linked lists binary search trees avl trees red black trees and splay trees.
wolverine could successfully repair all faults within reasonable time less than seconds for most of the programs .
we also evaluate wolverine on student submissions for heap manipulating problems from an introductory programming course wolverine could repair more than of the programs where the student had made a reasonable attempt.
we make the following contributions in this paper we propose that an integrated debug repair environment can yield significant benefits we demonstrate it by building a tool wolverine to facilitate debug repair on heap manipulations we propose a new proof directed repair strategy that uses the proof of unsatisfiability to guide the repair along the most promising direction we propose advanced debugging techniques specification refinement andspecification slicing that are facilitated by this integration of debugging and repair.
overview .
a wolverine debug repair session let us demonstrate a typical debug repair session on wolverine the program in figure attempts to create a doubly linked list using the push function and then reverses it using the reverse function.
the reverse function is buggy with three faults the loop condition is buggy which causes the loop to be traversed one less time than expected the programmer possibly due to a cut and paste error from the previous line sets temp2 to the prev field finally she forgets to reset the head pointer to the new head of the reversed list.the programmer launches wolverine via the start command then she issues multiple next commands to concretely execute the push statements thereby creating the list.
the current symbolic state of the program heap is displayed to the programmer shown in figure 2a .
wolverine start starting program... push wolverine next next next next push .
.
.
the user now decides to step into the reverse function using thestep command.
reverse wolverine step as the reverse function progresses current andhead must be placed at desired places on the other hand temp1 andtemp2 are used for intermittent manipulations of the pointers.
hence the programmer uses the track command to intimate wolverine of the expectations on current andhead while allowing wolverine to freely alter the temporary pointers for repairing the program.
struct node current temp1 null temp2 null wolverine track wolverine next current head wolverine next when the while loop is reached the user decides that the current program state is desirable at this point and hence asserts this state in the specification using the spec command.
when invoked the repair module will ensure that this program state is preserved at this location in any repair patch that it synthesizes.
while temp1 !
null wolverine spec program states added at the while statement the execution would not enter the loop due to bug1 however as the user wants the execution to enter the loop she alters the control flow via the enter command to force the execution into the loop.
while temp1 !
null wolverine enter the user employs the next command to execute through the loop till the second iteration of the loop is hit.
temp1 current prev wolverine next next next next next .
.
.
while temp1 !
null the state of the program that is displayed to the programmer is shown in figure 2b the user observes that the prev field of the node n4 which should have pointed to n3 instead points to null the same is the case with the the pointer variable current .
the user thus employs the change command in wolverine to make the respective updates to the state.
164synergistic debug repair of heap manipulations esec fse september paderborn germany head 10null null n1 n2 n3 n4next nextnextprevprevprev prev datadatadata datanext a nodes added before entering reverse curr temp2 temp1null head 10nullnull n1 n2 n3 n4next nextnext prevprev prev datadatadata datanull prev next b at the end of first loop iteration without user changes curr temp2 temp1nullhead 10null n1 n2 n3 n4next nextnext prevprev prev prev datadatadata datanextnull c changes brought about by the user after first loop iteration curr temp2 temp1 head 10null n1 n2 n3 n4 nextnextnext prev prevprev prev datadatadata datanext null d at the end of second loop iteration after user changes curr temp2 temp1 head 10null n1 n2 n3 n4 nextnextnext prev prevprev prev datadatadata datanext null e at the end of third loop iteration no changes required curr temp2 temp1 head24810null n1 n2 n3 n4nextnext next prevprevprev prev data datadata datanextnull f at the end of fourth loop iteration figure the visualization of the program execution provided by wolverine .
the dotted arrows denote relations in the program state that are untracked i.e.
not communicated to the repair module as part of the specification.
wolverine change current n3 wolverine change n4 prev n3 the state of the program heap is updated to as shown in figure 2c.
the user now confirms her expectations on the state of the program heap by issuing the spec command.
while temp1 !
null wolverine spec program states added the user now enters the loop for the second time.
wolverine enter while temp1 !
null .
.
.
at the end of this loop iteration the user again finds undesirable changes in the linked list so she changes the pointer current to n2andprev field of n3ton2.
while temp1 !
null wolverine change current n2 wolverine change n3 prev n2 the user satisfied with the current updated state of the list shown in figure 2d commits it to the specification.
while temp1 !
null wolverine spec program states addedshe now requests a repair patch using the repair command.
wolverine repair repair synthesized... the repair synthesized by wolverine correctly fixes bug2 however the other bugs still remain as the trace does not contain these cases yet.
the synthesized patch is guaranteed to satisfy the specification on the trace thus far wolverine now simulates hot patching of this repair allowing the user to continue this debugging session rather than having to undergo an abort compile debug cycle.
the user attempts to verify the repair by running the next third iteration of the loop this iteration completes successfully with the expected heap state without the user making any changes as shown in figure 2e alluding that the repair is possibly correct.
while temp1 !
null wolverine enter .
.
.
fourth iteration also updates the program heap as per the expectations of the user reinforcing her confidence in the repair patch.
while temp1 !
null wolverine enter .
.
.
now the user would like to exit the loop as the complete list has reversed however due to bug1 the loop termination condition 165esec fse september paderborn germany sahil verma and subhajit roy c to ir generator driver modulerepair modulegdb instruction screeninginput program irrepair patchir stateresponse gdb cmds rewrite moduleoutput programfixed code ir instrrepair patchgdb cmds figure the claws of wolverine does not hold.
the programmer forces a change in the control flow by using the leave command to forcefully exit the loop.
while temp1 !
null wolverine leave exiting function... wolverine signals the user that it is returning from the function at this point the user recognizes that the state is still buggy as the head pointer continues to point to the node n4 rather than n1 as shown in figure 2f.
the user changes head ton1 adds the final states and requests a repair.
wolverine change head n1 wolverine spec program states added wolverine repair repair synthesized... note that this repair required the insertion of a new statement wolverine is capable of inserting a bounded number of additional statements to a buggy program.
on our machine the first repair call takes .
s fixing bug2 while the second repair call returns in .
s fixing bug1 andbug3 .
to summarize the programmer uses the debugging session to build a specification to drive automated repair.
on the debugger the programmer is required to repair the program states to indicate her expectations specification while the program is automatically repaired by wolverine .
.
the claws of wolverine figure shows the high level schematic of wolverine the heart ofwolverine is the driver module that provides the user shell for accepting commands from the programmer and controls the coordination of the various modules.
wolverine accepts the buggy c program from the user and employs the c to ir generator to compile it into its intermediate representation ir as a sequence of guarded statements and a location map to map each line of the c source code to an ir instruction see .
note that each c code instruction can get compiled down to multiple ir instructions and the same c source line may contain multiple statements each generating a sequence of ir instructions for the sake of simplicity we will assume the map to be a one to one map in the rest of this paper i.e.
each c source line appears in a different line and each c statement compiles down to a single ir instruction .
on the programmer s command the driver initiates the debug session by loading the binary on gdb many of the command issuedby the programmer are handled by dispatching a sequence of commands to gdbto accomplish the task.
however any progress of the program s execution for example the next command from the user is routed via the instruction screening module that manages specification abstraction and simulates hot patching see and algorithm .
on the repair command the driver invokes the repair module to request an automated repair based on the specification collected thus far.
the repair module synthesizes a repair patch that is propagated to the instruction screening module to enable hot patching of this repair.
if the user is satisfied she can invoke our rewrite module to translate the repaired program from our intermediate representation to a c program.
algorithm we represent the state s of a program that contains a set of variables vand a set of heap nodes hwith fields fasv h the state of the program variables v is a map v d and the program heap is represented by has a map h f d .
the domain of possible values d isi hwhereiis the set of integers.
for simplicity we constrain the discussions in this paper to only two data types integers and pointers.
we use the function e to fetch the type of a program entity a program entity e eis either a variable v vor a field of a heap node h h f. also pointers can only point to heap nodes as we do not allow taking reference to variables.
we distinguish between symbolic andconcrete states the memory state witnessed by the concrete execution via gdb is referred to as the concrete state we extract the symbolic state as a memory graph from the concrete state and then essentially replace machine addresses by symbolic names.
we maintain the heap nodes pointers in symbolic form while the scalar values like integers remain in their concrete form.
.
symbolic encoding of an execution figure shows the axiomatic semantics of our intermediate representation using hoare triples .
our intermediate representation maintains a program as a sequence of guarded statements a statement is executed only if the corresponding guard evaluates to true rules grd1 andgrd2 .
the scope of our repairs include the modification insertion of both the statements and the guards.
the primary statements are the assignment statement x y the getfield statement x y.f and the putfield statement x.f y .
for a mapz we use the notation z1 z2 to denote thatz2inherits all mappings from z1except that the mappings e17 e2is added updated.
we skip discussions of other statements in our ir like print for brievity.
the assignment statement requires a precondition that the types of the variables match if the precondition holds it updates the variable mapv1by adding a new mapping from the assigned variable x to the current value contained in y. the getfield statement requires type consistency and also that the dereferenced variable should be of pointer type and non null .
if the preconditions are met the respective update ensues.
theconcrete statement is used to enable an interesting debugging strategy we refer to it as specification refinement we invoke 166synergistic debug repair of heap manipulations esec fse september paderborn germany x y v2 v1 v1 h1 x y v2 h1 as n x y.f y ptrv1 y null v2 v1 v1 h1 x y.f v2 h1 et f ld x y.f x ptrv1 x null h2 h1 v1 h1 x.f y v1 h2 put f ld v1 h1 v2 h2 v2 h2 sym v2 h2 v1 h1 concr v1 h1 v1 h1 concrete v2 h1 cncr v1 h1 skip v1 h1 skip true v1 h1 stmt v2 h2 v1 h1 rd?stmt v2 h2 rd1 false v1 h1 rd?stmt v1 h1 rd2 figure semantics of our intermediate representation concrete with statement s that we do not wish to model symbolically.
we in this case extract a concrete precondition execute concretely on the precondition fetching a concrete postcondition.
the symbolic state corresponding to the concrete postcondition is assumed to be the postcondition of the concrete statement.
the guards are predicates that can involve comparisons from for integers and only for pointers we skip providing their formal semantics.
when the repair command is invoked say after executing n ir instructions via gdb the repair module constructs the semantic model of the execution trace sem by the conjunction of the semantic encoding of the instructions in the trace sem ny i 1ti si si wheretiencodes the semantics of the ithinstruction as shown in figure andsi andsi denote the input and output state of this instruction respectively .
.
the heap debugger we show the basic functionalities provided by wolverine in algorithm .
our algorithm accepts a buggy program as a sequence of guarded statements where is aguard predicate of the form op ar 1 ar 2 and is either an assignment v1 v2 a getfield operation v1 v2.field a putfield operation v1.field v2 or a concrete statement.
wolverine starts off with a string of initializations where is the set of tracked entities the state of only these entities is recorded while creating the specifications.
the algorithm then enters the command loop.algorithm the heap debugger 1 e e h 2while truedo cmd prompt switch cmddo case start do loc gdb start case next do loc executestatement loc 9sc fetch concrete state 10ss create symbolic state sc show ss case break loc do gdb send break loc case track do addlst remlst case change es vs do 17sc fetch concrete state 18ss create symbolic state sc 19ss vs db set address vs case spec do 22sc fetch concrete state 23ss create symbolic state sc assert spec .ir id ss case repair do patch repair run hot patch patch end 29end for the next command wolverine dispatches the next program statement to be executed at source line loc to the statement screening module algorithm which returns the next line to be executed.
wolverine then queries gdbfor the current program state using the function fetch concrete state and then uses the functioncreate symbolic state to generate the memory map and construct the symbolic state this function returns back the symbolic map dsand a map the map records the mapping of the symbolic entities to the concrete entities.
the symbolic memory map is displayed to the user as a visual aid for debugging.
the break command dispatches the command to gdbfor inserting a breakpoint.
the track command called with the list of entities to be added removed from being tracked updates the list.
thechange command allows the user to alter the current program state thereby alter the specification by providing the symbolic entity esto be modified to the new value vs.wolverine accordingly translates the symbolic state to a relevant concrete state and issues a string of gdbcommands summarized by the function gdb set address to alter the concrete program state.
the spec command asserts the symbolic state at the current program point involving only the tracked entities.
finally the repair command invokes the repair module to synthesize a repair patch that obeys the string of assertions issued 167esec fse september paderborn germany sahil verma and subhajit roy algorithm executestatement input n l chan ed inserted preserved 1ifstmt concrete then loc gdb send next 3sc fetch concrete state 4ss create symbolic state sc repair add spec .ir id ss 6else if .status chan edthen gdb send skip irstm ir2gdbstm .ir id gdb exec stm irstm 10else if .status inserted then irstm ir2gdbstm .ir id gdb exec stm irstm 13else loc gdb send next 14return loc thus far.
on a successful repair it passes the repair patch to the instruction screening module to simulate hot patching of the repair.
in addition to the above wolverine also supports altering of the control flow like entry exit of loops via the enter andleave commands respectively flip branch directions etc.
we demonstrated these features in but we omit the details for brievity.
algorithm describes the executestatement function implemented by the instruction screening module.
this accepts a list of guarded statements and a map from the source line numbers inn to a tuple containing the corresponding ir instruction in l and status bits f chan ed inserted preserved to indicate a the respective ir instruction has been modified chan ed by a repair patch b appears as a new instruction inserted due to a repair patch or c is unmodified preserved this information is required to simulate hot patching.
note that deletion of a statement is also marked chan ed as the patch would simply set the guard tofalse in that case.
the module handles two primary tasks handling concrete statements if aconcrete statement is found wolverine executes the statement via gdbby issuing thenext command.
then it asserts the effect of this concrete execution by taking a snapshot of the concrete state via gdb and adding the corresponding symbolic state to the specification.
this allows for a powerful debugging strategy we refer to it as specification refinement see .
simulate hot patching if the statement has changed due to a repair patch wolverine requests gdbto skip the execution of the next statement.
then it translates the effect of the modified statement into a sequence of gdbcommands irstm via the ir2gdbstm function and dispatches the commandlist to gdbusing our gdb exec stm function.
otherwise it concretely executes the next statement via gdbby issuing the next command to it.
.
proof guided repair algorithm shows our repair algorithm it takes a buggy programpas a sequence of guarded statements and a bound on the number of new statements that a repair is allowed to insertalgorithm unsat core guided repair algorithm 1 rd stm ins 2n p num insert slots assert the input buggy program 3fori .
.
.
p do rd r i dp.
rd p. rd stm s i dp.stm p.stm 6end initialize the insertion slots 7fori p .
.
.n do ins t i i false 9end define the placing function 10 bk i .
.
.n i n distinct i 11 bk i .
.
k .
.
p i k i k 12v unsat relax till specification is satisfied 13 rd stm ins 14whilev unsat ortries exceeded do res dp uc solve spec sem bk rd k .
.
.
p rk rd stm k .
.
.
p sk stm ins k p .
.
.n tk ins use the unsat core to drive relaxation ifres unsat then if rd uc then rd else if stm uc then stm else if ins uc then ins else return null 24end 25iftries exceeded then return null 26return dp num insert slots .
the repair algorithm attempts to search for a repair candidate dp of size n p num insert slots that is close to the existing program and satisfies the programmer s expectations specification .
our algorithm is allowed to mutate and delete existing statements and insert at most nnew statements.
the insertion slots contain a guard false to begin with line the repair algorithm is allowed to change it to activate the statement.
deletion of a statement changes the guard of the statement tofalse .
wolverine allows for new nodes and temporary variables by providing a bounded number of additional hidden nodes temporaries made available on demand.
the number of insertion slots is configured by the user but these slots are activated by the repair algorithm only if needed.
for loops we add additional constraints so that all loop iterations encounter the same instructions.
.
.
primary constraints.
we use a set of selector variables r1 .
.
.
rn s1 .
.
.
sn to enable a repair.
setting a selector variable totrue relaxes the respective statement allowing wolverine to synthesize a new guard statement at that program point to satisfy 168synergistic debug repair of heap manipulations esec fse september paderborn germany the specification.
we define a metric closeness p1 p2 to quantify the distance between two programs by summing up the set of guards and statements that match at the respective lines.
as the insertion slots should be allowed to be inserted at any point in the program the closeness metric would have to be adjusted to incorporate this aberration due to insertions.
for this purpose our repair algorithm also infers a relation that maps the instruction labels in the repair candidate dpto the instruction labels in the original program p the instruction slots are assigned labels from the set p .
.
.
n .
we define our closeness metric as closeness p dp p x i p. rd dp.
rd p x i p.stm dp.stm nx i p dp.
rd false the above metric weights a repair candidate by the changes in the statements guards and new statements added insertion slots activated .
algorithm starts off by asserting the input program p via the selector variables as part of the constraints rdand stm lines and initializes the insertion slots to their deactivated state lines with selector variables ti.
the constraint bkensures that the function is well formed for each i i is a distinct value in the range .
.
.n and is a monotonically increasing function this ensures that the statements preserve the same order in dp as the order inp .
finally it uses issues a solve query to an smt solver to solve the repair constraint the sub constraint semcontains the semantic encoding of our intermediate statements figure and spec contains the specification collected during the debugging session as a result of the spec commands.
.
.
proof guided search space widening.
to ensure that the repaired candidate program dpisclose to the original program we progressively relax the closeness bounds.
the variables rd stm and insconstrain the distance in terms of changed guards statements and activated insertion slots of a repair candidate from the original program.
we use a proof guided repair strategy we use the unsat core uc produced from the proof of unsatisfiability to direct us to the bound that needs to be relaxed.
the unsat core represents the central reason as to why the program cannot be made to satisfy the specification if a constraint si .
.
.
is found in the unsat core it implies that the reason for unsatisfiability may be attributed to the fact that siis false!
hence one possible way to remove this unsatisfiability is to increase the bound on stmthat allows sito turn false .
at the same time we would also like to enforce a priority on the relaxations for instance deletion of a statement or mutation of a guard can be considered smaller changes than changing a statement or worse inserting a new statement.
the chain of conditions lines ensures that if the unsat core directs us to a possibility of smaller change we relax the respective boundbefore others.
finally on a successful repair we return the repaired program dp.
guiding repair via the unsat proof has multiple advantages the unsatisfiability core uc guides us to a feasible repair for example if ucdoes not contain the constraints pertaining to activation of the insertion slots then it is unlikely that inserting a new statement will fix the bug it allows us to prioritize the repair actions one would prefer mutation of a statement than insertion of a new statement the strategy is fast as the solver is provided constrained search spaces which is incrementally widened in a direction dictated by the proofs as the search progresses.
in case the program to be repaired is close to the original program the solver will be provided only easy instances that are allowed to mutate insert a small number of statements it allows a fail fast line if the specification is buggy or the repair is not possible due to structural constraints like the number of insertion slots provided if ucdoes not contain any constraint from rd stm ins then the program cannot be repaired via any repair action without violating the hard constraints like the program semantics .
the unsat core not only identifies the possible culprits a sort of bug localization but also allows us to define a priority among our repair preferences.
to the best of our knowledge ours is the first repair algorithm that uses unsat proofs to direct repair however this idea has threads of similarity with a model checking algorithm referred to as underapproximation widening see .
we evaluated a variant algvar of our proof directed repair scheme instead of increasing the respective repair bound we randomly relax one of the constraints from the unsat core.
however we found that the unsat cores are poor quite far from the minimum unsat core.
hence this variant of our algorithm performs poorly both in terms of success rate and the time taken for repair see .
advanced debugging repair .
specification refinement wolverine is designed to model heap manipulations however wolverine can use the concrete statement in its intermediate representation as an abstraction of any statement that it does not model.
on hitting a concrete statement wolverine uses gdb to concretely execute the statement and updates its symbolic state from the concrete states provided by gdb.
figure shows an instance where we wrap the i i statement in an concrete execution wolverine translates this statement to a string of gdbcommands and the symbolic state is updated with the value of ifrom the concrete state that gdbreturns after executing the statement.
hence though wolverine is specifically targeted at heap manipulations it can be used to debug repair programs containing other constructs as well as long as the bug is in a heap manipulation.
we refer to this technique of reconstructing the symbolic specification by running the statement concretely as specification refinement .
specification refinement can be used in creative ways by skilled engineers.
in figure the programmer decided to wrap a complete function call foo within the concrete construct allowing wolverine to reconstruct the effect of the function call via concrete execution without having to model it.
this strategy can fetch 169esec fse september paderborn germany sahil verma and subhajit roy 1vo id bar s t r u c t node c u r r e n t null i n t i c u r r e n t head while c u r r e n t !
null c o n c r e t e c o n c r e t e stmt .
c u r r e n t d a t a i c u r r e n t c u r r e n t next figure refinement with concrete function calls 1vo id r e v e r s e i n t i s t r u c t node l a s t c u r r e n t nt null c u r r e n t head while c u r r e n t !
null nt c u r r e n t next c u r r e n t next prev prev c u r r e n t c u r r e n t d a t a j fix1 c u r r e n t d a t a i c o n c r e t e c o n c r e t e stmt .
c u r r e n t nt fix2 c u r r e n t prev head prev fix3 i n s e r t stmt .
figure example for specification slicing significant speed ups for repair let us assume that in figure the programmer uses her domain knowledge to localizes the fault to lines she can pass this information to wolverine by wrapping the other statements in the loop lines in concrete statements this hint brings down the repair time on the full program on the complete execution from .0s to .5s i.e achieving a speedup on our machine .
this is understandable as each instruction that is modeled can increase the search space exponentially.
.
specification slicing in case the programmer is aware that two features of her implementation can be debugged independently she can employ another interesting debugging feature that we refer to as specification slicing she can use the track command in wolverine toslice away the values that are irrelevant to the feature being debugged.
for example figure shows a program that reverses a singly linked list while also assigning the data field with value increasing by one.
there exist three bugs the bugs at line and affects the loop reversal while the bug at line controls the assignment to data .
the programmer can employ the track command to remove thedata field from the specifications for faster repair of bug2 and bug3 i.e.
the blue edges in figure subsequently for bug1 the red edges are dropped.
the red and blue edges in figure shows how one of the states can be sliced into multiple smaller states for repair.
on our machine the two slices took .0s fix2 andfix3 and .5s fix1 to be fixed while the complete specification without slicing took .5s.
experiments we built wolverine using the gdbpython bindings the c toast compiler uses pycparser the visualization module uses igraph to construct the box and arrow diagrams and the repair module uses the z3 theorem prover to solve the smt constraints.
we conduct our experiments an intel r xeon r cpu .00ghz head 0null n1 n2 n3 n4next next data data datadatanexti j next currfigure specification slicing machine with gb ram.
to evaluate our implementation we attempt to answer the following research questions rq1 is our repair algorithm able to fix different types and combination of bugs in a variety of data structures?
rq2 can our repair algorithm fix these bugs in reasonable time?
rq3 how does our repair algorithm scale as the number of bugs are increased?
rq4 iswolverine capable of debugging fixing real bugs?
.
experiments with fault injection for rq1 and rq2 we select heap manipulating programs from online sources for a variety of data structures.
to create buggy versions we build our own fault injection engine to automatically inject bugs at random thereby eliminating possibilities of human bias.
for each program we control our fault injection engine to introduce a given number of bugs we characterize a buggy version by x y implying that the program requires modification ofx randomly selected program expressions each modification is a replacement of a program variable or a field in a program statement or a guard and the insertion of ynewly synthesized program statements.
for the experiments wolverine makes attempts at repairing a program each attempt followed by proof directed search space widening each attempt is run with a timeout of 30s.
the experiment was conducted in the following manner we evaluate each benchmark in table for four bug classes class1 class2 class3 and class4 for each benchmark bi at each bug configuration x y we run our fault injection engine to create buggy versions with xerrors that require modification of an ir instruction andyerrors that require insertion of a new statement each of the above buggy program is run times to amortize the run time variability.
figure shows the average time taken to repair a buggy configuration over the buggy variants which were themselves run twice the reported time shows the average time taken for the successful repairs only .
we report the time taken for our main algorithm in algorithm and its variant algvar discussed in the last paragraph in .
our primary algorithm performs quite well fixing most of the repair instances in less than seconds understandably the bug classes that require insertion of new instructions classes and take longer.
there were about widenings for bugs in class the bugs in class were more challenging needing widenings.
in terms of the success rate our primary algorithm was able to repair all the buggy instances .
however figure 8c shows the success rate for each bug configuration for algvar the success rate is computed as the fraction of buggy instances of the given buggy 170synergistic debug repair of heap manipulations esec fse september paderborn germany table description of our benchmarks b1 reverse singly linked list b2 reverse doubly linked list b3 deletion from singly linked list b4 creation of circular linked list b5 sorted insertion singly linked list b6 insertion in single linked list b7 swapping nodes singly linked list b8 splaytree left rotation b9 find minimum in binary search tree b10 find length of singly linked list b11 print all nodes singly linked list b12 splitting of circular linked list b13 avl tree right rotation b14 avl tree left right rotation b15 avl tree left rotation b16 avl tree right left rotation b17 red black tree left rotate b18 red black tree right rotate b19 enqueue using linked list b20 splaytree right rotated table tool evaluation on student submissions id total fixed imlmt ooscope vacuous s1 s2 s3 s4 s5 configuration that could be repaired by wolverine in any of the two attempts .
the inferior performance of the variant of our main algorithm shows that the quality of the unsat cores is generally poor while the performance of our primary algorithm demonstrates that even these unsat cores can be used creatively to design a good algorithm.
figure answers rq3 by showing the scalability of wolverine with respect to the number of bugs on of our benchmarks.
we see that in most of the benchmarks the time taken for repair grows somewhat linearly with the number of bugs though in theory the search space grows exponentially.
also one can see that more complex manipulations like left rotation in a red black tree b17 are affected more as a larger number of bugs are introduced as compared to simpler manipulations like inserting a node in a sorted linked list b5 .
the variance in the runtimes for the different buggy versions even for those corresponding to the same buggy configuration was found to be high.
this is understandable as smt solvers often find some instances much easier to solve than others even when the size of the respective constraint systems is similar.
.
experiments with student submissions in order to answer rq4 we collected buggy submissions from students corresponding to programming problems on heap manipulations from an introductory programming course .
we attempted repairing these submissions and categorized a submission into one of the following categories fixed fixed these are the cases where wolverine could automatically fix the errors.
imlmt implementation limitations these are cases where though our algorithm supports these repairs the current state of our implementation could not support automatic repair.
ooscope out of scope the bug in the submission did not occur in a heap manipulating statement.
vacuous vacuous in these submissions the student had hardly attempted the problem i.e.
the solution is almost empty .
overall we could repair more than of the submissions automatically where the student has made some attempt at the problem i.e.
barring the vacuous cases .
related work our proof guided repair algorithm is inspired by a model checking technique for concurrent programs referred to as underapproximation widening that builds an underapproximate model of the program being verified by only allowing a certain set of thread interleavings by adding an underapproximation constraint that inhibit all others.
if the verification instance finds a counterexample a bug is found.
if a proof is found which does not rely on the underapproximation constraint the program is verified else it is an indication to relax the underapproximation constraint by allowing some more interleavings.
hence the algorithm can find a proof from underapproximate models without needing to create abstractions.
to the best of our knowledge ours is the first attempt at adapting this idea for repair.
in the case of repairs performing a proof guided search allows us to work on smaller underapproximated search spaces that are widened on demand guided by the proof at the same time it allows us to prioritize among multiple repair strategies like insertion deletion and mutation.
in the space of repairs directfix also builds a semantic model of a program but instead uses a maxsat solver to search for a repair.
invoking a maxsat solver is not only expensive a maxsat solver also does not allow prioritization among repair strategies.
in directfix it is not a problem as the tool only allows mutation of a statement for repair and does not insert new statements.
alternatively one can use a weighted maxsat solver for the prioritizing among repair actions but it is prohibitively expensive we are not aware of any repair algorithm that uses a weighted maxsat solver for repair.
zimmermann and zeller introduce memory graphs to visualize the state of a running program and zeller used memory graphs in his popular delta debugging algorithms to localize faults.
our algorithm is also based on extracting these memory graphs from a concrete execution on gdband employing its symbolic form for repair.
the notion of concrete statement in wolverine bears resemblance to concolic testing tools .
symbolic techniques build a symbolic model of a program and use a model checker to execute the program they classify a statement buggy based on the distances of faulty executions from the successful ones.
angelic debugging instead uses a symbolic execution engine for fault localization by exploring alternate executions on a set of suspicious locations while angelix fuses angelic debugging style fault localization with a component based synthesis framework to automatically synthesize fixes.
there have also been regression aware strategies to localize repair bugs .
there have also been proposals to use statistical techniques evolutionary search and probabilistic models for program debugging.
however the above algorithms through quite effective for arithmetic programs 171esec fse september paderborn germany sahil verma and subhajit roy b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 b16 b17 b18 b19 b20 benchmarks05101520253035timeclass1 class2 class3 class4 a repair time for our primary algorithm b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 b16 b17 b18 b19 b20 benchmarks05101520253035timeclass1 class2 class3 class4 b repair time for the variant algvar of our primary algorithm b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 b16 b17 b18 b19 b20 benchmarks020406080100percentage repairclass1 class2 class3 class4 c success rates for algvar our primary algorithm has success rate in all cases.
figure performance of our repair algorithms number of bugs0102030405060time sec b2 b5 b12 b17 b18figure experiment showing the increase in repair time with increasing number of bugs were not designed for debugging repairing heap manipulations.
there have been proposals that repair the state of a data structure on the fly whenever any consistency check from a set of checks provided by a user is found to fail .
however our work is directed towards fixing the bug in the source code rather than in the state of the program which makes this direction of solutions completely unrelated to our problem.
in the space of functional programs there has been a proposal to repair functional programs with unbounded data types however such techniques are not applicable for debugging imperative programs.
there has been some work in the space of synthesizing heap manipulations.
the storyboard programming tool uses abstract specifications provided by the user in three valued logic to synthesize heap manipulations.
as many users are averse to writing formal specification synbad allows synthesis of programs from concrete examples to amplify the user s confidence in the program it also includes a test generation strategy on the synthesized program to guide refinement.
the intermediate representation ofwolverine is inspired from synbad wolverine can also be extended with a test generation strategy to validate the repair on a few more tests before exposing it to the programmer.
synlip proposes a linear programming based synthesis strategy for heap manipulations.
feser et al.
proposes techniques for synthesis of functional programs over recursive data structures.
wolverine on the other hand attempts repairs the primary difference between synthesis and repair is that for a good repair the tool must ensure that the suggested repair only makes small changes to the input program rather than providing a completely alternate solution.
discussion we believe that tighter integration of dynamic analysis possibly enabled by a debugger and static analysis via symbolic techniques can open new avenues for debugging tools.
we were careful to select a variety of data structures and injected bugs via an automated fault injection engine to eliminate human bias nevertheless more extensive experiments can be conducted.
172synergistic debug repair of heap manipulations esec fse september paderborn germany