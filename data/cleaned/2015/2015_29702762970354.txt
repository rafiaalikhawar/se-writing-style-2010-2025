apex automated inference of error specifications for c apis yuan kang columbia university usa yuanjk cs.columbia.edubaishakhi ray university of virginia usa rayb virginia.edusuman jana columbia university usa suman cs.columbia.edu abstract although correct error handling is crucial to software robustness and security developers often inadvertently introduce bugs in error handling code.
moreover such bugs are hard to detect using existing bug finding tools without correct error specifications.
creating error specifications manually is tedious and error prone.
in this paper we present a new technique that automatically infers error specifications of api functions based on their usage patterns in c programs.
our key insight is that error handling code tend to have fewer branching points and program statements than the code implementing regular functionality.
our scheme leverages this property to automatically identify error handling code at api call sites and infer the corresponding error constraints.
we then use the error constraints from multiple call sites for robust inference of api error specifications.
we evaluated our technique on api functions from different libraries across projects written in c and found that it can identify error handling paths with an average precision of and recall of .
we also found that our technique can infer correct api error specifications with an average precision of and recall of .
to further demonstrate the usefulness of the inferred error specifications we used them to find previously unknown potential bugs including several security flaws that are currently being fixed by the corresponding developers in the tested projects.
ccs concepts software and its engineering software libraries and repositories keywords error handling bugs specification mining api errors .
introduction reliable software should be able to tolerate a wide variety of failures.
therefore reliable software must be designed to behave gracefully even when lower level functions e.g.
api functions fail otherwise the failure may affect both software availability and security.
typically when a failure occurs the failing function notifies its caller about the failure and the caller then decideshow to handle such failures in a graceful manner.
however software developers often make mistakes and inadvertently introduce bugs in api error handling code .
for example a significant number of security flaws result from incorrect error handling e.g.
cve cve cve cve and cve .
in fact incorrect error handling was listed by the open web application security project owasp as one of the top ten sources of security vulnerabilities .
there are several existing static and dynamic analysis techniques to automatically detect incorrect handling of api function failures.
for example several prior projects used dynamic fault injection to simulate function failures to check whether the test program handles such failures correctly .
another popular approach for detecting error handling bugs is to use static analysis to check whether failures are properly detected and handled .
for example epex a system designed by jana et al.
uses under constrained symbolic execution to explore error paths and leverages a program independent error oracle to detect error handling bugs.
however all such tools need the error specifications of the api functions as input.
the error specification of an api function indicates whether the function can fail or not and if so how the function communicates a failure to the caller.
manually generating error specifications is error prone and tedious.
it is particularly hard for low level languages such as c that do not provide any specialized exception handling mechanisms and contain only generic channels of communication e.g.
return value arguments passed by reference between the caller and callee functions.
therefore the developers of each api must decide individually which values indicate failure.
consequently the error specifications are function specific and may vary widely across functions.
while there are values that intuitively indicate errors such as negative integers or null pointers such conventions do not always hold and thus will result in highly inaccurate specifications.
for example in openssl for some api functions 0indicates errors while for others 0is used to indicate success.
moreover some api functions are infallible i.e.they never return any error value.
a correct error specification should only contain fallible api functions but it is hard to manually separate them from the infallible ones.
api documentation is one obvious source for gathering such specifications.
however previous research has shown that api documentation is often unavailable or inaccurate .
for example rubio gonz lez et al.
found 700undocumented error code instances in linux file system api functions .
further api documentation usually fails to distinguish between benign and critical errors which is essential to minimize spurious bug reports as benign errors can be safely ignored.
in this paper we present a novel technique to automatically infer the error specifications for c api functions by analyzing their usage across multiple applications.
the key insight behind our permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
technique is that when an api function call fails and returns an error usually its caller does not continue normal execution and returns immediately.
error handling code written in c is known to be significantly more likely to use goto statements than regular code for such control transfers .
therefore error handling code in the caller function is more likely to have less branching points program statements and function calls than the code implementing a normal functionality.
we leverage such path characteristics to identify error handling code.
in particular we use under constrained static symbolic execution at the caller function to explore all feasible paths and determine whether a path exercises error handling code or not using on the path s features.
next we extract the constraints on an api function s return value that must be satisfied along the paths exercising error handling for that api function.
we call these constraints potential error specifications .
however these constraints may not be accurate due to either buggy or over conservative error handling checks.
we minimize these issues by comparing and contrasting the error constraints for the same api function extracted from different call sites across different programs.
we pick the most common error constraints as the error specification of the api function.
if there is no clear popular error constraint s across the call sites either the constraints are different or there are no constraints we declare that the api function cannot fail or the developers do not consider the failure of the function to be critical.
using our approach we generated correct error specifications for api functions collected from popular c libraries with a precision of and a recall of .
we also discovered potential error handling bugs that violate the error specifications across different applications.
so far we have reported bugs out of which have been fixed.
in summary the main contributions of our work are as follows.
to our knowledge we are the first to notice that the paths performing error handling in c code have unique features e.g.
branching points program statements that distinguish them from non error paths and empirically confirmed this insight.
leveraging characteristics of the program paths performing error handling we design and implement a novel algorithm apex to automatically infer error specifications of c api functions from their usage.
we conduct a detailed empirical evaluation of apex s ability to automatically infer error specifications for c api functions from open source libraries.
we found that apex has a precision of and a recall of .
this improves significantly over trivial specifications like treating a nonnegative return value as success for openssl api functions which only has precision.
using these error specifications we discovered potential error handling bugs in real world applications.
so far we have reported bugs that we thought to have serious consequences and out of them are already fixed by the developers.
the rest of the paper is organized as follows.
section describes the main insight behind our approach using a running example.
next in section we present an empirical study of unique path characteristics of error handling code.
section discusses apex s methodology for inferring error specifications and section evaluates it.
section discusses related work.
finally in section we examine potential threats that may affect our findings and we conclude in section .
.
motiv ating example in this section we provide a high level overview of our approach with a running example adapted from the curl project see figure .
file tool hugehelp.c 2voidhugehelp ... 4if inflateinit2 ... !
return 6buf malloc ... 7if buf !
null while status inflate ... if status ... else break 17inflateend ... l4 inflateinit2 !
l6 buf malloc l7 buf!
null l8 while l9 status inflate l10 status l11.
... l17 inflateend t t f f f t l18 return l5 return begin end figure sample error handling code and the corresponding control flow graph cfg containing zlib and libc api functions adapted from curl.
the red dotted arrows show error branches.
in this sample code fragment the caller function hugehelp calls four different api functions inflateinit2 inflate inflateend fromzlib andmalloc fromlibc .inflateinit2 returns a non zero integer value on error1 line .
the caller function checks for such cases and immediately returns line in case of an error.
if no such error occurs the execution continues and calls malloc at line .
as malloc returns a null pointer in case of a failure line checks whether malloc was able to allocate memory correctly if not it goes directly to line and subsequently returns from the caller function.
otherwise the regular execution continues.
another similar error check for inflate api call takes place at line .
note that inflateend can also return an error but the developer chose to ignore the error.
all the branches corresponding to error values are shown in red dotted lines in figure .
the error specifications for the api functions inflateinit2 inflate andmalloc based on their usage can be expressed as ne ationslash null and ne ationslash respectively.
the goal of this work is to automatically infer such api error specifications from these usage patterns.
before we describe our approach let us introduce some key terms that we will use in the rest of the paper.
definition .
.
control flow graph cfg a cfg of a function in the program is a directed graph represented by a tuple an bracketle tn e an bracketri ht.
n is the set of nodes where each node is labeled with a unique program statement.
the edges e n n represent possible flow of execution between the nodes in the cfg.
each cfg has a single begin n begin and end n end node.
all the nodes in the cfg are reachable from the n begin node and the n endnode is reachable from all nodes in the cfg.
definition .
.
path a path p is a sequence of nodes an bracketle tn0 n1 ....nj an bracketri htin a cfg such that there exists an edge between n kand nk i.e.
nk nk e for k ... j .
figure shows the cfg corresponding to the motivating example.
the begin and end nodes indicate the start and return exit from 1zlib error specification include linux zlib.h 473the function.
every other node corresponds to one program statement as marked with the respective line number.
a path exists between two nodes if they are connected by edges.
for example as shown in the figure three paths exist between node l7 and l17.
among all the possible paths that exist in a cfg we define error and non error paths corresponding to an api function as follows definition .
.
error path for an api function f an error path p err f is a path in the cfg of the caller function that starts from a node containing a function call to f follows a branch along whichf s error conditions are satisfied and ends at n end.
definition .
.
non error path for an api function f a non error path p nerr f is a path in the cfg of the caller function that starts from a node containing a function call to f follows a branch along which f s error conditions are not satisfied and ends at nend.
for example in figure an bracketle tl4 l5 end an bracketri ht an bracketle tl6 l7 l17 l18 end an bracketri ht and an bracketle tl9 l10 l17 l18 end an bracketri htare error paths for api functionsinflateinit2 malloc andinflate respectively.
a cfg can have multiple error and non error paths for an api function depending on how many error non error values the function can return and other conditions that are checked along those paths.
definition .
.
fallible infallible api functions a fallible api function is a function that can fail due to either internal or external reasons and in case of such a failure notifies its caller function by setting the api function s return value to certain error value s .
the api functions that cannot fail are called infallible api functions.
notice that the numbers of statements function calls and branching points along the error paths of a fallible api function are lower than their corresponding non error paths.
for example the error path forinflateinit2 line contains only 2statements function call and 1branching points.
in contrast a non error path an bracketle tl4 l6 l7 l8 l9 l10 l17 l18 end an bracketri hthas8statements 4function calls and 4branching points one while and three if statements .
we leverage this insight to design implement and evaluate an algorithm to automatically infer error specifications of the api functions.
for an api function f our algorithm works in three steps as described below.
step i collecting path information from individual call sites.
from the cfg of a caller function f we collect all the paths that start from the node corresponding to f s call statement.
we also collect the constraints on the return value of fand calculate the number of statements along each path.
since more paths can only be generated by more branches we additionally count the number of paths that run the call site for each constraint.
step ii combining path information across call sites.
we follow the above step for each caller of facross multiple call sites and combine the collected path information i.e.constraints on the return value of fand other path features based on the different unique constraints.
step iii inferring error specifications using voting.
we mark the paths as potential error paths that have a lower number of paths satisfying the same return value constraint and statement counts across all the call sites see section for a detailed analysis of the unique features of error paths .
thus for api function inflateinit2 path an bracketle tl4 l5 end an bracketri htwill be marked as an error path since it contains significantly less statements and branching points and therefore less paths with matching constraints compared to thenon error paths see figure .
the corresponding constraints will be inferred as error specifications.
for instance the error condition ne ationslash for api function inflateinit2 will be inferred as its error specification.
.
empirical study of error paths we conduct an empirical study of error paths to check whether they have any distinguishing features over non error paths.
our intuition behind this comes from the observation that developers often check whether an error has occurred during the execution of an api function call before using any of its results in most error cases the caller function short circuits the execution flow and bypasses the main logic.
thus in the caller functions the error paths should be simpler with less logic involved compared to the corresponding error free paths.
we measure such path characteristics in the caller functions by three properties i number of program statements ii number of function calls contained in the path and iii number of paths satisfying the same constraint on the return value of the called function which approximates the relative number of branch points.
we hypothesize that all these three measures should be lower along error paths than the corresponding error free paths.
.
study method table study subjects for understanding error path characteristics api call error non error library project functions sites paths paths gnutls zlib to understand the characteristics of error paths first we need to identify the error and non error paths at each api call site.
to do that we manually generated error specifications of gnutls functions and zlib functions that are called from and call sites respectively see table .
next we performed under constrained symbolic execution at the caller functions of each api function to explore the feasible paths.
for the paths that invoke calls to the api functions we checked the constraints on the return values of the functions against their corresponding error specifications.
the paths along which only error values can be returned are marked as error paths while the paths along which only non error values can be returned are marked as non error paths.
we drop all other cases where we cannot definitely conclude whether they are error or non error paths.
thus in total we compared and error paths in gnutls and zlib and and non error paths in them.
for example in figure the error specification of the zlib api functioninflateinit2 is ne ationslash .
our analysis will conclude that path an bracketle tl4 l5 end an bracketri htis an error path as the error condition is always satisfied along that path.
.
characteristics of error paths with the set of identified error and non error paths we check whether error paths have any distinguishing features over non error paths.
we characterize a program path based on three features i number of statements executed in the path ii number of functions called along it and iii number of paths that satisfy the same constraint at the call site.
figure summarizes the result.
number of program statements.
the box plots in figure 2a show that in both gnutls and zlib the number of statements executed 474gnutls zlib error non error error non error statements a number of program statements executed gnutls zlib error non error error non error functions b number of functions called gnutls zlib error non error error non error branches c number of paths figure characteristics of error vs. non error paths along error paths is less than non error paths.
a wilcoxon nonparametric test shows that these differences are statistically significant see table .
also cohen s d effect sizes between the two are1.
and0.
in zlib and gnutls respectively which are considered to be large and medium.
table comparison between error vs. non error paths features library wilcox.p.value cohendd statementszlib .83e .
large gnutls .87e .
medium functionszlib .91e .
small gnutls .
.
negligible pathszlib .
.
medium gnutls .33e .
small number of function calls.
figure 2b shows that for zlib apis the number of function calls in error paths is slightly lower than that of non error paths.
a wilcoxon non parametric test in table also confirms this observation with statistical significance.
however cohen s d effect size shows that the difference is small .
.
in contrast for gnutls apis we do not see any differences between the two sets.
thus overall we may not be able to characterize error paths based on the number of functions.
number of paths.
according to the box plots in figure 2c in both gnutls and zlib the number of error paths are less than nonerror paths with statistical significance see table .
cohen s d effect sizes between the two are .
medium and .
small for zlib and gnutls respectively.
this shows that the number of paths can be a good feature for distinguishing error constraints.
therefore we conclude that the number of program statements are significantly lower in error paths than non error paths and that there are significantly less error paths.
.
methodology this section presents apex a tool that automatically infers error specifications for c apis.
for an api function fand its caller c apex uses under constrained symbolic execution to explore all the feasible paths in cthat contain a call to f. for each path apex collects the constraints on the return value of fand other path specific statistics i.e.number of paths satisfying the same constraint and program statements.
apex aggregates such information over multiple call sites of f. the paths containing fewer paths satisfying the same constraint and program statements than average are identified as potential error paths and corresponding constraints are marked as the potential error specification of f. finally the error specification of fis decided by a voting algorithm that picks the most popular constraints from potential error specifications across different programs.
figure shows apex s workflow.
the algorithm works in three steps step i. collecting path information from individual call site for an api function fand a given program p first apex identifiesf s caller functions from p s call graph.
next for a caller c apex uses under constrained symbolic execution to explore all the feasible paths in cthat contain a call to fand collects information about path features pf such as statements and number of paths.
note that apex does not gather information about the number of function calls per explored path because function calls may not be a distinguishing feature for error paths as shown in section .
for path exploration apex uses under constrained symbolic execution starting from cas opposed to whole program symbolic execution thus ignoring the costly path prefix from the main function toc .
this helps apex remain scalable while analyzing large target programs at the cost of introducing some spurious paths.
however since we will combine data from multiple call sites in step ii effects of such spurious paths will be minimized.
in particular while exploring paths from caller c apex only includes paths that start at the api call end when the caller function terminates and records statistics about program statements and path counts that directly appear inside the caller.
this allows apex to focus on the relevant part of the caller body where error paths differ from non error paths.
apex further gathers the constraint c on the return value of f. by limiting the paths within caller functions apex also limits the constraints that apex gathers for the return values of the api functions.
to maximize the accuracy apex delays the evaluation of any unknown non constant symbols until the symbol is no longer used or the path has reached the end of the caller.
delaying evaluation allows apex to consider all the places within the caller function that add constraints on the return value of the api function.
the final output from this step represents a set of paths characterized by the constraints and path features c pf .
also note that while our discussion and current implementation only supports constraints on return values our technique can easily be extended to infer error specifications of an api function that transmits error values by modifying an argument passed by reference.
step ii.
combining path information across call sites in this step we aim to combine the path information i.e.constraint and path feature collected from multiple call sites by comparing constraints on the return values of an api function.
this is challenging because these constraints are often not identical.
some constraints are stronger than others.
for example consider the examples shown in table for the libc api function 475step ii.
combining path informa3on across call sites step iii.
inferring error specs using vo3ng across programs cj pfj step i ... call site pi c pf .
identified error paths .
inferred error specs step i collec3ng path informa3on from individual call site call site pj api func f step i ... call site pk api func f ci pfi ck pfk api func f figure apex s workflow table sample code showing error checking of libc api function stat program a file mutt mbox.c voidmbox reset atime context ctx structstat st ... if stat ... ... return ... program b file tar gnu chown.c int rpl chown const char file uid t uid gid t gid ... if stat ... ... !
return ... stat .
the function returns 0on success and 1on error2.
however while checking for failure call site a uses the constraint while call site b uses the constraint ne ationslash .
while both are correct 0is a stronger constraint than ne ationslash .
while inferring the error specifications of an api call apex picks the one that is used often in the program but the stronger constraint i.e.
0in this case will also include the counts of the more inclusive constraint so that it is more likely to be chosen.
this is critical for the accuracy of our inferred error specifications.
notice that such issues only appear in the case of integers given that apex currently supports three types of return values bool pointer and integer .
booleans and pointers cannot have overlapping constraints as apex currently does not distinguish between different values of non null pointers.
while combining the path information across call sites of an api function apex splits any overlapping range into multiple nonoverlapping ranges.
for example a constraint ne ationslash will be represented by the inclusive ranges .
let us assume that the return value for a function has the constraint ne ationslash i.e.
and at one call site and i.e.
at another call site along two paths the first path hassprogram statements and the second path has s program statements.
to compute the aggregate path features across different constraints apex splits the first constraint into two constraints each having 1path andsprogram statements.
the combined features of common constraint from the two call sites will be a path count of 2and a statement count list of s s respectively.
the final output of this step will be a combined set of path information characterized by constraints and path features c pf .
iii.
inferring error specifications using voting in this step apex aims to identify potential error constraints for a library function based on the path features.
the main decisions are made in two stages.
first apex identifies an error constraint from each project see algorithm .
then the individual programs vote for the global decision see algorithm .
per project error constraint inference.
in this step apex tries to identify potential error constraints of an api function ffor each project individually based on the aggregated path features as discussed in step ii see algorithm .
in particular among all the non overlapping constraints over all the paths for f apex first tries to identify the constraints for which the total number of paths is at least one standard deviation lower than the average line of all the paths.
if it fails to identify any such constraint apex then tries to find the constraints whose median statement counts over all paths in the project is at least one standard deviation lower than the average line .
if this too fails the corresponding project refrains from global voting.
global error constraint inference.
to infer global error specification of an api function f apex seeks votes from all the projects that call the function line of algorithm .
however if some callers have too few paths apex does not trust them.
to ensure this apex considers votes from the projects where the number of paths starting with a call to fis at least above or equal to the lower quartile of all such paths across all the projects line .
finally apex calculates the votes for potential error constraints from each project and picks the constraints which have at least one standard deviation more votes than the average line .
however if the number of such error constraints exceeds maxchoices apex declares the api function as infallible line to .
otherwise apex outputs the selected error constraints as the final error specification.
the paths where the error specification are satisfied are marked as potential error paths.
.
implementation we gathered information about the path features using the clang static analysis framework part of the llvm project and its underlying symbolic execution engine.
we implemented the parsing and processing logic for error specification inference i.e.algorithms and from the path features using python.
our addition to clang consists of 180lines of c code while the steps written in python consist of 063lines as measured using sloccount .
we give an overview of our modifications to clang below.
the clang analyzer symbolically tries to explore all feasible paths along the control flow graph of an input program.
it provides a plat4761castv ote input library function f project that uses library function f proj output candidate error specification for function f c 3countmap 4lengthmap 5foreach constraint con the return value of f proj do 6countmap nbranch proj f c 7lengthmap medianstmtcnt proj f c 8end 9c c countmap avg countmap c stdev 10ifc e atio slash then returnc 12end 13c c lengthmap avg lengthmap c stdev 14ifc e atio slash then returnc 16end 17return algorithm algorithm for extracting potential error constraints from each project 1inferspec input library function f projects that use library function f projs output inferred error specification for function f cf 3votemin lowerquartile npathcnt proj projs 4votemap 5foreachproj projs do ifnpathcnt prog f votemin then c castv ote f proj foreachc c do votemap votemap end end 12end 13ifnchoices votemap maxchoices then returninfallible 15end 16return c votemap avg votemap c stdev algorithm algorithm for error specification mining form for custom third party checkers to monitor different paths and inspect the corresponding path constraints.
a typical checker often looks for violations of different invariants along a path e.g.
division by zero .
in case of a violation the checker reports bugs.
we implement the path gathering process of apex as a checker inside the clang analyzer.
we extended clang s symbolic execution engine to perform underconstrained symbolic execution in each caller function of the api functions.
moreover in its current form clang does not support extracting the path constraints for each path.
we modified clang s constraint manager class to print out the path constraints in text format.
for each path through the caller function explored by the symbolic execution engine we collected the following information i the name of the caller function and the name of the api function s called and the constraints on api function s return values.
ii the number of program statements and function calls along the path.
iii the number of paths satisfying the constraints on the return values.
our current prototype implementation supports three types of constraints for three different data types i a pointer can either be null or notnull ii constraints on an integer are represented bya sorted list of non overlapping ranges and iii a c bool type can be either true orfalse .
table apex analysis times for the 5largest programs in our test set averaged over all library apis when run on a a machine with 2intel xeon2.67ghz processors with 4cores each and 24gb of memory project lines of code average analysis time s clama v 1h 3m 39s pidgin 1h 37m 50s grep 6m 59s gnutls 59m 18s coreutils 26m 08s table shows the performance of apex for the 5largest programs in our data set when run on a machine with 2intel xeon .67ghz processors with 4cores each and 24gb of memory.
for each program library pair we counted the time to gather the paths generate specifications and find bugs.
for each program we show the average times over all the libraries.
.
experimental results in this section we present an empirical evaluation of the ability of apex to correctly infer error specifications of c api functions.
we also evaluate how effective the inferred error specifications are for finding new bugs.
.
study subjects we studied 6c libraries gnutls libgcrypt gtk libc openssl and zlib across 28different projects as shown in table .
overall we analyzed combinations of libraries and software projects.
in general for a given library we analyzed the entire project source code.
however in certain projects only a part e.g.
particular files or modules uses the relevant library functions.
in such cases we analyzed only the relevant parts of the project if we could isolate them.
for example we analyzed only the files that use openssl and libgcrypt for curl the modules that use openssl and zlib for httpd and the applications that are included with openssl using openssl api functions.
in total we studied api functions from distinct call sites.
.
study methodology we measure apex s capability of inferring error specifications in terms of precision and recall.
suppose we analyzed the usage ofeapi functions using apex.
a perfect tool could infer correct error specifications for all the cases in e. however in practice apex will only infer error specifications for apis aand among them only a will be correct.
in this case we define the precision and recall of apex as follows precision.
the percentage of error specifications correctly inferred by apex over the total number of inferred specifications i.e.
a a .recall.
the percentage of error specifications correctly inferred by apex over expected number of the specifications i.e.
a e .
to evaluate the accuracy of apex s classification of error paths we calculate the precision and recall using the same formula.
however in this case e a anda would be the set of all error paths detected error paths and correct error paths respectively.
.
study results we start with investigating how well apex can identify error paths since the accuracy of inferring error specifications depends on this step.
thus we begin with a straightforward question namely 477table details of study subjects project libgcrypt gnutls gtk libc openssl zlib clama v collectd coreutils cryptmount curl diff evince gedit gnupg gnutls grep httpd lighttpd lynx mutt nginx openssh openssl pidgin remmina rsync tar teleport tor totem uget vpnc wget total note each entry contains studied number of functions per library per project and number of unique call sites .
rq1.
how accurately can apex identify error paths?
table accuracy of predicting error paths library precision recall libgcrypt .
.
gnutls .
.
gtk .
.
libc .
.
openssl .
.
zlib .
.
all .
.
table shows that apex can identify error paths with precision and recall.
for the gnutls gtk and libc libraries apex s precision is more than .
apex s precision is over for the libgcrypt and openssl libraries.
however apex does not perform so well for library zlib with a precision of only .
out of the 4mistakes in zlib apis 2were cleanup functions deflateend andgzclose for which apex incorrectly picked the value representing success as the error specification.
our heuristic that error paths are simpler does not tend to work very well for detecting error specifications of cleanup functions as they are usually called at the end of main computation just before returning from the caller function.
therefore neither the error paths nor the non error paths for these cleanup functions performs any significant amount of computation.
we found that apex s recall is more than for libraries libgcrypt gtk libc and openssl.
however for libraries zlib and gnutls apex s recall is significantly lower and26 respectively.
as shown in table we found that the distribution of the zlib and gnutls api functions are not distributed evenly across our test projects.
while several unique gnutls and zlibfunctions appear many times in the gnutls and clama v projects respectively not many functions appear elsewhere.
therefore apex cannot infer error specifications for functions that do not have enough diverse samples.
result apex can detect error paths with precision and recall.
rq2.
how accurately can apex identify api error specifications?
table shows that apex can infer error specifications with precision and recall on average for all the projects.
for all five libraries except zlib the precision varies from to84 .
however for zlib apex s precision drops to .
note that this is not particularly surprising given that apex did not perform well in detecting error paths for zlib as well see table mostly due to the presence of several cleanup functions.
table accuracy of inferring error specifications library precision recall libgcrypt .
.
gnutls .
.
gtk .
.
libc .
.
openssl .
.
zlib .
.
all .
.
apex s recall for inferring error specifications is above for libraries libgcrypt libc and openssl.
the recall is around for the other three libraries.
note that these results closely resemble the recall for error path detection.
as mentioned earlier the drop .
.
.
.
.
call sitesprecision call sites spearman correlation quantile count estimate p val less than less than .
.61e to to .
.
greater than greater than .
.08e all to .
.71e note the table shows that overall precision increases as the number of call sites increases with statistical significance marked with however this trend reverses at lower percentile of the call sites.
a precision0.
.
.
.
call sitesrecall call sites spearman correlation percentile count estimate p val less than .
.
to to .
.
greater than .
.
all to .
.
note the table shows that overall recall increases with statistical significance marked with as the number of call sites increases however this trend is not significant below the percentile in call site counts.
b recall figure the accuracy of inferring error specifications varies significantly with the number of distinct call sites of the api functions.
in recall is primarily caused by the low number of call sites across programs for zlib and gnutls apis.
since apex infers error specifications by learning from multiple call sites next we check how apex s performance varies with the number of call sites i.e.whether apex performs better for the functions with a larger number of call sites.
figure 4a shows the variation of precision with the number of distinct call sites of the tested api functions.
overall as expected we see a positive trend indicated by the blue dashed line i.e.
precision increases with the increase of call sites.
also the spearman correlation is positive .
with statistical significance.
we further inspect this trend at three different ranges of call sites i at lower range with functions having less than 8distinct call sites we see that the precision decreases as the number of call sites increases ii at medium range with functions having to distinct call sites we see a positive trend although it is not statistically significant.
and iii finally at higher range with call sites more than we see a distinct positive trend correlation .
with statistical significance.
a similar trend is observed for recall as well as shown in figure 4b.
overall recall increases with the number of call sites with statistical significance spearman correlation .
.
however it loses the statistical significance in the lower range.
we further compare apex s performance with baseline trivial error specifications for integers and null for pointers.
the following table shows the results.
for integer error return values apex s precision is which is 18percentage points better than the baseline case.
also for pointer return values apex reports95 precision i.e.5percentage points better than the baseline.
overall apex performs 13percentage points better than the baseline.
in particular apex is more effective for integer error types since they can have more diverse error values as compared to pointer error types with only null and non null options.
for library functions like openssl where error specifications are more diverse apex becomes more effective.
for example in openssl apex could detect integer error specifications with precision as opposed to the baseline performance of or an overall percentage point gain in the precision.table comparison of apex performance with baseline performance with trivial error specifications for integers and null for pointers baseline apex integer .
.
pointer .
.
overall .
.
result apex can infer error specifications with precision and47 recall.
overall accuracy increases as the number of call sites increases.
rq3.
how effectively can apex detect missing error checks?
table precision of detecting potential error handling bugs unfiltered filtered real library bugs bugs bugs precision libgcrypt .
gnutls .
gtk libc .
openssl .
zlib .
total .
in order to measure the effectiveness of the inferred specifications in finding error handling bugs we build a simple bug detection scheme using the inferred specifications.
given a fallible api function and its inferred error specification we investigate whether a caller of the api function checks the errors returned by the api function correctly if not we report it as a potential error handling bug.
in table column unfiltered bugs shows the counts.
in total we found 256cases of missing error checks.
however not all missing checks lead to potential bugs.
we randomly selected such cases and manually checked the call site to determine whether 479the error could occur given the information we can observe about the caller function up to the call.
if so we classified the missing check as a potential bug.
in practice the bug might still not occur because of checks further up the call trace or configurations that eliminate potential failures.
we concluded that only 36of them can be potential bugs.
most of the errors are caused due to either incorrectly inferred error specifications e.g.
libc function strerror is actually infallible but was incorrectly classified by apex to have an error specification of null or for functions which only fail if they are called with incorrect input values e.g.
libgcrypt function gcry cipher setiv .
in order to detect error handling bugs with more serious consequences we filter out functions whose return values are unchecked for a significant majority of the call sites in a function.
by significant we mean as in our error specification voting scheme that the number of call sites that never check the return value is at least one standard deviation higher than that of the remaining sites.
we further excluded the library gtk in this step as most of the gtk api functions only return error when invoked with invalid inputs and most of the input values are already checked before calling the api functions.
the third column of table see the column filtered bugs shows the reported bugs.
in total we reported missing error checks and a manual investigation reveals of them as potential error handling bugs.
thus overall we can detect potential error handling bugs with .
precision.
among them we performed best for zlib with a precision of .
we performed poorly for libgcrypt functions with only .
precision due to the prevalence of formatting functions such as gcry mpi scan that never fail when invoked with a valid format string.
we are now in the process of reporting these bugs to the developers.
so far we have reported bugs.
among them have already been patched by the developers.
we provide the details of three example bugs that developers confirmed in table .
example of table shows that the return value for openssl api function ssl ctx new was stored in data ctx without any checking.
it subsequently was passed as an argument into the api function ssl ctx set options .
the latter function would crash when a null pointer is returned by a failed call to ssl ctx new .
apex detected instances of this bug in projects lynx and mutt.
all the instances are acknowledged by the corresponding developers.
the mutt developers have already fixed the code while the lynx developers are in the process of fixing it.
example of table shows a bug found in project pidgin where a check was missing for the gnutls api function gnutls x509 crt init .
in case of a failure the function returns an error and a missing check renders the certificate certdat crt invalid.
the developers acknowledged and fixed this bug.
given the security sensitive nature of this bug the developers have also reserved a cve id common vulnerabilities and exposures identifier4 cve for it.
finally for libgcrypt example apex found instances of missing checks for api function gcry control in projects collectd remmina and vpnc.
gcry control is a variadic function that takes at least one argument and is fallible for arguments gcryctl set thread cps andgcryctl init secmem .
the latter is of particular importance not only for enabling secure memory but also dropping program privileges5.
currently we have one acknowledgment for this kind of bug from the devel3 samples of confirmed error handling bugs reported by apex.
example library openssl projects lynx mutt api function ssl ctx new status acknowledged and fixed static int ssl socket open connection conn ... data ctx ssl ctx new sslv23 client method disable ssl protocols as needed if !option opttlsv1 ssl ctx set options data ctx ssl op no tlsv1 ... example library gnutls projects pidgin api function gnutls x509 crt init status acknowledged fixed and cve being requested staticpurplecertificate x509 import from datum constgnutls datum t dt gnutls x509 crt fmt t mode ... gnutls x509 crt init certdat crt ... example library libgcrypt projects collectd remmina vpnc api function gcrypt control status acknowledged and fixed in remmina gcry control gcryctl set thread cbs ... gcry control gcryctl init secmem ... ... opers at remmina who used the gcryctl set thread cbs command and have fixed the bug.
result using apex s error specifications new errorhandling bugs were detected.
we found that incorrect error handling is pervasive for certain api functions.
in fact errors in such api functions are routinely ignored in the majority of their call sites.
table shows some examples from openssl and gnutls libraries where more than of their call sites fail to perform correct error handling.
table sample api functions for which of the call sites performed correct error checking library function call sites with correct error checking gnutls gnutls x509 crt get dn by oid opensslx509 name get entry ssl shutdown ssl write ssl do handshake ssl get privatekey .
related work static detection of error handling bugs.
static code checkers take source code and invariants as input and determine whether the specifications are violated .
there is a long line of work issuecomment 480using static analysis techniques for detecting different types of bugs including security bugs .
in this paper we primarily focus on techniques whose primary goal is to find error handling bugs.
there are several prior projects that designed specialized static bug finding tools for finding error handling bugs.
for example rubio gonz lez et al.
and gunawi et al.
created static bug finders for detecting error handling bugs in linux file system code.
lawall et al.
built and evaluated another static bug finding tool for finding error handling bugs in secure sockets layer ssl implementations.
weimer et al.
have developed bug finding tools for finding exception handling bugs in java programs.
robillard et al.
have built tools for simplification and visualization of exception handling flow that can help developers minimize mistakes in exception handling code.
the error specifications inferred by apex can be used with existing bug finding techniques like the ones described above for finding error handling bugs.
dynamic fault injection.
as error conditions rarely appear during regular operation finding error handling bugs is hard using regular testing methods.
to avoid such issues researchers have used fault injection to dynamically exercise error handling code in a program by injecting synthetic failures.
marinescu et al.
have developed a general purpose fault injection infrastructure for running tests with injected faults .
broadwell et al.
applied fault injection to test the recovery mechanisms of live systems while s kraut et al.
used fault injection for determining where patches are required to insert proper error handling code .
however all these fault injection techniques require fault profiles for deciding which functions can fail and what values will be returned in case of failures.
apex can make dynamic fault injection techniques completely automated as the fault profiles can be auto generated from the error specifications.
specification mining.
the closest work to ours for automatically mining error specifications is by acharya et al.
.
however they assumed that error handling code must be completely contained inside a branch statement conditional on the return value of an api function and must have an explicit return exit statement.
in such cases they identify the corresponding branch condition as the api s error specifications.
however unlike apex this heuristic does not work for functions that can return multiple error or nonerror values.
also unlike us they used a data flow insensitive code analysis technique based on that limits their accuracy.
rubio gonz lez et al.
and marinescu et al.
have used program specific heuristics e.g.
a fixed range of error values treating all compiler generated constants as error codes to infer api error specifications in their respective settings that do not work across different libraries programs.
unlike these techniques apex focuses on inferring the api error specifications i.e.the range of possible error values from a large number of programs in an automated manner that works for a diverse set of apis projects.
several prior research projects have mined different types of specifications from source code to help software developers.
for example buse et al.
try to aid developers in properly handling errors by inferring the exact causes of the exceptions .
acharya et al.
attempted to learn the proper order for calling api functions while nguyen et al.
focused on automatically discovering api preconditions.
more generally for inferring proper programming practices engler et al.
sought to infer assumptions that the programmer makes and check if any code contradicts such beliefs.
weimer et al.
assumed that the programmer s desired specifications can be inferred specifically from normal presumably nonbuggy code and then compared against potentially buggy exceptional cases .
our work complements these projects by focus ing on automated inference of error specifications that can be used to find bugs in error handling code.
another line of research tries to automatically infer api specifications from documentation e.g.
user manuals comments etc.
using natural language processing .
however unlike mining specifications from api usage these approaches are susceptible to errors omissions in documentation.
.
threats to v alidity external validity.
external validity concerns the generalizability of our result.
the effectiveness of our technique may be limited by the representativeness of our data set.
to minimize this threat we tested our technique on functions from 6popular open source apis across programs.
however other apis that are closed source or more specialized might have their own requirements for handling errors that contradict our observations.
construct validity.
apex works on the assumption that error paths have distinct features from non error paths.
however this may not be true for all functions.
in fact we already observed two types of functions that are different cleanup functions and infallible functions returning invalid looking values.
as we observed before half of the false error specifications in zlib are cleanup functions and other functions that come at the end of the caller.
while we still expect the error handling code to be minimal the normal path is likely going to be even simpler for the cleanup routines because the caller intends to use them at the end of a task.
infallible functions could return values that appear invalid and need to be checked but not due to failures of the function.
for example boolean return values from infallible functions are almost always used in conditional statements.
if one value leads to more complex branches the function may be classified as fallible as was the case ofgtk widget get visible in gtk .
likewise memset andmemcpy from libc return the first parameter which could be null .
if the caller decides to check it after the call the null value would be attributed to a failure of the api function.
to minimize such threats we perform an empirical study in section and show that for the majority of the api functions error paths indeed show distinctive traits.
internal validity.
the precision of our bug finding results is based on the authors judgment.
although multiple authors verified the bugs we are planning to report these bugs to the corresponding developers and already have started the process.
as mentioned earlier several of them have already been acknowledged and fixed by the developers.
.
conclusions in this paper we introduced apex a tool for automatically inferring the error specifications of api functions based on the insight that error paths are often simpler than regular paths i.e.they have lower numbers of branches statements and functions .
we evaluated our technique over 28projects using 6popular libraries and demonstrated that our technique can accurately infer error specifications for different api functions.
we also used the inferred specifications to find 118previously unknown potential error handling bugs in the 28tested projects.
.