extracting visual contractsfrom java programsabdullah alshanqiti amma2 mcs.le.ac.ukreiko heckel department of computer sciencesleicester university ukreiko mcs.le.ac.ukabstract visual contracts model the operations of componentsor services by pre and post conditions formalised as graphtransformation rules.
they provide a precise intuitive notationto support testing understanding and analysis of software.however due to their detailed specification of data states andtransformations modelling real applications is an error proneprocess.
in this paper we propose a dynamic approach to reverseengineering visual contracts from java based on tracing theexecution of java operations.
the resulting contracts give anaccurate description of the observed object transformations theireffects and preconditions in terms of object structures parameterand attribute values and their generalised specification by uni versally quantified multi objects.
while this paper focusses onthe fundamental technique rather than a particular application we explore potential uses in our evaluation including in programunderstanding review of test reports and debugging.i.
introductionvisual contracts vcs provide a precise high level speci fication of the object graph transformations caused by invoca tions of operations on a component or service.
they link staticmodels e.g.
class diagrams describing object structures andbehavioural models e.g.
state machines specifying the orderoperations are invoked in by capturing the preconditions andeffects of operations on a system s objects.visual contracts differ from contracts embedded with code such as jml in java or contracts in eiffel as well asfrom model level contracts in ocl.
they arevisual usinguml notation to model complex patterns and transformationsintuitively and concisely and theirexecutable semanticsbasedon graph transformation supports model based oracle and testcase generation run time monitoring service speci fication and matching state space analysis and verification.however creating a detailed model in any language is error prone.
visual contracts are no exception and their specifi cation of object states and transformations requires a deeperunderstanding of a system than models of externally visiblebehaviour.
this limits their applicability in testing verificationand program understanding in general.in this paper we propose a dynamic approach to reverseengineering visual contracts from sequential java programsbased on tracing the execution of java operations.
the result ing contracts give accurate descriptions of the observed objecttransformations their effects and preconditions in terms ofobject structures parameter and attribute values and allowgeneralisation bymulti objects.
the restriction to sequentialjava is due to the need to associate each access to a uniqueoperation invocation.given a java application the process starts by selectingthe classes and operations within the scope of extraction andproviding a set of test cases for the relevant operations.
weproceed by a observing the behaviour under these tests usingaspectj instrumentation and synthesising contract instancesas pre post graphs of individual invocations b combiningthe instances into higher level rules by abstracting from non essential context c generalising further by introducing multiobjects and d deriving logical constraints over attribute andparameter values.first solutions to variants of a and b were reportedin respectively.
apart from general performance im provements in the individual algorithms and their integrationin a prototype tool the dynamic analysis a was extendedby traceability of contract instances to code recording accessand changes to attribute and parameter values and producingcontract instances in a format that could be fed into the initialstep b of the learning.
the latter originally relied on bothpositive and negative examples so had to be adapted to makedo with positive examples only as produced by a .
supportfor operations with parameters was also added.
steps c and d extending the learning of basic contracts by multi objectsand attribute constraints are discussed here for the first time as is an experiment on the usefulness of visual contracts fortesting and debugging.following a general presentation of the notions and tech niques of the approach in sect.ii sect.iii adescribes theprototype tool implementing them.
the evaluation in sect.iiidiscusses the scalability of the extraction as well as thevalidity of the resulting models and their utility in programunderstanding in the context of testing and debugging.
apartfrom their use in validation case studies and experiments arechosen to exemplify potential applications in this area withoutclaiming that the present tool could support real world use.after discussing related work sect.vconcludes the paper.ii.
extractingvisualcontractsthis section gives an overview of the approach using a sim ple case study of a car rental service designed to represent arange of different preconditions and effects of operations overa complex object structure including the creation of objects the creation and deletion of links as well as attribute updates 30th ieee acm international conference on automated software engineering .
ieee public interfaceirentalextendsserializable publicstring registerclient string city string clientname publicstring makereservation string clientid string pick up string drop off publicvoid cancelreservation string reference publicvoid cancelclientreservation string clientid publicvoid pickupcar string reference publicvoid dropoffcar string reference publicreservation showclientreservations string clientid publicclient showclients string city publiccar showcars string city listing interface of a car rental serviceand constraints.
basic concepts of graph transformation areintroduced following .an interface with the relevant operations is given inlist ing .
the class diagram in the top left offigure 1shows theselected classes whose instances will be observed.
classesand data valued attributes in the diagram map to classes andattributes in java.
associations with cardinality1at the targetrepresent object valued attributes in their source class andassociations with cardinality are implemented by containers.formally a class diagram is represented as anattributedtype graphtg i.e.
a distinguished graph defining vertex edge attribute and data types from which object graphs can beconstructed.
anobject graphovertgis a graphgequippedwith a structure preserving mappingg tgassigning everyelement ingits type intg.a.
observing access and synthesising contract instanceswe adopt a dynamic approach to extract for each oper ation invocation acontract instancecapturing the observedbehaviour.
observations are made by weaving instrumentationcode using aspectj.
this results in a trace recording theobject creation read and write access to objects and attributescaused by the active invocation.
concurrent invocations createthe problem of identifying for each observation the relevantinvocation and are therefore not considered.
we aggregateobservations into a contract instance capturing the overallprecondition and effect of the invocation see for moredetails .
along with the instance we collect traceability datafor its elements such as the line numbers in the code causingfor their access.
this is used later to validate the extraction e.g.
to assess which code fragments are captured by whichcontracts.consider the contract instances infigure .
instancereg isterclientcreates a new client object registers it with thebranch atcity and updates attributebranch.cmax.
instancemakereservationbooks a car for a client by creating a newreservation objectrwith linkspickup dropoff madeandfor.linksofandatindicate that a client can reserve cars from thepickupbranch they are registered with.
instancespickupcaranddropoffcardescribe the movement of a car from thepickupto thedropoffbranch.as can be seen in the example a contract instance consistsof a pair of object graphs representing the situation before andafter the operation.
we writeb op a1 ... an g hto indicate the invocationop a1 ... an of an operationwith signatureop x1 t1... xn tn tleading to atransformation ofgintoh.
we assume thatg hlive in acommon name space given by unique object identities so theelements deleted preserved and created by the transformationareg h g handh g respectively.
fig.
type graph and rule instances extracted from car rentalserviceb.
deriving minimal contracts and shared contexteach contract instance only represents one invocation butof course our aim is to derive a small set of contracts thatdescribe the overall behaviour as precisely as possible.
sucha general contract is given by a set ofparametrised rulesop x1 ... xn y l rover the same operationsignature with graphslandr c a l l e dt h eleft andright handsideof the rule expressing the pre and postconditions of theoperation.
as beforel r l randr lrepresent theelements deleted preserved and created by the rule.to derive such a general model we consider all instancesrepresenting executions of the same operation.
first we gen erate aminimal rulefor each instance i.e.
the smallest rulecontaining all objects referred to by the operation s parametersand able to perform the observed object transformation.
theconstruction has been formalised in and implemented without considering parameters in .
formally given acontract instanceb op a1 ... an g hits minimalrule is the smallest rulel rsuch thatl g r hwitha1 ... an landb ras well asg h l randh g r l. that means the rule is obtained fromthe instance by cutting all context not needed to achieve theobserved changes nor required as input or return.the result is a classification of instances by effect allinstances with the same minimal rule have the same effect but 105possibly different preconditions.
these are in turn generalisedby one so calledmaximal rulewhich extends the minimal ruleby all the context that is present in all instances essentiallythe intersection of all its instances preconditions.figure 2shows an example of this generalisation where maximal rule c results from instances a and b ofcancelclientreserva tion .. .
the shared effect in both cases is the deletion of thereservation object connected to the client and the minimalrule is identical to b .
the isolatedr1 reservationobject in a arises from an unsuccessful test onr1when searching forthe reservation object to be cancelled.
fig.
extracting maximal rules from contract instances fig.
inferring mos from contract instancesbut minimal or maximal rules are not just generalisationsof instances but provide a constructive specification.
givenan object graphg a rule can be applied if there is a matchm l g such thatlis isomorphic to a subgraph ofgand removing an image of l rfromg the resultingstructure is a graph.
the derived object graphhis obtainedby adding a copy ofr l. unsurprisingly applying a ruleextracted from a contract instanceb op a1 ... an g hto the pre graphgof that instance we obtain its post graphh but we can also apply the same rule to other given graphsderiving transformations not previously observed.c.
introducing universally quantified multi objectsthe contracts extracted so far may use a number of rulesto describe the same operation.
in the case of iteration overcontainers for example the set of minimal rules is potentiallyunbounded but some only differ in the number of objectsmanipulated while performing the same actions on all ofthem.
rules with multi objects mos provide a concise wayto specify constraints and actions across sets of objects ofdifferent cardinalities.amulti object mo ruledistinguishes a setm lof monodes with cardinality constraintscard m p i ln statinghow many concrete objects each mo can be instantiated by.application of mo rules is defined by expanding mo nodesinto sets of regular nodes.
an expansion of an mo rule isa regular rule obtained by successively replacing each monodem m card m cbyc m copies for somec m c. this includes copying all incoming and outgoing edges sothat for each nodem mand chosenc m we getlmas lmv lv m unionmulti m ... c m and lme le le m unionmultile m ... c m wherele m e srcl e m tarl e m is theset of edges attached to nodem.
sources targets and typesof new edges and nodes are inherited froml.
the expansionextends toron the mo nodes shared withl.
due to theassociativity of the product up to isomorphism the resultingrule is essentially independent of the order of the mo nodesexpanded.
note that for two mo nodesm1 m2connected byan edge we will createc m1 c m2 edges between the copiesofm1andm2.
anapplication of an mo ruleto an objectgraphgis an application of a maximal applicable expansion.for example nodereservationinfigure c is anmo node shown with a 3d shadow with cardinality1.. applicable to object graphs with or 2reservationnodes con nected to theclient.
contract instances of two correspondingtransformations are shown infigure a and b .to derive mo rules from such instances we have to discoversets of nodes that have the same structure and behaviour thenrepresent them by a single multi object node.
we only considermulti object nodes that are part of the minimal rule becausetheir typical use is to describe universally quantified effects rather than preconditions .
in the rule instancefigure b for example bothreservationnodes have the same context i.e.
they both point to the sameclientnode by amadeedge and they are both connected toreturn collectionon the right hand side so share the same behaviour.
therefore they aresubstituted by one multi object as shown infigure c which also generalisesfigure a with only one occurrence.after inferring multi objects within individual rules if two morules are isomorphic the two original rules can be replacedby a single mo rule with appropriate cardinalities reflectingthe generalised cases.two objects areequivalentif they are of the same type part of the minimal rule and have the same context incident edges of the same type connected to the same nodes in the pre and postcondition thus specify the same actions .assuming for every operationopa set of maximal rulesr op as constructed in sect.ii b we derive mo rules in two steps.merge equivalent objects for each rulem r op and eachnon trivial equivalence class of objects inm one object ischosen as the representative for that class and added to the set 106of mo nodes form while all other objects of that class aredeleted with their incident edges.
the cardinality of the monode is defined to be the cardinality of its equivalence class the number of objects it represents .
the resulting set of morules ismor op .combine isomorphic rules a maximal set of structurallyequivalent rules inmor op differing only in their objectidentities and cardinalities of their mo nodes forms anisomorphism class.
for each such class we derive a single ruleby selecting a representative mo rule and assigning to each ofits mo nodes the union of cardinalities of corresponding nodesin all the rules in the class.
the resulting set of combined morules iscmor op .
an example is the derivation offigure c a combination of basic rulefigure a with the morule derived from b whose cardinalities of1and2for thereservationnode are merged to1.. .d.
deriving constraints on attributes and parameter valuesso far we have focussed on structural preconditions and ef fects disregarding the data held in objects attributes or passedas parameters.
however at implementation level manipulationof object structure and data are tightly integrated.
while wehave seen that the structural view is naturally expressed bygraphical patters constraints or assignments over basic datatypes are more adequately expressed in terms of logic.the contract forcancelclientreservation cid string de scribes the removal of areservationobject linked to theclientwhoseidmatches the parametercid.
in the contractthis is expressed by the equalityid cidin theclientobject.
formally c.idandcid as well as the right hand sidecounterpartc.id primeofc.id are local variables of the contractthat get instantiated by the match as part of an application.in particular given a graph objectgand matchm l g c.idis instantiated by the value of theidattribute ofm c i.e.
m c.id m c .id.
in a similar way we can extendmtoevaluate complex expressions and use these in assignmentsto update attributes.
the formalisation in attributed graphtransformation assumes an abstract data typeaas attributedomain linking it to the structural part by attribution maps.let us consider how attribute constraints for contracts can belearned.
say an instancei has attribute and parameter valuesai i.e.
these values wereeither read or written during the corresponding invocation .
amaximal ruler generalisinga number of instances with shared effects is given a setxof local variables for all formal parametersx1 ... xnand allattributes read or accessed by all its instances.
since maximalruleris embedded by a matchmiinto every instanceiitsubsumes this extends to an assignment of the local variablesmi x gi.fixing an order on the variablesx eachmibecomesa vector of values to be fed into a machine learning toolcapable of driving logical constraints.
we use the daikontool designed for the derivation of invariants over programvariables.
from the assignmentsmifor all instancesithat con tributed to the construction of rulerdaikon generates a set ofconstraints that are valid for all assignments.
these constraintsare fed back into the graphical part of the contract whereeach becomes part of the pre or postcondition depending onwether the variables used occur only inlor inl rand theparameters.
this approach allows the separation of structuraland constraint learning.iii.
eva l uat i o nin this section we illustrate the implementation of theapproach by a proof of concept prototype and discuss correct ness and completeness of extracted contracts.
we report onexperiments to assess the utility of visual contracts and thescalability of the extraction as implemented by the prototype.a.
prototype toolthe approach is implemented by a tool whose high levelarchitecture is shown infigure .
it consists of a tracerobserving the behaviour of selected classes using aspectjand constructing contract instances cf.subsection ii a ageneraliser learning minimal maximal and mo rules cf.subsection ii bandii c using daikon to learn constraints cf.subsection ii d both supported by a database connectionand a visualiser for selective display and analysis of contracts.an export to the graph and model transformation tool hen shin is used to simulate contracts for validation.
first wefocus on the visualiser to illustrate how results are presentedand how they could be used to aid program understanding.
fig.
architecture of the toolthe main task of the visualiser seefigure is to organise browse and display extracted contracts.
to this end we support the distinction in colour and style between elements ofthe minimal and larger maximal rule e.g.
dotted edgesand nodes with grey background represent elements ofminimal rules while nodes with white background andsolid edges are context elements the alternative display of collections as to associationsor using explicit collection objects the selective visualisation of rules for example of theminimal rule or the precondition only.figure 4shows two screenshots of the main interface.
in a we present an instance extracted frommakereservation infigure .
the upper part of a gives information onthe operation signature actual parameters and the extractionprocess.
apart from the rule showing the precondition andeffect at a high level we provide information on the accessto individual objects with the corresponding locations in the a rule instance b generalised rules interfacefig.
visualiser interfacecode.
they are available through a pop up window like the oneinfigure 6activated by clicking on the reservationnode inthe right hand side of the contract.figure b shows how generalised maximal and mo rules are displayed.
the top left shows a list of the rulesorganised by their operation signatures.
when selecting e.g.
a maximal rule all its rule instances will appear in thetable see the top right of b .
the lower part shows themaximal rule with multi objects and attribute constraintsforregisterclient that describe the relation between attributevalues input and return parameters.
for example the 4thconstraint states that the value of thecidis returned whilethe 5th requires that thecnameattribute of the new client fig.
object access and code locations a left hand side of maximal rulecancelclientreservations b left hand side with multi object extracted from a fig.
extraction of rule with multi objectobject has the same value as the 2nd parameter.
an exampleof a rule with multi object is shown infigure b as extractedfrom the maximal rule in a forcancelclientreservations .b.
correctness and completenessin order to establish to which extent the contracts extractedprovide an accurate description of the software s behaviourwe consider two directions thecorrectnessandcompletenessof the contracts.
for every statesin the implementationthere exists a corresponding object graphg s at model levelobtained by representing all objects in the scope of observation i.e.
that are instance of the classes selected for tracing cf.
start ofsection ii as nodes object valued attributes asedges and data valued attributes as node attributes.
then amodel iscorrectif for every valid statesand invocationin a stepin g s hin the model implies a stepin the implementation from statesto a new states primesuchthath g s prime .
that means the model does not allowbehaviour that is not implemented by the system.
conversely completenessmeans that for each valid states a step causedby an invocationinof the implementation leading to a states primemust be matched by a stepin g s g s prime in the model i.e.
all the system s behaviour is captured by the model.in general the models extracted will be neither correct norcomplete.
correctness fails because the model is extractedfor a certain part of the system only as identified by theimplementation classes selected for tracing.
anything outsidethis scope of observation is not recorded and therefore notrepresented by the model.
that means if the implementationchecks a condition on the state of an object outside scope this check is not reflected in the precondition of the contract.if this check fails a step in the model may not be reflectedby a step in the implementation.
a weaker condition takinginto account this limitation is that ofmoderated correctness.it states that if both preconditions are satisfied the observableeffect of the implementation level step should match the effectof the model level step.
here the comparison is moderatedvia the the mappingg of implementation states to objectgraphs which also takes account of the scope.completeness fails for the same reason that test cases cannotprove the correctness of a system.
the dynamic approach toextracting contracts is inherently dependent on the range of be haviours observed and behaviours that have not been observedwill not be reflected in the model.
so what can we realisticallyhope to achieve?
a minimal notion of completeness shouldrequire that all observed behaviours are represented in themodel i.e.
when executing the tests the model was extractedfrom all steps steps in the implementation should be matchedby the model.we used manual inspection on the car rental service casestudy to validate if the models extracted by the tool satisfy thebaseline moderated notions of correctness and completeness.the limited amount of code and our familiarity with theapplication allowed us to perform a detailed review for everymethod in the interface validating for all execution paths thatthere exists a rule in the corresponding contract capturing thepath s combined precondition and effect and vice versa forevery rule that the behaviour described is fully implemented.this process was aided by the export of extracted contracts tothe henshin model transformation tool which providesa facility to simulate contracts based on their operationalsemantics as graph transformation rules.consider the source code fragment inlisting 2implement ing thedropoffcar method.
there are three possible pathsleading to at least three different contracts depending onthe evaluation of the twoifstatements in lines and .when executing this method by three test cases that cover allstatements the extracted rules reflect the expected behaviours.this is confirmed by tracing the line numbers in the coderesponsible for the access to objects in the contracts.figure 8shows the left hand sides of the three rulesextracted fromdropoffcar .
for example a reflects thebehaviours of statements as we pass an invalidreser vation idand accordingly the execution breaks at line .the rule correctly describes the access tothis rentalandthereservationcontainer.
in b the parameter is valid i.e.
thereservationobjectleicester13exists but the executionbreaks at line since the car has not been picked up yet.this can be seen from thepickuplink which would have been 109deleted otherwise.
the rule in c reflects correctly the thirdpath i.e.
the conditions in and are false so there is noreturn from the method there.1publicvoid dropoffcar string reference 23intiindex getreservationindex reference 4if iindex 5return 78reservation getreservation this.reservations.get iindex check if reserved car has been picked up already10if getreservation.pickup!
null 11return return reserved car to the drop off branch15getreservation.dropoff.at.add getreservation.for remove reservation object17this.reservations.remove iindex listing implementation of dropoffcar method a rule instance extracted from lines b rule instance extracted from lines without line c rule instance extracted from all lines except fig.
rule instances fordropoffcar more generally due to the method of model extraction andassuming it was correctly implemented in our prototype tool we can assert that model and implementation should show thesame behaviour at least for the test cases used.
in particular contract instances capture precisely the preconditions andeffects relevant to the invocation they are derived from within the scope of observation minimal rules capture exactly the effect of contract in stances they are extracted from maximal rules subsume all contract instances they derivefrom i.e.
every contract instance can be replicated as anapplication of the maximal rule rules with multi objects are more concise but equivalentto the sets of maximal rules they derive from i.e.
byretaining the original rules cardinality information theydescribe exactly the same set of transformations the parameter and attribute constraints derived do notinvalidate any of the contract instances their maximal ruleoriginates from.the fact that in general models are only representative ofthe behaviour they were extracted from is an obstacle to someapplications such as their use in verification where automatedextraction has to be followed by a manual review and com pletion of contracts.
in the following section we demonstratean application to program understanding in the context oftesting and debugging that does not rely on completeness orcorrectness beyond the set of tests executed.c.
utility in assessing test reports and localising faultsusing the car rental service case study we conducted anexperiment to evaluate the utility of visual contracts extractedfrom the execution of test cases for analysing test reports andidentifying faults.
in this paper based exercise our hypothesiswas that visual contracts rather than textual representationsof the same information improve recall and accuracy ofdetecting faults in test reports .
generally we wanted to findout how visual contracts help developers and for which kindsof faults they are most effective.to conduct the experiment an implementation of the rentalcar service was documented in natural language seeded with8 faults and provided with several short test cases able todetect them.
tests were executed and results recorded intwo different formats a as sequences of invocations andreturns of operations from the interface with queries added todisplay details of the internal state after each step and b assequences of visual contracts extracted from the same invoca tions.
students were asked to identify invocations wherethe observed behaviour deviated from the expected based onthe documentation and locate the faults responsible in thecode provided.
both groups received reports from tests of4 invocations each containing a total of failures to betraced down to the seeded faults.the participating students were volunteers from anmsc module on uml based design implementation andtesting of service oriented architectures running february may at the university of leicester.
we could use data frompreviously submitted coursework one on modelling and oneon implementation and testing to check that the average levelof qualification of participants in both groups was comparable.the groups a and b were selected randomly handing outworksheets a and b alternatingly resulting in students 110in group a with an average coursework mark of .
and34 students in group b with an average coursework mark of68.
.
from the module the students were broadly familiarwith the concept of specification based testing of serviceinterfaces like the one provided.
the car rental serviceinterface its documentation and the two types of assignmentswere introduced to all students in a min session prior tothe experiment.
the participants then had mins under examconditions to analyse test reports detect and document failuresand locate the corresponding faults in the code provided.group a achieved an avg.
recall of .
identifying .7out of the faults and an avg.
precision of .
with .7correct out of .
responses .
group b had an avg.
recall of .
correctly identifying .
out of and an avg.
precision of0.
with .
correct out of .
responses .
this representsa factor of improvementrecall b recall aof0.
.
.4andprecision b precision aof0.
.
.
.
in bothcases the t test for independent two sample experiments forunequal variances and population sizes showed that the resultsare statistically significant with a probability p value of .033for recall and .
for precision.
the p value was calculatedusing an online tool1for a degree of freedom of the sum ofpopulation sizes a significance level of .
and a one tailed hypothesis there is a reasonable expectation that groupb would perform better than group a .
that means assumingthe null hypothesis that the different representations of testreports in both groups have no effect on the resulting scores is true there is a .
resp.
.
probability of observing thesame results due to random sampling error.
the key figuresare summarised intable i.2table i statistical data for groups a and brecallprecisiona mean0.
.232a std dev.
.
.212b mean0.
.35b std dev.
.
.209t test1.
.284p value0.
.013we investigated more closely which faults in which oper ations were detected more frequently by which group.
thenumbers are too low to have statistical significance but suggestthat the differential benefit of using visual contracts is greaterwith faults that involve structural features rather than thosethat concern attributes and parameter values only such as makereservation does not check theoflink betweenbranchandclientobject dropoffcar does not remove thereservationobject.the visual representation seems to be less effective for de tecting faults in postconditions than in preconditions.
in fact there are two examples of structural postcondition faults thatwere detected with higher frequency by group a than b i.e.
1social science statistics p value from t score calculator documents and instructions handed out to both groups as well asthe raw data and detailed calculations are available at all reservations for the rel evant client rather than only the one specified by theparameter pickupcar does not delete thepickuplink.indeed to understand the structural effect of a rule we haveto spot the differences between its left and right hand side which can be difficult if the structure is complex and thereare several changes.
this could be addressed for example byusing different colours to highlight changes.the highest relative benefit of visual contracts dis coveries in group b vs. in group a was observed forregisterclient see top right offigure where accordingto the documentation the client id returned should have beenformed ascity branch.cmaxwhile in fact wascomputed ascity branch.of.size using the size ofthe client list rather than the next free client numbercmax.to detect this problem requires matching information from preand postcondition including the navigation of the link betweenclientandbranchobject and the return value.
indeed oneadvantage of visual representations is that they are not linear and so able correlate items of information across more thanone dimension.threats to validity while it is unlikely see above thatresults are due to random error the design of the experimentitself could have biased the outcome.
the self selectionof participants may have resulted in groups that are notrepresentative of the software developers normally concernedwith testing tasks or could have provided an advantage to oneof the groups.
however testing is often performed by juniordevelopers.
many of our msc students mostly internationalwith a broad range of backgrounds would expect to go intoentry level developer roles after graduation.
as stated earlierwe checked that both groups were equally capable based ontheir academic performance on a related msc module thatmatched well with the expertise required in this task.the relatively poor performance overall is a cause for con cern.
we believe this is due to the limited time to understandand perform a quite complex task and the lack of practicalexperience of the participants but also caused by the paper based nature of the exercise where a debugging tool providingsimilar representations in a more interactive navigable waycould improve outcomes.
it is worth stressing however thatthe study does not claim the visual approach to be effective inabsolute terms only that it works better than the textual onein this artificial setting.
this indicates that it might provideadvantages in related practical tasks as well but this is yet tobe demonstrated.there could be bias in the representation of information toboth groups.
of course since the hypothesis claims that thevisual representation is more useful this unfair advantage isintended.
apart from that the information provided is equiva lent invocations with actual parameters and returns are showntextually in both cases only information on the internal state object structure and attribute values is represented differently in group a by query operations listing all accessed objects andtheir state and in group b by visual contracts extracted.
111the choice of case study with its dominance of structuralfeatures and their manipulation rather than computations ondata limit the validity of results to just such applications.
thisis justified by the fact that this is the natural domain for visualcontracts.
the nanoxml and jhotdraw case studies providefurther examples of that nature.d.
scalabilitywe use two case studies to evaluate scalability to largenumbers of invocations and large object graphs.
the casestudies are based on nanoxml and jhotdraw3 both popularbenchmarks for software testing and analysis and representa tive of the kind of system our method would be appropriatefor i.e.
with significant and dynamic object structures in theircore model.
in nanoxml this is the object representation ofthe xml tree for jhotdraw that of graphics objects.nanoxml is a small non validating xml parser for java which provides a light weight and standard way to manipu late xml documents.
we use version .
.
which consistsof three packages and java classes.
we focus on twoclasses xmlelementandxmlattribute which provide thefunctionality to manipulate xml documents.
we monitor allxmlelementmethods executing test cases in order toevaluate the handling of large numbers of invocations.
theoriginal test cases were generated by codepro4 some modifiedand completed manually to improve coverage.
these testscover out of instructions.
infigure 9we plotthe time taken to execute different batch sizes of tests from59 to .
each test generates a single rule instance fromwhich minimal and maximal rules multi objects and con straints are extracted.
tracing contract instance constructionand extraction of minimal rules are essentially linear as is thederivation of constraints and multi objects.
the constructionof maximal rules requires to compare all rule instances withshared minimal rules which is quadratic in the number of ruleinstances that share the same effect.
fig.
scalability for extracting contracts from nanoxmljhotdraw is a java gui framework for technical andstructured graphics developed as an exercise in good softwaredesign using patterns.
we used version .
which has 2433see junit test case generator focussing on the top level methods for the manipu lation of graphs such as .addfigure .. .deletefigure .. .copyfigure .. .decoratorfigure .. and all undoable ac tions in .commandmenu.actionperformed comexe .
we usegui testing using windowtester5to generate test cases byrecording user interactions.
we executed test cases thatcover of instructions.
based on the recorded testcases the total runtime of the extraction is about hours 15mins.
scalability is analogous to nanoxml seefigure but the quadratic component of maximal rule extraction is lesssignificant due to the smaller overall number of rule instances.
fig.
scalability for extracting contracts from jhotdrawunlike nanoxml where the number of invocations con tract instances is large but the size of each contract instancesmall jhotdraw produces contract instances up to severalhundreds of objects.table iishows the number of objectsaccessed number of instances maximal rules and rules withmo created with total size in terms of numbers of objects .table ii jhotdraw objects accessed and processed forconstruction of contractsexecutedinstancemaxmoexecuted method signatureobjectsrulesrulesrulescopycommand.execute 0add figure 0deletecommand.execute decoratorfigure.decorate figure 0undoablecommand.execute number and size of rulesbased on these results we conclude that scalability may beacceptable for batch processing moderately sized test suites but not necessarily for interactive testing.
in applications toprogram understanding and debugging however where thehuman effort is significant the time taken to prepare a moreeffective representation for inspection is likely to pay off andour user study indicates that such benefits may be expected.the number of cases where multi objects could be identified isrelatively small out of maximal rules but they covereda large number of objects that may be hard to survey withoutthis added level of abstraction.the overall evaluation provides some confidence in thevalidity of the technology the usefulness of the results andthe scalability of the tool but these aspects were evaluated5a tool to record gui tests for swing applications 112through separate experiments on a range of different cases.there is no direct evaluation of the usability of the tool orof the absolute effectiveness of the approach in applicationsto program understanding and testing because such claims arebeyond the scope of the paper.iv.
relatedworkreverse engineering visual contracts is a process of learningrules from transformations.
this has been suggested in anumber of areas including the modelling of real word businessprocesses biochemical reactions and model trans formations .
although related in the aim of discoveringrules the challenges vary based on the nature of the graphsconsidered e.g.
directed attributed or undirected graphs theavailability of typing or identity information etc.
we organisethe discussion in two levels tracing to construct rule instancesand learning to infer high level rules with advance featuresmodel extraction automated reverse engineering is basedon static or dynamic analysis.
the static approach exemplifiedby examines the source code only withthe intention of extracting all possible behaviours.
this isuseful for incomplete systems e.g.
components that cannot beexecuted independently but limited in its ability to detectdynamic object oriented behaviours such as dynamic binding.the drawback of a dynamic approach such as ours butalso is that the extracted model represents onlythose behaviours that are actually executed.
in particular uses aspectj for extracting a context free graph grammarbut their use of graph grammars is for representing nestedhierarchical call graphs not to model the behaviour of thesystem in terms of transformations on objects.learning models from observations propose miningalgorithms for graph transformation systems from transitionsystems.
theircontext algorithmprovides similar outputsto our inferred maximal rule but we differ in the strategyused.
their construction relies on extending the minimal ruleby adding matched context elements.
our approach is theopposite based on cutting down unmatched contexts from achosen contract instance which makes it easier to maintainthe graph structure as valid against the type graph.
to the bestof our knowledge no work has been done on inferring multi objects for visual contracts.in source and target graphs represent networks ofbiomolecules.
the authors aim to discover rules modellingreactions.
they extract the minimal rule by best sub graphmatching and adopt a statistical approach to rate context.
ourapproach is simpler in that the minimal rule is determined bytracing and we do not deal with uncertainty of context.considering approaches to learning model transforma tions we distinguishin placewhere source and targethave the same metamodel andout placetransformations wherethe metamodels are different .
for learningout placetrans formations use input output pairs representing the resultof a transformation process rather than a single step.
also address the learning ofout placetransformations while our approach focusses onin placetransformations.
also addressing the learning ofin placetransformationsis interactive requiring confirmation of the rules proposed.our approach does not rely on direct user involvement and significantly is not based on a small number of carefullyhand crafted examples but on large numbers of observationsextracted from a running system.
therefore scalability andthe ability to deal with example sets providing incompletecoverage are important.graph pattern mining an algorithmic problem closelyrelated to the extraction of rules from example transformationsis graph pattern discovery.
current approaches are statisticalor node signature based.
finding graph patterns by statisticalmeans is popular in machine learning but can producea large variance depending on the frequency of a pattern.
forinstance an object that is not accessed but always present inthe context is considered an important element of the rule.
discuss research in exact and best graph patternmatching.
a crucial point is how to distinguish nodes ascandidates for possible matches.
in a node signature forattributed graphs encodes node edge types and node attributes.we use a node signature based approach with added structuralinformation and metadata extended from subgraph to subrulematching taking into account shared minimal rules and pa rameters.v.conclusion andfutureworkwe presented an integrated approach and tool for learningvisual contracts from instrumentation of java code and obser vation of tests to the derivation of general rules with multi ob jects and attribute constraints.
it supports the analysis of testsbased on a concise visual and comprehensive representationof operations behaviour.
we have evaluated the validity of theresulting models usability and scalability in experiments onthree case studies.currently we work on improving the integration of ourtool with henshin to evaluate extracted contracts morewidely.
this involves invoking the model alongside the orig inal implementation with the same set of tests comparingoutputs for consistency.
executing the tests the contracts wereextracted from adds to their validation of correctness butmore interestingly we can try a range of additional casesto evaluate how well contracts capture the wider behaviour beyond the directly observed.
a related idea is the use foradaptive testing where test cases are generated fromcontracts in a cycle of test generation execution and contractextraction.we also plan to use contract extraction to support testingand debugging evaluating their effectiveness for these tasksmore comprehensively.
additionally we will be investigatingtechniques such as hyper j to support tracing and extrac tion for multithread java applications.acknowledgmentwe would like to thank michel chaudron and neil walkin shaw for the valuable advice and feedback on conducting userexperiments.
113references t. a. khan o. runge and r. heckel testing against visual contracts model based coverage ingraph transformations 6th internationalconference icgt bremen germany september .proceedings pp.
.
o. runge t. a. khan and r. heckel test case generation using visualcontracts eceasst vol.
.
g. engels m. lohmann s. sauer and r. heckel model drivenmonitoring an application of graph transformation for design bycontract ingraph transformations third international conference icgt natal rio grande do norte brazil september proceedings ser.
lecture notes in computer science a. corradini h. ehrig u. montanari l. ribeiro and g. rozenberg eds.
vol.
.
springer pp.
.
.
available j. h. hausmann r. heckel and m. lohmann model baseddevelopment of web services descriptions enabling a precise matchingconcept int.
j. web service res.
vol.
no.
pp.
.
.
available a. m. alshanqiti r. heckel and t. a. khan learning minimal andmaximal rules from observations of graph transformations electroniccommunications of the easst vol.
.
.
available a. m. alshanqiti and r. heckel towards dynamic reverse engineeringvisual contracts from java electronic communications of the easst vol.
.
.
available h. ehrig k. ehrig u. prange and g. taentzer fundamentals ofalgebraic graph transformation monographs in theoretical computerscience.
an eatcs series .
pp secaucus nj usa springer verlag new york inc. .
d. bisztray r. heckel and h. ehrig verification of architectural refac torings rule extraction and tool support proceedings of the doctoralsymposium at the international conference on graph transformation electronic communications of the easst vol.
.
m. d. ernst j. h. perkins p. j. guo s. mccamant c. pacheco m. s. tschantz and c. xiao the daikon system for dynamicdetection of likely invariants science of computer programming vol.
no.
pp.
special issue on experimentalsoftware and toolkits.
.
available t. arendt e. biermann s. jurack c. krause and g. taentzer henshin advanced concepts and tools for in place emf modeltransformations inmodel driven engineering languages and systems 13th international conference models oslo norway october proceedings part i ser.
lecture notes incomputer science d. c. petriu n. rouquette and .
haugen eds.
vol.
.
springer pp.
.
.
available h. bruggink towards process mining with graph transformationsystems ingraph transformation ser.
lecture notes in computerscience h. giese and b. knig eds.
springer internationalpublishing vol.
pp.
.
.
available c. h. you l. b. holder and d. j. cook learning patterns in thedynamics of biological networks inproceedings of the 15th acmsigkdd international conference on knowledge discovery and datamining ser.
kdd .
new york ny usa acm pp.
.
x. dolques a. dogui j. r. falleri m. huchard c. nebut and f. pfis ter easing model transformation learning with automatically alignedexamples inproceedings of the 7th european conference on modellingfoundations and applications ser.
ecmfa .
berlin heidelberg springer verlag pp.
.
m. k. sarkar t. chatterjee and d. mukherjee reverse engineering an analysis of static behaviors of object oriented programs by extractinguml class diagram international journal of advanced computerresearch vol.
no.
.
a. rountev o. volgin and m. reddoch static control flow analysisfor reverse engineering of uml sequence diagrams sigsoft softw.eng.
notes vol.
no.
pp.
sep. .
p. tonella and a. potrich reverse engineering of the interactiondiagrams from c code insoftware maintenance .
icsm .proceedings.
international conference on.
ieee sept pp.
.
h. brito h. marques neto r. terra h. rocha and m. valente on the fly extraction of hierarchical object graphs journal of the braziliancomputer society pp.
.
t. ziadi m. a. a. da silva l. m. hillah and m. ziane a fully dy namic approach to the reverse engineering of uml sequence diagrams in16th ieee international conference on engineering of complexcomputer systems iceccs .
ieee pp.
.
c. zhao j. kong and k. zhang program behavior discovery and ver ification a graph grammar approach ieee transactions on softwareengineering vol.
no.
pp.
.
g. kappel p. langer w. retschitzegger w. schwinger and m. wim mer conceptual modelling and its theoretical foundations incon ceptual modelling and its theoretical foundations a .d usterh oft m. klettke and k. d. schewe eds.
berlin heidelberg springer verlag ch.
model transformation by example a survey of thefirst wave pp.
.
t. mens and p. van gorp a taxonomy of model transformation electron.
notes theor.
comput.
sci.
vol.
pp.
mar.
.
m. faunes h. sahraoui and m. boukadoum generating modeltransformation rules from examples using an evolutionary algorithm inproceedings of the 27th ieee acm international conference onautomated software engineering ser.
ase .
new york ny usa acm pp.
.
d. varr model transformation by example inin proceedings of theacm ieee 9th international conference on model driven engineeringlanguages and systems models uml .
springer pp.
.
z. balogh and d. varr model transformation by example usinginductive logic programming international journal software andsystems modeling vol.
no.
pp.
.
p. langer m. wimmer and g. kappel model to model transforma tions by demonstration inproceedings of the third international con ference on theory and practice of model transformations ser.
lecturenotes in computer science l. tratt and m. gogolla eds.
springerberlin heidelberg vol.
pp.
.
m. qiu h. hu q. jiang and h. hu a new approach of graphisomorphism detection based on decision tree ineducation technologyand computer science etcs second international workshop on vol.
.
ieee pp.
.
d. conte p. foggia c. sansone and m. vento thirty years ofgraph matching in pattern recognition international journal of patternrecognition and artificial intelligence vol.
no.
pp.
.
n. dahm h. bunke t. caelli and y. gao efficient subgraph matchingusing topological node feature constraints pattern recognition vol.
no.
pp.
.
s. jouili i. mili and s. tabbone attributed graph matching usinglocal descriptions inadvanced concepts for intelligent vision systems acivs ser.
lecture notes in computer science see.
springer pp.
.
k. y. cai t. y. chen y. c. li w. y. ning and y. t. yu adaptive testing of software components inproceedings of the2005 acm symposium on applied computing ser.
sac .
newyork ny usa acm pp.
.
.
available h. ossher and p. tarr hyper j multi dimensional separation ofconcerns for java inproceedings of the 22nd internationalconference on software engineering ser.
icse .
new york ny usa acm pp.
.
.
available view publication stats