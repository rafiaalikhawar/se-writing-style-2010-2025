detecting unknown inconsistencies in web applications frolin s. ocariza jr. karthik pattabiraman ali mesbah university of british columbia v ancouver bc canada frolino karthikp amesbah ece.ubc.ca abstract although there has been increasing demand for more reliable web applications javascript bugs abound in web applications.
in response to this issue researchers have proposed automated fault detection tools which statically analyze the web application code to find bugs.
while useful these tools either only target a limited set of bugs based on predefined rules or they do not detect bugs caused by cross language interactions which occur frequently in web application code.
to address this problem we present an anomaly based inconsistency detection approach implemented in a tool called h olocron .
the main novelty of our approach is that it does not look for hard codedinconsistency classes.
instead it applies subtree pattern matchingto infer inconsistency classes and association rule mining to detect inconsistencies that occur both within a single language and between two languages.
we evaluated h olocron and it successfully detected previously unreported inconsistencies including bugs and code smells in web applications.
index t erms javascript fault detection cross language interactions i. i ntroduction the javascript programming language has rapidly grown in popularity over the past decade even topping the most popular technologies category of the two most recent stack overflow developer surveys .
although javascript programming has extended to the full web stack its most frequentusage remains at the client side.
unfortunately despite itspopularity javascript is still notoriously error prone and these errors often lead to high impact consequences such asdata loss and security flaws .
to mitigate this problem web developers rely heavily on testing and many tools have been developed for testing .
to complement testing developers use static code analysis tools which find bugs by reasoning about the program without having to execute it.
several techniques have beenproposed to automatically detect javascript bugs through staticanalysis.
for example jslint detects syntactic errors injavascript programs jensen et al.
analyze javascriptcode to find type inconsistencies ocariza et al.
proposeaurebesh for automatically detecting inconsistencies inangularjs web applications.
a common issue with the abovetechniques is that they detect bugs based on a predefined list of inconsistency rules or bug patterns.
as a result theissues they detect will be limited to those encompassed bythese hardcoded rules.
this is especially problematic for webapplications which use a wide variety of frameworks e.g.
angularjs backbonejs ember and libraries each with itsown coding rules and conventions.
moreover web frameworkstypically evolve fast and hence hardcoded rules may becomeobsolete quickly thereby necessitating expensive updates.
in this paper we propose an anomaly based inconsistency detection approach for javascript based web applications.anomaly based approaches learn the rules based on codesamples and can hence find unknown inconsistencies withouthardcoded rules or patterns.
our approach differs from prioranomaly based approaches in that it is cross language and can hence find inconsistencies within and between two different languages namely html and javascript.
prior work hasshown that many cross language interactions are highly error prone in web applications and hence it is important toconsider such cross language inconsistencies.
in addition tobugs javascript is also prone to code smells which are pieces of code that are difficult to maintain and are therefore prone to becoming an error when the code is modified.
these code smells often also manifest as inconsistencies particularlywhen there is a deviation in the code style.
therefore byapplying inconsistency detection we can also detect many code smells because our approach looks for code deviations.
we focus on detecting inconsistencies in mvc applications that is web applications implemented using javascriptmodel view controller mvc frameworks such as angu larjs backbonejs and ember.js.
we target these mvc frame works due to their rising popularity and because they do not interact directly with the dom document object model .
this makes them more amenable to static analysis than non mvc applications.
we make the following contributions we demonstrate that there are many inconsistency classes in mvc applications and that there is no singleinconsistency class that dominates over the others.
further many of these inconsistencies span multiple programminglanguages thereby motivating approaches such as ours we propose a technique for automatically detecting inconsistencies in javascript mvc applications.
unlike priorwork our approach does not look for hard coded inconsistencyclasses but instead uses subtree pattern matching to infer theseclasses.
further it uses association rule mining to find thecross language links we implement our technique in a tool called h olocron and we evaluate it on javascript applications from threedifferent mvc frameworks.
we find that h olocron can find a total of unknown bugs in these applications five of which are cross language.
further h olocron finds code smells in these applications.
.
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research566 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ii.
b ackground and motiv a tion we target a general class of bugs that we call inconsistencies in javascript mvc applications.
as the name suggests an mvc application consists of a model which defines the application data a controller which defines the functions that manipulate the values of the application data and a view which uses the data and functions defined in the model andcontroller to define a user interface.
static analysis is sufficientfor mvc applications as they rely primarily on javascriptbindings instead of dom interactions hence even thoughthe dom still changes the javascript code interacts primarilywith these static bindings instead of directly with the dom.
a. definitions we define a code component to be any contiguous piece of javascript or html code that could span a single line e.g.
function call html text etc.
or multiple lines e.g.
functiondefinition view definition etc.
.
these code components canbe represented by subtrees of the javascript code s abstractsyntax tree ast or the html code s dom representation we use these subtrees in our design section iii .
definition inconsistency two code components c aand cbare inconsistent if camakes an erroneous assumption about cb where the erroneous assumption can be implicitly inferred from the code e.g.
without having to rely on specifications .
the pair ca cb is an inconsistency.
therefore an inconsistency is a bug that can be discovered without the help of external specifications and hence can bedetected through an automated analysis of the web application code.
an inconsistency is considered cross language ifc aand cbbelong to different programming languages i.e.
in our work html and javascript.
ideally we would like to be able to label a web application as inconsistent by using a search approach that finds all inconsistent code components as described above.
however nosuch approach currently exists nor do we aim to propose suchan approach in this paper.
our goal rather is to find as manyof these inconsistencies as possible by detecting anomaliesin the ast and the dom.
the approach is described insection iii and its differences compared to other anomalydetection techniques are outlined in section vii.
a recent study provides some evidence that four classes of these inconsistencies occur in mvc applications .
for example the view components in the html code use variables that are erroneously assumed to be defined in themodel components in the javascript code.
in section v d wefind through a study of bug reports that these inconsistenciesabound in mvc applications and often go much beyond theclasses found in this prior study.
thus this prior approach will not work for these other classes.
b. motivating examples to illustrate the problem we introduce examples of two real bugs and one code smell that result from inconsistencies.
angularjs example.
in this application the javascript code closes a modal instance by calling the close method modalinstance.close close however this leads to incorrect application behaviour i.e.
a dialog box becomes broken as the modalinstance service has been replaced in the newer version of angularjs being used by the application by uibmodalinstance.
in this case the function call above incorrectly assumes that theservice object being dereferenced is valid thereby leadingto the inconsistency.
this example demonstrates the potential usefulness of a learning based approach for finding theseinconsistencies as the evolution of framework apis often modifies or introduces new coding rules.
backbonejs example.
in this application the javascript code is attempting to bind an element from an html view template to a layout view object by assigning the elproperty with an element selector as shown below.
1marionette.layoutview.extend el .some view ... in this case the selector .some view does not correspond to any element in the html template which causes thebinding to fail.
in other words the view incorrectly assumesthat a particular element with the class some view is definedin the html template.
this shows the difficulty of reasoningabout consistency across languages.
code smell.
code smells are important because if ignored they are prone to turning into bugs and can therefore lead the program to a faulty state.
these code smells often manifestas inconsistencies in the javascript code particularly when a piece of code is smelly because a coding style is applied toit that deviates from the coding style adhered to in the rest of the code.
for example consider a function func that takes a number as a parameter.
suppose that in most calls tofunc the argument is passed to func as a named constant num however in one sole call the argument is passed tofunc as a hardcoded number literal with the same value asnum.
when the developer updates the value of num they may forget that the number literal in the latter call also needsto be updated since it is an additional portion of the code that needs to be kept track of in this case a functional regressionwill be introduced.
this example which we discover to existin several applications as we report later in section v e demonstrates that it is not only functional bugs that manifest as inconsistencies but code smells as well.
c. challenges one of the main challenges is that we need to infer programmer intent in order to label code components as inconsistent.
for example in the angularjs example above how do weknow that modalinstance is an incorrect service name in the absence of specifications?
one approach is to leverage repeated appearances of the same code pattern to infer intent.
any deviations from this pattern are likely to be inconsis tencies.
further the more the examples of the same pattern authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
javascript htmltransform ast and dom into codetreesfind code patterns from subtrees infer consistency rulesdetect rule violationsintra pattern rules link rulesinconsistencies fig.
.
overview of our inconsistency detection approach and the fewer the counterexamples the more likely it is to be an actual pattern.
in the angularjs example there are manyinstances of uibmodalinstance.close ... which is a near match though the service name is different indicating that the service name modalinstance is incorrect.
another challenge is that we have to deal with crosslanguage inconsistencies as this forces our design to infer links between code components coming from different pro gramming languages.
for instance in the backbonejs exampleabove our design needs to infer that the value of the el property needs to be a selector for an element in the html template.
we can decide to simply hardcode this relationshipin our detector but the problem is that this link is specific tothe backbonejs framework.
iii.
a pproach the block diagram in figure presents an overview of our approach.
as the diagram shows our approach takesthe web application s 1javascript and html code as input and transforms these pieces of code into their correspondingast and dom representations respectively.
as explained in section iii a the ast and the dom trees are transformed into another tree object called a codetree which allows the approach to perform standardized operations on those trees.
inaddition to the trees generated from the input web application our technique also retrieves the ast and dom of otherweb applications that use the same framework these webapplications are retrieved from the web section iii c .
once the codetrees are generated for the input and sample code the approach analyzes the trees to find commonlyrepeated patterns in the trees section iii b .
to do so itlooks for subtree repeats which by definition are subtrees that appear multiple times in the codetrees these subtree repeats represent common code patterns in the web application.
after finding the subtree repeats the approach examines each code pattern found in the previous module and formulatesconsistency rules based on them.
there are two levels ofconsistency rules intra pattern consistency rules which are defined by the individual code patterns themselves and inter pattern consistency rules i.e.
link rules which are inferred based on pairs of code patterns.
these link rules allow 1from here on when we say web application we mean mvc applications.our approach to find consistency rules that span code writtenin different languages section iii d unlike prior work.
finally our approach finds inconsistencies based on a comparison between the codetree objects and the inferred consistency rules section iii e .
these represent both codesmells and bugs.
later in section v we demonstrate theusefulness of our approach in detecting bugs and code smells.
a. transforming code into trees the first module of our approach transforms the javascript and the html code of the input web application into their corresponding ast and dom representations.
more specifically an ast is constructed for each javascript file or javascriptcode within the same script tag and a dom representation is created for each html file.
these transformations are doneto simplify analysis as trees are a well studied data structurefor which many search and comparison algorithms have beenproposed.
it also makes our approach easier to extend to otherlanguages as it does not need complicated parsing algorithmsthat rely on knowledge of the syntax of specific languages.
in order to standardize the way that our approach operates on the asts and the doms we transform them both into adata structure called the codetree.a codetree is defined as a tree t v e where vis the set of nodes in the tree and e is the set of edges.
for every node v v we define v.type set to ast dom if vis an ast dom node v.label set to the node label.
if vis an ast node the label is set to either the node type e.g.
expressionstatement identifier etc.
or the corresponding identifier or literal value.ifvis a dom node the label is set to a tag name element node attribute name attribute node or text text node or an attribute value in addition to the above properties for each codetree node we also keep track of its parent and childnodes as well as the linenumber columnnumber and sourcefile.
b. finding common patterns the goal of our next module is to find patterns of repeating subtrees in the codetrees.
these patterns will form the basis of the consistency rules.
we first define the following definition subtree repeats let t t2 ... tn be codetrees and let r vr er and s vs es be two different subtrees of any of these codetrees.
then rand sare defined to be subtree repeats of each other if rand sare isomorphic where two nodes are considered equal iff theyhave the same type and label.
hence each node v r vrhas a corresponding node vs vssuch that vr.type vs.type and vr.label vs.label .
definition code pattern acode pattern cis defined as a set of subtrees such that for every pair of subtrees r s c rand sare subtree repeats.
hence the goal of this module is to find all the code patterns in the codetrees generated earlier in the previous module.
our technique for finding these code patterns is similar tothe approach used by baxter et al.
to detect clones in thesource code of a program using the ast.
more specifically our authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
design looks for all full subtrees in each codetree and assigns a hash value to each of these subtrees note that a full subtree pertains to a subtree that contains all the descendant nodes from the subtree s root.
all subtrees that hash to the samevalue are placed in their own hash bin.
the subtrees in eachhash bin are then compared to detect any collisions if thereare collisions the hash bin is split to resolve the collisions.these hash bins represent the code patterns.
the difference with baxter et al.
s technique is that when comparing subtrees our design abstracts out the labels of nodes pertaining to variable and function identifiers as wellas attribute values.
our design also abstracts out any labelsthat identify the data type of a literal node e.g.
stringliteral numberliteral etc.
.
so enables our design to find intra pattern consistency rules see section iii d .
c. using code examples from the web in addition to the target application our design also looks for patterns that are found in example web applications downloaded from web.
the purpose of using these example ap plications is to allow code patterns to appear more frequently thereby giving our design greater confidence about the validityof the pattern found.
further using these examples will alsoallow non patterns to appear less frequently percentage wise thereby decreasing the rate of false positives.
the example web applications retrieved chosen based on a github search result of the corresponding framework s name must use the same framework and framework version asthe target web application determined via the script tag of the target web application.
in addition each application mustinclude at least one file with both a .html extension and a .js extension not including library code included in the lib folder.
in our experiments we choose a total of five sampleapplications as we find that this number allows our techniqueto find enough inconsistencies while keeping the runtime low see section v g .
d. establishing rules from patterns after finding the patterns our design then analyzes these patterns to infer consistency rules.
in this case the design looks for both intra pattern and inter pattern consistency rules.
intra pattern consistency rules as mentioned earlier intra pattern consistency rules are defined by individual codepatterns.
algorithm shows the pseudocode for finding theserules and reporting violations.
the main idea is to concretize the nodes that were abstracted out in the previous module.
the algorithm first stores each code pattern in a queue line .
for each code pattern cin the queue the design determines the earliest node in depth first pre order that is still abstracted out among the subtrees in c. it achieves this by calling the getnextnodetoconretize function which returns the pre order number of the earliest node line .
once the pre order number of the earliest node is determined the actual nodes in the subtrees in cthat correspond to this pre order number are compared and marked as concretized lines and the subtrees are partitioned according to thealgorithm findintrapatterninconsistencies input cset the set of code patterns input t the threshold for dominant subpatterns output pi set of intra pattern inconsistencies 1pi remaining 2codepatternqueue c c cset while codepatternqueue is not empty do c codepatternqueue.dequeue preordernum getnextnodetoconcretize c 6i f preordernum 1then remaining remaining c continue end subpatterns foreach subtree s cdo node getpreordernode s preordernum markasconcretized node if subpatterns.haskey node.label then subpatterns .add s end16 else subpatterns s end end20 d getdominantpattern subpatterns if d c tthen expected getpreordernode d preordernum foreach code pattern cp subpatterns do ifcp negationslash dthen foreach subtree s cp do inc getpreordernode s preordernum pi pi inc expected end end end codepatternqueue.enqueue d end33 else codepatternqueue codepatternqueue subpatterns end36 end37 c set mergeremaining remaining label of the concretized node lines .
the partitions are included in an associative array called subpatterns line .
once the partitions are found the algorithm looks for the dominant pattern which represents the largest partition line .
if the number of subtrees in the dominant patternconstitutes greater than t of all the subtrees in the original code pattern c where tis a user set threshold all the subtrees belonging to the non dominant patterns are considered intrapattern inconsistencies lines and are discarded here an intra pattern inconsistency is represented by a tuple of the inconsistent node i.e.
the node that was just concretized inthe inconsistent subtree and the expected node i.e.
thenode that was just concretized in any subtree belonging to the dominant pattern line .
this process is repeated until thereare no further nodes to concretize after which all remainingpartitions belonging to the same original code pattern at the start of the algorithm are merged line .
as an example consider the subtrees in figure which form a code pattern this code pattern is found in the angularjs example introduced in section ii b. here the current nodebeing concretized is the left most leaf node of each subtree which in this case represents the name of the service beingdereferenced.
the subtrees are then partitioned according tothe label of this concretized node.
in this case there are twopartitions one containing the left most subtree with the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
callexpression memberexpression stringliteral identifi er identifi er close modalinstance closecallexpression memberexpression stringliteral identifi er identifi er close uibmodalinstance close...callexpression memberexpression stringliteral identifi er identifi er close uibmodalinstance closecallexpression memberexpression stringliteral identifi er identifi er close uibmodalinstance close fig.
.
example of an intra pattern consistency rule violation algorithm findlinkrules input cfr o m cto pair of code patterns output l set of link rules 1l foreach sfr o m sto cfr o m ctodo i node fr o m getpreordernode s fr o m i while node fr o m negationslash null do j node to getpreordernode s to j while node to negationslash null do 9i fnode fr o m negationslash node toand node fr o m.label node to.label then lr i sfr o m j sto l l lr end node to getpreordernode s to j end node fr o m getpreordernode s fr o m i end end concretized node coloured red and another containing the rest of the subtrees with the concretized node coloured blue.
thelatter partition is deemed to be dominant so the subtree in theother partition is labeled as inconsistent.
inter pattern consistency rules i.e.
link rules in addition to finding the intra pattern consistency rules ourdesign also looks for consistency rules that describe therelationship between code patterns we call these link rules.
this process allows our design to find relationships betweenpieces of code in the same programming language and acrosslanguages i.e.
cross language relationships.
all link rules are of the following form the i thpre order node in subtree s is equal to the jthpre order node in subtree s .
our design finds the link rules for each pair of code patterns cfr o m cto as shown in algorithm .
in this case the algorithm iteratesthrough every pair of subtrees between the two code patterns line .
for each of these pairs of subtrees the algorithm goesthrough every pair of nodes between the two subtrees lines and compares the two nodes to see if they have the samelabel.
if they have the same label a new link rule is added tothe list uniquely identified by the subtree pair s fr o m and sto and their respective pre order indices iand j. e. detecting violations violations to the intra pattern consistency rules are detected in conjunction with finding those rules as described in section iii d1.
for the link rules we make a distinction betweenunconditional and conditional link rule violations.
unconditional link rule violations a link rule violation is unconditional if the link rule is violated by a codecomponent regardless of where the component is located in the code.
the backbonejs example section ii b is anunconditional link rule violation.
to determine whether a linkrule lris violated our design examines each pair of code patterns c fr o m and cto as before.
it then determines which pairs of subtrees between cfr o m and ctosatisfy lr.
there are two ways in which a subtree can be an inconsistency.
first if a subtree sfr o m cfr o m does not satisfy the link rule lrwhen paired with any subtree sto cto and a large percentage pv a parameter chosen by the user of the other subtrees in cfr o m satisfy lrat least once then sfr o m will be considered an inconsistency.
for instance the left box in figure shows the code pattern to which the inconsistentcode in the backbonejs example section ii b belongs.
asindicated by the arrows in this figure almost each subtree inthis code pattern corresponds to a class attribute definition inthe html code right box in figure the only exception isthe subtree with the node highlighted in red some view .
this subtree is labeled an inconsistency assuming pv .
el property some view el property some region el property layout el property main attribute class some region attribute class layout attribute class main code pattern from the html codecode pattern from the javascript code fig.
.
example of an unconditional link rule violation.
the subtrees are slightly altered for simplicity.
second if a subtree sfr o m cfr o m does not satisfy the link rule lrwhen paired with a specific subtree sto cto and a large percentage of the other subtrees in cfr o m satisfy the link rule lrwith sto then sfr o m will also be an inconsistency.
conditional link rule violations a link rule violation is conditional if the link rule is violated given that the code component is located in a specific area in the code.
for example suppose a view vin the html code is associated with a model min the javascript code.
further suppose that the following link rule has been found the identifier x in the subtree with pattern ng model x is equal to the identifier y in the subtree with pattern scope.
y .
in this case if there exists no subtrees in the model m with pattern scope.
y that matches a certain subtree in the view vwith pattern ng model x then this latter subtree is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
considered a violation of the link rule i.e.
vis using an identifier that is undefined in the corresponding model m .
because this link rule violation only occurs given that the subtrees being compared are located in mand v this is a conditional link rule violation.
to find the conditional link rule violations we use a wellknown data mining technique called association rule learning .
this technique takes a set of transactions as input where each transaction contains a set of items that apply to that transaction.
based on an analysis of these transactions the technique looks for rules of the form a1 a2 ... an b1 b2 ... bm where both the left and right side of the implication are subsets of all the items.
in addition the technique only reports rules that exceed a particular confidence value i.e.
the percentage of transactions that follow the rule.
hence when finding the conditional link rule violations between pairs of code patterns cfr o m and cto we create a transaction for each subtree pair s fr o m sto .
the items included in each transaction include all the link rules satisfiedby the subtree pair as well as the ancestor nodes of theroot of each subtree these ancestor nodes dictate which areas in the source code the subtrees are located.
we usethe apriori algorithm to infer association rules with a confidence value greater than a user set parameter cv we are particularly interested in association rules of the form an fr o m anto lr where anfr o m and antoare ancestor nodes of the subtrees sfr o m and sto respectively and lris a link rule.
these rules are compared against each subtree pair non satisfying subtree pairs are reported as inconsistencies.
iv .
i mplementa tion we implement our technique in an open source tool called holocron2holocron is implemented in javascript as a plugin for brackets which is an integrated development environment ide for web development developed by adobe .to use h olocron the user only needs to specify the top folder of the target web application.
the output of the toolis a list of the inconsistencies found each inconsistency is shown to the user as a message identifying the inconsistent line of code and an example of what is expected based on theconsistency rule.
the javascript code is parsed into an astusing esprima and the html code is parsed into itsdom representation using xmldom .
for finding theassociation rules we adopt an existing implementation of the apriori algorithm .
v. e v alua tion a. research questions rqs rq1 prevalence of inconsistencies do inconsistencies occur in mvc applications and if so what are the characteristics of these inconsistencies?
rq2 real bugs and code smells can h olocron be used by developers to detect bugs and code smells in real world mvc applications?
frolino projects holocron rq3 thresholds how generalizable are the user defined thresholds across applications?
rq4 performance how quickly can h olocron detect inconsistencies?
b. subject systems for our experiments which answer rq2 to rq4 we consider four open source applications from each of the three main mvc frameworks angularjs backbonejs and em ber.js for a total of applications.
these three frameworks are the most widely used javascript mvc frameworks experiencing a growth in popularity from january 2013to april .
the applications are listed in table i with the sizes ranging from to kb loc .these sizes are representative of popular mvc applications for example a sample of github projects with at least stars that use angularjs retrieved from the top github issue search results has an average of lines of code and a median of loc.
in addition half of these projectshave fewer than loc not including libraries.
theseapplications were taken from various lists of mvc applicationsavailable on github .
in particular we chose the first four applications from each framework found from these lists filtering out the applications that did not have agithub repository and a working demo as this simplified thetask of reproducing the functional bugs found by our tool.
c. experimental methodology prevalence of inconsistencies rq1 .
to answer rq1 we manually analyze bug reports that have been filed for mvc applications on github.
more specifically we examine bugreports for applications implemented in each of the three mainmvc frameworks angularjs backbonejs and ember.js for a total of bug reports.
we only consider fixed or closedbugs to prevent spurious reports.
to find the bug reports weuse github s advanced search feature searching in particularfor github issues that are given the label bug and whosestatus is closed .
we perform the same search for each ofthe three mvc frameworks using the keywords angularjs backbone and emberjs respectively.
we discard any search results that correspond to applications not written in any of these three frameworks as well as results that do notpertain to the web application s client side code.
we then takethe first bug reports that satisfy the conditions describedfrom each of the three search results and use those bug reportsfor our analysis.
note that we did not confine ourselves to the subject systems listed in section v b. further notethat even though h olocron could be applied to the web applications we encountered in rq1 we opted not to use theseweb applications as the subjects for rq2 rq4.
this is becausethe bugs are dispersed across many different web applications and it would be infeasible for us to perform tests on each one.
for each of the bug reports we first determine whether the bug corresponds to an inconsistency as defined in section ii.if so we determine the bug s inconsistency category which is defined in section ii a some categories may possibly contain authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
only one inconsistency.
we also determine whether the bug is a cross language one.
real bugs and code smells rq2 .
for rq2 we run holocron on the subject systems described in section v b and record all the inconsistencies reported by the tool.
we examine each of these reported inconsistencies to determineif it corresponds to a real bug i.e.
it represents an errorthat leads the application to a failure state or code smell.
todetermine if a reported inconsistency represents a code smell we compare the reported inconsistency with the examples of correct lines provided by h olocron section iv and we qualitatively assess whether this deviation has any negativeimpact on maintenance.
we set the intra pattern violation threshold tto the unconditional link rule violation thresholds pvto and the conditional link rule violation threshold cvto in section v f we investigate the thresholds generalizability.
finally using the criteria outlined in section iii c we use example code from five open source web applicationsto train the analysis with more samples.
these five applica tions include the other three subject systems using the sameframework e.g.
if the target web application is angular puzzle we include the three other subject systems thatalso use angularjs namely projector cryptography and twittersearch as example code as well as two additional applications using the same mvc framework found ongithub .
we report the number of bugs andcode smells found by h olocron as well as its precision i.e.
number of bugs and code smells per inconsistency .
thresholds rq3 .
to answer rq3 we perform a fold cross validation to test if the applications tested in rq2 have similar accuracy at the given thresholds i.e.
t pv and cv .
if they have similar accuracy it would demonstrate the generalizability of the chosen thresholds which would strongly indicate they can safely be used whenrunning h olocron for other applications.
when performing the cross validation the applications are partitioned intofour groups with each group containing three applications one from each framework .
at each iteration of the crossvalidation we use one partition as the training set and wecalculate the aggregated precision value for the applicationsin that partition we then calculate the mean squared error mse of the remaining applications precision values withrespect to the aggregated value of the training set.
note that we only consider the reported violations correspondingto each parameter for example when varying the intrapattern violation threshold t we only consider the intra pattern violations when calculating precision.
performance rq4 .
we measure the time taken by h olocron to run on each subject application.
we run our experiments on a mac os x .
.
machine .
ghz intel core duo with gb ram .
d. prevalence of inconsistencies rq1 of the bug reports we studied we found that of these bug reports correspond to an inconsistency.
these didangularjs backbonejs ember.js allnot inconsistency inconsistency mvc framework of bug reports fig.
.
percentage of bug reports classified as an inconsistency for each mvc framework frequencynumber of categories fig.
.
number of inconsistency categories with a particular frequency.
mostinconsistency categories have just inconsistencies in them.
this shows why we need an automated approach to infer the inconsistency categories.
not need the application s specifications to detect pointing to the promise of a tool such as ours which finds inconsistencies.for example one of the ember.js applications passed a modalobject to the buildurl method even though this method which is part of the ember.js api expects a string as itsfirst parameter.
this inconsistency could be inferred based onother usages of the method which were correct.
the remaining30 of the bugs however required prior knowledge of theapplication s specifications.
for example one of the bugs wascaused by the fact that the programmer did not update thedisplay style of an element to block .
prior specification was needed to establish that the programmer intended tomodify the style to block and hence this bug would notbe detected by our approach.
the per framework results are summarized in figure .
as this figure shows of bug reports correspond to inconsis tencies for the angularjs and ember.js applications and of bug reports correspond to inconsistencies for backbonejs applications.
these results suggest that inconsistencies areprevalent in web applications created using javascript mvc frameworks.
we further found that of the inconsistencies are cross language.
for example one of the bugs resulted fromthe programmer erroneously using the data src attribute instead of the src attribute in the html code which led to incorrect bindings with the javascript code.
therefore existing tools that are based on a single language will not beable to detect a significant percentage of these inconsistencies.
figure shows the distribution of inconsistency categories we found again an inconsistency category is uniquely iden572 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i number of real bugs found per applica tion with corresponding issue numbers in parentheses some issues are aggrega ted into one bug report .
t he size is shown in kb with lines of code loc in parentheses .
framework application size loc o f code total bugs smells angularjs angular puzzle projector cryptography twittersearch backbonejs cocktail search contact manager webaudiosequencer backbone mobile ember.js todomvc emberpress giddyup bloggr overall tified by the two components that are inconsistent as well as the incorrect assumption made by one of the components.
asthis figure illustrates most inconsistency categories which is defined in section v c appear only once in the bug reportswe studied for example categories had only a singleinconsistency each.
further we found a total of differentinconsistency categories in our experiment.
the large number of categories suggests that there are many different rules thatare used by programmers in writing javascript mvc based applications and hence motivates an approach that discoversthe rules automatically such as ours .
e. real bugs and code smells rq2 table i shows the result of running h olocron on the subject systems.
in total h olocron was able to detect unreported bugs from mvc applications.
we have reported these bugs to the developers with two of the bugs descriptions acknowledged i.e.
those from cocktail search and the rest still pending3 further we were able to manually reproduce the bugs and confirm them ourselves.
as seen in this table holocron was able to find a bug in allof the applications tested except for one todomvc .
further h olocron found unconditional link rule violations conditional link ruleviolations and intra pattern consistency rule violations.
thus h olocron can be used by web developers to find bugs representing various types of consistency rule violations.
further out of real bugs found were cross language inconsistencies.
the bug in cryptography for instance results from an assignment in the javascript code incorrectly assuming that an element in the html code has a numerical value even though it is a string.
in addition the bug intwittersearch resulted from a controller in the javascript code assuming that an input element in the html code hasits type attribute defined which is not the case.
detectionof these cross language inconsistencies is made possible by h olocron looking for link rules in the applications.
3some of these applications are maintained sporadically which could explain the delay in response from the developersin all h olocron was able to find bugs spanning fifteen inconsistency categories.
for example the bug in giddyupis caused by a property assignment erroneously assuming that it has a corresponding route assignment in the ember.jsrouter.
in contrast aurebesh which also targets mvcapplications will not be able to detect this bug because it only considers four pre determined inconsistency categories to which this inconsistency found in giddyup does not belong and it only works for angularjs applications whereas giddyup is developed with ember.js.
in total aurebesh only detected two of the inconsistencies that h olocron identified both from angular puzzle across all applications.
finally many of the bugs found have potentially severe consequences on the application.
for example the bugs inprojector which are caused by an incorrect assumption about the type of value being assigned to an object property all cause the application to hang.
further the bug inwebaudiosequencer an audio player makes an audio clip un playable after a sequence of input events.
thus h olocron finds bugs that potentially have high impact on the application.
code smells.
we also found that of the reported inconsistencies correspond to code smells the detection of which could help the developer improve the quality of the code.
thecode smells found in our evaluation belong to three categories an inconsistency is labeled as a hardcoded constants hc code smell if the inconsistent code uses a hardcoded literal value in calculations and method calls other similar pieces of code use a non hardcoded value e.g.
variables named constants etc.
and the hardcoded literal value could safely be replaced with a non hardcoded value to make itmore maintainable.
we found instances of hc code smells.
further an inconsistency is labeled as an unsafe value usage uvu code smell if an object is dereferenced without accounting for the possibility of it being null even though a null check is applied to similar objects in other parts of thecode or a safer object is used to call the same method inother parts of the code.
for instance in emberpress one of the inconsistencies occurs as a result of the get method being called directly through a model object repeatedly this is potentially unsafe if the object is null and it is good practice to call the method via the ember object instead i.e.
ember.get as is done in other lines of code.
we found instances of uvu code smells.
finally an inconsistency is labeled as a multi purpose identifiers mpi code smell if the same identifier is being used for multiple unrelated objects.
this code smell manifests as an inconsistency when the identifier is used in a specificway in some parts of the code but used in a different way inanother part of the code.
for example in angular puzzle the identifier src is used both as a class name for a div element in the html code and as a name for a puzzle object in the javascript code.
we found instances of such smells.
precision.
like most static analysis tools h olocron incurs false positives i.e.
inconsistencies that are neither bugs nor code smells .
false positives occurred in all but one of the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
applications twittersearch .
in total h olocron reported inconsistencies of which were either real bugs or code smells.
hence approximately half the reports are potentially useful in improving the web applications quality.
the remaining reports are false positives.
while the false positive rate may seem high to users of static analysis tools we believe that they will not deter significantlythe usability of h olocron based on our own analysis of the false positives that appeared in our experiment.
in particular we found that these false positives fall under two very specificcategories.
first we found that of these i.e.
half false positives occur because of frequent usage of certain kinds of literals contrasted with infrequent usage of another kind ofliteral.
for example in projector most of the object method calls take string literals as parameters but there are three suchcalls that take number literals as parameters which thoughcorrect are reported as inconsistencies.
in our experiments ittook us only an average of minutes to discard each falsepositive of this kind without prior knowledge of the code base.
additionally the other false positives occur because of frequent usage of a certain identifier contrasted with infrequentusage of another identifier.
for instance in angular puzzle there are two main arrays both of which are accessed throughthethis identifier words andgrid.
while grid is used almost times in the code words is used only twice leading to the false positive.
we found these false positives to betrickier to discard again given our limited knowledge ofthe code base since it was not immediately clear to uswhat certain identifiers are being used for on average ittook us about minutes before deciding to discard falsepositives of this kind.
we strongly suspect however that thosefamiliar with the code base would also be able to discardmany of these false positives very quickly.
for instance in theangular puzzle example it was evident that words should not be replaced by grid since words is being used in a function whose purpose is to iterate through previously foundwords in the puzzle represented by words .
further for each inconsistency h olocron includes examples of the correct lines of code that the reported inconsistency deviates from which would help the developers gain more context about whythe inconsistency is reported and determine if it is valid.
f .
thresholds rq3 as mentioned earlier we used fold cross validation to investigate the generality of the user defined thresholds and measured the mse.
the mse can range between and with lower values indicating lower error and are hence better.when setting the intra pattern violation threshold to the oneused in rq2 experiment i.e.
the average mse .
.
an mse of .
is non negligible as it indicates that the precision can vary by as much as .
however closerinvestigation reveals that the aggregated precision for all theapplications when considering only intra pattern violations is50 and only one application out of fell below this average contact manager .
similarly when setting the unconditionallink rule violation threshold to the average mse value is0.
the aggregated precision for all the applications when considering only unconditional link rule violations is .
and only three of the applications cocktail search giddyup and bloggr client fell below this precision value.
these results indicate that the error represented by the msevalues primarily represent how much the aggregated precisionvalues are exceeded by the applications for example for the intra pattern inconsistencies two of the applications todomvcandgiddyup had perfect precision and the remainder of the applications had precisions within the range to .hence the precision values reported earlier are conservativeones and the thresholds chosen work well across the applications showing their generality.
note that the mse value is when setting the conditional link rule violation threshold to the chosen percentage i.e.
as the applications inour experiment had perfect precision when only consideringconditional link rule violations.
g. performance rq4 we find that on average h olocron ran for .
minutes for each of the applications.
because h olocron will typically be run prior to deployment of the application this is an acceptable overhead.
the worst case overhead occurred withwebaudiosequencer which is also the largest application where h olocron ran for almost minutes however note that many popular mvc applications are smaller in size thanthis on average section v b .
in this case most of the timewas spent on finding the link rule violations as all pairs ofsubtree classes are compared with each other as well as all subtrees within these classes.
h. threats to v alidity an external threat to validity is that we used a limited number of applications in our evaluation.
to mitigate this threat we chose applications coming from three popular mvcframeworks sizes and various application types as seen intable i. further for our study of bug reports in rq1 wecategorize the inconsistencies based on a qualitative analysisof the reports some of which may be misleading.
to mitigatethis we also look at other aspects of the bug including patchesand commits associated with the bug.
finally the bugs thatwe studied for rq1 are limited to fixed bugs with the label bug and with the status closed however many githubdevelopers do not label bug reports and hence we may havemissed certain bugs in our analysis.
nonetheless we choosebug reports this way to minimize spurious or invalid bugs.
vi.
d iscussion the main assumption behind our approach is that there are sufficient examples of a consistency rule that appear for it toboth successfully learn the consistency rule and detect anyviolations to that rule.
while this is the case for large webapplications small web applications have very few samples to learn from and hence may incur large numbers of false positives and false negatives.
to mitigate this problem we augmentour code patterns with subtrees found in code examples from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
other web applications as discussed in section iii b. so allows our design to be more confident about the validityof the consistency rules as well as debunk any consistencyrules that may lead to false positives.
in fact we found thatwithout the example code our false positive rates more thandoubled.
using more and better examples can likewise bringdown the false positive rate.
this is a subject of future work.
furthermore our main focus in this paper is in using h olocron to detect inconsistencies in mvc applications.
nonetheless our design can be run on web applications usingnon mvc javascript frameworks such as jquery.
this maylead to a large number of inaccuracies as the javascriptcode in these frameworks interacts directly with the dom which undergoes many changes throughout the execution ofthe web application.
however h olocron may be able to detect inconsistencies within the javascript code as well as inconsistencies between the javascript code and any component of the dom that does not get modified.
to detectthe remaining inconsistencies we may need to use dynamicanalysis this is also a subject for future work.
vii.
r ela ted work bug and code smell detection.
considerable work has been done on software fault detection and code smell detection by identifying code patterns.
an alternate approachfor finding bugs is anomaly detection.
this technique wasproposed by engler et.
al.
and commercialized as thecoverity tool which also supports javascript to someextent.
instead of hardcoding rules as the above techniquesdo this approach looks for deviant behaviours in the input application s code with these deviations providing an indi cation of potential bugs in the program.
reiss has also proposed a similar tool that finds unusual code in programs.
this approach has the advantage that it can learn rules fromcommon patterns of behaviour and hence the rules do notneed to be updated for each framework.
the main difference with our work is that these prior techniques do not use subtree patterns as the basis forthe consistency rules and they also cannot detect cross language inconsistencies as they implicitly assume a singlelanguage model.
further static analysis techniques such asfindbugs detect faults based on hardcoded rules or bug templates.
additionally dynamic analysis techniques such asdlint check consistency rules based on bad codingpractices .
as shown in our evaluation rq1 this can lead to many missed bugs especially for javascript mvc applica tions as there are no specific inconsistency categories that dominate the others.
further the frameworks used in webapplications evolve fast.
tools such as flow and typedevil are capable of finding type related faults.
these tools analyze the staticor dynamic data flow of the program to find these faults and hence this approach will not be able to detect faults thatdo not stem directly from this data flow.
while typedevilalso leverages the structure of dynamically observed data tofind inconsistent types it does not consider the link rules hence unlike h olocron it will not be able to detect cases where a variable defined in the model is assigned a type inconsistent with how it is used in the html templaterepresenting the view e.g.
a variable assigned a string beingused as the value for the count attribute in angularjs whichexpects a number .
in addition nguyen et al.
propose atechnique that can detect dangling i.e.
undefined referencesin javascript code that is generated from php code however unlike our tool this technique is only capable of finding theseinconsistencies if the