flexjava language support for safe and modular approximate programming jongse park hadi esmaeilzadeh xin zhang mayur naik william harris georgia institute of technology ga usa jspark gatech.edu hadi cc.gatech.edu xin.zhang gatech.edu naik cc.gatech.edu wharris cc.gatech.edu abstract energy efficiency is a primary constraint in modern systems.
approximate computing is a promising approach that trades quality of result for gains in efficiency and performance.
stateof the art approximate programming models require extensive manual annotations on program data and operations to guarantee safe execution of approximate programs.
the need for extensive manual annotations hinders the practical use of approximation techniques.
this paper describes flexjava a small set of language extensions that significantly reduces the annotation effort paving the way for practical approximate programming.
these extensions enable programmers to annotate approximation tolerant method outputs.
the flexjava compiler which is equipped with an approximation safety analysis automatically infers the operations and data that affect these outputs and selectively marks them approximable while giving safety guarantees.
the automation and the language compiler codesign relieve programmers from manually and explicitly annotating data declarations or operations as safe to approximate.
flexjava is designed to support safety modularity generality and scalability in software development.
we have implemented flexjava annotations as a java library and we demonstrate its practicality using a wide range of java applications and by conducting a user study.
compared to enerj a recent approximate programming system flexjava provides the same energy savings with significant reduction from to in the number of annotations.
in our user study programmers spend to less time annotating programs using flexjava than when using enerj.
categories and subject descriptors d. .
frameworks d. .
reliability keywords language design modular approximate programming .
introduction energy efficiency is a primary concern in modern systems.
mobile devices are limited by battery life and a significant fractionof the data center cost emanates from energy consumption.
furthermore the dark silicon phenomenon limits the historical improvements in energy efficiency and performance .
approximate computing is a promising approach that trades small and acceptable loss of output quality for energy efficiency and performance gains .
this approach exploits the inherent tolerance of applications to occasional error to execute faster or use less energy.
these applications span a wide range of domains including web search big data analytics machine learning multimedia cyber physical systems speech and pattern recognition and many more.
for instance a lossy video codec can tolerate imprecision and occasional errors when processing pixels of a frame.
practical programming models for approximation are vital to fully exploit this opportunity.
such models can provide significant improvements in performance and energy efficiency in the hardware by relaxing the abstraction of full accuracy .
safe execution of programs is crucial to the applicability of such techniques.
that is the programming model needs to guarantee that approximation will never lead to catastrophic failures such as array out of bound exceptions.
recent works on approximate programming languages enable these techniques to provide such safety guarantees.
these guarantees however come at the expense of extensive programmer annotations programmers need to manually annotate all approximate variable declarations or even annotate the safe to approximate operations .
this need for extensive annotations hinders the practical use of approximation techniques.
in this paper we propose a small set of language extensions that significantly lowers the annotation effort and paves the way for practical approximate programming.
to achieve this goal we identified the following challenges that need to be addressed.
the extensions should enable programmers to annotate approximation tolerant method outputs.
the compiler then should automatically infer the operations and data that affect these outputs and selectively mark them approximable while providing safety guarantees.
this process should be automatic and the language compiler should be codesigned in order to relieve programmers from manually and explicitly annotating data declarations or operations.
this paper addresses these challenges through the following contributions .we introduce flexjava a small set of extensions that enables safe modular general and scalable object oriented approximate programming.
it provides these features by introducing only four intuitive annotations.
flexjava supports modularity by defining a scope for the annotations based on the syntactic structure of the program.
scoping and adherence to program structure makes annotation a natural part of the software development process section .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
esec fse august september bergamo italy acm.
... .
745executememorywrite back......reg readdata cacheregister fileregister fileintunitfpunitmemorycpufigure a processor that supports fine grained approximation.
the shaded units perform approximate operations or store data in approximate storage.
.theflexjava annotations are designed to support both coarse grained and fine grained approximation and enable programmers to specify a wide range of quality requirements quality metrics and recovery strategies section .
.
.the language is codesigned with a compiler that automatically infers the safe to approximate data and operations from limited annotations on program or function outputs.
the compiler statically enforces safety using a scalable dataflow analysis that conservatively infers the maximal set of safe toapproximate data and operations.
this automated analysis significantly reduces the number of annotations and avoids the need for safety checks at runtime section .
.
.we implemented flexjava annotations as a library to make it compatible with java programs and tools.
we extensively evaluate flexjava using a diverse set of programs and by conducting a user study section .
and section .
.
the results of our evaluation show that flexjava reduces the number of annotations from to compared to enerj a recent approximate programming language.
we also conduct a user study that shows from to reduction in annotation time compared to enerj.
with fine grained approximation and small losses in quality flexjava provides the same level of energy savings from to compared to enerj.
with coarse grained approximation flexjava achieves even higher benefits .
average energy reduction and .
average speedup for less than quality loss.
a growing body of work is proposing new approximation techniques that stand to deliver an order of magnitude benefits in both energy and performance .
our results suggest that practical programming solutions such as flexjava are imperative for making these techniques widely applicable.
.
background approximation techniques are broadly divided into two types fine grained techniques that apply approximation at the granularity of individual instructions and data elements and coarse grained techniques that apply approximation at the granularity of entire code blocks.
flexjava supports both types of techniques.
we review the literature on these techniques before presenting the design of flexjava .
fine grained approximation.
architectures support fine grained approximation by allowing to execute interleaved approximate and precise instructions .
as figure shows such architectures support both approximate operations and approximate storage.
a bit in the instruction opcode identifies whether the instruction is the approximate or the precise version.
current proposals for approximate instructions lack room for enough bits to encode multiple approximation levels.
as a result we assume the prevalent binary level approximation although our approach can take advantage of multi level approximation.
in this model an approximate instruction has probabilistic semantics it returns an approximate value with probability p and the precise value with probability p. the approximate value may be arbitrary.
the architecture also allows approxi table error probabilities and energy savings for different operations in fine grained approximation.
we consider the three hardware settings of mild medium and aggressive from .
operationtechniquemildmediumaggressivetiming error probability10 2energy reduction12 mantissa bits float bits8 bits4 bitsmantissa bits double bits16 bits8 bitsenergy reduction32 read upset probability10 .
.
3write failure probability10 .
.
3energy reduction70 per second bit flipprobabilitymemory power reduction17 integerarithmetic logicfloating pointarithmeticdram memory voltageoverscalingbit widthreductionreducedrefresh ratesram read write reg file data cache voltageoverscaling10 mate storage i.e.
program data can be stored in approximate sections of the memory cache or registers.
we use three such probabilistic architecture settings shown in table that offer increasing energy savings with higher error probabilities.
these models are similar to the ones that are used in recent works on approximate programming .
coarse grained approximation.
coarse grained approximation techniques concern approximating entire loop bodies or functions .
loop perforation is one such technique that transforms loops to skip a subset of their iterations.
green substitutes functions with simpler approximate implementations or terminates loops early.
npus are a new class of accelerators that replace functions with hardware neural networks to approximately mimic the functions behavior.
more generally as the focus of the semiconductor industry shifts to programmable accelerators coarse grained approximation can pave the way for new classes of approximate accelerators that can deliver significantly better performance and energy savings.
.flexjavalanguage design we have designed a set of language extensions for approximate programming that satisfy four key criteria .safety.
the extensions guarantee safe execution.
in other words approximation can never lead to catastrophic failures such as array out of bound exceptions.
.modularity.
the extensions are modular and do not hinder modular programming and reuse.
.generality.
the extensions are general and enable utilizing a wide range of approximation techniques without exposing their implementation details.
.scalability.
the extensions are scalable and let programmers annotate large programs with minimal effort.
we have incorporated these extensions in the java language.
this section describes approximate programming in the resulting language flexjava using a series of examples.
in the examples bold underlinehighlight the safe to approximate data and operations that the flexjava compiler infers automatically from the programmer annotations.
section .
presents the formal semantics of the annotations and the static analysis performed by the compiler.
.
safe programming in flexjava providing safety guarantees is the first requirement for practical approximate programming.
that is the approximation should never affect critical data and operations.
the criticality of data and operations is a semantic property of the application that can only be identified by the programmer.
the language must therefore provide a mechanism for programmers to specify where approximation is safe.
this poses a language compiler co design challenge in order to alleviate the need for manually annotating all the approximate data and operations.
to address this challenge we provide two language annotations called loosen and 746tighten .
these annotations provide programmers with full control over approximation without requiring them to manually and explicitly mark all the safe to approximate data and operations.
selectively relaxing accuracy requirements.
as discussed above not all program data and operations are safe to approximate.
therefore flexjava allows each data and operation in the program to be either precise or approximate.
approximate data can be allocated in the approximate sections of memory and an approximate operation is a variant that may generate inexact results.
all data and operations are precise by default.
the loosen annotation allows to relax the accuracy requirement on a specified variable at a specified program point.
that is any computation and data that exclusively affects the annotated variable is safe to approximate.
for example in the following snippet the programmer uses loosen luminance to specify that the computation of luminance can be safely approximated.
float computeluminance float r float g float b float luminance r .3f g .6f b .1f loosen luminance return luminance from this single annotation the flexjava compiler automatically infers that data r g b and luminance can be safely allocated in the approximate memory.
it also infers that all arithmetic operations loads and stores that contribute to calculating luminance are approximable.
to provide memory safety and avoid null pointer exceptions operations that calculate addresses to access r g and bare not approximable.
a single annotation thus suffices to relax the accuracy of four variables and nine operations.
our language compiler codesign alleviates the need to manually annotate all these variables and operations.
control flow safety.
to avoid unexpected control flow flexjava keeps all the computation and data that affects control flow precise by default.
consider the following example int fibonacci int n int r if n r n else r fibonacci n fibonacci n loosen r return r variable ris annotated as an approximate output and naffects r. but since nalso affects control flow in the conditional it is not safe to approximate.
in many cases conditionals represent simple control flow that can be converted to data dependence.
programmers can add explicit loosen annotations to mark such conditionals approximate.
however to reduce programmer effort the flexjava compiler automatically achieves this effect by conservatively converting control dependencies into data dependencies using a standard algorithm .
the following example illustrates this optimization double sobel double p double x y g r x p ... y p ... g sqrt x x y y if g .
r .
else r g loosen r return r double sobel double p double x y g r x p ... y p ... g sqrt x x y y r g .
?
.
g l loosen r return r in the code snippet on the left by annotating r there are only a few opportunities for approximation since rdepends on gwhich is used in the conditional.
however the flexjava compiler can convert this control dependence to data dependence.
thisconversion is illustrated in the snippet on the right using the ternary ?
operator.
after conversion ris only data dependent ong which in turn makes gsafe to approximate.
consequently as the snippet on the right shows all data and operations that affect gare also safe to approximate.
as this example shows this automation significantly increases approximation opportunities without the need for extra manual annotations.
memory safety.
approximating address calculations may lead to memory access violations or contamination of critical data.
to avoid such catastrophic failures and provide memory safety any computation or data that affects address calculations is precise in flexjava .
similarly any computation or data that affects object allocation size is also precise.
however objects that do not contribute to address calculations allocation sizes or control flow may be allocated in approximate memory in accordance with the programmer annotations.
consider the following example int computeavgred pixel pixelarray int sumred for int i i pixelarray.length i sumred sumred int pixelarray .
r int avgred sumred pixelarray.length loosen avgred return avgred variables iandpixelarray are not approximable since they are used for address calculations.
but the contents of the pixel objects pointed to by the pixelarray elements e.g.
pixelarray .r are approximable due to loosen avgred .
as discussed before programmers can always override the default semantics and relax these strict safety guarantees.
restricting approximation.
flexjava provides the tighten annotation which is dual to loosen .
annotating a variable with tighten makes any data or operation that affects the variable precise unless a preceding loosen makes a subset of those data and operations approximable.
the following examples illustrate the interplay between loosen and tighten float computeavg pixel p float sum p.r p.g p.b tighten sum float avg sum .0f loosen avg return avg float computeavg pixel p float sum p.r p.g p.b loosen sum float avg sum .0f tighten avg return avg in the left example we relax the accuracy of data and operations that affect avgexcept those that affect sum.
conversely in the right example we relax the accuracy of data and operations that affect sumwhile keeping the last step of computing avg precise.
the flexjava compiler automatically introduces tighten annotations to prevent approximating control flow and address calculations.
the tighten annotation could also be used by programmers when critical data and operations are intertwined with their approximate counterparts.
no such cases appeared when annotating the evaluated benchmarks section .
.
.
modular approximate programming scoped approximation.
modularity is essential when designing a language since it enables reusability.
to make approximate programming with flexjava modular we define a scope for theloosen annotation.
the default scope is the code block that contains the annotation e.g.
the function or the loop body within which the loosen annotation is declared.
as the following example illustrates data and operations that are outside of the scope of the loosen annotation are not affected.
int p for int i i a.length i p a for int i i b.length i p b loosen p 747since loosen p is declared in the second loop that process the barray the operations outside of this loop e.g.
p a are not affected and cannot be approximated.
assigning scope to the loosen annotation provides separation of concerns.
that is the loosen annotation only influences a limited region of code that makes it easier for programmers to reason about the effects of the annotation.
furthermore the scope of approximation adheres to the syntactic structure of the program that makes annotating the code a natural part of the program development.
to ensure safety the scope for the tighten annotation is the entire program.
all data and operations in the program that affect the annotated variable in tighten will be precise.
the same principle applies to the conditionals and pointers.
the flexjava compiler automatically applies these global semantics and relieves programmers from safety concerns.
reuse and library support in flexjava.composing independently developed codes to build a software system is a vital part of development.
composability must be supported for the annotations.
to this end we define two variants for the loosen the default case and the invasive case loosen invasive .
these variants have different semantics when it comes to function calls.
if a function call is in the scope of a loosen annotation and its results affects the annotated variable it may be approximated only if there are loosen annotations within the function.
in other words the caller s annotations will not interfere with the annotations within the callee and may only enable them.
if the callee does not affect caller s annotated variable its internal loosen annotations will not be enabled.
with this approach the library developers can develop general approximate libraries independently regardless of the future specific use cases.
the users can use these general libraries without concerning themselves with the internal annotations of the libraries.
the following examples demonstrate the effects of loosen for function calls.
static int square int a int s a a loosen s return s public static void main string args int x square loosen x system.out.println x static int square int a int s a a loosen s return s public static void main string args int x square system.out.println x in the left example as highlighted loosen x declares the local operations with the main function as safe to approximate.
the annotation also enables approximation in the square function that was called in the scope of the loosen x annotation.
within thesquare function the approximation will be based on the annotations that are declared in the scope of square .
as the right example illustrates if there are no loosen annotations in the caller function main nothing will be approximated in the callee function square .
an expert user may want to apply approximation to the callee functions even if they do not contain any internal annotations.
flexjava provides the loosen invasive for such cases.
the loosen invasive enables applying approximation to the conventional libraries that are not annotated for approximation.
note that loosen invasive does not cause control flow or memory address calculations to be approximated as we discussed for loosen .
the only difference is how approximation is enforced in the callee function as illustrated below.static int square int a int s a a return s public static void main string args int x square loosen x system.out.println x static int square int a int s a a return s public static void main string args int x square loosen invasive x system.out.println x in the left example the loosen x annotation approximates the local operations in main function but will not lead to any approximation in the square function since it does not contain any loosen annotations.
in contrast in the right example loosen invasive x enforces safe approximation in square since its return value affects x. supporting separate compilation.
flexjava supports separate compilation .
that is a flexjava program can link with both annotated and unannotated pre compiled code without having to re compile it.
if the precompiled code is not annotated it executes precisely.
if the precompiled code is annotated its annotations are respected and its data and operations are approximated accordingly.
moreover the annotations in the new program will not approximate any additional operations and data in the precompiled code other than the ones already approximated by annotations in them.
.
oo programming in flexjava to this point we have described how to use flexjava annotations to identify approximate data and operations within methods of a class.
this section describes how to declare class fields as approximate and how inheritance and polymorphism interplay with the annotations.
approximating class fields.
since class fields are not declared in the scope of any of the methods we allow the programmers toselectively relax their semantics in the constructor of the class.
the fields will be allocated in the approximate section of the memory if an outer level loosen enables approximation in the constructor.
in principle instantiation of an object involves a function call to the constructor.
the outer level loosen annotations have the same effect on constructors as they have on other function calls.
class a float x y a float x float y this .x x this .y y loosen x public static void main a a new a .5f .0f float p .5f a. x loosen p the annotated pis affected by the instance of a. therefore loosen p enables approximation in the constructor.
consequently thexfield will be allocated in the approximation section of the memory because of the loosen x in the constructor.
the yfield will not be allocated in the approximation section since it is not annotated in the constructor.
inheritance.
when inheriting an annotated class annotations are preserved in methods that are not overridden.
naturally if the child class overrides a method the overriding method must be re annotated if approximation is desired.
polymorphism due to approximation.
depending on the annotations different instances of a class and different calls to a method may carry approximate or precise semantics.
the flexjava compiler generates different versions of such classes and methods using code specialization .
.
generality in flexjava support for coarse grained approximation the annotations discussed so far enable fine grained approximation at the level of single operations and data.
this section describes another form of annotations the begin loose end loose pair that enables coarse grained approximation in flexjava .
any arbitrary code block that is enclosed between this pair of annotations can be approximated as a whole.
both annotations have a variable argument list.
the first argument of begin loose which is a string identifies the type of approximation that can be applied to the code block.
the compiler or the runtime system then can automatically apply the corresponding approximation technique.
some approximation techniques may require programmers to provide more information.
for example function substitution requires the programmer to provide an approximate version of the function.
this extra information can be passed to the compiler or runtime system through the arguments of begin loose orend loose .
this approach is flexible enough to enable a variety of coarse grained approximation techniques.
we describe how to use the approach with two such techniques loop perforation and npus .
loop perforation.
loop perforation allows the runtime to periodically skip iterations of loops.
the programmer can set the initial rate of perforation skipping the iterations .
flexjava annotations can be used for loop perforation as the following example shows.
begin loose perforation .
for int i i n i ... end loose the begin loose perforation .
and end loose annotations identify the loop that can be approximated.
the first argument of begin loose perforation declares that the desired approximation technique is loop perforation.
the second argument .
identifies the rate of perforation.
neural acceleration.
neural processing units npu are a new class of accelerators that replace computeintensive functions with hardware neural networks.
we give an overview of the npu compilation workflow since we use them to evaluate flexjava s coarse grained annotations.
the compiler first automatically trains a neural network on how an approximable code block behaves.
then it replaces the original block with an efficient hardware implementation of the trained neural network or the npu.
this automatic code transformation also identifies the inputs and outputs of the region.
the compiler performs the transformation in four steps .input output identification.
to train a neural network to mimic a code block the compiler needs to collect the input output pairs that represent the functionality of the block.
therefore the first step is identifying the inputs and outputs of the delineated block.
the compiler uses a combination of live variable analysis and mod ref analysis to automatically identify the inputs and outputs of the annotated block.
the inputs are the intersection of live variables at the location of begin loose npu with the set of variables that are referenced within the segment.
the outputs are the intersection of live variables at the location of end loose with the set of variables that are modified within the segment.
in the example that follows this analysis identifies xandyas the inputs to the block and pandqas the outputs.
.code observation.
the compiler instruments the program by putting probes on the inputs and outputs of the block.
then it profiles the instrumented program using representative input datasets such as those from a test suite.
the probespackage edu.flexjava abstract class qualitymetric double acceptablequalityloss .
qualitymetric double q acceptablequalityloss q abstract void checkquality object... o abstract void recover object... o figure an abstract class for defining the quality metric.
package edu.flexjava class flexjava static void loosen object... o static void loosen invasive object... o static void tighten object... o static void begin loose string type object... o static void end loose object... o figure f lexjavaannotations are implemented as a library.
log the block inputs and outputs.
the logged input output pairs form the training dataset.
.training.
the compiler uses the collected input output dataset to configure and train a multilayer perceptron neural network that mimics the approximable block.
.code generation.
finally the compiler replaces the original block with a series of special instructions that invoke the npu hardware sending the inputs and receiving the computed approximate outputs.
the following example illustrates the use of flexjava annotations for npu acceleration.
double foo double x double y begin loose npu p math.sin x math.cos y q math.sin x y end loose return p q the programmer uses begin loose end loose to indicate that the body of function foois a candidate for npu acceleration.
the first argument of begin loose npu indicates that the approximation technique is npu acceleration.
.
support for expressing quality metrics quality requirements and recovery practical and complete approximate programming languages need to provide a mechanism to specify and express quality metrics quality requirements and recovery mechanisms.
as shown in prior works on approximation quality metrics are application dependent .
for example an image processing application may use signal to noise ratio as the quality metric while the quality metric for web search is relevance of the results to the search query.
the quality metric for machine learning algorithms that perform classification is the misclassification rate.
consequently the common practice in approximate computing is for programmers to specify the application quality metric and the acceptable level of quality loss.
the flexjava annotations can be naturally extended to express quality metrics and requirements.
as figure shows we first provide an abstract class as a template for implementing the quality metric function.
the programmer can implement this abstract class and override the checkquality function to implement the quality metric.
the constructor of this class can be used to set the acceptable level of quality loss acceptablequalityloss .
the programmer can also override the recover to implement a recovery procedure for the occasions that the quality loss is greater than the requirements.
note that the quality requirement can be expressed as a probability if desired.
after implementing the qualitymetric class the programmer can pass its instance via the last argu749 real constant r2r variable v2v real expression e2r v operation label l2l statement s v l e1 e2 jloosen v jtighten v jassume v js1 s2js1 s2js figure language syntax.
stack 2v!r tainted set t v state !
hs tijh tijerrorjhalt figure semantic domains.
ment of loosen loosen invasive orend loose to the compiler or the runtime system.
clearly the programmer need not specify the quality metric in each such annotation it is usually specified only when annotating the final output or important functions of the application as illustrated in the following example.
static int cube int x int y x x x loosen y return y public static void main string args int z cube loosen z new applicationqualitymetric .
system.out.println z notice that the quality requirement is not specified in the function or library annotations loosen y .
it is specified only in the last annotation on the final output zof the program.
in this example the acceptable quality loss is which is passed to the constructor as .
.
.flexjavaimplementation flexjava is a small set of extensions to java that enables safe modular general and scalable object oriented approximate programming.
it achieves these goals by introducing only four intuitive annotations loosen tighten loosen invasive and thebegin loose end loose pair.
in this section we describe our implementation of these annotations and the development environment of flexjava .
implementation of annotations.
we implemented flexjava annotations as a library to make it compatible with java programs and tools.
figure illustrates this library based implementation that provides the interface between the flexjava language and compiler.
the flexjava class implements the annotations as empty variable length argument functions.
consequently compiling a flexjava program with a traditional compiler yields a fully precise executable.
the approximationaware compiler however can intercept calls to these functions and invoke the necessary analyses and approximate transformations.
integrated highlighting tool.
flexjava is coupled with a static approximation safety analysis that automatically infers the safeto approximate operations and data from the programmer annotations.
we have developed an integrated tool that highlights the source code with the result of this analysis.
by visualizing the result this tool further facilitates flexjava programming and can help programmers to refine their annotations.
in its current form the integrated tool adds comments at the end of each line showing which of the line s operations are safe to approximate.
it is straightforward to convert this visual feedback to syntax highlighting.
in fact we used the result of this tool to highlight the examples in section .. .
approximation safety analysis in this section we define the formal semantics of approximation safety for annotated programs in flexjava .
we definea core language with loosen and tighten annotations.
we give a concrete semantics parameterized by the set of operations to be approximated in an annotated program in the language.
the semantics determines if a given set of operations is approximable.
as this problem is undecidable we develop a static analysis that conservatively infers the largest set of approximable operations in a given annotated program.
.
core language figure shows the syntax of our core language.
it supports real valued data and control flow constructs for sequential composition branches and loops.
we elide conditionals in branches and loops executing them nondeterministically and using the assume v construct that halts if v .
we extend the language with annotations loosen v and tighten v .
these annotations arise from their source level counterparts described in section .. further tighten v is implicitly added by the flexjava compiler before each use of variable vin a conditional an array index a pointer dereference or a program output.
to statically identify operations that are approximable under the given annotations each operation has a unique label l. example.
we illustrate the above concepts for the program on the left below.
for now ignore the sets in annotations next to each line of the program.
l l v1 input v1 v2 input v1 v2 v2 tighten v1 t v2 while v1 t v2 v1 f v1 t v2 v2 g v2 t v2 tighten v1 t v2 t v2 loosen v2 t tighten v2 t output v2 t the compiler introduces tighten v1 on lines and to ensure that v1 0executes precisely and tighten v2 on line to ensure that the value of v2output on line is precise.
the programmer relaxes the accuracy of v2on line which allows the operations writing to v2on lines and to be approximated without violating the tighten v2 requirement on line .
however the operations writing to v1on lines and cannot be approximated as they would violate the tighten v1 requirement on line or respectively.
.
concrete semantics we define a concrete semantics to formalize approximation safety for our language.
figure shows the semantic domains.
each program state !
except for special states error and halt described below tracks a tainted settof variables.
a variable gets tainted if its value is affected by an approximate operation and untainted if loosen is executed on it.
figure shows the semantics as a set of rules of the form lj hs t1i h t2ijhaltjerror it describes an execution of annotated program swhen the set of approximated operations is l starting with stack i.e.
valuation to variables 1and tainted set t1.
the rules are similar to information flow tracking approximated operations in lare sources ruleasgn loosen v aresanitizers ruleloosen and tighten v aresinks rules tightenpass andtightenfail .
the execution ends in state error if some tighten v is executed when the tainted set contains v as described by rule tightenfail.
the execution may also end in state halt which is normal and occurs when assume v fails i.e.
v as described by 750lj hv l e1 e2 ti h t0i wheret0 t fvgifl2loruses e1 e2 t6 tnfvgotherwise asgn lj hloosen v ti h tnfvgi loosen lj htighten v ti h ti tightenpass lj htighten v ti error tightenfail lj hassume v ti h ti asmpass lj hassume v ti halt asmfail figure concrete semantics of approximation safety.
rulesasmpass andasmfail .
we omit the rules for compound statements and those that propagate error and halt as they are relatively standard and do not affect the tainted set.
we now define approximation safety formally defn .. approximation safety a set of operations lin a programsis approximable if lj hs i6 error.
to maximize approximation we seek as large a set of approximable operations as possible.
in fact a unique largest set exists as our semantics satisfies the property that if operation sets l1 andl2are approximable then so is l1 l2.
example.
in the example program the largest set of approximable operations is those on lines and .
column l shows the tainted set as per our semantics after each statement under this set of approximated operations.
the error state is unreachable in any run as the tainted set at each tighten v does not contain v. hence this set of operations is approximable.
.
static analysis the problem of determining if a given set of operations is approximable in a given annotated program even in our core language is undecidable.
we present a novel static analysis that conservatively solves this problem i.e.
if the analysis deems a set of operations as approximable then it is indeed approximable according to defn.
.. .
further we apply an efficient algorithm that uses the analysis to automatically infer the largest set of approximable operations.
our static analysis is shown in figure .
it over approximatesthe tainted sets that may arise at a program point in the concrete semantics by an abstract state d a set each of whose elements is or an abstract tainted set of variables.
the analysis is a set of transfer functions of the form fl d d0 denoting that when the set of approximated operations is l the annotated program stransforms abstract state dinto abstract state d0.
the element arises ind0either if it already occurs in dor ifscontains a tighten v statement and an abstract tainted set incoming into that statement contains the variablev.
thus the element indicates a potential violation of approximation safety.
in particular an annotated program does not violate approximation safety if the analysis determines that starting from input abstract state f g the output abstract state does not contain theorem .. soundness for each program s if 2fl f g then for each state lj hs i6 error.
example.
for our example from section .
the columns on the right show the abstract state computed by the analysis after each statement under the set of approximated operations indicated by the column header.
for l the final abstract state contains and indeed the operations on lines and are not approximable.
but for l the final abstract state does not contain proving that operations on lines and are approximable.
abstract tainted set 2v abstract state d d f g fl 2d!2d fl d fl fl d fl d fl d d fl d leastfix d0 d d0 fl d ftrans l d jd2dg for atomic statement t where trans l trans l fvgifl2l uses e1 e2 nfvgotherwise trans l ifv otherwise trans l nfvg figure approximation safety analysis.
our static analysis has the useful property that for any annotated program there exists a unique largest set of operations that it considers approximable.
theorem .. unique largest solution 9lmax l flmax f g 2fl f g l lmax .
we use a standard algorithm to infer this largest set of approximable operations.
starting with all operations approximated it iteratively finds a largest set of approximable operations which passes all the tighten checks in the program.
.flexjavaevaluation this section aims to answer the following research questions.
rq1 can flexjava significantly reduce the number of manual annotations?
rq2 can flexjava significantly reduce the programmer effort and annotation time?
rq3 can flexjava give significant speedup and energy gains with both fine and coarse grained approximation?
as the results of the evaluations show flexjava reduces the number of annotations between and compared to enerj the leading approximation language.
we also conduct a user study that shows from to12 reduction in annotation time compared to enerj.
flexjava however provides the same level of energy savings from to38 compared to enerj with fine grained approximation.
with coarse grained approximation flexjava achieves .
energy reduction and .
speedup for under quality loss.
benchmarks and quality metrics.
as table shows we evaluateflexjava using 10java programs.
eight are the enerj benchmarks .
we use two additional benchmarks hessian and sobel.
five of these come from the scimark2 suite.
the rest arezxing an android bar code recognizer jmeint an algorithm to detect intersecting 3d triangles part of the jmonkeyengine game engine sobel an edge detection application based on the sobel operator and raytracer a simple 3d ray tracer.
to better study the scalability of our analysis we added the hessian application from the boofcv vision library with lines of code.
this application uses the hessian affine region detector to find interesting points in an image.
the code for this application uses java generics that is not supported by the enerj compiler and simulator.
however our safety analysis supports java generics and was able to analyze this application.
therefore only for this specific application our comparisons are limited to annotation effort and safety analysis.
table also shows the applicationspecific quality metrics.
we measure quality by comparing the 751table benchmarks quality metrics and results of safety analysis analysis runtime and of approximable data and operations.
sor avg entry difference smm avg normalized difference mc normalized difference fft avg entry difference lu avg entry difference sobel image edge detection avg pixel difference raytracer 3d image renderer avg pixel difference jmeint jmonkeyengine game triangle intersection kernel percents of correct decisions hessian interest point detection in boofcv library avg euclidean distance zxing bar code decoder for mobile phones percents of correct results scimark2 benchmark scientific kernelsdescriptionquality metricbenchlibraryinferredpotentialinferredpotential3660k68141332823860k69171142785960k471312918416860k11111422648528360k151219201600163284k10225153416174214k14491282645 962216k296717183294310 174261k6 171271k12 454analysisruntime sec of approximabledata of approximatedoperations of lines annotations sor smm mc t lu sobel raytracer jmeint hessian zxing440 14109enerj flexjava figure number of annotations required to approximate the same set of data and operations using enerj and f lexjava.
output of the fully precise and the approximated versions of the program.
for each benchmark we use 10representative input datasets such as 10different images.
the quality degradation is averaged over the input datasets.
.
rq1 number of annotations to answer rq1 we compare the number of enerj annotations withflexjava annotations.
we use enerj as a point of comparison because it requires the minimum number of annotations among existing approximate languages .
enerj requires programmers to annotate all the approximate data declarations using type qualifiers.
then the enerj compiler infers the safe to approximate operations for fine grained approximation.
in contrast our approximation safety analysis infers both approximate data and operations from a limited number of flexjava annotations on the program or function outputs.
we used the chord program analysis platform to implement our approximation safety analysis.
compared to enerj our analysis infers at least as many number of safe to approximate data and operations with significantly fewer number of manual annotations.
figure shows the number of annotations with enerj and flexjava .
as figure illustrates there is a significant reduction in the number of annotations with flexjava .flexjava requires between mc to hessian less annotations than enerj.
the largest benchmark in our suite is zxing with lines of code.
it requires 696annotations with enerj 109annotation with flexjava .
thus flexjava reduces the number of annotations by a factor of .
the zxingbenchmark needs several loosen annotations to mark its function outputs as approximable.
further many condition variables are safe to approximate and such variables need to be annotated explicitly.
therefore zxing requires a number of flexjava annotations that is relatively large compared to all other benchmarks.
these results confirm thatflexjava annotations and its approximation safety analysis can effectively reduce the number of manual annotations.
the results in figure are with no use of loosen invasive .
using loosen invasive only reduces the number of annotationswithflexjava .
moreover in the evaluated benchmarks there is no need for any manual tighten annotations.
as described before flexjava s approximation safety analysis automatically inserts tighten annotations for the critical variables to ensure control flow and memory safety.
the flexjava highlighting tool was useful since it effectively visualizes the result of the automated approximation safety analysis.
approximation safety analysis.
in table columns of lines and analysis runtime sec report the number of lines in each program and the runtime of the approximation safety analysis.
the analysis analyzes application code and reachable java library jdk code uniformly although we report their sizes separately in the table.
the analysis was performed using oracle hotspot jvm .
.
on a linux machine with .
ghz quad core processors and gb memory.
the analysis runtime strongly correlates with the number of potentially approximable data and operations.
the potential approximable elements include all the data declarations and all the operations that are not address calculations and jump or branch instructions in the byte code.
the number of potential elements is presented in columns of approximable data potential and of approximable operations potential respectively.
the analysis determines whether or not each of these elements is safe to approximate with respect to the programmer annotations.
the number of all the potential approximable elements defines the search space of the analysis.
thus the space of possible solutions that the approximation safety analysis explores for zxing is of size .
automatically finding the largest set of approximable elements from this huge space justifies the seconds hours and minutes of running time to analyze zxing.
however the analysis runtime is not exponential with respect to the number of potential elements.
that is because in each iteration the analysis eliminates at least one element from the potentials list.
naturally significantly reducing the number of manual annotations requires an automated analysis that takes some machine time.
that is the analysis is trading machine time for fewer annotations potentially saving programmer time.
furthermore we report the pessimistic runtime when all of the libraries and program codes are analyzed in a single compiler run without separate compilation.
separate compilation may reduce this runtime when precompiled approximate libraries are available.
.
rq2 programmer effort annotation time to answer rq2 we conduct a user study involving ten programmers.
the programmers are asked to annotate three programs with both languages.
to avoid bias in our study toward flexjava we used three programs from the enerj benchmark suite .
the benchmarks are not large so that the subjects can understand their functionality before annotating them.
as presented in figure we measure the annotation time with enerj and flexjava and compare the results.
the subjects are computer science graduate students who have prior background 7520510152025annotation time min s1 s2 s3 s4 s5 s6 s7 s8 s9s10 avgenerj flexjava a annotation time for sor 0510152025annotation time min s1 s2 s3 s4 s5 s6 s7 s8 s9s10 avg26.
enerj flexjava b annotation time for smm 0510152025annotation time min s1 s2 s3 s4 s5 s6 s7 s8 s9s10 avg39.
enerj flexjava c annotation time for fft figure annotation time with enerj and f lexjavafor a sor b smm and c fft.
the x axes denotes the user study subjects.
in java programming but have no experience in approximate programming.
we measured the annotation time using the following procedure.
first we orally explain how to annotate the programs with flexjava and enerj.
then we demonstrate the annotation process on a simple benchmark mc and show the subjects how to use the tools for both languages.
for this study the subjects then annotate three of benchmarks sor smm and fft using both languages.
half of the subjects use enerj annotations first and the other half use flexjava first.
the measured time for enerj constitutes annotation plus compilation time.
whereas the measured time for flexjava constitutes annotation time plus the time for running the approximation safety analysis plus the time for analyzing the analysis results using the source highlighting tool.
we provide the unannotated application and a description of its algorithm for the subjects.
we allow the subjects to review each application code prior to annotating it.
our current highlighting tool is enough to check whether or not the analyzed results are equivalent between the two languages.
figure shows the annotation time.
on average the annotation time with flexjava is less than enerj for sor smm and fft respectively.
although we demonstrate how the subjects can use the languages they need time to gain experience while annotating the first program.
once the subjects acclimate to flexjava with the first benchmark sor they spend proportionally less time annotating the next benchmark.
theflexjava annotation time for the second benchmark smm is typically lower than the first benchmark sor .
in contrast the annotation time with enerj does not reduce beyond a certain point even after gaining experience.
we believe that this is because enerj requires manually annotating all the approximate variable declarations and more.
using flexjava sorand smm require three loosen annotation but fftrequires six.
we believe that this explains why the time to annotate fftinflexjava is greater than the time to annotate sorand smm.
in summary these results show that flexjava significantly reduces programmer effort by providing intuitive language extensions and leveraging the automated approximation safety analysis.
.
rq3 energy reduction and speedup to answer rq3 we study energy gains and speedup of flexjava with both fine and coarse grained approximation.
.
.
fine grained approximation tools and models.
we modify and use the enerj open source simulator for error and energy measurements.
the simulator provides the means to instrument java programs based on the result of the analysis.
it allows object creation and destruction in approximate memory space and approximating arithmetic and logic operations.
the runtime simulator is a java library that is invoked by the instrumentation.
the simulator records memory footprint and arithmetic operation statistics while simultaneously injecting error to emulate approximate execution energy reductionsor smm mc t lu sobel raytracer jmeint zxing gmeanmild medium aggressive a energy reduction quality loss sor smm mc t lu sobel raytracer jmeint zxingmild medium aggressive b quality loss figure a energy reduction and b quality loss when approximating all the safe to approximate data and operations.
and measure error.
the simulator uses the runtime statistics to estimate the amount of energy dissipated by the program.
the error and energy measurements are based on the system models described in table .
the models and the simulator do not support performance measurements.
we measured the error and energy usage of each application over ten runs and average the results.
figure shows the energy reduction and the output quality loss when the safe to approximate data and operations are approximated.
these results match those of enerj .
as shown the geometric mean of energy reduction ranges from with the mildhardware setting to with the aggressive hardware setting.
the energy reduction is least for jmeint with mild and highest for raytracer with aggressive .
all the applications show low and acceptable output quality loss with themildsetting.
however in most cases there is a jump in quality degradation when the hardware setting is changed to aggressive .
if this level of quality is not acceptable fft then the application should dial down the hardware setting to medium or mild.flexjava provides the same level of benefits and quality degradations as enerj while significantly reducing the number of manual annotations.
.
.
coarse grained approximation to evaluate flexjava s generality we use the npu coarsegrained approximation .
npu can only be used to approximate the benchmarks fft sobel raytracer and jmeint .
each benchmark has only one function that can be approximated with npus.
each of these functions can be delineated using a single pair of begin loose end loose annotation.
tools and models.
we measure the benefits of npus in conjunction with a modern intel nehalem core i7 processor.
we use a source to source transformation that instruments the quality loss0 speedupenergy reductionfftsobelraytracerjmeintgmean0 fftsobelraytracerjmeintgmeanfftsobelraytracerjmeintgmeanfigure speedup energy reduction and output quality loss when the approximate annotated functions using the npu.
benchmarks java code to emit an event trace including memory accesses branches and arithmetic operations.
this source level instrumentation is unaffected by the jit garbage collection or other vm level systems.
using a trace based simulator we generate architectural event statistics.
the architectural simulator includes a cache simulation.
the simulation process outputs detailed statistics including the cycle count cache hit and miss counts and the number of functional unit invocations.
the trace based cpu simulator is augmented with a cycle accurate npu simulator that also generates the statistics required for the npu energy estimation.
the resulting statistics are sent to a modified version of mcpat to estimate the energy consumption of each execution.
we model the energy consumption of an eight processing engine npu using the results from cacti .
mcpat and .
figure shows the energy reduction speedup and quality loss with the npu coarse grained approximation.
the baseline executes the precise version of the benchmark on the cpu without any npu approximation.
on average the benchmarks see a .
energy reduction and a .
speedup.
these benefits come for less than quality degradation across all the benchmarks which is commensurate with other approximation techniques and prior npu works .
the enerj system does not provide any coarse grained approximation results for comparison.
these results demonstrate that coarse grained approximation may have limited applicability but can provide higher benefits.
whereas fine grained approximation is more widely applicable with possibly lower gains.
flexjava supports both granularities as a general language to maximize opportunities for approximation in a wider range of applications.
.
related work there is a growing body of work on language design reasoning analysis transformations and synthesis for approximate computing.
these works can be characterized based on static vs. dynamic approximation granularity automation and safety guarantees.
to this end flexjava is a language accompanied with an automated static analysis that supports both fine and coarse grained approximation and provides formal safety guarantees.
we discuss the related work with respect to these characteristics.
enerj is an imperative programming language that statically infers the approximable operations from approximate type qualifiers on program variables.
in enerj all approximable variables must be explicitly annotated.
enerj works at the granularity of instructions and provides safety but not quality guarantees.
rely is another language that requires programmers to explicitly mark both variables and operations as approximate.
rely works at the granularity of instructions and symbolically verifies whether the quality requirements are satisfied for each function.
to provide this guarantee rely requires the programmer to not only mark all variables and operations as approximate but also provide preconditions on the reliabilityand range of the data.
both enerj and rely could be a backend forflexjava when it automatically generates the approximate version of the program.
axilog introduces a set of annotations for approximate hardware design in the verilog hardware description language.
verilog does not support imperative programming constructs such as pointers structured data memory allocation recursion etc.
the lack of these features results in fundamentally different semantics for safe approximation and annotation design.
chisel uses integer linear programming ilp formulation to optimize approximate computational kernels.
a chisel program consists of code written in an imperative language such as c and a kernel function written in rely that will be optimized.
several works have focused on approximation at the granularity of functions or loops.
loop perforation is an automated static technique that periodically skips loop iterations.
even though loop perforation provides statistical quality guarantees the technique is not safe and perforated programs may crash.
green provides a code centric programming model for annotating loops for early termination and functions for approximate substitution.
the programmer needs to provide the alternative implementation of the function.
green is also equipped with an online quality monitoring system that adjusts the level of approximation at runtime.
such runtime adjustments are feasible due to the coarse granularity of the approximation.
flexjava provides the necessary language extensions for supporting these coarse grained approximation techniques as well as the fine grained ones.
similar to enerj uncertain t is a type system for probabilistic programs that operate on uncertain data.
it implements a bayesian network semantics for computation on probabilistic data.
similarly uses bayesian networks and symbolic execution to verify probabilistic assertions.
.
conclusion practical and automated programming models for approximation techniques are imperative to enabling their widespread applicability.
this paper described one such language model that leverages automated program analysis techniques for more effective approximate programming.
the flexjava language is designed to be intuitive and support essential aspects of modern software development safety modularity generality and scalability.
we implemented flexjava and its approximation safety analysis and evaluated its usability across different approximation techniques that deliver significant energy and performance benefits.
the results suggest that flexjava takes an effective and necessary step toward leveraging approximation in modern software development.
.