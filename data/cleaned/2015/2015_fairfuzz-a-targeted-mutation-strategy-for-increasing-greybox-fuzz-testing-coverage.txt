fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coverage caroline lemieux university of california berkeley usa clemieux cs.berkeley.edukoushik sen university of california berkeley usa ksen cs.berkeley.edu abstract in recent years fuzz testing has proven itself to be one of the most effective techniques for finding correctness bugs and security vulnerabilities in practice.
one particular fuzz testing tool american fuzzy lop afl has become popular thanks to its ease of use and bug finding power.
however afl remains limited in the bugs it can find since it simply does not cover large regions of code.
if it does not cover parts of the code it will not find bugs there .w ep r o pose a two pronged approach to increase the coverage achieved by afl.first theapproachautomaticallyidentifiesbranchesexercised by few afl produced inputs rare branches which often guard code that is empirically hard to cover by na vely mutating inputs.
the second part of the approach is a novel mutation mask creation algorithm which allows mutations to be biased towards producing inputs hitting a given rare branch.
this mask is dynamically computed during fuzz testing and can be adapted to other testing targets.
we implement this approach on top of afl in a tool named fairfuzz.
we conduct evaluation on real world programs against state of the art versions of afl.
we find that on these programs fairfuzz achieves high branch coverage at a faster rate that stateof the art versions of afl.
in addition on programs with nested conditional structure it achieves sustained increases in branch coverageafter24hours average10.
increase .inqualitativeanalysis we find that fairfuzz has an increased capacity to automatically discover keywords.
ccs concepts software and its engineering software testing and debugging keywords fuzz testing coverage guided greybox fuzzing rare branches acm reference format caroline lemieux and koushik sen. .
fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coverage.
in proceedingsof the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm new york ny usa 11pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction fuzz testing has emerged as one of the most effective testing techniques for finding correctness bugs and security vulnerabilities in real worldsoftwaresystems.ithasbeenusedsuccessfullybymajor software companies such as microsoft and google for security testing and quality assurance.
the success of coverageguidedgreyboxfuzzing cgf inparticularhasgainedattentionboth in practice and in the research community .
one of the leading cgf tools american fuzzy lop or simply afl has found vulnerabilities in a broad array of programs including web browsers e.g.
firefox internet explorer network tools e.g.
tcpdump wireshark image processors e.g.
imagemagick libtiff various system libraries e.g.
openssh pcre c compilers e.g.
gcc llvm and interpreters for perl php javascript .
coverage guided greybox fuzzing is based on the observation thatincreasingprogramcoverageoftenleadstobettercrashdetection.
the actual fuzzing process starts with a set of user provided seed inputs.
it then mutates the seed inputs with byte level operations.
it runs the program under test on the mutated inputs and collects program coverage information.
finally it saves the mutated inputs which are interesting according to the coverage information the ones that discover new coverage.
it continually repeats the process but starting with these interesting mutated inputs instead of the user provided inputs.
while many of the individual test inputs it generates may be garbage duetoitslowcomputationaloverhead cgfgeneratestest inputs much faster than more sophisticated methods such as symbolic execution and dynamic symbolic execution a.k.a.
concolic testing techniques .
in practice this trade off has paid off and cgf has found numerous correctness bugs and security vulnerabilities in widely used software .
althoughthegoalofaflandothercgftoolsistofindassertion violations and crashes as quickly as possible their core search strategies are based on coverage feedback afl tries to maximize the coverage it achieves.
this is because there is no way to find bugsorcrashesataparticularprogramlocationunlessthatlocationis covered by a test input.
however while experimenting with afl and its extensions we observed that afl often fails to cover key program functionalities.
for example afl did not cover colorspaceconversioncodein djpeg attributelistprocessingcodein xmllint and a large variety of packet structures in tcpdump .
therefore afl cannot be expected to find bugs in these functionalities.
put succinctly if afl does not cover some program regions it will not find bugs in those regions.
we propose a lightweight technique called fairfuzz which helps afl achieve better coverage.
this technique requires noextrainstrumentation beyond afl s regular instrumentation unlike authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france caroline lemieux and koushik sen some other recently proposed fuzzing techniques .
thus the technique preserves afl s ease of use.
while we focus on branch coverage our proposed technique could easily be modified for other kinds of coverage and testing objectives.
fairfuzz is based on a novel mutation strategy that increases the probability of hitting the code locations that have been hit by few of afl s previously generated inputs.
fairfuzz works in two main steps.
first it identifies the program branches that are rarely hit by previously generated inputs.
we call such branches rare branches.
these rare branches guard under explored functionalities of the program.
by generating more random inputs hitting these rare branches fairfuzz greatly increases the coverage of the parts of the code guarded by them.
second fairfuzzusesanovellightweightmutationtechniqueto increasetheprobabilityofhittingtheserarebranches.themutation strategy is based on the observation that certain parts of an input already hitting a rare branch are crucial to satisfy the conditions necessary to hit that branch.
therefore to generate more inputshitting the rare branch via mutation the parts of the input that are crucial for hitting the branch should not be mutated.
fairfuzz identifies these crucial parts of the input by performing a number of small mutation experiments.
later in test input generation itavoids mutating these crucial parts of the input.
this mutationstrategy is orthogonal to approaches that try to increase crashes found by afl by helping afl pass magic byte checks o rb y customizing power schedules and can be combined with them to simultaneously increase code coverage and the number of bugs or crashes discovered.
we implemented our technique fairfuzz on top of afl.
we evaluated fairfuzz against three popular versions of afl.
wecompare to aflfast an extension of afl which prioritizes inputsthathitrarepathsthroughtheprogram butdoesnotchangethemutationtechniquesofafl.weconductourevaluationonnine real world benchmarks including those used to evaluate aflfast.
we repeat our experiments and provide measures of variability whencomparingtechniquesinourevaluation.wefindthatonthese benchmarksfairfuzzachieveshighbranchcoverageatafasterrate that state of the art versions of afl average .
increase after hour and3.
increaseafter5hours .priorworkdemonstratesthatafteracertainamountofcoverageisachieved evensmallincreasesinbranchcoveragecanyieldmorebugfindingpower .fairfuzz has a stronger advantage on programs with nested conditional structure obtainingsustainedincreasesinbranchcoverage average .
increaseafter24hours and accordingtoqualitativecoverage analysis better discovering complex keywords.
in summary we make the following contributions we propose a novel lightweight mutation masking strategy to increase the chance of hitting the program regions thatare missed by previously generated inputs.
we describe amethod to implement mutation masking which smoothly integrates with the usual fuzz testing mutation procedure.
we develop an open source1implementation of mutation masking targeted to rare branches on top of afl named fairfuzz.
afl algorithm.
procedure fuzztest prog seeds queue seeds whiletruedo begin a queue cycle forinputinqueuedo if isworthfuzzing input then continue score performancescore prog input for0 i input do formutation indeterministicmutationtypes do newinput mutate input mutation i runandsave prog newinput queue for0 i scoredo newinput mutatehavoc input runandsave prog newinput queue procedure mutatehavoc prog input nummutations randombetween newinput input for0 i nummutations do mutation randommutationtype position randombetween newinput newinput mutate newinput mutation position returnnewinput procedure runandsave prog input queue runresults run prog input ifnewcoverage runresults then addtoqueue input queue we perform evaluation of fairfuzz against different stateof the art versions of afl on real world benchmarks.
we detail the general method and implementation of fairfuzz insection 3andtheperformanceresultsinsection .wewillbegin in section 2with a more detailed overview of afl its current limitations and how to overcome these with our method.
overview our proposed technique fairfuzz is built on top of americanfuzzy lop afl .
afl is a popular greybox mutation based fuzz tester.
greybox fuzz testers are designated as such since unlikewhitebox fuzz testers they do not do any source code analysis but unlike pure blackbox fuzz testers theyuselimitedfeedbackfromtheprogramundertesttoguidetheir fuzzing strategy.
next we give a brief description of afl illustrate one of its limitations and motivate the need for fairfuzz.
.
afl overview to fuzz test programs afl generates random inputs.
however instead of generating these inputs from scratch it selects a set of previouslygeneratedinputsandmutatesthemtoderivenewinputs.
the overall afl fuzzing algorithm is given in algorithm .
the fuzzing routine takes as input a program and a set of userprovided seed inputs .
the seed inputs are used to initialize a queue line2 of inputs.
afl goes through this queue line selects an input to mutate line mutates the input lines runs the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coveragease september montpellier france program on and simultaneously collects the coverage information for the mutated inputs line and finally adds these mutated inputs to the queue if they achieve new coverage line .
an entire pass through the queue is called a cycle.
cycles are repeated line3 until the fuzz testing procedure is stopped by the user.
afl s mutation strategies assume the input to the program under test is a sequence of bytes and can be treated as such during mutation.
afl mutates inputs in two main stages the deterministic algorithm lines8 stages and the havoc lines12 stage.
all the deterministic mutation stages operate by traversing the input under mutation and applying a mutation at each position in this input.
these mutations line include bit flipping byte flipping arithmetic increment and decrement of integer values replacing of bytes with interesting integer values max int etc.
the number of mutated inputs produced in each of these stages is governed by the length of the input being mutated line .
on the other hand the havoc stage works by applying a sequence of random mutations setting random bytes to random values deleting orcloningsubsequencesoftheinput totheinputbeingmutatedto produce a new input.
several mutations are applied to the original input line beforerunningitthroughtheprogram line .the numberoftotalhavoc mutatedinputstobeproducedisdetermined by a performance score score line7 .
.
afl coverage calculation above we mentioned the role that coverage information plays in the afl procedure.
the use of this information is one of afl skey innovations.
specifically afl uses this information to selectinputs for mutation and save new inputs saving only those that have achieved new program coverage.
in order to collect this coverage information efficiently afl inserts instrumentation into the program under test.
to track coverage it first associates each basic block with a random number via instrumentation.
the randomnumber is treated as the unique id of the basic block.
the basic block ids are then used to generate unique ids for the transitions between pairs of basic blocks.
in particular for a transition from basic block atob afl uses the ids of each basic block id a and id b respectively to define the id of the transition id a b as follows id a b def id a greatermuch1 id b .
right shifting greatermuch the basic block id of the transition start block a ensures that the transition from atobhas a different id from the transition from btoa.
we associate the notion of basic block transitionwiththatofa branchintheprogram scontrolflowgraph and throughout the paper we will use the term branch to refer to this afl defined basic block transition unless stated otherwise.
the coverage of the program under test on a given input is collected as a set of pairs of the form branchid branchhits .
if a branchid branchhits pairispresentinthecoverageset itdenotes that during the execution of the program on the input the branch with idbranch id was exercised branch hits number of times.
the hits are bucketized to small powers of two.
afl refers this set of pairs as the pathof an input.
afl says that an input achieves new coverage if it discovers a new branch id branch hits pair.
.
limitations of afl while afl s search strategy is guided by coverage we observed in our experiments that often afl fails to cover some important functionalities of the program under test.
note that achieving good coverage is precursor to finding bugs and crashes if a program region is not covered there is no way afl can find bugs or crashes in that region.
considerthecodefragmentshowninfigure .itisadaptedfrom theparser.c file used in libxml2 sxmllint utility.
afl found manysecurityvulnerabilitiesinthislibraryinthepast .weran afl on this benchmark for hours repeating this experiment times see section 4for more experimental details .
only in one of these hour runs did afl produce an input passing line .e v e n then afl failed to explore the contents of any of the if statements in lines6 .
as such it failed to explore the large quantity of code after line mostly omitted in figure .
since this code is not evencovered then afl simply cannot find any bugs in it.
the key reason afl is unable to produce inputs covering any of this code even after discovering an input containing !attlist is that afl mutates bytes paying no attention to which byte values are required to cover particular parts of the program.
for example after having produced the input !attlist bd afl will not prioritize mutation of the bytes after !attlist .
instead it is as likely to produce the mutants !catlist bd !
!attlist bd o r ?
??
!attlist bd as it is to produce !attlist id .h o w e v e r t o explore the code in figure once afl discovers !attlist bd i t should not mutate the !attlist part of this input.
to see why suppose that the production of an input like !attlist id with the token id is required to pass the processing code omitted in line of figure .
preventing the modification of !attlist increasesafl sprobabilityofgenerating !attlist id byatleast .
figure2illustrates how restricting mutation to only the last two characters of the input yields to a smaller space of mutants to explore and thus a higher probability of discovering an input that will get deeper into the program.
.
overview of fairfuzz we propose a two pronged approach that addresses this concern but can be smoothly integrated into afl or other mutation based fuzzers.
it works as follows.
the first part of our approach is the identification of statements like the if statement in line of figure which potentially guard large unvisited regions of code.
for this we utilize the observation that such statements are usually hit by very few of afl s generated inputs i.e.
they are rare and can thus be easily identified by keeping the track of the number of inputs which hit each branch.
intuitively thecodeguardedbyabranchhitbyfewinputsismuch lesslikelytohavebeenthoroughlyexploredthanthecodeguardedby a branch hit by a huge percentage of generated inputs.
having identified these rare branches for targeted fuzzing we modify the input mutation strategy in order to keep the condition of the rare branch satisfied.
specifically we use a deterministic mutation phase to approximately determine the parts of the input that cannot be mutated for mutants to hit the rare branch.
the subsequent mutation stages are then not allowed to mutate these crucial parts of the input.
as a result we significantly increase the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france caroline lemieux and koushik sen 1if cmp9 ptr !
a t t l i s t 2ptr some processing code omitted while ptr!
ptr!
eof inttype if cmp5 ptr c d a t a ptr type xml attribute cdata else if cmp6 ptr i d r e f s ptr type xml attribute idrefs else if cmp5 ptr i d r e f ptr type xml attribute idref else if ptr i ptr d ptr type xml attribute id else if cmp6 ptr e n t i t y ptr type xml attribute entity else if cmp8 ptr e n t i t i e s ptr type xml attribute entities else if cmp8 ptr n m t o k e n s ptr type xml attribute nmtokens else if cmp7 ptr n m t o k e n ptr type xml attribute nmtoken if type ptr break more omitted code if cmp9 ptr r e q u i r e d ptr default decl xml attribute required if cmp8 ptr i m p l i e d ptr default decl xml attribute implied if cmp6 ptr f i x e d ptr default decl xml attribute fixed if !is blank ch ptr xmlfatalerrormsg space required after fixed ptr figure code fragment based off the libxmlfileparser.c showingmanynestedifstatementsthatmustbesatisfiedto explore erroneous behavior.
probability of generating new inputs that hit the rare branch.
this opens up the possibility of better exploring the part of the code that is guarded by the branch.
while we apply it to targeting rare branches this mutation modification strategy is general and can be applied to other testing targets.
weimplement thisapproachontopofaflinfairfuzz.wefind thisapproachleadstofastercoverage aswellasincreasedcoverage compared to the maximum coverage achieved over stock afl and other modified versions of afl on several real world benchmarks.
the details of the evaluation are presented in section .
we present the details of our approach in the next section.
!attlist bd !attlist bd character mutants character mutantsmutable region without maskmutable region with mask figure preventing afl from mutating the !attlist part of this input increases the probability of generating !attlist id by at least .
fairfuzz algorithm in fairfuzz we modify the afl algorithm in two key ways toincrease the coverage achieved.
first we modify the selection of inputs to mutate from the queue and second we modify the way mutations are performed on these inputs.
algorithm 2outlines the fairfuzz algorithm and how it differs from the afl algorithm.
we beginwithanabstracttreatmentofthemutationmaskingtechnique and then dive into the fairfuzz particulars.
.
mutation masking in this section we introduce the mutation mask for a given input x and a given testing target t. we saysatisfies x t is true if input xsatisfies t. definition1.
amutation is a tuple c m where mis the number of bytes impacted by the mutation and cis one of the following mutation categories o overwrites mbytes starting at position kwith some values i insertssome sequence of mbytes at position k d deletes mbytes starting at position k. to fully specify mutations with c o i the values that are inserted or written over existing bytes must be specified.
given an input x a mutation c m and a position i x m let mutate x i denote the input produced by applying mutation onxat position i. definition2.
themutationmask foraninput xandatestingtarget tis a function maskx t n p o i d which takes a position iin the input xand returns a subset of o i d .
we say that a mutation category c maskx t i ifsatisfies mutate x c i t is true.
that is if cis in the set maskx t i then after applying a mutation of category cat position ionx the resulting input will satisfy the target t. intuitively the mutation mask specifies whether the input produced from mutating xat position iwill likely reach the testing target.
with this mask given a mutation c m at position k we can compute oktomutate maskx t k k m logicalanddisplay i kc maskx t i .
we describe the algorithm to compute maskx t i in section3.
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coveragease september montpellier france algorithm2 fairfuzz algorithm.
differences from the afl algorithm are highlighted in gray.
procedure fairfuzz prog seeds queue seeds whiletruedo begin a queue cycle forinputinqueuedo rarestbranch raresthitby prog input numhits ifnumhits rarity cutoff then continue score performancescore prog input mask computemask prog input rarestbranch for0 i input do formutation indeterministicmutationtypes do if oktomutate mask mutation i then continue newinput mutate input mutation i runandsave prog newinput queue for0 i scoredo newinput mutatehavoc input runandsave prog newinput queue procedure mutatehavoc prog input nummutations randombetween newinput input for0 i nummutations do mutation randommutationtype position randomoktomutate mask mutation newinput mutate newinput mutation position returnnewinput procedure runandsave prog input queue runresults run prog input forbranchinrunresults do numhits ifnewcoverage runresults then addtoqueue input queue .
.
biasing mutation with the mutation mask.
fairfuzz uses oktomutate maskx t k to bias mutations towards the testing target as follows.
in the deterministic mutation stages algorithm line10 oktomutateisusedtofilteroutmutantsthatcouldviolatethetestingtarget asillustratedinline 12ofalgorithm .inparticular fora givenmutationtype andposition i ifoktomutate maskx t i is true the mutant x prime mutate x i is generated and passed to runandsave.
otherwise fairfuzz skips the mutant.
recallthatduringthehavocstage mutantsarecreatedbychoosing a random mutation and random position at which to applyit.
fairfuzz selects the random mutation c m as afl does algorithm line23 .
however instead of selecting the position at random between and newinput m as in algorithm line20 fairfuzz chooses the position randomly from the subset of ok to mutate positions algorithm line24 .
precisely the call torandomoktomutate maskx t in line24of algorithm 2is sampleuniform i oktomutate maskx t i .if the set of ok to mutate positions is empty fairfuzz skips themutation in line 25and chooses a new c m at the next iteration of the havoc mutation inner loop line .
.
targeting rare branches so far we have kept the testing target abstract.
in this section we concretize it by elaborating the definition of rare branches and giving the concrete algorithm which fairfuzz uses to compute the mutation mask for rare branches.
.
.
selecting inputs to mutate.
to bias input generation towards rare branches fairfuzz selects only inputs that hit rare branches for mutation.
first we formalize the concept of a rare branch.
definition .
we say that an input xhitsa branch b denoted hits x b if the execution of the program on xexercises the branch bat least once.
thehit count of a branch is the number of produced inputs i which have exercised the branch.
more formally definition .
letibe the set of all inputs produced by fuzzing so far.
the hit count of branch bis numhits x i hits x b .
concretely numhits is kept as a map of branches to hit count updated every time a mutant is run line 30of algorithm .
to establish numhits fairfuzz runs one round of mutation on the seed input with no masking.
a natural idea is to designate the nbranches hit by the fewest inputsasrare orthebrancheshitbylessthan ppercentofinputsto be rare.
after some initial experiments we rejected these methods as a they can fail to capture what it means to be rare e.g.
if n and the two rarest branches are hit by and inputs both would be rare and b these thresholds need to be modified for differentbenchmarks.instead wedefineararebranchasonewhose hit count is smaller than a dynamic rarity cutoff as follows.
let b be the set of all branches in the program.definition .
letbv b b numhits .arare branch is a branch bsuch that numhits rarity cutoff where rarity cutoff 2isuch that 2i min b prime bv numhits 2i.
for example if the branch hit by the fewest inputs has been hit by inputs any branch hit by 25inputs is rare.
to determine whether an inputs hits a rare branch fairfuzz computes the rarest branch hit by the input definition .
letbranches x b b hits x b .
then the rarest branch hit by input xis the branch b such that b argmin b branches x numhits .
then fairfuzz selects only inputs whose rarest branch is a rare branch for mutation line 6of algorithm .
although fairfuzz only selects inputs using the above strategy it could run some of the cycles using afl s default strategy.
this would ensure that it does not skip the default strategies of afl which might be better for creating crash prone inputs.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france caroline lemieux and koushik sen algorithm computing the mutation mask in fairfuzz.
procedure computemask prog input branch mask initwithemptyset input for0 i input do inputo mutate input flipbyte i ifbranch brancheshitby prog inputo then mask mask o inputi mutate input addrandombyte i ifbranch brancheshitby prog inputi then mask mask i inputd mutate input deletebyte i ifbranch brancheshitby prog inputd then mask mask d return mask .
.
computation of the mutation mask.
algorithm 3outlines how fairfuzz computes maskx bfor a given input xand rare branch b. the algorithm works as follows.
for each position iin the x fairfuzz produces the mutants xo by flipping the byte at position i line4of algorithm xiby adding a random byte at position i line7 and xdby deleting the byte at position i line10 .
then for each xc fairfuzz determines whetherhits xc b by running xcthrough the program captured in brancheshitby on lines .
finally if xchitsb fairfuzz notes the position ias overwritable o insertable i or deletable d respectively lines .
while the calculation is illustrated as separate from the deterministic mutation stages in algorithm the two are integrated in the implementation.
since the mask computation adds only two new deterministic mutation types to afl byte flipping is a default mutation type the computation adds negligible overhead to stock afl.
of course this computation of o maskx b i and i maskx b i is approximate fairfuzz doesn t check whether every value overwritten or inserted results in bbeing hit.
unfortunately trying all possible values to insert or write is too expensive and produces too many redundant inputs.
empirically we find this approximation produces an effective mutation mask see section .
.
finally note that this algorithm could be easily adapted to other testing targets by replacing hits xc b withsatisfies xc t .
.
trimming inputs for testing targets afl s efficiency depends on large part on its ability to quickly produce and modify inputs .
thus it is important to make sure the deterministic mutation stage and in fairfuzz mutation mask computation is efficient.
since the runtime of the computation is linear in the length of the selected input fairfuzz needs to keep the length of the inputs in the queue short.
afl has two techniques forkeepinginputsshort prioritizingshortinputswhenselecting inputs for mutation and trimming an efficient approximation of delta debugging the parent input before mutating it.
this trimming is omitted from algorithms 1and2for clarity.
trimming attempts to minimize the input to mutate with the constraint that the minimized input hits the same path set of branchid branch hits astheun minimizedone.ho wever this constraintisnotgood enough for reducing the length of inputs when very long inputsare chosen.
fairfuzz may do this since it selects inputs based only on whether they hit a rare branch.
we found that we can make inputs shorter in spite of this if we relax the trimming constraint.
in particular we relax the constraint to require that the minimized inputhitsonlythetargetbranchoftheoriginalinput insteadofthe same path as the original input.
similar relaxation could be done for other testing targets.
we refer to fairfuzz with this relaxed constraint as fairfuzz with trimming.
implementation and evaluation we implemented fairfuzz as an open source tool built on top of afl.
the implementation adds around lines of c code to the file containing afl s core implementation.
we evaluated fairfuzz on different real world benchmarks.
we selected these from those favored for evaluation by the afl creator djpegfrom libjpeg turbo .
.
and readpng from libpng1.
.
those used in aflfast s evaluation tcpdump nr from tcpdump .
.
and nm objdump d readelf a andc filt from gnu binutils .
and a few benchmarks with more complex input grammars in which afl has previously found vulnerabilities mutool draw from mupdf .
and xmllint from libxml2 .
.
since some of these input formats had afl dictionaries and some did not we ran all the evaluation without dictionaries to level out the playing field.
in each case we seeded the fuzzing run with the inputs in the corresponding afl testcases directories except c filt which was seeded with the input z1fv n for png we used only not kitty.png.
.
coverage compared to prior techniques in this section of evaluation we compare three popular versions of afl against fairfuzz all based off of afl version .40b.
afl is the vanilla afl available from afl s website.
fidgetyafl is afl run without deterministic mutations.
aflfast.new is aflfast run without deterministic stage and with the cut off exponential exploration strategy.
configurations and are the fastest performing versions of afl and aflfast respectively.
we compare to for baseline reference.
we ran fairfuzz with input trimming for the testing target and omitting all deterministic stages except those necessary to compute the mutation mask.
we ran each technique for hours on a single core on each benchmark.werepeatedeach24hourexperiment20timesforeach benchmark.
we ran our experiments for hours as the fuzzing process does not have a defined end time and this is a runtime used in prior work .
we repeated our experiments times because fuzz testing is an inherently non deterministic process and so is its performance.
this enabled us to report results that are statistically significant in section .
.
.
.
.
overallbranchcoverageachieved.
we begin by analyzing coverage achieved by different techniques through time.
the main metricwereportisbasicblocktransitionscovered whichiscloseto the notion of branch coverage used in real world software testing.
why branch coverage?
other than basic block transitions i.e.
branches covered theonlyothercommonlyusedmetrictoevaluate afl coverage is afl path coverage.
as mentioned in section .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coveragease september montpellier france a tcpdump b readelf c nm d objdump e c filt f xmllint g mutool draw h djpeg i readpng figure3 numberofbasicblocktransitions aflbranches coveredbydifferentafltechniquesaveragedover20runs bands represent c.i.s .
an afl path is set of branch id branch hits but due to afl s implementation only the branches covered metric is robust to the orderinwhichinputsarediscovered.hereisasimpleillustrationof whytheaflpathcoverageisorder dependent.consideraprogramwith two branches b1andb2.
suppose input ahitsb1once input b hitsb2once and input chits both b1andb2.
their respective paths arepa b1 pb b2 and pc b1 b2 .
if afl discovers these inputs in the order a b cit will save both aandb and count paths and not save csince it does not exercise a new branchid branchhits pair.
on the other hand if afl discovers the inputs in the order c a b it will save cand count path and save neither anorb.
thus it appears on the second run that afl has found half the paths it did on the first run.
on the other hand regardless of the order in which inputs a b care discovered the numberofbranchescoveredwillbe2.reportingrealpathcoverage is only possible if all inputs produced by afl were saved but this was not tractable in our hour experiments given the volume of inputsproduced tensofmillions .thus wereportbranchcoverage.
we also noted that the creator of afl also favors branch coverage which he refers to as tuple resolution as a performance metric statinghehasfounditisthebestpredictorofhowaflwillperform in the wild .
results.figure3plots for each benchmark and technique the average number of branches covered over all runs at each time point dark central line and confidence intervals in branches covered at each time point shaded region around line over the runs for each benchmark.
for the confidence intervals we assume student s t distribution taking .
times the standard error .
from figure we see that that on all benchmarks except c filt fairfuzz achieves the upper bound in branch coverage generally showing the most rapid increase in coverage at the beginning of execution.
note that while fairfuzz keeps a sizeable lead on the xmllint benchmark figure 3f it does so with wide variability.
closer analysis reveals that one run of fairfuzz on xmllint was buggy and no inputs were selected for mutation this run covered no more than branches.
however fairfuzz had two runs on xmllint covering an exceptional and branches respectively.
figure4 shows at every hour for how many benchmarks each technique has the leadin coverage.
by leadwe mean its average authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france caroline lemieux and koushik sen higher is better figure number of benchmarks on which each technique has the lead in coverage at each hour.
a benchmark iscounted for multiple techniques if two techniques are tiedfor the lead.
coverage is above the confidence intervals of the other techniques and no other technique s average lies within its confidence interval.
we say two techniques are tied if one s average lies within the confidence interval of the other.
if techniques tie for the lead the benchmark is counted for both techniques in figure which is why the number of benchmarks at each hour may add up to more than .
this figure shows that fairfuzz quicklyachieves alead in coverage on nearly all benchmarks and is not surpassed in coverage by the other techniques in our time limits.
.
.
detailed analysis of coverage differences.
figure3shows there are three benchmarks c filt tcpdump andxmllint o n which one technique achieves a statistically significant lead in afl s branch coverage after hours with aflfast.new leading onc filt and fairfuzz on the other two .
we were curious as to what these branch coverage increases corresponded to in terms of source code coverage differences.
since afl saves all inputs that achieve new program coverage i.e.
that are placed in the queue to disk we can replicate what program coverage was achieved in each run by replaying these queue elements through the programs under test.
since each benchmark wasrun20times wetaketheunion overeachtechnique ofinputs in the queue for all runs.
we ran the union of the inputs foreach technique through their corresponding programs and thenran lcovon the results to reveal coverage differences.
using the union is a generous approach and can only reveal which regions are uncoverable by the different techniques over all the runs.
xmllint.thebulkofthecoveragegainson xmllint wereinthe mainparser.c file.
the key trend in increased coverage appears to be fairfuzz s increased ability to discover keywords.
for example both afl and fairfuzz have higher source code coverage than fidgetyafl and aflfast.new as they discovered the patterns !doctype and !attlist in at least one run.
however fairfuzz also produced inputs satisfying all the other conditionals illustrated in figure which meant discovering all the keywords used in the comparisons.
the produced inputs included !doctypet !attlist?d t nmtokens !doctype?
!attlist d t entity !doctype !attlist d t id required p we believe the mutation masking technique is directly responsible for the discovery of these.
to see this let us focus on thetable number of runs for each technique producing an input with the given sequence in hours.
sequence afl fidgetyafl aflfast.new fairfuzz !a !at !att !attlist block covered by the inputs above whose code is outlinedininfigure .whilebothaflandfairfuzzhadarundiscovering the sequence !attlist of all the saved inputs for afl in that run only .
of them visited line of figure resulting in hits of the line.
in contrast we found that .
of the saved inputs produced by fairfuzz in the run where it discovered !attlist visited line of figure resulting 2124hits of the line.
with two orders of magnitude more hits of this line it is obvious that fairfuzz was better able to explore the code in figure .w e believe the orders of magnitude difference can be attributed to the mutation mask.
to confirm the effect was not just luck we also look at the number of runs which produced subsequences of !attlist .
this is illustrated in table .
the decrease in the number of runs discovering !atfrom the number of runs discovering !ain this table shows the mutation mask in action with of fairfuzz runs discovering !at comparedto1 and3foraflfast.new fidgetyafl and aflfast.new respectively.
finally as is obvious from the example inputs above although fairfuzz discovered more keywords the inputs it produced were not necessarily more well formed.
nonetheless these inputs allowed the fairfuzz to explore more of the program s faults.
this is reflected in the coverage of a large case statement differentiating error messages in parser.c .
these messages do not result in afl crashes i.e.
segmentation faults simply in non zero exit codes.
both fidgetyafl and aflfast.new cover only of these cases afl covers and fairfuzz covers .
tcpdump.likexmllint tcpdump hasextensivenestedstructure with the presence of various sequences in the input leading to differentprintingfunctions.weobservedthatcoveragefor tcpdump differs a bit for all four techniques over a variety of different files but see the biggest gains in three files printing certain packet types print forces.c print llc.c and print snmp.c .
the coverage gains in these files suggest fairfuzz is better able to automatically detect sequences in the inputs necessary to increase program coverage.
for example unlike the other three techniques fairfuzzwasabletocreatefilesthathavelegalforces rfc packet length.
fairfuzz was also able to create ieee .
logical link control llc packets with the organization ally unique identifier oui corresponding to rfc and subsequently explore the many subtypes of this oui.
finally in the simple network management protocol parser fairfuzz was able tocreateinputscorrespondingtotrappdus aswellassomeinputs with a correct snmpv3 user based security message header.
we note these gains in coverage seem less impressive than those of fairfuzz on xmllint even though the performance in figure looks similar.
this appears to be because fairfuzz gets consistently higher coverage of tcpdump instead of covering parts of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coveragease september montpellier france the program wholly uncoverable by the other techniques.
we can see this by looking at the number of branches covered byatleast one ofthe runs the union over the runs and the number of branches covered atleastonceinall the runs the intersection over the runs .
for tcpdump fairfuzz has a consistent increase in the intersection of coverage fairfuzz s contains branches compared to aflfast.new s but a smaller gain in the union fairfuzz s is while aflfast.new s is .
on the other hand theintersectionofcoveragefor xmllint isvirtuallythesame for all techniques except stock afl for fidgetyafl for aflfast.new and for fairfuzz maybe because of thebuggy run mentioned in section .
.
but fairfuzz s union of coverage contains over more branches than that of aflfast.new .
c filt.the differences in terms of source code coverage between techniques were much more minimal for c filt than fortcpdump orxmllint .
for example fairfuzz covers lines incp demangle.c that aflfast.new does not related to demangling binary components when the operator has a certain op code.
on the other hand aflfast.new covers a branch where xmalloc failed int max is called when a length bound comparison fails while fairfuzz fails to produce an input long enough to violate the length bound.
fairfuzz also fails to cover a branch incxxfilt.c taken when the length of input read into c filt surpasses the length of the input buffer allocated to store it.
fairfuzz s inability to produce very long inputs may be related to the second round of trimming fairfuzz does.
or it could be becausec filt has highly recursive structure so full branch coverage is not as good a exploration heuristic for this program.
a testing target other than hitting rare branches may be better suited for programs like c filt.
the pattern we see from this analysis is that fairfuzz is better able to automatically discover input constraints and keywords special sequences packet lengths organization codes and target exploration to inputs which satisfy these constraints than the other techniques.
we suspect the gains in coverage speedon benchmarks such asobjdump readpng andreadelf are due to similar factors.
we conjecture the targeting of rare branches shines the most in the tcpdump andxmllint benchmarks since these programs are structured with many nested constraints which the other techniques are unable to properly explore over the time budget and perhaps even longer without extreme luck.
.
can masking effectively target branches?
finally we were curious as to whether the mutation mask strategy effectively biased mutation towards our testing target.
in fairfuzz the target was hitting the same rare branch as the parent input.
weconductedthefollowingexperimentonasubsetofourbenchmarks to evaluate the effect of the mask.
we added a shadowmode to fairfuzz.
when running in shadow mode every time an input is selected for mutation fairfuzz first performs all mutations without the influence of the mutation mask theshadowrun .
then for the same input fairfuzz performs all mutations again using the mutation mask filtering and bias.
this shadow run allows us to compute the difference between the percentage of generated inputs hitting the target with andtable average of mutated inputs hitting target branch for one queueing cycle.
a cycle without trimming.
det.
mask det.
plain hav.
mask hav.
plain xmllint .
.
.
.
tcpdump .
.
.
.
c filt .
.
.
.
readelf .
.
.
.
readpng .
.
.
.
objdump .
.
.
.
b cycle with trimming.
det.
mask det.
plain hav.
mask hav.
plain xmllint .
.
.
.
tcpdump .
.
.
.
c filt .
.
.
.
readelf .
.
.
.
readpng .
.
.
.
objdump .
.
.
.
without the mutation mask foreachparentinput.
since some target branches may be easier to hit than others this gives us a betteridea of how effective the masking technique is in general.
in our experiments we ran fairfuzz with the shadow run on a subset of our benchmarks.
for each benchmark we ran a cycle with target branch trimming and one without.
our results are presented in table which shows the target branchhitpercentagesforthedeterministicandhavocstages.these percentages are the averages over all inputs selected for mutation in the first queueing cycle of the percentage of children inputs hitting the target.
overall table 2shows that the mutation mask largely increases the percentage of mutated inputs hitting the target branch.
the hit percentages for the deterministic stage are strikingly high.
this is not unexpected because in the deterministic stage the mutation mask simply prevents mutations at locations likely to violate the target branch.
thus the gain percentage of inputs hitting the target branch in the havoc stage is most impressive.
in spite of theuse of the mutation mask in the havoc stage being heuristic weconsistently see the use of the mutation mask causing a 3x 10x increase in the percentage of inputs hitting the target branch.
as for trimming it appears that extra trimming reduces the number of inputshittingthetargetbranchwhenthemutationmaskisdisabled but has minimal effect when the mutation mask is enabled.
again we note that the mutation masking technique is independent of the testing target.
in particular the fact that the branches being targeted are rare .
this suggests that this strategy could be used in a more general context.
for example we could target only the branches within a function that needs to be tested or if some area of the code was recently modified or bug prone we could target the branches in that area with the mutation mask.
recent work on targeted afl shows promise in such an application of afl and we believe the mutation masking technique could be used cooperatively with the power schedules presented in that work.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france caroline lemieux and koushik sen 1if strcmp str bad!
do bad things 1if str b if str a if str d if str !
do bad things figure multi byte comparison left unrolled to byte bybyte comparison right .
discussion while we chose benchmarks with a variety of input formats accomplishing different tasks the results of our evaluation may not generalize to other programs.
theforemostlimitationofusingrarebranchesasatestingtarget in fairfuzz is the fact that branches that are never hit by any afl inputcannotbetargetedbythismethod.so itconferslittlebenefits to discovering a single long magic number when progress towards matching the magic number does not result in new coverage e.g.
the comparison on the left of figure .
we believe the fairfuzz mutation masking algorithm could be used in conjunction withmethods targeting the magic number issue to build a more effective fuzzer.
recall fairfuzz was effective at finding keyword sequences in thexmllint benchmark.
this may be because the long string comparisons in parser.c usecmpnmacros see figure which are structured as byte by byte comparisons.
so afl s instrumentation reports new coverage when progress was made on these comparisons.thecreatorsof laf intel proposeseveralllvm deoptimization passes to improve afl s performance including a pass that automatically turns multi byte comparisons into byte bybyte comparisons.
figure 5shows an example of this comparison unrolling.
the integration of these llvm passes into afl s instrumentation is straightforward requiring only a patch to afl s llvm based instrumenter .
due to fairfuzz s performance on xmllint we believe fairfuzz could show similar coverage gains on other programs if they were compiled with this laf intel pass.
we did not evaluate this as the evaluation of the laf intel pass wasdoneinafl s parallel fuzzingmode.wedidnotdoanyexperimentswiththisparallelfuzzingasourimplementationdidnothave a distributed version of the rare branch computation algorithm.
other related work we have discussed aflfast in the previous sections.
unlike our proposed approach it targets rare paths not branches and it does not change the mutation strategies of afl.
other prior work on afl has focused on producing a single input passing a difficult tohitbranch liketheoneontheleftoffigure .driller uses symbolic execution to pass branches when afl gets stuck.
steelix whose source code was unavailable at the time of submission adds a static analysis stage extra instrumentation andmutations to afl to better produce inputs satisfying multi byte comparisons.
these techniques require more instrumentation but find magic numbers more accurately than fairfuzz.
ho wever neither of these techniques will be able to prevent a discovered magic sequence from being mutated to encourage further exploration while fairfuzz does.
unlike fairfuzz and other greybox fuzzers which use coverage information as a heuristic for which inputs may yield newcoverage under mutation symbolic execution tools methodically explore the program under test by capturing path constraints and directly producing inputs which fit yet unexploredpath constraints.
the cost of this precision is that it can lead to the path explosion problem which causes scalability issues.
traditional blackbox fuzzers such as zzuf mutate userprovided seed inputs according to a mutation ratio which may need to be adjusted to the program under test.
bff and symfuzz adapt this parameter automatically by measuring crash density and input bit dependence respectively.
these optimizations are not relevant to afl type fuzzers which do not use this mutation ratio parameter.
there exist several fuzzers highly optimized for certain input file structures including network protocols and source code .fairfuzzisofmuchlowerspecificitysowillnotbe as effective as these tools on these specific input formats.
however its method is fully automatic requiring neither user inputs o r extensive tuning .
while fairfuzz uses its mutation mask to try and fix important parts of program inputs recent work has more explicitly tried to automatically learn input formats.
learn fuzz uses sequencebased learning methods to learn the structure of pdf objects autogram proposes a taint analysis based approach to learning input grammars while glade uses an iterative approach and repeated calls to an oracle to learn a context free grammar for a set of inputs.
fairfuzz does not assume a corpus of valid inputs of anysizefromwhichvaliditycouldbeautomaticallylearned noran oracle for the grammar but consequently does not learn as precise a grammar of the input.
another approach to smarter fuzzing is to find locations in seed inputs related to likely crash locations in the program and focusmutation there and taintscope .
these directed methods are not directly comparable to fairfuzz since they do not have the same goal of increasing program coverage.
vuzzer uses both static and dynamic analysis to get immediate values and input positions used in comparisons.
it uses a markov chain modeltodecidewhichpartsoftheprogramshouldbetargeted asopposed to our empirical approach.
randoop automatically generates test cases for object oriented programs through feedback directed random test gen eration.
evosuite uses seed inputs and genetic algorithms to achieve high code coverage.
both these techniques focus on generatingsequencesofmethodcallstotestprograms notbyte sequence inputs for a given program like fairfuzz.
search based software testing sbst uses optimization techniques such as hill climbing and genetic algorithmstogenerateinputsthatoptimizesomeobservablefitness function.
these techniques work well when the fitness curve is smooth with respect to changes in the input which is not the case in coverage based greybox fuzzing.