a large scale empirical comparison of static and dynamic test case prioritization techniques qi luo kevin moran and denys poshyvanyk department of computer science college of william and mary williamsburg virginia usa qluo kpmoran denys cs.wm.edu abstract the large body of existing research in test case prioritization tcp techniques can be broadly classi ed into two categories dynamic techniques that rely on run time execution information and static techniques that operate directly on source and test code .
absent from this current body of work is a comprehensive study aimed at understanding and evaluating the static approaches and comparing them to dynamic approaches on a large set of projects.
in this work we perform the rst extensive study aimed at empirically evaluating four static tcp techniques comparing them with state of research dynamic tcp techniques at di erent test case granularities e.g.
method and classlevel in terms of e ectiveness e ciency and similarity of faults detected.
this study was performed on real word java programs encompassing kloc.
in terms of e ectiveness we nd that the static call graph based technique outperforms the other static techniques at test class level but the topic model based technique performs better at testmethod level.
in terms of e ciency the static call graphbased technique is also the most e cient when compared to other static techniques.
when examining the similarity of faults detected for the four static techniques compared to the four dynamic ones we nd that on average the faults uncovered by these two groups of techniques are quite dissimilar with the top of test cases agreeing on only of detected faults.
this prompts further research into the severity importance of faults uncovered by these techniques and into the potential for combining static and dynamic information for more e ective approaches.
ccs concepts software and its engineering !software testing and debugging keywords regression testing test case prioritization static dynamic1.
introduction modern software is constantly evolving developers make various program changes to add new features or refactor existing code.
during this process it is crucial to ensure that developers do not introduce new bugs known as software regressions .regression testing is a methodology for e ciently and e ectively validating software changes against an existing test suite aimed at detecting such bugs .
one of the key tasks which is of critical importance to the regression testing process is regression test case prioritization.
regression test prioritization techniques reorder test executions in order to maximize a certain objective function such as exposing faults earlier or reducing the execution time cost .
for insatnce microsoft researchers have built test prioritization systems for development and maintenance of windows for a decade .
moreover a large body of research work has been proposed to design and evaluate regression tcp techniques .
most traditional tcp techniques are based on the dynamic coverage information of the regression test suite in previous software versions.
a typical dynamic approach applies a certain test prioritization strategy on a particular test coverage criterion to iteratively compute each test s priorty and then ranks them to generate a prioritized list of tests.
researchers have proposed various approaches for traditional tcp such as greedy total and additional strategies adaptive random testing and search based strategies .
although dynamic test prioritization techniques can be powerful in practice they may not be always applicable due to notable disadvantages e.g.
time consuming performance degradation over new program versions and test cases .
thus researchers have proposed a number of test prioritization techniques that rely solely upon static information extracted from the source and test code.
the introduction of purely static techniques begs several important questions in the context of past work on dynamic techniques such as how does the e ectiveness of static and dynamic techniques compare on real world software projects?
do static and dynamic techniques uncover similar faults?
how e cient are static techniques when compared to one another?
the answers to these questions will guide future work in developing new test case prioritization techniques.
several empirical studies have been conducted in an attempt to examine and understand varying aspects of di erent white and black box tcp approaches .
however there is a clear gap in the existing body of empirical studies characterized by the following recently proposed tcp techniques particularly static techniques havearxiv .05917v1 jan 2018not been thoroughly evaluated against each other or against techniques that require dynamic coverage no previous study including static approaches comprehensively examines the impact of di erent test granularities e.g.
prioritizing entire test classes or individual test methods the e ciency of the techniques and the similarities in terms of uncovered faults and prior studies have not typically been conducted on several mature real world software systems.
each of these points are important considerations that call for a thorough empirical investigation.
studying the e ectiveness and similarity of faults uncovered for both static and dynamic techniques would help inform researchers of potential opportunities to design more e ective and robust tcp approaches.
additionally evaluation on a large group of sizable real world java programs would help bolster the generalizability of these results.
to answer the previously posed questions and address the current gap in the existing body of tcp research we perform an extensive empirical study comparing four popular static tcps i.e.
call graph based with total and additional strategies string distance based and topic model based techniques to four state of the art dynamic tcps i.e.
the greedy total greedy additional adaptive random and search based techniques on realworld software systems.
all tcps are implemented based on the papers that initially proposed them and the implementation details are given in section .
.
it is worth noting that di erent granularities of dynamic coverage may impact the e ectiveness of dynamic tcps.
in this paper we chose to examine statement level coverage for dynamic techniques since previous work has shown that statement level coverage is at least as e ective as other common coverage criteria e.g.
method and branch coverage in the tcp domain.
in our evaluation criteria we examine the e ectiveness of these techniques in terms of average percentage of faults detected apfd and the similarity of detected of faults at di erent test granularities e.g.
both method and class levels .
additionally we examine the e ciency in terms of execution time of static tcps to better understand the time cost associated with running these approaches on subjects.
when examining static approaches we found that the call graph based with additional strategy technique outperforms all studied techniques at the test class level.
at the test method level the topic model based technique performs better than other static techniques but worse than two dynamic techniques the additional and search based techniques.
our results indicate that the test granularity dramatically impacts the e ectiveness of tcp techniques .
while nearly all techniques perform better at method level granularity the static techniques perform comparatively worse to dynamic techniques at method level as opposed to class level.
in terms of execution time call graph based techniques are the most e cient of the static tcps.
finally the results of our similarity analysis study suggest that there is minimal overlap between the uncovered faults of the studied dynamic and static tcps with the top of prioritized test cases only sharing of uncovered faults.
this suggests that future tcps may bene t from the severity importance of faults uncovered by di erent techniques and the potential for combining static and dynamic information.
this paper makes the following contributions to the best of the author s knowledge this is the rst extensive empirical study that compares the e ective ness e ciency and similarity of uncovered faults of both static anddynamic tcp techniques at di erent granularities on a large set of real world programs.
we discuss the relevance and potential impact of the ndings in the study and provide a set of learned lessons to help guide future research.
we provide a publicly available extensive online appendix and dataset of the results of this study to ensure reproducibility and aid future research .
.
background related work in this section we formally de ne the tcp problem introduce the studied techniques in the context of the related work and distill the novelty and research gap that our proposed study ful lls.
rothermel et al.
formally de ned the test prioritization problem as nding t02p t such that8t00 t002p t t006 t0 f t0 f t00 where p t denotes the set of permutations of a given test suite t and fdenotes a function from p t to real numbers.
in this section we introduce the underlying methodology of our studied techniques in detail which include static tcp techniques section .
and dynamic tcp techniques section .
.
all studied techniques attempt to address the tcp problem formally enumerated above with the objective function of uncovering the highest number of faults with the fewest number of test cases.
in our study we limit our focus to static tcps that require only source code and test cases and the dynamic ones that only require dynamic coverage and test cases as inputs for two reasons this represents fair comparison of similar techniques that leverage traditional inputs e.g.
test cases source code and coverage info and the inputs needed by other techniques e.g.
requirements code changes user knowledge are not always available in real world subject programs.
additionally we discuss existing empirical studies section .
.
we discuss our own re implementation of these tools later in section .
.
static tcp techniques call graph based.
this technique builds a call graph for each test case to obtain a set of transitively invoked methods called relevant methods .
the test cases with a higher number of relevant methods in the call graph are treated as the ones with higher test ability and thus are prioritized rst.
this approach encompasses two sub strategies the totalstrategy prioritizing the test cases with higher test abilities earlier and the additional strategy prioritizing the test cases with higher test abilities excluding the methods that have already been covered by the prioritized test cases.
mei et al.
extended this work to measure the test abilities of the test cases using the number of statements in their relevant methods instead of the number of relevant methods .
the intuition here is that test cases with a larger number of statements in their relevant methods are more likely to detect faults.
as de ned in previous work a whitebox static approach requires access to boththe source code of subject programs and other types of information e.g.
test code whereas black box static techniques do not require the source code of subject programs.
static techniques can be classi ed as either white or black box whereas most dynamic techniques including the ones considered in this study are considered white box techniques since they require access to the subject system s source code.
thus the call graph based technique is classi ed as a white box approach whereas the other two studied techniques are black box approaches.
we consider both types of static techniques in this paper in order to thoroughly compare them to a set of techniques that require dynamic computation of coverage.
string distance based.
the key idea underlying this technique is that test cases that are most di erent from already executed test cases as measured by textual similarity based on string edit distance should be prioritized earlier .
the reason is that test cases that are textually dissimilar have a higher probability of executing di erent code paths and thus detecting more bugs.
this technique is a black box static technique since it uses only the test case code.
in this technique four string edit distances are introduced to calculate the gap between each pair of test cases hamming levenshtein cartesian and manhattan distances.
based on prior experimental results manhattan distance performs best in terms of detecting faults.
thus in our study we implemented the string based tcp based on the paper by ledru et al.
and chose manhattan distance as the representative string distance computation for this technique.
we provide explicit details regarding our implementation of studied techniques in section .
topic based.
this static black box technique uses semanticlevel topic models to represent tests of di ering functionality and gives higher prioritization to test cases that contain different topics form those already executed .
the authors claim that topics which abstract test cases functionality can capture more information than the existing static test prioritization techniques and is robust in obtaining di erences between test cases.
the technique creates a vector for the code of each test case including the test case s correlation values with each topic.
after that it calculates the distances between test cases using manhattan distance and de nes the distance between one test case and a set of test cases as the minimum distance between this test case and all test cases in the set.
during prioritization process the test case which is farthest from all other test cases is selected and put into the prioritized set.
then the technique iteratively selects the test cases that are farthest from the prioritized set.
we implemented this technique based on the original paper with the same described parameters.
other approaches.
an approach presented by jiang et al.calculates the distances between test cases based on the input values of test cases and favors the test cases which are farthest from the already prioritized test case set .
recently saha et al.
proposed an approach that uses information retrieval ir techniques to recover the traceability links between test cases and code changes and sorts the test cases based on their relevant code changes with those having more relevant code changes being prioritized rst .
these techniques require additional information such as the test input and code changes.
recall that we focus on automated tcps that require only the source code and the test cases of the subjects.
thus we choose the call graph based string based and topic based techniques as the focus.
.
dynamic tcp techniques greedy techniques.
as explained in our overview of the call graph based approach traditional dynamic tcps use two sub techniques the total strategy and additional strategy to prioritize test cases based on the code coverage.
similarly the total strategy prioritizes test cases based on their code coverage and the additional strategy prioritizes test cases based on their code coverage excluding the code elements that have been covered by prioritized test cases.
thus the total strategy favors the test cases that cover more code but the additional strategy would select the test cases that can cover di erent code from the already prioritized test cases earlier.
in our study we implemented the greedy techniques based on the work by rothermel et al.
.
the additional strategy of this approach has been widely considered as one of most e ective tcps in previous works .
recently zhang et al.
proposed a novel approach to bridge the gaps between these two strategies by unifying the strategies based on the fault detection probability .
di erent code coverage criteria such as statement coverage basic block and method coverage faultexposing potential fep coverage transition and roundtrip coverage have been investigated in the domain of dynamic tcp.
for instance do et al.
use both method and basic block coverage information to prioritize test cases .
elbaum et al.
proposed an approach that prioritizes test cases based on their fep and fault index coverage in which the test cases exposing more potential faults will be assigned a higher priority.
kapfhammer et al.
use software requirement coverage to measure the test abilities of test cases for test prioritization .
adaptive random testing.
jiang et al.
proposed a novel approach called adaptive random test case prioritization art which introduces the adaptive random testing strategy into the tcp domain .
art rst randomly selects a set of test cases iteratively to build a candidate set then it selects from the candidate set the test case farthest away from the prioritized set.
the whole process is repeated until all test cases have been selected.
to nd the farthest test case art rst calculates the distance between each pair of test cases using jaccard distance based on their coverage and then calculates the distance between each candidate test case and the prioritized set.
three types of distances are used to calculate the distance between one test case and the prioritized set min avgand max.
for example minis the minimum distance between the test case and the prioritized test case.
the authors compared art with di erent distances and also the random tcp technique.
the results show that art with mindistance performs best.
thus in our empirical study we implemented art based on jiang et al.
s paper and chose min distance to estimate the distance between one test case and the prioritized set.
search based techniques.
search based tcp techniques introduce the meta heuristic search algorithm into the tcp domain exploring space of test case combinations to nd the ranked list of test cases that detect faults more quickly .
liet al.
propose two search based test prioritization techniques hill climbing based and genetic based.
the hill climbingbased technique evaluates all neighbors locally searching the ones that can achieve largest increase in tness.
the genetic technique halts evolution when a prede ned termination condition is met e.g.
the tness function value reaches a given value or a maximal number of iterations has been reached.
our empirical study uses the genetic based test prioritization approach as the representative search based test case prioritization technique because previous results demonstrate that genetic based technique is more e ective in detecting faults .
other approaches.
several other techniques based on leveraging dynamic program information have been proposed but do not t into any of the classi cations enumerated above .
islam et al.
presented an approach thatrecovers traceability links between system requirements and test cases using ir techniques and dynamic information such as execution cost and code coverage to prioritize test cases .
nguyen et al.
designed an approach that uses ir techniques to recover the traceability links between change descriptions and execution traces for test cases to identify the most relevant test cases for each change description .
however these tcps require more information e.g.
execution cost user knowledge code changes than code coverage.
in this paper we choose dynamic techniques that require only code coverage and test cases for comparison thus we select three techniques i.e.
greedy with total additional strategies art and search based .
recall that we do not study the potential impact of coverage granularity on the e ectiveness of dynamic tcps.
previous work has already shown that statement level coverage is at least as e ective as other coverage types thus we chose statement level coverage for all studied dynamic tcps.
.
empirical studies on tcp techniques several studies empirically evaluating tcp techniques have been published.
in this subsection we discuss the studies most closely related to our own in order to illustrate the novelty and research gap lled by our proposed study.
rothermel et al.
conducted a study for unordered random and dynamic tcp techniques e.g.
coverage based fep based on c programs to evaluate their abilities of fault detection .
elbaum et al.
conducted a study for several dynamic tcp techniques on c programs to evaluate the impact of program versions program types and di erent code granularity on the e ectiveness of tcp techniques .
thomas et.
al compared the topic based technique with the string based and call graph based techniques and the greedy additional dynamic technique at method level on two subjects.
however this study is limited by a small set of subject programs a comparison to only one dynamic technique a comparison only at method level and no investigation of fault detection similarity among the approaches.
doet al.
presented a study of dynamic test prioritization techniques e.g.
random optimal coverage based on four java programs with junit to demonstrate that these techniques can be e ective not only on c but also on java programs but di erent languages and testing paradigms may lead to divergent behaviors .
they also proposed an empirical study to analyze the e ects of time constraints on tcp techniques .
henard et al.
recently conducted a study comparing white and black box tcp techniques in which the e ectiveness similarity e ciency and performance degradation of several techniques was evaluated.
while this is one of the most complete studies in terms of evaluation depth it does not consider the static techniques considered in this paper.
thus our study is di erentiated by the unique goal of understanding the relationships between purely static and dynamic tcps.
to summarize while each of these studies o ers valuable insights none of them provides an in depth evaluation and analysis of the e ectiveness e ciency and similarity of detected faults for static tcp techniques and comparison to dynamic tcp techniques on a set of mature open source software systems.
this illustrates that a clear research gap exists in prior work empirically comparing more traditional techniques based on dynamic information against those that operate purely on static code artifacts.
the study conductedtable the stats of the subject programs size loc tm test cases at method level tc test cases at class level all all mutation faults detected faults can be detected by test cases.
subject programs size tm tc detected all p1 java apns p2 gson fire p3 jackson datatype guava p4 jackson uuid generator p5 jumblr p6 metrics core p7 low gc membuffers p8 xembly p9 scribe java p10 gdx artemis p11 protoparser p12 webbit p13 restfixture p14 lastcalc p15 lambdaj p16 javapoet p17 liqp p18 cassandra reaper p19 raml java parser p20 redline smalltalk p21 jsoup learning p22 wsc p23 rome p24 jactor p25 jprotobuf p26 worldguard p27 commons io p28 asterisk java p29 ews java api p30 joda time total in this paper is meant to close this gap and o er researchers and practitioners insight into the similarity and trade o s between such approaches.
.
empirical study in this section we state our research questions and enumerate the subject programs test suites study design and implementation of studied techniques in detail.
.
research questions rqs rq 1how do static tcp techniques compare with each other and with dynamic techniques in terms of e ectivness measured by apfd?
rq 2how does the test granularity impact the e ectiveness of both the static and dynamic tcp techniques?
rq 3how similar are di erent tcp techniques in terms of detected faults?
rq 4how does the e ciency of static techniques compare with one another in terms of execution time cost?
to aid in answering rq we introduce the following null and alternative hypotheses.
the hypotheses are evaluated at a .
level of signi cance h0 there is no statistically signi cant di erence in the effectiveness between the studied tcps.
h1 there is a statistically signi cant di erence in the effectiveness between the studied tcps.
.
subject programs test suites and faults we conduct our study on real world java programs.
the program names and sizes in terms of lines of code loc are shown in table where the sizes of subjects vary from to loc all are available on github .
our subjects are larger in size and quantity than previous work in the tcp domain .
to perform this study we checked out the most current master branch of each program and provide the version ids in our online appendix .
for each program we used the original junit test suites for the corresponding program version.
since onetable studied tcp techniques type tag description statictpcg tot call graph based total strategy tpcg add call graph based additional strategy tpstr the string distance based tptopic rtopic model based using r lda package tptopic m topic model based using mallet dynamictptotal greedy total statement level tpadd greedy additional statement level tpart adaptive random statement level tpsearch search based statement level of the goals of this study is to understand the impact of test granularity on the e ectiveness of tcp techniques we introduce two groups of experiments in our empirical study based on two test case granularities i the test method and ii the test class granularity.
the numbers of test cases on test method level and test class level are shown in columns of table respectively.
one goal of this empirical study is to compare the e ectiveness of di erent test prioritization techniques by evaluating their fault detection capabilities.
thus each technique will be evaluated on a set of program faults introduced using mutation analysis.
as mutation analysis has been widely used in regression test prioritization evaluations and has been shown to be suitable in simulating real program faults this is a sensible method of introducing program defects.
we applied the pit mutation tool s built in mutators to produce mutation faults for each project.
all mutation operators can be found in our online appendix .
note that not all produced mutation faults can be detected covered by test cases thus we ran pit with all test cases to obtain the faults that can be detected and used these detected faults in our study.
the numbers of detected mutation faults and the numbers of all mutation faults are shown in columns and of table respectively.
as the table shows the numbers of detected mutation faults range from to .
there are of course certain threats to validity introduced by such an analysis namely the the potential bias introduced by the presence of equivalent and trivial mutants .
we summarize the steps we take in our methodology to mitigate this threat in section .
.
design of the empirical study as discussed previously see section we limit the focus of this study to tcp techniques that do not require non traditional inputs such as code changes or software requirements.
we select two white box and two black box static techniques and four white box dynamic techniques with statement level coverage as the subject techniques for this study which are listed in table .
we sample from both white and black box approaches as the major goal of this study is to examine the e ectiveness and trade o s of static and dynamic tcps under the assumption that both the source code of the subject application as well as the test cases are available.
it is worth noting that our evaluation employs twoversions of the static topic model based technique as when contacting the authors of they suggested that an implementation using the mallet tool would yield better results than their initial implementation in r .
we now describe the experimental procedure utilized to answer each rq posed above.
rq the goal ofrq 1is to compare the e ectiveness of di erent tcp techniques by evaluating their fault detection capabilities.
following existing work we xed the number of faults for each subject program.
that is we ran domly chose di erent mutation faults and partitioned the set of all faults into groups of ve e.g.
a mutant group to simulate each faulty program version.
thus di erent faulty versions i.e.
were generated for each program.
if a program has less than mutation faults we use all detected mutation faults for this program and separate these faults into di erent groups ve faults per group .
for the static techniques we simply applied the techniques as described in sections .
to the test and source code of each program to obtain the list of prioritized test cases for each mutant group.
for the dynamic techniques we obtained the coverage information of the test cases for each program.
we then used this coverage information to implement the dynamic approaches as described in sections .
.
then we are able to collect the fault detection information for each program according to the fault locations.
to measure the e ectiveness in terms of rate of fault detection for each studied test prioritization technique we utilize the well accepted average percentage of faults detected apfd metric in tcp domain .
formally speaking let tbe a test suite and t0be a permutation of t the apfd metric for t0is computed according to the following metric apfd pm i 1tfi n m 2n where nis the number of test cases in t mis the number of faults and tfiis the position of the rst test case int0that detects fault i. recall that every subject program has mutant groups ve mutations per group .
thus we created faulty versions for each subject each version contains ve mutations and ran all studied techniques over these faulty versions.
that is running each technique times for each subject.
then we performed statistical analysis based on the apfd results of these versions.
to test whether there is a statistically signi cant di erence between the e ectiveness of di erent techniques we rst performed a one way anova analysis on the mean apfd values for all subjects and a tukey hsd test following the evaluation procedures utilized in related work .
the anova test illustrates whether there is a statistically signi cant variance between all studied techniques and the tukey hsd test further distinguishes techniques that are signi cantly di erent from each other as it classi es them into di erent groups based on their mean apfd values .
these statistical tests give a statistically relevant overview of whether the mean apfd values for the subject programs di er signi cantly.
additionally we performed a wilcoxon signed rank test between each pair of tcp techniques for their average apfd value across all subject techniques to further illustrate the relationship between individual subject programs.
we choose to include this non parametric test since we cannot make assumptions about wether or not the data under consideration is normally distributed.
rq the goal of this rq is to analyze the impact of di erent test granularities on the e ectiveness of tcp techniques.
thus we choose two granularities test method and test class level.
the test method level treats each junit test method as a test case while test class level treats each junit test class as a test case.
we examine both the e ectiveness and similarity of detected faults for both granularities.
rq the goal of this rqis to analyze the similarity of detected faults for di erent techniques to better understand the level of equivalency of di ering strategies.
it is clear thatthis type of analysis is important as while popular metrics such as apfd measure the e ectiveness between two di erent techniques this does not reveal the similarity of the test cases in terms of uncovered faults.
for instance let us consider two tcp techniques a and b. if technique a achieves an apfd of and technique b achieves an apfd of while this gives a measure of relative e ectiveness the apfd does not reveal how similar or orthogonal the techniques are in terms of the faults detected.
for instance all of the faults uncovered by top ten test cases from technique b could be di erent than those discovered by top ten test cases from technique a suggesting that the techniques may be complimentary .
to evaluate the similarity between di erent tcp techniques we utilize and build upon similarity analysis used in recent work and construct binary vector representations of detected faults for each technique and then calculate the distance between these vectors as a similarity measure.
we employ two methodologies in order to give a comprehensive view of the similarity of the studied tcps.
at the core of both of these techniques is a measure of similarity using the jaccard distance to determine the distance between vectorized binary representations of detected faults where a signi es a found fault and a signi es an undiscovered fault for di erent techniques across individual or groups of subject programs.
we use the following de nition j ti a ti b jti a ti bj jti a ti bj where ti arepresents the binary vectorized discovered faults of some studied technique a after the execution of the ith test case in the techniques prioritized set and ti brepresents the same meaning for some studied technique b and j ti a ti b .
while we use the same similarity metric as in we report two types of results results comparing the similarity of the studied static and dynamic techniques using the average jaccard coe cient across all subjects at di erent test case granularities and results comparing each technique in a pair wise manner for each subject program.
for the second type of analysis we examine each possible pair of techniques and rank each subject program according to jaccard coe cient as highly similar .
.
similar .
.
dissimilar .
.
or highly dissimilar .
.
this gives a more informative view of how similar two techniques might be for di erent subject programs.
to construct both types of binary fault vectors we use the same fault selection methodology used to calculate the apfd that is we randomly sample faults from the set of known discoverable faults for each subject.
rq the nal goalof our study is to understand the e ciency of static techniques in terms of execution costs.
note that we only focus on the e ciency of static techniques since dynamic techniques are typically run on the previous version of a program to collect coverage information and thus the temporal overhead is quite high and well studied.
to evaluate the e ciency of static techniques we collect two types of time information the time for pre processing and the time for prioritization.
the time for pre processing contains di erent phases for di erent techniques.
for example tpcg totand tp cg addneed to build the call graphs for each test case.
tp strneeds to analyze the source code to extract identi ers and comments for each test case.
besides tptopic needs to pre process extracted textual information and use the r lda package and mallet to build topicmodels.
the time for prioritization refers to the time cost for tcp on di erent subjects.
.
tools and experimental hardware we reimplemented all of the studied dynamic and static tcps in java according to the speci cations and descriptions in their corresponding papers since the implementations were not available from the original authors and had to be adapted to our subjects.
all three of the authors carefully reviewed and tested the code to make sure the reimplementation is reliable.
we also invited an expert working in the area of test case prioritization to review our code.
tpcg tot tp cg add following the paper by zhang et al.
we use the ibm t. j. watson libraries for analysis wala to collect the rta static call graph for each test and traverse the call graphs to obtain a set of relevant methods for each test case.
then we implement two greedy strategies i.e.
total and additional to prioritize test cases.
tpstr based on the paper by ledru et al.
each test case is treated as one string without any preprocessing.
thus we directly use jdt to collect the textual test information for each junit test and then calculate the manhattan distances between test cases to select the one that is farthest from the prioritized test cases.
tptopic rand tp topic m following the topic based tcp paper we rst use jdt to extract identi ers and comments from each junit test and then pre process those e.g.
splitting removing stop words and stemming .
to build topic models we used the r lda package for tp topic r and mallet for tp topic m. all parameters are set with previously used values .
finally we calculated the manhattan distances between test cases and selected the ones that are farthest from the prioritized test cases.
dynamic tcp techniques we use the asm bytecode manipulation and analysis toolset to collect the coverage information for each test.
speci cally in our empirical study it obtains a set of statements that can be executed by each test method or test class.
the greedy techniques are replicated based on the paper by rothermel et al.
.
for the art and search based techniques we follow the methodology described in their respective papers .
experimental hardware the experiments were carried out on thinkpad x1 laptop with intel core i5 .
ghz processor and gb ddr3 ram.
.
results in this section we outline the experimental results to answer the rqs listed in section .
.
rq rq effectiveness of studied techniques at different granularities the values of apfd across all subjects at class level are shown in figure a and table .
based on this gure we make the following observations.
first somewhat surprisingly at the test class level the static tp cg addtechnique performs the best across all studied tcp techniques including all dynamic techniques with an average apfd value of .
see table .
tp cg totperforms worse than tpcg add followed by tp str tp topic mand tp topic r. the best performing dynamic technique at class level is tp add followed by tp search tp total and tp art.
it is notable that at test class level granularity the most e ective dynamic technique tp addand the most e ective static technique perform similarly .
versus .
respectively.
this suggeststpcg tot tpcg add tpstr tptopic r tptotal tpadd tpartapfd tpsearch0.
.
.
.
tptopic m p1 p30 a the values of apfd on test class level across all subject programs.
tpcg tot tpcg add tpstr tptopic r tptotal tpadd tpartapfd tpsearch0.
.
.
.
tptopic m p1 p30 b the values of apfd on test method level across all subject programs.
figure the box and whisker plots represent the values of apfd for di erent tcp techniques at di erent test granularities.
the x axis represents the apfd values.
the y axis represents the di erent techniques.
the central box of each plot represents the values from the lower to upper quartile i.e.
to percentile .
table results for the anova and tukey hsd tests on the average apfd values depicted in figures a b .
granularity metric tpcg tot tpcg add tpstr tptopic rtptopic m tptotal tpadd tpart tpsearch p value test classavg .
.
.
.
.
.
.
.
.
.86e 7hsd a a a bc ab ab a c a test methodavg .
.
.
.
.
.
.
.
.
.69e 13hsd d cd cd cd bc cd a cd ab that at the test class level the call graph based strategy performs about as well as dynamic coverage information which is notable.
additionally overall the static techniques outperform the dynamic techniques at test class granularity.
to further investigate rq 1and answer rq 2we ran all of the subject tcps on the subject programs at test method level which we can compare to the results at test class level outlined above see rq .
the results are shown in figure b and table .
first when examining the static techniques with test method granularity they perform differently as compared to the results on test class level.
surprisingly t topic m .
performs better than the other static techniques followed by tp str tp cg add tp topic r and tp cg totrespectively.
it is worth noting that the effectiveness of the topic model based technique varies quite dramatically depending on the tools used for its implementation mallet signi cantly outperforms the r based implementation.
however as a whole the e ectiveness of the dynamic techniques outpaces that of the static techniques at method level granularity with tp addperforming the best of all studied techniques .
.
this nding is consistent with previous studies .
overall on average all static and dynamic tcps perform better on test method level as compared to the results on test class level.
logically this is not surprising as using a ner level of granularity e.g.
prioritizing individual test methods gives each technique more exibility which leads to more accurate targeting and prioritization.
furthermore the ranges of average of apfd for all tcps on test method level are smaller than the results on test class level con rming that the performance of the tcp at test method level is more stable.
the ranges of apfd values re ect the robustness of thetcps.
for example the range of average of apfd across all subjects at test class level for tp addis the smallest i.e.
.
.
implying that the performance of tp addis usually stable despite di ering types of subjects.
conversely the ranges of apfd values for tp strand tp artare much larger .
.
for tp str .
.
for tp art implying that their performance varies on di erent types of subjects.
to further investigate the nding that static techniques tend to have a higher variance in terms of e ectiveness depending on the program type we investigated further by inspecting several subject programs.
one illustrative example is that scribe java scores and for the average values of apfd under tp strand tp topic rrespectively which are notably worse than the results of tp cg tot .
and tpcg add .
.
to understand the reason for this discrepancy we analyzed the test code and found that scribe java is documented written more poorly than other programs.
for instance the program uses meaningless comments and variable names such as param param v1 v2 etc.
this con rms the previously held notion that static techniques which aim to prioritize test cases through text based diversity metrics experience performance degradation when applied to test cases written in a poor generic fashion.
finally to check for statistically signi cant variations in the mean apfd values across all subjects and con rm deny our null hypothesis for rq we performed a one way anova and tukey hsd test.
the results of the anova test given in the last column of table are well below our established threshold of .
thus signifying that the subject programs are statistically di erent from one another.
this rejects the null hypothesis and we conclude that there are statistically signi cant di erences between di erent tcp techniques attable the table shows the results of wilcoxon signed rank test on the average apfd values for each pair of tcp techniques.
the techniques t1 to t9 refer to tp cg tot tp cg add tp str tp topic r tp topic m tp total tp add tp art tpsearch respectively.
for each pair of tcp techniques there are two sub cells.
the rst one refers to the p value at test class level and the second one refers to the p value at test method level.
if a p value is less than .
the corresponding cell is shaded.
t1 t2 t3 t4 t5 t6 t7 t8 t9 t1 .
.1e .
.4e .5e .
.
.1e .
.
.
.7e .8e .
.
.7e t2 .
.1e .
.
.3e .
.
.
.
.
.
.6e .4e .
.
.5e t3 .
.4e .
.
.3e .0e .
.
.
.
.
.9e .1e .
.
.7e t4 .5e .
.3e .
.3e .0e .2e .0e .4e .
.6e .7e .
.
.6e .7e t5 .
.1e .
.
.
.
.2e .0e .
.
.9e .2e .5e .
.2e .2e t6 .
.
.
.
.
.
.4e .
.
.
.7e .3e .
.
.6e .0e t7 .
.7e .
.6e .
.9e .6e .7e .9e .2e .7e .3e .7e .9e .
.2e t8 .8e .
.4e .
.1e .
.
.
.5e .
.
.
.7e .9e .4e .5e t9 .
.7e .
.5e .
.7e .6e .7e .2e .2e .6e .0e .
.2e .4e .5e table the tables show the classi cation of subjects on di erent granularities using jaccard distance.
the four values in each cell are the numbers of subject projects the faults of which detected by two techniques are highly dissimilar dissimilar similar and highly similar respectively.
the technique enumeration is consistent with table .
a this table shows the classi cation of subjects at the cut point on test class level.
t1 t2 t3 t4 t5 t6 t7 t8 t9 t1 t2 t3 t4 t5 t6 t7 t8 t9 total b this table shows the classi cation of subjects at the cut point on test method level.
t1 t2 t3 t4 t5 t6 t7 t8 t9 t1 t2 t3 t4 t5 t6 t7 t8 t9 total the di ering granularities.
the results of the tukey hsd test illustrate the statistically signi cant di erences between the static and dynamic techniques by grouping the techniques into categories with arepresenting the best performance and drepresenting the worst.
for test class level we see that the groupings slightly favor the static techniques as more of them are grouped in the top ranked acategory.
for test method level it is clear that the dynamic techniques outperform the static as far more dynamic techniques are ranked in the better performing categories.
in order to illustrate the individual relationships between strategies we present the results of the wilcoxon signed rank test for all pairs of techniques in table .
the shaded cells represent the results that indicate a statistically signi cant di erence between techniques across all the subjects e.g.
p in summary we answer rq rq 2as follows rq there is a statistically signi cant di erence between the e ectiveness of the studied techniques.
on average static technique tp cg addis the most e ective technique at test class level whereas dynamic technique tpaddis the most e ective technique at test method level.
overall the static techniques outperform the dynamic ones at test class level but the dynamic techniques outperform the static ones at test method level.
rq the test granularity signi cantly impacts the e ectiveness of tcp techniques.
all the studied techniques perform better at test method level compared torq continued test class level.
there is also less variation in the apfd values at method level compared to class level which signi es that the performance of the studied techniques is more stable at test method level.
.
similarity between uncovered faults for different tcp techniques the results for the similarity are shown in tables a b and figures b a .
the two gures represent the results comparing the average jaccard similarity of the studied static techniques to the studied dynamic techniques for all subject programs across randomly sampled faults at di erent prioritization cut points.
these results indicate that there is only a small amount of similarity between these two classi cations of techniques at the higher level cut points.
more speci cally for test method level only of the detected faults are similar between the two types of techniques for the top of the prioritized test cases and at test class level only about are similar for the top of prioritized test cases.
this result illustrates one of the key ndings of this study the studied static and dynamic tcp techniques do not uncover similar program faults at the top cut points of prioritized test cases.
the potential reason for these results is that di erent techniques use di erent types of information to prioritize test cases.
for example the studied static techniques typically aim to promote diversity between prioritized test cases using similarity diversity metrics such as textual distance or call graph information.
in contrast the studied dynamic tcps consider statement level dynamic coverage to priori jaccard similarity coefficient .
.
.
.
cut points a class level results jaccard similarity coefficient .
.
.
.
cut points b method level results figure average jaccard similarity of faults detected between static and dynamic techniques across all subjects at method and class level granularity.
tize test cases.
this nding raises interesting questions for future work regarding the possibility of combining static and dynamic information and the relative importance of faults that di ering techniques might uncover.
it should be noted that di erent coverage granularities for dynamic tcps may also e ect the results of similarity however we leave such an investigation for future work.
from these gures we can also conclude that the techniques are slightly more similar at method level than at class level.
to further illustrate this point we calculated the jaccard coe cients for each pair of tcps for each subject program and show the results in table a .
for each pair of techniques we group the subjects into the categories described in section .
due to space limitations we only show results for the top of prioritized test cases a complete dataset can be found at .
the results con rm the conclusions drawn from figures a b .
it is clear that when comparing the studied static and dynamic techniques more subjects are classi ed into the highly dissimilar and dissimilar categories.
another relevant conclusion that can be made is that the dissimilarity between techniques is not universal across all subjects.
that is even though two techniques may be dissimilar across several subjects there are some cases where similarity still exists.
this suggests that only certain types of programs that exhibit di erent characteristics may present the opportunity of performance improvement for tcps by using both static and dynamic information.
rq the studied static and dynamic tcp techniques tend to discover dissimilar faults for the most highly prioritized test cases.
speci cally at the testmethod level static and dynamic techniques agree only on of uncovered faults for the top of prioritized test cases.
additionally a subset of subjects exhibit higher levels of ucovered fault similarity suggesting that only software systems with certain characteristics may bene t from di ering tcp approaches.
.
efficiency of static tcp techniques the results of time costs for the studied static techniques at both of test method and test class levels are shown in table .
note that the time of pre processing for tp cg tot and tp cg addare the same for both method and class levels.
as the table shows all studied techniques require similar time to pre process the data at both method and class levels and to rank test cases on class level.
but the times for prioritization are quite di erent at method level.
we nd that tp cg totand tp cg addtake much less time to prioritize test cases totaling .
seconds and .
seconds as compared to tp str totalling .
seconds tptopic r totalling .
seconds and tp topic m totalling seconds .
specially these two techniques take much longer time on some subjects e.g.
p27and p30 .
however these subjects have a large number of test cases see table implying that tp str tp topic rand tptopic mwill take more time as the number of test cases increases.
overall all techniques take a reasonable amount of time to preprocess data and prioritize test cases.
at testmethod level tp cg totand tp cg addare much more e cient.
tp str tp topic rand tp topic mrequire more time to prioritize increasing numbers of test cases answering rq .
rq on test method level tp cg totand tp cg add are much more e cient in prioritizing test cases.
tp str tptopic rand tp topic mwould take more time when the number of test cases increases.
the time of preprocessing and prioritization on test class level for all static techniques are quite similar.
.
threats to v alidity threats to internal validity in our implementation we used pit to generate mutation faults to simulate real program faults.
one potential threat is that the mutation faults may not re ect all natural characteristics of real faults.
however mutation faults have been widely used in the domain of software engineering research and has been demonstrated to be representative of the actual program faults .
additionally further threats related to mutation testing include the potential bias introduced by equivalent and trivial mutants.
to mitigate these threats we randomly selected faults for each subject system when conducting our study related to the e ectiveness and similarity of faults uncovered for the various techniques.
this follows the guidelines and methodology of previous well accepted studies minimizing this threat.
to perform the study we reimplemented eight tcp techniques presented in prior work.
it is possible that there may be some slight di erences between the original authors implementations and our own.
however we performed this task closely following the technical details of the prior techniques and set parameters following the guidelines in the original works.
additionally the authors of this paper met for and open code review related to the implementation of the studied approaches and our implementation was reviewed by an expert in the eld of test case prioritization.
furthermore based on our general ndings we believe our implementations to be accurate.
threats to external validity the main external threat to our study is that we experimented on only software systems which may impact the generalizability of the re table execution costs for the static tcp techniques.
the table lists the average min max and sum of costs across all subject programs for both test class level and test method level i.e.
cost at test class level cost at test method level .
time is measured in second.
techniquespre processing test prioritization avg.
min max sum avg.
min max sum tpcg tot .
.
.
.
.
.
.
.
.
.
.
.
.
.
tpcg add .
.
.
.
.
.
.
.
.
.
.
.
.
.
tpstr .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tptopic r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tptopic m .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sults.
involving more subject programs would make it easier to reason about how the studied tcp techniques would perform on software systems of di erent languages and purposes.
however we chose systems with varying sizes 2kloc kloc and di erent numbers of detectable faults which makes for a highly representative set of java programs.
additionally some subjects were used as benchmarks in recent papers .
thus we believe our study parameters have su ciently mitigated this threat to a point where useful and actionable conclusions can be drawn in the context of our research questions.
finally we selected four static tcp techniques to experiment with in our empirical study.
there are some other recent works proposing static tcp techniques but we focus only on those which do not require additional inputs such as code changes or requirements in this empirical study.
furthermore we only compared the static techniques with four state of art dynamic tcp techniques with statementlevel coverage.
we do not study the potential impact of different coverage granularities on dynamic tcps.
however these four techniques are highly representative of dynamic techniques and have been widely used in tcp evaluation and statement level coverage has been shown to beat least as e ective as other coverage types .
.
lessons learned in this section we comment on the lessons learned from this study and their potential impact on future research lesson .
our study illustrates that di erent test granularities impact the e ectiveness of tcp techniques and that the ner method level granularity achieves better performance in terms of apfd detecting regression faults more quickly.
this nding should encourage researchers and practitioners to use method level granularity and perhaps explore even smaller granularities for regression test case prioritization.
additionally researchers should evaluate their newly proposed approaches on di erent test granularities to better understand the e ectiveness of new approaches.
lesson .
the performance of di erent tcps varies across di erent subject programs.
one technique may perform better on some subjects but perform worse on other subjects.
for example tp topic performs better than tp cg add onwebbit but performs worse than tp cg addonwsc.
this nding suggests that the characteristics of each subject are important to nding suitable tcps.
furthermore we nd that the selection of subject programs and the selection of implementation tools may carry a large impact regarding the results of the evaluation for tcps e.g.
there can be large variance in the performance of di erent techniques depending on the subject particularly for static approaches .
this nding illustrates that the researchers need to evaluate their newly proposed techniques on a large set of real subject programs to make their evaluation reliable.
to facilitate this we provide links to download our subject programs and data at .additionally a potential avenue for future research maybe an adaptive tcp technique that is able to analyze certain characteristics of a subject program e.g.
complexity test suite size libraries used and modify the prioritization technique to achieve peak performance.
lesson .
our ndings illustrate that the studied static and dynamic tcp techniques agree on only a small number of found faults for the top ranked test methods and classes ranked by the techniques.
this suggests several relevant avenues for future research.
for instance i it may be useful to investigate speci c tcp techniques to detect important faults faster when considering the fault severity importance during testing ii di ering tcp techniques could be used to target speci c types of faults or even faults in speci c locations of a program and iii static and dynamic information could potentially be combined in order to achieve higher levels of e ectiveness.
furthermore the similarity study performed in this paper has not been a core part of many tcp evaluations and we assert that such an analysis should be encouraged moving forward.
while apfd gives a clear picture of the relative e ectiveness of techniques it cannot e ectively illustrate the di erence set of detected faults between two techniques.
this is a critical piece of information when attempting to understand new techniques and how they relate to existing research.
.
conclusion in this work we perform an extensive study empirically comparing the e ectiveness e ciency and similarity of detected faults for static and dynamic tcp techniques on real java programs.
the experiments were conducted at both test method and test class levels to understand the impact of di erent test granularities on the e ectiveness of tcp techniques.
the results indicate that the studied static techniques tend to outperform the studied dynamic techniques at the test class level whereas dynamic techniques tend to outperform the static techniques at test method level.
additionally we found that the faults uncovered by static and dynamic techniques for the highest prioritized test cases uncover mostly dissimilar faults which suggests several promising avenues for future work.
finally we found evidence suggesting that di erent tcp techniques tend to perform di erently on di erent subject programs which suggests that certain program characteristics may be important when considering which type of tcp technique to use.
.