learning api usages from bytecode a statistical approach t am the nguyen hung viet pham phong minh vu t ung thanh nguyen computer science department utah state university tam.nguyen hung.pham phong.vu aggiemail.usu.edu tung.nguyen usu.edu abstract mobile app developers rely heavily on standard api frameworks and libraries.
however learning api usages is often challenging due to the fast changing nature of api frameworks for mobile systems and the insufficiency of api docu mentation and source code examples.
in this paper we pro pose a novel approach to learn api usages from bytecode ofandroid mobile apps.
our core contributions include hapi a statistical model of api usages and three algorithms to extract method call sequences from apps bytecode to trainhapi based on those sequences and to recommend methodcalls in code completion using the trained hapis.
our empirical evaluation shows that our prototype tool can effectively learn api usages from thousand apps containing350 million method sequences.
it recommends next methodcalls with top accuracy of and outperforms baselineapproaches on average .
keywords statistical model api usage mobile apps .
introduction mobile apps are software applications developed specially for mobile devices like smartphones and tablets.
due to the exploding in popularity and usage of those devices millions of mobile apps have been developed and made available toend users.
due to the fierce competition those mobile appsoften need to have very short time to market and upgrade cycles andthus shortdevelopmenttime.
toaddressthisrequirement mobile app developers often rely heavily on apiapplication frameworks and libraries such as android andios frameworks java apis etc and mobile apps extensivelyre use api components.
for example a prior study reports some android apps having up to of their external dependencies to android apis and to java apis .
learning api usages is usually challenging due to several reasons.
first an api framework often consists a large permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full cita tion on the first page.
copyrights for components of this work owned by others thanacm must be honored.
abstracting with credit is permitted.
to copy otherwise or re publish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt2016 acm.
isbn .
.
.
.
of components.
for example the android application framework contains over classes and meth ods which are organized in more than packages .moreover while common api usage scenarios often involve several api elements and follow special rules for pre and post conditions or for control and data flows documentation of such usages is generally insufficient.
forexample the javadoc of a class mainly contains only descriptions of its fields and methods and rarely has code examples describing in details the usages of its objects andmethods .
descriptions and code examples for api us ages involving several objects are usually non existed.
these challenges are even more severe for learning apis of mobile frameworks.
due to the fast development of mo bile devices and the strong competition between softwareand hardware vendors those frameworks are often upgradedquickly and include very large changes.
for example major versions of android framework containing nearly method levelchangeshavebeenreleasedwithinfiveyears .additionally source code of most mobile apps is not publiclyavailable.
with few apps with source code available find ing and learning code examples from existing mobile app projects would be difficult and insufficient.
in this paper we introduce salad s tatistical a pproach for l earning a pis from d vm bytecode a novel approach to address the problem of learning api mobile frameworks.
to address the problem of insufficient documentation andsource code examples salad learns api usages from bytecodeof android mobile apps of which millions are publicly available.
as a statistical approach salad can learn com plex api usages involving several api objects and methods.finally salad can automatically generate recommenda tions for incomplete api usages thus it could reduce thechance of api usage errors and improve code quality.
the key component of our approach is hapi standing for h idden markov model of api usages .ah a p ii sah i d den markov model hmm representing method callsequences involving one or multiple related api objects.
it has several states aimed to represent the internal states of the represented api objects.
it also associates with prob abilities for selecting the starting state for transiting fromone state to another and for calling a method at a given state.
those probabilities describe the statistical patterns of api states and method calls.
salad also consists of three new algorithms involving hapi.
one algorithm is designated to train a hapi i.e.inferring its internal states and estimating the associated probabilities from a very large collection of method call se2016 ieee acm 38th ieee international conference on software engineering quences.
anotheralgorithmusesatrainedhapitocompute the generating probabilities of several method sequences and rank those sequences based on those probabilities.
this ranking result is used for api usage recommendation.
the last algorithm extracts api method sequences from apps bytecode which are then used for training hapis.
itfirst analyzes bytecode and builds groums.
a groum gr aph based o bject u asge m odel is a graph based model in which the nodes represent method calls and data objects and the edges indicate control and data flows be tween those methods and objects.
with that design a groum can represent an usage scenario including many objects and methods and complex control and data flowsbetween them.
once a groum is built our algorithm cantravel all its paths following the control and data dependen cies and extracts the corresponding method sequences.
we have conducted several experiments to evaluate the usefulness and effectiveness of salad.
the experiment re sults show several important points.
first our approachsalad is highly efficient and scalable.
it is able to extract nearly millions method sequences and train thou sands hapis from more than thousands mobile apps downloaded from google s android app market.
with thathuge amount of training data salad can predict and rec ommend the next method call for a given api method call sequence with a top accuracy of nearly and a top accuracy of more than .
in addition our model hapiconsistently outperforms two baseline models n gram and recurrent neural network with the average improvement around .
based on salad we have developed an api usage recommendation tool named droidassist.
this tool is implemented as a plug in of android studio and available on line at more information about this tool can be found in and that website.
source code and experiment data of this work e.g.extracted api method sequences groums and hapis are also made available there.
the remaining of this paper is organized as the following.
section presents an example of android apis andtheir usages in practice.
it also illustrates how hapis couldbe used to model api usages.
section introduces hapias the main conceptual contributions of salad.
section discusses the overall architecture of salad and its key algorithms.
our empirical evaluation is presented in section5.
we discuss related work in section .
.
example this section briefly introduces api usages and hapi via an example.
figure reproduced from android developerwebsite illustrates usages of a mediarecorder object in android api framework as a state diagram.
this state di agram is a finite state machine in which each node drawn as a rounded rectangle represents an internal state of the mediarecorder object and each edge drawn as an arrow represents a state transition when a method drawn as thelabel of the edge is called.
welearnfromthisstatediagramthata mediarecorder object has seven states during its lifetime.
it is at one state ata time and can change to another state if a method is called.for example as after being created the mediarecorder object is in the initialstate.
if method setaudiosource or setvideosource is called it changes to the initialized state.
error initial released recording preparedinitialized datasource configuredreset reset setaudiosource setvideosource setaudiosource setvideosource setoutputformat setaudioencoder setvideoencoder setoutputfile setvideosize setvideoframerate setpreviewdisplay reset reset prepare release start reset stop error occurs or an invalid call figure state diagram of mediarecorder object then it will change from the initialized state to the datasourceconfigured s t a t ei fw ec a l lm e t h o d setoutputformat.
however at any time if method resetis called the object will come back to its initialstate.
it could be seen from this example that state diagrams can represent usages of api objects precisely and concisely.
thus they are useful to learn and understand api usages.
for example we could infer from figure the following method call sequence to perform an audio recording task.
setaudiosource ... setoutputformat ... setaudioencoder ... setoutputfile ... prepare start stop release unfortunately documentationofmostofapiobjectsdoes not contain state diagrams representing their usages.
in addition state diagrams can be used to to check for thevalidityof method call sequences but not their popularity .
for example we cannot know from a state diagram that a sequence is validbuthas never been used or compare if a sequence is more likely to be used in practice than another.
last but not least current code completion engines like the thebuilt inengineinandroidstudioidedonotincorporatestate diagrams in their recommendations.
we design hapi to take advantages of the usefulness of state diagrams in representing api usages and address theirdiscussed limitations.
in essential a hapi is a probabilistic state diagram .
its nodes and edges associate with probabilities which can be used to estimate the probability of anymethod call sequences.
more importantly its structure andprobabilistic parameters can be learned directly from data.
figure illustrates a hapi model learned by salad to represent the usages of a mediarecorder object.
in this figure each node of the hapi represents a state of the object.but different from the state diagram in figure each stateof a hapi has a probability for being the starting state in a method sequence.
it also has a distribution specifying the probability to call a particular method i.e.
emission probabilities and another distribution specifying the prob417 .
setaudiosource .
setvideosource .
.
.
setaudioencoder .
setvideoencoder .
.
.
setoutputfile .
setvideosize .
.
.
prepare .
setpreviewdisplay .
setvideoframereate .
.
start .
release .
stop .
.
.
reset .
.
setoutputformat .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure hapi model for usages of mediarecorder object ability to change to another state i.e.
transition probabilities .
to simplify the drawing we only show method callsand transition edges with significant probabilities in the fig ure.
by design the states of a hapi model aim to representthe internal states of the corresponding api objects.
the transition probabilities capture switching patterns of thoseinternal states and the emission probabilities describe the method calling patterns at each of those states.
for example accordingly to the hapi model in figure amediarecorder object starts in state with probability of .
in this state method setaudiosource can be called with a probability of and when that happens the ob ject can change to state with a probability of .
instate setoutputformat can be called with a probability of and so on.
technically a hapi is a hidden markovmodel which can be trained i.e.
inferring its structureand the associating probabilities from a given collection ofmethod call sequences.
once trained we can use it to compute and compare the probabilities of any given method sequences.
for example the sequence setaudiosource setoutputformat setaudioencoder would have higher probability than the sequence setaudiosource setoutputformat start.
hapi models have several advantages over plain state diagrams.
first the state diagram only specifies the generalrules for using objects but not specify the common usages.in contrast once learned from code examples hapi couldinfer common usages of an api object by searching for the method sequences that have highest probabilities.
second a hapi could be used to predict the most likely next methodcall in a given api method call sequence.
thus we canuse hapi to recommend api usages while developers arewriting code.
.
api usage model in this section we will discuss hapi our proposed statistical model for api usages in more details.
we also re protected void startrecording string file mediarecorder recorder newmediarecorder recorder.setaudiosource mediarecorder.audiosource.mic recorder.setoutputformat mediarecorder.outputformat.three gpp recorder.setaudioencoder mediarecorder.audioencoder.amr nb recorder.setoutputfile file try recorder.prepare catch illegalstateexception e e.printstacktrace catch ioexception e e.printstacktrace recorder.start figure code example using mediarecorder object introduce groum a graph based model for object usagesdeveloped previously by nguyen et al.
.
salad uses groum as a temporary representation for api usages extracted from mobile apps bytecode.
.
hmm based api usage model a hapi is a generative probabilistic model that describes the process of generating method call sequences involving oneormultipleapiobjects.
asahiddenmarkovmodel a hapi formally has a set q q q2 ... q k ofkhidden states and associates with a set v v1 v2 ... v m ofm api methods of the api object s it is modeling.
each stateq ihas a probability ito be selected as the starting state of the model.
when being in one state a hapi can emit i.e.generate a method call and or switch to another state.
the transition matrix a a ij i j ..k specifies the state transition probabilities.
that means aijis the probability that the model changes from state qito state qj.
the generating matrix b bik i ..k k ..m specifies the emission probabilities.
specially bikis the probability to call method vkwhen the model is in state qi.
as seen this hapi model has k k2 kmparameters.
with those parameters the hapi model can generate a method sequence y y1 y2 .. y t via the following generating process .
sett and sample the state qitfrom the initial state distribution 1 2 ... k .
sample a method call ytfrom the calling distribution of stateqit i .
e .
bit1 bit2 ... b itm .
sample the next state qit 1from the transition distrib u t i o no fs t a t eq it i .
e .
ait1 ait2 ... a itk .
increase ta n dl o o pb a c ks t e p2f o r titerations.
modeling api usages using hapi involves two problems.
the first problem is training i.e.
estimate the parameters of a hapi model for one or multiple api objects from ex isting method call sequences involving.
the second problemis using the trained hapi models to compute the generatingprobabilities of any method call sequences for recommending api usages.
in section we will present two algorithms we developed in salad to solve those two problems.
.
graph based object usage model a hapi model for one or multiple api objects is trained by a collection of method sequences involving those objects.toextractthosesequencesfrombytecode weemploygroum a graph based model of object usages as a temporary representation of api usages.
418mediarecorder.
init mediarecorder.setaudiosource mediarecorder.outputformat mediarecorder.setaudioencorder mediarecorder.setoutputfile mediarecorder.prepare mediarecorder.startmediarecorder stringint int int figure4 groummodelforusagesof mediarecorder object figure lists a code example with the usage of a mediarecorder object.
figure illustrates the groum built for the main execution path of that code example.
as seen in this figure a groum is a labeled directed graph.
it hastwo kinds of nodes object nodes andaction nodes .a no b ject node represents an object.
it is labeled by the nameo ft h eo b j e c tt y p e e .
g .
mediarecorder and illustrated as a rounded rectangle in the figure.
an action node repre sents a method call.
it is labeled the method qualified name e.g.mediarecorder.start and illustrated as a flat rectangle.
there are two kinds of edges representing control flow and data flow.
in the figure solid arrows illustrate control flowedges between action nodes while dashed arrows illustratedata flow edges between object nodes and other nodes.
using groum to represent api usage scenarios has two main advantages.
first we can easily identify all action nodes having data dependency with a given object node or set of object nodes from which we can extract method se quences.
second we could determine if a given set of objectnodes have usage dependency.
a set of object nodes has usage dependency if there is at least one action node that have data dependency with all of them.
salad only ex tracts method sequences of usage dependent objects becausethey are more likely to represent legitimate api usages in volving multiple objects.
.
system architecture figure shows the overall architecture and processing pipeline of salad.
for the pre processing phase it has two components to extract groums from bytecode and source code and another component to extract api methodsequences from those groums.
in the training phase thehapilearnercomponentisresponsibletousethosemethodsequences to train the hapi models.
once trained those models can use two components method call recommender andmethodsequenceanalyzertorecommendanextmethodcalls for a given method sequence and to estimate the like lihood of that sequence respectively.
in the rest of this section we will present the design and implementation details of those components.
.
bytecode groum extractor this component is responsible to extract groums from source code groum extractor android bytecodecurrent editing code api usage model api sequence extractor arusarusapi call sequences method call recommender method sequence analyzerbytecode groum extractor arusarusapi usage models hapi learner arusarushapi modelsarusarusapi call sequencesapi sequence extractor figure the overview of salad s architecture apps bytecode instructions.
bytecode of android apps isstored as .dex files and available on online app markets like google play store.
thus the extraction process has three steps downloading the .dex files parsing those filesinto control flow graphs cfgs and analyzing thosecfgs to build the groums.
.
.
downloading .dex files salad has a built in app crawler developed based on the google play crawler project .
this crawler simulates an android device thus it can access the app store like a normal smartphone.
we program it to download all thetop free new free apps in all categories.
for each downloadapplication package .apk files we extract and store the.dex files which contain all of its bytecode.
.
.
parsing .dex files the next step is to parse .dex files to build control flow graphs.
salad employs smali an assembler disassembler for android .dex files to obtain bytecode instructionsimplemented for each class and method available in the .dexfiles.
based on those instructions salad constructs a con trol flow graph cfg for each method to simplify the further analysis tasks.
let us discuss this in more details.
dalvik virtual machine.
android apps are originally developed in java and re targeted for execution in dalvik virtual machine dvm .
dvm is a register based virtual machine.
it has a set of bit registers for storing primitive values e.g.
integers and floating point numbers and object 419publicstring readtextfile string filename throwsioexception filereader fr newfilereader filename bufferedreader br newbufferedreader fr stringbuilder strbuilder newstringbuilder string line while line br.readline !
null strbuilder.append line br.close returnstrbuilder.tostring figure a source code example iomanager.readtextfile ljava lang string ljava lang string new instance v1 ljava io filereader invoke direct v1 v6 l j a v a i o f i l e r e a d e r .
init ljava lang string v new instance v0 ljava io bufferedreader invoke direct v0 v1 ljava io bufferedreader .
init ljava io reader v 000a new instance v3 ljava lang stringbuilder 000c invoke direct v3 ljava lang stringbuilder .
init v 000f invoke virtual v0 ljava io bufferedreader .readline ljava lang string move result object v2 if nez v2 001d invoke virtual v0 ljava io bufferedreader .close v invoke virtual v3 ljava lang stringbuilder .tostring ljava lang string 001b move result object v4 001c return object v4 001d invoke virtual v3 v2 ljava lang stringbuilder .append ljava lang string ljava lang stringbuilder goto000f figure dalvik bytecode of code example in figure