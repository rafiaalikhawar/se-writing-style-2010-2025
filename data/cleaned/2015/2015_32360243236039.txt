singularity pattern fuzzing forworst casecomplexity jiayi wei the universityof texasat austin austin texas usa wjydzh1 gmail.comjia chen the universityof texasat austin austin texas usa grievejia gmail.comyu feng the universityof texasat austin austin texas usa yufeng cs.utexas.edu kostasferles the universityof texasat austin austin texas usa kferles cs.utexas.eduisil dillig the universityof texasat austin austin texas usa isil cs.utexas.edu abstract wedescribeanewblackboxcomplexitytestingtechniquefordeterminingtheworst caseasymptoticcomplexityofagivenapplication.
thekeyideaistolookforan inputpattern ratherthanaconcrete input that maximizes the asymptotic resource usage of the target program.
because input patterns can be described concisely as programs ina restricted language our method transforms the complexity testing problem to optimal program synthesis .
in particular we express these input patterns using a new model of computation calledrecurrentcomputationgraph rcg andsolvetheoptimal synthesisproblembydevelopingageneticprogrammingalgorithm that operates onrcgs.
we have implemented the proposed ideas in a tool called singularity and evaluate it on a diverse set of benchmarks.
our evaluation shows that singularity can effectively discover the worst casecomplexityofvariousalgorithmsandthatitismorescalable compared to existing state of the art techniques.
furthermore ourexperimentsalsocorroboratethat singularity candiscover previously unknown performance bugs and availability vulnerabilities in real world applications such as google guavaand jgrapht.
ccs concepts softwareanditsengineering softwareperformance software testing and debugging securityandprivacy denial ofservice attacks keywords complexity testing optimal program synthesis fuzzing genetic programming performance bug availability vulnerability acmreference format jiayi wei jia chen yu feng kostas ferles and isil dillig.
.
singularity pattern fuzzing for worst case complexity.
in proceedings of the 26th acm joint european software engineering conference and symposium permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa associationfor computing machinery.
acm isbn ... .
the foundations of software engineering esec fse november 4 lake buena vista fl usa.
acm new york ny usa 11pages.
introduction reasoningaboutaprogram sworst casecomplexityisanimportant problemthathasmanyreal worldapplications includingperformancebugdetectionandidentificationofsecurityvulnerabilities.
for instance automated complexity analysis can identify cases where an algorithm s expected worst case complexity does not matchthatofitsimplementation thusindicatingthepresenceof aperformancebug.suchtechniquesarealsousefulfordetecting availabilityvulnerabilitiesthatallowattackerstocausedenial ofservice e.g.
throughalgorithmic complexity attacks .
while there is a large body of literature on worst case complexityanalysis mostofthesetechniquesdonotproduce worstperformanceinputs henceforthcalled wpis thattriggerthe worst caseperformancebehaviorofthetargetprogram.suchwpis can be used to debug performance problems and confirm the presenceofsecurityvulnerabilities.
furthermore wpis canshed light onthe cause of worst caseexecutions and help programmerswrite suitablesanitizerstoguardtheircodeagainstpotentialdosattacks.
in this paper we propose a new black box complexity testing technique to efficiently generate inputs that trigger the worst case performanceofagivenprogram.thekeyinsightunderlyingour approach is thatwpisalmost alwaysfollowa specific pattern that canbeexpressedasasimpleprogram.forinstance totriggerthe worst caseperformanceofaninsertionsortalgorithm theinputarraymustbeinreversesortedorder whichcanbeprogrammatically generatedbyappendinglargerandlargernumberstoanemptylist.
based on this observation our key insight is to transform the complexity testing problem to a program synthesis problem where the goal is to find a programthat expresses the common pattern shared by allwpis.in particular given a targetprogrampwhose resource usage we want to maximize our algorithm synthesizes another programg called a generator such that the outputs of g correspond preciselyto the wpis of p.since the common pattern underlyingwpiscanoftenberepresentedusing smallgenerator programs thisapproachallowsustodiscoverwpisveryefficiently.
inthesimplestcase agenerator gconsistsofaninitialinputseed stogetherwithafunction fwhoseoutputislargerthanitsinput.
sincesize fi s size fj s whenever i j ourmethodcangeneratearbitrarilylargeinputsbyapplying fsufficientlymanytimes.
esec fse november4 9 lake buena vista fl usa jiayiwei jia chen yu feng kostasferles andisildillig forinstance theinputpattern f x.append x last x correspondstoaninfinitesequenceofinputsoftheform ... .
thus we can determine the worst case complexity of the target program by using the synthesized generator to obtain manywpisandthen fittingacurve throughthesedata points.
the problem of finding patterns that characterize wpis correspondstoan optimalsynthesisproblem wherethegoalistosynthesizeageneratorgsuchthatthevaluesproducedby gmaximizethe targetprogram sresourceusage.ourmethodsolvesthisoptimal synthesis problem by performing feedback guided optimization usinggeneticprogramming.specifically werepresentgenerators usingasetofdslscalled recurrentcomputationgraphs rcg that are a expressive enough to model most inputpatterns ofinterest andyet b restrictiveenoughtomakethesearchspacemanageable.
giventhisrepresentation ourmethodlooksforanoptimalrcgby applying genetic operators e.g.
mutation crossover to existing rcgsandbiasingthesearchtowardsgeneratorsthatmaximizethe target program s resourceusage.
we have implemented these ideas in a tool called singularity publiclyavailableongithub .weevaluate singularity seffectiveness on severalbenchmarks includingthosefrom previous literature real world applications and challenge problems from the darpa stacprogram1.
ourexperiments demonstrate singularity s effectiveness at finding inputs that trigger the worst case performance of various textbook algorithms whose average and worst casecomplexityaredifferent.ourexperimentsalsodemonstratetheadvantagesofourapproachover a slowfuzz astate ofthe artfuzzingtechniqueforfindingavailabilityvulnerabilities and b wise acomplexitytestingtechniquebasedondynamicsymbolic execution.
finally our experiments corroborate that singularity can find previously unknown performance bugs in widely used java applicationssuch as google guava andjgrapht .
in all this paper makesthe following key contributions weintroducethenotionof inputpatterns andshowhowtoreduce the complexity testing problem to an optimal program synthesis problem wherethegoalistofindaninputpatternthatmaximizes the target program s resourceusage.
we introduce anew model of computation called recurrent computationgraphs rcg forexpressinginputpatterns.thisrcg modelcanbeinstantiated indifferentwaystoobtain adomainspecific languagefor generatinginputsofmanydifferenttypes.
weshowhowtosolvetheunderlyingoptimalsynthesisproblem using genetic programming.
our method defines new genetic operators overrcgs and guides the searchtowards those input patterns that maximizeresourceusage.
we implement our method in a tool called singularity and evaluate it on a diverse set of benchmarks.
our experiments show the benefits of our approach over prior techniques and demonstrate that singularity can discover interesting security vulnerabilitiesandperformance bugs.
overview inthis section wepresentourproblem definitionandgivea brief overviewofour approach throughasimplemotivatingexample.
1thestacprogramaimstodevelopprogramanalysistechniquesforfindingavailability and confidentiality vulnerabilities.defquick sort xs if xs.length returnxs pivot xs left middle right forxinxs if x pivot middle.append x elif x pivot left.append x else right.append x left quick sort left right quick sort right returnconcat left middle right figure quicksort with middle pivot selection .
problemdefinition given a target program p our goal is to find an input pattern that triggersp s worst case resource usage.
as mentioned in section we represent input patterns as generator programs gthat produce an infinite sequenceof increasingly larger inputsforp.
definition .
generator given a program pwith signature ageneratorgforpisaprogramwithsignature unit stream .wewritegitoindicatethe i thelementinthestream producedbygandrequirethat size gi size gj whenever i j. becauseourgoalistomaximizetheresourceusageofagiven program we need a way to measure the size of an input and its correspondingresourceusage.thus a problemconfiguration inour settingconsistsofatriple p wherepisthetargetprogram with signature is a metric that defines the size of any value of type and is a function of type rthat measures the resource usage of pon any input of type .
in particular we write s todenotetheresourceusageof ponaconcreteinput sof type .
we also use the notation g nto denote the largest elementgisuch gi n. tocomparetheasymptoticresourceusageoftwopatterns we definethe following binary relation onapair of generators definition2.
relation ageneratorgisasymptoticallybetter thananother generator g writteng g iff the resource usage ofgon the target program exceeds that of g forall sufficiently largesizes n. n n. g n g n given a problem configuration p we now formalize our goalas the complexity testingproblem definition .
complexity testing thegoalofthe complexity testingproblemistofindaninputpatternsuchthatnootherpattern isasymptoticallybetterthan it.thatis wewantto finda gwhere g .g g .
motivating example wenowinformallydescribeourcomplexitytestingtechniqueon the simple quicksort example shown in figure 1as python code.
for concreteness let us assume that generators are expressed in 214singularity pattern fuzzing for worstcasecomplexity esec fse november4 9 lake buena vista fl usa p c x.le e ie le c int list ie int x plus ie ie minus ie ie times ie ie length le le list x append le e prepend e le concat le le figure2 adslwhere prepend appendaddsanelementtothe head tailofalist respectively.
figure3 output yisobtainedbyrepeatedlyapplyingfunctionfto seed value c. a simplified dsl shown in figure .
specifically a program gin this language is a tuple c f wherecis a constant seedvalue and fisafunctionthatoperatesoveralistofintegers.asillustrated in figure we can compute an infinite sequence of values from c f by repeatedly applying ftoc where the i th value yiin the sequence is given by fi c denoting isuccessive applications of f to valuec.
using the dsl from figure we can express the worst case pattern for the quicksort implementation from figure 1as follows g parenleftbig x.append prepend length x x length x parenrightbig this program produces the following sequenceofinputs ... observe that these inputs indeed trigger the worst case running time of the quicksort implementation from figure because a thesmallestvalueineachlistofthesequenceisthemiddleelement and b the quicksort implementation figure 1chooses the middle element as its pivot.
wenowexplainhow singularity findsthispattern g using genetic programming gp .
singularity startswithapopulation of randomly generated programs that conform to the context free grammargiveninfigure 2andevaluatesthefitnessofeachprogram.
since our goal is to maximize running time the fitness function assigns a higher score to programs that take longer.
for simplicity let us assume that we evaluate running time on some particular inputsize such as arrays oflength .
even though it is highly unlikely that the target generator g occursintheinitialpopulation p itmightbethecasethat pcontains several useful albeit suboptimal functions such as f1 x.append x length x andf2 x.prepend length x x .
these functions are useful since the desiredpattern can be obtainedby mixing thesefunctionsusing genetic operators.
for thenextiteration the genetic programming algorithmrandomly picks fit generators from the previous iteration.
for example theinputpatterns f1 and f2 arelikelytobeselected becausetheyhavehigherthanaverageresourceusage.
singularitythen uses these input patterns to generate a new population ofcandidatepatternsbycombiningthemusinggeneticoperators figure an rcg with cinternal states and moutput states.
such as mutation and crossover.
for example we can obtain the followingprogram f3fromf1andf2usingthecrossoveroperation x.append prepend length x x length x in particular crossover replaces a random sub expression in one programwithasub expressiontakenfromanotherprogram.inthis case wecanobtain f3fromf1 f2bysubstitutingthesub expression xinf1withtheentirebodyof f2.furthermore f3resultsinhigher resourceconsumption comparedto f1andf2.
we continue the process of generating new populations and monitor both their maximal and average performance.
in general average performance will keep increasing over generations and at some point singularity will generate the desired programg from f3 by mutating the sub expression length x tolength x .
since f can be used to generate an input of size100that achieves the maximal possible resource usage our algorithm will eventually terminate with the desired input pattern g .observethatwecannowdeterminetheworst casecomplexity ofthisquicksort implementationbymeasuringtherunningtimeof quicksort on the input values generated by g and using standard techniques to fitacurve throughthesedata points.
recurrentcomputation graphs inthissection weintroduce recurrentcomputationgraphs rcgs as a family of dsls for representing generators.
intuitively we choosercgsasourcomputationmodelbecausetheyareexpressive enough to capture most input patterns of interest that arise in practice but they are also restrictive enough to keep the search spacemanageable.
definition4.
recurrentcomputationgraph arecurrentcomputationgraphgisatriple i f o whereiisatuple of initialization expressions fis a tuple of update expressions where i f an of outputexpressions.
beforeconsideringtheformalsemanticsofrcgs wefirstexplain theminformally anrcg i f o isageneralizationofthesimple computational model described in section .
.
as illustrated in figure4 insteadofusingoneinternalstate anrcggeneratesan infinitesequenceofvaluesbymaintaining i internalstatesthat are initialized using iand updated using f. an rcg also uses an output layeroto transform its internal states before outputting them.thisdecouplingallowsthenumberofinternalstatestobe 215esec fse november4 9 lake buena vista fl usa jiayiwei jia chen yu feng kostasferles andisildillig si llbracketii rrbracket si llbracketfi rrbracket ... sc ma sto sc yj llbracketoj rrbracket ... sc ma sto sc where i c i and1 j m o llbracket i f o rrbracket bracketleftbig y1 ... ym t t bracketrightbig figure recurrentcomputation graphsemantics different from the number of arguments that the target program takes.
as before we can generate the k th value in the infinite sequencebyupdatingthe internal states exactly ktimes.
rcgsemantics.
moreformally thesemanticsofanrcg i f o isgivenbytherulesshowninfigure .here si representsthe i thinternalstateattimestep t andyi correspondstothe i th outputvalueattime t.asshowninfigure si iscomputedusing thei thinitializationexpressionin i andsi isobtainedfrom s1 ... sc by applyingthe updatefunction fi.
finally yj is obtained from the internal state at time tby applying the output expressionojto s1 ... sc .
the semantics of the rcg is then given by the infinite sequence of values y1 ... ym for t ...givenanrcggandavalue y wesaythat yisinthe language ofg writtenl g ify y1 ... ym for some time step t. rcgexpressions.
ourdefinitionofrecurrentcomputationgraphs intentionally does not fix the expression language over which i f oare specified.
to maximize theflexibilityof our approach rcgsareparametrizedbyasetofcomponents coverwhichtheinitialization update andoutputexpressionsareconstructed.recall thatbothfandoare functions and their arguments correspond to the rcg s internal states.
hence expressions eforfandocan be generatedaccording to the following grammar e si c f e1 ... ek wheresirepresents the i th internal state cis a constant value andf cisafunctionofarity k.sinceinitializationexpressions are required to be constants initfollows a similar grammar except thatwedonotallowinitializationexpressionstorefertothercg s internal states.
example .
thequicksort pattern from section .2can be expressedasthefollowing2 statercgusingthecomponents plus append prepend inc as well as integerconstants .
i f plus s1 append prepend inc s1 s2 s1 o s2 the first few iterations of the pattern s evaluation are shown below whereweuse todenote append prepend and plusrespectively s1 s2 s1 3s2 inc s1 5s2 inc inthepreviousexample theoutputstatewasexactlythesameas one of the internal states.
however as illustratedby the following example this isnot alwaysthe case.
example .
consider the following sequence of inputs ...thisinputpattern can be representedusing the following rcg i f plus s1 append s2 s1 o concat s2 s2 the output here is obtained by concatenating two copies of the input state s2 however there is no simple way to express this pattern without distinguishing between internal and output states.
complexitytestingasdiscrete optimization in this section we formulate the complexity testing problem introduced insection .1asanoptimalprogram synthesisproblem2.
towards this goal we first introduce the concept of a measurement modelfor assigning scores to recurrentcomputationgraphs definition5.
idealmeasurementmodel givenanrcgg an ideal measurement model mmapsgto a numeric value such that g g .
g g m g m g .
inotherwords anidealmeasurementmodel massignsahigher scoretogcomparedtog ifginducesasymptoticallyworsebehaviorofthetargetprogramcomparedto g .usingthisnotion we nowformulatecomplexitytestingintermsofthefollowingpattern optimization problem definition .
pattern optimization given an ideal measurementmodelm thepatternoptimization problemistofind anrcg that maximizesm i.e.
find the solution of argmax gm g .
because rcgs correspond to programs definition 6is a form of optimal program synthesis problem where the goal is to maximize asymptoticresourceusage.thefollowingtheoremstatesthatthe pattern optimization problem is equivalent to our definition ofthe complexitytestingproblem from section .
theorem .
.
eqn.
.2gives asolutionto definition .
proof suppose pattern gsatisfies eqn.
.
.
ifgis not a solution to definition thenwehavesome g suchthatg g.usingeqn.
.
weknowthatm g m g which meansgisnot thesolution to eqn.
.
i.e.
contradiction .
theorem .1isusefulbecauseitallowsustoturnthecomplexity testingproblemintoadiscreteoptimizationproblem assumingthat wehaveaccesstoanidealmeasurementmodel m.however due to the black box nature of our approach mis difficult to obtain in practice.
in particular the ideal measurement model requires reasoning about the asymptotic resource usage of the program on all inputs of a given shape but this is clearly a very difficult 2inoptimalprogramsynthesis thegoalistosynthesizeaprogramthatnotonly satisfies the specification butalso maximizesthe valueof some objectivefunction 216singularity pattern fuzzing for worstcasecomplexity esec fse november4 9 lake buena vista fl usa staticanalysisproblem.thus asaproxytothisidealizedmetric we insteadestimatethequalityofaninputpatternbyusingan empirical measurementmodel m n.specifically ameasurement model m n evaluatesthequalityofagenerator gbyrunningtheinputprogram pon inputs up to size n. in the remainder of this paper we use the following empirical modelas aproxyfor definition definition .
empirical measurement model ourempirical measurement model denotedm n evaluates an input pattern by returning the maximum resource usage among all inputs whose size does not exceedbound n.more formally m n g max x l g x n x .
thefollowingtheoremstatestheconditionsunderwhich m n isagoodapproximation ofthe ideal model theorem4.
.m nisanidealmeasurementmodel i.e.
satisfies equation4.
if nis sufficientlylargeand wehave limn g n proof weshowthat g g impliesm n g m n g underthe conditions stated in the theorem.
suppose g g .
from definition this means there exists n1such that n n1.
g n g n .
because we assume all patterns resource usage increase to infinity as the input size grows we can show that there exists some n2such that n n2.mn g g n andmn g g n usingeqn.
.
.
thus for n max n1 n2 wehavem n g m n g .
finding optimal rcgusinggp wenowdescribeageneticprogramming gp algorithmforsolving the discrete optimization problem from section .
we first present the top level algorithm andthen explainits subroutines.
.
algorithmoverview our pattern maximization algorithm is summarized in algorithm and follows the typical structure of genetic programming.specifically westartwitharandomly generatedinitialpopulationofrcgs lines and repeatedly create a new population by combining the fittest individualsfrom the old population.
to create a new population pop we create mnew rcgs by combining individuals from the existing population pop this corresponds to the forloop at lines .
a new individual gis created by randomly choosing a genetic operator op line and combining op.arityindividuals from the current population.
while there are several different techniques that can be used to select individualsfromthepopulation ouralgorithmusestheso called deterministictournamentmethod lines8 .specifically wesample krcgs and choose the rcg with the best fitness as the winner.
giventhenewrcg gcreatedatline10 weevaluate g sfitness line using a fitness function that we discuss in more detail in section .
.
ifgis fitter than the previously fittest rcg we 3kis a hyper parameter called tournament size and controls the evolution pressure of the gp process when kis set to there is no evolution pressure and all individuals from the population regardless of their fitness have the same chance to be picked by the tournament method hence in this case gp degenerates to random search.
when kissettothesizeofthewholepopulation onlythebestindividualofeachpopulation canbeselected to participatein the creationof newindividuals.algorithm1 pattern maximizationusing gp input gpops the setof genericoperators to use input m population size input k tournament size input n size bound for performance measurement.
input hyper parametersusedfor calculatingfitness output the pattern withthe highestfitness score sofar procedure findoptimalrcg gpops m k n pop initpopulation m best findbest pop while not converged do pop forifrom1tomdo op randompick gpops forjfrom1toop.aritydo argsj tournament pop k g op args g.fitness m n g e size g cost g ifg.fitness best.fitnessthen best g pop pop g pop pop returnbest figure mutation operator thenupdate besttobeg.thealgorithmterminateswithsolution bestif there has been no fitness improvement on bestfor many generations line4 .
.
geneticoperators we nowdescribe the genetic operators usedinalgorithm .
mutation operator.
the mutation operator is used to maintain diversity from one generation to the next and prevents the algorithmfrom convergingon alocal ratherthan global optimum.
itcreatesanrcgg fromanexistingrcg gbyapplyingmodifications to a node in the abstract syntax tree ast representation of g.specifically wefirstrandomlychooseaninitialization update or output expression eand then select a random node n called themutationpoint ine.ourmutationoperatorthenreplacesthe sub treetrooted at nwith a randomly generated ast with the same type as t.figure6illustrates this process.
217esec fse november4 9 lake buena vista fl usa jiayiwei jia chen yu feng kostasferles andisildillig figure crossoveroperator crossover operator.
the crossover operator is used to combine existingmembersofapopulationintonewindividuals.specifically givenrcgsg1andg2 we choose a mutation point n1of type in g1aswellasanothermutationpoint n2ofthesametype fromg2.
wethencreatetwonewrcgsbyswappingthesub treesrooted atn1andn2and randomly pick one of the two new rcgs.
the crossover operation isillustratedinfigure .
reproductionoperator.
thereproductionoperatorisjustanidentityfunction itsimplycopiestheselectedindividualintothenext generation.
reproduction is used to maintain stability between generationsbypreservingthe fittest individuals.
constfoldoperator.
theconstfold operatorissimilartoreproductionexceptthatitalsoperformslight weightconstantfoldingon the ast.
using constfold allows continuous evolution of constants usedinthe rcgswithoutgrowing totalast size.
.
fitnessfunction sinceourgoalistofindanrcgthatmaximizesthetargetprogram s resourceusage thesimplestimplementationofthefitnessfunction simply uses the measurement model m. however as standard ingeneticprogramming thefitnessfunctiondoesnothavetobe exactlythesameastheoptimizationobjective.wedesignourfitness function to have the following three properties it should be consistent with the measurement model m meaningthatgisconsideredfitter than g ifm g m g .
it should prevent individuals from evolving to unboundedly large programs bypenalizingrcgswithvery large ast size.
whentworcgshavesimilarsizeandresourceusage itshould use the occam srazor principleto prefer the simpler one.
basedonthesecriteria our fitness function fisdefinedas f g m n g e size g cost g wheresizemeasuresthe total astsize of g andcostisa measure of the complexity of the rcg4.
both and are tunable hyperparameters.
specifically is used for bloat control if the ast size ofgis smaller than thene size g 4is close to but when size g thefitnessquicklydecaysto .thehyper parameter mustbechosenasavaluelessthan 1anddeterminesthepenalty factor associatedwithcomplexity.
4wedefinecomplexityintermsoftheconstantsusedinthercg.intuitively thelarger the constants used in the rcg the higherthe cost.
implementation we have implemented the proposed method in a tool called singularity which consistsofapproximately6 000linesofscala code andmadeitpublicly avaibale ongithub .
in what follows we discussimportant design and implementation choices underlying singularity .
resource usage measurement.
recall that our problem definitionandfitnessevaluationfunctionusearesourcemeasurement function .
weimplement bycounting thenumber ofexecuted instructionsratherthanmeasuringabsoluterunningtime asthe latterstrategyistoonoisyduetofactorssuchascachewarm up contextswitching garbage collection etc.
to measure the executed number of instructions we perform static instrumentation using the soot framework for java programsandthellvmframework forc c programs.inmore detail we initializeaninteger counterwhen theapplication starts andincrementitbyoneaftereachinstruction.ourimplementation also provides a lighter weight version of this instrumentation that onlyincrementsthecounteratmethodentrypointsandloopheaders.
in practice we found this alternative strategy to work quite well asitstrikesagoodbalancebetweenprecisionandoverhead.
unlessstatedotherwise allofourbenchmarksareinstrumented using this lightweightstrategy.
rcg components.
recallfromsection 3thatourrecurrentcomputation graphs are parameterized by a set of components that are usedtoconstructexpressions.ourimplementationcomeswitha library of such components for most built in types and collections.
forinstance thecomponentlibraryforintegersincludemethods such asinc dec plus minus times modetc.
similarly for lists we have generic components such as append prepend access concat lengthandsoforth.forgraphs wehavecomponentsthat representemptygraphsaswellasoperationsthataddnodesand edges see table .
since our framework is fully extendable the user can apply singularity to programs that take custom data types byprovidingnewcomponentsthat operate over .
parameter tuning.
as mentioned earlier genetic programming algorithms have many tunable parameters such as population size tournament size threshold and cost penalty factor used in thefitnessfunctionetc.unfortunately theseparametersareoften hard to configure manually due to the complex dynamics of genetic programmingand the intricate interactionbetween different parameters.toaddressthisproblem wedevelopedanautomatic parameter generator which samples these parameters from a joint distribution.
when we run singularity multipletimes ona problem wealwaysusedifferentparametersetssampledfromthisjoint distribution.inourexperience thisstrategyincreasesthelikelihood thatsingularity willfind the desiredworst case pattern.
evaluation toevaluate the usefulnessof singularity we designa series of experiments that are intendedto address the following questions issingularity useful for revealing the worst case complexity ofagiven program?
howdoes singularity comparewithstate of the arttesting toolsthat addressthe same problem?
218singularity pattern fuzzing for worstcasecomplexity esec fse november4 9 lake buena vista fl usa table evaluationon textbook algorithms.
algorithm name best case worst casefound worst?
optimized insertion sort n n2 quick sort nlogn n2 optimized quick sort nlogn n2 wayquick sort nlogn n2 sequential search n binary search logn binary search treelookup n red black treelookup logn separate chain hashlookup n linear probing hashlookup n nfaregex match m n mn booyer mooresubstring m n mn primminimumspanningtree v e elogv bellman ford shortest path v v e dijkstra shortest path elogv alternating pathbipartite v v v e hopcroft karp bipartite v e v issingularity useful for detecting algorithmic complexity vulnerabilitiesandperformance bugsinreal world systems?
unless stated otherwise experiments are conducted on an intel xeon r computer with an e5 v3 cpu and 64g of memory running onubuntu16.
.
.
asymptoticboundanalysis inthissection weevaluate singularity onstandardalgorithms such as sorting searching graph algorithms and string matching that are taken from a widely used algorithms textbook by sedgewick and wayne .
the goalof this experiment is to determinewhether singularity can identify the worst caseasymptotic complexityofthesealgorithms.
toensurethe benchmarksare nontrivial we onlyfocusonalgorithms whose worst case running time is known to us and is differentfromtheirbestcases.basedonthesecriteria weobtain a total of algorithms.
for each of them we run singularity foratotaltimeof3hoursandrestartfuzzingwithadifferentrandom seed whenever the fitness has no improvement for more than 150generations.finally we determineworst casecomplexitiesby using input patternsthat maximize resource usage at size n .
theresultsofthisexperimentaresummarizedintable .the first three columns of this table provide the name of the algorithm along withits corresponding best caseand worst case asymptotic performance and the final column shows whether singularity is abletotriggertheexpectedworst casecomplexity.todetermine whether a pattern s worst case complexity has been found we measure its performance at different input sizes and try to fit a linearrelationshipbetweenthetheoreticalworst caseperformance and the actual performance.
if the data show a linear trend and the r2metric is greater than .
we conclude that singularity is ableto generateinputswiththe desiredworst case complexity.
aswecanseefromthistable singularity cantriggertheworstcase behavior in of the cases.
for the hopcroft karp bipartite matching algorithm the inputs generated by singularity trigger o v e complexityratherthantheexpected o e v complexitybecause the worst case pattern cannot be represented using our standardsetofgraph componentslistedintable .
.
comparisonagainst wise toexplorehow singularity comparesagainstothercomplexity testingtechniques weperformacomparisonbetween singularity andwise .unlikesingularity wiseisawhite boxtestingtool based on dynamic symbolic execution.
specifically wiseproceeds in two phases in the first phase it performs exhaustive search onsmallinputstolearnso called branchpolicygenerators which exerciseworst caseexecutionpaths.inthesecondphase wiseuses the output of the first phase to prune program paths that do not conform to the learntbranchpolicygenerator.
we perform this experiment on the benchmarks that are used for evaluating wise .
we give both tools a time limit of three hours and compare the performance of each benchmark on the inputsgeneratedby singularity andwise.specifically we train wiseon the same training size reported in their paper and use both tools to generate inputs up to size nforn .
specifically we use n 30tomatch thevalue used intheoriginal wisepaper.wealsoreport n 500andn 1000todemonstrate the advantagesofour approach over wise.
the results of this experiment are summarized in table .
here thesymbol indicatesthatthetoolfailedtogenerateanyinputs withinthe3hourtime limit.otherwise thenumberindicatesthe worst case performance in terms of instruction count of the algorithmoninputsgeneratedbyeachtool.
themaintake awayfromthisexperimentisthat singularity andwisetrigger roughly the same performance behavior in all caseswhere wisedoesnottimeout i.e.
generatesaninputwithin the hour time limit .
however as we increase the value of n wisefails to generate inputs on more and more benchmarks.
in particular wisecantriggertheworst casebehavioron8outofthe benchmarks for n but this number drops to for n andto3for n .specifically wisefailstogenerateanyinputs for large values of nbecause all paths explored by the concolic executionenginewithinthetimelimitareprunedbythegenerator meaningthat wisefailstofindanyinputsthatcantriggerworstcasebehavior.incontrast bylookingforinputpatternsratherthan concrete inputs singularity can scale to much larger values of n. .
comparisonagainst slowfuzz inournextexperiment wecompare singularity againstslowfuzz astate of the artfuzzingtoolforfindingavailabilityvulnerabilities.
similar to our approach slowfuzz performs resourceusage guided evolutionary search but generates concrete inputs as opposedto inputpatterns that maximizeresourceusage.
wecompare singularity withslowfuzz intermsofscalability andthequalityof thegeneratedinputs.similartosection .
we assess scalability by running each tool on increasing input sizes rangingfrom 64bytes to 2kbytes.
toevaluate the qualityofthe results werunbothtools30timeswitha2 hourtimelimitforeach runand compare the largestresource usageobtained byeachtool.
to reduce the time required to perform this experiment we run both tools on an hpc cluster with intel xeon phi cpu cores at .4ghz and96gram running centos6.
.
219esec fse november4 9 lake buena vista fl usa jiayiwei jia chen yu feng kostasferles andisildillig table worst casenumberofinstructionsexecuted on the wisebenchmarks benchmarksize size size wise singularity wise singularity wise singularity sortedlistinsert heap insert jdk .
redblacktreeinsert quicksort jdk .
binarysearchtreeinsert mergesort jdk .
bellman ford adjacency matrix .
.
dijkstra adjacency matrix .
travelingsalesman symbol indicates thatthe tool fails to produceany inputswithin3hour.
fuzzingsizeusageratio geometricmean weightedgeometricmean figure comparison against slowfuzz .the usage ratio represents the ratio between the worst case resource usage found by singularity and byslowfuzz .
thebenchmarksforthisexperimentincludethosereportedin theslowfuzz paper which consist of several sorting algorithms ahashtableimplementationfromphp 19regularexpressionmatchingproblems andaziputilityfromthe bzip2application.
we do not use the bzip2example in our evaluation since the vulnerability is triggered only when certain bits in the input file header are set hence this benchmark is not related to the input pattern generationproblem addressedinthis paper.
since this experiment involves benchmarks and different input sizes we report the aggregate results for each size.
for each benchmark bandsizen weuseinputs iandi generatedby singularity andslowfuzz to compute the usage ratio rn b rn b b i b i where b i denotes the running time in terms of instruction count of benchmark bon input i. observe that rn b 1indicates that inputsgeneratedby singularity take longer to run.
toaggregateoverallbenchmarksforeachinputsize weconsider twodifferentmetrics geometricmean foreachinputsize sandbenchmarks b1 ... bk we compute the geometric mean denoted gm rn b1 ... rn bk of ratiosrn b1 ... rn bk.
weightedgeometricmean sincetheusageratio rn biscloseto forabouthalfofthebenchmarks thegeometricmeandoesnotconveythefullstory.instead wewant toassignasmallweight tocaseswherebothtoolshavesimilarperformance andassigna larger weight when there is a significant performance difference.
hence wealsocomputethefollowing weightedgeometricmean5 wgm rn b1 ... rn bk exp parenleftbig summationtextk i 1ln rn bi summationtextk i 1ln rn bi parenrightbig the results ofthiscomparison are summarizedinfigure .we can observe two main trends based on this figure first singularityis able to generate inputs that cause the applications to run significantlylongerwithinthetimeframe showingthat singularityismore efficient than slowfuzz in terms of fuzzing efficiency.
second theperformanceratiosgrowas nincreases showingthat singularity scales better compared to slowfuzz .
hence these resultshighlightthescalabilityadvantageofpatternfuzzingover concrete inputfuzzing.
.
availabilityvulnerabilitydetection to demonstrate that singularity can generate inputs that exercise non trivial algorithmic complexity vulnerabilities we evaluate singularity on ten benchmarks taken from the darpa stac program.
specifically we choose exactly those benchmarks that a exhibitanavailabilityvulnerability and b whereitispossibleto constructan exploit using amalicious inputpattern.
in more detail each stac benchmark is a java application containing between to lines of code.
furthermore each benchmarkcomeswithapre definedinputbudget bandatarget running time t and the goal is to craft an attack vector that causes the running time ofthe application to exceed tusing an inputof size at most b. table3provides more detailed information about thesestac benchmarks.
toperformthisexperiment werun singularity foratotalof3 hoursoneachbenchmark.bydefault weuseafuzzingsizeof1kb unless the specifiedinputbudget bissmaller.
as summarized by the results in table singularity is able to generate the desired attack vector for out of these benchmarks.tounderstandthelimitationsof singularity wemanually 5likethegeometricmean thismetricisfairbecauseifweswitch singularity and slowfuzz i.e.
replace rn biwith1 rn bifor alli wgm rn becomes1 wgm rn .
many othercommon averaging functions e.g.
arithmeticorquadraticmean donot havethisproperty.
220singularity pattern fuzzing for worstcasecomplexity esec fse november4 9 lake buena vista fl usa table evaluationon stac benchmarks.
benchmark description inputtype dslused inputbudget target time av found?
blogger bloggingwebapplication url string 5kb 300s graphanalyzer dot to png ps converter dot file graph 5kb 3600s imageprocessor image classifier png file array 70kb 1080s textcrunchr textanalyzer textfile string 400kb 300s linearalgebra matrixcomputation service matrix array .25kb 230s airplan1 online airline scheduler graph graph 25kb 500s airplan2 online airline scheduler graph graph 25kb 500s airplan3 online airline scheduler graph graph 25kb 500s searchableblog webpage search engine matrix array 1kb 10s braidit1 online multiplayergame string string 2kb 300s investigate thosebenchmarks for which singularity fails to find an attackvector.
fortextcrunchr therootcauseoftheproblemistheempirical measurementmodel.inparticular singularity evaluatesthefitness of an individual based on its performance on inputs at size 1kb butthis ismuch smaller than theinput budget of 400kband results in sub optimal patterns.
while we could circumvent this problembyusingamuchlargerinputsize thatwouldsignificantly increase the time to evaluate the fitness of a given input pattern thereby slowing downthe fuzzingalgorithm.
forairplan3 the evaluationtime takestoo long.during fitness evaluation running the application on an input of size 1kb can take more than minutes and as a result singularity fails to convergeto the fittest pattern within the hourtime limit.
.
performance bug detection to evaluate whether singularity can help with discovering unknownperformance bugs in real world projects we run singularityon three popular java libraries namely google guava vavr andjgrapht .alloftheselibrarieshavemorethan 1000starsongithubandareusedbymorethan70otherprojects on maven central.
hence any performance issue in these libraries islikely to have significant real world impact.
foreach library we identifyaset ofpublicapis relatedtocontainer operations or graph algorithms and write driver code to invoke these apis using inputs generated by singularity .
we thenusetheinputpatternsgeneratedby singularity todetermine worst case complexities by a generating inputs of different sizes and b fitting a curve through these data points.
if the complexity obtained by singularity is worse than the expected worst case wereporttheanomalytodevelopersandletthemconfirmwhether this isaperformance bug.
usingthismethodology weidentifiedfive previouslyunknown performance bugs all of which have been confirmed by the developers.
in what follows we include brief descriptions of the performance problems uncoveredby singularity performance bugs in guava.
singularity identified two performancebugs in the immutablebimap andimmutableset container classesintheguavalibrary.bothoftheseclassesprovideamethod calledcopyofthatreturnsan immutablebimap orimmutableset thatcontainsthesameelementsastheinputcollection.whileboth ofthesecopyofmethodsareexpectedtotakelineartime theinputs generated by singularity causeo n2 performance.
in particular table graph related components signature description emptygraph createan empty graph addn add anewnodeto the graph adde v add a new edge with two new vertices and edgevalue vto the graph growe v i add a new edge with one endpoint being an existingnode i growloop v i add anewselfloop to an existingnode i bridgee v i1 i2 add an edgebetween twovertices i1 i2 deletee i delete the ithedgefrom graph mergegraph 1 2 mergetwographs into onegraph updateevalue v i updatethe ithedge svalue in graph addcompleten v add a new node then connect it to all existing nodes withedgevalue v singularity triggers this worst case behavior by causing hash collisionsdespitetheexistenceofamechanismthattriestoprotect against hash collisions.the inputsgeneratedby singularity are complexenoughtobypasstheseexistingmitigationmechanisms.
thedetails includingthebugreportandinputpatternsdiscovered are explainedin singularity sdocumentation .
performancebuginjgrapht.
singularity identifiedaserious performancebuginthejgraphtimplementationofthepush relabel maximum flow algorithm .
while the theoretical worst case behavior of this algorithm is o n3 singularity is able to find inputsthattrigger o n5 runningtime.thispatterncorrespondsto an rcg with internal states and output states as shown below andwhere the componentsemantics are listedintable i addnode emptygraph f1 plus s1 f2 growe bridgee growe s2 inc s1 s1 o s2 performancebuginvavr.
singularity alsoidentifiedtwoperformanceproblemsinthevavrlibrarythatprovidesimmutableand persistent collections.
in particular while the addallandunion methods of linkedhashset are supposed to have worst case linearcomplexity singularity foundinputsthattriggerquadratic behavior.
the developers have acknowledged this issue and added acaveattothecorresponding javadocsthatthesemethodshave quadratic ratherthanthe expected linearcomplexity.
221esec fse november4 9 lake buena vista fl usa jiayiwei jia chen yu feng kostasferles andisildillig .
threatsto validity randomness.
sincesingularity leveragesrandomizedalgorithms its performance can be affected by various factors like parameter sampling and individual selection.
hence our results may be skewedbyunusuallyluckyorunluckyruns.tomitigatethisconcern we run singularity as well as slowfuzz multiple times andconsiderthe bestresult acrossallofthese.
benchmark selection.
due to their own technical limitations we are not able to run slowfuzz andwiseon a common set of benchmarkprograms.instead wecompare singularity againstslowfuzzandwiseseparately on their own benchmarks.
while a commonbenchmarksetforalltoolsmayprovideamorecomprehensive view we believe our comparison is sufficient for showing the strengths andweaknessesofthesetechniques.
limitations generality.
whilethe singularity frameworkcanbeapplied to many different programs it requires the user to provide suitable componentsthatoperateovertheinputtypeofthetargetprogram.
singularity already comes with a library of components for standarddatatypes e.g.
integers lists graphs buttheuserneedsto provideadditionalcomponentsfor customdata types.
drivercode.
whilesingularity supportsawiderangeofcommonlyuseddatatypes itexpectstheusertowritedrivercodeto translate these dsl data structures into the format accepted by the targetprogram.althoughthiskindoftranslationnormallyrequires littlemanualeffortandcanevenbeautomated sometargetapis only accept inputs with special property or of special format.
in such cases to improve fuzzing efficiency additional effort from the usermay beneededtointegrate such domainknowledge intothe driver code.
related work testing for performance.
there is a long line of work on automatedtestingtechniquestouncoverperformanceproblems .amongthesepriortechniques wiseisthefirst one to introduce the complexity testing problem where the goal is to determine the complexity of a given program by constructing test cases that exhibit worst case behavior.
at a high level wiseuses an optimized version of dynamic symbolic execution to guide the search towards execution paths with high resource usage.
while wiseis a white box testing technique our approach ispurelyblack box andcan scaleto larger inputsizes.
fromatechnicalperspective perfsyn ismoresimilartoour approach in that it uses black box evolutionary search to generate teststhatcauseperformancebottlenecks.specifically perfsynstarts withaminimalusageexampleofthemethodundertestandapplies a sequence of mutations that modify the original code.
however a key difference is that perfsynfocuses on performance bottlenecks related to api usage whereas our approach focuses on finding inputpatterns that trigger worst case complexity.
another idea related to performance testing is empirical computationalcomplexity .inparticular goldsmithetal.propose a technique for measuring empirical complexity by running the program on workloads spanning several orders of magnitude insizeandfitting theseobservationstoa modelthatpredictsperformance as a function of input size.
since this technique requires the user to manually providerepresentative workloads our approach iscomplementary to theirs.
performance bug detection.
as argued earlier in section 1and demonstratedthroughourexperiments singularity canbeuseful for uncovering performance bugs.
in this sense our technique is relatedtoalonglineofworkonperformancebugdetection 23 .mostofthesetechniquestargetnarrowclassesofperformance problems such as redundant traversals loop inefficiencies andunnecessaryobjectcreation .comparedto these techniques singularity can to detect a broader class of performancebugsbutrequirestheusertodecidewhetherthereported worst case complexitycorrespondsto aperformance bug.
algorithmiccomplexity vulnerabilities.
recently there hasbeen significant interest in automated techniques for detecting algorithmic complexity ac vulnerabilities .
some of these techniques target a specific class of vulnerabilities such as thoserelatedtoregularexpressions .amongapproachesthat target a broader class of ac vulnerabilities slowfuzz is most closelyrelatedtoour approach.inparticular slowfuzz alsouses evolutionary search for generating inputs but performs mutations atthebytelevel.incontrast ourmethodlooksforinputpatterns rather than concrete inputs and can therefore scale better when large inputsizesare required.
asymptotic complexity analysis.
sincesingularity can be used todetermineworst casecomplexity itisrelatedtostatictechniques foranalyzingtheasymptoticbehaviorofprograms .
our approach is complementary to static techniques in that wecangenerateconcreteinputsthattriggerworst casebehavior.
for instance our method can be used to validate the complexity bounds reported by a static analyzer and help programmers debug performance problems.
conclusion we have presented a new black box fuzzing technique for generating inputs that trigger worst case performance of a given program.
the key idea underlying our method is to look for input patterns ratherthanconcreteinputsandformulatethecomplexitytesting problemintermsofoptimalprogramsynthesis.specifically express inputpatternsusingrecurrentcomputationgraphsandusegenetic programmingtofindanrcgthatresultsinworst casebehavior.
ourexperimentsdemonstratetheadvantagesofourapproachcomparedtoothertechniquesandshowthatourmethodisusefulfor a finding worst case asymptotic complexity bounds of interesting algorithms b detectingavailabilityvulnerabilitiesinnon trivial programs and c discovering previously unknown performance bugsinwidely usedjava libraries.