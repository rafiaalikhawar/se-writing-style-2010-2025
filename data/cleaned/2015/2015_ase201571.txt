general ltl specification mining caroline lemieux dennis park ivan beschastnikh department of computer science university of british columbia caro.lemieux gmail.com emaildpark gmail.com bestchai cs.ubc.ca abstract temporal properties are useful for describing and reasoning about software behavior but developers rarely write down temporal specifications of their systems.
prior work oninferring specifications developed tools to extract likely programspecifications that fit particular kinds of tool specific templates.
this paper introduces texada a new temporal specification mining tool for extracting specifications in linear temporal logic ltl of arbitrary length and complexity.
texada takes a userdefined ltl property type template and a log of traces asinput and outputs a set of instantiations of the property type i.e.
ltl formulas that are true on the traces in the log.texada also supports mining of almost invariants properties with imperfect confidence.
we formally describe texada s algorithmsand evaluate the tool s performance and utility.
i. i ntroduction specifying and reasoning about the temporal behavior of programs has been extensively studied .
one relatively recent idea is to mine a set of traces generated by a program to derive likely temporal specifications of the program an api or some other aspect of the software .
for example consider figure which listsa set of traces modeled after the var log secure.log file in osx.
these traces satisfy the temporal property guest login is always followed by authorized which indicates that either the guest account has no password or guest logins always succeed.
mined specifications cannot replace manually written specifications created by an expert since a property mined from program traces could be a false positive1.
nevertheless as many programs lack formal specifications mined specifications are valuable and have been shown to be useful for a wide assortment of tasks such as testing malware detection data structure repair supporting program evolution and debugging .
we present texada a tool that implements algorithms to mine linear temporal logic ltl properties of arbitrary length and complexity.
note the property guestlogin is always followed by authorized mined from the log in figure can be expressed in ltl as g guest login xfauthorized .
unlike prior specification mining tools that extract a specific set of pre defined templates texada mines specifications described by an arbitrary user defined ltl template and can mine specificationsthat satisfy user defined support and confidence thresholds.
while it is unclear how to adapt prior miners to extract new patterns such as the cause effect precedence chain between two events pprecedes s tbetween qand r texada handles this pattern and all other ltl based patterns by design.
we show that texada s property types are sufficient to 1the property guest login is always followed by authorized would be a false positive if a guest login in which the guest mistyped her password and failed to authenticate is missing from the log.login attempt auth failedlogin attemptauth failedlogin attemptauth failedlogin attemptauthorized login attemptauth failedlogin attemptguest loginauthorizedlogin attemptguest loginauth failedauthorized log property type texadatrace trace trace trace property instances or always followed by g x xf y g guest login xfauthorized x y fig.
top example inputs to texada including an authentication log and a property type.
bottom texada s mined property instances output a set of ltl formulas based on the property type input template that evaluates to true on each trace in the input log.
capture both existing temporal specification taxonomies like in perracotta and dwyer et al.
as well as specification templates used in custom built miners like synoptic .
texada can also mine almost invariants or temporal properties that are falsified at some but not all locations in the input traces.
texada provides two controls for this the confidence threshold allows a user to control the degree to which a mined property can be violated and the support threshold allows a user to control the minimum number of times that a property was validated.
for example if aalways followed by b is mined from a log the user may interpret this property differently depending on its support i.e.
the number of aevents in the log the more aevents there are the less likely that a always followed by b is true by chance.
more concretely the property g guest login xfauthorized in figure has confidence of on each trace in the figure but a support of on traces and and a support of on traces and .
as another example the property fauthorized eventually authorize appears in the trace has confidence of .
over the entire log.
texada allows users to specify the support and confidence thresholds that all mined properties must satisfy.
mining of almost invariants is supported by other specification miners .
our contribution is the generalization of the calculation of these statistics to arbitrary ltl properties.
texada takes two inputs figure log at e x tfi l e containing multiple traces where each trace is a totally orderedsequence of string events and property type an ltl formula whose atomic propositions are variables.
texada s output is a set of ltl formulae or property instances that are instantiations of the input property type.
in a property instance the variable atomic propositions in the property type are replaced with eventsfrom the log.
texada guarantees that for the given support and confidence thresholds every returned property instance is valid on each of the input traces in the input log and it returns all valid property instances of the input property type.
30th ieee acm international conference on automated software engineering .
ieee our work makes the following contributions we present two algorithms a linear miner and a map miner for mining arbitrary ltl specifications from logs of program behavior.
we also present an algorithm to compute support support potential and confidence statistics of arbitrary ltl properties.
these algorithms are implemented in the texada tool which is released as open source and includes ready to use property types from .
we evaluate texada s performance and show that it outperforms the specialized temporal property miner in synoptic .
texada runs in seconds on logs with hundreds of execution traces with each trace containing thousands of events.
we evaluate texada s utility by using it to mine patterns from a log of website activity studied by two previoustools .
we find that texada generated propertyinstances are concise and help to focus attention on therelevant properties with particular structure.
we use texada to confirm expected properties of a solution to the sleeping barber problem .
and we combine texada with daikon to infer likely data temporal properties.
ii.
f ormal background we begin by formally describing what we mean by a log a trace and an event.
definition log trace and event .the alphabet of events is a finite alphabet of strings.
an ordered sequence of events is a trace and a set of traces is a log.
we use the term event variable to denote a place holder for an event.
in this paper we use the beginning of the alphabet to denote events e.g.
a b c and the end of the alphabet to denote event variables e.g.
x y z .
we use linear temporal logic to compactly specify specification templates which we call property types.l t l statements assert certain conditions over time and use the operators until u next x eventually f always g weak until w release r and strong release m .
in this paper ltl will refer to a restricted version of propositional temporallogic pltl in which the non temporal parts of formulae are built from atomic propositions and the usual logic operators and .
we define ltl formulae in a manner similar to emerson .
definition ltl formula .an atomic proposition p i sa n ltl formula.
if pand qare ltl formulae so are p q p puq and x p. we can then define all other logic operators like and .
any non temporal formula is true on a trace if it is true on the first event of the trace.
the other temporal operators follow until puq holds if there is an event in the trace where qholds and if pis true on all events up to the first event where qholds.
next xp holds if pis true on the event immediately following the trace s first event.
finally eventually fp true up holds if there exists a future event in the trace where pis true.
globally always gp f p holds on a trace if pholds on all events in the trace.
the operators w r and mare variations of until and are defined as in .
standard ltl semantics assume an infinite sequence of events.
since texada mines specifications fromfinite traces we redefine the ltl semantics to fit our context see end of this section .
a property type captures the temporal relationships between a set of event variables and optionally a set of events.
definition property type .aproperty type is an ltl formula in which all of the atomic propositions are either event variables or events.
for example the property type g x xfy represents the xis always followed by y relationship between xand y. referring to events in a property type allows us to amongst other things establish scope.
for example if we are interested in expressing xis always followed by y between open file denoted of and close file denoted cf then we can use these events in the property type to create a scope as in g of cf fcf x cf u y cf ucf a property instance corresponds to a property type and has identical ltl structure but with each event variable in the property type replaced by an event.
following beschastnikh et al.
we call the map which associates each variable with an event a binding.
for example a property instance of the xis always followed by y property type in a program trace may be open file is always followed by close file i.e.
g open file xfclose file .
definition property instance .let be a property type.
then is a property instance of or an instantiation of if is an ltl formula that is identical to in structure and in which all of the atomic propositions are events.
definition binding .let ebe an alphabet of events and letvbe a finite set of event variables.
then a binding2is a function b v e. applying a binding to the variables in a property type creates a property instance corresponding to that binding applying x open file y close file tog x xfy creates the property instance g open file xfclose file .w e use property in place of property instance and property type when the context makes it clear which one we mean.
we say that a binding and its corresponding property instance are valid on a log if the property instance holds on each trace in the log.
generally we are interested in mining all of the valid property instances.
but we may also be interested in those instances that are most likely e.g.
because a log is incomplete or contains anomalous or buggy executions .
to help with these cases we generalize the notion of validity.
definition trace support potential .the support potential of a property instance on a trace tis the number of time points of twhich could falsify .
definition trace support .the support of a property instance on a trace tis the number of time points of twhich could falsify b u tdo not falsify .
to explain these further consider checking ga on some trace.
one way to do this is to iterate along the trace and check whether the event at each position is a. if at any time point ais found to be true gais falsified.
therefore for ga 2a binding may bind multiple variables in vto the same event.
this may produce trivial results for example g x fy a common formulation of always followed by is true any time xand ybind to the same event.
this is why in this paper we use xf yinstead of f y i.e.
g x xfy .
functiontexada property type string prop s log l thresholds t returns valid property instances of prop sonl.
letvalid instances prop parse property type prop s traces parse log l for binding ingen binding prop.vars traces.events prop instance instantiate prop binding valid check prop instance traces t if valid valid instances.add prop instance return valid instances fig.
a high level description of texada.
the two versions of the check function line are listed in figures linear miner and figure map miner .
the evaluation of aat each position in the trace is potentially falsifiable.
so the support potential for this property instance is the length of the trace and its support is the number of positions in the trace at which aappears.
in general the number of falsifiable time points depends on both the structure of the property instance and the sequence of events in the trace.
we elaborate further on falsifiable time points in section iv a. we use trace confidence to denote the ratio of trace support to trace support potential if both are confidence is .
a confidence of means that the instance is not falsified at any time point.
we say that a property instance is vacuously true if its support and support potential are both .
the global support and global support potential of a property instance is the sum of its support support potential over all traces in the log global confidence is the ratio of global support to global support potential.
we use the terms support support potential and confidence when it is clear from the context if we mean the trace based or global versions.
we can now formulate texada s objective.
texada takes as inputs a log a property type and support support potential and confidence thresholds3.
texada outputs a set of property instances such that each instance has support support potential confidence greater than or equal to the corresponding threshold.
finite trace semantics.
to check a property on a finite trace we effectively transform the finite trace into an infinite trace by appending an infinite sequence of terminal events .
this extension defines exactly the infinite trace we are checking on so more advanced adaptations of ltl to finitetraces are not necessary .
for many property types this extension does not affect the validity of the property instances.for example consider checking ais immediately followed by b g a xb on a finite trace which ends in a. adding s to the end of this trace does not change the invalidity of this property instance on that trace is band immediately follows aso the property remains invalid.
however texada evaluates gato true on a finite trace consisting solely of a events.
this is despite the fact that on the extended trace i.e.
aa...a ... gadoes not hold.
it this case texada checks au instead of ga. effectively texada determines the validity of the property instances before .
instead of requiring the user to incorporate this additional bound into the property type texada implicitly evaluates the property type as if it contained the bound.
3when these thresholds are omitted texada uses the default confidence threshold of and support and support potential thresholds of .
the user may specify the trace or global versions of each of these three thresholds.iii.
t exada design overview figure lists the pseudocode for texada s algorithm.
we overview the design behind this code and then explain texada s two property checking algorithms in sections iv and v. representing a property type.
texada parses an input property type into a tree structure whose leaves are atomic propositions line of figure .
figure c shows an example of such a tree.
texada traverses this tree when checking the validity of a property instance.
this style of checking contrasts with other pattern mining tools that use automata to represent temporal properties e.g.
.
critically we use the tree representation to memoize and re use evaluation results see section vi .
since the sub trees of two different property instances may be identical the memoization significantly speeds up the checking of many potentially thousands of similar property instances.
representing a trace.
texada parses each input trace into one of two representations line of figure a linear array form or a map form in which each event is mapped to a sorted list of trace locations where the event appears.
for example the linear form of the trace a a b bis .
its map form is a b .
the map form allows the property checking algorithm to avoid traversing sections of the trace that do not contain relevant events.
representing the space of property instances.
in line of figure texada iterates over the set of property instances represented by bindings of variables vto events e .
texada considers all possible bindings4 or the space of all v element permutations of e. texada generates instantiations dynamically which bounds space usage.
checking property instances over traces.
finally texada checks the validity of each property instance on all traces in the log line figure before moving on to the next instance.
thecheck function on line has two variants one for each of the two trace representations linear map .
iv .
l inear miner a natural way to evaluate a property instance on a linear trace is to iterate over the trace and recursively evaluate each operator according to its semantics section ii .
the core section of this linear checking algorithm is listed in figure .
we describe the algorithm by checking a property instance on trace in figure .
the linear trace representation is listed in figure a and the property instance we will check is authorized wguest login g guest login xfauthorized this is the guest login always followed by authorized property with the added restriction that authorized cannot occur before guest login the causefirst pattern in table i .
internally texada represents this property as a tree figure c and checks this property instance by traversing this tree.
the root of the tree is to check it we check its children on the first event of the trace see figure lines .
left sub tree of to check authorized wguest login we follow the checking code for uin figure lines but aswis a weak until we will return true on line .
we begin 4texada explores the space of permutations generated without replacement by default and has a flag to consider permutations with replacement.
functioncheck linear property instance prop trace t returns true if prop holds on t false otherwise.
operations that do not require trace traversal if prop isevent return t.first event prop else if prop p q returncheck linear p t check linear q t else if prop p q returncheck linear p t check linear q t else if prop p return !check linear p t operations that require trace traversal else if prop x p if t.first event .is terminal this creates the infinite sequence of terminal events.
returncheck linear p t returncheck linear p t.next event else if prop g p if t.first event .is terminal return true returncheck linear p t check linear prop t .next event else if prop puq if t.first event .is terminal if we get here we have not seen q need q to occur for until to hold.
return false else if qholds on t return true else if pholds on t return false here p and !q hold so we need to look for a !p or q further down the trace.
returncheck linear prop t.next event fig.
a section of the linear checking algorithm.
traversing the linear representation of the trace in figure a at the first event which is login attempt .
since this does not evaluate to true on guest login nor on authorized we check authorized wguest login on the next event.
here we return true because guest login has been reached without violating authorized.
right sub tree of in general to check gpwe must check pon each event in the trace figure lines recursing until pis found or the trace ends.
the implication operator p qworks like p q short circuiting if pis found.
so to check g guest login xfauthorized we recurse down the trace.
when we reach guest login we need to check the implication xfauthorized .
at this point the xoperator takes a step along the trace.
then checking fauthorized involves stepping down the trace once more until we find authorized .
we find it at position and return that xfauthorized holds.
continuing we find the gsub property is not violated and the full property holds on this trace it does not hold on the log in figure as it is violated in trace .
boolean operators omitted from figure such as the and are implemented by combining the results of checking pand qwith the corresponding operator as with the other boolean operators.
evaluation can short circuit on and operators.
the woperator evaluation is identical to uexcept that it evaluates to true in the base case.
in both the linear miner and the map miner section v we take special care to check property types at the end of the trace to satisfy the finite trace semantics see section ii .
most operators have a simple boolean base case for the terminal event .
the next operator xp requires a more extensive basew g guest login authorized guestlogin authorizedx f1 login attempt guest login auth failed authorized login attempt guest login auth failed authorized a b c fig.
a linear and b map representations of trace from figure .
c syntactic tree for property authorized wguest login g guest login xfauthorized .
case since evaluating xpon requires evaluating pon creating the appearance of an infinite trace .
this evaluation terminates because the formula tree for any pis finite thus texada will eventually reach an event at a leaf node whose checking does not recurse.
a. computing support and support potential the linear miner returns property instances that are never falsified.
we now describe an algorithm to calculate the trace support for a property instance.
interestingness measures of temporal properties have been considered previously .
however these measures were restricted to property types of theform ais always followed by b o r aalways precedes b or nested variations of these.
texada computes an approximation of support and support potential for arbitrary ltl formulae whose definitions are not captured in this previous work.
figure lists the pseudocode for the support algorithm5.i t has the same recursive structure as the linear mining algorithm in figure but instead of combining boolean values the calculation in the recursive call combines counts.
the support potential algorithm not shown for space reasons deviates from the support algorithm in figure at the atomic propositions support returns at satisfied falsifiable time points while support potential returns at alltime points.
key challenge equivalence of p qand p q.note that the support calculation for in figure differs significantly from figure .
this is because the equivalence of p qand p qis central to our notion of falsifiability.
for example we would like the support of ais always followed by b g a xfb to be the number of time points at which aoccurs and is eventually followed by b and the support potential to be the total number of time points at which aoccurs.
for this formula the absence of adesignates a falsifiable time point.
however since a formula like g a b can be re written asg a b org b a it is unclear which side of the implication should determine falsifiability.
the algorithm uses a helper function called interval not listed which takes a proposition and returns the intervalon which this proposition must be checked.
this function returns the interval containing only t.first event on atomic propositions the interval from t.first event to the terminal 5in our implementation the algorithm for linear property instance checking is bundled with support and support potential calculation.
we explain them separately to simplify our presentation.
functionsupport instance prop trace t returns the number of atomic proposition evaluations on twhich could have falsified prop on which prop was satisfied if prop isevent if t.first event prop return return else if prop p q if a child with an earlier interval is satisfied then the property instance is vacuously true if interval p t interval q t if qissatisfied byt return returnsupport p t else if interval p t interval q t if pissatisfied byt return returnsupport q t else if both pand qare satisfied byt return else if support p t support q t returnsupport p t returnsupport q t else if prop p if t.first event !
p return return else if prop gq if t.first event .is terminal return returnsupport q t support prop t.next event else if prop fq if t.first event .is terminal return else if qholds ont returnsupport q t returnsupport prop t.next event else if prop xq if t.first event .is terminal return returnsupport q t.next event fig.
a section of the support calculation algorithm.
event on g f u the interval of x s child node in the formula tree pushed by one on x and the union of the interval of the children of and on these operators.
an interval iis smaller than another interval jifiand jare disjoint and ioccurs first.
getting back to the always followed by example g a xfb since the interval for ais strictly before the interval for xfb we execute lines in figure and return the support of xfb .
here the algorithm approximates which side s falsification indicates a falsifying time point by comparing the temporal order of each side given by the interval calculation.
the other operators are simpler.
the support of gpis the sum of support of pat each event.
property instances are in negative normal form6 s ot h e pevaluation treats pas an atomic proposition.
the operators not listed for space reasons correspond in structure to the linear checking algorithm.
overall the linear miner and support support potential algorithms have a simple recursive structure.
next we describe the map miner which was designed to reduce linear scanning over traces and reduce redundant computation.
v. m ap miner the map miner uses the map trace representation e.g.
figure b .
the map based property instance checker leverages a key property of ltl an ltl formula describes the sequence of events relative to each other.
the map checker therefore 6prior to calculating support texada converts property instances into negative normal form pushing the logical not operators to the leaves.
functioncheck map property instance prop index i returns true if prop holds starting at i false otherwise.
omitted boolean connectives and operators f r. if prop x p special case for the end of the trace.
if i omega pos returncheck map p i else move forward and check p returncheck map p i if prop g p fi r s t not p first occurrence p if !p never occurs g p holds.
if fi r s t not p false return true return false if prop puq find q. fi r s t q first occurrence q if q never occurs until does not hold.
if fi r s t q false return false fi r s t not p first occurrence p if !p never occurs until holds.
if fi r s t not p false return true make sure !p did not occur before q. if fi r s t not p fi r s t q return false return true fig.
a section of the map miner checking algorithm.
can skip over the trace between the relevant events using the map trace representation .
as we will show in section vii b this makes the map checker much more efficient than the linear checker especially on long traces.
the miner is structured as three functions check map firstoccurrence and last occurrence .
each one takes a node in the property instance tree e.g.
figure c and an interval in the trace and then traverses the sub tree rooted at the node.
the check map function figure traverses the tree to implement operator semantics on a node given the validity of the node s sub trees in the trace at certain positions.
this function returns a boolean and evaluates non temporal operators identically to check linear figure lines .
temporal operators are implemented by using the first and last occurrence information provided by the first occurrence and last occurrence functions.
first occurrence figure returns the first position in some interval where a sub formula rooted at a node in the property instance tree evaluates to true or returns false if no such position exists.
for example in lines of figure the check map function evaluates gp at index iin the trace by using the result of first occurrence p .
iffirst occurrence returns false then pnever occurs after i which means that gpis true on this interval otherwise g pis false on this interval.
when first occurrence is called with an event node i.e.
a leaf in the sub tree it runs a binary search on the sorted positions list associated with the event stored in the map trace representation to find the first occurrence of the event in a given interval line in figure .
however first occurrence must also traverse the sub tree when it is called with a non leaf node.
lines in figure detail the case of first occurrence puq intvl first occurrence makes a recursive call firstoccurrence q intvl and uses the returned position in a call tolast occurrence p .
then the first position where puqholds in this interval is the point at which there are no longer any pevents until qor where qoccurs if q functionfirst occurrence instance prop interval intvl returns first index in intvl where prop is true false otherwise.
if prop isevent returnbinary search prop intvl else if prop puq find first position where qis true.
fi r s t q first occurrence q until needs qto occur.
if fi r s t q false return false find the last !
pthat occurs before the first q last not p last occurrence p if !
pdoes not occur before the first q puqholds on the first element of the interval.
if last not p false return intvl .start if the last !
pbefore qis after the end of our original interval puqholds nowhere on that interval.
if last not p intvl .end return false return last not p fig.
pseudocode for a section of the first occurrence function that facilitates the check map function in figure .
is the start of the trace puqholds trivially since there is nowhere for pto occur before q .
we omit last occurrence for space reasons but it looks similar to first occurrence.
returning to the example used in the linear miner description consider checking the same causefirst property instance in figure c .
we check the same trace this time using the map representation listed in figure b .
check map starts at the root node and recursively checks its two children.
left sub tree of to check authorized wguest login we follow figure lines with line returning true for the w operator .
we find the first occurrence of guest login .
then we find the first occurrence of authorized authorized .
since guest login occurs before authorized we return true.
right sub tree of to check g guest login xfauthorized we find the first occurrence of guest login xfauthorized guest login xg authorized .
we do this by finding the first occurrence ofguest login and of xg authorized on our desired interval if they do not co occur we repeat the process on an interval with a later start point.
since both do not occurat one point in the trace we find no first occurrence of guest login xg authorized and find the right sub tree to be true.
both sub trees of are true so the property holds.
vi.
c hecking sta te memoiza tion as texada may check thousands of bindings for a given property type it will check many ltl formulae with similar syntactic trees.
this results in redundant computation.
texada uses memoization to reduce such duplicate computation.
a benefit of the tree representation of property types is that we can re use the result of evaluating one instantiation in evaluating a similar instantiation.
this is possible because two instantiations will frequently have identical sub formulae or sub trees.
for example figure shows two property instances of the property type xis always followed by yafter wuntil z with nearly identical syntactic trees.
the tsub tree in figure corresponds to the sub formula a e u b e we which is common to both property instances.
we have implemented a memoization strategy in the map checker to store the result of evaluating first occurrenceg d e g c e u g w e e e c a b e g ed a tt t b t fig.
a syntactic tree for g c e a e u b e we b syntactic tree for g d e a e u b e we .
the tree on the right differs in a single node left most terminal d node .
therefore we can determine the truth value of the highlighted sub tree by using a memoization of the computation of an identical sub tree that appears on the left.
and last occurrence on a subformula for a given interval.
we started with memoizing these functions as theyare frequently invoked.
we plan to extend memoization toother intermediate checking state in our future work.
our implementation retains memoized state until the mining process completes.
our evaluation in section vii b indicates that on short formulas the memoized state is small compared to that of the input log which must be maintained in memory.
vii.
e v alua tion in this section we show that texada generalizes over prior work section vii a that it is fast section vii b and that it is useful section vii c vii d and vii e .
a. expressiveness of property types our survey of related work indicates that texada property types are sufficient to capture both the various temporal specification taxonomies like in perracotta and dwyer et al.
as well as specification templates used in the numerous custom built miners like synoptic .
perracotta is a tool to mine eight different kinds of temporal properties.
these properties cover common program patterns.
for example perracotta s response pattern represents a pattern in which an action xis followed by a response y. table i lists the property patterns mined by perracotta and the corresponding texada ltl property types.
dwyer et al.
defined a set of ltl specification patterns based on a survey of a variety of specifications.
a specification pattern in their formulation consists of a pattern and a scope over which the pattern must be true.
table ii lists two specification patterns as property types.
all of the specification patterns trivially translate to texada property types.
synoptic is a tool to infer an fsm model from a log of system behavior to support programmer comprehension.
its algorithm relies on the mining of three temporal property types listed in table iii.
these properties have also been used to infer more accurate models in invarimint and csight .b.
performance evaluation we evaluated texada s performance on a machine running bit ubuntu .
tls with 8gb ram and an intel i5 86table i property patterns mined by the perracotta tool and their equivalent property types in texada.
pattern reg.
ex.
ltl response y xx yy g x xfy alternating xy y wx g x x x uy y x y wx multieffect xyy y wx g x x x uy multicause xx y y wx g x xfy g y x y wx effectfirst y xy g x x x uy y x y wx causefirst xx yy y wx g x xfy onecause y xyy g x x x uy oneeffect y xx y g x xfy g y x y wx table ii two example specification patterns from each one demonstrates a different scope.
pattern scope ltl presponds to s t after q g q g s xft x tu t fp never p between qand r g q r fr pur table iii property patterns used in synoptic and their equivalent ltl property types in texada.
pattern ltl always followed by g x xfy always precedes fy y ux never followed by g x xg y haswell quad core .2ghz processor.
texada is implemented in about lines of c depends on the boost library7 and uses the spot library to parse and traverse ltl property types.
for all performance experiments comparing to synoptic we use texada revision a410 .
we first compare texada s linear and map miners against the temporal miner in synoptic which mines the three temporal property types in table iii8.
synoptic mines instances of these property types from the input log and guarantees that they are satisfied in the inferred fsm model.
synoptic is an interesting point of comparison because although it is implemented in java it is highly optimized for mining the three temporal properties.
we were interested to see if texada s general property miners could out perform synoptic s specialized miner.
for a proper comparison these experiments used a confidence threshold of and a support threshold of .
we generated a set of random synthetic logs each with a specific number of traces unique events and trace length.
we ran texada s map miner linear miner and synoptic s miner using the onlymineinvariants option times on each log input and report the average runtime.
we compared the texada miners against synoptic s miner along three dimensions varying the number of traces figure the length of the traces figure and the number of unique events figure .
these three dimensions determine both synoptic s and texada s performance.
the take away from these experiments is that on the three synoptic invariant types in table iii the map miner dominates the linear miner and the synoptic miner.
varying the number of traces figure .
the trace length was held constant at and the number of unique events was held constant at .
synoptic threw an outofmemoryerror at traces.
all three miners exhibit a linear slowdown indicating a fixed performance penalty to processing an 8synoptic is one of the few miners that was available to us for evaluation.additional input trace.
varying trace length figure .
the number of traces per log was held constant at and the number of unique events was held constant at .
this figure is similar to figure in that all miners slow down linearly.
the linear miner hasthe worst performance since each additional event in a trace requires further recursion e.g.
for the goperator for always followed by property in table iii .
varying number of unique events figure .
the number of traces per log was held constant at and the length ofa trace was held constant at .
the linear miner doesespecially poorly with an exponential slow down while the synoptic and map miners have similarly good performance.
the above results indicate that the map miner generally outperforms the linear miner.
this is because the map miner often avoids recursive trace traversal that the linear miner isforced to perform.
however we did find property types on which the map miner performed worse than the linear miner.
we are working to further characterize their relative performance.
varying support and confidence thresholds.
texada s code is optimized for the default thresholds of support of and confidence of .
for example the linear miner can short circuitfurther recursion along the trace for some of the operators .
nondefault support and confidence thresholds disable most of these optimizations.
this is because to calculate the exact support or support potential of a property instance texada must count all possible falsifiable time points.
we found that decreasing the trace confidence threshold generally increases runtime.
in figure we see that increasing the support threshold causes a variety of effects while mining the always followed by always precedes and never followed by properties10.
in each case an increase in support threshold causes an initial jump in runtime followed by a flat section and sometimes a decrease in runtime.
introducing the support threshold forces texada to stop shortcircuiting on the evaluation of several operands however oncethe support threshold is set too high the property instance willfail the threshold on some trace.
at this point texada will begin to short circuit evaluation by moving to the next instantiation instead of checking the current instantiation on the remaining traces in the log.
note that this trace short circuiting is unsafe if thresholds are specified at the global level as this forces evaluation over the entire log.
we discuss the advantages of introducing support and confidence thresholds despite the large runtime cost in section vii c .
benefit of memoization.
to evaluate the effect of memoization we carried out an experiment with three instantiations of the property poccurs at most twice between qand rand soccurs at most twice between qand r .
we selected this property type because we found that the map checker was slower than usual in evaluating instances of this type.
to compare the runtime of the map checker with and without memoization we slowed down the checker by using a log containing a single especially long trace that we synthesized.
the trace consisted of million events sampled at random from a set of eventtypes.
we measured the runtime in checking instantiations 9some examples of short circuiting if one branch is found to be false in evaluating i f poccurs in evaluating gp or if a property instance is found to be false on one trace in the log.
10these properties were mined on a randomly generated log over events with event traces each with events.
11we used texada revision df18 300time s number of traces per logsynoptic linear miner map miner fig.
time to mine the three synoptic property types using synoptic and texada s linear and map miners for logs with varying numbers traces per log.
35000time s number of events per tracesynoptic linear miner map miner fig.
time to mine the three synoptic property types using synoptic and texada s linear and map miners for logs with varying number of events per trace.
a b and c. we designed the bindings for these so that the memoized state of band cwould help in evaluating a and vice versa.
however evaluating bwould not help in evaluating c and vice versa.
we ran the map checker on a b and cin four configurations with memoization clearing memoized state after checking a with memoization clearing memoized state after checking c.w er a n each configuration times and report the average runtime.
the two orders that do not clear memoized state had nearly identical runtimes of about .7s indicating that for this example the checking order does not matter.
we believe that this will generally hold true since we memoize the evaluation of every sub formula.
the two orders that cleared the memoized state also had similar runtimes of about .1s.
in this experiment memoization decreased the total runtime by .
in practice we expect the speed up to be significantly higher as many more than just three instantiations would share the memoized state.
memory use in these experiments peaked at 342mib and was primarily used to store the input trace.
the experiments generated kib of memoized state or kib per propertyinstance.
mining all possible instances of the same propertytype with four variables over the same log over event types requires checking property instances12.
at the rate of kib per property instance this process will generate about25 mib of memoized state.
we aim to improve on the memory use of memoized state by developing expiration policies to regularly delete memoized state that is not going be reused.
c. mining patterns of user activity to evaluate texada s utility we applied it to a web log used to evaluate the bear framework and perfume .
this log records web requests for a real estate website on which 12the default configuration is to generate bindings without replacement no two variables are bound to the same event.
1000time s unique eventssynoptic linear miner map miner fig.
time to mine the three synoptic property types using synoptic and texada s linear and map miners for logs with varying number of unique events.
1000time s trace support thresholdg x xfy g x xg!y fy !y u x fig.
time to mine each synoptic property with the texada linear miner given different trace support thresholds.
users browse or search for houses and apartments to rent or buy.
each request has a timestamp and an anonymized ip address we use these to interpret the log as separate executions of the web site one execution per client who accesses the site where events are the visited site pages.
we reused the event types from the bear study by preprocessing the log to remove irrelevant events like those generated by web crawlers and by assigning semanticallyidentical events to the same label.
the pre processed logcontained about lines with different events.
we used texada revision e436 to mine the property types in table ii with the linear miner.
in the analysis we ignored rarely occurring events to simplify inspection.
due to space constraints we discuss the implications of a select set of mined property instances.
the log had no ground truth to compare our results to but we believe the following results show utility.
for each result below we report a runtime that is an average over runs.
.
fnews page !news page unews article visits to news article always precede visits to the news page.
texada runtime .6s instances returned support threshold confidence threshold .
.
this is an instantiation of xalways precedes y in table iii and has .
confidence and support.
this instantiation suggests that the news articles generate much more initial interest than the news page andthat this page is only accessed by users who have taken the time to access an article and want more content.
it may indicate the news page needs to be redesigned for broader appeal.
.
g sales page xf sales anncs after visiting a sales page the sales announcement pages is always visited.
texada runtime .5s instances returned confidence threshold .
.
this is an instantiation of xis always followed by y in table iii and has .
confidence and 88table iv number of instances of g x xg y mined from the bear log with the linear miner using varying global support and global confidence thresholds.
the cell highlighted in the upper left corresponds to the default texada thresholds.
aaaaaasupp.conf.
.
.
.
.
.
.
.
.
support.
we expect users interested in buying or selling a property to navigate from the main sales page to the sales announcements.
however the lower confidence of the property suggests there may be a block to easy navigation between the two.
the sales page could be revised to better funnel users towards announcements.
.g search g news article xfrenting anncs x renting anncs u renting anncs fsales anncs users who visit news article pages eventually visit a sales announcement page.
texada runtime .8s instances returned we ran this property with confidence threshold and support threshold .
this is an instantiation of presponds tos tafter q in table ii.
this property says that after a search every time a user accesses a news article and then a renting announcement the user will then subsequently access a sales announcement something that does not happen every time users visit a renting announcement after search .
this may indicate that news articles impact users navigation which can prompt work on news article accessibility.
the support and confidence thresholds allow the user to focus on the most likely instantiations.
the filtering effect due to support and confidence is illustrated in table iv where increasing global confidence and support thresholds decreases the number of instances of the never followed by property foundon the bear log.
we also see that high support automaticallyfilters out low confidence properties the bottom row of the table shows that there were no additional properties with support at least 200k and a confidence value below .
.
the properties in the bottom row likely include the key patterns in the log.
two features distinguish the above properties from results derived using other tools on the same log .
texadagenerated properties are concise and allow a developer to focus on and filter by a set of relevant events without needing to understand other events in the trace.
the properties have a well defined ltl structure stipulated by the property type.
d. v alidating expected behaviour the sleeping barber problem is a classic concurrency problem attributed to edsger dijkstra .
in the problem a barber alternates between cutting hair sleeping and checking for customers in his waiting room.
if a customer walks in and finds the barber sleeping the customer wakes up the barber and gets a haircut.
if the customer walks in and the barber is cutting hair the customer waits in the waiting room if there isspace otherwise the customer leaves.
when the barber is done cutting hair he checks if there are customers in the waitingroom.
if there are then he cuts one of the customer s hair otherwise he goes to sleep.
in our version of the problem eachcustomer desires a certain number of haircuts.
our solution is based on a solution by teemu kerola and represents the barber and each customer as a thread.
the implementation tracks the state of the barber and each customer and prints the state of each thread whenever a customer enters a customer exits a customer receives the desired number of haircuts and the barber retrieves a customerfrom the waiting room.
we treat the barber s and customers states as events.
the resulting trace includes multiple events foreach of the above time points.
we call this a multi propositional trace multiple atomic propositions customer and barber states are logged at each time point.
we checked a log from five runs of our solution to the sleeping barber problem.
the runs had seven customers each of which desired two haircuts.
there were unique events in the lines long log with traces having lines time points .
we used texada to confirm that desired properties hold over these runs.
this analysis is not a proof of correctness but as we show below it can reveal bugs.
no two customers receive haircuts at the same time.
instantiations of the g x y will test this property when x and yare bound to customer i gettinghaircut and customerj gettinghaircut respectively with distinct iand j. running this property with the map option took .
seconds and outputted property instances.
we filtered these instances to find those of the form g customer i gettinghaircut customer j gettinghaircut for all distinct i jpairs demonstrating no violations of the mutex in these runs.
each customer receives haircuts.
we check this property by confirming that each customer transitions to the gettinghaircut state from another state exactly twice.
a property thatexpresses this is an extension of the bounded existence property with global scope x w xw x w xwg x f x xf x xfx .
the first half of this property assures that all transitions to xoccur at most twice and the second half assures that these transitions occur at least twice13.
with the map miner texada took .031s to check this property returning property instances.
these instances bind xtocustomer i waiting and customer i gettinghaircut for alli except customer .
examining the log we found that in one trace customer transitioned to the gettinghaircut state only once.
the second time the customer was observed to enter to be the only one in the waiting room when the barber checked it and to exit the barbershop.
this turned out to bea bug in our logging code not the implementation no timepoint was logged during the haircut for customer .
texada helped us find this bug.
for this example we have also used texada to validate the property customers are served in the order in which they sit down.
in addition we used texada in a similar way to validate an implementation of the dining philosophers problem.
we omit these for space reasons.
e. mining data temporal properties texada can be used to develop more advanced program analyses.
we prototyped a tool that combines texada with daikon a tool to infer likely data invariants from program traces .
our prototype infers likely data temporal properties.
13this is an example of an ltl property that is checkable with texada but which may be easier to specify as an automaton.
89as an example consider a queue class with fields size and capacity which represent the current size and the maximum size of the queue respectively.
for this class daikon may infer a data invariant like size capacity .
with texada we can infer temporal relations between these data invariants.
for example thequeue may also have an isfull flag.
while daikon can infer a data invariant like isfull true size capacity at some program points a more powerful property can be formulated temporally isfull false u size capacity .
that is isfull isfalse until size is equal to capacity it is an instance of xholds until ybecomes true .
this datatemporal property captures an important correctness condition the queue is not flagged as full until it reaches capacity.
we prototyped a version of a tool to mine data temporal properties.
it works as follows.
first it uses one of daikon s frontends to instrument a program to collect data tracesfrom a set of program executions e.g.
the program s testsuite .
then it uses daikon to infer likely data invariants from these traces.
the daikon invariants are spliced into the control flow of the data traces matching invariants with their corresponding program points.
this generates a set of totally ordered invariant traces which are multi propositional asdefined in section vii d .
finally the tool runs texada on these traces to generate data temporal properties.
we applied this technique to queuear a program distributed with daikon that implements the queue class discussed above.
we used queuear s test suite to generate invarianttraces one per queue instance.
using texada we mined this.currentsize w this.currentsize this instantiation reflects an important but expected property of the queue s test suite the queue is always created empty.
we think that data temporal properties can be useful in test case generation and for bug detection.
evaluation of datatemporal properties is part of our future work.
viii.
r ela ted work the problem of checking an ltl formula on a finite trace has been considered by van der aalst et al.
their algorithm is similar to texada s linear checker.
there are also efficient techniques for checking an ltl formula on a single trace using alternating finite automata .
however the generated afa depends on both the property instance and the trace making the approach not scalable to our context which requires checking a large set of ltl properties across many traces.
many specification mining tools have appeared in prior work .
existing tools mine ltl properties but unlike texada these are designed to mine a particular set of property types.
the perracotta tool by yang et al.
mines several two variable response patterns and chains alternating properties together to form multi variable properties.
it also supports approximate inference to filter out uninteresting properties.
lo et al.
extend yang et al.
s work with a miner that produces quantified temporal rules that capture data flow relationships among events .
li et al.
extend perracotta to minesimple ltl patterns from traces and merge these to analyze digital circuits.
these same ltl patterns are mined between data invariants in .
although prior work has not explicitlymined temporal relationships between data invariants there has been work on augmenting models such as fsms and live sequence diagrams with data invariants .
weimer et al.
mine alternating and response pat terns on exceptional control flow to effectively identify bugs.
javert also mines alternating patterns along with resource ownership patterns i.e.
ab c and composes them intomore complex properties.
reger et al.
use a similar pattern composition technique and extend it to accommodate imperfect traces .
gabel et al.
improve the efficiency of mining the alternating and resource allocation patterns by using bdds to represent property types.
like all these miners texada is a dynamic analysis technique and may produce false positives.
one promising approach to validate minedspecifications of programs whose code is available is to use deductive specification inference .
a number of tools mine association rules response patterns between events sets dynamine examines revision historyof a program and observes program behaviour to filter behaviour and to avoid blow up of potential patterns.
thummalapentaet al.
mine such rules to infer exception handling rules.
lo et al.
develop an algorithm to mine response patterns between sequences of events.
invarimint is a declarative model inference specification approach that requires an algorithm designer to specify model inference algorithms as parameterized fsm templates with bindings functions that resemble texada property types.
texada can be used to mine the legal bindings in invarimint.
recent work on inferring various types of models from source code execution traces and log files relies on temporal properties .
for example in temporalproperties are specified manually by a user to guide specifi cation mining and in a set of properties are mined automatically from the input traces.
texada can improve both types of work the texada mined property instances can be presented to the user for selection or used en masse.
the recursive descent parsing style checking of ltl in texada does not work for classic ltl with infinite trace semantics.
the standard way to check an ltl formula isto derive a b uchi automaton and to intersect it with the model.
using existing model checking tools out of thebox e.g.
spot for specification mining is not typically possible because of the mis matched trace semantics.
ix.
c onclusion texada is a general ltl miner that is a swiss army knife of property mining.
it replaces a suite of tools that are based on specific templates and supports tasks ranging from log exploration to property validation.
we presented two algorithmsin texada that mine arbitrary ltl properties and an algorithm to compute the support and confidence for an arbitrary ltl property.
our evaluation demonstrates that texada is fast and can outperform synoptic an existing special purpose miner.
wealso demonstrated texada s utility by mining properties from a web log of user activity by validating expected properties of a solution to the sleeping barber problem and by mining datatemporal properties from traces of daikon invariants.
property types in texada encompass those proposed in prior work and can capture a wide variety of temporal patterns.
we encourage other researchers to build their software analyses on top of texada which is open sourced and includes pre defined property types from prior work .