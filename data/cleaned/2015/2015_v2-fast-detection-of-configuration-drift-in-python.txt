v2 fast detection of configuration drift in python eric horton chris parnin north carolina state university raleigh nc usa ewhorton cjparnin ncsu.edu abstract code snippets are prevalent but are hard to reuse because they often lack an accompanying environment configuration.
most are not actively maintained allowing for drift between the most recent possible configuration and the code snippet as the snippet becomes out of date over time.
recent work has identified the problem of validating and detecting out of date code snippets as the most important consideration for code reuse.
however determining if a snippet is correct but simply out of date is a non trivial task.
in the best case breaking changes are well documented allowing developers to manually determine when a code snippet contains an out of date api usage.
in the worst case determining if and when a breaking change was made requires an exhaustive search through previous dependency versions.
we present v2 a strategy for determining if a code snippet is out of date by detecting discrete instances of configuration drift where the snippet uses an api which has since undergone a breaking change.
each instance of configuration drift is classified by a failure encountered during validation and a configuration patch consisting of dependency version changes which fixes the underlying fault.
v2 uses feedback directed search to explore the possible configuration space for a code snippet reducing the number of potential environment configurations that need to be validated.
when run on a corpus of public python snippets from prior research v2 identifies instances of configuration drift.
index t erms configuration management configuration repair configuration drift environment inference dependencies.
i. i ntroduction code snippets are commonly used by developers to provide api documentation and act as examples for learning and reuse .
stack overflow a question and answer site for developers has over 1m questions relating to python a popular and fast growing programming language .
on github s gist system developers have shared over 300k public python code snippets .
both feature prominently in search results for api documentation and a study by yang et al.
found over 4m code blocks from stack overflow snippets that had been reused in public github projects .
recently code snippets in jupyter notebooks have become a standard for sharing and replicating scientific work and more .
unfortunately many code snippets require a non trivial environment configuration in order to execute successfully and are not accompanied by sufficient information for developers to easily recreate that configuration .
this leads to the problem of configuration drift where a code snippet goes out of date because the apis that it depends on experience breaking changes over time.
developers struggle to determine if a code snippet has experienced configuration drift or is simply incorrect .
in some instances a breaking changemade to an api may be highlighted in release documents made available to developers.
in the worst case determining if and when a breaking change was made requires an exhaustive search through previous dependency versions.
the ability to validate and detect out of date code snippets is the most important consideration for quality of code reuse according to a recent survey of software developers .
pimental et al.
found that only of jupyter notebooks could be executed and only had reproducible results .
they note that reproducibility suffers because the notebook format does not encode dependencies or dependency versions.
for example the recent release of tensorflow version .
introduced many breaking changes.
as a result many jupyter notebooks are not runnable with the latest version of the framework.
this proves detrimental as developers have remarked that documentation for the tensorflow platform is largely based on examples.1overall there is an unmet need for checking if code examples are up to date and runnable.
this work presents v2 available at v2 project v2 a tool that determines if a code snippet is out of date by detecting configuration drift.
v2 is based on the observation that an instance of configuration drift often manifests as a crash during execution.
it can therefore be categorized by the illuminating failure crash paired with a configuration patch sufficient to enable execution.
patches consist of changes to dependency versions and act both as a certificate of correctness for the snippet and enable execution with an older configuration if desired.
unlike other work in configuration repair v2 automatically infers up to date candidate environment configurations from a code snippet without the need of developer input or pre existing build scripts.
if the code snippet experiences a crash when executed in its candidate environments v2 searches for configuration drift by employing feedbackdirected search a search strategy that incorporates feedback from code snippet execution and knowledge about prior api breakage events to prune and prioritize configuration patches from the space of all possible environment configurations.
we show that v2 is able to discover configuration drift in open source python code snippets from the gistable dataset and from a wide array of jupyter notebooks .
for both datasets we show that incorporating execution feedback and knowledge of previous api breakages enables v2 to more quickly decide when configuration drift is present in a snippet.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1importmath 2fromfunctools importwraps 4fromtheano importtensor ast 5fromtheano.sandbox.rng mrg import mrg randomstreams asrandomstreams arrowhookleft 7fromlasagne importinit 8fromlasagne.random importget rng ... a 2addbayes.py bayes.py 3run 4run 5cmdpython bayes.py b dockerfile 1decrementsemvermajor theano .
.
.
.
2decrementsemverminor theano .
.
.
.
c mutations fig.
a import statements extracted from a github gist using the lasagne and theano apis.
b a base environment configuration using the docker container system dockerfile format containing the gist and the latest versions of theano and lasagne.
due to configuration drift the gist does not execute successfully using the configured versions.
c environment mutations made while searching for the correct version of theano.
ii.
m otiv ation consider the code snippet fragment presented in figure 1a.
the fragment contains the import statements for lasagne and theano from a public python gist found on github.
both libraries can be found on and installed from the python package index pypi .
however after installing version .1and1.
.
the latest versions respectively executing the code fragment with python results in the following exception ... 2file usr local lib python3.
site packages lasagne layers pool.py line in module arrowhookleft arrowhookleft 3from theano.tensor.signal import downsample 4importerror cannot import name downsample from theano.tensor.signal usr local lib python3.
site packages theano tensor signal init .py arrowhookleft arrowhookleft arrowhookleft the exception indicates lasagne has attempted to import downsample from theano and failed because the current version of theano does not provide it in the expected location.
the lasagne installation documentation2indicates that the library is tightly coupled with theano and that a very recent version of theano is often required to run correctly lasagne has a couple of prerequisites that need to be installed first but it is not very picky about versions.
the single exception is theano due to its tight coupling to theano you will have to install a recent version of theano usually more recent than the latest official release!
fitting the version of lasagne you choose to install.
however the current version of lasagne was released before the current version of theano.
while the documentation indicates that the correct configuration requires installing a pre release version of theano it may actually be the case that lasagne has drifted and is now out of date.
the theano versioning scheme uses semantic versioning3 semver which tells us the current version of theano is a major version some patches.
we start searching for the correct version by going back to the latest release of the previous major version theano .
.
.
when that fails we go back an additional minor version theano .
.
.
using this version allows the gist to be executed successfully although with a warning that the downsample module has been moved to the theano.tensor.signal.pool module confirming that execution originally failed because the code had fallen out of date.
iii.
v2 v2 v ersion is an extension of dockerizeme that adds support for validating multiple environments and reasoning over dependency versions.
v2 determines if a code snippet or its dependencies is out of date by discovering instances of configuration drift.
each instance of configuration drift is identified by two things a runtime failure and a configuration patch consisting of version changes.
to detect configuration drift v2 first generates candidate environments that are potentially correct.
that is the environment is configured with the dependencies that v2 infers as being potentially necessary for executing a snippet correctly.
it then executes the snippet in this inferred environment recording any execution failures as they are encountered.
for each new execution failure v2 applies mutations to installed dependency versions to generate a new candidate configuration until the fault is either resolved or no new candidate configurations can be made.
v2 uses information about snippet execution and prior api breakage events to prune and prioritize candidate configurations.
we now detail each stage of the repair algorithm in detail.
a. candidate environment generation in order to find instances where configuration drift has caused a failure v2 must first have one or more candidate environment configurations for a code snippet.
these should contain the set of required dependencies although they may not have the correct versions.
v2 uses the docker container system to specify configurations for isolated environments.
the use of docker guarantees a clean and consistent base authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
environment for v2 to work in and allows each candidate environment to be based off of a standard image.
although the scheduled end of life for python is many older scripts will not run in python as they use syntax that was removed from the language.
candidate generation must first determine which language runtime to use either python or python .
the correct language runtime is detected by attempting to parse the code snippet using python s built in ast module for each language runtime or .
if the code snippet parses in both language runtimes then two potential candidate environments are generated.
v2 then uses the dependency resolution algorithm and knowledge base provided by dockerizeme to populate each candidate environment with an initial set of dependencies in the following manner.
v2 extracts fully qualified names of resources appearing in import nodes of the ast.
imported resources not in the python standard library are mapped to a set of packages from the python package index pypi that potentially provide them although the set may be an overestimate.
these packages are considered the direct dependencies of the code snippet.
v2 also resolves all transitive dependencies i.e.
packages depended on by a direct dependency or by another transitive dependency.
each dependency is initially pinned at the latest version available on pypi because dockerizeme does not consider versions and a final installation order is generated such that for each dependency it is installed only after all packages that it depends on.
a runtime dependencies tuple defines a candidate environment specification containing the correct language runtime level and dependencies listed in a valid installation order.
b. environment v alidation the v2 validation phase accepts as input a single code snippet and a candidate environment specification in the runtime dependencies format.
it returns a status code indicating the result of executing the code snippet in the candidate environment plus any metadata about the execution or encountered failures.
validation consists of two phases environment configuration and snippet execution.
during the configuration step v2 creates a new execution environment using a docker container based on the language runtime.
this guarantees a consistent starting environment.
it then configures the execution environment according to the candidate environment specification by installing each dependency in order.
installation failures are recorded as part of the validation metadata but do not halt validation.
if a dependency which is not required fails to install it will not affect the result of execution.
conversely if a required dependency fails to install it will produce an execution failure.
finally the snippet is executed in the configured environment.
if the snippet runs to completion without experiencing a failure the execution result is coded as success .
if an exception is encountered during execution the snippet is considered to have failed validation and the execution result is coded as exception .
in this case the exception name message and stack trace are provided in the validation metadata.in certain cases a code snippet will run indefinitely instead of exiting.
for example a snippet which waits for user input will block forever.
if a snippet has not exited after a time limit execution is stopped and the validation is coded as timeout .
a timeout is considered neither a success nor a failure as it is generally undecidable if the snippet would have eventually exited.
regular python snippets are run with a time limit of one minute.
because they generally involve computation and require a longer runtime jupyter notebooks are run with a base time limit of two minutes plus an additional minute for each cell in the notebook.
c. environment mutation configuration drift is classified by a validation failure and a patch.
each patch consists of a sequence of configuration changes mutations to the environment configuration which are sufficient to resolve the fault.
v2 supports two classes of mutation operators for dependency versions.
the first class is based on the semantic versioning scheme and the second class is based on pre existing knowledge about version changes.
semantic v ersioning semantic versioning semver is a versioning scheme which defines major minor patch and prerelease changes to a package.
breaking api changes must be accompanied by a major version change while backwards compatible additions are accompanied by a minor version change.
however before version .
.
semver defines that an api should not be considered stable and that anything may change at any time.
many python dependencies follow a versioning scheme that is or can be interpreted as semver.
v2 defines two mutation operators for semantic versions decrementsemvermajor and decrementsemverminor which mutate the major and minor version level of a dependency in an environment configuration as seen in figure 1c.
both mutation operators will decrement the specified version level by one if possible but will choose the latest release at that version level.
for example if a package has versions .
.
.
.
and1.
.
thendecrementsemvermajor .
.
.
.
.decrementsemverminor only operates within a major version it will not roll back to a previous minor version if so also requires decrementing the major version.
upgrade matrix in the worst case all versions of a dependency may be enumerated by combining the semver mutation operators described in section iii c1.
however such a brute force approach is generally not feasible due to the large number of potential candidate environments in the version configuration space.
a more efficient approach is to prioritize or prune environment configurations based on how likely they are to fix a validation failure.
to make this estimation we extrapolate from travisci build statuses of python projects that experience version upgrade events.
an upgrade event occurs when a commit is made that upgrades the version of a single project dependency triggering a travisci build for the project.
figure shows an upgrade event initiated by pyup bot an upgrade bot for python projects.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a pull request to upgrade matplotlib from .
.
to .
.
.
b git diff.
fig.
an upgrade event initiated by the upgrade bot pyup.
fig.
version upgrade matrix for wheel.
all upgrade events were discovered by mining google bigquery for github pull requests from january though january .
we limit our search to pull requests which change the version for only a single python dependency and were submitted by an account with the name dependabot dependabot snyk bot o rpyup bot .
we then extract the project build statuses for the original and new dependency versions from travis ci excluding build histories where one of the statuses was either canceled or errored.
in total this provided upgrade events for distinct packages that experienced at least one failure.
taken together the build statuses for a single package form a version upgrade matrix for that package where each row and column indicates upgrading from one version to another.each cell of an upgrade matrix contains the percent of builds that were broken by performing the version upgrade where a breakage is determined by a build status that changes from passing to failing as a result of the upgrade.
figure shows the version upgrade matrix for the python package wheel.
an incompatibility cluster in the top row indicates that upgrading from version .
.
becomes more likely to cause a failure as the distance between versions increases.
intuitively we apply the heuristic that upgrades which break a larger number of builds are more likely to indicate a backwards incompatible change.
conversely given a failed validation downgrading to a version which experienced a large number of upgrade failures is more likely to fix the fault.
when v2 finds a validation failure caused by a dependency with an upgrade matrix it can leverage information about the incompatible upgrades to test only those versions likely to result in a fix pruning the rest of the version space.
d. feedback directed search the problem of finding an instance of configuration drift can be solved by conducting a search through the full configuration space for a code snippet.
we model the configuration space as a configuration graph g v e where each vertex v vis a potential environment configuration and each directed edge u v m eis a pair of configurations u v and a mutation msuch that applying mutation mto configuration uresults in configuration v. we now formally define the problem driftsearch of finding patched configurations in gthat fix faults caused by configuration drift.
if some configuration fixes all faults we say that it is a working environment configuration.
input a configuration graph g v e and a starting environment v. problem find a working environment w. objectives minimize the distance from vtow.
minimize the number of vertices explored.drift search authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we implement a search strategy feedback directed search that generates a configuration space from a candidate environment configuration by applying the mutation operators defined in section iii c. feedback directed search incorporates information about the executability of a code snippet within candidate environments to intelligently drive exploration of the configuration space reducing the number of environments in the configuration space explored and allowing v2 to quickly converge to a working configuration.
procedure feedbackdirectedsearch environment checkpoint null do validation validation validate environment iffixed checkpoint validation then record drift checkpoint checkpoint validation ifnot fixable checkpoint then return environment end end fault localization ifupdated checkpoint then dependency localize checkpoint ifdependency is not null then ifhas matrix dependency then mutator matrix dependency end else mutator iddfs dependency end end else mutator iddfs environment end end exploration environment next environment mutator while not successful checkpoint return environment algorithm implementation of feedback directed search for a single candidate environment.
exploration is performed by either using a version upgrade matrix or iterativedeepening depth first search iddfs .
v2 begins feedback directed search with a list of candidate environment configurations generated as described in section iii a. if more than one candidate environment was generated feedback directed search operates on the environment specifications round robin exploring the configuration space for each candidate in tandem.
so allows feedbackdirected search to satisfy the objective of minimizing thedistance or number of mutations from starting environment vto working environment win the case that one candidate environment is easily fixable but the other is not.
the search algorithm is structured in three distinct phases validation checkpointing and pruning fault localization and exploration.
a high level implementation of feedback directed search for a single environment is outlined in algorithm .
we now highlight each phase in detail.
v alidation checkpointing and pruning given a code snippet sand candidate environment c feedback directed search first performs validation of sincusing the procedure outlined in section iii b. if the candidate environment produces an execution failure the validation result is saved as a checkpoint and cwill be mutated to fix the fault.
after each environment mutation sis again validated in c. conceptually at each stage of the search process a validation checkpoint represents the latest unfixed validation failure.
we consider the fault indicated by the validation checkpoint to have been fixed by a sequence of mutations to cif a newer validation results in an execution which covers more ofs.
that is the mutations made to callow execution of s to proceed past the line which previously caused a failure.
whenever such a sequence is discovered by feedback directed search it and the validation checkpoint are recorded as an instance of configuration drift and the checkpoint is updated to the newer validation.
if a validation indicates that a sequence of mutations has not changed the validation result or that execution exits on or before the line reached by the checkpoint it is discarded and the search process continues.
whenever a new validation checkpoint is discovered v2 determines if it is potentially fixable via mutations to dependency versions.
if it is not potentially fixable search halts and returns the current environment and instances of configuration drift reported.
a validation checkpoint is considered potentially fixable if the execution exception does not indicate a failure due to the local file system and satisfies one of it is caused by an installed dependency.
it is an import error related to an installed dependency.
it is one of typeerror orattributeerror which can indicate breaking changes in a public api.
fault localization during search v2 prunes the local configuration search space by performing fault localization to map validation checkpoint failures to a single dependency.
if the execution failure was caused by code not belonging to the code snippet or the python standard library v2 extracts the last dependency from the stack trace that was installed as part of the environment configuration.
if the exception is an import error related to a single installed dependency v2 indicates that dependency.
in cases where fault localization fails to highlight a single installed dependency related to the failure v2 continues exploring the local search space.
exploration whenever a validation result indicates that a code snippet sdoes not execute successfully in a candidate environment c feedback directed search searches the local configuration space for a fix by applying mutations to c. there are three exploration strategies based on the success of fault authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
localization and whether v2 can leverage one or more version upgrade matrices.
if v2 succeeds in localizing a fault to a single installed dependency d and that dependency has a version upgrade matrix feedback directed search proceeds by querying all pairs of versions vi vi such that the version matrix indicates a nonzero percent of builds were broken by upgrading from vi 2tovi and vi 1is at most the current version of d. selection in this manner implicitly disregards the versions which experienced no breaking upgrades.
an ordering of versions is generated by sorting all pairs in descending order byvi .
then for each vi allvj 2not already in the ordering are sorted in descending order by percentage of builds broken and appended to the order.
while validation indicates that the checkpoint has not been fixed dis mutated to be the next version in the ordering and validated again.
when v2 is capable of localizing a fault to a single installed dependency d but that dependency does not have a version upgrade matrix feedback directed search explores the local configuration space by performing iterative deepening depth first search iddfs over the versions of dusing the semver mutation operators from section iii c1.
in all cases the operators are strongly ordered such that all instances ofdecrementsemvermajor are applied prior to instances of decrementsemverminor .
this coupled with the fact that decrementsemverminor does not cross major version boundaries guarantees that the same configuration is not reached at two different depths.
if v2 is unable to localize a fault to a single installed dependency feedback directed search performs iterative deepening depth first search over the versions of all dependencies making use of upgrade matrices for individual dependencies where applicable.
in either case while performing iterative deepening depth first search candidate environments are only validated when they are generated.
because of the size of the search space tracking all candidate environments on the frontier quickly becomes intractable limiting search algorithms which require so.
depth first exploration allows feedback directed search to generate and validate new candidate environments with smaller memory requirements.
note that because mutation operators result in decreasing dependency versions exploration will never undo mutations made prior to the current checkpoint.
search is halted if no sequence of mutations will lead to an as of yet unexplored environment.
iv .
e v aluation we evaluate the ability of v2 to find instances of configuration drift by analyzing open source python code snippets.
a. datasets horton and parnin previously presented gistable a dataset of python code snippets from github s snippet sharing service .
they identified a subset of approximately hard gists that experienced a failure even after a straightforward approach to inferring an environment configuration.
wetable i summary of code snippets from datasets.
gist jupyter total with a candidate environment with a successful candidate environment no successful candidate environment exclude gists that are known to have over direct dependencies because the large configuration space is intractable for a baseline.
for example an environment with dependencies each with versions would have nearly 60k possible unique configurations.
this leaves gists that we refer to as the gist dataset.
prior work was unable to make of these gists execute successfully after candidate environment generation using the latest versions of all dependencies .
second we collect larger python code snippets in the form of python notebooks.
rule et al.
previously collected .25m open source jupyter notebooks from github making the dataset publicly available .
as part of their release they provide a random sample of notebooks many of which are written in python.
we exclude notebooks from the sample for which no candidate environment could be generated leaving notebooks we refer to as the jupyter dataset.
there were several main causes for why candidate generation failed all related to being unable to parse the snippet.
some notebook files were completely empty or identified as using jupyter kernels for other languages such as r meaning v2 could not parse the notebook source code as python.
other notebooks contained ipython magics which are defined as statements which are syntactically invalid python causing difficulty in parsing.
for simplicity and to disambiguate between the origin of code snippets we refer to code snippets from the gist dataset as gists and code snippets from the jupyter dataset as notebooks.
table i shows a summary of both.
together these snippets represent a wide range of behaviors and api uses and their generated candidate environments have over 2k unique installable packages.
b. methodology we use iterative deepening depth first search to establish a baseline for identifying configuration drift in each dataset.
this baseline enumerates all states in the configuration space and represents a worst case scenario where it is assumed a repair can be made by modifying a dependency version but no information is available to guide configuration.
for each code snippet we record whether search finished or timed out.
if search finished we record whether or not it resulted in a successful environment configuration and the total number of environments validated.
after running the baseline we analyze both datasets using v2 with feedback directed search recording the same metrics as used in the baseline evaluation.
in all cases where search authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
finished within the timeout we also record every instance of configuration drift identified by v2 along with the number of environments in the configuration space that were validated while identifying the instance as evaluations are the dominating factor in cost for validation based approaches .
how far the final configuration is from the starting configuration is also recorded.
if search did not find a fully working environment configuration we record metadata about why the search process terminated and which portion of the configuration space it was operating in.
we performed evaluation on a cluster of virtual compute nodes running ubuntu .
.
lts.
each compute node was configured with cpu cores and gb memory.
evaluations were run using the hashicorp nomad job scheduler with at most jobs running on a single compute node at one time.
all evaluations were run with a timeout of hour after which they were given the chance to gracefully exit and record results.
evaluations which lasted longer than hours were terminated.
this could happen for snippets where validating the last environment took longer than an hour as we allowed each validation to fully complete before timing out.
v. r esults we evaluate v2 with three metrics related to its ability to detect configuration drift improvement over the baseline discovery of configuration drift and search performance.
a. improvement over the baseline the iterative depening depth first search baseline approach searched for a working environment configuration using only the mutation operators decrementsemvermajor and decrementsemverminor .
we found that the most common baseline result was a timeout at the one hour mark without finding a working environment configuration.
search failed to complete for out of gists nearly .
out of notebooks likewise failed to complete within an hour.
comparatively feedback directed search only timed out on gists a reduction of from the baseline analysis.
this is mirrored by jupyter notebooks only of which timed out versus the baseline of a reduction of .
a simple search strategy is insufficient for fully exploring the configuration space of most code snippets.
feedbackdirected search aids exploration by allowing v2 to focus only on a relevant subset of the configuration space.
b. discovered configuration drift v2 discovered instances of configuration drift present in gists and instances present in notebooks.
search terminated without finding a working environment configuration for gists and notebooks only and of which timed out respectively although notebooks experienced a jupyter error related to network issues .
for gists and notebooks search was terminated because the validation failure was heuristically determined to not be fixable by mutating installed dependency versions according the criteriafig.
number of validations performed on gists for which a working environment was ultimately found.
if v2 is able to make use of data in a version upgrade matrix it can converge to a working environment with fewer validations.
in section iii d1.
in the other cases search was terminated because v2 had explored all environment configurations in the portion of the configuration space determined to be relevant to the validation failure without finding a patch.
v2 is capable of finding instances of configuration drift in both gists and notebooks.
it can potentially find more than one instance in a single snippet.
c. search performance we record two metrics important to search performance corresponding to the objectives of driftsearch section iii d .
the first is the total number of environment configurations validated before finding a patch.
this indicates the overall performance of feedback directed search since validation dominates runtime performance.
the second metric is the number of mutations made to a candidate environment to find a patch.
both metrics reflect on v2 s ability to prune and prioritize within the search space.
feedback directed search shows an improvement over the baseline in the average number of validations needed to find a working environment configuration.
gists see a large improvement dropping from validations on average in the baseline to when using feedback directed search.
jupyter notebooks see a more modest improvement from to .
for gists v2 was able to take advantage of a version upgrade matrix for of the that were made fully executable bringing the average number of validations needed down from to .
even when a working environment was not found v2 was able to use the version upgrade matrices for about of code snippets decreasing the number of validations needed before deciding no working environment existed.
figure shows the distribution of number of validations required by feedback directed search to find a working en483 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vironment configuration for gists.
when able to prioritize using a version upgrade matrix v2 requires a third as many validations on average with substantially better savings in the worst case.
time savings are also seen for individual instances of configuration drift regardless of whether a fully working environment was eventually discovered.
a relatively small number of mutations about is required to find a configuration patch for each instance of drift on average.
however incorporating information from a version upgrade matrix results in an improvement in the worst case.
for gists the maximum number of mutations made to create a configuration patch without a version upgrade matrix was while the maximum with one was .
for notebooks the maximum number of mutations dropped from to .
this indicates that v2 is able to correctly skip over certain versions while searching.
feedback directed search is able to find configuration drift by only searching a portion of the entire configuration space.
whenever a version upgrade matrix is available v2 can leverage the build information to prioritize dependency versions and further improve search performance.
d. configuration drift f ound in code snippets we now detail v2 s behavior on two code snippets from our corpus detailing how feedback directed search actually found and fixed instances of configuration drift.
prioritization of dependency v ersions consider the gist moby.py 6which contains the following imports from the python library sphinx .
1fromsphinx importaddnodes 2fromsphinx.builders.html import standalonehtmlbuilder arrowhookleft 3fromsphinx.util.osutil importeexist make filename 4fromsphinx.util.smartypants import sphinx smarty pants asssp arrowhookleft executing moby.py with the latest version of sphinx .
.
results in an import error for the module sphinx smarty pants .
a developer might assume that the configuration is broken and look for a missing dependency that provides an extension to sphinx.
however sphinx extensions are provided from the sphinx.ext module not the sphinx.util module.
another assumption is that a breaking change was made to the smartypants module.
to validate this assumption the developer must find a previous version of sphinx for which moby.py executes successfully.
they start by reverting from sphinx .
.
to the previous major version sphinx .
.
.
however executing with this version results in the same error.
they change the major version again to sphinx .
.
a change which also requires using python but so results in an import error forosutil on the line before indicating that the latest version change has actually broken a part of the configuration which previously worked.
a correct working version exists it must be one of the other untested minor or patch level versions.
without any other information discovering this version requires performing an exhaustive search though the .x and0.x versions.
using a depth first strategy such as iterative deepening depth first search the developer might additionally validate versions .
.
.
.
.
.
and0.
.
before finding a working configuration with version .
.
.
v2 by comparison starts by validating sphinx version .
.
and encounters the original error localizing it to the sphinx module.
using the available upgrade matrix it sees that the most recent version with upgrades that resulted in a broken build was .
.
and the only broken upgrade was from version .
.
.
it then mutates the environment resulting in a configuration in which the gist successfully validates.
uncovering multiple instances of configuration drift v2 is capable of uncovering more than one instance of configuration drift from the code snippets that it analyzes.
for example by using feedback directed search v2 demonstrates two instances of configuration drift in the gist guesscandidate model.py 7which the following excerpt is from.
1fromsklearn.cross validation importtrain test split 2fromkeras.preprocessing importsequence text 3fromkeras.models importsequential 4fromkeras.layers import dense dropout activation embedding lstm convolution1d maxpooling1d arrowhookleft ... 6x forxinlabeled sample 7y forxinlabeled sample this gist relies on two installable packages scikit learn andkeras .
v2 correctly generates candidate environment configuration for both python and python containing the latest versions of both of these packages.
the first validation inside of a candidate environment results in a failure returning the message no module named sklearn.cross validation even though the sci kit package is included in the environment configuration.
v2 recognizes this as a potential instance of configuration drift and applies the mutation operatordecrementsemverminor scikit learn .
.
.
.
.
the next validation also results in a failure but this time with the message no module named tensorflow.
v determines that the previous failure has been fixed because execution progressed past the line which caused the previous failure and recognizes this as a potential instance of configuration drift involving keras .
in searching for a patch it applies the mutation operators decrementsemvermajor keras .
.
.
.
anddecrementsemvermajor keras .
.
.
.
.
finally v2 encounters the error name labeled sample is not defined .
it again recognizes that the previous failure has been fixed.
further it recognizes that this failure indicates authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
an error with the gist that cannot be fixed by modifying the environment configuration and terminates search.
vi.
l imitations v2 presents a promising approach to finding and repairing instances of configuration drift within a code snippet and its dependencies.
we show that it is capable of finding and repairing drift in a large corpus of open source python code snippets.
there are however some limiting factors which make it challenging to uncover all instances of drift.
a silent failures feedback directed search requires that configuration drift result in a crash during snippet execution because this failure is used to guide the search process and determine when the configuration drift has been patched.
this requirement is sound for a large number of breaking api changes such as removal of modules or a change in the code signature because such changes result in runtime or compile time exceptions.
however some breaking changes in dependency behavior may cause a failure which does not manifest as a crash.
v2 cannot address such cases although we note that the problem of determining if program behavior is expected is an open and challenging area of research .
b mutation operators and ordering v2 concentrates on major and minor dependency versions because they are the most likely to introduce or change behavior of an api and its search strategy explores versions in the configuration space with equal precedence only giving preference to configurations that are more similar to the original candidate configuration.
however developers differ in how they reason about the stability of dependencies and communities differ on how they handle versioning .
other search strategies may ultimately prove to be more effective at uncovering configuration drift.
c overzealous pruning parts of the v2 search algorithm are informed by heuristics.
in cases where a heuristic erroneously produces a false positive or false negative determination search may be terminated prematurely.
for example if a validation failure is heuristically determined to not be fixable by modifying dependency versions but a fix actually does exist v2 will stop exploration and be unable to report the configuration drift.
for some dependencies search is informed by a version upgrade matrix obtained from travisci build results.
however an upgrade matrix may be incomplete or not sufficiently represent some breaking upgrades causing incorrect pruning.
d snippet properties some code snippets may be unsuitable for uncovering configuration drift.
gists can be overly general relying on other services and requiring resources like authentication tokens .
failures related to these resources may shadow configuration drift that could otherwise be discovered.
notebooks are heavily used within the data science community and data science dependencies may be more stable than python dependencies in general.
additionally gists were restricted to having at most direct dependencies.
while this does not necessarily restrict the total number of dependencies it may impact the distribution of results.e discovery because exploration of the configuration space is guided by feedback from validation v2 discovers at most one instance of configuration drift at a time.
further validation can be an expensive process and other instances of drift may be hidden by the most recent validation failure.
vii.
d iscussion and future work recent work has shown that managing dependencies is a large and time consuming problem developers face when engaging in configuration management .
in particular some developers have highlighted dependency management as one of the largest problems facing python requiring developers to spend non trivial amounts of time on configuration for basic tasks.8this problem impacts data scientists who must overcome the friction imposed by configuration just to perform their job.
in addition upgrading a version of a library that contains incompatibilities in data structures signature changes to api calls or behavior breaking changes can result in additional effort to address these changes.
if a developer fails to understand the nature of a dependency change or performs insufficient testing they can introduce undetected faults in code.
such factors may cause a developer to become reluctant to update dependencies.
but if they delay updating code too long they may be locked out of being able to use important new features only available in new versions as it becomes more and more difficult to adapt their code.
for this reason detecting instances of configuration drift has direct implications for configuration management.
being able to highlight where code contains outdated api usages even between dependencies of that code can help developers locate and fix usage of apis that have been changed benefiting work in api migration.
further by pairing each instance of drift with a corresponding fix we motivate code repair and reuse.
for example repairing jupyter notebooks can enable replicating important calculations even in older notebooks.
although we focus on python we believe detection of configuration drift is an important problem for other languages.
for example updating the mongodb driver for node.js from .
.x to2.
.x affected the way order by parameters are used in the sortfunction.
previously parameters were allowed to be specified as list of objects but in the newer version list of lists must be provided .
v2 is capable of detecting such a breaking change in any language so long as the code snippet may be parsed and validated and previous versions of dependencies are made available.
while the technique outlined in this paper shows promise we believe there are several areas for improvement.
a fuzzing data in version upgrade matrices is necessarily limited as it originates from upgrades to existing open source projects which both use upgrade bots and build through travisci.
when data does exist for a package the matrix authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is usually sparse.
we believe that the amount and quality of available upgrade data can be augmented.
one method would be to engage in fuzzing of dependency versions for libraries.
for example the upgrade matrix for numpy could be filled in by choosing a set of snippets or generated tests that cover the api and observing their execution with different versions of the library.
this additional execution data could help determine clusters of incompatible versions that indicate a breaking change for particular api uses.
traditional fuzzing techniques can also be implemented to improve drift detection.
some code snippets particularly those meant to be used as examples define functions but do not execute them.
executing these functions with generated input would ensure greater coverage of the code snippet and its api uses allowing further detection of instances where configuration has drifted.
b progression in the face of adversity v2 currently only recognizes configuration drift caused by versions of installed dependencies.
however code snippets often depend on resources external to the configuration environment such as communication with databases or rest apis.
when validation of a code snippet fails due to an external service future work can focus on determining if the failure represents an instance of configuration drift and attempt to generate a fix.
if a fix cannot be found a mock patch sufficient to remove the validation failure could be inserted allowing analysis of the snippet to continue.
missing resources such as files on the local file system could also be synthesized to allow code snippet analysis to continue.
c improvements to search feedback directed search uses heuristics and checkpointing to reduce the search space.
this results in improved performance but at the potential cost of completeness.
this could be mitigated by still searching all versions but using version matrices for prioritization.
additionally the checkpointing process can be modified to allow for backtracking to a previous checkpoint if no solution is found as might be the case in library version conflicts .
however v2 does not currently do so.
finally work can be done to improve the quality of search through the environment space.
v2 assumes that the original candidate environment is complete and contains all required dependencies if not the correct versions.
we leave it to future work how best to continue searching if it is discovered that this is not the case.
d optimization and improvement the validation strategy employed by v2 currently starts by creating and configuring a new environment.
this is sufficient to guarantee correctness of validation but requires an expensive configuration phase after every mutation performed by feedback directed search.
we note that because feedback directed search generates a new environment configuration by applying a single mutation to the previous configuration v2 could optimize the validation process by creating and continually mutating a single environment specification.
this would greatly reduce the cost of validation.viii.
r elated work previous work has concentrated on evaluating the executability of code in the context of its configuration.
sul r and porub an find of java builds fail due to dependency related errors .
mcintosh et al.
agree that build maintenance imposes a large overhead on developers .
yang et al.
evaluate python code snippets as do horton and parnin .
they find that python code snippets are not executable by default due to configuration errors and horton and parnin additionally highlight the difficulty of correct configuration of which inferring correct dependency versions ranks highly.
additional studies have focused specifically on how developers manage dependencies and versions within environment configuration.
xavier hora and valente note that developers deliberately make breaking changes to apis for several reasons related to code maintenance .
further developers struggle with different options for specifying dependency versions that are supported by many package management systems and analysis of such systems motivates the need for better tooling to deal with problems related to versions .
although these works demonstrate that configuration of dependencies is a frequent cause of build and execution failure and that developers have need of better tooling support of versions no study attempts to uncover instances of configuration drift automatically.
horton and parnin do classify code snippets which have drifted and only execute successfully with an older version of a dependency table ii from gistable but this classification was performed by manually generating configuration scripts.
existing work has been performed on the automatic repair of environment configurations.
weiss et al.
presented tortoise a system which synthesizes patches for configuration scripts but can only do so by analyzing recorded developer actions .
horton and parnin work on inferring working environment configurations without the need of developer interaction but they crucially ignore dependency versions .
work by macho et al.
and by hassan and wang has presented automated repair of configuration scripts that includes version modifications.
these are the closest related works of which we are aware.
crucially both techniques require an existing environment configuration and neither approach uses feedback to guide search.
in addition they focus on the java build ecosystem and cannot repair python code snippets.
macho et al.
prioritize versions using a distance metric that prefers small version changes.
hassan and wang generate a ranked list of all possible patches and exhaustively apply them until some patch succeeds or there are no more patches to apply.
neither approach attempts to prune the configuration space and prioritization is limited.
there are approaches that use feedback and historical knowledge but they focus on code not computing environments.
this work presents an improvement over previous approaches by incorporating feedback and prior knowledge for more efficient identification of repairs.
we also focus on identifying instances of configuration drift in code determining authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
when dependencies have been updated and synthesizing a patch as a proof of existence.
this is in contrast to other approaches which focus on an existing environment configuration and assume failures result from the code being updated.
ix.
c onclusion motivated by the problem of detecting out of date code snippets we implement v2.
v2 discovers instances of configuration drift in python code snippets where each instance is identified by looking for crashes that can be fixed with modifications to versions of installed dependencies.
two techniques lie at the heart of v2 s ability to uncover configuration drift.
the first is feedback directed search a search strategy that uses information gleaned from executing a code snippet to determine which portion of the configuration space to explore next.
the second is a corpus of version upgrade matrices that describe the before and after build statuses for over seven thousand package upgrade events in open source python projects.
these version upgrade matrices allow v2 to significantly prune the configuration space and effectively prioritize the remaining states leading to faster discovery of working configurations.
v2 found instances of configuration drift in the gist and jupyter datasets.
it was able to do so quickly requiring many fewer validations than a baseline prioritization strategy.