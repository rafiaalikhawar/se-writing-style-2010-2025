scalable incremental building with dynamic task dependencies gabri l konat delft university of technology delft the netherlands g.d.p.konat tudelft.nlsebastian erdweg delft university of technology delft the netherlands s.t.erdweg tudelft.nleelco visser delft university of technology delft the netherlands e.visser tudelft.nl abstract incrementalbuildsystemsareessentialforfast reproduciblesoftwarebuilds.incrementalbuildsystemsenableshortfeedbackcycles when they capture dependenciesprecisely andselectively execute build tasks efficiently.
a much overlooked feature of build systems istheexpressivenessofthescriptinglanguage whichdirectlyinfluencesthemaintainabilityofbuildscripts.inthispaper wepresentanewincrementalbuildalgorithmthatallowsbuildengineerstouse a full fledged programming language with explicit task invocation value and file inspection facilities and conditional and iterative languageconstructs.incontrasttopriorworkonincrementalityfor suchprogrammablebuilds ouralgorithmscaleswiththenumber oftasks affectedbya changeandisindependent ofthesize ofthe softwareprojectbeingbuilt.specifically ouralgorithmacceptsa set of changed files transitively detects and re executes affectedbuild tasks but also accounts for new task dependencies discov ered during building.
we have evaluated the performance of our algorithm in a real world case study and confirm its scalability.
ccs concepts softwareanditsengineering softwareconfigurationmanagement and version control systems keywords scalable incremental build dynamic task dependency acm reference format gabri lkonat sebastianerdweg andeelcovisser.
.scalableincrementalbuildingwithdynamictaskdependencies.in proceedingsofthe2018 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.
introduction virtually every large software project employs a build system to resolvedependencies compilesourcecode andpackagebinaries.
one great feature of build systems besides build automation isincrementality after a change to a source or configuration file only part of a build script needs re execution while other parts can bereusedfromapreviousrun.indeed incrementalbuildsystems permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
for all other uses contact the owner author s .
ase september montpellier france copyright held by the owner author s .
acm isbn .
keyenablerfor shortfeedbackcycles.the reliableandlongterm maintainable usage of incremental build systems requires the following three properties efficiency themostobviousrequirementisthatrebuilds must be efficient.
that is the amount of time required for a rebuild must be proportional to how many build tasks are affectedbyachange.specifically asmallchangeaffecting few tasks should only incur a short rebuild time.
precision an incremental rebuild is only useful if it yields the exact same result as a clean build.
to this end incrementalbuildsystemsmustcaptureprecisedependencyinformation aboutfile usageand task invocations.make like build systems do not offer means for capturing precise dependencies.
instead over approximation .h leads to inefficiency because of considering too many files and underapproximation mylib.h leadstoincorrectrebuildsbecause ofmissingdependencies e.g.
other.h .precisedependency information is required for efficient and correct rebuilds.
expressiveness like all software artifacts build scripts grow during a project s lifetime and require increasing maintenance .
therefore build scripts should be written in expressive languages avoiding accidental complexity.
thatis buildscriptinglanguagesshouldnotrequirebuild engineerstoapplycomplicated designpatterns e.g.
recursive or generated makefiles for expressing common scenarios.
currentincrementalbuildsystemsputaclearfocusonefficiency andprecision butfallshortintermsofexpressiveness.inparticular in order to support incremental rebuilds current systems impose a strictseparationofconfigurationandbuildstages.allvariability of the build process needs to be fixed in the configuration stage whereas the build stage merely executes a pre configured build plan.
this model contradicts reality where how to build an artifact dependsontheexecutionofotherbuildtasks.wehaveobserved twosourcesofvariabilityinbuilding.first basedontheresultof other tasks conditional building selects one of multiple build tasks toprocessacertaininput.second basedontheresultofothertasks iterative building invokes build tasks multiple times on different inputs.inbothcases dependenciesontaskinvocationsonlyemerge during the build build engineers cannot describe these dynamic dependencies in the configuration phase.
we illustrate a concrete example in section .
a solution to the expressiveness problem is to provide build engineers with a full fledged programming language.
in such a system buildtasksareproceduresthatcaninvokeotherbuildtasks intheirbody.buildtaskscaninspecttheoutputofinvokedtasks andusethattoconditionallyanditerativelyinvokefurthertasks.
the problem of such a programmable build system is that it is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gabri l konat sebastian erdweg and eelco visser difficult to achieve incrementality.
we are only aware of a single build system that is both programmable and incremental pluto .
unfortunately the incremental build algorithm of pluto has an importantlimitation tocheckwhichtasksneedre execution pluto needstotraversetheentiredependencygraphofthepreviousbuild and has to touch every file that was read or written in the previousbuild.
this contradicts our first requirement efficiency because the rebuild time of pluto depends on the size of the software project more than it depends on the size of the change.
in particular even when no file was changed pluto s algorithm requires seconds to determine that indeed no task requires re execution.
we illustrate pluto s algorithm using an example in section .
in this paper we design implement and evaluate a new incremental build algorithm for build systems with dynamic task dependencies.
while pluto s algorithm only takes the old dependency graphas input andtraverses ittop down ouralgorithm also takes a set of changed files and primarily traverses the dependency graphbottom up.wecancollectchangedfiles forexample from ides that manage their workspace or by using a file system watchdog.
our algorithm uses the changed files to drive rebuilding of tasks only loading and executing those tasks that are transitively affected by a change.
however due to dynamic task dependencies thedependency graphcan changefrom onebuild tothe nextone.
ourbuildalgorithmaccountsfornewlydiscoveredanddeletedtask dependencies by mixing bottom up and top down traversals.
ournewincrementalbuildalgorithmprovidessignificantperformance improvements when changes are small.
we have conducted areal worldcasestudyonthespoofaxlanguageworkbench atool builtfordevelopingdomain specificlanguages dsls .thebuild script of spoofax processes dsl specification files and generates interpreters compilers andideplug insforthem.wefoundthat our algorithm successfully eliminates the overhead of large dependency graphs and provides efficient rebuilding that is proportional to the change size.
insummary wemakethefollowingcontributions.wereview programmaticbuildscripts incrementalbuildingwithpluto and why this does not scale section .
we describe our key idea of bottom up incremental building and what is needed to make it work section wepresentourhybridincrementalbuildalgorithm thatmixesbottom upandtop downbuilding section andbriefly discussitsimplementation section .weevaluatetheperformance ofthehybridalgorithmagainstpluto salgorithmwithacasestudy on the spoofax language workbench section .
background and problem statement mostbuildsystemsprovidea declarative scriptinglanguage.declarativelanguagesaregreatastheyletdevelopersfocuson whatto compute rather than howto compute it.
however we argue that declarativityismisdirectedwhenitcomestodescribingsophisticated build processes that involve conditional and iterative task application.
for example consider the build script in figure .
we wrote this buildscriptinthepiebuildscriptlanguage whichmostlyprovidesstandard programminglanguageconcepts.
thatis the build script performs iterative building by defining and calling functionsfunc main string val config parseyaml .
config.yaml val src config.srcdirif config.checkstyle val styleok checkstyle src if config.failonstyle !styleok return style error val usertests .
test val gentests gentests src .
test gen var failed for test usertests gentests val testok runtest test if !testok failed return failed tests failed func parseyaml p path config ... func checkstyle src path bool ... func gentests src path trg path path ... func runtest test path int ... figure build script that invokes tasks conditionally anditeratively at build time.
tasks like mainandparseyaml stores results of tasks in local variablessuchas configandsrcwhichcanbeimmediatelyused bysubsequenttasks andinvolvesconditionalbuildingwithcontrol structureslike ifandfor.byandlarge ourbuildscriptisanormal program that happens to handle file paths and invoke external processes to generate and run tests.
but how can we execute such a programmatic build script incrementally?
most build systems require declarative specifications of build tasksforthisreason tosupportefficientincrementalrebuilds.however erdweg et al.
demonstrated that it is also possible to incrementallyexecuteprogrammaticbuildscripts with pluto abuild system that incrementally executes build scripts written in java.
thepielanguageweusedinourexampleisanalternativefront end to pluto .
the build algorithm of pluto constructs a dependency graph of a build while the build script runs.
for example consider thedependency graph of our example script in figure .
the dependency graph contains a node for each invoked task and for each read or written file.
edges between nodes encode dependencies.
a task depends on the tasks it invokes and on the files it reads or writes.
moreover when a task reads a file that was generated by another task the reading task depends on the generating task such thatthegeneratingtaskisexecutedfirst.whilenotshowninour graph both task task edges and task file edges are labeled with stamps e.g.
timestamp hashsum thatdetermineifthetaskoutput respectively file content is up to date.
the incremental build algorithm of pluto takes the dependency graphofthepreviousrunandselectivelyrerunstaskstoensurecon sistencyofthebuild.thedependencygraphofabuildisconsistent if for each invoked task i all read and written files are up to date and ii theoutputsofallcalledtasksareup to date.anincremental authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scalable incremental building with dynamic task dependencies ase september montpellier france mainparse yaml .. check style .. gen tests .. .
config .yaml .
src a .
src b. src b aux .
testgen a. testgen b. test x runtest mainparse yaml .. check style .. gen tests .. .
config .yaml .
src a .
src b. src b aux .
testgen a. testgen b. test x runtestmainparse yaml .. check style .. gen tests .. .
config .yaml .
src a .
src b. src b aux .
testgen a. testgen b. test x runtest.
src c .
testgen c runtestinitial dependency graphchange c1 change c2 change c3reads file writes file requires task affected by changemainparse yaml .. gen tests .. .
config .yaml .
src a .
src b. src b aux .
testgen a. testgen b. test x runtestcheck style .. figure the dependency graph of a build captures task and file dependencies and is the basis for incremental building.
buildalgorithmiscorrectifitalwaysrestoresconsistency .or intuitively acorrectincrementalbuildalgorithmyieldsthesame result as a clean build.
the challenge is to restore consistency with as little computational effort as possible.
forexample letusassumetheinitialdependencygraph top left infigure isconsistenttobeginwith.
wediscussthreedifferent changesc1 c3 c1 if we change file config.yaml to turn off style checking task mainbecomes inconsistent since the stamp of its file dependency changes e.g.
newer timestamp changed hashsum .
we can restore consistency by rerunning tasks parseyaml andmainonly all other tasks remain consistent sincetheyneitherinvoke mainnorreadfileswrittenby main.
the incremental build yields a new dependency graph topright in figure where the new invocation of maindoes not depend on checkstyle anymore.
c2 if instead we change the content of user test .
test x taskruntest .
test x becomes inconsistent and needs rerunning.sincetask maincallsruntest .
test x itneeds rerunning if the value returned by runtestchanges such that we obtain a different number of failedtests.
either way the dependency graph remains unaffected bottom left in figure .
c3 finally ifweaddasourcefile .
src c taskscheckstyle andgentests are affected because they depend on the directory.
src.
if the new file has a style error this affects mainandyieldsanewdependencygraphwherenotesting occurs notshown .otherwise letusassume gentests produces a new test .
test gen c for the added file which affectsmain s scan of directory test gen .
during the subsequent rerun of main we discover a new task invocation runtest .
test gen c bottom right in figure .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gabri l konat sebastian erdweg and eelco visser the incremental build algorithm of pluto can handle these and anyotherchangescorrectly.moreover thealgorithmisoptimally incrementalinthesensethatitonlyexecutesataskifabsolutely necessary.
the basic idea of the algorithm is to start at the root node s ofthedependencygraph totraverseitdepth first andto interleave consistency checking and rerunning.
in particular while rerunningataskthatinvokesanothertask iftheinvokedtaskexists inthedependencygraph continuewithconsistencycheckingof theinvokedtaskandonlyrerunitifnecessary.thisinterleaving of consistency checking and rerunning is what enables support for conditional and iterative task invocations.
problem statement.
the incremental build algorithm of pluto hasanimportantlimitation.irrespectiveofthechangedfiles ithas to traversethe entiredependency graphto check consistencyand todiscovertasksthatneedrerunning.whilethatmaybefinefor largerchangesthataffectlargepartsofthegraphlike c3 theoverheadforsmall impactchangeslike c2issignificant.especiallyin interactive settings where developers routinely trigger sequences of small impact changes this overhead can quickly render the systemunresponsive.theproblemisthatthealgorithmdoesnot scale downtosmallchangeswhen scalingup tolargedependencygraphs.
our goal is to design realize and evaluate a new incremental build algorithm for programmatic build scripts that scales in thesize of a change.
that is rebuild times should be proportional to the impact a change has on the overall build.
in particular rebuild timesshouldbeindependentofthesizeofthedependencygraph.
these requirements preclude a full traversal of the dependency graph to discover affected tasks as done by pluto.
instead our new algorithmtakesthesetofchangedfilesasinputandonlyevervisits affected tasks.
key idea and challenges thekeyideatoincreasingthescalabilityoftheplutoalgorithmisto executetasks bottom up.inthissection wemotivatethisapproach and we discuss the corner cases that require adjustments to a pure bottom up algorithm.
.
bottom up traversal thekeyproblem ofthepluto buildalgorithmis thatit visitsand checks tasks that are ultimately unaffected.
for example in change c2in section only a single task runtest is affected by the change to file .
test x .
however pluto will visit and check all reachabletasksinatop downdepth firsttraversal includingthe tasks that are not affected by the change parseyaml checkstyle andgentests .
establishing that these tasks are unaffected is expensive as our benchmarks demonstrate section .
to make the algorithm scale it should only visit the nodes of thedependencygraphthatareactuallyaffectedbyachange.the changesthattriggerare buildareto files whichareatthe leavesof thedependencygraph.tasksthatneedtoberecomputeddepend directly or indirectly on such file changes.
instead of looking for tasksthatmayindirectlydependonachangeandgraduallygettingcloser to the actual change as pluto does why not start with those changes and the tasks that depend on them?thekeyideaofouralgorithmisto traversethedependencygraph bottom up driven by file changes only visiting and checking affected tasks.
the algorithm first executes the tasks that are directly affectedbychangedfiles.forexample inchange c2 file.
test x changes which directly affects task runtest .
test x which must therefore be re executed.
tasks can also be indirectly affected byafilechange namelywhenitreadsafileproducedbyanaffectedtaskorwhenitreadstheoutputvalueofanaffectedtask.forexam ple inchange c3 file.
src cisadded whichtriggersre execution ofgentests whichyieldsanewoutputvaluetomain whichthus is indirectly affected re executes and creates a new runtest task.
a subsequent edit of file .
src ctriggersgentests again which producesthesamevalueasbeforebutupdatesthegeneratedfile .
test gen c which affects the corresponding runtest task the maintask is not affected this time .
thus abottom uptraversalexecutestasksthatareaffectedby changed files or by other affected tasks following a path from the changedleavesofthedependencygraphtotheroot s .however a pure bottom up traversal is not adequate to support program matic build scripts with dynamic dependencies.
we discuss the adjustments that are necessary to realize an adequate algorithm.
.
top down initialization in order to perform a bottom up traversal over the dependencygraph we need a dependency graph to start with.
therefore we startwithpluto stop downalgorithmtoobtaintheinitialdependency graph.
this is efficient since every task is affected in the initial build.
.
early cut off by default a bottom up traversal takes the transitive closure of dependencies re executingalltasksonthepathfromachangedfile to the root s of the dependency graph.
however re execution of a taskdoesnotalwaysleadtoanewresult.iftheresultwasthesame as before thepath to the root canbe cut off early.for example in c2maindependson runtest .
test x whichdependsonthe changed .
test x file.
so do we need to re execute main?
that depends on the output of task runtest .
test x .
if the result isadifferent integer valuethanbefore thenumberofteststhat fail changes and mainshould be re executed otherwise mainis not affected and we can cut off the build early1 as shown in the bottom left part of figure .
.
order of recomputation anotherpotentialproblemofnaivebottom upevaluationisthat tasks may be executed multiple times.
for example in change c3 maindepends on two existing affected tasks checkstyle and gentests .apossibleexecutiontracewhen checkstyle doesaffect main notshowninthefigure istoexecute checkstyle thenmain whichisaffectedby checkstyle thenexecute gentests andthen executemainagainbecauseitisaffectedby gentests .executinga task multiple times is not onlyinefficient but also causes glitches inconsistent results that are exposed to users.
1in a real world build script runtestwould output a report of which tests fail and why and mainwould be re executed whenever this changes.
we support this but chose to keep the example from section 2simple for demonstration purposes.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scalable incremental building with dynamic task dependencies ase september montpellier france to avoidsuchre executions weshould ensurethatall affected dependenciesofataskareexecutedbeforethetaskitself.instead of eagerly executing tasks when encountered during a bottom up traversal we scheduletasksinapriorityqueue whichistopologically sorted according to the dependency graph.
until the queue is empty scheduledtasksareremovedfromthefrontofthequeueand executed.thetopologicalorderingofthepriorityqueueensures that task dependencies are executed before the task itself.
.
dynamic dependencies thefinalchallengeistosupportdynamicdependenciesduringa bottom up traversal.
consider change c3again where a new task runtests .
test gen c isdiscoveredby main.abottom uptraversalcanneverdetectsuchadynamicdependency sinceitonly hasaccesstothedependencygraphofthepreviousrun.toremedy this we temporarily switch to top down depth first building when executingatask sothatthetaskcandiscoverdependenciestonew tasks discover dependenciesto existingtasks or removeexisting dependencies.
when discovering a dependency to a new task top down depthfirst building continues recursively by eagerly executing the new task.forexample inchange c3 taskmainis indirectly affected and thus is built in a top down manner after its dependencies checkstyle andgentests havebeenbuilt whichrecursivelycalls taskruntests .
test gen c and registers a dependency to it.
furthermore whenadependencyisdiscoveredtoatask tthatexists intheolddependencygraph itmightbeaffectedalready.thatis t and dependencies of tmay have been scheduled in the queue.
we cannot execute tbefore executing its dependencies.
therefore we temporarilyswitchbacktobottom upbuilding executingdependenciesof tthatarescheduledinthequeue until titselfisexecuted or found unaffected.
then we switch back to top down buildingand continue executing the caller.
finally when a dependency is removed i.e.
dependency to a task that was made in the previous run but not in this run the dependency graph is updated but no further action is taken.
.
dependency graph validation asintheplutoalgorithm wealsoneedtoenforcevalidityofthe dependencygraphbydetectingoverlappinggeneratedfiles hidden task dependencies and cyclic tasks.
an overlapping generated file occurs when more than one task generates creates or writes to the same file.
this makes it unclear in which order those tasksmust be executed to bring the file into a consistent state and istherefore disallowed.
furthermore a hidden dependency occurs whenataskrequires reads afilethatwasgeneratedbyanother task withouttherequiringtaskdependingonthegeneratortask.
suchadependencymustbemadeexplicit sothatthegeneratedfileisupdatedbythegeneratortaskbeforebeingreadbytherequiring task.
finally a task is cyclic when it indirectly calls itself.
we disallow cyclictasks toensure terminationof the buildalgorithm.
wechecktheseinvariantson the flywhileconstructingthenew dependency graph for subsequent incremental builds.
vartq varte varoc vardgnew function buildnewtask t dgold te oc dgnew dgold exec t function buildwithchangedfiles f dgold te oc dgnew dgold tq new priorityqueue dgold.deporder schedaffbyfiles f dgold whiletq nequal do execandschedule tq.poll dgold figure algorithm main build functions.
function execandschedule t dgold valr exec t schedaffbyfiles r. enfiles dgold schedaffcallersof t r.output dgold returnr.output function schedaffbyfiles f dgold forf fdo for stamp t dgold .requireesof f do if stamp .isconsistent f then tq tq t if stamp t dgold .generatorof f then if stamp .isconsistent f then tq tq t function schedaffcallersof t o dgold for stamp tcall dgold .callersof t do if stamp .isconsistent o then tq tq tcall figure algorithm bottom up building.
function exec t ift tethenabort te te t valr t.run te te t dgnew dgnew r validate t r observe t r.output oc r.output returnr.output function require t dgold ifo oc then return o else ift dgoldthen return requirenow t dgold else return exec t function requirenow t dgold whilevaltmin tq.leastdepfromoreq t do tq tq tmin valo execandschedule tmin dgold ift tmin then return o valo dgold .outputof t observe t o oc o returno function validate t r forf r. enfiles do for t en dgnew .generatorof f do ift nequalt en thenabort forf r.reqfiles do for t en dgnew .generatorof f do if dgnew .callstasktr t t en thenabort figure algorithm execution requirement and valida tion.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gabri l konat sebastian erdweg and eelco visser change driven incremental building in this section we present our hybrid algorithm that mixes bottomupandtop downincremental buildingbasedontheobservations andideasfromtheprevioussection.wepresentthealgorithmin threeparts mainfunctions figure bottom upbuilding figure and execution figure .
all functions share four global variables definedatthetopoffigure .variable tqisatopologicallyordered priority queue of affected tasks that still need to be executed.
variableteis a set of currently executing tasks used to detect cyclic tasks.
variable ocis a cache of output values for tasks that have alreadybeenexecuted.finally variable dgnewisthenewdependency graph that is constructed from the old dependency graph and dynamic dependencies on the fly.
weprovidetwoentrypointstoincrementalbuildinginfigure both of which first clear the set of executing tasks te clear the cacheoc and copy the old dependency graph dgoldtodgnew.
function buildnewtask istheentrypointforaninitialbuild.functionbuildnewtask then simply invokes function exec figure5 to execute the task.
we describe execbelow.
the second entry point buildwithchangedfiles is more interestingasitinitiatesbottom upbuilding.ittakesasinputasetof changed file paths f represented as filesystem path strings such as .
config.yaml andtheolddependencygraph dgold.thebasic ideaistoscheduleandrunaffectedtasksusingpriorityqueue tq until all affected tasks are up to date.
to this end we create a new priority queue using the task dependencies in dgoldas a topological ordering.
we call function schedaffbyfiles described below with the old dependency graph to find all tasks directlyaffected by the changed file paths f and add those tasks to the queue tq.
themainloopofbottom upbuildingisthefollowing while loop as long as there are affected tasks in the queue poll a scheduled task retrievethetaskatthefrontandremoveit fromthequeue execute it and add all tasks affected by it to the queue.
since the queue is topologically ordered dependencies of tasks are executed before the task itself.
unless a task itself does not terminate for exampleby recursivelycallingnewtasks adinfinitum thequeue becomes empty at some point since cyclic tasks are disallowed terminating the algorithm.
.
bottom up building whenever a task occurs in the priority queue tq it is definitely affected directly or indirectly by changed files.
hence no further consistency check is necessary.
function execandschedule in figure4acceptsanaffectedtask runsitunconditionallyusing exec andschedulesnewtasksbasedonthegeneratedfilesandoutput value of the executed task.
if a task does not change or create new generated files nor produce a new output value no new tasks will be scheduled and building may be cut off early.
function schedaffbyfiles schedulestasksbasedonchanged filepaths f.iftasktrequiresachangedfileandthestamp stamphas changed isinconsistent then tisaffectedbythechangeto fandis scheduled by adding it to tq.
analogously if a task generates a file thathaschanged itisaffectedandthusscheduled.astampcontains asummaryofafile scontent suchasthelastmodificationdateorahash andisusedtoefficientlycheckwhetherafilehaschangedwithisconsistent .forexample whenusingthefile smodificationdate asastamp wecomparethemodificationdateinthestamp with thecurrentmodificationdateofthefileonthelocalfilesystem and considerthefilechangedifthemodificationdateisdifferent.we use the old dependency graph dgold computed in a previous run ofthealgorithm tofindtasksthatrequireafile requireesof and to find the task that generates a file generatorof along with the stamp that was produced at the time the dependency was created.
likewise the schedaffcallersof function schedules callers of tasktbased on changes to its output value o.i ftcallhas a dependency to task t and that dependency is inconsistent with relation to the new output value ooft thentcallis affected by the new output value oand is scheduled.
similarly we use a stamp oftheoutputvalue whichcouldbethefulloutputvalue suchas anintegerrepresentingthenumberoffailingtests orasummary ofthevaluesuchasahash andcomparethestampwiththenew outputvaluewith isconsistent .finally theolddependencygraph dgoldis used to find callers of a task with callersof.
.
execution requirement and validation function exec figure5 executes the body of t. during task execution a task may require call other tasks with the require function.therefore wefirstneedtocheckifwearealreadyexecut ingtask t andabortwhenacycleisdetected.then weadd ttothe set of executing tasks te runthe body of the task and remove t fromte.onceexecutioncompletes weupdatethenewdependency graphdgnewwiththeresult rofexecuting t.aresult rcontains thedynamicdependenciesthetaskmadeduringexecution aset reqfilesofreadfiles enfilesofcreatedorwrittentofiles anda setreqtasks of other tasks that were called by t and the output valueoutputthat the taskproduced.
a dependency graph dgis a set of those results where each task has a single result.
we then validate thenewdependencygraph callanyexternalobservers of the task s output with observe cache the output and finally return the output.
weusefunction exectoexecutetasksbothduringbottom up and top down traversals.
while execis agnostic to the traversal order function requiremust take care to handle tasks required bottom up and top down correctly.
we distinguish three cases.
if t wasalreadyexecuted visited thisrun wereturnitscachedoutput valueoc .
otherwise we check if twas in the old dependency graphdgold.
if tasktis new and does notoccur indgold then we execute it unconditionally.
note that no existing task in dgold can depend or be affected by the new task t. iftasktexistedbeforein dgold weonlyexecuteitifitisactually affected.sincethecallerof tawaitstheoutputof t weusefunction requirenow toforceitscheckingandpossibleexecution now.task tis affected if it occurs in queue tqor if any of its dependencies occurringin tqwillaffectitlater.function requirenow repeatedly finds dependency tminoftthat is lowest in the dependency graph closes to the leaves .
since the queue only contains affected tasks we execute tminand schedule tasks affected by it.
we continue until either we have executed the required task t or until no more dependenciesoftask tareaffectedandwecanreuse t soutputvalue from the old dependency graph with dgold .outputof t .
note that this latter case always triggers for tasks scheduled bottom up authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scalable incremental building with dynamic task dependencies ase september montpellier france bybuildwithchangedfiles because their dependencies cannot occur intqanymore.
thevalidate function incrementally validates the correctness of the new dependency graph after executing a task t. for a dependency graph to be correct it may not have overlapping generated files nor any hidden dependencies.
if another task t engenerates the same file fastdoes there is an overlapping generated file and execution is aborted.
furthermore if trequires a file fwithout a transitive task dependency on t enthat generates f there is a hidden dependency and execution is aborted.
in both cases this signals that there is an error in the build script.
.
properties anincrementalbuildalgorithmiscorrectifitproducestheexact sameresultasacleanbuild.therefore allaffectedandnewtasks must be executed.
our algorithm is correct for tasks in the old dependency graph if a task is affected it will be scheduled.
a task is affected directly by depending on a changed file or indirectly transitively bydepending ona changedfile that anaffected task generates orbydependingonthechangedoutputofanaffected task.
all indirectly affected tasks are always found by traversing thedependencygraphbottom up throughpollingthequeueand scheduling affected tasks.
finally all scheduled tasks are executed.
our algorithm is also correct for new tasks that are executed top downliketheplutoalgorithm whichiscorrect .theonly difference is the reqirenow function which first executes the dependencies of the task but does eventually execute the task itself.
therefore the hybrid algorithm is correct.
for optimality we only consider and execute affected tasks.
for existing tasks this is true because only affected tasks scheduled.
newtasksareaffectedandalwaysexecuted.however weonlywant to execute neededtasks.
the hybrid algorithm considers all task in theolddependencygraphasneeded.thisisanoverapproximation because it can happen that an affected task is not needed any more after top down execution since a task may remove its dependency toanaffectedtask.therefore theoretically thehybridalgorithmis onlypartiallyoptimal.ho wever this is a rare case as shown in the evaluation in section .
implementation wehaveimplementedthehybridalgorithmasanalternativeexecutionalgorithmforpie asystemfordevelopinginteractive softwaredevelopmentpipelines consistingofadslandapifor implementing interactive pipelines and a runtime for incrementallyexecutingthem.interactivesoftwaredevelopmentpipelines are similar to incremental build systems they are used to incrementally build software artifacts and also require fast feedback for usage in interactive environments with many low impact changes such as ides and code editors.
pie builds forth on pluto by reusing itsmodelandalgorithm butprovidesaconciseandexpressivedsl fordevelopinginteractivepipelinesandbuildscripts minimizing boilerplate in contrast to pluto s java api.
our algorithm is implemented as a separate executor in the pie runtime fullyconformingtoitsapi.thatis wecanrunexisting piebuildscriptswithoutchangestoouralgorithm.furthermore sincepieimplementstheplutobuildalgorithm wecancompareour algorithm against pluto s for the exact same build scripts.
pie includingourhybridalgorithm isopensourcesoftwarethatcan be found online2.
evaluation inthissection weevaluatetheperformanceofthehybridalgorithm compared to pluto s pure top down algorithm.
we describe our experimentalsetup showtheresults interpretthem anddiscuss threats to validity.
.
experimental setup we compare the performance of the pluto incremental build algorithm as implemented in the pie runtime against our hybrid incrementalbuildalgorithm whichwehaveimplementedinpie runtime.
build script.
asabuildscript wereusethespoofax piepipeline areimplementationofalargepartofthespoofaxpipeline which was used as a case study of pie .
spoofax is a language workbench asetoftoolsfordevelopinglanguages inwhichlanguagesare specifiedinterms ofmeta languages suchas sdf forsyntaxspecification andnabl fornameandtype analysis.
the spoofax pipeline derives artifacts from a languagespecification such as a parse table for parsing and a constraint generatorand solverforsolving nameandtypeanalysis.
furthermore spoofax supports interactive language development in an idesetting enablingalanguagedevelopertomodifyalanguage specification resultinginimmediatefeedbackinexampleprograms of that language and also supports developing multiple languages side by side.
the spoofax pie reimplementation supports these features.
the build script is open source and can be found online3.
asinput thespoofaxbuildscripttakesaworkspacedirectory consisting of language specifications where each language specificationhasaconfigurationfiledescribinghowtobuildthelanguage specification aspecificationofthesyntax styling andnameand typeanalysisinmeta languages andexampleprograms.aconfiguration file at the root of the workspace lists the locations of all language specifications and locations of the spoofax meta languages.
as a concrete workspace we use a directory with three spoofax languagespecificationsforthetiger calc andminijavalanguages.
describingthespoofaxbuildscriptisoutsideofthescopeofthis paper.however wedoarguewhyspoofaxrequiresaprogrammatic build script with dynamic dependencies.
the spoofax build script frequently makes use of conditional building where the resultof executing a task influences a condition for another task.
forexample when a program fails to parse the program cannot be analyzed since analysis requires an ast.
therefore a condition that checks whether the parsing task succeeds guards the analysis task.
furthermore spoofax also makes frequent use of iterative building where tasks are invoked multiples on different inputs which are outputs of previous tasks.
for example there is a single task description for parsing a file which is dispatched based on theresultofparsingtheworkspaceconfigurationfile parsingthe language specification configuration files the concrete files thatare in the workspace and the extension of each file.
without a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gabri l konat sebastian erdweg and eelco visser programmaticbuildscript alltheseformsofvariabilitywouldhave tobeencodedintheconfigurationstepofadeclarativebuildscript which is not possible because many values only become evident during build script execution.
changes.
tomeasureincrementalperformance wehavesynthesizedachainof60realisticchangeswithvaryingimpacts.first a from scratch buildis performedthat builds alllanguage specifications.
then we make changes in the form of opening or changing atexteditor requiringexecutionofataskthatprovidesfeedback for that editor or of modifying and saving a file which requires execution of tasks that keep the workspace up to date.
changes include editing and saving example programs styling specifications syntax specifications and name and type analy sis specifications adding a new language specification un changes and two extreme cases where we run the build with no or allfileschanged.thesechangeshavevaryingimpacts wherethe impact is determined by how many tasks are affected by a change andtheruntimeofthosetasks.forexample changingasyntaxdefi nitionfilerequiresrecompilationoftheparsetableandreparsingof all example programs.
changing the name and types specification has a larger impact because it requires regeneration of a constraint generator compilationoftheconstraintgenerator applicationof thegeneratoragainstallexampleprograms andfinallyapplication of the constraint solver to solve all generated constraints.
a small impactchangeiseditinganexampleprograminaneditor which just requires parsing styling and analysis for that program.
weruntheexactsamechangesagainsttheplutoandourhybrid algorithm withtheonlydifferencethatwepassthechangedfilesto our hybrid algorithm whereas pluto does not require this.
we run thechainofchangesagainstonealgorithminonego tosimulatea full editing session.
technicalities.
we run the benchmark using the jmh benchmarkingframework whichrunsthebenchmarkforanalgorithm in a separate forked jvm letting the jvm jit fully specialize to that algorithm.
furthermore it runs the benchmark multiple times beforestartingmeasurements toensurethatthejvmiswarmed up.
finally it ensures that the garbage collector is executed before running a benchmark so that garbage produced in a previous run does not influence the new one.
wehave executedthe benchmarkon amacbookpro witha .
ghz intel core i7 processor gb of mhz ddr3 memory andassd runningmacos10.
.
.thebenchmarkwasexecuted witha64 bitjreofversion1.
.0b144 with16mbofstackmemory and gb of heap memory.
.
results and interpretation wenowshowthebenchmarkingresultsandinterpretthem.itisnot possibletodiscusstimemeasurementsforall60changes.therefore we aggregate the time taken for different kinds of changes and show those instead.
figure 6shows the time measurements for eachaggregatedchange forboththeplutoandhybridalgorithm inacolumnchartwithlogarithmicscale.wenowgoovertheresults for each kind of change.
a initial build.
first we perform an initial build building all language specifications.
to obtain the initial dependency graph we use top down building.
therefore both the pluto and hybrid algorithm perform identically.
b editor changes.
weaggregatetherunningtimeforalleditor changes both opening new editors and editor text changes for exampleprogramsandlanguagespecifications.foralleditorchanges combined the hybrid algorithm is seconds faster providing a speedupof1016 .thespeedupishighbecausethesechangeshave a small impact and therefore are efficiently handled by the hybrid algorithm.itisimportanttoquicklyprocesseditorchangesinides as programmers make many changes to editors and require fast feedback cycles.
c example program file changes.
we modify the files of several example program and add a new example program file.
for these changes combined the hybrid algorithm takes .
seconds providing a second speedup.
again these changes have a small impact and are therefore efficiently handled by the hybrid algorithm whereastheplutoalgorithmstillrequirescheckingof the entire dependency graph.
d styling specification change.
we modify the styling specificationofthecalclanguage andaddastylingspecificationtothe tigerlanguage.forthesechanges thehybridalgorithmis8seconds faster providing a speedup.
the impact of these changes areslightlylarger changestothestylingspecificationrequirerestylingofopeneditors butarestillrelativelysmallerinimpactand thus efficiently handled.
e adding language specification.
we add the minijava language totheworkspace requiringittobebuilt anditsexampleprograms to be processed.
since this change causes many new tasks to be executed itsimpactislarge.thehybridalgorithmperformsroughly the same as the pluto algorithm providing only a .
second speedup because of reduced dependency graph checking.
f syntax specification small change.
wemodifylexicalsyntax definitionofthecalclanguagetoparsenumbersincorrectly and undo the change afterwards.
this requires the parse table to be rebuilt andrequiresprocessingofcalc sexampleprograms.the hybridalgorithm providesa .5second speedup becausea smaller part of the dependency graph is checked.
g syntax specification cascading change.
we modify the calc syntax definition in such a way that the resulting parser will failto parse all example programs and also in such a way that new astsignaturesneedtobegenerated.fromthesyntaxspecification spoofax generates ast signature files that the name and type analysisuses.thesesignaturefileshavechanged thereforerequiring the name and type analysis specification to be recompiled.
finally all example programs must be reparsed and reanalyzed.
however becauseexampleprogramscannotbeparsedanymore theyalsocannotbeanalyzedanymore sincenameandtypeanalysisrequiresanast.therefore thedependencyfromtheprocess example file task to the task that analyzes the ast of an example program disappears.
the pluto algorithm first visits the processexample file task which removes its dependency to the analysistask and therefore never recompiles the name and type analysis specification.
however the hybrid algorithm goes bottom up to firstrecompilethenameandtypeanalysisspecification andonly thenexecutestheprocessexamplefiletask thereforeexecutinga authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scalable incremental building with dynamic task dependencies ase september montpellier franceaggregate runtime in seconds 1s10s100s abcdefgh i jkl70.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.1pluto hybrid .
.
.
figure6 columnchartwithaggregatebenchmarktimemeasurements.thex axisrepresentthedifferentchanges described below the y axis represents the time taken in seconds in logarithmic scale.
for each change we show the time taken forthe pluto algorithm and our hybrid algorithm.
a initial build b all editor changes c example program changes d stylingspecificationchanges e addinglanguagespecification f syntaxspecificationsmallchange g syntaxspecification cascading change h syntax specification refactor i analysis specification changes j analysis specification refactor k no changes l all files changed.
taskthatwasnotrequiredtobeexecuted.inthiscase thehybrid algorithm was seconds slower causing a slowdown.
thisisatradeoffofthehybridalgorithm ifadependencytoa task disappears the hybrid algorithm will still visit it.
however these cases are very rare only a single change triggers this kind of behavior.
for example if at least one example program could be parsed into an ast possibly through error recovery the analysis specification has to be recompiled.
we undo the change afterwards to make example programs parse again.
h syntax specification refactor.
werefactorapartoftheminijava syntax definition into another file which results in a semanticallyequivalentparser.thehybridalgorithmprovidesa14.5second speedup becauseitfirst rebuildstheparsetable detectsthat it did not change and then cuts off the build early.
contrary to the previous change a bottom up traversal here helps in cutting down theincrementalbuildtime bynoteventraversingtheunaffected part of the dependency graph.
i analysis specification change.
wemodifythenameandtype analysisspecificationofthecalclanguage suchthatitscopesbindingsdifferently andundothechangeafterwards.becausechanging thesespecificationshasamoderateimpact thehybridalgorithm providesamoderate9.7secondspeedup .
j analysis specification refactor.
we refactor a part of the tiger nameandtypeanalysisspecificationintoanotherfile.eventhough this results in a semantically equivalent analyzer the change detectionofthespoofax piebuildscriptisnotsmartenoughtodetect this.becausecompilingthenameandtypeanalysisspecification andthenperformingconstraintsolvingforalltigerexampleprograms is expensive this change has a large impact.
therefore the pluto and hybrid algorithm perform nearly identically.k no changes.
whentherearenochanges thehybridalgorithm essentially performs no work completing in sub millisecond time whiletheplutoalgorithmstillneedstochecktheentiredependency graph costing3.3secondsoftime.thisistheconstantoverheadthat even small impact changes suffer from with the pluto algorithm which the hybrid algorithm saves.
l all files changed.
finally wechangeallsourcefilesbyappending a space to the end of each file.
realistically this kind of change can happen when checking out a different branch in a source control management system such as git.
when all source files change usingabottom upapproachmakesnosense since almostall tasks will be affected while incurring overhead because of scheduling.
therefore we detect when more than of source files all requiredfiles forwhichthereisnogeneratortask change andrunatop downbuildwiththeplutoalgorithminstead thereforerunning as fast as the pluto algorithm does.
this heuristic seems to work well but may require further tweaking.
conclusion.
wecanconcludethat forthisbuildscriptandworkspace directory our algorithm scales better with the impact of a changethantheplutoalgorithm formanykindsofchanges.the onlyexceptionsbeingwhenallfilesarechanged forwhichafull rebuild could be triggered or when a dependency to an expensive task is removed which rarely happens.
.
threats to validity a possible threat to validity is that we have benchmarked the algorithms against a single build script.
however it is a complex build script that represents the realistic scenario of interactive language developmentinalanguageworkbench.forexample thebuildscript authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france gabri l konat sebastian erdweg and eelco visser requires dynamic file dependencies in order to track precise dependencies which only become evident during a build.
furthermore it alsorequiresdynamictaskdependencies inordertodispatchthe correcttasksbasedontheconfigurationoftheworkspaceandeach language specification.
anotherpossiblethreatisthatwehavesynthesizedachainof changes instead of using existing change scenarios.
however we have constructed changes to different kinds of aspects such as changing an example program and changing a file of the syntaxspecification andwithvaryinglevelsofimpact rangingfrom changing the text in a single editor to changing a file of the name andtypespecification whichtransitivelyaffectsmanyothertasks.
related work thereisalargebodyofworkonincrementalbuildsystems.make isanincrementalbuildsystemwithdeclarativebuildrulesbased onfiles.ithaslimitedsupportfordynamicfiledependencies and nopropersupportfordynamictaskdependencies.becauseofthese limitations makescaleswellforsimplebuildscripts sinceitcan firsttopologicallysortdependencies iterateover thedependencies and incrementally execute affected tasks.
while it is possible to emulate dynamic task dependencies this requires tedious makefile generation encoding of all dependencies as files and recursive make execution.
therefore make is not sufficient for more complicated build scripts.
many build systems follow a similar approach to make first building a task dag and then executing it.
for example gra dle bazel buck prom fabricate tup and ninja follow this approach with slight variations.
gradle is a build automation tool programmable in the groovy language that like our hybrid algorithm also supports values as inputs and outputsoftasks.promreplacesdeclarativemakeruleswithlogicalprogramming whilekeepingthesameincrementalbuildalgorithm.
fabricate uses system tracing to automatically infer file dependencies but is only supported on linux.
tup like our hybrid build algorithm requiresa list ofchanged files asinput instead ofscanning all files to more efficiently build the task dag.
ninja unlike make detects changes to the commands of a rule resulting in a rebuild if the rule is changed.
none of the above systems supports dynamic file or task dependencies.
somebuildsystemsintertwineincrementalexecutionwiththe discoveryoffileandtaskdependencies.pluto isajavalibrary fordevelopingincrementalbuildscriptswithdynamicdependencies.
as discussed throughout this paper pluto uses a top downalgorithm that does not scale to small changes over large dependencygraphs.omake isabuildsystemwithmake likesyntax but with a richer dependency tracking mechanism and a more complicatedalgorithm.ithaslimitedsupportfordynamicfiledependencies through scanner rules that scan depfiles and register their dependencies during execution.
however it does not support dynamic task dependencies all tasks dependencies are specified staticallyinthebuildrules.shake isahaskelllibraryfor implementing buildscripts with incrementalexecution.
it haslimitedsupportfordynamicfiledependencies allowingneededfiles tobediscovereddynamically butgeneratedfiledependenciesmustbespecifiedstaticallyasthebuildtarget.italsohaslimitedsupportfordynamictaskdependencies tasksarenamedbykeys andthose tasks can be required like files through their keys.
however these tasks are not parameterized nor can they return values making their use as dynamic task dependencies tedious.
our work is also related to approaches on incremental computing.
datalog is a logic programming language with incremental solvers .
the are several differences between our hybrid algorithm and incremental datalog solvers.
datalog solvers can deal with cycles eagerly compute all facts and use static dependencies fromthedatalogprogram whereasthehybridalgorithm andbuild systems in general disallow cycles only compute demanded facts and use dynamic dependencies.
adapton is a library for on demand lazy incremental computation.
like the pluto and our hybrid algorithm adapton supports a form of dynamic task dependencies dynamic computation dependencies which form a computation graph.
initially adapton builds a full computation graph.
then to achieve incrementality when a node in the computation graph is affected bya change it transitively marks all dependent nodes by setting a dirty flag.
then when a computation result is demanded it transitivelyrerunsalldirtynodesthatarerequiredbythecomputation.
the downside of dirty flagging is that it is an over approximation of what actually needs to be executed ignoring cases where the output of a computation does not change.
in build systems where many tasks may depend on a single compiler task and where computations include calling compilers that can run for seconds to evenminutes avoidingrecomputationwhendependenciesdonot change iscrucial.forexample whenwechangeasyntaxspecification but the resulting parse table does not change dirty flagging has already marked parsing all example files as dirty.
therefore our hybrid algorithm checks outputs of task to cut off the build early instead of performing dirty flagging and propagation.
conclusion we have shown the need for an efficient precise and expressive build system.
many build systems are efficient and precise but not expressive makingcomplexbuildscriptdevelopmenttedious.pluto a recent incremental build system that supports programmablebuild scripts with dynamic dependencies is expressive but doesnot scale with the impact of a change because it requires a topdown traversal over the entire dependency graph for each change.
to overcome this scalability problem we have realized a hybrid algorithm that mixes bottom up building for scalability and topdown building for expressiveness through dynamic dependencies.
wehaveevaluatedtheperformanceofourhybridalgorithmagainst pluto salgorithm withacasestudyonthespoofaxlanguageworkbench.theevaluationdemonstratesthatthehybridalgorithm with the exception of one kind of change indeed scales better with the impactofachange andisthereforefasterthantheplutoalgorithm in particular for low impact changes.