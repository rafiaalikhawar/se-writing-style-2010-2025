sound static deadlock analysis for c pthreads daniel kroening university of oxford oxford uk kroening cs.ox.ac.ukdaniel poetzl university of oxford oxford uk daniel.poetzl cs.ox.ac.ukpeter schrammel university of sussex brighton uk p.schrammel sussex.ac.uk bj rn wachter ssw trading gmbh germany bjoern.wachter gmail.com abstract we present a static deadlock analysis for c pthreads.
the design of our method has been guided by the requirement to analyse real world code.
our approach is sound i.e.
misses no deadlocks for programs that have de ned behaviour according to the c standard and the pthreads speci cation and is precise enough to prove deadlock freedom for a large number of such programs.
the method consists of a pipeline of several analyses that build on a new contextand thread sensitive abstract interpretation framework.
we further present a lightweight dependency analysis to identify statements relevant to deadlock analysis and thus speed up the overall analysis.
in our experimental evaluation we succeeded to prove deadlock freedom for programs from the debian gnu linux distribution with in total .
mloc in hours.
ccs concepts theory of computation !program analysis keywords deadlock analysis static analysis abstract interpretation .
introduction locks are the most frequently used synchronisation mechanism in concurrent programs to guarantee atomicity prevent unde ned behaviour due to data races and hide weakmemory e ects of the underlying architectures.
however locks if not correctly used can cause a deadlock where one thread holds a lock that the other one needs and vice versa.
in small programs deadlocks may be spotted easily.
however this is not the case in larger software systems.
locking disciplines aim to prevent deadlocks but are di cult to maintain as the system evolves and every extension bears the risk of introducing deadlocks.
for example if the order in which locks are acquired is di erent in di erent parts of the code this may cause a deadlock.the problem is exacerbated by the fact that deadlocks are di cult to discover by means of testing.
even a test suite with full line coverage is insu cient to detect all deadlocks and similar to other concurrency bugs triggering a deadlock requires a speci c thread schedule and a set of particular program inputs.
therefore static analysis is a promising candidate for a thorough check for deadlocks.
we hypothesise that static deadlock detection can be performed with a su cient degree of precision and scalability and without sacri cing soundness.
to this end this paper presents a new method for static deadlock analysis.
our approach is sound1 i.e.
misses no deadlocks for programs that have de ned semantics according to the c standard and the pthreads speci cation and thus in particular do not contain data races .
to quantify scalability we have applied our implementation to a large body of real world concurrent code from the debian gnu linux project.
speci cally this paper makes the following contributions .
a static deadlock analysis for c pthreads that is sound for de ned programs and can handle real world code.
.
a new context and thread sensitive abstract interpretation framework that forms the basis of our analyses.
the framework uni es contexts threads and program locations via the concept of a place.
.
a lightweight dependency analysis for identifying statements that could a ect a given set of expressions.
we use it to speed up the pointer analysis by focusing it to statements that are relevant to deadlock analysis.
.
we show how to build a lock graph that soundly captures a variety of sources of imprecision such as maypoint to information and thread creation in loops recursions and how to combine the cycle detection with a non concurrency check to prune infeasible cycles.
.
a thorough experimental evaluation on programs from debian gnu linux with .
mloc in total and up to kloc per program.
.
overview the design of our analyses has been guided by the goal to analyse real world concurrent c pthreads code in a sound way.
for programs with unde ned behaviour we do not formally guarantee soundness as for such programs the compiler is allowed to do anything and may in particular produce a program containing a deadlock.
this could happen in 1we use the term soundness in the static analysis veri cation sense i.e.
a sound analysis does not miss any bugs.
this di ers from the usage in dynamic analysis where it means that an analysis does not yield false bug reports.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
1void vlc mutex lock vlc mutex t p i nt val pthread mutex lock p vlc thread assert locking mutex 1void create worker void func void void arg p th re ad a tt r t a t t r i nt r e t p t h r e a d a t t r i n i t a t t r i f r e t pthread create thread arg thread id a t t r func arg !
f p r i n t f stderr error s n s t r e r r o r r e t e x i t figure lock and create wrappersfunction pointer call removal return removal icfa constructionc program icfa figure icfadependency analysis pointer analysis may lockset analysis must lockset analysis lock graph construction cycle detection non concurrency checkyes no figure analysis pipeline practice for example if the compiler removes an if branch that contains an unlock operation if it can determine that the branch always invokes an unde ned operation such as one resulting in an integer over ow .
fig.
gives an overview of our analysis pipeline.
an arrow between two analyses indicates that the target uses information computed by the source.
we use a dashed arrow from the non concurrency analysis to the cycle detection to indicate that the required information is computed ondemand i.e.
the cycle detection may repeatedly query the non concurrency analysis which computes the result in a lazy fashion .
all of the analyses operate on a graph representation of the program introduced in sec.
.
.
the exception is the cycle detection phase which only uses the lock graph computed in the lock graph construction phase.
the pointer analysis may and must lockset analysis and the lock graph construction are implemented on top of our new generic context and thread sensitive analysis framework described in detail in sec.
.
.
to enable trade o between precision and cost the framework comes in a owinsensitive and a ow sensitive version.
the pointer analysis was implemented on top of the former thus marked with in fig.
and the may and must lockset analysis and the lock graph construction on top of the latter marked with .
the dependency analysis and the non concurrency analysis are separate standalone analyses.
context and thread sensitivity.
typical patterns in real world c code suggest that an approach that provides a form of context sensitivity is necessary to obtain satisfactory precision as otherwise there would be too many false deadlock reports.
for instance many projects provide their own wrappers for the functions of the pthreads api.
fig.
for example shows a lock wrapper from the vlc project.
an analysis that is not contextsensitive would merge the points to information for pointer pfrom di erent call sites invoking vlc mutex lock and thus yield many false alarms.
thread creation causes a similar problem.
for every call topthread create the analysis needs to determine which thread is created i.e.
the function identi ed by the pointer passed to pthread create .
this is straightforward if a function identi er is given to pthread create .
however similar to the case of lock wrappers above projects often provide wrappers for pthread create .
fig.
gives the wrapper for pthread create from the memcached project.
the wrapper then uses the function pointer that is passed to create worker to create a thread.
maintaining precision in such cases requires us to track the ow of function pointer values from function arguments to func 1i n t main pthread t t i d pthread create tid thread pthread mutex lock m1 pthread mutex lock m3 pthread mutex lock m2 func1 pthread mutex unlock m2 pthread mutex unlock m3 pthread mutex unlock m1 pthread join tid i n t r r func2 return 22void func1 x 26void thread pthread mutex lock m1 pthread mutex lock m2 pthread mutex lock m3 x pthread mutex unlock m3 pthread mutex unlock m2 pthread mutex unlock m1 pthread mutex lock m4 pthread mutex lock m5 x pthread mutex unlock m5 pthread mutex unlock m4 return 44i n t func2 i nt a pthread mutex lock m5 pthread mutex lock m4 i f a x else x pthread mutex unlock m4 pthread mutex unlock m5 return figure example of a deadlock free program tion parameters.
this is implemented directly as part of the analysis framework as opposed to in the full points to analysis .
dependency analysis.
deadlock detection requires the information which lock objects an expression used in a pthread mutex lock call may refer to.
we compute this data using the pointer analysis which is potentially expensive.
however it is easy to see that potentially many assignments and function calls in a program do not a ect the values of lock expressions.
consider for example fig.
.
the accesses to xcannot a ect the value of the lock pointers m1 m5.
further the code in function func1 cannot a ect the values of the lock pointers and thus in turn the call func1 in line cannot a ect the lock pointers.
we have developed a lightweight context insensitive owinsensitive analysis to identify statements that may a ect a given set of expressions.
the result is used to speed up the pointer analysis.
the dependency analysis is based on marking statements which transitively share common vari380ables with the given set of expressions.
in our case the relevant expressions are those used in lock create and join statements.
for the latter two we track the thread id variable rst parameter of both whose value is required to determine which thread is joined by a join operation.
we give the details of the dependency analysis in sec.
.
non concurrency analysis.
a deadlock resulting from a thread rst acquiring lock m1 and then attempting to acquire m2 at program location and thread rst acquiring m2and then attempting to acquirem1 at program location can only occur when in a concrete program execution the program locations 1and run concurrently.
if we have a way of deciding whether two locations could potentially run concurrently we can use this information to prune spurious deadlock reports.
for this purpose we have developed a non concurrency analysis that can detect whether two statements cannot run concurrently based on two criteria.
common locks .
if thread and thread hold a common lock at locations 1and then they cannot both simultaneously reach those locations and hence the deadlock cannot happen.
this is illustrated in fig.
.
the thread main attempts to acquire the locks in the sequence m1 m3 m2 and the thread thread attempts to acquire the locks in the sequencem1 m2 m3.
there is an order inversion between m2 andm3 but there is no deadlock since the two sections and and thus in particular the locations and are protected by the common lock m1.
the common locks criterion has rst been described by havelund common locks are called gatelocks there .
create and join .
statements might also not be able to run concurrently because of the relationship between threads due to the pthread create and pthread join operations.
in fig.
there is an order inversion between the locks ofm5andm4by function func2 and the locks of m4 m5of thread thread .
yet there is no deadlock since the thread thread is joined before func2 is invoked.
our non concurrency analysis makes use of the must lockset analysis computing the locks that must be held to detect common locks.
to detect the relationship between threads due to create and join operations it uses a search on the program graph for joins matching earlier creates.
we give more details of our non concurrency analysis in sec.
.
.
analysis framework in this section we rst introduce our program representation then describe our context and thread sensitive framework and then describe the pointer analysis and lockset analyses that are implemented on top of the framework.
.
program representation preprocessing .
our tool takes as input a concurrent c program using the pthreads threading library.
in the rst step the calls to functions through function pointers are removed.
a call is replaced by a case distinction over the functions the function pointer could refer to.
speci cally a function pointer can only refer to functions that are type compatible and of which the address has been taken at some point in the code.
this is illustrated in fig.
top .
we assume that the function pointer fphas type void void .
function f2 address not taken and f4 not type compatible do not have to be part of the case distinction.
calling f4 viafpwould be unde ned behaviour according to the c standard .
in the second step functions with multiple exit points i.e.
multiple return statements are transformed such as to have only one exit points illustrated in fig.
bottom .
interprocedural cfas .
we transform the program into a graph representation which we term interprocedural control ow automaton icfa .
the functions of the program are represented as cfas .
cfas are similar to control ow graphs but with the nodes representing program locations and the edges being labeled with operations.
icfas have additional inter function edges modeling function entry function exit thread entry thread exit and thread join.
fig.
shows a concurrent c program and fig.
shows its corresponding icfa thread exit and thread join edges and the function func1 are omitted .
we denote by prog a program represented as an icfa byfuncs the set of identi ers of the functions by l f n 1gthe set of program locations by ethe set of edges connecting the locations and by op e a function that labels each edge with an operation.
for example in fig.
the edge between locations and is labeled with the operation x and the edge between locations and is labeled with the operation func entry a .
we further write l f for the locations in function f. each program location is contained in exactly one function.
the function func yields the function that contains .
the set of variable identi ers in the program is denoted by vars .
we assume that all identi ers in prog are unique which can always be achieved by a suitable renaming of identi ers.
we treat lock unlock thread create and thread join as primitive operations.
that is we do not analyse the body of e.g.
pthread create as implemented in e.g.
glibc on gnu linux systems .
instead our analysis only tracks the semantic e ect of the operation i.e.
creating a new thread.
apart from intra function edges we also have inter function edges that can be labeled with the ve operations func entry func exit thread entry thread exit and thread join.
a function entry edge func entry connects a call site to the function entry point.
the edge label also includes the function call arguments and the function parameters.
for example func entry a indicates that the integer literal is passed to the call as an argument which is assigned to function parameter a. a function exit edge func exit connects the exit point of a function to every call site calling the function.
our analysis algorithm lters out infeasible edges during the exploration of the icfa.
that is if a function entry edge is followed from a function f1to function f2 then the analysis algorithm later follows the exit edge from f2tof1 disregarding exit edges to other functions.
a thread entry edge thread entry connects a thread creation site to all potential thread entry points.
it is necessary to connect to all potential thread entry points since often a thread creation site can create threads of di erent types i.e.
corresponding to di erent functions depending on the value of the function pointer passed to pthread create .
analogous to the case of function exit edges our analysis algorithm tracks the values of function pointers during the icfa exploration.
at a thread creation site it thus can resolve the function pointer and only follows the edge to the thread entry point corresponding to the value of the function pointer.
athread exitedge connects the exit point of a thread to the location following all thread creation sites and a thread joinedge connects a thread exit point to all join operations in the program.
.
analysis framework overview our framework to perform context and thread sensitive analyses on icfas is based on abstract interpretation .
it implements a ow sensitive and ow insensitive xpoint computation over the icfa and needs to be parametrised 3811void f1 2void f2 3void f3 4i n t f4 i n t a .
.
.
.
.
.
f1 .
.
.
f3 .
.
.
f4 .
.
.
10fp .
.
.
2i f fp f1 3f1 4else 5i f fp f3 6f3 1i n t f 2i f .
.
.
return 4else return .
.
.
8a f 1i nt f i n t r e t i f .
.
.
r e t goto end else r e t goto end 9end return r e t .
.
.
13a f figure function pointers and returnsfunc2 int a 55lock m5 lock m4 x x ... return 0main 21create tid thread lock m1 join tid r func2 return 0thread 43lock m1 lock m2 unlock m5 unlock m4 return 0thread entry thread par func entry a func exit r ... ... figure icfa associated with the program in fig.
with a custom analysis to which it delegates the handling of individual edges of the icfa.
we provide more details and a formalization of the framework in the next section.
our analysis framework uni es contexts threads and program locations via the concept of a place .
a place is a tuple n of program locations.
the program locations n 1are either function call sites or thread creation sites in the program such as e.g.
location in fig.
.
the nal location ncan be a program location of any type.
the locations n 1model a possible function call and thread creation history that leads up to program location n. we denote the set of all places for a given program by p. we use the operator to extend tuples i.e.
n n n n .
we further writejpjfor the length of the place.
we write p for elementi indices are based .
we use slice notation to refer to contiguous parts of places p denotes the part from indexi inclusive to index j exclusive and p denotes the pre x until index i exclusive .
we write top p for the last location in the place.
as an example in fig.
place denotes the program location in function func2 when it has been invoked at call site in the main function.
if function func2 were called at multiple program locations min the main function we would have di erent places m for location in function func2 .
similarly for the thread function thread and e.g.
location we have a place with identifying the creation site of the thread.
each place has an associated abstract thread identi er which we refer to as thread id for short.
given a place p n the associated thread id is either t the empty tuple if no location in pcorresponds to a thread creation site or t i such that iis a thread creation site and all jwithj i are not thread creation sites.
it is in this sense that our analysis is thread sensitive as the information computed for each place can be associated with an abstract thread that way.
we write getthread p for the thread id associated with place p. the analysis framework must be parametrised with a custom analysis.
the framework handles the tracking of places the tracking of the ow of function pointer values from function arguments to function parameters and it invokes thecustom analysis to compute data ow facts for each place.
the domain transfer function and join function of the framework are denoted by ds ts andts respectively and the domain transfer function and join function of the parametrising analysis are denoted by da ta andta.
the custom analysis has a transfer function ta e p!
da!
d a and a join function ta da d a!
d a. the domain of the framework parametrised by the custom analysis is then ds fpms da the transfer function ists e p!
ds!d s and the join function is ts ds ds!d s. the set fpms is a set of mappings from identi ers to functions which map function pointers to the functions they point to.
we denote the empty mapping by .
we further write fpm fp ?to indicate that fpis not in dom fpm the domain of fpm .
a function pointer fpmight be mapped byfpmeither to a function for to the special value d for dirty which indicates that the analysed function assigned tofpor took the address of fp.
in this case we conservatively assume that the function pointer could point to any thread function.
.
analysis framework details we now explain the formalisation of the analysis framework which is given in fig.
.
the gure gives the owsensitive variant of our framework.
we refer to the extended version of the paper for the ow insensitive version.
the gure gives the domain join function tsand transfer functionts which are de ned in terms of the join function ta and transfer function taof the parametrising analysis such as the lockset analyses de ned in the next section .
the function nexts e p de nes how the place pis updated when the analysis follows the icfa edge e. for example on afunc exitedge the last two locations are removed from the place which are the exit point of the function and the location of the call to the function and the location to which the function returns to is added to the place which is the location following the call to the function .
the thread entry and func entry cases are delegated to entrys p .
the rst case of the function handles recursion.
if the location of the called function is already part of the place then the prex of the place that corresponds to the original call to the function is reused rst case .
if no recursion is detected the 382domain ds fpms da s1 stss2 s fpm sa withs1 s fpm1 s1 a withs2 s fpm2 s2 a with fpm fpm1tfpfpm2 withsa s1 atas2 a fpm1tfpfpm2 fpm fpm fp dfpm1 fp d fpm2 fp d v fpm1 fp v fp 2dom fpm2 fpm2 fp v fpm2 fp v fp 2dom fpm1 fpm1 fp v ?otherwise withe top p f func andn jpj nexts e p entrys p op e 2fthread entry func entryg p 2op e 2ffunc exit thread exit thread joing p 2otherwise entrys p p0 p p0 p00 p otherwise withe src tgt op e func entry arg1 argk par1 park and ss fpm sa tsje pk ss fpm0 taje p k sa fpm0 pari argi isfunc argi fpm argi isfunc pointer argi withe src tgt f func tgt op e thread entry thr arg par andss fpm sa tsje pk ss fpm0 taje pk sa match fp fpm thr f ?a otherwise match fp fpm thr f isfunc pointer thr fpm thr 2f?
d fg isfunc thr thr f withe src tgt op e 2ffunc exit thread exit thread joing and ss fpm sa tsje pk ss taje pk sa withe src tgt op e op andss fpm sa tsje pk ss fpm taje pk sa figure context thread and ow sensitive abstract interpretation framework entry location of the function is simply added to the current place second case .
for intra function edges last case of nexts the last location is removed from the place and thetarget location of the edge is added.
the overall result of the analysis is a mapping s2p!
fpms d a .
the result is de ned via a xpoint equation .
we obtain the result by computing the least xpoint via a worklist algorithm of the equation below with s0denoting the initial state of the places s s0t p g p0 es.t.np p p0 e tsje p0k s p0 s with np p p0 top p0 top p nexts p0 p withsts0 p s p tss0 p the equation involves computing the join over all places p0 and edgesein the icfa such that np p p0 e .
we next describe the de nition of the transfer function of the framework in more detail.
the de nition consists of four cases function entry thread entry function exit thread exit thread join and intra function edges.
when applying a function entry edge a new function pointer map fpm0is created by assigning arguments to parameters and looking up the values of the arguments in the current function pointer map fpm.
as in the following cases the transfer function taof the custom analysis is applied to the statesa.
applying a thread entry edge to a state ssyields one of two outcomes.
when the value of the function pointer argument thrmatches the target of the edge i.e.
the edge enters the same function as the function pointer points to then the function pointer map is updated with argand par as in the previous case and the transfer function of the custom analysis is applied.
otherwise the result is the bottom element?s ?a .
the function pointer map is cleared as its domain contains only parameter identi ers which are not accessible outside of the function and the custom transfer function is applied.
the custom transfer function is applied.
if a function pointer fpis assigned to or its address is taken its value is set to dinfpm thus indicating that it could point to any thread function.
this case is omitted from fig.
for lack of space.
implementation.
during the analysis we need to keep a mapping from places to abstract states which we call the state map .
however directly using the places as keys for the state maps in all analyses can lead to high memory consumption.
our implementation therefore keeps a global two way mapping shared by all analyses in fig.
between places and unique ids for the places we call this the place map .
the state maps of the analyses are then mappings from unique ids to abstract states and the analyses consult the global place map to translate between places and ids when needed.
in the two way place map the mapping from places to ids is implemented via a trie and the mapping from ids to places via an array that stores pointers back into the trie.
the places in a program can be e ciently stored in a trie as many of them share common pre xes.
we give further details in the extended version .
.
pointer analysis we use a standard points to analysis that is an instantiation of the ow insensitive version of the above framework see the extended version of the paper .
it computes 383domain 2objs ff?gg s1ts2 s1 s2ifs1 s26 f?g f?g otherwise with op e lock a tje pk s s vs p a ifs vs p a f?g f?g otherwise with op e unlock a tje pk s ifjsj s6 f?g s vs p a ifjs vs p a j s6 f?g vs p a f?g s otherwise with op e 2fthread entry thread exit thread joing tje pk s figure may lockset analysis.
we denote by vs p a the value set of pointer expression aat placep see sec.
.
for each place an element of vars!
2objs ff?gg .
that is the set of possible values of a pointer variable is either a nite set of objects it may point to or f?gto indicate that it could point to any object.
we use vs p a to denote the value set at place pof pointer expression a. the pointer analysis is sound for concurrent programs due to its ow insensitivity .
.
lockset analysis our analysis pipeline includes a may lockset analysis computing for each place the locks that may be held and a must lockset analysis computing for each place the locks that must be held .
the former is used by the lock graph analysis and the latter by the non concurrency analysis.
the may lockset analysis is formalised in fig.
as a custom analysis to parametrise the ow sensitive framework with.
the must lockset analysis is given in the extended version .
both the may and must lockset analyses makes use of the previously computed points to information by means of the function vs .
in both cases care must be taken to compute sound information from the may point to information provided by vs .
for example for the may lockset analysis on an unlock a operation we cannot just remove all elements in vs p a from the lockset as an unlock can only unlock one lock.
we use lsa p lsu p to denote the may and must locksets at place p. .
dependency analysis we have developed a context insensitive ow insensitive dependency analysis to compute the set of assignments and function calls that might a ect the value of a given set of expressions in our case the expressions used in lock create and join statements .
the purpose of the analysis is to speed up the following pointer analysis phase cf.
fig.
.
below we rst describe a semantic characterisation of dependencies between expressions and assignments and then devise an algorithm to compute dependencies based on syntax only speci cally the variable identi ers occuring in the expressions assignments .
semantic characterisation of dependencies.
letas fe2e prog jisassign op e gbe the set of assignment edges.
let exprs be a set of starting expressions.
let further r a w a denote the set of memory locationsthat an expression or assignment amay read resp.
write over allpossible executions of the program.
let further m a r a w a .
then we de ne the immediate dependence relation depas follows with denoting transitive closure and denoting composition dep1 exprs as a b 2dep1 r a w b dep2 as as a b 2dep2 r a w b dep dep1 dep if a b 2dep1 then the evaluation of expression amay read a memory location that is written to by assignment b. if a b 2dep2 then the evaluation of the assignment amay read a memory location that is written to by the assignmentb.
if a b 2dep this indicates that the expression a can transitively be in uenced by the assignment b. we say adepends on bin this case.
the goal of our dependency analysis is to compute the set of assignments a depj a !a the binary relation aprojected to the second component .
however we cannot directly implement a procedure based on the de nitions above as this would require the functions r w to return the memory locations accessed by the expressions assignments.
this in turn would require a pointer analysis the very thing we are trying to optimise.
thus in the next section we outline a procedure for computing the relation depwhich relies on the symbols i.e.
variable identi ers occuring in the expressions assignments rather then the memory locations accessed by them.
computing dependencies.
in this section we outline how we can compute an overapproximation of the set of assignments aas de ned above.
letsymbols a be a function that returns the set of variable identi ers occuring in an expression assignment.
for example symbols a lock fa igand symbols p q fp qg.
as stated in sec.
.
in our program representation all variable identi ers in a program are unique.
we rst de ne the relation sym2which indicates whether two assignments have common symbols sym2 as as a b 2sym2 symbols a symbols b our analysis relies on the following property if two assignmentsa bcan access a common memory location i.e.
m a m b then a b 2sym .
this can be seen as follows.
whenever a memory region location is allocated in c it initially has at most one associated identier.
for example the memory allocated for a global variable xat program startup has initially just the associated identi er x. similarly memory allocated via e.g.
a int malloc sizeof int num has initially only the associated identi er a. if an expression not mentioning x such as p can access the associated memory location then the address of xmust have been propagated to pvia a sequence of assignments such as q x s f q p s f with each of the adjacent assignments having common variables.
thus if a bcan access a common memory location then both must be connected to the initial identi er associated with the location via such a sequence.
thus in particular a bare also connected.
therefore a b 2sym .
we next de ne the sym relation which also incorporates the starting expressions sym1 exprs as a b 2sym1 symbols a symbols b sym sym1 sym 384as we will show below we have dep sym and thus also a depj a !a symj a !a.
thus if we compute sym above we get an overapproximation of a. the fact that dep sym can be seen as follows.
let a b 2dep.
then there are a1 a2 a n bsuch that a1 a2 2dep1 dep2 a2 a3 2dep2 an b 2dep2.
let a0 a00 be an arbitrary one of those pairs.
then r a w b by the de nition of dep1and dep2.
thusm a m b .
as we have already argued above if two expressions assignments can access the same memory location then they must transitively share symbols.
thus a0 a00 2sym1 sym must hold.
therefore since we have chosen a0 a00 arbitrarily we have that all of the pairs above are contained insym1 sym 2and thus by the de nition of sym and in particular the transitivity of sym 2we get a b 2sym.
thus we can use the de nition of sym above to compute an overapproximation of the set of assignments that can affect the starting expressions as de ned semantically in the previous section.
algorithm.
algorithm gives our dependency analysis.
the rst phase line algorithm is based on the ideas from the previous section.
it computes the set of edges that can affect the given set of starting edges.
it rst computes the set of setsrwhich contains for each edge a set which contains the symbols mentioned by this edge lines .
then line assigns to nm a map that maps unique integers to sets inr.
then line assigns to sma map that maps symbols to those numbers corresponding to sets in rin which the respective symbols occur.
for example if we haver ffx yg fzgg then we would get nm f07!
fx yg !fzggand sm fx7!
y7!
z7!1g.
the purpose of this numbering is to have a compact representation of smto guarantee linear runtime of the algorithm.
then in lines the algorithm propagates the set of symbols to compute transitive dependencies.
the sets nh sh store the numbers and symbols that have been handled already.
finally lines select the assignment func exit and thread join edges that share symbols with those encountered during the propagation phase.
in the second phase the algorithm additionally determines thefunc entry and thread entry edges that could lead to an edge determined in the previous phase.
the ability to prune function calls has a potentially big e ect on the performance of the analysis as it can greatly reduce the amount of code that needs to be analysed.
in the following section we evaluate the performance and e ectiveness of the dependency analysis.
its e ect on the overall analysis is evaluated in sec.
.
evaluation.
we have evaluated the dependency analysis on a subset of benchmarks of the benchmarks given in sec.
.
for each benchmark the dependency analysis was invoked with the set of starting expressions exprs being those occuring in lock operations or as the rst argument of create and join operations.
the results are given in the table below.
runtime sign.
assign.
sign.
func.
25th percentile s .
.
arithmetic mean s .
.
75th percentile s .
.
figure analysis runtime and e ectiveness the table shows that the average time over all benchmarks to perform the dependency analysis was s. the rst andalgorithm dependency analysis input icfa prog start edges start edges output set of a ecting edges a 1a a ecting edges prog start edges 2f ffje2a f func src e g 3fh 4whilef6 do removeffromf 6fh fh ffg 7e fejfunc tgt e f op e 2ffunc entry thread entrygg fore2edo 9a a feg 10f0 func src e iff0 2fhthen f f ff0g 13return a last line give the 25th and 75th percentile.
this indicates for example that for of the benchmarks it took s or less to perform the dependency analysis.
the third and fourth column evaluate the e ectiveness of the analysis.
on average of the assignments in a program were classi ed as signi cant i.e.
potentially a ecting the starting expressions .
the data also shows that often the number of significant assignments was very low in of the cases it was or less .
this happens when the lock usage patterns in the program are simple such as using simple lock expressions like pthread mutex lock mutex that refer to global locks with simple initialisations such as using static initialization via pthread mutex initializer .
the average number of functions classi ed as signi cant was .
this means that on average of the functions that occur in a program were identi ed as irrelevant by the dependency analysis and thus do not need to be analysed by the following pointer analysis.
overall the data shows that the analysis is cheap and able to prune a signi cant number of assignments and functions.
.
non concurrency analysis we have implemented an analysis algorithm to compute whether two places p1 p2are non concurrent.
that is the analysis determines whether the statements associated with the places p1 p2 i.e.
the operations with which the outgoing edges of top p1 top p2 are labeled cannot execute concurrently in the contexts embodied by p1 p2.
whether the places are protected by a common lock is determined by computing the intersection of the must locksets lines .
if the intersection is non empty they cannot execute concurrently and the algorithm returns true.
this approach is similar to the one described by havelund except that we statically compute the set of locks that must be held at a place p whereas havelund does dynamic analysis and deals with exact locksets associated with concrete program executions.
if the common locks check yields false the algorithm proceeds to check whether the places are non concurrent due to create and join operations.
this is done via a graph search in the icfa.
first the length of the longest common pre x ofp1andp2is determined line .
this is the starting point for the icfa exploration.
if there is a path from 1to it is checked that all the threads that are created to reach placep1are joined before location 2is reached and same for a path from 2to .
this check is performed by the 385algorithm a ecting edges 1function a ecting edges prog start edges 2a start edges 3r fore2e prog do op op e ifop a b op thread entry a b op func exit a b op thread join a b then r r fsymbols a symbols b g else ifop func entry arg1 argn par1 parn then r r fsymbols argi symbols pari j i2f1 ngg nm number map r sm symbol map r 12s s e2start edgessymbols op e 13nh sh whiles6 do removesfroms 16sh sh fsg forn2sm do ifn 2nhthen nh nh fng s s sh fore2e prog do ifop a b op func exit a b op thread join a b then if symbols a symbols b sh then a a feg return a procedure unwind the full details of which we give in the extended version .
we evaluated the non concurrency analysis with respect to what fraction of all the pairs of places p1 p2of a program it classi es as non concurrent.
we found that on a subset of benchmarks of the benchmarks of sec.
it classi ed of the places corresponding to di erent threads as nonconcurrent on average.
we give more data in the extended version .
.
lock graph analysis our lock graph analysis consists of two phases.
first we build a lock graph based on the lockset analysis.
in the second phase we prune cycles that are infeasible due to information from the non concurrency analysis.
.
lock graph construction alock graph is a directed graph l22objs p objs with objs objs f?g .
each node is a lock2objs and an edge lock p lock 2objs p objs from lock 1to lock 2is labelled with the place pof the lock operation that acquired lock 2while lock 1was owned by the same thread getthread p .
hence the directed edges indicate the order of lock acquisition.
fig.
gives the lock graph for the example program in fig.
.
we use the result of the may lockset analysis sec.
.
to build the lock graph.
fig.
gives the lock graph domainalgorithm non concurrency analysis input placesp1 p2 must locksets ls1 u ls2 uoutput true ifp1 p2are non conc.
false otherwise 1ifp1 p2then return true 3ifls1 u ls2 u6 then return true 5i jcommon pre x p1 p2 j 6r1 r2 true true p1 p2 8ifhaspath then 9r1 unwind i p1 10ifhaspath then 11r2 unwind i p2 12returnr1 r2 m1 m2 m3m4 m5 m t m t m t m m m f figure lock graph for the program in fig.
t mand fare shorthand for thread main and func2 that is instantiated in our analysis framework.
for each lock operation in place pa thread may acquire a lock lock corresponding to the value set of the argument to the lock operation.
this happens while the thread may own any lock lock 1in the lockset at that place.
therefore we add an edge lock p lock for each pair lock lock .
finally we have to handle the indeterminate locks denoted by?.
we compute the closure cl l of the graph w.r.t.
edges that involve ?by adding edges from all predecessors of the ?node to all other nodes and to each successor node of the ?node we add edges from all other nodes.
.
checking cycles in the lock graph the nal step is to check the cycles in the lock graph.
we look for deadlocks involving two or more threads.
each cycle cin the lock graph could be a potential deadlock.
a cycle cis a set of distinct edges there is a nite number of such sets.
a cycle is a potential deadlock if jcj allconcurrent c where allconcurrent c lock p lock lock0 p0 lock0 2c non concurrent p p0 getthread p getthread p0 multiple thread getthread p and multiple thread t means that twas created in a loop or recursion.
owing to the use of our non concurrency analysis we do not require any special treatment for gate locks or thread segments as in .
.
experiments we implemented our deadlock analyser as a pipeline of static analyses in the cprover framework.the tool and benchmarks are available online at deadlock detection.
386domain 2objs p objs s1ts2 s1 s2 with op e lock a tje pk s s f lock p lock jlock 12lsa p lock 22vs p a g cl s s f lock p lock j lock p ?
2s lock2getlocks s nflock ?gg f lock p lock j ?
p lock 2s lock2getlocks s nflock ?gg figure lock graph construction we performed experiments to support the following hypothesis our analysis handles real world c code in a precise and e cient way.
we used concurrent c programs that contain locks from the debian gnu linux distribution with the characteristics shown in fig.
.2the table shows that the minimum number of di erent locks and lock operations encountered by our analysis was .
we found that this is due to a small number of benchmarks on which the lock operations were not reachable from the main function of the program i.e.
they were contained in dead code .
we additionally selected programs and introduced deadlocks in them.
this gives us a benchmark set consisting of benchmarks with a total of .
mloc.
of these benchmarks are assumed to be deadlock free and benchmarks are known to have deadlocks.
the experiments were run on a xeon x5667 at ghz running fedora with bit binaries.
memory and cpu time were restricted to gb and seconds per benchmark respectively.
results.
we correctly report potential deadlocks in the benchmarks with known deadlocks.
the results for the deadlockfree programs are shown in fig.
grouped by benchmark size t o. .
.
timed out m o. .
.
out of memory .
kloc analysed proved alarms t o m o figure results for the deadlock free programs for deadlock free benchmarks we report alarms that are most likely spurious.
the main reason for such false alarms is the imprecision of the pointer analysis with respect to dynamically allocated data structures.
this leads to lock operations on indeterminate locks see statistics in fig.
.
for of the lock operations on average the analysis was precise i.e.
the value set contained only a single lock.
the scatter plot in fig.
illustrates how the tool scales in terms of running time with respect to the number of lines of code.
the tool successfully analysed programs with up to 40k lines of code.
as the plots show the asymptotic behaviour is di cult to predict since it mostly depends on the complexity of the pointer analysis.
we evaluated the impact of the di erent analysis features on a random selection of benchmarks and break down the running times into the di erent analysis phases on those 2lines of code were measured using cloc .
.
figure loc vs. analysis time timeout s benchmarks where the tool does not time out or goes out of memory we found that the dependency analysis is effective at decreasing both the memory consumption and the runtime of the pointer analysis.
it decreased the memory consumption by and the runtime by on average.
we observed that still the vast majority of the running time of our tool is spent in the pointer analysis which is due to the often large number of general memory objects including all heap and stack objects that may contain locks.
may lock analysis .
must lock analysis .
and lock graph construction .
take less time the run times for the dependency analysis and the cycle checking up to the rst potential deadlock are negligible.
in benchmarks the non concurrency analysis refuted infeasible cycles however all of these programs had other feasible cycles.
.
threats to validity this section discusses the threats to internal and external validity of our results and the strategies we have employed to mitigate them .
the main threat to internal validity concerns the correctness of our implementation.
to mitigate this threat we have continually tested our tool during the implementation phase which has resulted in a testsuite of system unit and regression tests.
to further test the soundness claim of our tool on larger programs we introduced deadlocks into previously deadlock free programs and checked that our tool correctly detected them.
while we have reused existing locks and lock operations to create those deadlocks they might nevertheless not correspond well to deadlocks inadvertently introduced by programmers.
the threats to external validity concern the generalisability of our results to other benchmarks and programming languages.
our benchmarks have been drawn from a collection of open source c programs from the debian gnu linux distribution that use pthreads and contain lock operations from which we ran most of the smaller ones and some larger ones.
we found that the benchmark set contains a diverse set of programs.
however we did not evaluate our tool on embedded safety or mission critical software a eld that we see as a prime application area of a sound tool like ours due to the ability to verify the absence of errors.
during the experiments we have used a timeout of s. this in particular means that we cannot say how the tool would fare for users willing to invest more time and computing power in particular the false positive rate could increase as programs that take a long time to analyse are likely larger and could have more potential for deadlocks to occur.
finally our results might not generalise to other programming languages.
for example while naik et al.
387max avg min lines of code .
threads .
threads in loop .
locks .
lock operations .
precise lock operations .
indeterminate locking operations .
size of largest lockset .
.
.
non concurrency checks .
.
.0max avg min total analysis time s .
.
.
dependency analysis .
.
.
pointer analysis .
.
.
may lockset analysis .
.
.
must lockset analysis .
.
.
lock graph construction .
.
.
cycles detection .
.
.
peak memory gb .
.
.
figure benchmark characteristics and analysis statistics analysing java found that the ability to detected common locks was crucial to lower the false positive rate we found that it had little e ect in our setting since most programs do not acquire more than locks in a nested manner see tab.
size of largest lockset .
.
related work deadlock analysis is an active research area.
a common de ciency of many of the existing tools is that they are neither sound nor complete and produce false positives and negatives.
dynamic tools.
the development of the java pathfinder tool led to ground breaking work over more than a decade to nd lock acquisition hierarchy violation with the help of lock graphs exposing the issue of gatelocks and segmentation techniques to handle di erent threads running in parallel at di erent times.
try to predict deadlocks in executions similar to the observed one.
deadlockfuzzer use a fuzzying technique to search for deadlocking executions.
multicore sdk tries to reduce the size of lock graphs by clustering locks and magiclock implements signi cant improvements on the cycle detection algorithms.
helgrind is a popular open source dynamic deadlock detection tool and there are many commercial implementations of dynamic deadlock detection algorithms.
static tools.
there are few static analysis tools to nd deadlocks in c programs.
locklint is a semi automatic lightweight approach that relies on user supplied lock acquisition orders.
racerx performs a path and context sensitive analysis but its pointer analysis is very rudimentary.
several model checking tools also allow to nd deadlocks among other errors .
the tools lazy cseq and mu cseq use context bounded sequentialisation and analyse the resulting program with the bounded model checker cbmc .
esbmc also uses context bounding and encodes each interleaving as an smt formula.
both the versions of cseq and esbmc are unsound for de ned programs due to contextbounding and loop unrolling but in contrast to our tool are also able to detect some unde ned behaviours.
the civl model checker explores all execution paths and interleavings of a program.
it symbolically represents the program state and queries a constraint solver to check state reachability.
for java there is jlint2 a tool similar to locklint.
the tool jade consciously uses a may analysis instead of a must analysis which causes unsoundness.
the tools presented in and do not consider gatelock scenarios.
other tools.
some tools combine dynamic approaches and constraint solving.
for example checkmate model checks a path along an observed execution of a multi threaded java program sherlock uses concolic testing and moni tor runtime executions of java programs.
there are related techniques to detect synchronisation defects due to blocking communication e.g.
in message passing mpi programs for the modelling languages bip dfinder tool or abs deco tool that use similar techniques based on lock graphs and may happen in parallel information.
dependency analysis.
our dependency analysis is related to work on concurrent program slicing and alias analysis .
our analysis is more lightweight than existing approaches as it works on the level of variable identi ers only as opposed to more complex objects such as program dependence graphs pdg or representations of possible memory layouts.
moreover our analysis disregards expressions occuring in control ow statements such as if statements as these are not relevant to the following pointer analysis which consumes the result of the dependency analysis.
the analysis thus does not produce an executable subset of the program statements as in the original de nition of slicing by weiser .
non concurrency analysis.
our non concurrency analysis is context sensitive works on demand and can classify places as non concurrent based on locksets or create join.
locksets have been used in a similar way in static data race detection and havelund used locksets in dynamic deadlock detection to identify nonconcurrent lock statements.
our handling of create join is most closely related to the work of albert et al.
.
they consider a language with asynchronous method calls and an await statement that allows to wait for the completion of a previous call.
their analysis works in two phases the second of which can be performed on demand and also provides a form of context sensitivity.
other approaches which however do not work on demand include the work of masticola and ryder and naumovich et al.
for ada and the work of lee et al.
for async nish parallelism.
.
conclusions we presented a new static deadlock analysis approach for concurrent c pthreads programs.
we demonstrated that our tool can e ectively prove deadlock freedom of .
mloc concurrent c code from the debian gnu linux distribution.
the experiments show that the pointer analysis takes the most time and its imprecision is the primary source for false alarms.
future work will focus on addressing this limitation.
moreover we will integrate the analysis of pthreads synchronisation primitives other than mutexes e.g.
condition variables and extend our algorithm to java synchronisation constructs.
.