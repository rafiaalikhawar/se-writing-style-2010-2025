goal conflict detection based on temporal satisfiability checking renzo degiovanni nicolas ricci dalal alrajehypablo castro nazareno aguirre departamento de computaci n universidad nacional de r o cuarto and conicet argentina ydepartment of computing imperial college london uk rdegiovanni nricci pcastro naguirre dc.exa.unrc.edu.ar dalal.alrajeh ic.ac.uk abstract goal oriented requirements engineering approaches propose capturing how a system should behave through the speci cation of high level goals from which requirements can then be systematically derived.
goals may however admit subtle situations that make them diverge i.e.
not be satis able as a whole under speci c circumstances feasible within the domain called boundary conditions .
while previous work allows one to identify boundary conditions for con icting goals written in ltl it does so through a pattern based approach that supports a limited set of patterns and only produces pre determined formulations of boundary conditions.
we present a novel automated approach to compute boundary conditions for general classes of con icting goals expressed in ltl using a tableaux based ltl satis ability procedure.
a tableau for an ltl formula is a nite representation of all its satisfying models which we process to produce boundary conditions that violate the formula indicating divergence situations.
we show that our technique can automatically produce boundary conditions that are more general than those obtainable through existing previous pattern based approaches and can also generate boundary conditions for goals that are not captured by these patterns.
ccs concepts software and its engineering !requirements analysis risk management theory of computation !automated reasoning modal and temporal logics keywords goal con icts satis ability checking tableaux method .
introduction the derivation of correct software requirements speci cations is essential to any reliable software development process .
with the ever increasing complexity of software the importance of rigorous methods in supporting the attainmentof correct speci cations prior to their implementation also increases.
much research over the last decades has demonstrated the signi cant advantages that formal goal oriented approaches bring to the generation of correct software requirements speci cation.
goals are prescriptive statements of how the system should behave.
they re ect stakeholders understanding of what the envisioned system is intended to do and the criteria upon which it would be evaluated.
they are commonly used to aid the elicitation and elaboration of requirements guide the re nement and organisation of requirements and support the derivation of software operations .
however for such tasks to be successfully achieved the goals themselves must be correct which is not often the case.
goals are typically too ideal to start with wavering o the exceptional conditions that may arise within its environment once implemented partial and imprecise.
ensuring their correctness within the development cycle is of utmost importance.
one of the challenges in specifying correct goals is ensuring their consistency.
inconsistency occurs when two or more goals cannot be satis ed simultaneously owing to their contradictory nature non conformance to standards or because of restrictions imposed within certain domains amongst other reasons .
they are typically a result of overlapping and con icting expressions.
detecting and resolving inconsistencies in goals a process called inconsistency management early on not only helps in avoiding costly software repairs but also supports systematic requirements elicitation and veri cation activities .
several approaches have been proposed in the literature for managing inconsistency in goals.
much work has been done on the qualitative end e.g.
where the general focus has been on identifying contradictory low level requirements and computing the degree to which goals are satis ced or denied by them.
on the formal side inconsistency management has also been the focus of several studies e.g.
.
a weaker notion of con ict called divergence in goals expressed in linear temporal logic ltl has been addressed in .
this latter type of inconsistency is concerned with those goals which are not contradictory can be simultaneously satis ed but become inconsistent when certain conditions hold.
consider for instance the following goals from the mine pump controller example the pump shall be on when the water level is above the high threshold and the pump shall be o when methane is detected in the mine .
these goals are not logically inconsistent as they are satis able in cases where the water level never reaches a high level or methane is not detected in the mine.
they permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
become logically inconsistent only in the case when the water level is high and methane is present at the same time.
situations like the latter can be captured formally as assertions called boundary conditions i.e.
declarative formulas that characterise those particular circumstances that lead to inconsistency.
existing model synthesis approaches would not detect this type of inconsistency since there exists at least one model that satis es such goals in which the boundary condition never holds.
so far very limited work has been done on automatically nding boundary conditions for goal expressions save for which supposes goals expressed according to xed templates written in ltl.
in this paper we present a novel approach to automatically compute boundary conditions for con icting goals expressed in ltl using a satis ability procedure based on tableaux.
a tableau for an ltl formula is essentially a nite graph representation of all its satisfying models it is built by rst decomposing the formula whose satis ability is being analysed according to decomposition rules that produce for temporal operators constraints on the current state and future states for their satisfaction.
the resulting graph explores the possible ways of making the initial formula satis able and in this process contradictory portions are identi ed.
the second phase of the tableau method removes contradictory portions as well as parts of the graph that cannot satisfy eventualities leaving a subgraph the tableau that captures allmodels of the formula when it becomes empty the formula is unsatis able .
intuitively the tableau indirectly captures con icting situations since any condition not included in the tableau necessarily prevents the formula from being satis able.
our approach consists of computing the tableau from a set gof goals and then exploring it to identify conditions that would escape the tableau thus violating the goals to produce boundary conditions.
our approach is general in the sense that it can automatically detect con icts in goals expressed as any ltl formula as opposed to where goals must comply with speci c patterns for con ict detection .
in particular our approach can be applied to all patterns in .
in fact as we will show our technique produces more general boundary conditions than those of the pattern based approach while at the same time it allows us to compute boundary conditions from goals not captured by these patterns.
the rest of the paper is organised as follow.
section introduces preliminary concepts necessary in the paper.
section presents an illustrating example used to motivate the approach.
section describes the approach in detail.
in section we validate our technique by comparing it with the pattern based mechanism for con ict detection and by applying our approach on various case studies.
finally we discuss related work in section and draw some conclusions and further work in section .
.
background .
goal oriented modelling goal oriented requirements engineering proposes capturing how a system should behave through the speci cation of a set of high level goals that will drive the requirements engineering process.
goals are prescriptive statements that the envisioned system is expected to achieve through the cooperation of its agents e.g.
humans devices and software within a given domain.
domain properties are descriptivestatements about the problem world such as natural laws .
in this setting a goal model is a decomposition of goals through re nements which essentially capture how a goal can be achieved in terms of simpler ones.
these goal renements end when each leaf subgoal can be assigned to a single agent.
agents provide operations whose combined behaviours must ful ll the goals.
a requirement is a terminal goal assigned to a software agent while an assumption is a goal assigned to an agent in the environment.
in this context inconsistent goals may arise from conicting expressions.
in particular a weak form of con ict called divergence is of relevance in goal oriented requirements engineering.
a set of goals g1 gnis said to be divergent with respect to a set dom of domain properties i there exists a boundary condition bcsuch that the following conditions hold fdom bc v i ngigj false logical inconsistency fdom bc v j6 igjg6j false for each i n minimality bc6 g1 gn non triviality intuitively conditions 1and2indicate that the boundary condition captures a particular combination of circumstances that makes the goals con icting.
roughly speaking the rst condition establishes that goals g1 gncannot simultaneously be satis ed in dom under any circumstances when bc holds.
the second condition states that removing any of the goals no longer results in a logical inconsistency.
the third condition prohibits a boundary condition to be simply the negation of goals.
notice also that the minimality condition forbids trivial boundary conditions bccannot be false nor can it be the negation of one of the goals gi and requires it to be consistent with the domain dom.
.
linear time temporal logic linear time temporal logic ltl is a formalism that has been extensively employed to state properties of reactive systems.
ltl assumes a lineal topology of time i.e.
each instant is followed by a unique future instant and its formulas are evaluated over in nite traces that represent system executions.
given a set apof propositional variables ltl formulas are inductively de ned using the standard logical connectives and temporal operators andu as follows i everyp2apis an ltl formula and ii iff1andf2are ltl formulas then so are f1 f1 f2 f1 f2 f1and f1uf2.
we consider the usual de nition for the operators always eventually and win terms of uand logical connectives.
temporal formulas are evaluated over in nite traces of propositional valuations.
formulas with no temporal operators are evaluated in the rst valuation of a trace.
given a trace fis true in i fis true in the trace obtained by removing the rst valuation from andf1uf2is true in i there exists a position isuch that f2holds in and for all j i f1holds in .
in this work we focus on safety properties typically speci ed as 2f and a particular kind of liveness properties namely those captured by the reachability and response patterns speci ed as 3fand2 f1!3f2 respectively.
for further details on ltl and temporal patterns see .
.
the tableau method for ltl the tableau method is a well known logical satis ability approach based on the decomposition of the formula being 508assessed according to the semantics of its logical operators to search for satisfying valuations.
in propositional logic formulas are decomposed according to the semantics of boolean connectives a model satis es f1 f2i it satis es both conjuncts at the same time a model satis es f1 f2i it satis es at least one of the disjuncts and so on.
notice that if we start with the singleton containing the assessed formula and connect sets of formulas according to decomposition rules e.g.
ff1 f2gwill be connected to ff1 f2g then this tableau process leads to a nite tree the tableau .
branches originate due to disjunction niteness is guaranteed because sets containing contradictions are not further expanded and atomic formulas cannot be decomposed.
in a propositional tableau structure leaves not containing contradictions characterise sets of satisfying valuations those obtained by assigning true resp.
false to atomic variables appearing positively resp.
negatively in the branch and assigning any truth value to any other atomic proposition.
the tableau method for ltl extends propositional tableau with rules to cope with temporal operators.
temporal operators will lead to requirements on the current state in a trace and on the rest of the trace.
for instance 2f globallyf will hold in a trace i fholds in the current state of the trace and2fholds in the rest of the trace or equivalently if 2f holds in the current state .
on the other hand 3fleads to branching as disjunction does a trace satis es 3fi the current state satis es for the rest of the trace satis es 3f or equivalently 3fis satis ed in the current state .
notice that these additional decomposition rules if applied exhaustively may lead to in nite branches.
to avoid decomposing the same formula twice decomposed formulas are marked and if a decomposition leads to a previously constructed set then the arc will lead to the already produced one thus ltl tableaux are graphs as opposed to propositional tableaux which are trees .
then ltl tableaux will deal with sets of formulas and marked formulas subformulas of that being assessed connected according to decomposition rules.
more precisely ltl tableau works as follows.
initially the tableau contains only one node the root consisting of the unmarked formula being queried for satis ability.
then each node will be decomposed according to the following rules f1 f2 f1 f2 2f1 f1 2f1 f1 f2 f1jf2 3f1 f1j 3f1 f1uf2 f2jf1 f1uf2 notice that we do not have rules for negation we assume the original formula to be in negation normal form nnf where negations are pushed to be applied to atomic propositions.
rules labelled with do not lead to branches whereas those labelled with produce branches.
definition .
elementary formula .
we call literal to a propositional variable or its negation.
a formula iselementary i it is a literal or a temporal formula whose main operator is .
then the above rules are applied iteratively taking into account marked vs unmarked formulas and elementary formulas as follows .ifnis a node labelled with a set sof formulas containing at least one unmarked non elementary formula f then i iffis a formula and 2are the formulas resulting from decomposing f then we create a node n0labelled with the set s ffg f 2g ff g and then we connect nwithn0 ii iffis a formula and 2are the formulas resulting from decomposing f then we create two nodes n1andn2 such that n1 is labelled with the set s ffg ff g f 1gandn2 is labelled with s ffg ff g f 2g and nally we connectnwithn1andn2.
.ifnis a node labelled with a set sthat contains only elementary and marked formulas then we create a node n0labelled with the set s0 such that 2s0i s and then we connect nwithn0.
definition .
states and pre states .
the set of nodessn nthat contain only elementary or marked formulas are called states whereas the set pn nthat contains the initial root node and immediate successors of states are called pre states .
after constructing the tableau to decide if is satis able the unsatis able nodes must be eliminated from the graph.
to do so the following deletion rules are repeatedly applied .if a node contains both a proposition pand its negation p it is eliminated.
.if all successors of a node have been eliminated it is eliminated.
.if a node is a pre state that contains some eventuality 3f2orf1uf2that is not satis able then it is eliminated.
a formula 3f2orf1uf2is satis able in a pre state i there exists a path in the tableau leading from that pre state to a node that contains formula f2.
intuitively eventualities express promises that a property will eventually be ful lled so one must guarantee that a future state satis es them to consider these satis able.
the decision procedure ends when all unsatis able nodes have been removed from the tableau.
if the initial node has been eliminated the initial formula is unsatis able if not it is satis able.
the reader is referred to for further details and examples regarding the tableau construction for ltl.
as an example consider the tableau in figure generated for the formula p p. the rootnode contains f2 p pg we already decomposed the conjunction for space reasons .
all nodes whose identi ers are in boldface n2 n3 n5 n8 andn9 are states .
noden8 cannot be further expanded since it contains a propositional inconsistency pand p .
notice also that all nodes reachable from n3 containp and therefore they cannot ful l the eventuality p associated to formula p. the parts of the tableau that are eliminated according to the above rules are highlighted in the gure.
since root belongs to the tableau after all deletion rules have been applied p pis satis able the tableau also indicates the only way to make it satis able is in a trace in which the eventuality pis ful lled in the rst state while in the rest of the trace pis satis ed.
.
motiv ating example to illustrate both the problem addressed and our proposed solution let us consider a simpli ed version of the mine pump controller mpc .
the mpc has a sensor that detects when the water level is high and a sensor to detect the presence of methane in the environment.
the propositional p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p rootn1n2n4n5n8n6n7n9 p p p p p p p p p n3 p p figure tableau example.
variables hw mand poare employed to represent the facts that a high water level is reached that methane is present in the environment and that the pump is on respectively.
in this context the following goals are relevant goal maintain informaldef the pump should be o when methane is detected in the mine.
formaldef m!
po goal maintain informaldef the pump should be on when the water level is above the high threshold.
formaldef hw!
po while these goals can be simultaneously satis ed e.g.
when the water level is never high or methane is never present in the environment they become logically inconsistent when at the same time the water level is high and methane is present.
such con icting situations in this case characterised by the boundary condition hw m are not obvious to identify and are very important to detect.
we propose automatically detecting such boundary conditions by constructing and processing a tableau from the goals temporal formalisations.
let us provide some intuition on how the process works in the particular case of safety goals.
from the above safety goals that we denote here as g1 andg2for space reasons the tableau method previously introduced produces the tableau shown in figure .
the rootnode is the only pre state and nodes n0 n1 n2and n3are states.
also since n3contains both pand p it is not further expanded will be removed from the tableau .
the dashed lines in the gure indicate that target nodes are reached through intermediate nodes that are neither states nor pre states .
states in the tableau capture sets of valuations in particular instants of a trace through the literals they contain.
for instance state n0characterises valuations or points during a trace execution in which there is no methane and water level is not high m hw .
moreover if the consistent states in a tableau are identi ed basically the states of the tableau that remain after the removal phase since these characterise allconsistent situations the negation of their disjunction indirectly captures how the goals would be violated would fall into the unsatis able part of the tableau .
in our particular example this formula is m hw m g1 g2 g g m hwm!
po g1 hw!po g2 g g m pom!
po g1 hw!po g2 g g po pom!
po g1 hw!po g2 g g po hwm!
po g1 hw!po g2 root n0n1n2n3figure tableau for the mine pump controller.
po po hw and reaching it leads to a violation of the goals.
thus m hw m po po hw is a boundary condition or equivalently hw m po hw m po as our tool produces it after simpli cation evidencing a weak con ict between the goals.
actually as we will explain later on this is in fact a potential boundary condition since it may not satisfy minimality an additional checking must be performed on our produced violations to guarantee minimality .
it is worth noting that our computed boundary condition is more general than that manually identi ed above hw m .
by more general we mean that the formula hw m implies the boundary condition computed by our approach.
as we will show in our experimental assessment this tableaubased approach produces more general con icts than those obtained using alternative pattern based techniques.
in the next section we describe in detail the approach including how other kinds of goals besides safety are handled.
.
the approach our tableau based approach to automatically detect goal con icts receives a goal oriented requirements speci cation composed of ltl formulas capturing the domain assumptions dom as well as goals g fg1 gng.
the process may determine that there are no con icts or that there exist either strong orweak con icts.
the most relevant case upon which we concentrate in this work is when weak con icts are detected.
if this is the case our process produces a setbc fbc bckgofboundary conditions capturing di erent divergent situations between the goals in the domain.
our approach is able to deal with safety goals and a particular kind of liveness goals namely those that can be expressed following the reachability orresponse progress patterns .
reachability goals have the form 3f while response goals have the form f1!3f2 .
progress goals on the other hand are expressed as 23f2 and are a particular case of response goals those where f1 true .
the overall approach is summarised in the following steps.
tableau generation and re nement a tableau structuretfordom gis automatically generated using the ltl decision procedure presented in section .
.
as mentioned before structure tencodes allmodels of dom g. if after the deletion rules are applied all the nodes are removed from t then goals and domain speci cations are contradictory 510and we do not look at it any further otherwise we proceed to look for weak con icts.
potential bcidenti cation at this point tableau tproduced in the previous phase is non empty and characterises all the models for dom g in the sense that every sequence that satis es dom gis a path in the tableau t and every nite path obtained from tis the pre x of some model of dom g .
however there may exist some in nite paths intthat leave some eventuality formula unsatis ed and thus such paths do not satisfy dom g. taking these observations into account from t there are two potential sources of divergences that must be analysed.
on one hand all the unsatis able nodes removed by the application of the tableau deletion rules characterise a particular kind of violation to dom g. a condition that would force one to reach the inconsistent portion removed from t may represent a divergence for dom andg.
we call this the safety case .
on the other hand given a liveness goalgi2g whose eventuality is f e.g.
a reachability goal gi 3f an in nite path in the tableau tthat does not pass through a state in which fholds is a violation for giand a potential source of divergence between the goals.
we call this the liveness case .
why these cases are potential divergences and not actual divergences is further discussed later on and analysed in the next phase.
this current phase will produce a set of ltl formulas characterising potential divergences for both the safety and liveness cases.
this phase is achieved by extracting from tableau ta set of path conditions that characterise the two kinds of inconsistencies just described.
a path condition is an ltl formula characterising a path in the tableau see section .
.
to produce path conditions tis traversed starting from the root node collecting the information provided by the states to build ltl formulas that capture the following situations.
for the safety case the produced ltl formula captures a path that escapes from t directing us into the unsatis able nodes those removed from the tableau during node deletion .
for the liveness case the produced ltl formula characterises a path intthat avoids the states in which the eventuality of some liveness goal is ful lled.
path conditions are used to produce the potential boundary conditions pbc fpbc1 pbcmg whose concrete formulation depends on whether they are safety or liveness cases.
as previously mentioned formulas in pbc arepotentialcon icts because although they characterise violations fordom g they do not necessarily represent a divergence case between the goals with respect to the domain.
more precisely according to the divergence de nition given in section .
we have to check if the logical inconsistency and minimality conditions are satis ed to guarantee that these are divergences.
bcextraction this nal phase consists of removing from pbc those conditions that do not satisfy the divergence properties in section .
.
the remaining boundary conditions bc fbc bckgcapture weak con icts between the goals in gand the domain dom .
algorithm describes how the above steps are combined.
we provide further details of each step below.
.
generating and refining the tableau ltl tableaumethod line in algorithm implements the ltl decision procedure introduced in section .
.
it generates a tableau structure t hn r rooti which encodesalgorithm takes as input an ltl speci cation of the domain dom and of a set of goals g. the output indicates if the goals have nocon ict or if they are strongly orweakly con icting.
when goals are weakly con icting a set bcof boundary conditions capturing divergences is produced.
function detectdivergences dom g bc t hn r rooti ltl tableaumethod dom g ifn then .dom gis unsatis able.
return unsat .
goals and domain speci cations are contradictory.
else .dom gis satis able.
look for weak con icts .
.compute potential boundary conditions.
pbc safetybc t .safety case.
glive livenessgoals g for all gi2glivedo .liveness case.
pbc pbc flivenessbc t gi g end for .check divergence conditions.
bc filterdivergences dom g pbc ifbc6 then return weak con ict detected bc.
else return no con ict detected .
end if end if end function allpotential models for dom g. recall that the formula to which the tableau construction is applied in our case dom g is satis able i the root node is not removed during the application of the deletion rules.
notice that in algorithm we simply indicate that the goals and domain constraints are contradictory when the tableau is empty root node removed .
when on the other hand tmaintains some nodes after the application of the deletion rules then dom gissatis able .
in this case the approach proceeds to generate potential boundary conditions as described below.
.
generating potential boundary conditions after generating the tableau t the approach proceeds to extract from ta set of of ltl formulas that characterise potential boundary conditions.
more precisely functions safetybc andlivenessbc in algorithm generate these ltl formulas for the safety and liveness cases respectively.
in both cases the ltl formulas are generated in two steps.
first safetybc computes a set of frontier path conditions that escape from tdirecting us into the unsatis able nodes previously removed by the tableau method.
similarly livenessbc rst computes a set of path conditions in tthat avoid passing through the states in which the eventuality of some liveness goal is ful lled.
then given these path conditions safetybc andlivenessbc generate the set of potential boundary conditions from these computed path conditions.
in the remainder of this subsection we introduce some terminology necessary to present the process for extracting potential boundary conditions from a tableau and then we further describe the above mentioned functions.
state constraints successors and path conditions.
lett hn r rootibe a tableau structure.
the state nodes oft see de nition .
contain literals that represent the constraints that the states should satisfy to be part of a model for the formula that was queried for satis ability.
definition .
state constraints .
given a state nodes2sn the state constraints imposed by s denoted by cons s are composed of the conjunction of literal formulas 511thatscontains.
given a set s snof state nodes cons s is de ned asw s2scons s .
cons s then returns a propositional formula that characterises all states that satisfy the conditions imposed by state s. for instance if s f2 p q 3r p q q rg then cons s q r characterising the states in which the proposition qis false and ris true.
notice that according to de nition .
some nodes in n are neither states nor pre states.
for the sake of simplicity let us ignore all these intermediate nodes preserving the transition relation between states and pre states in r. definition .
successors .
given two pre state nodesd1 d22pn succs d1 d2 fs2snj d1 s 2r s d 2rg i.e.
the set of state nodes that transit from d1to d2.
we will use succs d to denote all state nodes that are successors of pre state d i.e.
succs d fs2snj d s 2rg.
definition .
path .
apath d0 s0 d1 s1 dk sk intis a sequence of pairs of a pre state node and a set of state nodes such that .d0 root .8i i k si succs di di andsk succs dk .8i i k si6 aloop free path is a path where di6 dj for i j k. definition .
path condition .
apath condition is asequence of propositional formulas such that there exists a path d0 s0 d1 s1 dk sk for a given tableau t where i cons si for all i k. intuitively a path and its corresponding path condition characterise consistent ways of traversing the tableau t. our approach will consider loop free paths to compute path conditions for producing potential boundary conditions.
the frontier path condition de ned below is used for describing the paths that cross the frontier of the consistent part of the tableau and lead to an inconsistent portion of it.
definition .
frontier path condition .
afrontier path condition is asequence of propositional formulas such that there exists in ta path condition and k. .
.
potential safety boundary conditions function safetybc given in algorithm receives as input the tableau structure t hn r rootiand returns a set of potential boundary conditions.
first it calls function safetyfpcs line to compute a set of frontier path conditions capturing paths that escape from treaching the unsatis able nodes removed during the tableau construction.
safetyfpcs exploreststarting from the rootnode invocation in line and traverses tusing the successors de nition given above set siin lines recovering path conditions line required to nally reach the inconsistent portion of the tableau set skand formula in lines .
the algorithm keeps track of the already visited pre states nodes so loops are not considered lines .
intuitively safetyfpcs computes all the shortest loop free frontier path conditions in t that start in the rootnode and escape from t ending in the unsatis able portion removed previously from t. then function safetybc encodes each frontier path condition as an ltl formula f by nesting each condition in the path using the next temporal operator line .
theresulting formula fis used to generate a potential boundary condition f line .
intuitively this formula indicates that there might be a con ict in our model if condition f is eventually reached since it would lead to reaching the inconsistent part of the tableau.
notice that by applying tofwe are somehow generalising the inconsistency case f. this is necessary because otherwise and due to our analysis being limited to loop free paths the obtained divergences would be too strong representing divergent cases of a xed length .
this generalisation step may however make the candidate boundary condition consistent with the goals and domain so we will have to later on check for inconsistency with respect to these constraints see section .
.
algorithm receives as input a tableau t hn r rooti and returns a set pbc of ltl formulas characterising potential boundary conditions.
function safetybc t pbc pbc frontierpcs safetyfpcs t root for all 2frontierpcs do f k pbc pbc f3 f g end for return pbc end function function safetyfpcs t v d fpc ifv pnthen return else v0 v fd g sk succs d cons sk currfpc fpc fg for alld2pn v0do ifsuccs d d then si succs d d cons si fpc fpc safetyfpcs t v0 d end if end for return fpc fcurrfpcg end if end function .
.
potential liveness boundary conditions function livenessbc in algorithm takes as input the tableautand a liveness goal gi2glive and returns an ltl formula that characterises di erent paths in tthat do not guarantee the eventuality corresponding to the goal gi.
this ltl formula represents a potential divergence between goal giand the other goals and domain constraints.
livenessbc starts by identifying the nodes in tin which the eventuality required by giis ful lled.
that is if giis a reachability goal 3for a response goal g!3f then 3fis the eventuality that gishould ful l. then sentence e eventualities t gi in line will store in ethe set of all nodes from tthat contain formula f i.e.
each node in e satis es the eventuality demanded by goal gi .
for instance ifgi 3p then all nodes from tthat contain proposition p will be in the set e. after that livenessfpcs computes all the loop free path conditions in a way similar to that for the safety case.
however for the liveness case the path conditions computed avoid those paths that pass through the nodes in e. then the main di erence with the safety case is the composition of 512the setssiandskin algorithm .
in particular set sionly considers state nodes that transition to the next pre state node but that are not included in the set e line .
the setskonly contains the nodes that are in e line thus i.e.
cons sk cons succs d e characterises the nodes that do not satisfy the eventuality line .
livenessfpcs then returns the shortest loop free path conditions that avoid reaching nodes in which the eventuality required by giholds.
in line a formula fcharacterising each path condition is generated.
the disjunction of all these formulas captures all the di erent ways of traversing the tableau without hitting a state in which the eventuality of goalgiis satis ed line .
if the goal is a reachability one of the form gi 3f and the computed path condition isfc then2 fc is the potential divergence line .
this ltl formula indicates that there is a con ict if the condition fcalways holds preventing the eventuality frequired by gifrom being ful lled.
if on the other hand the goal is a response one of the form gi f1!3f2 and the computed path condition is fc then f1 fc is the potential divergence line .
this ltl formula indicates that there is a con ict if f1holds at some point but the eventuality f2is never ful lled.
notice that f2 may be satis ed before the condition f1holds but it will not be satis ed an in nite number of times.
the case of a progress goal 23f2is the same as for response simply takingf1 true.
notice again that in both cases by putting fcin the scope of 2we are generalising the divergent case.
intuitively formula 2fctries to characterise the in nite paths in the tableau that do not satisfy the gi s eventuality.
despite the fact that the generated ltl formulas capture con icts with dom g these may be discarded in the following phase because they may not meet all the requirements to be considered divergences e.g.
the minimality condition.
algorithm takes a tableau t hn r rootiand a liveness goalgi and returns a potential boundary condition pbc.
function livenessbc t gi pbc e eventualities t gi fc false pcs livenessfpcs t e root for all 2frontierpcs do f k fc fc f end for ifgi !
then return fc .
giis a response goal.
else return fc .
giis a reachability goal.
end if end function function livenessfpcs t e v d pc .same algorithm as safetyfpcs except the computation of setssiandsk.
.
.
.
sk succs d e cons sk cons succs d e .
.
.
si succs d d e cons si .
.
.
end function .
filtering boundary conditions continuing with algorithm after computing the set pbc of potential boundary conditions for the safety and liveness cases function filterdivergences dom g pbc is concernedwith checking which ones represent actual divergences.
the previous phase produces potential boundary conditions pbc that may fail to be actual boundary conditions because of various reasons i they might be consistent with the goals and domain constraints ii they might not be minimal or iii they might be the negation of a goal.
situation i can arise because despite the fact that we compute path conditions that indeed contradict the goals and domain speci cation since such path conditions are loop free we generalise them weaken them by applying a temporal operator such generalisation may make some potential boundary conditions consistent with the goals and domain constraints.
situations ii and iii are more clear these impose conditions on our potential boundary conditions that the process to generate them does not take into account and thus they must be checked afterwards.
we then have to go through an additional process represented by function filterdivergences that for each ltl formula bc2pbc checks whether bc meets the conditions described in section .
that de ne divergences i.e.
inconsistency with goals and domain speci cation minimality with respect to the set gof goals and that bcis not a trivial boundary condition .
filterdivergences checks inconsistency with goals and domain speci cation by assessing the satis ability of bc g dom using an ltl satis ability procedure minimality i.e.
that for each goal gi2g dom v j6 igj bcis satis able is also checked using ltl satis ability nally checking that bc6 gis just a syntactical check.
filterdivergences discards those ltl formulas in pbc that do not meet the above conditions and returns a set bc pbc of boundary conditions for the goals gin the domain dom.
filterdivergences needs for each potential boundary condition to perform as many calls to the ltl decision procedure as goals are in g to check the minimality condition .
to e ciently perform all these checks we use aalta an e cient ltl satis ability checker recently developed.
the experimental evaluation in section shows that the time required by filterdivergences is small compared to the time required to build the tableau.
.
correctness and in completeness let us discuss now termination correctness and in completeness of our approach.
regarding termination recall that in section .
we explained that the tableau generation process is guaranteed to terminate and the structure generated is a nite graph.
so the tableau contains a nite number of pre state and state nodes.
since the functions to compute the path conditions safetyfpcs andlivenessfpcs consider only loop free paths over a nite graph these are nitely many and thus safetyfpcs andlivenessfpcs terminate.
all the checks performed in the last phase of the approach filterdivergences are made using the ltl satis ability checker aalta that is guaranteed to terminate for a nite number of potential boundary conditions.
thus the whole process is guaranteed to terminate.
regarding the correctness of the approach i.e.
that if the process produces a formula bcthis is indeed a boundary condition notice that the last phase of our approach filterdivergences checks that bcsatis es all the conditions of the de nition of boundary condition see section .
thus guaranteeing correctness.
513regarding completeness i.e.
that if there exists a divergence situation between the goals and the domain our process is able to produce it the situation is di erent.
unfortunately our approach is not complete.
let us provide an example.
consider again goals pand3 p used in section .
to illustrate a tableau.
as we mentioned these goals can be satis ed only when the eventuality pis ful lled in the rst state and in the rest of the trace pholds.
so if pholds in the initial state the goals diverge.
in fact pis indeed a boundary condition it meets the three properties de ning it in section .
.
however our approach cannot compute it since we only produce formulas that contain at least one temporal operator.
in fact our approach will produce formulas 2p 3pand3 p p as potential boundary conditions none of which satisfy the boundary condition de nition and thus are removed by filterdivergences .
.
ev aluation in this section we evaluate our proposal addressing the following research questions rq1 is our approach well suited to detect divergences in goal speci cations?
rq2 are the boundary conditions computed by our approach more general than those derived by related techniques?
rq3 does our approach apply to speci cations that cannot be handled by related techniques?
to answer rq1 we take various case studies from the literature on formal requirements speci cations that feature both safety and liveness goals and evaluate our technique for computing divergences.
section .
reports the results of analysing two case studies the elevator controller and the rail road crossing system .
to answer rq2 in section .
we brie y introduce the pattern based approach to goal con ict detection from and compare divergences computed using our approach against those obtained using the pattern based one.
to answer rq3 in section .
we study a simpli ed version of the tcp protocol whose goals do not correspond to any of the patterns of the previous approach from to assess how our approach deals with them.
finally in section .
we provide further examples and discuss about the scalability of our approach and the succinctness of the computed boundary conditions.
these research questions are answered using a tool that we developed that implements our tableau based goal con ict detection approach.
the tableau generation and potential boundary conditions computation is implemented in haskell and employs a bdd library to simplify expressions when path conditions are collected while computing boundary conditions.
moreover the tool integrates the ltl satis ability checker aalta to e ciently perform all the sat checks required by the filterdivergences phase.
the tool the speci cations for all case studies and a description of how to reproduce the experiments can be found in rdegiovanni ase2016.
all the experiments were run on an intel core i5 processor .2ghz with 8gb of ram running gnu linux ubuntu .
.
for each case study we report the size of the constructed tableau number of nodes and transitions the number of computed potential boundary conditions the number of resulting divergences and the analysis time required for constructing the tableau and for the entire process.
this information is summarised in section .
.
.
case studies we evaluate two case studies taken from the literature the elevator controller introduced in and a simpli ed version of the rail road crossing system taken from .
.
.
elevator controller the elevator controller has one sensor callto detect when a user has called the elevator and one sensor at oor that is set to true when the elevator reaches the oor where the user is waiting.
in addition the controller sends an open signal indicating the door must open.
for simpli cation we assume there is only one user that may call the lift at a time.
the following goal and domain properties are elicited goal achieve formaldef call!
open domain maintain formaldef open !at oor the goal openwhencall indicates that the controller should respond to the user s calling by opening the door.
the domain property dooropenswhenatfloor captures the door s behaviour indicating the door opens only when the elevator reaches the oor where the user is waiting.
our approach computes the following potential boundary conditions .
call atfloor open open .
call open call atfloor open open condition is computed for the safety case while condition is for the liveness goal.
only condition meets the de nition of divergence condition is inconsistent with the domain because the door will open in the next state but the elevator is not at the oor where the user called it .
this formula captures the scenarios in which the elevator has been called but the elevator will not be at the oor where it was called and it will never open the door.
the whole process to compute this boundary condition takes .
seconds.
.
.
the rail road crossing system consider now a simpli ed rail road crossing system .
in this model a train can approach and enter a crossing captured by taandtc respectively.
a car may also approach and enter the crossing captured by caandcc respectively.
the crossing gate may be opened go or closed go .
the following goals and domain properties are elicited goal avoid formaldef tc cc goal maintain formaldef ta!
go domain property trainsnotstop formaldef tc ta domain property carscrosswhengateisopened formaldef cc !ca go our tool computes potential boundary conditions with only one being a divergence in .
seconds.
the identi ed divergence is the following .
cc go ta cc go tc go ta tc this boundary condition reveals a few dangerous situations.
a con ict arises if the gate is open when the train is approaching and the car has not crossed yet.
other similar con icting situation arise when the car is crossing at the same time as the train is approaching or crossing.
.
comparison with divergence patterns we now compare our technique with the only previous formal approach to derive boundary conditions presented in .
this previous approach requires matching goals against a set of pre de ned divergence patterns for which divergence expressions are provided.
to answer rq2 we compare these divergences with those computed by our approach when fed with the pre de ned patterns from .
figure summarises the three divergence patterns presented in in which the goals and domain are speci ed in ltl.
p!
q r!
s q!s p r achieve avoid p!
q q!p p qu p retraction1 q!r p!
qws p r s u p r s retraction2 figure divergence patterns from .
in the case of the achieve avoid pattern the following potential boundary conditions are produced resulting all in divergences .
p q r s q r s p q r q r s .
p q r s p q s .
p q r q r q r s .
p p q r p q r s p q r q r p q r s p q s the entire process for computing and ltering the boundary conditions takes .
seconds.
boundary conditions are computed for the safety case while the last condition is for the liveness goal.
when we compare the pattern based derived boundary condition p r with those computed with our technique we observe that the former implies our boundary condition but not vice versa .
that is boundary condition is more general than that derived by the pattern.
the mentioned implication has been veri ed using a simple ltl satis ability check f1impliesf2i f1 f2 is unsatis able .
from the point of view of succinctness clearly our boundary conditions computed from loop free path conditions in the tableau are more complex and less readable than that derived by the pattern.
when applying our technique to the retraction1 pattern the approach computes the following potential boundary conditions where and correspond to the safety case and to the liveness case .
p q .
p q p q .
p p q p q p q the rst two are discarded because they do not satisfy the minimality condition while formula is identi ed as a divergence.
the whole boundary condition computation takes just .
seconds.
again our computed boundary condition is not as succinct as the pattern based one.
and also as inthe previous pattern our computed boundary condition is more general than the pattern based derived one the pattern based boundary condition implies formula .
when applying our technique to the retraction2 pattern the tool computes the following potential boundary condition which is a divergence .
p q r p q s q r the whole divergence computation takes .
seconds.
since this pattern does not consider liveness goals the boundary conditions were computed for the safety case only.
as with the previous patterns formula is implied by that derived by the retraction2 pattern and consequently our approach is again more general .
notice that for the achieve avoid pattern our approach is able to produce boundary conditions that are not identi ed by the pattern.
thus these characterise additional divergent cases that can be very useful to engineers when analysing con icting situations in goal speci cations.
.
an example not captured by patterns consider the tcp network protocol which provides reliable in order delivery of packets in packet based data transmission.
for simpli cation let us assume that the protocol can send one packet at a time i.e.
it waits for an acknowledgement ack before sending the next packet.
brie y the following liveness goals are elicited for this protocol goals achieve formaldef send!
ackudelivered goals achieve formaldef delivered!
senduack notice that this example cannot be matched to any of the above patterns.
our technique is able to analyse this speci cation and computes in .
seconds the following divergences .
send ack delivered send ack delivered ack delivered send ack delivered send ack delivered .
delivered ack delivered send ack delivered send ack delivered the rst boundary condition evidences a divergence if from a certain point onwards after sending a packet either the ack signal is never received or it is received before the packet has been delivered.
the second boundary condition indicates that the goals are divergent when a packet was delivered but its corresponding ack is never received or a new packet is sent before receiving the ack.
.
discussion let us brie y discuss about the scalability of our approach and the readability of our computed boundary conditions.
table summarises for each case study the size of the constructed tableau number of nodes and transitions the number of computed potential boundary conditions pbcs and the resulting divergences bcs the analysis time required for constructing the tableau and for the entire process in seconds .
moreover to assess the readability of the bcs computed we evaluate the succinctness of the boundary condition computed for each case study we choose the biggest one when multiple pbcs are computed .
we measure the number of literals lit.
and the number of logical and temporal operators involved in the formula l.op.
and t.op.
515resp.
.
we also consider additional more complex speci cations namely the atm telephone and london ambulance service las and formulas resp.
.
table scalability and succinctness summary case tableau pbcs bc succinctness tableau total study nodes trans bcs lit.
l.op.
t.op.
time time elevator .
.
rrcs .
.
tcp .
.
atm .
.
telephone .
.
las .
.
achieve avoid .
.
retraction1 .
.
reatraction2 .
.
table shows that almost all the analysis time is spent in constructing the tableau.
we observe that this is more evident in the speci cations that contain more liveness goals as the tcp atm and telephone case studies.
this is due to the fact that removing the nodes that do not satisfy eventualities requires multiple visits to the tableau.
although we need to perform a more thorough scalability evaluation the e ciency of our approach is promising at least when analysing speci cations that involve only safety goals or a restricted number of liveness goals.
table also shows that the computed boundary conditions involve a considerable number of literals logical and temporal operators hindering their readability.
this is evidently one of the most important issues we need to overcome to help the engineer in understanding the divergences computed and resolving the goal models.
.
related work various informal and semi formal approaches have been proposed for detecting con icts in requirements models .
in addition formal methods for detecting inconsistency have also been proposed in .
these approaches focus on logical inconsistencies only or ontology mismatch.
other techniques for reasoning about inconsistencies based on abduction such as consider generating explanations in the form of conjunctions of ground literals for strong inconsistencies in requirements expressed in quasi classical logic.
our approach focuses on detecting weak inconsistencies and automatically generating general ltl expressions that characterise situations in which inconsistencies may arise.
techniques such as perform consistency checks for requirements expressed as conditional scenarios as a precursor for model synthesis.
these consistency checks would identify inconsistency between two enabled charts.
our work on the other hand focuses on nding a characterisation for enabling conditions that could lead to an inconsistency.
con icts in non functional requirements have also been considered in .
for instance proposes a catalogue of con icts categorising these pairwise according to the frequency in which they occur together.
in an approach for detecting con icts between feature descriptions expressible in ltl is presented.
it focuses on strong con icts i.e.
mutually inconsistent features applies to features of the form p!qu r d and uses a model checker for the con ict check.
our approach focuses on identifying weak con icts characterising them by boundary conditions and is applicable to a wider class of ltl formulas.the technique presented in combines model checking and machine learning to automatically generate a set of obstacle conditions with respect to goals and domain properties expressed in ltl.
it supposes however that each goal is satis able within its domain and focuses on identifying the conditions under which the goal and domain may be inconsistent.
it does not handle situations that arise because the goals themselves are inconsistent with one another.
the resolution of con icts has been the subject of recent work e.g.
.
the technique proposed in makes use of argumentation patterns to elicit compose and relate stakeholders beliefs.
the technique assumes con icts have already been elicited and calculates an inconsistency score between beliefs and goals described informally .
these scores are then used as a guide for engineers as to which goals to resolve.
approaches like propose methods that generate consistency speci cations by construction eliminating the need for detection.
the problem of detecting inconsistency in speci cations is related to that of vacuity detection .
the latter may be a result of the former though inconsistency detection cannot be reduced to a vacuity check.
it is also somewhat related to that of detecting overconstrained speci cations.
for instance proposes an algorithm for extracting a core set of assertions that cause an inconsistency in an alloy model.
the method assumes that inconsistency is already known to exist.
our method however attempts to nd the assertion i.e.
bc that would lead to the inconsistency.
it also relates to that of realisability of speci cations e.g.
in that con icting goals may lead to unrealisable requirements.
.
conclusion and future work detecting inconsistencies early on in the requirements engineering process helps avoiding costly software repairs and also supports systematic requirements elicitation and veri cation activities.
this paper presents a novel approach for detecting divergences in goal speci cations and generating boundary conditions that characterise the cases under which a strong inconsistency could potentially arise.
to the best of our knowledge our approach is the rst fully automated technique for computing goal con icts that applies both to safety and to a wide range of liveness goals speci ed in ltl.
our tableau based method is guaranteed to produce correct results and to terminate.
our approach computes more general formulas than previous related techniques.
however as our boundary conditions are automatically produced from tableau paths that lead to inconsistencies they are often longer and less comprehensible in some cases than the more compact ones derived from patterns.
the presented work opens various lines for future work.
for instance a source of incompleteness of our approach is related to the way we interpret divergent tableau paths applying a kind of generalisation through the application of temporal operators.
we are studying alternative stronger ways of dealing with these divergent paths to be able to identify more boundary conditions.
we are also considering the use of inductive learning techniques to support the inference of more generalised expressions.
our approach relies on a tableaux construction we plan to study more e cient tableau procedures e.g.
to increase our technique s e ciency.
we also plan to exploit tableaux structures for other problems related to requirements speci cations such as obstacle condition identi cation .
.