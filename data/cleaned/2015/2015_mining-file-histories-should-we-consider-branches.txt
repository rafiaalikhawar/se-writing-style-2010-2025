mining file histories should we consider branches?
vladimir kovalenko delft university of technology delft the netherlands v.v.kovalenko tudelft.nlfabio palomba university of zurich zurich switzerland palomba ifi.uzh.chalberto bacchelli university of zurich zurich switzerland bacchelli ifi.uzh.ch abstract modern distributed version control systems such as git offer support for branching the possibility to develop parts of software outside the master trunk.
consideration of the repository structurein miningsoftwarerepository msr studies requiresathoroughapproachto mining butthereis nowell documented widespread methodology regarding the handling of merge commits and branches.
moreover there is still a lack of knowledge of the extent to which considering branches during msr studies impacts the results of the studies.
in this study we set out to evaluate the importance of proper handlingofbrancheswhencalculatingfilemodificationhistories.
we analyze over git repositories of four open source ecosystems and compute modification histories for over two million files usingtwodifferentalgorithms.onealgorithmonlyfollowsthefirst parent of each commit when traversing the repository the other returnsthefullmodificationhistoryofafileacrossallbranches.we show that the two algorithms consistently deliver different results butthescaleofthedifferencevariesacrossprojectsandecosystems.
further weevaluatetheimportanceofaccurateminingoffilehistoriesbycomparingtheperformanceofcommontechniquesthatrely onfilemodificationhistory reviewerrecommendation change recommendation anddefectprediction fortwoalgorithmsoffilehistoryretrieval.wefindthatconsideringfullfilehistoriesleadsto an increase in the techniques performance that is rather modest.
ccs concepts softwareanditsengineering softwareconfigurationmanagement and version control systems keywords version control systems branches mining software repositories acm reference format vladimirkovalenko fabiopalomba andalbertobacchelli.
.mining file histories should we consider branches?.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 12pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction the workflow of modern version control systems vcs such as git extensively relies on branching.
branching support allows developerstomanagemultipleisolatedversionsoftheworkingtree whichcanbemodifiedindependentlyofeachother.branch related operations in git are by design extremely lightweight compared to older vcss .
low cost of branching allows branches to be used for development of individual features for experimenting withdesignsolutions andforpreparingreleases .inallthese examples useof branchesallows teams tokeep themain working treefreeofquestionablecodeandreducesdevelopmentoverhead related to version conflicts .
whilebeingthemostpopularversioncontrolsystemtoday gitisquiteunfriendlyfordatamining .inparticular branching features introduce issues for miners branches can be removed and overwritten andsynchronizationwiththeremoterepositorycan introduce implicit branches with no logical meaning .
despite the difficulties with analysis of git history mining of historical data from vcs is still the basis for a variety of studies which quantitatively explore the development process and suggest approaches to facilitate it .
history of individual files is a particularly important source of information for prominent practical applications like i defect prediction algorithms where metrics based on file history are important features ii code ownership heuristics which are based on aggregation of individual contributions of all authors of the file and iii code reviewer recommendation wherehistoryofpriorchangestofilesserves as a basis for automatic selection of the expert reviewers.
pitfalls of git from the data mining perspective pose common threatstovalidityofeveryofsuchstudies.someofthesethreats suchasmutabilityofhistory arecommonlyacknowledgedbyresearchers e.g.
.nevertheless thereisnowidespreadapproachtohandlingofmergecommitsandbranchesduring mining.
moreover msr studies often do not provide a detailed description of mining algorithms and handling of the branches inparticular orexplicitlyfocustheanalysesonthemainbranchof the repository .
inthisstudy weaimatmakingafirststeptowardtheassessment ofthethreatsarisingfromnotconsideringfullinformationabout brenchinginminingsoftwarerepositorystudies.specifically we focusontheimpactofthebranchhandlingstrategyonextractionof a file modification history.
this task requires a traversal of a repository graph to collect individual commits affecting the file.
we first perform a preliminary analysis on how the mining of file histories is impacted by branches by measuring how much first parent i.e.
history extractable when only considering the first parent of each commitwhentraversingtherepository and full i.e.
thehistory authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france vladimir kovalenko fabio palomba and alberto bacchelli extractable when considering changes in all branches file histories differ from each other.
then we study how performance ofthree msr applications code reviewer recommendation change recommendation and defect prediction that use file modification histories as input data varies when considering branches.
our results show that the first parent and full mining strategies consistently result in different file histories even though the scale ofthedifferencevariesacrosssoftwareecosystemsandrepositories within each ecosystem.
we find that considering the full file historiesleadstoan increaseintheconsideredmsr basedtechniques performancethatisrathermodest.thismarginalincreaseindicates that our findings do not raise any serious questions on the validity ofstudiesthatsimplifytheminingapproach.nevertheless inour workwedevisedamethodandatoolforefficientminingoffullfile histories at scale which we make publicly available .
background severalpriorstudiesfocusontheuseofbranchinganditsadded valuefordevelopers.combined thesestudiesprovidestrongevidenceofimportanceofbranchinginmodernsoftwaredevelopment.
appleton et al.
explore an extensive set of branching patterns andproposeanumberofbestpracticesandantipatterns.buffenbargerandgruell devisepracticesandpatternstofacilitateefficient parallel development mitigating the complexity of branching operations in early vcss.
bird et al.
conclude that developers working in a branch represent a virtual team.
barr et al.
claim thatlightweightbranchingsupportistheprimaryfactorinrapid adoptionofmoderndistributedvcssinossprojects.birdandzimmermann identifycommonproblemsfromimproperbranch usageand proposean analysisto assessmoreefficient alternative branchstructures.shihabetal.
findthattheexcessiveuseof branches is associated with a decrease in software quality.
today smostpopularversioncontrolsystem git wasnot designed to preserve a precise history of modifications which impliesdifficultieswiththeanalysisofthesehistories .analysis of software version histories is not only used to study the developmentpractices butalsotofacilitatedevelopmentwithdatadriven tools.
prominent examples of applications for tools heavily relying on histories of changes of individual files are defect pre diction code reviewer recommendation and change prediction .
notably the complexity of git the mutabilityofitsdatastructure andthedifficultyoffiguringoutthe parentrelationshipsbetweenrevisionscomplicatetheworkofresearchers and prevent some practitioners from using it as their versioncontrolsystem .beingabletoaccuratelyretrievehistoriesofpriorchangesisvitalforefficientuseoftechniquesthat arebasedonhistories.moreover insomecaseshistoriesneedtobe processed to achieve optimal performance of the techniques for instance kawrykow and robillard show that removing non essential changes from modification histories improves the performance of co change recommendation .
.
motivation version control repositories are the key data source for a wide variety of software engineering studies .
with no widespread high level mining tool in use the common wayfor the researchers to mine the histories of repositories is to usehomegrown tools based on low level libraries such as jgit .
while low level operations provide greater flexibility of mining they also undermine the reproducibility of studies as details of miningareusuallynotelaboratedoninthepapers.reproduction packages whereavailable commonlycontaininformationobtained after mining but not the repository mining scripts.
restoring the actual change history from a git repository is challenging anderror prone .
tocome around thedifficulties some studies e.g.
focus on the development activity in the mainbranch thusomittingpartofthechangesintherepository.
this approach may be sufficiently precise for some applications because i insome repositories mostof developmentactivity takes placeinthemasterbranch and ii the rebaseoperationisoften used to integrate changes from branches into the main branch.
however consideration of branches and careful handling of merge commitsmightbeimportantforprecisecalculationofindividual filehistories whicharetheprimarysourceofinputdatainsome contexts such as code reviewer recommendation and change recommendation .
the difference in quality of data between different mining approaches andtheimpactofthechosenminingapproachonperformance of analysismethods driven by historicaldata are not clear and have not yet been explored.
we conduct this study to quantifytheeffect ofconsideringthegraphstructure oftherepository importanceofsuchconsiderationisreportedasoneoftheperils of mining git and to investigate how the difference in the resultsfromdifferentmining approachesimpactsperformanceof msr applications.
whilethefilehistoriesarethemaininputdataforavarietyof msr based techniques there is no guarantee that more complex and precise mining methods ensure an increase in performance of the techniques notable enough to justify the extra mining effort.
with no prior research existing on this topic with this study we seeknotonlytoidentifytheimpactofbranchhandlingstrategyon performanceoffile history basedmethods butalsotocomparethe scale of this impact between different techniques.
this knowledge couldhelpmakeasteptowardsensuringthatmsrstudiesandtheir practical applications employ optimal mining strategies to get the most value out of the repository data.
.
challenges of mining the file histories mining of histories of individual files at large scale is a non trivial task.gitprovidesatoolkitforrepositoryoperations including git log which facilitates retrieval of logs of commits.
however git wasnotdesignedtosupportcarefulstorageandretrievalofhistory of changes which implies several complications with using git log for mining file histories.
specifically performance with no specialized index for file histories in place retrieval of histories of changes for an individual file requires traversalofthecommitgraph.retrievalofhistoriesforeveryfile in the repository tree is very expensive.
handling of renames agitrepositorydoesnotcontainanyrecords of renames and moves of files.
such events are detected based onsimilarityofcontentsofconsecutiveversionsofafile with thresholds defined by the settings of the git client.
as a result authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mining file histories should we consider branches?
ase september montpellier france calculatedhistoryofthesamefileinthesamerepositorymight appear different on different clients.
handling of merge commits and branches thegit logtool whichisoftenusedforanalysisofsoftwarehistories supports an overwhelming variety of settings with over argument options .unlessthetoolisthoroughlysetup somepotentially interesting changes might be implicitly omitted for example by defaultgit log prunes some side branches.
a default approach might not be suitable for some applications.
difficulty of use a wide variety of settings makes the user experiencewith git logquitecomplicated.certainscenariosofretrievalofrepositoryhistoryareevenharder forexample traversingthecommitsgraphforwardintime whichmightbeuseful in some contexts is more difficult.
for example all descendants of a commit can be retrieved with the following command git rev list all parents grep .
.
sha.
awk print this command which only lists the commits without providing any information on the structure is already not trivial.
.
retrieval of file histories history of commits in a git repository can be represented as a directed acyclic graph.
each commit logically represents a stateof the repository s file tree.
each version of the state is based onone or several prior parent version and only the difference in the state between the parent and the current version is actually stored.1infigure left whichpresentsahypotheticalcommittree thecommitparentrelationshipsarerepresentedbyblackarrows forexample commit5istheparentofcommit6.mergecommits whichintegratechangesfrommultiplebranches havemorethan one parent.
in figure commit has two parents and .
in a mergecommitwithmultipleparents thelistofparentsissorted ifbranch aismergedintobranch b thefirstparentofthemerge commit would be the one that branch bwas pointing to before the merge.
in figure parent commits are sorted left to right commit is the first parent of commit .
each commit affects a set of files2and defines their new content relativetotheircontentintheparentcommit.itispossibletosay that a commit affectsa file if its content in the revision which is represented by the current commit is different from its contentin the parent commit or if the file was created removed in the current commit.
it is common to think of a commit as simply a set ofchangesinoneormultiplefiles.thissimplemodelisconvenientandisusedbygititself e.g.
inthe git diff command.infigure affected files are shown in boxes next to nodes of the commit tree.
retrieval of a a history of changes for a given file i.e.
list of the commits that affect this file one needs to traverse the commit graph to identify such commits.
a traversal and handling of commits one by one is necessary because git does not store any auxiliary data that would allow to perform this operation faster.
duringthetraversal itispossibletoeitherfollowallparentsofa merge commit which ensures visiting every transitive parent of the starting point and including all of these commits in the history or only follow the first parent.
1described is a simplified scheme of the storage model of git which is in reality more complex.
2the set can be empty e.g.
in most of merge commits without conflicts.we refer to the traversal strategy that follows all parents and toresultinghistories as full.consideringtheexamplerepository graphinfigure fulltraversalstartingfromthelatestcommitin the repository would include all commits in the repository.
a full history for the file f2would contain all of these commits that affect f2.
an alternative strategy is to only follow the first parentofeverymergecommitduringthetraversal.werefertothis strategy and resulting file histories as first parent.
for the example in figure such traversal starting from commit would only includecommits and .afirst parent history of f2would only include commits from this traversal that affectf2.itisimportanttonotethatthefirst parentstrategydoes not omit merge commits that contain changes to the file relative to its first parent an example of such commit in figure 1is and it is included in the first parent history as well.
the histories for the file f2 as retrieved with both strategies are presentedinfigure right .asthefirst parenthistorycontainsless commits somechangestothefileareomitted.thus usingthefirstparent strategy to calculate quantitative properties of file histories such as number of changes or number of contributors leads to incompleteresults.thetwocasesrepresentedbythetwostrategies areratherextreme thesimplifiedstrategyomitsallchangesthat were made outside the main branch and did not end up in the mainbranchafterarebase.therearelessradicalwaysofsimplifiedhandlingofbranchesthantoomittraversingthebranchcompletely.
forexample onewaytoseethesummaryofchangesinabranch is to inspect the output of git diff between two parents of a mergecommit.thisapproachisadoptedbysomeguiapplications ontopofgit suchassourcetree3.whilethisapproachallowsto retrieve a summary of changes in a branch the individual changes possibly made by different authors are presented together and are not distinguishable which makes the approach less applicable for miningtasks itisimpossibletoidentifyindividualcontributions by count sizes or dates of changes per author.
we find the extreme case of comparing full and first parent histories an appropriatesetting to study the impactof the mining strategy on the results of mining and performance of the methods based on these results.
with the two extreme cases we have thehighest chance of identifying effects not present in less extreme settings.asthisstudyisthefirsttoexploresucheffects weconsider this setting fruitful to highlight the directions for future work.
methodology .
research questions wecenterourinvestigationaroundtworesearchquestions.first we set out to quantify the importance of careful handling of branches duringmining.inparticular we i exploretherepositorystructure tocalculatenumbersofcommitsreachablewithandwithoutconsidering branches and ii analyze differences on a lower level of history of individual files.
thus our first research question is rq1.how does the branch handling strategy impact the results of mining?
having identified the magnitude of the difference between mining approaches that consider and do not consider branches we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france vladimir kovalenko fabio palomba and alberto bacchelli 1add f1 add f2edit f1edit f1 edit f2 edit f2 merge edit f2edit f1 edit f29 edit f1edit f2 edit f1edit f2 merge no changes edit f1edit f2 edit f1edit f2 1add f1add f2edit f1edit f1 edit f2 edit f2 merge edit f2edit f1 edit f29 edit f1edit f2 edit f1edit f2 merge no changes edit f1edit f2 edit f1edit f2 1history of f2 first parent history of f2 full figure construction of file parent connections and resulting file histories investigatetheimpactofbranchhandlingstrategyontheperformance of algorithms relying on history of files such as reviewer recommendation changerecommendation anddefectprediction.
thus our second research question is rq2.how important is the branch handling strategy for applications?
.
mining histories at large scale traversal of the commit tree can take a significant amount of time in some repositories the tree contains hundreds of thousands of commits.ifthisoperationhastoberepeatedformanyorevenall files in the repository which is often the case during mining the repository for file histories it can take a lot of time for larger repositories.
slowness of mining the file histories is a limitation of thestoragemodelofgit whichdoesnotlinkindividualversionsof a file to each other and does not include indices of changes to individual files.
to overcome this limitation we devised an alternative representationofchangesingit aimedatfastretrievaloffilehistories.weusea graphdatabase engine4tostore arepresentation of thecommitgraph.tokeepthedatabasecompact weonlystorethe commit nodes and records of affected files excluding their content.
in addition to the commit parent relationship which is the basis of the commit graph in git we introduce the concept of parent file versions.
a parent version of a file can be defined as a change tothe same file in some other commit which can be reached fromthe current commit with a unique path over the commit parentgraph.
in figure center the file parent connections are representedbygrayarrows.byprocessingtherepository webuildthe graph of parent relationships between file versions and store it in the graph database aside the commit graph.
once the file parent graphisbuilt retrievalofpriorchangestothefileisassimpleas retrieving all transitive parents of the current version which only 4neo4j traversing the whole repository thanks to direct links to parent file versions.
for large scale mining tasks this approach saves time after processing the repository and building the file parent connections it is possible to retrieve full modification histories for several thousand files per second.
figure right presents the resulting histories from traversal of the file parent graph.
.
target systems we take a number of steps to ensure diversity in our target systems .
our dataset consists of repositories from github selected in a stratified manner to include projects of different scale.
usingghtorrent werandomlysample100repositorieswith over commits recorded in ghtorrent database for each and repositories with to commits.
of the repositories turned out not to be publicly available anymore the rest comprise our github sample.
counts of commits as retrieved from ghtorrent are not completely accurate so actual distribution of sizesofrepositoriesinthesampleisslighlymoredisperse.wehave attempted to download and mine all repositories from the apache open source ecosystem of which we succeeded with repositoriesof532.therestoftherepositorieswerenotavailable empty or failed to process with our toolkit.
finally we include and repositories from eclipse and openstack respectively which use gerrit for code review.
the repositories in these two samples belong to the projects concerned bythelatest100 000reviewsineachgerritinstance whichwehave mined to evaluate the performance of a reviewer recommendation algorithm section .
.
we usesmaller subsetsof repositoriesfor partsofrq2.forchangerecommendationanddefectprediction we use samples of repositories from each of eclipse and apache ecosystems.theseecosystems wereselectedbasedon availability of defect data explained in section .
.
.
we use the same sample forchangerecommendation section .
.
.toevaluatereviewer authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mining file histories should we consider branches?
ase september montpellier france recommendation performance we use the repositories of the mostactiveprojectsfromeachofeclipseandopenstackecosystems section5.
.forthequantitativeanalysisofrepositorystructure and file histories rq1 we use all repositories from the four samples.
we report the entire list of repositories in our online appendix .
rq1 difference in mining results our first research question seeks to quantify the differences resulting from the application of two different mining approaches to retrieval of the history of files in git.
.
methodology wedevisedasetofmetricsthatquantifytheeffectofstrategyof branchhandlingontheresultsofmining.afterwards wecompared twoapproachesintermsofthesemetrics i.e.
the first parent one which extracts history only considering the first parent of each commit when traversing the repository and the fullone which extracts all the commits by exploiting the approach described in section2.
.
for each repository we first compute descriptive measures of itsstructure suchasnumberofcommitsthatarereachablefrom head the latest commit in the main branch number of merge commits with more than one parent number of files in the repository and number of unique contributors to the repository.
we usethesemetricstocomparetheecosystemsbetweeneachother and to explore the variation in branching activity within and betweenthem whichisimportantformining forexample differences betweenthe numbersofcommitsreachable dependingonthetraversalstrategydenotetheimportanceofthestrategyformining if only the first parent is considered and traversed some commits are left out while still contributing to the state of the repository at head.
number of merge commits can be used as a proxy measure of branching activity in the repository.
beyond repository wide metrics the way in which branches arehandledalsoimpactsthecalculationofhistoriesofindividual files if only the main branch is considered some changes from file historyare omitted.this effectmight impactvarious applications of file histories ranging from identification of contributors to a file to more complex scenarios such as reviewer recommendation.
to quantify this effect we calculate histories of every file in the repository using both the first parent and thefullapproaches to retrieve all commits that contribute to a given version of a file.
for every repository all of which contain over million files in total we calculate repository wide average length of the history of a file in its tree when retrieved via first parent and full method.
we compute the ratio of these averages and fraction of files for which the two methods deliver different histories among all files in the repository.
in addition we calculate numbers of contributors to eachfileforbothmethodsoffilehistorymining andcomparetheir repository wide averages.
.
results .
.
descriptive metrics.
to display the natural differences between the ecosystems which are not associated with different miningstrategies wefirstpresentthecomparisonoftheecosystemsin terms of natural activity metrics such as sizes of repositories and number of contributors.
the top two rows of figure 2present acomparisonofdescriptivemetricsbetweentherepositoriesinthe four subject ecosystems.
the numbers of commits in the repositories within each ecosystem greatly vary.
a median number of commits in a repository ranges from for github to for openstack.anaveragerepositorycontainsseveralhundredfiles inthefiletreeatheadandthisnumbervariesinallecosystems with a lower variation for openstack.
projects from github are typically developed by only a few authors the median number of contributors for a github repository is .
this value for openstack is with eclipse and apache falling in the middle.
for measures of branching activities repositories from three of the four ecosystems display moderate values the majority of commitsinatypicalrepositoryfromeveryecosystemexceptopenstack is reachable from head.
openstack also stands out in numbers ofmergecommits.inamedianproject almost30 ofcommitsin therepositorythatarereachablefromheadaremerges figure .
alongwithhigherbranchingactivity openstackrepositoriesshow thehighestdifferencebetweennumbersofcommitsreachablefrom head via the first parent and via all parents.
notably repositories from github are much more diverse in termsofbranchingactivitymetrics.weattributethisdiversitytothefactthatprojectsinotherecosystemsarelogicallyconnected with possibly common engineering guidelines and intersecting development teams.
in addition the branching structure of the repositories is possibly impacted by the strategy of integrating the pull requests which are a common part of the workflow at github and can be either merged or rebased.
.
.
file history metrics.
table1presents the statistics on the fourecosystemswithregardtodifferenceinfirst parentandfullfilehistories.overthefourecosystems offilesdisplaydifferenceinhistoriesretrievedviafirstparentandfullmethods.ecosystem wide fractions vary from in eclipse to in openstack.
of the repositoriesinoursamplescontainatleastonefilewithdifferenceinthehistory.fractionofsuchrepositoriesvariesbetweenecosystems from56 ineclipseto97 inopenstack.
ofallcommitsand of all files belong to such repositories which indicates that the difference between first parent and full histories is significant in most of the repositories and cannot be ignored as a rare effect.
distributionsofthemetricsrelatedtodifferenceintheresultsof miningfilehistoriesarepresentedinthebottomrowoffigure .
one metric that indicates the importance of the strategy of file historyminingforagivenrepositoryisnumberoffilesforwhich historiesretrievedviathefirstparentandviathefulltraversalhave different lengths.
such files exist in of repositories fromapache 173outof260 fromthegithub 220of395 in eclipse and in of openstack repositories.
similarly to the merge activity metrics fraction of files with differenceinhistorygreatlyvarieswithineveryecosystem.median proportionofsuchfilesis8 inapacheandgithub under1 in eclipse and in openstack repositories.
distribution of ratio of the length of the two histories across repositories that contain files withthedifferenceinhistories naturally thismetricisonlydefined forsuchprojects displaysasimilarbehaviouracrossecosystemstofraction of files with the difference in history.
this ratio for eclipse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france vladimir kovalenko fabio palomba and alberto bacchelli table overview of the target ecosystems ecosystemprojects commits files totalwith differencetotalin projects with differencetotal with differencein projects with difference github apache openstack eclipse total apache eclipse github openstacktotalcommitscount of commits in the repository apache eclipse github openstackfilesintreefiles in tree at head apache eclipse github openstackuniqueauthorsinrepounique authors of commits .
.
.
.
.
apache eclipse github openstackmergecommitfractionfraction of merge commits among commits reachable from head .
.
.
.
.
apache eclipse github openstackreachablecommitfractionfraction of commits reachable from head among all commits in the repository .
.
.
.
.
apache eclipse github openstackmainbranchreachablefractionfraction of commits reachable from head via the first parent among commits reachable from head .
.
.
.
.
apache eclipse github openstackfractionoffileswithdifffraction of files with different sizes of history first parent full .
.
.
.
apache eclipse github openstackhistorylengthratiototalaverage ratio of history lengths first parent full all files .
.
.
.
apache eclipse github openstackavgcontributorsratiototalaverage ratio of numbers of contributors in first parent full histories all files figure comparison of descriptive metrics between repositories in different ecosystems repositories is the highest of the four the histories are the most similar median ratio is .
and the lowest for openstack .
.
if we omit the files with identical first parent and full histories and only consider the files with the difference an ecosystem wide median value for average ratio of history lengths in a repository ranges from .
to .
for openstack and eclipse respectively.
thevaluesfortheaforementionedmetricsindicatethat inmost of the repositories from all four ecosystems the first parent strategy leaves out a significant number of changes.
the proportion of filesaffectedbythedifferenceandthescaleofthisdifferenceare the lowest for eclipse and highest for openstack.
onestraightforwardpracticalapplicationoffilehistoriesisretrieval of contributors to a file.
developer tools with code viewing features such as github display contributors to the current file in theuserinterfaceoffilecontentdisplay.figure 2displaystheratios of counts of version control user records in first parent and full histories.whiletheratioiscloseto1formostoftherepositoriesin eclipse github and apache there are quite a few repositories withlargedifferenceineachoftheseecosystems.formostofthe repositories in openstack retrieval of histories via the first parent ofthecommit leavesoutover25 of contributorrecords median value of the ratio is .
.
only considering the files with different histories naturally leads to an even stronger effect.
.
.
summary.
the analysis of the results of mining across over1 400repositoriesinthefoursubjectecosystemsrevealsthat inmostoftheconsideredrepositories thetwostrategiesofmining file histories deliver different results figure table1 .
the size of the difference for a typical repository varies across the four ecosystems and is the lowest for eclipse and the highest for openstack.thesizeoftheeffectalignswiththeproportionofthemergecommitsinrepositoriesandreachabilityofcommits figure .the differencebetweenthehistoriesdoesnotonlyimpacttheirquantita tivemetrics butalsodistortstheobservednumbersofcontributors authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mining file histories should we consider branches?
ase september montpellier france toafile.weexploretheimpactoftheminingtechniqueonthemore complex repository analysistechniques relyingof filehistories in the next research question rq2 section .
rq2 importance for applications to evaluate importance of the mining approach for practice we comparetheperformanceofthreeprevalenttechniquesbasedon historiesofchanges i recommendationofcodereviewers ii change recommendation and iii defect prediction .
itisimportanttonotethat whilewecomparethenumbersof performance of the techniques we do not perform statistical tests toassessthesignificanceofthedifference because i wearemerely demonstratingtheexistenceofthedifferenceforindividualprojects fromoursamples ratherthantryingtogeneralizetheresultsfor a broader population of projects and ii statistical tests such as mann whitney u which arecommonly usedfor thispurpose are not applicable in our case because measures of performance ofconceptually similar algorithms on related data from the same projects cannot be considered independent samples .
.
code reviewer recommendation .
.
methodology.
recommendation of reviewers for code reviewhas thegoal offinding themostqualified reviewerfor anew codechangecommittedonarepository .suchrecommendation toolsusuallyminethechangehistoryinformationtoidentifythe developer that is more expert on the piece of code impacted by the change under review.
thus it represents a prominent example of usage of file histories to assist developers in routine tasks.
in thelastfewyearsthereviewerrecommendationalgorithmshave beenadoptedbyindustrialcodereviewtools suchasgithub gerrit and upsource .
we focus on two open source ecosystems that use gerrit for code review eclipse and openstack .
for each of the two gerrit instances we extract the most recent codereviews.wechoosethisnumbertohaveasufficientlylarge dataset whichwould however notincludeallofthereviewsinthe correspondinginstances butonlytwosets similarinsize ofthe mostrecentreviewsfromeachinstance.weassesstheimpactof the file history retrieval method on accuracy of recommendations of code reviewers based on the history of changes.
we perform the evaluationtofindoutwhethertheaccuracyofrecommendations changesdependingonmethodoffilehistoryretrieval butnotto achieve maximum possible accuracy.
thus we resort to a trivial reviewerrecommendationalgorithm basedoncountsofdevelopers priorcontributionstothefilesunderreview.weevaluatethe recommendations by comparing a list of recommendations with actualreviewersofachangeset asrecordedingerrit.toassessthe accuracyofrecommendations weusetwocommonwisemetrics mean reciprocal rank mrr and top k precision .
.
.
results.
table2presents the results of evaluation of reviewerrecommendationalgorithmbasedonauthorsofpastchanges to files under review.
we compare the accuracy of the algorithm betweenthetwo variationsofinputdata first parent andfullfile histories.
for each of the two ecosystems eclipse and openstack wecomparetheaccuracynumbersfor20projectsineachecosystem.
the selected projects are the most represented among 000latest code reviews in the corresponding gerrit instance.
we re port values of mean reciprocal rank and top k accuracy for k in average for all reviews in the project for the recommendation lists based on both first parent and full histories of files under review and explore the difference between these values.
to keepthetablecompact weonlyreportthe5mostactiveprojects fromeachecosystemindividually andaggregatedvaluesforthetop 5andtop20projects.toillustratethescaleofdifferencebetween filehistories wealsoreportaveragecountsofcommitsintheunion ofhistoriesoffilesunderreview forbothmethodsofretrievalof file histories and the ratio of these numbers for the two methods.
for the eclipse ecosystem the difference in recommendation accuracy is subtle mrr and all top kprecision values only vary very slightly between first parent and full histories consistently acrossallprojects.fortheopenstackecosystemthedifferenceis slightlymorepronounced.whilemrrvaluesonlydifferslightly top kprecision values differ increasingly for higher values of k. this difference indicates that the full histories of files may include changes made by future reviewers of a file that are not presentin the first parent histories.
the increase in the size of the effect with the increase of ksuggests that authors of such changes are typicallynotthemaincontributorsofthefile astheyenduparound k thpositioninthelistofpastcontributorssortedbynumbersof contributions thusstartingtoaffectthetop kprecisionvaluefor the corresponding kand higher.
thedifferenceinthesizeoftheeffectbetwenthetwoecosystems can be explained by the fact that the difference between the full andfirst parenthistoriesismuchhigherforopenstackrepositories than for eclipse.
in openstack the full histories of commits forallfilesunderreview inunion containonaverage5.26times asmanychangesasthefirst parenthistories.ineclipse theaveragedifferencebetweensizesofhistoriesisunder20 .suchalow differenceisunlikelytocausealargedeviationofthetwosorted contributorlists andisthusnotcriticalfortheaccuracyofreviewerrecommendationbasedonhistoryofchanges.alargedifferencein openstack however noticeably impacts the accuracy of reviewer recommendation.
.
change recommendation .
.
methodology.
anotherexampleofusageofhistoricaldata toimprovetheuserexperienceofdevelopmentprocessisrecommendation of changes based on mining of association rules for changestoindividualfiles.apracticalapplicationforthistechnique wasdescribedbyzimmermann etal.
inparticular givenanew codechangeasinput theirtechniquesuggestsrelatedchangesthatthedevelopermightwanttoapplybasedonthefilesthatfrequently change with the modified file.
we perform an experiment to assess the effect of using full histories of changes to a file compared to using the first parent histories.
the original design by zimmermann uses a set of changes from version control to infer file association rules.
to apply the approachtoourareaoffocus differenceinresultsofminingof individual files we adapt the design of the original tool.
we use two different approaches to infer the association rules from past changes and evaluate their performance in predicting a change of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france vladimir kovalenko fabio palomba and alberto bacchelli table results of reviewer recommendation evaluation on projects from eclipse and openstack mrr top precision top precision top precision top precision top precision changes per review project openstack reviewsreviews w difffirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull ratio openstack tripleo heat templates .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
openstack releases .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
openstack cinder .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
openstack requirements .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
openstack infra zuul .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total openstack top .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total openstack top .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
project eclipse reviewsreviews w difffirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull ratio papyrus org.eclipse.papyrus .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jgit jgit .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
linuxtools org.eclipse.linuxtools .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
egit egit .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
platform eclipse.platform.ui .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total eclipse top .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total eclipse top .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total eclipse top openstack top .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
a given file in the commit.
the common part of the two algorithms is their context and input data.
below we use the notation f cto denote that the commit c affectsthefile f i.e.
thefileis modified init.bothalgorithmstry to predict the change to the file fcurrentin the current commit ccurrent.
inthefirstalgorithm single file weinfertheassociationrules fromthecommitsthataffectedthisfileinthepast c ciaffects fcurrent .
in the second algorithm other files we infer the rules from thecommits thataffectedevery oftheother filesin thecommit c c ciaffects fk fk f fi ccurrent fcurrent we evaluate both algorithms and compare their performance depending on the type of file histories in use first parent or full.
intuitively a full history contains more information about past changes which allows one to infer more association rules someof which are more likely to match the current change.
however sinceweareinterestedindifferencebetweenthetwomethodsof file history mining in terms of their capability to provide information to inferthe association rules from pastchanges quantitative difference is explored by rq1 we make adjustments to account for the difference in sizes of the two histories we only include the predictions where the histories are different otherwise they performequally wetrimthefullhistorytothesizeofthefirstparent history taking the most recent commits into account to inferrulesfromthesamenumberofcommits wesorttherules bysupportand trim the larger ruleset to match size with smaller to account for the possible difference in the number of rules .
inaddition tobringthealgorithmclosertoapracticalapproach weonlygeneratethepredictionswhenthefollowing empirically derived criteriaaremet i wedonotconsiderlargecommitswithmorethan10changeswheninferingtherules theyrarelyrepresent meaningful changes ii we only execute the algorithm when thesmaller of two histories contains at least commits otherwisethe history is too trivial to learn meaningful rules from iii weuse at most most recent commits from the history to infer therules tocapturethe currentstateoflogical couplingbetween files iv we useat most 10rules with the highest support values recommendationlistsarefiniteandsmallinpracticalcontexts .we useanopensourceimplementation oftheapriorialgorithm to infer the association rules.
a formal definition of the concept of an association rule is available in literature .
imitatingareal lifecontextofrecommendationofchanges we derive a recommendation set from the set of rules as a union ofall one item sets of headsof the rules bodiesof which are fully contained among the other files changed in the commit c. weusearandomsampleof10projectsfromeachofapacheand eclipse ecosystems for evaluation.
we select these projects to alignthesamplewiththesampleusedfordefectprediction section .
.
for which the choice of target systems is restricted by the issue tracker in use.
.
.
results.
table3presentstheresultsofevaluationofchange recommendation.
an event corresponds to a single case when association rules have been successfully generated using both firstparentandfullhistories.insomeevents noneoftherulesmatchthe setofchangesinthecommit sonorecommendationscanbeproduced.rateofsucheventsispresentedinthelastcolumnoftable .
the setup and the algoritms are described in detail in section .
.
.
in the context of this study we are interested in comparing the performanceoffullandfirst parenthistoriesastheinputdatafor each of the two algorithms.
the other files algorithm which uses histories of the other filesinthecommittoproducetheassociationrules producesmore eventsandgeneratesmorerecommendationsonsampledrepositories from both apache and eclipse.
however only under of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mining file histories should we consider branches?
ase september montpellier france table3 comparisonofperformancemetricsforchangerecommendation by mining approach and ecosystem apache algorithmhistory typeevents countrecommendations average rules average success ratefailure rateno prediction rate single filefull .
.
.
.
.
first parent .
.
.
.
.
other filesfull .
.
.
.
.
first parent .
.
.
.
.
eclipse algorithmhistory typeevents countrecommendations average rules average success ratefailure rateno prediction rate single filefull .
.
.
.
.
first parent .
.
.
.
.
other filesfull .
.
.
.
.
first parent .
.
.
.
.
table comparison of performance metrics for defect prediction by mining approach and ecosystem precision recall f measure auc roc project apache defectsfirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull delta calcite .
.
.
.
.
.
.
.
.
.
.
.
falcon .
.
.
.
.
.
.
.
.
.
.
.
james .
.
.
.
.
.
.
.
.
.
.
.
lens .
.
.
.
.
.
.
.
.
.
.
.
lucy clownfish .
.
.
.
.
.
.
.
.
.
.
.
madlib .
.
.
.
.
.
.
.
.
.
.
.
predictionio .
.
.
.
.
.
.
.
.
.
.
.
qpid proton .
.
.
.
.
.
.
.
.
.
.
.
ranger .
.
.
.
.
.
.
.
.
.
.
.
r eef .
.
.
.
.
.
.
.
.
.
.
.
overall apache .
.
.
.
.
.
.
.
.
.
.
.
project eclipse defectsfirst parentfull deltafirst parentfull deltafirst parentfull deltafirst parentfull delta acceleo .
.
.
.
.
.
.
.
.
.
.
.
chemclipse .
.
.
.
.
.
.
.
.
.
.
.
efxclipse .
.
.
.
.
.
.
.
.
.
.
.
epp .
.
.
.
.
.
.
.
.
.
.
.
hudson .
.
.
.
.
.
.
.
.
.
.
.
platform.releng .
.
.
.
.
.
.
.
.
.
.
.
recommenders .
.
.
.
.
.
.
.
.
.
.
.
swtbot .
.
.
.
.
.
.
.
.
.
.
.
tcf .
.
.
.
.
.
.
.
.
.
.
.
downloads .
.
.
.
.
.
.
.
.
.
.
.
overall eclipse .
.
.
.
.
.
.
.
.
.
.
.
overall apache eclipse .
.
.
.
.
.
.
.
.
.
.
.
these recommendationsare successful.the single file algorithm using rules inferred from the history of a single file generates less recommendations of which around a half are successful.
the fullhistoriesperformslightlybetterastheinputdataforbothalgorithms in both ecosystems depending on the ecosystem and algorithm they yield5 m o r er e commendations which are more likely to be successful i.e.
to match an actual change .
.
defect prediction .
.
methodology.
thelastapplicationaimsatrecommending developers the files that are more likely to contain defects .
inourstudy wetakeintoaccountthebasiccodechangemodel bccm predictionmodeldevisedbyhassan whichisbasedontheentropy ofchangesappliedbydevelopersin acertaintime windowandiscomputedexploitingtheconceptofshannonentropy .weconsiderthemodelbyhassan ratherthanmorerecent ones e.g.
since i weareonlyinterestedinmodelsrelyingon changehistoryinformation thuswecannotconsidermodelsbased onproductmetrics and ii bccmperformssimilarlytoothers proposed in literature thus still being representative of the field .ourconjectureisthatthequantificationoftheentropymay be more precise when considering the full history of files rather than the single parent case.
we perform a replication of the study by hassan consideringthebccm.itsplitsthechangehistoryofasoftwareproject intothree monthtimeperiods andadoptsathree monthsliding windowtotrainandtestalogisticregressionclassifier thatis the one adopted in the original study byhassan .
in other words starting from the beginning of the history it computes the entropy ofchangesonthefilesavailableinatimewindowandusessuchdata to train a classifier that predicts the defectiveness of files in thesubsequenttimewindow.theprocessisthenrepeateduntilthe endofthehistory.giventhenatureofthemodel weevaluateits performance in the two scenarios i.e.
single parent vs full by consideringthemeanf measureandauc roc achievedwhen run on each time window.
inthiscase weruntheexperimentover20randomlysampled systemsbelongingtotheapacheandeclipseecosystemsconsidered in the study their names are reported in the online appendix .
we do so because to extract actual defects composing the ground truthonwhichcomparetheresultsofthemodelagainst werelyona issue tracker mining tool based on bugzilla and therefore we limitthisstudytotheecosystemsthatuseit.ourgroundtruthis representedbypost releasedefectsmarkedassolvedbydevelopers on the issue tracker.
as such we consider as defective all thosefiles that have encountered a problem in a certain time window according to the timestamp of the bug report.
.
.
results.
table4reports the results achieved when considering the problem of predicting defects using the bccm model defined by hassan in case of single parent or full history configuration.
overall the delta between the two approaches is not largeforanyoftheevaluationmetricsconsidered.forinstance the f measure is only higher in both apache and eclipse respectively.thus inafirstglancewecanclaimthatconsideringbranches does not improve the defect prediction performance.
nevertheless finerobservationsrevealtwoaspectsthatitisworthtohighlight.in the first place the model built using the single parent strategy has alwaysperformance equal or lower than the one that considers the full history thus taking into account the full set of changes is not detrimental inthecaseofdefectprediction.conversely thefullhistory approach provides benefits in and of the cases when considering f measure and auc roc respectively meaning that defectpredictionperformancecangenerallygainwhenconsidering allthechangesratherthanasubsetofthem.itisinterestingtonote thedifferencesarehigherwhenconsideringtheauc roc i.e.
the evaluation metric suggested by previous work to evaluate defect prediction models specifically it is up to higher on the repositoryoftheapachefalconproject showingthatconsideringthefullhistoryoffilescanprovidestrongimprovements.therefore authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france vladimir kovalenko fabio palomba and alberto bacchelli basedonourfindings wecanfinallyclaimthattakingthewhole historyintoaccountwhenbuildinghistory baseddefectprediction models might provide important benefits in terms of performance.
limitations and threats to validity a number of limitations affect the results of our study and pose potential threats to its validity.
whendesigningtheexperimentstocompareperformance we tried to follow the original approaches as closely as possible but it was not always possible completely e.g.
with changeprediction thusresultsontheoriginalapproaches may differ.
while we used a diverse population of projects from four independentecosystems itisnotclearwhetherandhowour results can be generalized further.
ouranalysisincludedanextensivetechnicalwork although wetesteditcarefullyandunderseveralscenarios wecannot guaranteethatcodeisbug free.however wemakethecode available in the online appendix .
discussion and implications .
discussion ourresultshighlightseveralimportantaspectsregardingthechoice of the mining strategy.
thetechnicaldetailsofminingcansignificantlyimpactthe quantitative properties of the retrieved data.
in case of our study such properties are the sizes of file histories and numbers of contributors inover2millionfilesfromourcompositesampleof four ecosystems the resulting histories differ for of files.
the size of the difference varies across projects and ecosystems.in openstack projects the first parent and full histories are differentfor55 offiles whileineclipseprojectsweobservethe difference for only of files.
thesizeofthedifferenceisassociatedwithotherproperties of a repository.
in our case the ecosystem with the highest difference i.e.
openstack also demonstrates the highest merging activity most of which can be attributed to code review after asuccessful code review in openstack changes are merged back into the trunk by a bot.
thus high proportion of merges and their impactonfilehistoriescanbeconsideredaconsequenceoftheirdevelopment workflow namely code review.
notably while a similarworkflowwithcodereviewsperformedwithgerritisalso present in eclipse this ecosystem displays the lowest degree of difference changesineclipsearetypicallyrebased butnotmerged aftercodereview.theimpactofthisparticularfactorontheresults of repository mining deserves a deeper analysis in future work.
thedifferenceinresultsofminingcaninfluencetheperformanceoftechniquesbasedonfilehistories reviewerrecommendation changerecommendation anddefectprediction.
forallofthetestedapproaches fullhistories whenusedasinput data perform at least not worse than first parent histories in most cases yielding a slight increase in performance.
someapplicationsaremoresensitivetoqualityofinputdata thanothers.
inourcase forreviewerrecommendationinopenstack full histories provide better accuracy especially when longerrecommendation lists are evaluated top and top accuracy .
openstack also happens to be the ecosystem where the difference between the first parent and full histories is the highest.
at the sametime eclipseprojectsshowthesmallestdifferencebetween the first parent and full histories among all four target ecosystems and this small difference appears insufficient to influence accuracy of reviewer recommendation.
.
implications consideringthepointsabove weseeseveralimportantimplications of our results.
software engineering researchers should be aware ofthepossibleimpactoftheminingtechniqueonthere sults.
ourstudydemonstratesthatomittingchangesoutside the main branch during mining of file histories significantly impactstheresultsofmining whichoftenleadstoaslight decrease in performance of methods that use file histories as input data.
the choice of the mining technique should accountfor the context of the mining task.
whileusingfullfile historiesensuresabetterperformance inmostcasesthedifference is only marginal.
in many contexts a small increase inperformancemaynotjustifydedicatingtheextraeffortto moreprecisemining.whilewesuggestusingprecisemining methods where possible and provide a tool for that in many contexts it is not essential.
researchersshouldreportthetechnicaldetailsofmin ing.
wesuggestthattechniquesofrepositoryminingshould be described in more detail by authors of msr studies asnot providing details complicates reproducibility of studies and oversimplifying the mining potentially undermines performance of methods and validity of studies.
conclusion withthestudypresentedinthispaper wemakethefollowingmain contributions thefirstdemonstrationoftheimportanceofcarefulhandlingofmergecommitsandchangesfromoutsidethemainbranch for calculation of file histories analysisofimpactofastrategyofminingfilehistorieson performanceofthreetechniquesrelyingonthemasinput data atoolforefficientminingofprecisefilehistoriesingit .
ourresultscovertheunderrepresentedtopicoftechnicaldetails of mining the repositories for file histories and open opportunitiesfordeeperanalysisofassociatedfactors suchastopologyofchange histories.
we hope that this study will inspire other researchersin msr to apply a more detailed approach to mining where it isfeasible and to report the technical details of mining to ensure clarity and reproducibility of the studies.