practically tunable static analysis framework for large scale javascript applications y oonseok ko kaist mir597 kaist.ac.krhongki lee kaist petitkan kaist.ac.krjulian dolby ibm research dolby us.ibm.comsukyoung ryu kaist sryu.cs kaist.ac.kr abstract we present a novel approach to analyze large scale javascript applications statically by tuning the analysis scalability possibly giving up its soundness.
for a given sound static baseline analysis of javascript programs our framework allows users to define a sound approximation of selected executions that they are interested in analyzing and it derives a tuned static analysis that can analyze the selected executions practically.
the selected executions serve as parameters of the frameworkby taking trade off between the scalability and the soundnessof derived analyses.
we formally describe our framework inabstract interpretation and implement two instances of theframework.
we evaluate them by analyzing large scale real worldjavascript applications and the evaluation results show that theframework indeed empowers users to experiment with differentlevels of scalability and soundness.
our implementation providesan extra level of scalability by deriving sparse versions of derived analyses and the implementation is publicly available.
i. i ntroduction javascript applications are prevalent these days and their sizes become larger and their program logics become more complex.
one can find various kinds of applications writtenin javascript including games compilers and evenoperating systems .
the extensive uses of multiplelarge scale libraries 1such as jquery2 mootools3 prototype4 and yui5are one of the sources of the problem.
however statically analyzing large scale javascript applications is very challenging.
extremely dynamic features ofjavascript like run time code generation and heavy uses offirst class functions complicate static analysis of programflows .
in addition to normal control flows in programs javascript involves diverse exception flows which add com plications to control flow graphs of programs and in turn to their static analysis.
while most c program analysesignore infrequent uses of exception behaviors by setjmp andlongjmp and ml like program analyses use stronglytyped language features to analyze exception flows and todetect uncaught exceptions dynamic changes of objectproperties including prototypes and the lack of static typesystem in javascript make the static analysis of its exceptionflows much more complex and unscalable.
1javascript libraries are often called frameworks.
large scale c programs a general sparse analysis framework has been very successful in implementingpractical analyzers but it may not be applicable to otherlanguages like javascript.
the authors discussed it as an openissue as follows applying our framework for other languages maybe more difficult than that for c. for instance fordynamic languages such as javascript our simpleflow insensitive pre analysis may not be effective since too imprecise analyses can take much timefor those languages.
designing a pre analysis thatis cheap yet precise for other languages remains anopen problem.
indeed our experimental results show that simply applyingthe general sparse analysis framework to javascript is noteffective.
unfortunately even state of the art javascript analysis techniques are often sound but impractical or practical but un sound.
most javascript analysis frameworks like safe t ajs and w ala providetraditional sound static analyzers which are not yet practicallyscalable.
in addition w ala provides a new intentionally unsound static analysis especially designed for scalability.
since w ala was originally designed for sound static analysisof java programs it provides a sound propagation based analysis pb of javascript programs similarly for java program analysis.
however because such a sound analysis has shownto be impractical not being able to analyze the most widelyused javascript library jquery w ala provides yet anotherjavascript analysis an unsound field based analysis fb b y constructing lightweight and unsound call graphs whichhas been successfully used for a commercial product ibmsecurity appscan .
given that the problem of scalable sound static analysis of large javascript applications is still an open problem users may get more benefits from focusing on a subset ofprogram executions.
instead of attempting to analyze the entireprogram flows analyzing program executions selectively maybe a reasonable option.
as a recently introduced term soundiness denotes attempting to capture the balance prevalent in practice of over approximated handling of most languagefeatures yet deliberately under approximated handling of afeature subset well recognized by experts may be a desirable 30th ieee acm international conference on automated software engineering .
ieee approach to take and many modern analysis applications like ides security analyses and bug detectors do not requiresoundness.
as we describe in more detail later in this paper one may prefer to use a sound and elaborate analysis tounderstand every possible execution flow of a given program.or one may want to use an efficient analysis for a selectedsubset of program executions that they are interested in.
in this paper we present a novel approach to analyze largescale javascript applications statically by tuning sound baseline analyses for scalability using approximation of selected executions of interest to users possibly giving up soundness.
our framework takes a static baseline analysis that over approximates the javascript semantics and a pre analysis that over approximates a subset of program executions andproduces a tuned static analysis that can analyze the selected executions practically.
the framework allows users to identifya subset of program execution flows that they are interestedin analyzing to take trade off between the scalability and thesoundness of derived analyses.
users can tune the trade off between the scalability and the soundness of derived analyses by using pre analyses of se lected executions as parameters.
the fewer program executionflows a pre analysis covers the more a derived analysis wouldbe scalable but unsound.
we formally describe our frameworkin the abstract interpretation setting and evaluate theframework by using two instances swp derived from safe as a sound baseline analysis and w ala s pb as a sound pre analysis and swf derived from safe as a sound baseline analysis and w ala s fb as an unsound pre analysis.
ourexperiments with real world javascript applications show that swf may miss some analysis results that swp can obtain but it is indeed more scalable and still precise.
users may wantto find an appropriate balance between the soundness and thescalability by tuning the coverage of pre analyses.
our imple mentation also provides an extra level of scalability in termsof analysis performance by deriving sparse versions of derived analyses and the implementation is publicly available .
the contributions of this paper are as follows we present a novel approach that allows users to decidethe trade off between the scalability and the soundnessof static analysis.
we formally present the framework in the abstract interpretation setting.
it clearly describes assumptions andrequirements to use the framework and it proves thesafety of derived analyses.
we show how to use the general framework with two concrete instances using the state of the art javascript analyzers safe and w ala. the instance swp shows that simply applying the general sparse analysis frame work to javascript may not be effective and the instance swf shows that focusing on selected program executions enables analysis of large scale javascript applications.
we make our implementation publicly available .
our experimental results show that the framework de rives tuned static analyses that can analyze real worldjavascript applications practically.the rest of the paper is organized as follows.
we illustrate complications of statically analyzing javascript libraries usinga concrete code example from the yui library section ii .
weformally present the framework that takes a baseline analysisand a pre analysis as inputs and derives a tuned static analysisin the abstract interpretation setting and we prove the safety ofthe derived analyses section iii .
to show how to instantiatethe general framework we describe two concrete instancesof the framework using safe as a baseline analyzer andtwo analyses of w ala as pre analyses section iv .
then we describe our implementation section v and evaluatethe framework using two instances section vi .
we discussrelated work section vii and conclude section viii .
ii.
m otiv a ting example while much progress has been made in analyzing modern javascript applications that rely heavily on multiple libraries significant challenges still remain for achieving a good balanceof the analysis cost and precision.
this is largely due to librarycode making extensive use of dynamic javascript features especially first class property accesses.
we use figure takenfrom the yui library to illustrate the situation.
the mix function in figure essentially implements a form of mixin based inheritance to provide object orientedfeatures within javascript code.
the mechanism is to copyproperties both code and data from its second argument supp to its first argument recv mimicking the effect of inheritance.
the other arguments of mix determine the details of copying overwrite andmerge denote whether to overwrite or merge properties white if specified lists properties to be copied and excludes all other properties from copying and mode denotes whether and how to copy prototypes of objects.
thus lines determine the source from and the destination to of copying depending on mode lines copy only the whitelisted properties and lines copy all the properties.
this poses a challenge to analyses that have to reason about statements like to from on lines and an a ve analysis that simply approximates the values of key with the set of all possible property names will produce anextremely imprecise result that all properties of from flow into all properties of to.
in addition traditional analyses have also suffered from extreme cost as the level of imprecisionhas caused tremendous amounts of propagation.
attempts toprovide better results have largely taken two approaches.
one approach has been to apply ever more aggressive forms of analysis sensitivity to disam biguate the behavior such as aggressive flow and contextsensitivity transformations of for in loop bodies to expose more opportunities for context sensitivity and even exploitingdynamic information to improve static analysis.
this approachhas shown the ability to handle ever increasing complexity injavascript but nothing has yet been shown to robustly handlemodern framework based code.
for any calls to mix for example distinguishing the use of different properties in each loop iteration requires multipleapplications of techniques such as correlation tracking .
5421y.mix function recv supp overwrite white mode merge var alwaysoverwrite exists from i key len to if !recv !supp return recv y if mode if mode y.mix recv.prototype supp.prototype overwrite white merge from mode mode ?
supp.prototype supp to mode mode ?
recv.prototype recv if !from !to return recv else from supp to recv alwaysoverwrite overwrite !merge if white for i len white.length i len i key white if !hasown.call from key continue exists alwaysoverwrite ?
false key into if merge exists isobject to true isobject from true y.mix to from overwrite null merge else if overwrite !exists to from else for key infrom if !hasown.call from key continue exists alwaysoverwrite ?
false key into if merge exists isobject to true isobject from true y.mix to from overwrite null merge else if overwrite !exists to from if y.object.
hasenumbug y.mix to from overwrite y.object.
forceenum mode merge return recv fig.
code excerpt from the yui librarybut more is required since precision also depends on precise handling of merge to avoid potential pollution from extraneous recursive copies on lines and .
and beyond that notethat calls to mix may use different values of mode on lines and but mode on line .
there are four possible options which require understanding constants to distinguish once again needed to avoid pollution from extraneous copies.
given this degree of complication the other approach has gone the other way making the analysis less pre cise to address the cost explosion of traditional analysis.the field based approach for example abandons objectsensitivity entirely using a single location globally for eachfield.
this approach addresses the issue of statements like to from since they become no ops for analysis and can be ignored.
while this approach has been shownto scale it loses precision and or soundness in many cases.
however this approach suffers from severe but different issues of its own.
even a very simple code like the following 1var f x function a .
.
.
2var g x function b .
.
.
3f.x will be imprecise because a field based analysis does notdistinguish between fields in different objects with the samename it concludes that f.x on line points to either function aorb.
thus there is still no technique in the state of the art that robustly handles modern javascript libraries and reliablyprovides good precision and performance.
this motivates our tunable static analysis framework.
even though a sound analysis alone or the field based analysis alonemay not produce precise analysis results a combination oftwo analyses may generate better results than that of eachanalysis.
for example consider the following code using the mix function 1var f x function a ... y function b .
.
.
3var g x function c .
.
.
4var h y.mix f 5h.x a sound analysis may conclude that h.x on line points to either function aorbdue to the analysis complexity of mix .
on the contrary the field based analysis will conclude that h.x points to either function aorcbecause it considers only the property names.
now consider a tuned analysis whichperforms a sound analysis but only within the results of thefield based analysis the analysis results will lie inside theintersection of the results of the two analyses.
the tunedanalysis gets benefits from both analyses which makes itsstatic analysis simpler more efficient and more precise thanstatic analysis of each of them.
our goal is to present a general framework that automatically derives a tuned analysis from two analyses.
the frame work takes a sound baseline analysis and a possibly unsound pre analysis generating a boundary of analysis results likethe field based analysis and it produces a tuned analysis thatperforms the baseline analysis only within the boundary.
c53 c46 c42 c44 c49 c42 c43 c4d c46 c01 c54 c55 c42 c55 c46 c54 c01 c56 c4f c53 c46 c42 c44 c49 c42 c43 c4d c46 c01 c54 c55 c42 c55 c46 c54 c01 c54 c55 c42 c55 c46 c54 c01 c4a c4f c01 c54 c46 c4d c46 c44 c55 c46 c45 c01 c46 c59 c46 c44 c56 c55 c4a c50 c4f c54 c01 c54 c55 c42 c55 c46 c54 c01 c4a c4f c01 c42 c01 c51 c53 c46 c0e c42 c4f c42 c4d c5a c54 c4a c54 c01 fig.
program execution flows iii.
t unable stat i c analysis framework in this section we describe our framework which enables to tune the scalability of static analysis.
consider the execution flows illustrated in figure .
light gray circlesdenote reachable states during evaluation white circles denoteunreachable states during evaluation and dark gray circlesdenote states in selected execution flows.
a sound baselineanalysis approximates all the reachable states possibly includ ing some unreachable states section iii a and a pre analysisapproximates the states in the selected execution flows asdenoted by a closed loop in figure section iii b .
it isa sound approximation of the selected execution flows and at the same time it is an unsound approximation of theentire execution flows.
the framework allows users to tunethe derived analysis section iii c by choosing appropriatesubsets of program executions.
we discuss the impacts of se lected program executions in terms of the analysis scalability soundness and precision section iii d .
a. baseline analysis for the entire semantics the first input to the framework is a baseline static analysis that over approximates the entire semantics of given programs.
the framework assumes that the baseline analysis is designedin the abstract interpretation setting .
collecting semantics.
we denote a program pas a directed graph c e where canderepresent a set of nodes and a set of edges respectively.
a node c cdenotes a control point in the program and an edge c c e c cdenotes a control flow from ctoc .
given a programp we define its collecting semantics using c s f where c a finite set of control points s a powerset of concrete states f c s s a set of local semantic functions at a given control point c c s a set of program states mapping control points to sets of concrete states and a set of control flows for a given program state for a set of concrete states s. a local semantic function f c takes a set of concrete states and returns a union of sets ofresulting states for each of the given states.
a set of controlflows is a subset of control flows eand it is confined by a given program state .
then the collecting semantics of a programpis the least fixpoint of the following semantic function f c s c s f c c.f c c c c .baseline abstraction.
for a baseline analysis that our framework tunes for scalability we require a static analysisdesigned in the abstract interpretation framework.
we assumethat it abstracts a set of concrete states to an abstract state sby the following galois connection s s s s. while the framework does not require any structure on s when sis a function cpo complete partial order l vfor a finite set of abstract locations l land an arbitrary cpo of abstract values v v the framework provides an extra level of scalability in terms of the analysis performance as we discussin section v. then the abstraction of a program state and the concretization of an abstract program state c sfor the baseline analysis are as follows m c c. s c m c c. s c .
the abstract semantics of the baseline analysis is the least fixpoint of the following semantic function f c s c s f c c. f c c c c where f c s sis an abstract semantic function at a given control point cand c cis a set of abstract control flows for a given abstract program state .
the abstract semantic function fis a monotonic function designed in the abstract interpretation framework such that c c. s. f c f c c c. s f c f c s the set of abstract control flows c s c cis an abstract counterpart of c s c csatisfying the following conditions m c s. the first condition means that the set of abstract control flows m is a sound approximation of the concrete control flows for a given program state and the second condition means that is monotonic.
b. pre analysis for selected semantics the second input to the framework is a pre analysis that over approximates a set of selected execution flows of a givenprogram.
in order to analyze only the execution flows of inter est our framework asks for an approximation of the selectedsubset of the whole program executions.
the scalability of theanalysis is parameterized by this set of selected executions.
selected collecting semantics.
suppose that we are interested in analyzing selected execution flows specified by alocal semantic function f ssuch that c c s .f s c f c .
544then we can define a selected collecting semantics that subsumes only the selected execution flows denoted by fsas the least fixpoint of the following semantic function fs c s c s fs c c.f s c c c c .
abstraction for selected collecting semantics.
for a preanalysis that our framework uses to tune the baseline analysis for scalability we do not require it be designed in the abstractinterpretation framework unlike for the baseline analysis.
theframework does not assume anything about the pre analysisexcept that it produces a contour which over approximates the selected execution flows we are interested in.
a contour c x for some poset partially ordered set xover approximates the selected collecting semantics s lfpfs cholds for the following galois connection c s s s x. note that xmay be c s like the collecting domain c slike the abstract domain or some other domain.
because the contour is an element in the domain x our framework requires an interpretation of the contour in termsof the abstract domain by an interpretation function i x c s such that m s i. then i c denotes an over approximation of the selected executions in the abstract domain.
when xisc s orc s iis mor the identity function respectively.
in summary the relations between the collecting domain theabstract domain and xare as follows c s c s m m leftrightline s s s cali x c. tuned static analysis finally using the baseline analysis fand the contour c our framework derives a tuned static analysis which over approximates the selected set of program executions approx imated by c. using the sound abstract semantic function ffrom the baseline analysis and the interpretation of the contouri c we can define a tuned analysis which overapproximates selected executions as the least fixpoint of thefollowing abstract semantic function f s c c. f c c s c c i c where the abstract semantic function fconsiders only the control flows restricted by the given contour s def i c .
thus the derived analysis fsconsiders only the control flows restricted by the contour and the resulting abstract states from fremain within the interpretation of the contour because fs performs the meet operation with i c .the derived analysis fsis an over approximation of the selected program executions approximated by the contour.
theorem correctness of fs m lfpfs lfp fs also the interpretation of the contour i c is an overapproximation of the derived tuned analysis of the selected executions theorem lfp fs i c proofs of both theorems are straightforward.
d. discussion our framework allows users to tune the analysis scalability by choosing appropriate contours.
because a derived tuned analysis performs its analysis within the boundary confinedby its contour the contour determines the scalability of thetuned analysis.
good contours trim spurious execution flowsfrom consideration of tuned analyses leading to reducing falsepositives from the analysis results.
depending on a selected contour the derived analysis may not be scalable enough.
in such cases choosing an unsound butscalable contour that contains a strict subset of all executionflows may be an option.
by choosing specific cases to focuson tuned analyses can get benefits for the scalability whilegiving up the soundness.
of course one can focus on othercases one by one or collectively by selecting different contours.
as the selection of contours explicitly tunes the analysis scalability by confining the scope of tuned analyses it alsoimproves the precision of tuned analyses.
no matter whatcontours we select the tuned analysis has less false alarmsthan that of the baseline analysis.
at the same time becausecontours trim any spurious execution flows not contained inthem by the meet operation with i c the tuned analyses become more precise than the baseline analysis.
note that the tuned analysis is more scalable than the baseline analysis because it trims the analysis target with thegiven contour by performing the meet operation with i c .
in addition when the abstract state domain sis a function cpo complete partial order l vas we discussed in section iii a we can improve the analysis scalability furtherin terms of the analysis performance by applying the sparseanalysis framework .
we describe how we applyit in our implementation of the framework in section v. iv .
i nst ances to demonstrate how to use the general framework in practice this section shows two instances swp and swf .
they both use the safe analysis as a baselineanalysis and swp and swf use w ala s propagation based analysis pb and w ala s field based analysis fb as pre analyses that construct contours respectively.
a. instance swp selected collecting semantics .
because pb is a sound analysis using pb as a pre analysis effectively means that swp uses all the possible execution flows as selected executions.
thus the selected collecting semantics c s fp for some fpis the same as the collecting semantics in section iii a.
545abstraction for selected collecting semantics.
since pb is a flow insensitive analysis which does not consider control points during analysis it abstracts a set of concrete states foreach control point to a singleton abstract state c s s s s s c c s c s c c. s .
then a contour cwp sis the least fixpoint of the following semantic function fp s s fp c c fp c where fp c s sis an abstract counter part of fp.w e assume that the abstract semantic function fp c is monotonic designed in the abstract interpretation framework.
therefore the following condition holds s lfpfp lfp fp.
since we use the same abstraction for abstract states thedefinition ofi pis simply as follows ip c c. which satisfies the condition m s ip.f o rag i v e n abstract state it produces a function that returns the abstractstate for any control point.
then we can design a tunedanalysis f swp for the contour cwp as follows fswp c c. f c c p c c ip cwp wherep def ip cwp .
note that the derived analysis fswp is as precise as safe and because it is tuned by the contour cwp it may be more precise than safe.
in addition since the contour overapproximates the collecting semantics the tuned analysis over approximates all the possible program executions by theo rem .
b. instance swf selected collecting semantics.
to lessen the analysis complexity fb abandons elaborate object sensitive analysis entirely using a single location globally for each field.thus we can denote the selected collecting semantics as c s f f for some local semantic function ff where ff c specifies the selected collecting semantics at a given control point c which is a subset of the collecting semantics f c c c s .f f c f c .
then we can define the selected collecting semantics asfollows f f c s c s ff c c.f f c c c c .
abstraction for selected collecting semantics.
because fb is a flow insensitive and object insensitive analysis it doesnot consider control points nor objects during analysis.
thus it basically abstracts a set of concrete states for each controlpoint to a global single abstract object o c s s s o s l l c c s c l s o c c. s l l. o then a contour cwf ois the least fixpoint of the following semantic function ff o o ff o c c ff c o where ff c is an abstract counter part of ff c .
we assume that the abstract semantic function ff c is monotonic designed in the abstract interpretation framework.
therefore thefollowing condition holds s lfpff lfp ff.
in this case we can define if o c s as follows if o c c. l l. o and we can design a tuned analysis that subsumes the selectedcollecting semantics as follows f swf c c. f c c f c c if cwf wheref def if cwalaq .
to see the effects of the tuned analysis more clearly let us revisit the code example presented in section ii 1var f x function a ... y function b .
.
.
var g x function c .
.
.
var h y.mix f h.x while the actual evaluation of the code calls the function a on line the sound baseline analysis safe will conclude that either function aorbwill be called and an unsound fb will conclude that either function aorcwill be called.
however the tuned analysis will precisely conclude that onlythe function awill be called by performing the meet operation with the contour.
c. discussion while both pb and fb two pre analyses used in the instances are standalone static analyzers the framework does not require a pre analysis be a separate static analysis.
instead one can use a collection of dynamic execution traces thatcontain the states during particular executions as a pre analysisresult.
for such a collection of dynamic execution traces wedo not even need to abstract a set of concrete states to constructa contour.
thus we can use the following galois connection c s s sc s where both sand sare the identify function.
the interpretation functioniis the same as min this case.
546indeed we can formalize the blended analysis in this setting where a tuned analysis performs the baseline safe analysis on only extracted execution flows.
also whena contour contains information about dynamically generatedcode the corresponding tuned analysis can get benefits fromthe extracted code.
although we could not experiment withsuch a pre analysis that collects concrete execution tracesbecause the tool is not publicly available we plan to pursuethis direction.
v. i mplement a tion this section describes main technical challenges in integrating two independently developed analyzers and derivingsparse analyses for javascript programs and explains how wesolve them.
a. interpretation of wala analysis results in safe we implemented the framework using safe as the baseline analysis and two versions of w ala analyses pb and fb as pre analyses.
the analysis results of pb and fb correspond totheir contours c wp and cwf respectively.
to use the contours in tuned analyses we develop concrete versions of the inter pretation function i pandiffor pb and fb respectively.
in other words to use the pre analysis results in the safeanalysis we should transform program states in w ala toprogram states in safe which requires various mappingsbetween w ala domains and safe domains.
for example we should transform an abstract location in w ala to that insafe and an abstract value in w ala to that in safe.
hereare some representative transformation due to the differencesbetween w ala and safe in the implementation of javascriptstatic analysis.
user objects .
for user defined objects generated by function declarations array literals object literals or object con struction we use their source locations to map the same userobjects in w ala and safe.
for built in functions that donot have source locations of their definition sites we use theirnames.
lexical environments.
javascript maintains variable information in lexical environments each function call createsa new lexical environment to keep the information of thevariables in the function.
while safe creates a lexical en vironment for each function call site as the ecmascript stan dard specifies w ala creates a lexical environment for eachfunction declaration.
thus for each lexical environment for afunctionfin w ala we map it to the lexical environments of the call sites of fin safe.
arguments objects.
each javascript function except for the global function has an implicitly declared arguments object.
while safe generates arguments objects in function call sites as the ecmascript standard specifies w ala generatesthem in function definition sites.
similarly for lexical envi ronments we map each arguments object for a function f in w ala to the arguments object of the call sites of fin safe.v ariables.
both w ala and safe deal with user defined variables from input javascript programs and analyzer definedtemporary variables to keep intermediate results of complexexpressions.
for example when safe translates a complexexpression like x obj.prop1.prop2 into its own intermediate representation it generates a temporary variable for obj.prop1 .
while it is straightforward to map user defined variables using their source locations mapping analyzer defined variables is not trivial because w ala and safe havedifferent strategies to create temporary variables.
for tempo rary variables we use source locations of their correspondingcomplex expressions.
implicit type conversions.
javascript has implicit type conversions for primitive values such as strings numbers and booleans.
when primitive values are used as built inobjects like string number and boolean they implicitly convert to corresponding built in objects.
while safe modelsimplicit type conversions as the ecmascript standard defines w ala does not support them.
thus we transform implicittype conversions in javascript applications to explicit typeconversions.
b. sparse analysis for javascript applications to make tuned analyses even more scalable we applied the general sparse analysis framework in our implementation after addressing two issues.
the first issuesis that while the sparse analysis framework requires a pre analysis be a conservative approximation of a given baselineanalysis contours in our framework may not be a conservativeapproximation of the baseline analysis.
however because theformalization presented in section iii guarantees that contourssupport conservative approximation of tuned analyses by the orem we can safely apply the sparse analysis framework totuned analyses.
the second issue is that the general sparse analysis framework is often inefficient in javascript analysis because re building data dependencies whenever analysis results change iscostly .
the proposed approach that postpones rebuildingdata dependencies may work well for c like languages butit may not work for languages with prevalent exception flowslike javascript.
a reasonable solution may be an incrementalalgorithm that newly builds data dependencies only for partsthat have been changed .
however the algorithm is im practically expensive for javascript analysis because wheneverthe algorithm creates a new join node during analysis it requires elimination of related edges to the join node.to address this problem of prevalent exception flows weimproved the incremental algorithm.
instead of eliminatingexisting edges and adding nodes on the fly as in the traditional incremental algorithm we devised an improvedalgorithm that pre computes all the possible nodes and constructs data dependencies using the pre computed nodes.
our algorithm may create more nodes than the original incremental algorithm but it certainly reduces the costs ofdata dependency construction which is especially necessaryfor javascript analysis.
547vi.
e v alua tion in this section we evaluate the proposed tunable analysis framework using four analyzers.
we first describe research questions evaluation methodology and evaluation subjects and we show the evaluation results.
a. research questions we design our evaluation to address the following research questions rq1.
scalability given the same timeout how many subjects does each analyzer finish analyzing?
an analyzer finishing analysis of more subjects is more scalable.
rq2.
precision for the callsites in each subject how many called function objects does each analyzer approx imate on average?
an analyzer that finds fewer functionobjects for each function call on average is more precise.
rq3.
coverage given the same timeout how many basic blocks does each analyzer finish analyzing?
ananalyzer finishing analysis of more basic blocks hashigher coverage.
rq4.
global sparse analysis is the global sparse analysis framework applicable to javascript?
b. evaluation methodology and subjects to answer the research questions we performed various experiments using four analyzers safe a sound baseline analyzer swp a tuned analyzer with safe as a baseline analyzer and w ala s pb as a pre analyzer swf a tuned analyzer with safe as a baseline analyzer and w ala s fb asa pre analyzer and fb an unsound w ala s fb analysis.
for all the experiments safe used call context sensitivityand location cloning .
the pre analyses pb and fb arecontext insensitive and they do not perform string analysis.
inaddition pb used correlation tracking for for in loops.
while the quality of analysis results relies on the quality of theunderlying analyzers because it is not the main focus of thispaper we refer the interested readers to relevant papers .
for evaluation subjects we used categories benchmark library and website and used subjects from each category.we distinguished benchmarks and websites because they havedifferent behaviors and we included libraries becausethey have been the major targets for javascript analysis .
for the benchmark category we used raytrace richards splay and navierstokes from the v8 benchmarksuite version 6and box2dweb7.
for the library category we used jquery mootools prototype yui and underscore8.f o r the website category we used live.com wikipedia.org facebook.com youtube.com and baidu.com .
for each category we selected subjects that show the differences be tween analyzers most explicitly.
we conducted the experimentson a machine with .4ghz intel core i7 cpu and 32gbmemory.
able i scalability of the analyzers.
entries marked denote that the analyzers do not finish analysis within the timeout of minutes.
the analysis time is in seconds and parenthesized numbers m n denote that a pre analysis took mseconds and a baseline analysis tooknseconds.
the analysis time for fb is the same as the preanalysis time for swf .
subject loc safe swp swfbenchmarkraytrace .
.
.
.
.
.
richards .
.
.
.
.
.
.
splay .
.
.
.
.
.
.
navierstokes .
.
.
.
.
.
.
box2dweb .
.
.
.
.
.
.
libraryjquery .
.
.
mootools .
.
.
prototype .
.
.
yui .
.
.
.
.
.
underscore .
.
.
websitelive.com .
.
.
.
wikipedia.org .
.
.
.
.
.
.
facebook.com .
.
.
youtube.com .
.
.
baidu.com .
.
.
c. scalability to compare the scalability of four analyzers we show which analyzer finishes analysis of each subject in table i with the timeout of minutes.
we measured the analysis timein seconds.
for tuned analyzers we show how much time apre analysis and a baseline analysis each took in parentheses.because the analysis time for fbis the same as the pre analysis time for swf we do not show fb in the table.
while all safe swp swf a n d fbcan finish analyzing most benchmarks they show differences in analyzing libraries and websites.
comparing safe and swp in analyzing libraries they both cannot analyze most of them swp finishes analysis of the yui library.
to analyze yui in a sound manner safe analyzes many possibly spurious execution flows of yui whichcauses much possibly unnecessary analysis computation.
onthe contrary swp uses a contour produced by pb to trim unnecessary execution flows which makes a set of executionflows to analyze smaller than safe .
therefore it decreases the amount of analysis computation leading to finish analysisof yui by swp .
because swp takes sound analysis results of pb to generate contours our framework guarantees that swp provides a sound analysis result of yui.
for the analysis of websites both safe and swp cannot analyze most of them except for the simple wikipedia.org safe can finish analysis of live.com in addition.
we observed that swp did not finish analysis of live.com because its pre analysis pb did not finish analyzing it.
not surprisingly swf is the most scalable one it successfully finishes analysis of all the benchmarks libraries andwebsites within minutes.
because contours derived from thefb pre analysis are deliberately unsound swf can analyze large scale programs more effectively than safe and swp .
the experimental results show that the analysis scalability is tunable by contours.
we believe that reasonably designedcontours will enable analysis of large and sophisticated pro grams.
548d.
precision to evaluate how precise results each tuned analysis produces by confining analysis targets with its contour we measured the average number of callees the analyzer estimates over thenumber of call sites as shown in table ii.
we also present themaximum number of calls in parentheses.
note that comparinganalysis precision between sound analyses safe and swp and unsound analyses swf and fb is not trivial.
although the numbers in the table do not represent the analysis precisionof whole programs it shows speculative analysis precision forthe analysis targets of each analyzer.
splay and navierstokes in benchmarks show the same numbers for all the analyzers except for fb.
richards in benchmarks has the same precision in safe and swp and yui in libraries shows the same precision between swp and swf .
we confirmed that they have the same call sites and each call site has the same callees which means that they have thesame precision at each call site.
for richards box2dweb and live.com swf shows smaller numbers than safe and swp due to its unsound pre analysis fb.
as the fb column for precision in table ii suggests fb may miss some call sites unsound and at the same time it may include unreachablecall sites imprecise as well.
because fb ignores propertyaccesses with imprecise property names it may miss actualexecution flows.
also because fb is context insensitive i t over approximates functions to be called at call sites.
thus numbers of call sites analyzed by fb are smaller than those by swf for some cases raytrace richards splay and navierstokes but larger in most cases.
however since swf performs the meet operation with the contours derived from fb swf presents the best results.
note that fb has been successfullyused in finding security vulnerabilities in the appscan product.because the analysis results from swf subsumes the concrete execution flows analyzed by fb swf can detect the same security vulnerabilities as appscan.
moreover because swf produces more precise analysis results appscan may be ableto reduce false positives by using swf instead of fb.
the experimental results show that the analysis precision is tunableby contours.
when analysis results are not precise enough onemay shrink contours to achieve better analysis precision.
e. coverage finally we compare the analysis coverage of the analyzers using numbers of reachable basic blocks that they analyze.
we can expect that safe and swp subsume all the possible execution flows but they may not terminate.
on the contrary swf and fb may subsume partial execution flows but because they are more scalable they may cover more lines of sourcecode even when safe and swp do not terminate.
table ii shows that swf and fb indeed cover more subjects.
splay and navierstokes in benchmarks cover the same basic blocksin safe swp and swf .
we can speculate from this result that contours generated in swp and swf include safe analysis results so that each analysis result is sound for the wholeprogram.
richards shows that safe covers more basic blocks than swp and swp covers more basic blocks than swf .indeed because both safe and swp are sound their analysis targets should include that of swf .
at the same time because swp performs the meet operation with the contours derived from pb the analysis targets of swp should be smaller than that of safe .
even though fb shows the largest coverage for all subjects fb may miss some actual basic blocks unsound and simulataneously it may include unreachablebasic blocks imprecise as we discussed in section vi d.while fb analyzes more than thousand basic blocks for most websites swf does not analyze that many basic blocks by the meet operation with the contours from fb.
the experimentalresults show that generating smaller contours helps analysis oflarge scale programs while giving up some analysis coverage.to improve the analysis coverage one may enlarge contoursto cover more program execution flows.
f .
sparse as we discussed in section v b swp and swf are instances of the global sparse analysis framework .
we consider swp as an application of the global sparse analysis framework as it is.
table i shows that applying the globalsparse analysis as is to javascript analysis helps in analyzingyui while safe did not finish analysis of yui swp did.
however it does not work well in general in the sense that swp does not outperform safe noticeably.
we believe that an a ve application of the general sparse analysis framework to analysis of javascript programs represented by swp i s likely to be ineffective.
for languages with frequent changesin control flow graphs like javascript additional techniquesare necessary as in swf .
g. threats to v alidity we identify the following threats to the validity the subjects used in the experiments may not berepresentative.
we selected widely used subjects for different categories that have different behaviors each from real world javascript applications.
however they may not be representative of all javascript programs.
the experimental results on precision may not rep resent the precision of the whole program analysisresults.
because we measured only average numbers of callees and numbers of call sites in analysis targets theanalysis precision results may not apply to whole programanalysis results.
therefore direct comparison betweenaverage numbers of callees is meaningful if analyses havethe same call sites.
if a contour of swf excludes call sites that have small numbers of callees then swf may have larger average numbers of callees than other soundanalyses safe and swp .
vii.
r ela ted work because javascript applications are prevalent these days researchers have proposed various techniques to staticallyanalyze javascript programs.
similarly for statically typedlanguages like java most analysis techniques are sound butimpractical .
moreover static analysis of javascript 549t able ii precision and coverage.
each entry for precision denotes the average number of callees that the analyzer estiates the maximum number of calls the number of call sites.
each entry for coverage denotes the number of reachable basic blocks that the analyzer analyzes.
subjectprecision coverage safe swp swf fb safe swp swf fbbenchmarkraytrace .
.
.
richards .
.
.
.
splay .
.
.
.
navierstokes .
.
.
.
box2dweb .
.
.
.
11728libraryjquery .
.
mootools .
.
prototype .
.
yui .
.
.
underscore .
.
1766websitelive.com .
.
.
wikipedia.org .
.
.
.
facebook.com .
.
youtube.com .
.
baidu.com .
.
is much more impractical than static analysis of java due to its extremely dynamic and functional features.
some analysis likecorrelation tracking keeps track of relationships betweenobject properties but it applies to only special patterns.some sound analysis like dynamic determinacy utilizesdeterminate values at compile time but it loses the precisiongain by determinate values as soon as it reaches indeterminatevalues which is not scalable enough.
instead recent studies have reported unsound analyses of javascript programs.
because bug detection does not need toguarantee absence of bugs bug detection may not need touse sound analysis.
similarly a simple taint analysis may notrequire sound analysis it may be enough to analyze unsoundcall graphs of target programs as long as the unsound analysisis scalable enough to finish analyzing large scale javascriptapplications in the wild .
once unsound analyses areacceptable various combinations of dynamic and static anal yses would be possible by performing such analyses on onlyextracted execution flows .
building on top of the static analysis techniques for javascript programs researchers have developed open sourcejavascript static analyzers.
safe is an abstract inter pretation based static analysis framework.
it supports a richset of modeled libraries dom apis and platform apis foranalyzing real world javascript web applications .
it alsoprovides various analysis techniques like multiple sensitivitiesand loop sensitive analysis .
like safe t ajs sup ports a static analysis in the abstract interpretation framework.it provides several analysis techniques to improve the precisionand scalability of javascript analysis but it is not yet scalable for analyzing libraries like mootolsand prototype.
w ala is originally developed for javaprogram analysis and now it also provides javascript pro gram analysis.
using existing analysis supports for java itequips with a variety of tools for javascript analysis includinga sound propagation based pointer analysis.
however dueto the significant differences between java and javascript w ala provides another unsound field based analysis forjavascript which has been successfully used in academia and applied to a commercial product ibm security app scan .
jsai is a javascript analysis framework withconfigurable sensitivities.
while jsai supports sound analyses our approach handles even unsound analyses.
for large scale c programs several scalable analyses are available.
a sparse analysis framework for c like programs has shown very effective in making existing sound staticanalyses scalable.
its extension to a general sparse analy sis framework proposes a mechanism to apply it toother languages like javascript.
however unfortunately ourexperiments using the propagation based w ala analysis asits simple flow insensitive pre analysis to make the safeanalysis scalable showed that the framework as it is may notbe practically applicable to analysis of javascript programs.
viii.
c onclusion we present a general framework that enables designers of analyses to tune the analysis scalability and precision.
giventhat the extremely dynamic and functional features of large scale javascript applications make scalable static analysisalmost impossible designers may get more benefits fromexperimenting with the analysis scalability and precision thanpursuing for the ultimate sound and scalable static analysis.our framework is parameterized by a sound baseline analysisthat analyzes a given program elaborately and a pre analysisthat specifies only a subset of execution flows designers cantune the scalability and precision of the resulting analysis bychanging the pre analysis.
our framework is theoretically wellfounded in the abstract interpretation framework and practi cally evaluated with state of the art javascript analyzers.
weformally presented stepwise instructions to use our framework and exemplified differences resulted from different choices ofpre analyses.
using open source javascript analyzers safeand w ala we implemented two instances of the frameworkand showed effectiveness of the framework.
a cknowledgment this work is supported in part by national research foundation of korea grant nrf 2014r1a2a2a01003235 samsung electronics and google faculty research a ward.
550references javascript online games html.
list of languages that compile to js coffeescript wiki list of languages that compile to js.
node os runtime.js g. richards s. lebresne b. burg and j. vitek an analysis of the dynamic behavior of javascript programs in proceedings of the acm sigplan conference on programming language design andimplementation .
k. yi and s. ryu a cost effective estimation of uncaught exceptions in standard ml programs theoretical computer science vol.
no.
pp.
.
x. leroy and f. pessaux type based analysis of uncaught exceptions acm transactions on programming languages and systems vol.
no.
pp.
mar.
.
h. oh k. heo w .
lee w .
lee and k. yi design and implementation of sparse global analyses for c like languages in proceedings of the acm sigplan conference on programming language design andimplementation pp.
.
y .
ko k. heo and h. oh a sparse evaluation technique for detailed semantic analyses computer languages systems structures .
h. oh k. heo w .
lee w .
lee d. park j. kang and k. yi global sparse analysis framework acm transactions on programming languages and systems vol.
no.
.
kaist plrg safe javascript analysis framework ac.kr .
s. bae h. cho i. lim and s. ryu safewapi web api misuse detector for web applications in proceedings of the acm sigsoft symposium and the european conference on f oundations of softwareengineering .
a. m ller s. h. jensen p .
thiemann m. madsen m. d. ingesman p .
jonsson and e. andreasen t ajs type analyzer for javascript ajs .
m. madsen and a. m ller sparse dataflow analysis with pointers and reachability in proc.
21st international static analysis symposium sas .
ibm research t.j. watson libraries for analysis w ala http wala.sf.net.
m. sridharan j. dolby s. chandra m. sch afer and f. tip correlation tracking for points to analysis of javascript in proceedings of the european conference on object oriented programming .
m. sch afer m. sridharan j. dolby and f. tip dynamic determinacy analysis in proceedings of the acm sigplan conference on programming language design and implementation .
a. feldthaus m. sch afer m. sridharan j. dolby and f. tip efficient construction of approximate call graphs for javascript ide services inproceedings of the international conference on software engineering .
ibm security appscan en appscan.
b. livshits m. sridharan y .
smaragdakis o. lhot ak j. n. amaral b. y .
e. chang s. z. guyer u. p .
khedker a. m ller and d. v ardoulakis in defense of soundiness a manifesto communications of the acm pp.
.
p .
cousot and r. cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation offixpoints in proceedings of the acm sigact sigplan symposium on principles of programming languages pp.
.
systematic design of program analysis frameworks in proceedings of the acm sigact sigplan symposium on principles ofprogramming languages pp.
.
implementation of practically tunable static analysis framework for large scale javascript applications omitted for anonymizing authors .
g. bracha and w .
cook mixin based inheritance in proceedings of the european conference on object oriented programming object oriented programming systems languages and applications pp.
.
e. andreasen and a. m ller determinacy in static analysis for jquery inproceedings of the acm international conference on object oriented programming systems languages and applications .
c. park and s. ryu scalable and precise static analysis of javascript applications via loop sensitivity in proceedings of the european conference on object oriented programming .
s. wei and b. g. ryder practical blended taint analysis for javascript inproceedings of the international symposium on software testing and analysis pp.
.
j. d. choi v .
sarkar and e. schonberg incremental computation of static single assignment form in proceedings of the international conference on compiler construction .
c. lattner a. lenharth and v .
adve making context sensitive pointsto analysis with heap cloning practical for the real world in proceedings of the acm sigplan conference on programming language designand implementation .
w .
t. cheung s. ryu and s. kim development nature matters an empirical study of code clones in javascript applications empirical software engineering .
a. feldthaus and a. m ller checking correctness of typescript interfaces for javascript libraries in proceedings of the acm international conference on object oriented programming systems languages andapplications .
s. h. jensen p .
a. jonsson and a. m ller remedying the eval thatmen do in proceedings of the international symposium on software testing and analysis .
s. h. jensen m. madsen and a. m ller modeling the html dom and browser api in static analysis of javascript web applications inproceedings of the european conference on f oundations of softwareengineering .
v .
kashyap k. dewey e. a. kuefner j. wagner k. gibbons j. sarracino b. wiedermann and b. hardekopf jsai a static analysisplatform for javascript in fse proceedings of the 22nd acm sigsoft international symposium on f oundations of software engi neering .