effective test suites for mixed discrete continuous stateflow controllers reza matinnejad shiva nejati lionel c. briand snt centre university of luxembourg luxembourg reza.matinnejad shiva.nejati lionel.briand uni.luthomas bruckmann delphi automotive systems luxembourg thomas.bruckmann delphi.com abstract modeling mixed discrete continuous controllers using stateflow is common practice and has a long tradition in the embedded software system industry.
testing stateflow models is complicated by expensive and manual test oracles that are not amenable to full automation due to the complex continuous behaviors of such models.
in this paper we reduce the cost of manual test oracles by providing test case selection algorithms that help engineers develop small test suites with high fault revealing power for stateflow models.
we present six test selection algorithms for discrete continuous stateflows an adaptive random test selection algorithm that diversifies test inputs two white box coverage based algorithms a black box algorithm that diversifies test outputs and two search based blackbox algorithms that aim to maximize the likelihood of presence of continuous output failure patterns.
we evaluate and compare our test selection algorithms and find that our three output based algorithms consistently outperform the coverage and input based algorithms in revealing faults in discrete continuous stateflow models.
further we show that our output based algorithms are complementary as the two search based algorithms perform best in revealing specific failures with small test suites while the output diversity algorithm is able to identify different failure types better than other algorithms when test suites are above a certain size.
categories and subject descriptors software program verification keywords stateflow testing mixed discrete continuous behaviors structural coverage failure based testing output diversity.
.
introduction automated software testing approaches are often hampered by thetest oracle problem i.e.
devising a procedure that distinguishes between the correct and incorrect behaviors of the system under test .
despite new advances in test automation test oracles most often rely on human knowledge and expertise and thus are the most difficult testing ingredient to automate .
in this situation in order to reduce the cost of human test oracles test case selection criteria have been proposed as a way to obtain minimal test suites with high fault revealing power .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy.
copyright acm embedded software systems in various industry sectors are developed using stateflow which is integrated into the matlab simulink language.
stateflow is a hierarchical state machine language that is most commonly used in practice to specify mixed discrete continuous behaviors .
such behavior evolves in continuous time with discrete jumps at particular time instances and is typically captured using a stateflow model consisting of some discrete states such that during each state the system may behave based on a continuous time differential or a difference equation.
the state equations may change when the system transitions to its subsequent states due to some discrete time event.
stateflow models being detailed enough to enable code generation and simulation are subject to extensive testing.
testing stateflow models allows engineers to verify the behavior of software functions and is more likely to help with fault finding compared to testing code as stateflow models are more abstract and more informative for engineers.
testing stateflow models however is complicated mostly due to their continuous behaviors .
existing work on formalizing and automating test oracles for stateflow and in general for other state machine dialects has primarily focused on implicit test oracles such as runtime errors e.g.
division by zero and data type overflow or on oracles based on discrete behavior properties such as temporal reachability termination or state invariants which can be specified using logical assertions or temporal logic .
compared to test oracle automation for discrete system behaviors the problem of developing and automating test oracles for continuous behaviors has received significantly less attention and is left unexplored.
in our earlier work we proposed an approach to automate test oracles for a class of embedded controllers known as closed loop controllers and for three types of continuous output failures stability smoothness andresponsiveness .
our approach used metaheuristic search to generate test cases maximizing the likelihood of presence of failures in controller outputs i.e.
test cases that produce outputs that break or are close to breaking stability smoothness and responsiveness requirements .
this approach however fails to automate test oracles for stateflows because for closed loop controllers the environment plant feedback and the desired controller output setpoint are both available.
hence test oracles could be formalized and automated in terms of feedback and setpoint.
for stateflow models which typically implement open loop controllers the plant feedback is not available.
given that test oracles for stateflow models are not amenable to full automation mostly due to their complex continuous time behaviors in this paper we focus on providing test case selection algorithms for stateflow models.
our algorithms help engineers develop small test suites with high fault revealing power for continuous behaviors effectively reducing the cost of human test 1oracles .
in this paper we present and evaluate six test selection algorithms for mixed discrete continuous stateflow models a black box adaptive random input based algorithm two white box adaptive random coverage based algorithms a black box adaptive random output based algorithm and two black box search based output based algorithms .
our adaptive random input based algorithm simply attempts to generate a test suite by diversifying test inputs.
our two white box adaptive random coverage based algorithms aim to achieve high structural coverage.
specifically we consider the well known state and transition coverage criteria for stateflow models.
our black box adaptive random output based algorithm aims to maximize output diversity i.e.
diversity in continuous outputs of stateflow models.
output diversity is an adaptation of the recently proposed output uniqueness criterion to stateflow.
output uniqueness has been studied for web applications and has shown to be a useful surrogate to white box selection techniques.
we consider this criterion in our work because stateflows have rich time continuous outputs providing a useful source of information for fault detection.
our black box search based output based algorithms rely on metaheuristic search and aim to maximize objective functions capturing the degree of presence of continuous output failure patterns.
inspired by discussions with control engineers we propose and formalize two continuous output failure patterns referred to as instability anddiscontinuity .
the instability pattern is characterized by quick and frequent oscillations of the controller output over a time interval and the discontinuity pattern captures fast short duration and upward or downward pulses i.e.
spikes in the controller output.
presence of either of these failure patterns in stateflow outputs may have undesirable impact on physical processes or objects that are controlled by or interact with a stateflow model.
our contributions we focus on the problem of testing mixed discrete continuous stateflow models.
we propose two new failure patterns capturing undesirable behaviors in stateflow outputs that may potentially harm physical processes and objects.
we develop black box search based test selection algorithms generating test inputs that are likely to produce continuous outputs exhibiting these failure patterns.
in addition we define a black box output diversity test selection criterion for stateflow and present an adaptive random test selection algorithm based on this criterion.
we evaluate our six algorithms comparing the output based selection algorithms with the coverage based and input based selection algorithms.
our evaluation uses three stateflow models including two industrial ones.
our results show that the output based algorithms consistently outperform the coverage based and inputbased algorithms in revealing stateflow model faults.
further for relatively larger test suites the coverage based algorithms are subsumed by the output diversity algorithm i.e.
any fault found by the coverage based algorithms are also found with the same or higher probability by the output diversity algorithm.
finally we show that our adaptive random and search based output based algorithms are complementary as the search based algorithms perform best in revealing instability and discontinuity failures even when test suites are small while the adaptive random output diversity algorithm is able to identify different failure types better than the search based algorithms when test suites are above a certain size.
.
background and motiv ation motivating example.
we motivate our work using a simplified stateflow from the automotive domain which controls a supercharger clutch and is referred to as the supercharger clutch controller scc .
figure a represents the discrete behavior of scc specifying that the supercharger clutch can be in two quiescent states engaged a scc discrete behavior b scc timed behaviorengageddisengaged engaging c engaging state of scc mixed discrete continuous behaviordisengagingdisengagedengagedtime time time ctrlsig time ctrlsig onmovingonslippingoncompletedtime ctrlsig f time engagingtime ctrlsig g time time ctrlsig .
figure supercharge clutch controller scc stateflow.
or disengaged.
further the clutch moves from the disengaged to the engaged state whenever both the engine speed engspd and the engine coolant temperature tmp respectively fall inside the specified ranges of and .
the clutch moves back from the engaged to the disengaged state whenever either the speed or the temperature falls outside their respective ranges.
the variable ctrlsig in figure a indicates the sign and magnitude of the voltage applied to the dc motor of the clutch to physically move the clutch between engaged and disengaged positions.
assigning 0toctrlsig moves the clutch to the engaged position and assigning 0toctrlsig moves it back to the disengaged position.
to avoid clutter in our figures we use engagereq to refer to the condition on the disengaged!engaged transition and disengagereq to refer to the condition on the engaged!disengaged transition.
the discrete transition system in figure a assumes that the clutch movement takes no time and further does not provide any insight on the quality of movement of the clutch.
figure b extends the discrete transition system in figure a by adding a timer variable i.e.
time to explicate the passage of time in the scc behavior.
the new transition system in figure b includes two transient states engaging and disengaging specifying that moving from the engaged to the disengaged state and vice versa takes ms. since this model is simplified it does not show handling of alterations of the clutch state during the transient states.
in addition to adding the time variable we note that the variable ctrlsig which controls physical movement of the clutch cannot abruptly jump from 0to or vice versa.
in order to ensure safe and smooth movement of the clutch the variable ctrlsig has to gradually move between 0and 0and be described as a function over time i.e.
a signal.
to express the evolution of the ctrlsig signal over time we decompose the transient states engaging and disengaging into sub state machines.
figure c shows the sub state machine related to the engaging state.
the one related to the disengaging state is similar.
at beginning state onmoving the func20.
.
.
.
.0timeinput output signalsinputoutput control signal a c b figure an example input dashed line and output solid line signals for scc in figure .
the input signal represents engagereq and the output signal represents ctrlsig .
tionctrlsig has a steep grade i.e.
function f to move the stationary clutch from the disengaged state and accelerate it to reach a certain speed in 300ms.
afterwards state onslipping ctrlsig decreases the speed of clutch based on the gradual function gfor 200ms.
this is to ensure that the clutch slows down as it gets closer to the crankshaft.
finally at state oncompleted ctrlsig reaches value 0and remains constant causing the clutch to get engaged in about 100ms.
when the car is stationary i.e.
vehspd is the clutch moves based on the steep grade function ffor400ms and does not have to go to the onslipping phase to slow down before it reaches the crankshaft at state oncompleted .
input and output.
the stateflow inputs and outputs are signals functions over time .
each input output signal has a data type e.g.
boolean enum or float specifying the range of the signal.
for example figure shows an example input dashed line and output solid line signals for scc.
the input signal is related to engagereq and is boolean while the output signal is related to ctrlsig and is a float signal.
the simulation length i.e.
the time interval during which the signals are observed is two sec for both signals.
in theory the input signals to stateflow models can have complex shapes.
in practice however engineers mostly test stateflow models using constant or step input signals over a fixed time interval.
this is because developing manual test oracles for arbitrary and complex input signals is difficult and time consuming.
stateflow outputs might be either discrete or continuous.
a discrete output is represented by a boolean or an enum signal that takes a constant value at each state.
a continuous output is represented by a float signal that changes over time based on a difference or differential equation e.g.
ctrlsig in figure c .
our focus in this paper is on stateflows with some continuous outputs.
stateflow requirements.
the specification of stateflow controllers typically includes the following kinds of requirements requirements that can be specified as assertions or temporal logic properties over pure discrete behavior e.g.
the state machine in figure a .
for example if engine speed engspd and temperature tmpfall inside the ranges and respectively the clutch should eventually be engaged .
requirements that focus on timeliness of the clutch behavior and rely on the time variable see figure b .
for example moving the clutch from disengaged to engaged or vice versa should take 600ms.
note that scc is an open loop controller and it does not receive any information from the clutch to know its whereabouts.
hence engineers need to estimate the position state of the clutch using timing constraints.
requirements characterizing continuous dynamics of controlled physical objects.
for example the clutch should move smoothly without any oscillations and it should not bump into the crankshaft or other physical components close to it .
engineers need to evaluate the continuous ctrlsig signal to ensure that it does not exhibit any erratic or unexpected change with any undesirable impact on physical processes or objects.
existing literature such as model checking and formal verification largely focuses on properties that fall in groups one and .
.
.
.
.
.
.
.
.
.
.
b timetime a ctrlsig output .
.
.
.
.
abcfigure the output signals ctrlsig for two faulty versions of scc a an unstable output and b a discontinuous output.
two above .
the third group of requirements above although of paramount importance for correct dynamic behavior of controllers are lesser studied in the software testing literature compared to the requirements in the first and second groups.
to evaluate outputs with respect to the requirements in the third group engineers have to evaluate the changes in the output over a time period .
in contrast model checkers focus on discrete time behaviours only and evaluate outputs at a few discrete time instances states ignoring the pattern of output changes over time.
failure patterns.
figure shows two specific patterns of failures in continuous output signals violating requirements on desired physical behaviors of controllers group three .
the failure in figure a shows instability and the one in figure b refers todiscontinuity .
specifically the former signal shows quick and frequent oscillations of the controller output in the area marked by a grey dashed rounded box and the latter shows a very shortduration pulse in the controller output at point a. in section we provide a number of test selection algorithms to generate test cases that reveal failures in mixed discrete continuous stateflow outputs including the two failure patterns in figure .
.
test selection algorithms in our work we propose the following test case selection algorithms to develop test suites that can reveal erroneous continuous outputs of stateflow models black box input diversity id .
our input diversity selection algorithm is adaptive random and attempts to maximize diversity of test inputs selected from the input search space.
adaptive random test selection is a simple strategy that is commonly used as a baseline for comparison.
a selection algorithm has to perform at least better than adaptive random to be considered worthwhile.
white box coverage based.
structural coverage criteria have been extensively studied in software testing as a method for measuring test suite effectiveness .
we consider the two well known state coverage sc andtransition coverage tc criteria for stateflows mostly as another baseline of comparison.
black box output diversity od .
in the context of web applications recent studies have shown that selecting test cases based on outputs uniqueness i.e.
selecting test cases that produce highly diverse or distinct outputs enhance fault finding effectiveness of test suites .
stateflow outputs provide a primary source of data for engineers to find faults.
hence in our work we adapt the output uniqueness proposed by and define a notion of output diversity over continuous control signals.
black box failure based.
the goal of failure based test selection algorithms is to select test inputs that are able to reveal common failures specific to a particular domain .
we identify two failure patterns related to continuous dynamics of controllers instability and discontinuity.
based on these two patterns we define two failure based and output based selection algorithms output stability os andoutput continuity oc .
output stability aims to select test inputs that are likely to produce outputs exhibiting a period of instability particularly in response to a sudden change in input.
3an example of an output with instability failure is shown in figure a .
a period of instability in this signal which is applied to a physical device may result in hardware damage and must be investigated by engineers.
in contrast output continuity attempts to select test inputs that are likely to produce discontinuous outputs.
the control output of a stateflow is a continuous function with some discrete jumps at state transitions.
for example for both the control signals in figures and b there is a discrete jump at around time .
sec i.e.
point a0in figure and point a in figure b .
at discrete jumps and in general at every simulation step the control signals are expected to be either left continuous or right continuous or both.
for example the signal in figure is right continuous at point a0due to the slope from a0to c0 and hence this signal does not exhibit any discontinuity failure at point a0.
however the signal in figure b is neither right continuous nor left continuous at point a. this signal which is obtained from a faulty version of scc shows a very short duration pulse i.e.
a spike at point a. this behavior is unacceptable because it may damage the clutch by imposing an abrupt change in the voltage applied to the clutch .
specifically the failure shown in figure b is due to a fault in a transition condition in the scc model.
due to this faulty condition the controller leaves a state immediately after it enters that state and modifies the control signal value from b to a. in the remainder of this section we first provide a formal definition of the test selection problem and we then present our test selection algorithms.
test selection problem .
let sf o be a stateflow model where fs1 s ngis the set of states fr1 rmgis the set of transitions fi1 i dgis the set of input variables and ois the controller output of the stateflow model based on which we want to select test cases.
typically embedded software controllers have one main output i.e.
the control signal applied to the device under control.
if a stateflow model has more than one output we can apply our approach to select test cases for each individual output separately.
note that stateflow models can be hierarchical or may have parallel states.
among our selection algorithms only state and transition coverage algorithms sc and tc are impacted by the stateflow structure.
in our work we assume that and respectively contain the states and transitions in flattened stateflow models .
however our sc and tc algorithms do not require to statically flatten stateflow models as these algorithms dynamically identify the flattened states and flattened transitions that are actually executed during simulation of stateflow models.
each input output variable of sfis a signal i.e.
a function of time.
when sfis simulated its input output signals are discretized and represented as vectors whose elements are indexed by time.
assuming that the simulation time is t the simulation interval is divided into small equal time steps denoted by t. for example for scc we set t 2sand t 1ms.
we define a signal sgas a function sg f0 t t k tg!r sg where tis the simulation time step kis the number of observed simulation steps andrsgis the signal range.
in our example we have k .
we further denote by minrsgandmaxrsgthe min and the max ofrsg.
for example when sgis a boolean rsgis f0 1g and when sgis a float signal rsgis the set of float values betweenminrsgandmaxrsg.
as discussed in section to ensure the feasibility of the generated input signals in this paper we only consider constant or step input signals.
our goal is to select a test suite ts fi1 i qgofqtest inputs where qis determined by the human test oracle budget.
eachalgorithm.
id s election input stateflow model sf.
output test suite ts fj1 j qg.
.
let ts figwhereiis a random test input of sf .forq 1times do .
maxdist .
letc fi1 i cgbe a candidate set of random test inputs of sf .
for eachii2cdo .
dist min8i02tsdist ii i0 .
ifdist maxdist .
maxdist dist j ii .
ts ts j .
return ts figure the input diversity test selection algorithm id .
test inputijis a vector sg1 sg d of signals for the sfinput variablesi1toid.
by simulating sfusing each test input ij we obtain an output signal sgofor the continuous output oofsf.
.
input diversity test selection the input diversity selection algorithm id generates a test suite with diverse test inputs.
given two test inputs i sg1 sg d andi0 sg0 sg0 d we define the normalized euclidean distance between each pair sgjandsg0 jof signals as follows dist sgj sg0 j s kp i sgj i t sg0 j i t pk maxrsg minrsg note thatsgjandsg0 jare alternative assignments to the same sf inputij and hence they have the same range.
further we assume that the values of kand tare the same for sgjandsg0 j. it is easy to see that dist sg sg0 is always between 0and1.
we define the distance between two test inputs i sg1 sg d andi0 sg0 sg0 d as the sum of the normalized distances between each signal pair dist i i0 dp j dist sgj sg0 j figure shows the id s election algorithm which given a stateflow model sf generates a test suite tswith sizeqand with diverse test inputs.
the algorithm first randomly selects a single test input and stores it in ts line .
then at each iteration it randomly generates ccandidate test inputs i1 i c. it computes the distance of each test input iifrom the existing test suite tsas the minimum of the distances between iiand the test inputs in ts line6 .
finally the algorithm identifies and stores in tsthe test input among the ccandidates with the maximum distance from the test inputs in ts lines .
.
coverage based test selection in order to generate a test suite tsbased on the state transition coverage criterion we need to simulate sfusing each one of the candidate test inputs and compute the state and the transition coverage reports for each test input simulation.
the state coverage report sis a subset of fs1 s ngcontaining the states covered by the test input i and the transition coverage report ris a subset of fr1 r mgcontaining the transitions covered by i. the state coverage test selection algorithm sc s election is shown in figure .
the algorithm for transition coverage tcselection is obtained by replacing s state coverage report with t transition coverage report .
at line the algorithm selects a random test input iand adds it to ts.
at line it simulates sf usingiand adds the corresponding state coverage report to a set tsc .
at each iteration the algorithm generates ccandidate test inputs and keeps their corresponding state coverage reports in a set cc.
it then computes the additional coverage that each one of the test inputs among the ccandidates brings about compared to the coverage obtained by the existing test suite ts line .
at the end of the iteration the test input that leads to the maximum 4algorithm.
sc s election input stateflow model sf.
output test suite ts fj1 j qg.
.
let ts figwhereiis a random test input of sf .
let tsc fsgwheresis the state coverage reports of executing sfwithi .forq 1times do .
maxaddcov .
letc fi1 i cgbe a candidate set of random test inputs of sf .
let cc fs1 s cgbe the state coverage reports of executing sfwithi1toic .
for eachsi2ccdo .
addcov jsi s02tscs0j .
ifaddcov maxaddcov .
maxaddcov addcov .p si j ii .
ifmaxaddcov .
let p sj j ijwheresj2ccandjsjj max s02ccjs0j .
tsc tsc p ts ts j .
return ts figure the state coverage sc selection algorithm.
the algorithm for transition coverage tc is obtained by replacing s state coverage report with t transition coverage report .
algorithm.
od s election input stateflow model sf.
output test suite ts fj1 j qg.
.
let ts figwhereiis a random test input of sf .
let tso fsgogwheresgois the output signal of executing sfwithi .forq 1times do .
maxdist .
letc fi1 i cgbe a candidate set of random test inputs of sf .
let co fsg1 sg cgbe the output signals of executing sfwithi1toic .
for eachsgi2codo .dist min8sg02tsodisto sgi sg0 .
ifdist maxdist .maxdist dist .p sgi j ii tso tso p ts ts j .
return ts figure the output diversity test selection algorithm od .
additional coverage is selected and added to ts line .
more precisely a test input ibrings about maximum additional coverage if compared to other ctest input candidates it covers the most number of states that are not already covered by the test suite ts.
note that if none of the ccandidates yields an additional coverage i.e.
maxaddcov is0at line we pick a test input with the maximum coverage among the ccandidates line .
.
output diversity test selection the output diversity od algorithm aims to generate a test suite tssuch that the diversity among continuous output signals produced by different test inputs in tsis maximized .
in order to formalize this algorithm we define a measure of diversity disto between pairs of control output signals sgo sg0 o .
specifically we define the diversity between sgoandsg0 obased on normalized euclidean distance and as defined by equation i.e.
disto sgo sg0 o dist sgo sg0 o .
figure shows the od algorithm i.e.
od s election .
the algorithm first selects a random test input iand simulates sfusing i. it addsitots line1 and the output corresponding to ito another set tso line2 .
then at each iteration the algorithm first randomly generates ccandidate test inputs line together with their corresponding test outputs and store the outputs in set co line6 .
then in line it uses distoto compute the distance between each test output sgiinco and the test outputs corresponding to the existing test inputs in ts.
among the test outputs in co the algorithm keeps the one with the highest distance from the test outputs in tso line11 and adds such a test output to tso and its corresponding test input to ts line12 .
.
failure based test selection the goal of failure based test selection algorithms is to generate test inputs that are likely to produce output signals exhibitingspecific failure patterns.
we develop these algorithms using metaheuristic search algorithms that generate test inputs maximizing the likelihood of presence of failures in outputs.
we propose two failure based test selection algorithms output stability and output continuity that respectively correspond to instability and discontinuity failure patterns introduced in section .
we first provide two heuristic quantitative objective functions that estimate the likelihood for each of these failure patterns to be present in control signals.
we then provide selection algorithms that guide the search to identify test inputs that maximize these objective functions and hence are more likely to reveal faults.
output stability.
given an output signal sgo we define the functionstability sgo as the sum of the differences of signal values for consecutive simulation steps stability sgo kp i 1jsgo i t sgo i t j specifically function stability sgo provides a quantitative approximation of the degree of instability of sgo.
the higher the value of the stability function for a signal sgo the more certain we can be that sgoexhibits some instability failure.
for example the value of the stability function applied to the signal in figure a is higher than that of the stability function applied to the signal in figure b since due to oscillations in the former signal the values ofjsgo i t sgo i t jare larger than those values for the latter signal.
output continuity.
as discussed earlier control signals at each simulation step are expected to be either left continuous or rightcontinuous or both.
we define a heuristic objective function to identify signals that are neither left continuous nor right continuous at some simulation step.
since in our work simulation time steps t are not infinitesimal we cannot compute derivatives for signals and instead we rely on discrete change rates that approximate derivatives when time differences of observable changes cannot be arbitrarily small.
given an output signal sgo let lci jsgo i t sgo i dt t j tbe the left change rate at step i and letrci jsgo i dt t sgo i t j tbe the right change rate at step i. we define the function continuity sgo as the maximum of the minimum of the left and the right change rates at each simulation step over all the observed simulation steps continuity sgo 3max dt k dtmax i dt min lci rci specifically we first choose a value for dtindicating the maximum expected time duration of a spike.
then for a fixed dt for every stepisuch that dt i k dt we take the minimum of the left change rate and the right change rate at step i. since we expect the signal to be either left continuous or right continuous at least one of the right or left change rates should be a small value.
we then compute the maximum of all the minimum right or left change rates for all the simulation steps to find a simulation step with the highest discontinuity from both left and right sides.
finally we obtain the maximum value across the time intervals up to length dt.
for our work we pick dtto be between 1and3.
for example the signal in figure b yields high right and left change rates at point a. as a result function continuity produces a high value for this signal indicating that this signal is likely to be discontinuous.
in contrast the value of function continuity for the signal in figures is lower than that in figure b because at every simulation step either the right change rate or the left change rate yields a relatively low value.
as discussed earlier we provide a meta heuristic search algorithm to generate test suites based on our failure patterns.
specifically we use the hill climbing with random restarts hcrr 5algorithm.
os s election input stateflow model sf.
output test suite ts fj1 j qg.
.
letibe a random test input of sfandsgothe output of executing sfwithi .
letall fig .highestfound stability sgo .for q citerations do .newi tweak i .
letsgobe the output of executing sfwithnewi .all all fnewig .
ifstability sgo highestfound .
highestfound stability sgo .i newi .
iftimetorestart .
let ibe a random test input of sfandsgothe output of executing sfwithi .
highestfound stability sgo .all all fig .
let tsbe the test inputs in allwith theq highest values of stability function .
return ts figure the test selection algorithm based on output stability.
the algorithm for output continuity oc s election is obtained by replacing stability sgo withcontinuity sgo .
algorithm .
in our earlier work on computing test cases violating stability smoothness and responsiveness requirements for closed loop controllers hcrr performed best among a number of alternative single state search heuristics.
figure shows our output stability test selection algorithm os s election based on hcrr.
the algorithm for output continuity oc s election is obtained by replacing stability sgo withcontinuity sgo in osselection .
at each iteration the algorithm tweaks the current solution i.e.
the test input to generate a new solution i.e.
a new test input and replaces the current solution with the new solution if the latter has higher value for the objective function.
similar to standard hill climbing the hcrr algorithm includes a tweak operator that shifts a test input iin the input space by adding values selected from a normal distribution with mean and variance 2to the values characterizing the input signals line and a replace mechanism lines that replaces iwithnewi ifnewi has a higher objective function value.
in addition hcrr restarts the search from time to time by replacing iwith a randomly selected test input lines .
we run the algorithm for q c iterations where qis the size of the test suites and cis the size of candidate sets in the greedy selection algorithms in figures to .
this is to ensure that oc s election spends the same test execution budget as the other selection algorithms.
the oc s election algorithm keeps all the test inputs generated during the execution in a set all lines 7and14 .
at the end of the algorithm from the set all we pickqtest inputs that have the highest objective function values line and return them as the selected test suite.
.
experiment setup in this section we present the research questions and describe our study subjects our metric to measure fault revealing ability of different selection algorithms and our experiment design.
.
research questions rq1 fault revealing ability .how does the fault revealing ability of our proposed test selection algorithms compare with one another?
we start by comparing the ability of the test suites generated using the different test selection algorithms discussed in section in revealing faults in stateflow models.
in particular we are interested to know if our selection algorithms outperform input diversity baseline ?
and if there is any selection algorithm that consistently reveals the most faults across different study subjects and different fault types?
rq2 fault revealing subsumption is any of our selection algorithms subsumed by other algorithms?
or for each selection al table characteristics of our study subject stateflow models.
publicly availablenameno.
of inputshierarchicalstatesparallelstatesno.
of statessccassnono234213162no1nogcsyes8100yesno.
of transitions255327 gorithm are there some faults that can be found by that algorithm but not by others?
this question investigates if any of the selection algorithms discussed in section is subsumed by other algorithms i.e.
if any selection algorithm does not find any additional faults missed by other algorithms.
rq3 fault revealing complementarity .what is the impact of different failure types on fault revealing ability of our test selection algorithms?
this question investigates whether any of our selection algorithms has a tendency to reveal a certain type of failures better than others.
this shows whether our selection algorithms are complementary to each other.
that is they reveal different types of failures thus suggesting they may be combined.
rq4 test suite size .what is the impact of the size of test suites generated by our selection algorithms on their fault revealing ability?with this question we study the impact of size on fault revealing ability of test suites and investigate whether some selection algorithms already perform well with small test suite sizes while some may require to enlarge test suites to better reveal faults.
.
study subjects we use three stateflow models in our experiments two industrial models from delphi namely scc discussed in section and auto start stop control ass and one public domain model from mathworks website i.e.
guidance control system gcs .
table shows key characteristics of these models.
all of these three models have a continuous control output signal.
specifically the continuous control signal in scc controls the clutch position in ass it controls the engine torque and in gcs it controls the position of a missile.
these models have a large number of input variables.
scc and ass have hierarchical states or states and gcs is a parallel state machine.
the number of states and transitions reported in table are those obtained after model flattenning.
we note that our industrial subject models are representative in terms of the size and complexity among stateflow models developed at delphi.
the number of input variables transitions and states of our industrial models is notably more than that of the public domain models from mathworks .
further most public domain stateflows are small exemplars created for the purpose of training and are not representative of the models developed in industry.
specifically while discrete continuous controllers are very common in many embedded industry sectors among the models available at only gcs was a discrete continuous stateflow controller and had a continuous control signal and hence we chose it for our experiment.
but since gcs continuous behavior was too trivial we modified it before using it in our experiments by adding some configuration parameters and some difference equations in some states.
we have made the modified version available at .
.
measuring fault revealing ability in our study we measure the fault revealing ability of test suites generated by different selection algorithms.
to automate our experiments we use fault free versions of our subject models to generate test oracles i.e the ground truth oracle .
let tsbe a test suite generated by one of our selection algorithms and for a given faulty model sf.
for the purpose of this experiment we assume thatsfcontains a single fault only.
we measure the ability of ts 6ts idsctcodosoc .fault seeding2.selectionalgorithmsffaultysf zz size q figure our experiment design step was repeated for times due to the randomness in our selection algorithms.
in revealing the fault in sfusing a boolean measure.
our measure returns true if there exists at least one test input in tsfor which the output of sfsufficiently deviates from the grand truth oracle such that a manual tester conclusively detects a failure.
otherwise our measure returns false.
formally let o fsg1 sg qgbe the set of output signals obtained by running sffor the test inputs in ts fi1 i qg and letg fg1 g qgbe the corresponding test oracle signals.
the fault revealing rate denoted by frr is computed as follows frr sf ts i q dist sgi gi thr i q dist sgi gi thr where dist sgi gi is defined by equation and thr is a given threshold.
if we set thr to zero then a test suite detects a given fault i.e.
frr if it is able to generate at least one output that deviates from the oracle irrespective of the amount of deviation.
for continuous dynamic systems however the system output is acceptable when the deviation is small and not necessarily zero.
furthermore for such systems it is more likely that manual testers recognize a faulty output signal when the signal shape drastically differs from the oracle.
in our work we set thr to0 .
as a result a test suite detects a given fault i.e.
frr if it is able to generate at least one output that diverges from the oracle such that the distance between the oracle and the faulty output is more than0 .
we arrived at this value for thr based on our experience and discussions with domain experts.
in our experiments in addition we obtained and evaluated the results for thr andths 15and showed that our results were not sensitive to such small changes in thr .
.
experiment design figure shows the overall structure of our experiments consisting of the following two steps step1 fault seeding.
we asked a delphi engineer to seed faults in each one of our two industry subject models z generating faulty versions of scc and ass i.e one fault per each faulty version.
the faults were seeded before our experiments took place.
the engineer was asked to choose the faults based on his experience in stateflow model development and debugging.
in addition we required the faults to be seeded in different parts of the stateflow models and to be of different types.
we categorize the seeded faults into two groups wrong output computation which indicates a mistake in the equations computing the continuous control output e.g.
replacing a min function with a max function or a operator with a operator in the equations.
wrong stateflow structure which indicates a mistake in the stateflow structure such as wrong transition conditions or wrong priorities of the transitions from the same source.
as for the publicly available model gcs since it was smaller and less complex than the delphi models we seeded faults into the model to create faulty versions z .
among all the faulty models for each case study around and of the faults belong to the wrong output computation and wrong stateflow structure categories respectively.
step2 test case selection.
as shown in figure after seeding faults for each faulty model we ran our six selection algorithms namely input diversity id state coverage sc transition coverage tc output diversity od output stability os a average frr values for different test suite sizes and threshold thr .
.
.
idsctcodosocaverage frr values q .
scc thr .
.
.
idsctcodosocaverage frr values q .
b average frr values for test suite size q and three different thresholdsscc thr .
idsctcodosocscc thr .
idsctcodosocaverage frr values q idsctcodosoc .
.
.
.
.
idsctcodosocaverage frr values q .
average frr values q idsctcodosoc0.
.
.
figure boxplots comparing fault revealing abilities of our test selection algorithms for different test suite sizes and different thresholds.
and output continuity oc test selection algorithms.
for each faulty model and each selection algorithm we created a test suite of sizeqwhereqtook the following values and .
we repeated the test selection step of our algorithm for times to account for the randomness in the selection algorithms.
in summary we created faulty models versions for scc and ass and versions of gcs .
for each faulty model and for each selection algorithm we created five different test suites with sizes and .
that is we sampled different test suites and repeated each sampling for a times i.e.
in total different test suites were generated for our experiment .
overall our experiment took about hours time on a notebook with a .4ghz i7 cpu gb ram and gb ssd.
.
results and discussions this section provides responses based on our experiment design for research questions rq1 torq4 described in section .
rq1 fault revealing ability .
to answer rq1 we ran the experiment in figure with test suite sizes q and and for all the faulty models i.e.
z for scc z for ass andz for gcs .
we computed the fault revealing rates frr with three thresholds thr .
.
and .
.
figure a shows four plots comparing the fault revealing ability of the test selection algorithms discussed in section with thr .
.
each plot in figure a compares six distributions corresponding to our six test selection algorithms.
each distribution consists of points.
each point relates to one faulty model and represents the average fault revealing ability of the different test suites with a fixed size and obtained by applying one of our test selection algorithms to that faulty model.
for example a point with x sc and y .
in the q plot of figure a indicates that among the different test suites with size generated by applying sc to one faulty model test suites were able to reveal the fault i.e.
7frr and could not reveal that fault i.e.
frr .
to statistically compare the fault revealing ability of different selection algorithms we performed the non parametric pairwise wilcoxon pairs signed ranks test and calculated the effect size using cohen s d .
the level of significance was set to0 and following standard practice dwas labeled small for d medium for d and high for d .
comparison with input diversity .
testing differences in frr distributions with thr .
shows that for all the test suite sizes all the test selection algorithms perform significantly better than id.
in addition for all the test suite sizes the effect size is high for od os and oc and medium for sc and tc.
coverage achieved by coverage based algorithms .
in our experiments on average for the different test suites obtained by sc tc selection algorithms and for our three subject models we achieved and state transition coverage for the test suites with size 25and50 respectively.
further we noticed that the largest test suites generated by our coverage based selection algorithms i.e.
q were able to execute the faulty states or transitions of 73out of the 75faulty models.
comparing output based and coverage based algorithms .
for all the test suite sizes statistical test results indicate that od os and oc perform significantly better than sc and tc.
for os and for all the test suite sizes the effect size is high .
for od with all the test suite sizes except for q the effect size is medium and forq the effect size is high .
for oc with all the test suite sizes except for q the effect size is medium and for q the effect size is low .
comparing output based algorithms .
forq and os is significantly better than od and oc with effect sizes of medium forq and low for q .
however neither of oc and od is better than the other for q and .
for q os is better than od with a low effect size with no significant difference between os and oc or oc and od.
finally for q there is no significant difference between os oc and od.
modifying thr .
the above statistical test results were consistent with those obtained based on frr values computed with thr .
and .
.
as an example figure b shows average frr values forq for thr .
.
and .
.
increasing the threshold from 15to0 25decreases the frr values but however does not change the relative differences in frr values across different selection algorithms.
in summary the answer to rq1 is that the test suites generated by od os oc sc and tc have significantly higher fault revealing ability than those generated by id.
further even though coverage based algorithms sc and tc were able to achieve a high coverage and execute the faulty states or transitions of faulty models the failure based and output diversity algorithms os oc and od generate test suites with significantly higher fault revealing ability compared to those generated by sc and tc.
for smaller test suites q os performs better than oc and od while for q we did not observe any significant differences among the failure based and output diversity algorithms os oc and od .
finally our results are not impacted by small modifications in the threshold values used to compute the fault revealing measure frr .
rq2 fault revealing subsumption .
to answer rq2 we consider the results of the experiment in figure a .
we applied the wilcoxon test to identify for each of the faulty models which selection algorithm yielded the highest fault revealing rate i.e.
the highest average frr over runs .
figure and table show the results.
figure shows which algorithms are best in finding sccassgcssctcodosocfaults q 123456789101234567892012345678930sctcodosocsctcodosocfaults q faults q 123456789101234567892012345678930sccassgcssctcodosocfaults q 123456789101234567892012345678930sctcodosocsctcodosocfigure the best selection algorithm s for each of the faulty models.
table the number of faults out of found inclusively i and exclusively e by each algorithm and for each test suite size.
q 5scq 0q 25q 50tcodosoc8 i e i e i e i e i e each of the faults for scc for ass and for gcs for each test suite size q and .
in this figure an algorithm a is marked as best for a fault f denoted by if based on the wilcoxon test results for f there is no other algorithm that is significantly better than a in revealing f. table shows two numbers i e for each algorithm and for each test suite size.
specifically given a pair i e for an algorithm a i indicates the number of faults that are best found by a and possibly by some other algorithms i.e.
inclusively found by a while e indicates the number of faults that are best found by a only i.e.
exclusively found by a .
for example when the test suite size is od is among the best algorithms in finding faults and among these faults od is the only best algorithm for faults.
coverage algorithms.
as shown in table sc is subsumed by the other algorithms for every test suite size e .
that is sc does not find any fault exclusively and any fault found by sc is also found with the same or higher probability by some other algorithm.
tc is able to find one fault exclusively for q but is subsumed by other algorithms for q .
further based on figure sc and tc together are able to find three faults exclusively for q of ass and and of gcs and two faults exclusively for q of ass and of gcs .
however for q they are subsumed by od.
output based algorithms.
as shown in table os fares best as it finds the most number of faults both inclusively and exclusively for different values of q. in contrast od shows the highest growth in the number of inclusively and exclusively found faults as qincreases compared to os and oc.
in summary the answer to rq2 is that coverage algorithms find the least number of faults both exclusively and inclusively and as test suite size increases these algorithms are subsumed by the output diversity od algorithm.
the output based algorithms are complementary i.e.
are not subsumed by one another and while output stability os finds the highest number of faults both inclusively and exclusively output diversity od shows the highest 8q a average frr values with thr .
and for instability failures failures .
.0average frr values0.
b average frr values with thr .
and for discontinuity failures failures sctcodosoc c average frr values with thr .
and for other failures failures q .
.0average frr values0.
.
.0average frr values0.5q sctcodosocsctcodosoc q sctcodosoc q 5q 10q 25q sctcodosocsctcodosocsctcodosocsctcodosoc sctcodosocsctcodosocsctcodosocsctcodosocq 5q 10q 25q 50figure the average frr values for different types of failures and for different test suite sizes.
improvement in fault finding as the test suite size increases.
rq3 fault revealing complementarity .
to answer rq3 we first divide the faulty models in our experiments based on the failure type that they exhibit.
to determine the failure type exhibited by a faulty model we inspect the output that yields the highest frr among the outputs produced by the test suites related to that model.
we identified three types of failures in these outputs and divided the faulty models into the following three groups the faulty models exhibiting instability failure models the faulty models exhibiting discontinuity failure models and the other models that neither show instability nor discontinuity models .
figures a to c compare the fault revealing ability of our test selection algorithms for test suite sizes q and and for each of the above three categories of failures i.e.
instability discontinuity and other .
instability and discontinuity.
the statistical test results show that for the instability failure os has the highest fault revealing rate forq and .
similarly for the discontinuity failure oc has the highest fault revealing rate for q and .
however for larger test suites q for instability and q and for discontinuity os oc and od are equally good at finding the instability and discontinuity failures.
other.
as for the other failures os and od are better able to find these failures compared to other algorithms for q and .
for q there is no significant difference between os od and oc in revealing these failures.
however as shown in figure c for q the frr value distribution for od has the highest average compared to other algorithms.
further the variance offrr values for od in figure c with q is the lowest making od the best algorithm for finding failures other than instability and discontinuity when large test suites are available.
discontinuity sctcodosoc instabilityothers .
.
.
test suite sizefrr mean average frr values vs. test suite size for different classes of failures thr .
figure the impact of test suite size on the average frr over test suites of different faulty models.
in summary the answer to rq3 is that when test suites are small os and oc show a clear tendency to respectively reveal the instability and discontinuity failures better than other types of failures and better than other algorithms.
with large test suites however os oc and od are equally good at finding the instability and discontinuity failures.
further with small test suites os and od are better than other algorithms in revealing failures other than instability and discontinuity.
for large test suites however od shows a tendency to perform better for the other types of failures since by diversifying outputs it increases the chances of finding failures not following any specific pattern.
rq4 test suite size .
to answer rq4 we extended the experiment in figure to include q as well.
figure shows how the average of frr over test suites for different faulty models and in different failure groups is impacted by increasing the test suite size.
specifically for figure the faulty models are divided based on the failure type they exhibit for instability for discontinuity and for others .
according to figure os performs best in revealing instability failures even with small test suite sizes where its average frr is very close to one .
.
similarly oc performs best in revealing discontinuity failures and its average frr for small test suites is already very high i.e.
.
.
for other kinds of failures os performs best for very small test suites but for q od performs the best.
finally for instability and discontinuity os od and oc perform better than sc and tc for all test suite sizes while for other failures os and od perform better than oc sc and tc for all the test suite sizes.
in summary the answer to rq4 is that the fault revealing ability of os respectively oc for instability respectively discontinuity failures is very high for small test suites and almost equal to the highest possible fault revealing rate value.
for failures other than instability and discontinuity the ability of od in revealing failures rapidly improves as the test suite size increases making od the best algorithm for such failures for test suite sizes more than or equal to .
discussion.
we present our observations as to why the coverage algorithms are less effective than the output based algorithms for generating test suites for mixed discrete continuous stateflows.
further we outline our future research direction on effective combination of our output based test selection algorithms.
why coverage algorithms are less effective?
overall our results show that compared to output based algorithms coverage algorithms are less effective in revealing stateflow faults and as discussed in rq2 they are subsumed by the output diversity algorithm.
based on our experiments even though test suites generated by sc and tc cover the faulty parts of the stateflow models they fail to generate output signals that are sufficiently distinct from the oracle signal hence yielding a low fault revealing rate.
that is a discrete notion of state or transition coverage does not help reveal 9continuous output failures.
note that these failures depend on the value changes of outputs over a continuous time interval.
the poor performance of coverage algorithms might be due to the fact that state and transition coverage criteria do not account for the time duration spent at each state or for the time instance at which a transition is triggered.
for example an objective to cover states while trying to reduce the amount of time spent in each state may better help reveal discontinuity failures see figure b .
combining output based selection algorithms.
our results show that for large test suites and for allfailure types the fault revealing ability of os oc and od are the same with an average frr of .
to .
.
however for smaller test suites and for specific failures some algorithms i.e.
os for instability and oc for discontinuity perform remarkably well with an average frr higher than .
.
this essentially eliminates the need to use large test suites for those specific failure types.
these findings offer the potential for engineers to combine our output based algorithms to achieve a small test suite with a high fault revealing rate.
recall that test oracles for mixed discrete continuous stateflows are manual and hence the test suite size has to be kept as low as possible typically q .
for example given our results on fault revealing ability of os oc and od and assuming that a test suite size budget of qis provided we may allocate a small percentage of the test suite size to oc to find discontinuity failures and share the rest of the budget between os and od by giving od a higher share.
this is because os is able to find instability failures with small test suites but also it performs well at finding other failures.
however only od was able to subsume sc tc with large test suites and given that od s performance increases with the test suite size a larger test suite size might be allocated to od.
this suggests future work to investigate guidelines on dividing the test suite size budget across different output based test selection algorithms.
.
related work what distinguishes our work from the existing model based testing approaches is that in our work stateflow models are the artifacts under test while in model based testing test cases are derived from stateflow models or other state machine variants in order to exercise the system on its target platform.
these model based testing approaches often generate test cases from models using various automation mechanisms e.g.
search based techniques model checking guided random testing or a combination of these techniques .
in a model based testing approach for mixed discrete continuous stateflow models is proposed where test inputs are generated based on discrete fragments of stateflow models and are applied to the original models to obtain test oracles in terms of continuous signals.
in all these approaches stateflow models in addition to generating test cases are used to automate test oracles.
in reality however stateflows might be faulty and cannot be used to automate test oracles.
hence we focus on generating small and minimal test suites to identify faults in complex executable stateflow models for which automated test oracles are not available a common situation in industry.
formal methods and model checking techniques have been previously applied to verify stateflow models.
these approaches largely focus on stateflows with discrete behaviours and attempt to maximize discrete state or transition coverage.
in our work we test stateflows with mixed discrete continuous.
further our results show that for discrete continuous stateflows test inputs that cover faulty parts of stateflow models may not be able to reveal faults i.e.
may not yield outputs with sufficient distance from the oracle .
hence focusing on coverage alone may not result in test suites with high fault revealing ability.we proposed two failure patterns capturing specific errors in continuous outputs of stateflow models.
our failure patterns are analogous to the notion of fault models .
fault models provide abstract descriptions for specific things that can go wrong in a certain domain .
several examples of fault models have been proposed e.g.
for access control policies or for specific concurrency or security faults .
our work is the first to define such notion for mixed discrete continuous stateflows and apply it using meta heuristic search.
our failure patterns capture the intuition of domain experts and are defined over continuous controller outputs.
we further note that instability and discontinuity patterns are respectively similar to the accuracy and change rate properties that are typically used to characterize physical behaviour of cyber physical software controllers .
our output diversity selection algorithm is inspired by the output uniqueness criterion that has been proposed and evaluated in the context of web application testing and has shown to be a useful surrogate to white box coverage selection criteria .
however while in output uniqueness is characterized based on the textual visual or structural aspects of html code in our work we define output diversity as euclidean distance between pairs of continuous output signals and apply it to stateflow models.
several approaches to test input generation when test inputs are discrete rely on techniques such as symbolic execution constraint solvers or model checkers e.g.
.
in our coverage based algorithms sc and tc we used adaptive random test input generation because our test inputs are signals.
as discussed in section with our adaptive random strategy sc and tc were able to achieve a high coverage despite small test suite sizes.
adapting symbolic techniques to generate test input signals is left for future work.
.
conclusions embedded software controllers are largely developed using discretecontinuous stateflows.
to reduce the cost of manual test oracles associated with stateflow models test case selection algorithms are required.
these algorithms aim at providing minimal test suites with high fault revealing power.
we proposed and evaluated six test selection algorithms for discrete continuous stateflows three output based od os oc two coverage based sc tc and one input based id .
our experiments based on two industrial and one public domain stateflow models showed that the output based algorithms consistently outperform the coverage based algorithms in revealing faults in mixed discrete continuous stateflows.
further for test suites larger than the output based algorithms were able to find with the same or higher probability all the faults revealed by the coverage based algorithms and hence subsumed them.
in addition os and oc selection algorithms had very high fault revealing rates even with small test suites for instability and discontinuity failures respectively.
for the other failures od outperformed the other algorithms in finding faults for test suite sizes larger than and further its fault detection rate kept improving at a faster rate than the others when increasing the test suite size.
in future we will seek to develop optimal guidelines on dividing test oracle budget across our output based selection algorithms.
further we intend to apply our test selection algorithms to models consisting of simulink blocks as well as stateflow models with discrete continuous behaviors as stateflow models are most often embedded in a network of simulink blocks.