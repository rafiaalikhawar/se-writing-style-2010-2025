semantic slicing of software version histories yi li chenguang zhu julia rubin member ieee and marsha chechik member ieee abstract software developers often need to transfer functionality e.g.
a set of commits implementing a new feature or a bug fix from one branch of a configuration management system to another.
that can be a challenging task as the existing configuration management tools lack support for matching high level semantic functionality with low level version histories.
the developer thus has to either manually identify the exact set of semantically related commits implementing the functionality of interest or sequentially port a segment of the change history inheriting additional unwanted functionality.
in this paper we tackle this problem by providing automated support for identifying the set of semantically related commits implementing a particular functionality which is defined by a set of tests.
we formally define the semantic slicing problem provide an algorithm for identifying a set of commits that constitute a slice and propose techniques to minimize the produced slice.
we then instantiate the overall approach cs licer in a specific implementation for java projects managed in git and evaluate its correctness and effectiveness on a set of open source software repositories.
we show that it allows to identify subsets of change histories that maintain the functionality of interest but are substantially smaller than the original ones.
index terms software changes version control dependency program analysis.
i ntroduction real software is seldom created all at once and changes are inevitable .
software development is typically an incremental and iterative process where many program versions are created each evolving and improving the previous ones.
for example new requirements bugs and errors emerge during use and developers can take advantage of the knowledge and insights they gain to repair enhance and optimize earlier versions of the system through incremental updates.
this makes version history a crucial artifact in the software development process.
software configuration management systems scm such as git svn and mercurial are commonly used for hosting software development artifacts.
they allow the developers to periodically submit their ongoing work storing it as an increment over previous version.
such an increment is usually referred to as a commit git and svn or a change set mercurial and we use these two terms interchangeably.
commits are stored sequentially and ordered by their time stamps so that it is convenient to trace back to any version in the history.
branching is another construct provided by most modern scm systems.
branches are used for example to store a still in development prototype version of a project or to store multiple project variants targeting different customers.
however the sequential organization of changes is inflexible and lacks support for many tasks that require high level semantic understanding of program functionality .
for example developers often need to locate and transfer y. li c. zhu and m. chechik are with the department of computer science university of toronto toronto on canada m5s3g4.
e mail liyi czhu chechik cs.toronto.edu j. rubin is with the department of electrical and computer engineering university of british columbia vancouver bc v6t1z4.
e mail mjulia ece.ubc.ca this article extends and improves the results presented in .
it contains novel techniques for history slice minimization additional data in the experimental results and a more detailed review of the related work.functionality either for porting bug fixes between branches or for propagating features from development to release branches .
several scm systems provide mechanism of replaying commits on a different branch e.g.
the cherry pick command in git.
yet little support is provided for matching high level functionality with commits that implement it scm systems only keep track of temporal and text level dependencies between the managed commits.
the job of identifying the exact set of commits implementing the functionality of interest is left to the developers.
even in very disciplined projects when such commits can be identified by browsing their associated log messages the functionality of interest might depend on earlier commits in the same branch.
to ensure correct execution of the desired functionality all change dependencies have to be identified and migrated to the new branch as well which is a tedious and error prone manual task .
for example consider the feature make groovy method blacklist truly append only introduced in version .
.
of the elasticsearch project a real time distributed data search and analytics framework written in java.
this feature and its corresponding test case are implemented in a single commit 647327f4 .
yet propagating this commit to a different branch will fail because one of the added statements makes use of a field whose declaration was introduced in an earlier commit 64d8e2ae .
including unwanted functionality and unnecessary commits in patches is often considered to be bad practice.
for instance most of the software projects implement strict guidelines of accepting only small and focused patches .
the main rationale behind these guidelines is to keep changes that have a different purpose separate which leads to a speed up in the code review process fewer merge conflicts and easier future maintenance.
for example the bitcoin core contributor guideline stresses the importance of simplicity of pull requests patchsets should always be focused.
for example a pull2 request could add a feature fix a bug or refactor code but not a mixture.
please also avoid super pull requests which attempt to do too much are overly large or overly complex as this makes review difficult.
in this paper we look at the problem of identifying the exact minimal subset of history that implements a particular functionality of interest.
inspired by the concept of program slicing we refer to this subset of semantically related commits as a semantics preserving slice .
we assume that a functionality is defined by a set of tests exercising it.
we propose a system cs licer which enhances the support provided by current scm tools by mapping high level functionalities to low level commits.
cslicer has two main phases semantic slicing and slice minimization .
the first phase consists of a generic history slicing algorithm which is independent of any specific scm system in use and an scm adaptation component that adapts the output produced by the slicing algorithm to specifics of scm systems.
the slicing algorithm relies on static and dynamic program analysis techniques to conservatively identify all atomic changes in the given history that contribute to the functional and compilation correctness of the functionality of interest.
the scm adaptation component then maps the collected set of atomic changes back to the commits in the original change history.
it also takes care of merge conflicts that can occur when cherry picking commits in text based scm systems e.g.
svn or git.
this step can optionally be skipped when using language aware merging tools or in semantic based scm systems .
however such systems are not dominant in practice yet.
the generic semantic slicing algorithm is conservative and can be imprecise.
the second phase of cs licer mitigates the imprecision and improves the quality of history slices through slice minimization.
we investigate various sources of imprecision that commonly appear in practice and design several techniques to detect and remove the false positives.
we first use a light weight screening technique to filter out changes that are less likely to affect the target functionality according to heuristics.
then we enumerate all possible combinations of the remaining commits and find a minimal subset of the original history which preserves the functionality of interest.
empirical results show that our proposed slice minimization techniques can effectively improve the solution quality of cs licer .
the use case of the cs licer system is not limited to functionality porting it can also be used for refactoring existing branches e.g.
by splitting them into functionality related ones.
we instantiate cs licer for java projects hosted in git.
to empirically evaluate the effectiveness and scalability of our approach we experiment with a set of open source software projects.
the results show that our approach can identify functionality relevant subsets of original histories that a correctly capture the functionality of interest while being b minimal in many cases or c substantially smaller than the original ones.
contributions.
in our prior work we presented an algorithm which computes an over approximated semantic history slice and evaluated the prototype implementation on a few subjects subjects.
in this paper we propose novel slice minimization techniques on top of the original algorithmto improve quality of the computed semantic slices.
we also extend and restructure the empirical studies to better evaluate the effectiveness of our approach.
we summarize the contributions as follows.
we formally define the semantic slicing problem for software version histories and propose a generic semantic slicing algorithm that is independent of underlying scm infrastructures and tools.
we extend the generic algorithm to bridge the gap between language semantic entities and text based modifications thus making it applicable to existing textbased scm systems.
we propose a number of heuristic based techniques which can effectively improve slice quality by reducing false positives and minimizing history slices.
we instantiate the overall approach cs licer by providing a fully automated semantic slicing tool applicable for git projects implemented in java.
the source code of the tool as well as binaries and examples used in this paper are available at we evaluate the tool on a number of real world mediumto large scale software projects.
we compare our twophase minimization technique with the state of art delta debugging .
our experiments show that cslicer is able to correctly identify functionalityrelevant minimal subsets of change histories more efficiently.
organization.
the rest of the paper is organized as follows.
we start with a simple example in section illustrating cslicer .
it is followed by necessary background and definitions in section .
in section we formalize the semantic slicing algorithm and prove its correctness.
in section we define the notion of minimal history slice and propose several techniques that can improve quality of semantic slices.
in section we describe the implementation details and optimizations.
in section we report on our case studies and empirical findings.
finally in section and we compare cs licer with related work and conclude the paper respectively.
cs licer by example in this section we illustrate cs licer on a simple schematic example inspired by the feature migration case in the elasticsearch project .
figure shows a fragment of the change history between versions v1.
and v1.
for the filefoo.java .
initially as shown in version v1.
the file contains two classes aandb each having a member method gandf respectively.
later in change set c1 a line with a textual comment was inserted right before the declaration of method a.g. then in change set c2 the body of b.f was modified from return x to return x .
in change set c3 the body of a.g was updated to return the value of a newly added field yin classb.
in change set c4 a field declaration was inserted in classaand finally in change set c5 a new method hwas added to class a. the resulting program in v1.
is shown in figure on the left.
each dashed box in figure encloses a commit written in the unified format the output of command diff u .
the3 v1.
class a hunk deps int g return class b static int f int x return x return x hunk deps int g return return new b .y class b int y static int f int x return x class a int x hunk deps int g class a int x int h return b.f x hunk deps int g c5 c4 c3 c2 c11 class a int g return class b static int f int x return x v1.
fig.
.
change history of foo.java .
c l a s s a i n t x i n t h return b .
f x hunk deps i n t g return new b .
y c l a s s b i n t y s t a t i c i n t f i n t x return x c l a s s a i n t x i n t h return b .
f x hunk deps i n t g return c l a s s b s t a t i c i n t f i n t x return x fig.
.foo.java before and after semantic slicing.
lines starting with are inserted while those starting with are deleted.
each bundle of changed lines is called a hunk and comes with a context a certain number of lines of surrounding text that stay unchanged.
in figure these are the lines which do not start with or .
the context that comes with a hunk is useful for ensuring that the change is applied at the correct location even when the line numbers change.
a conflict is reported if the context cannot be matched.
in the current example the maximum length of the contexts is four lines up to two lines before and after each change.
suppose the functionality of interest is that the method a.h returns .
this functionality was introduced in c5and now needs to be back ported to v1.
.
simply cherrypickingc5would result in failure because the body of methodb.f was changed in c2and the change is required to produce the correct result the declaration of field a.x was introduced in c4but was missing in v1.
which would cause compilation errors and a merge conflict would arise due to the missing context of c5 the text that appears immediately after the change.
this text was introduced in c1.
in fact the change histories form a dependency hierarchytextual contextscompilation setfunctional setcorrectness well formedness applicabilityc1examples c4c2 c5 hunkcompilationfunctionaldependency types fig.
.
change dependency hierarchy.
with respect to the target functionality see figure .
at its core the functional set contains program components which directly participate in the test execution to deliver the target functionality e.g.
methods a.h andb.f.
to start with cslicer examines the history and identifies functional dependencies that are essential for the semantic correctness of the functional set e.g.
c2 c5.
in addition cs licer computes thecompilation set which connects the functional core with its structural supporting components i.e.
classes a band the field declaration int x ina.
similarly the corresponding contributing changes are called the compilation dependencies e.g.
c4.
they are necessary to guarantee program wellformedness including syntactic correctness and type safety.
finally to ensure the selected changes can be applied using a text based scm system some additional changes which provide textual contexts should be included as well.
we call these changes the hunk dependencies e.g.
c1.
in the semantic slicing phase our proposed algorithms compute a set of commits that are required for porting the functionality of interest to v1.
successfully c1 c2 c4 c5 .
this process is formalized in section .
then in the slice minimization phase cs licer attempts to reduce from the identified commits and in this particular case fails since the solution is already optimal there is no smaller set of commits that can preserve all of the desired properties.
we investigate more complex cases in section .
applying the set of commits in sequence on top of v1.
produces a new program shown in figure on the right.
it is easy to verify that the call to a.h in both programs returns the same value.
changes introduced in commit c3 an addition of the field b.y and a modification of the method a.g do not affect the test results and are not part of any other commit context.
thus this commit can be omitted.
b ackground in this section we provide the background needed in the rest of the paper.
.
language syntax to keep the presentation of our algorithm concise we step back from the complexities of the full java language and concentrate on its core object oriented features.
we adopt a simple functional subset of java from featherweight java denoting it by p. the syntax rules of the language p are given in figure .
many advanced java features e.g.
interfaces abstract classes and reflection are stripped from p while the typing rules which are crucial for the compilation4 p l l classcextends c c f km k c c f super f this.f f m c m c x return e e x e.f e.m e new c e c e fig.
.
language syntax rules .
c cc d d e c eclasscextends d ... c d fig.
.
subtyping rules .
correctness are retained .
we discuss additional language features in section .
we say that pis asyntactically valid program of language p denoted by p p ifpfollows the syntax rules.
a program p pconsists of a list of class declarations l where the overhead bar lstands for a possibly empty sequence l1 ... l n. we use a bracketle t a bracketri htto denote an empty sequence and comma for sequence concatenation.
we use l to denote the length of the sequence.
every class declaration has members including fields c f methods m and constructors k .
a method body consists of a single return statement the returned expression can be a variable a field access a method lookup an instance creation or a type cast.
the subtyping rules of p shown in figure are straightforward.
we write c dwhen class cis a subtype of d. as in full java subtyping is the reflexive and transitive closure of the immediate subclass relation implied by the extends keyword.
the field and method lookup rules are slightly different from the standard ones see figure field overshadowing and method overloading are not allowed while method overriding is allowed in featherweight java .
for example when resolving a method call c.m the method listmof classcis first consulted.
if mis defined in c then its type and body are returned as a pair b b x.e .
otherwise the lookup continues recursively on the super class ofc.
.
abstract syntax trees a valid program p pcan be parsed as an abstract syntax tree ast denoted by a st p .
we adopt a simplified ast model where the smallest entity nodes are fields and methods.
formally r ast p is a rooted tree with a set of nodes v r .
the root of ris denoted by root r which represents the compilation unit i.e.
the program p. each entity node xhas an identifier and a value denoted by id x and x respectively.
in a valid ast the identifier for each node is unique e.g.
fully qualified names in java and the values are canonical textual representations of the corresponding entities.
we denote the parent of a node xby p arent x .
for example figure shows two asts for the program foo.java before and after the change set c3is applied.
in the left ast the following facts are true about the node f id f foo.b.f int f static int f int x return x parent f b.fields object a bracketle t a bracketri ht classcextends d c f km fields d d g fields c d g c f classcextends d c f km b m b x return e m methods m c b b x.e classcextends d c f km m m methods m c methods m d fig.
.
fields and methods lookup .
foo b a y int g f int foo b a g f int ins y int b upd a.g c3 fig.
.
visualize c3as a sequence of atomic changes applied on asts.
the children are unordered the ordering of child nodes is insignificant.
therefore each program has its unique ast representation.
.
changes and change histories let be the set of all asts.
now we define what change change set and change history as ast transformation operations.
definition .
atomic change .
an atomic change operation is either an insert delete orupdate see figure .
it transforms r producing a new ast r such that r r .
an insertion ins x n v y inserts a node xwith identifiernand value vas a child of node y. a deletion del x removes node xfrom the ast.
an update upd x v replaces the value of node xwithv.
a change operation is applicable on an ast if its preconditions are met.
for example the insertion ins x n v y is applicable on rif and only if y v r .
insertion of an existing node is treated the same as an update.
definition .
change set .
let randr be two asts.
a change set is a sequence of atomic changes a bracketle t 1 ... n a bracketri htsuch that r n 1 r r where is standard function composition.
a change set 1is applicable to rif 1is applicable to rand 1is applicable to 1 r .
change sets between two asts can be computed by tree differencing algorithms .
for instance in figure c3consists of an insertion of a new node ytobfollowed by an update of the nodeg.
definition .
change history .
a history of changes is a sequence of change sets i.e.
h a bracketle t ... k a bracketri ht.
definition .
sub history .
a sub history is a sub sequence of a history i.e.
a sequence derived by removing change sets from h without altering the ordering.
y v r ins x n v y v r v r x parent x y id x n x v x v r del x v r v r x x v r upd x v x v fig.
.
types of atomic changes .
we write h hindicating h is a sub history of hand refer to a bracketle t i ... j a bracketri htashi..j. the applicability of a history is defined similar to that of change sets.
.
test cases we assume that semantic functionalities can be captured by test cases and the execution trace of a test case is deterministic.
for simplicity a test case can be abstracted into two parts the setup code which initializes the testing environment and executes the target functionalities using specific inputs as well as the oracle checks which verify that the produced results match with the expected ones.
a test execution succeeds if all checks pass.
definition .
test case .
a test case tis a function t p b such that for a given program p p t p is true if and only if the test succeeds and false otherwise.
a test suite is a collection of unit tests that can exercise and demonstrate the functionality of interest.
let test suite tbe a set of test cases ti .
we write p tif and only if program ppasses all tests in t i.e.
t t t p .
cs licer phase s emantic slicing in this section we define the semantic slicing problem and present our slicing algorithms in detail.
.
overview of the workflow we start with the formal problem definition followed by a high level overview of our approach.
.
.
problem definition definition .
semantics preserving slice .
consider a program p0and itsksubsequent versions p1 ... p ksuch that pi p andpiis well typed for all integers i k. lethbe the change history from p0topk i.e.
h1..i p0 pifor all integers i k. lettbe a set of tests passed by pk i.e.
pk t. a semantics preserving slice of history hwith respect to tis a sub history h hsuch that the following properties hold h p0 p h p0 is well typed h p0 t. our goal is to conservatively identify such a semanticspreserving slice or sometimes referred to as semantic slice for short.
a trivial but uninteresting solution to this problem is the original history hitself.
shorter slicing results are preferred over longer ones and the optimal slice is the shortest sub history that satisfies the above properties.
however the optimality of the sliced history cannot always be guaranteed by polynomial time algorithms.
since the test case can be ...h p0 pkt t1 ... tm compute functional setcompute compilation set ast diff pi pi 1slicing i ... k h i scm adaptation h hunk dependencies history slice fig.
.
high level over view of the semantic slicing algorithms.
arbitrary it is not hard to see that for any program and history there always exists a worst case input test that requires enumerating all 2ksub histories to find the shortest one.
the naive approach of enumerating sub histories is not feasible as the compilation and running time of each version can be substantial.
even if a compile and test run takes just one minute enumerating and building all sub histories of only twenty commits would take approximately two years.
in fact it can be shown that the optimal semantic slicing problem is np complete by reduction from the set cover problem.
we omit the details of this argument here.
to address this problem we devise an efficient algorithm which requires only a one time effort for compilation and test execution but may produce sub optimal results.
an optimal algorithm which runs the test only once cannot exist in any case in order to determine whether to keep a change set or not it needs to at least be able to answer the decision problem given a fixed program pand test t for any arbitrary program p will the outputs of tbe different on both?
which is known to be undecidable .
.
.
workflow figure illustrates the high level workflow of the semantic slicing algorithms.
first the functional set and compilation set are computed based on the latest version pk and the input tests t. the original version history his then distilled as a sequence of change sets a bracketle t ... k a bracketri htthrough ast differencing.
this step removes cosmetic changes e.g.
formatting annotations and comments and only keeps in iatomic changes over code entities.
each such set ithen goes through the core slicer component which decides whether to keep a particular atomic change or not.
this component outputs a sliced change set i which is a subsequence of i. finally the sliced change sets are concatenated and returned as a sub history h .
optionally a post processing step scm adaption of h is needed if the sliced history is to be applied using text based scm systems.
below we describe each step in turn illustrating them through the running example presented in section .
step computing functional set.
cslicer executes the test on the latest version of the program left hand side of figure which triggers method a.h. it dynamically collects the program statements traversed by this execution.
these include the method bodies of a.h andb.f.
the set of source code entities e.g.
methods or classes containing the traversed statements is called the functional set denoted by .
the functional set in the current example is a.h b.f .
intuitively if a the code entities in the functional set and b the execution traces in the program after slicing remain unchanged then the test results will be preserved.
special attention has to be paid to any class hierarchy and method lookup changes that might alter the execution traces as discussed in more detail later.
step computing compilation set.
to avoid causing any compilation errors in the slicing process we also need to ensure that all code entities referenced by the functional set are defined even if they are not traversed by the tests.
towards this end cs licer statically analyzes all the reference relations based on pkand transitively includes all referenced entities in the compilation set denoted by .
the compilation set in our case is a a.x b .
notice that the classes aand bare included as well since the fields and methods require their enclosing classes to be present.
step change set slicing.
in the change set slicing stage cslicer iterates backwards from the newest change set k to the oldest one collecting changes that are required to preserve the behavior of the functional and compilation set elements.
each change is divided into a set of atomic changes see definition .
having computed the functional and compilation set highlighted in figure cs licer then goes through each atomic change and decides whether it should be kept in the sliced history h based on the entities changed and their change types.
in our example c2and c5are kept in h since all atomic changes introduced by these commits b.f anda.h are in the functional set.
c4 contains an insertion of a.b which is in the compilation set.
hence this change is also kept in h .c3can be ignored since the changed entities are not in either set.
during the slicing process cs licer ensures that all entities in the compilation set are present in the sliced program albeit their definitions may not be the most updated version.
because the entities in the compilation set are not traversed by the tests differences in their definitions do not affect the test results.
optional scm adaptation.
in the scm adaptation phase change sets in h are mapped back to the original commits.
as some commits may contain atomic changes that sliced away by the core slicing algorithm including these commits in full can introduce unwanted side effects and result in wrong execution of the sliced program.
we eliminate such side effects by reverting unwanted changes.
that is we automatically create an additional commit that reverts the corresponding code entities back to their original state.
in addition we compute hunk dependencies of all included commits and add them to the final result as well.
for example the comment line added in c1forms a context for c5.
therefore c1is required in the sliced history to avoid merge conflicts when cherry picking c5.
the details of this process are discussed in section .
.
.
semantic slicing algorithm now we present in detail the semantic slicing algorithm which is independent from the underlying scm systemsrequire h h p0 p h p0 t ensure h h h p0 p h p0 t procedure semantic slice p0 h t h k a bracketle t a bracketri ht h initialization pk h p0 pkis the latest version func dep pk t functional set comp dep pk compilation set fori do iterate backwards i a bracketle t a bracketri ht initialize sliced change set for ido if lookup h1..i p0 then keep lookup if is d el id then continue skip non comp and deletes if is u pd id then continue skip non test updates i i concatenate the rest end for h h i growh end for returnh end procedure fig.
.
algorithm the semantic slicing algorithm.
and it follows essentially the workflow depicted in figure .
the optional scm adaptation phase will be discussed in section .
.
.
.
algorithm the main s emantic slice procedure is shown in figure .
it takes in the base version p0 the original history h a bracketle t ... k a bracketri htand a set of test cases tas the input.
then it computes the functional and compilation set and respectively lines and .
func dep pk t .based on the execution traces of running tonpk the procedure f unc depreturns the set of code entities ast nodes traversed by the test execution.
this set includes all fields explicitly initialized during declaration and all methods and constructors called during runtime.
comp dep pk .the procedure c omp depanalyzes reference relations in pkand includes all referenced code entities of into the compilation set .
we borrow the set of rules for computing from k astner and apel where the authors formally prove that their rules are complete and ensure that no reference without a target is ever present in a program.
applying these rules which are given in figure and described below allows us to guarantee type safety of the sliced program.
l1 a class can only extends a class that is present l2 a field can only have type of a class that is present k1 a constructor can only have parameter types of classes that are present and access to fields that are present m1 a method declaration can only have return type and parameter types of classes that are present e1 a field access can only access fields that are present e2 a method invocation can only invoke methods that are present e3 an instance creation can only create objects from classes that are present e4 a cast operation can only cast an expression to a class that is present c d c d f c c c d f super f this.f f c d f c m d x return e c d ... return e.f f ... return e.m e m ... return new c e c ... return c e c x parent x x x fig.
.
c ompdepreference relation rules.
p1 an entity is only present when the enclosing entities are present t1 an entity is in the compilation set if it is in the functional set.
we iterate backwards through all the change sets in the history lines and examine each atomic change in the change set.
an atomic change is included into the sliced history if it is an insertion or an update to the functional set entities or an insertion of the compilation set entities.
updates to the compilation set entities are ignored since they generally do not affect the test results.
our language pdoes not allow method overloading or field overshadowing which limits the effects of class hierarchy changes.
exceptions are changes to subtyping relations or casts which might alter method lookup line .
therefore we define function l ookup to capture such changes lookup p defines m c methods m c e atio slash methods m c where methods and methods are the method lookup function for pand p respectively.
finally the sliced history h is returned at line .
.
.
correctness of algorithm assume that every intermediate version of the program pis syntactically valid and well typed.
we show that the sliced program p produced by the s emantic slice procedure maintains such properties.
lemma .
syntactic correctness .
h p0 p. proof.
from the assumption every intermediate version p0 ... p kis syntactically valid.
as a result their asts are well defined and every change operation his applicable given all preceding changes.
updates on tree nodes do not affect the tree structure and therefore do not have effect on the preconditions of the changes.
we can safely ignore updates when considering syntactic correctness.
we prove the lemma by induction on the loop counter i. the base case is when i kandh a bracketle t a bracketri ht.
by definition h pk pkis inp.
assume that h h1..i p0 p. we must show that h i h1..i p0 p. from the condition on lines and we know that changes affecting only the entities outside of are ignored.
so for any change h we have id .
depending on the change type of the precondition of is eitherid itself or its parent should present figure .
because of the c omp deprule p1 i.e.
x parent x changes to entities in and their parents are kept.
therefore any change h stays applicable.lemma .
type safety .
h p0 is well typed.
proof.
entities outside of compilation set stay unchanged except for method lookup changes which might be kept and do not affect type soundness and their referenced targets are preserved since deletions are omitted.
thus non compilation set entities remain well typed.
by similar inductive argument as in lemma and the completeness of the c omp deprules we have that the compilation set entities also stay well typed after the slicing.
thus h p0 is well typed.
theorem .
correctness of algorithm .
let a bracketle tp1 ... p k a bracketri htbe kconsecutive subsequent versions of a program p0such that pi pandpiis well typed for all indices i k. let h a bracketle t ... k a bracketri htsuch that i pi pifor all indices i k. lettbe a test suite such that pk t. then the sliced history h semantic slice p0 h t is semanticspreserving with respect to t. proof.
according to definition we need to show that h satisfies the following properties h p0 p h p0 is well typed h p0 t. from lemma and lemma we know that h h1..i p0 satisfies and is an invariant for the outer loop lines of algorithm .
the original history hhas a finite length k so upon termination we have h p0 satisfies and .
since all functional set insertions and updates are kept in h any functional set entity that exists in h p0 can be found identical in h p0 .
because all changes that alter method lookups are also kept line the execution traces do not change either.
due to that reason and by the definition of functional set also holds.
thus h p0 satisfies and .
.
scm adaptation the proposed semantic slicing algorithm operates on the atomic change level and can directly be used with semanticbased tools such as semanticmerge .
as an optional step scm adaptation integrates the generic algorithm with text based scm systems such as git.
.
.
eliminating side effects to make the integration with text based scm systems easier each atomic change has to be mapped back to a commit in the original history.
the sub history h i a bracketle t ... k a bracketri ht iis possibly empty returned by s emantic slice is a sequence of atomic changes labeled by indices indicating their corresponding original commits.
a non empty sliced change set ican thus be mapped to its counterpart in the original history i.e.
i. pj pi pi ... i j ... i 2 insert 3 delete 1 update 4 5 fig.
.
illustration of direct hunk dependencies.
however original commits may contain changes that are sliced away by algorithm .
these changes might create unwanted side effects which break the type safety of the compilation set entities.
we deal with this issue by restoring entities that are outside of the compilation set to their original state as in the initial version of the program thereby selectively ignoring these unwanted changes and eliminating the side effects.
we do that by creating an additional commit that reverts unwanted changes on the corresponding code entities.
.
.
calculating hunk dependencies algorithm treats changes between versions as tree edit operations.
another view of changes used by text based scm tools is called hunk .
a hunk is a group of adjacent or nearby line insertions or deletions with surrounding context lines which stay unchanged.
for simplicity we reuse the notations of tree change operations for hunk changes.
for example figure shows an abstract view of the changes made between pi 1andpi where blocks with represent lines removed and blocks with represent lines inserted.
grey blocks surrounding the changed lines represent the contexts.
from the text based view the difference between pi 1andpiconsists of three hunks i.e.
1 2and 3. we define two auxiliary functions left andright which return the lines involved before and after the hunk change respectively.
special cases are right when is a deletion and left when is an insertion.
in both cases the functions return a zero length placeholder at the appropriate positions.
in order to apply the sliced results with text based scm tools where changes are represented as hunks it is needed to ensure that no conflict arises due to unmatched contexts.
informally a change set idirectly hunk depends on another change set j denoted by i squiggleright j if and only if j contributes to the hunks or their contexts in i. in contrast if idoes not directly hunk depend on j we say they commute i.e.
reordering them in history does not cause conflict.
the procedure h unk dep h returns the transitive hunk dependencies for all change set in h i.e.
hunk dep h defines uniondisplay i h j j h h i squiggleright j .
procedure direct hunk bi h1..i d bi li for i 1do if is d el right range bi then d d i else if is ins right bi e atio slash then d d i bi bi right end for d d direct hunk bi h1.. i returnd end procedure fig.
.
algorithm the d irect hunk procedure.
once a sub history h is computed and returned by algorithm we augment h with h unk dep h and the result is guaranteed to apply to p0without edit conflicts.
given a change set i we collect a set of text lines biwhich are required as the basis for applying i. for example bifor iincludes left for all iand their surrounding contexts all shaded blocks under pi 1in figure .
figure describes the algorithm for computing the set of direct hunk dependencies squiggleright by tracing back in history and locating the latest change sets that contribute to each line of the basis.
starting from i we iterate backwards through all preceding change sets.
if a change set contains a deletion that falls in the range of the basis line or an insertion that adds lines to the basis line then is added to the direct dependency set d. in figure i squiggleright jbecause jhas both an insertion 4 and a deletion 5 that directly contribute to the basis at pi .
when the origin of a line is located in the history the line is removed from the basis set line .
the algorithm then recursively traces the origin of the remaining lines in bi .
upon termination dcontains all direct hunk dependencies of i. in the worst case h unk depcalls d irect hunk for every change set in h .
thus the running time of h unk dep is bounded above by o h h max h .
cs licer phase s lice minimization the problem of finding optimal semantics preserving subhistory is intractable in general as we showed in section .
.
.
however there are many cases where a minimal sub history is preferred or even required.
for example when submitting pull requests for review contributors should refrain from including unrelated changes as suggested by many project contribution guidelines .
also developers commonly suggest to split a mixed patch into multiple ones e.g.
as indicated by these code review comments okay nevertheless we need to split this up because it is unrelated to the issue we re talking about.
therefore we would like to produce logically clean and easy to merge history slices by reducing all irrelevant changes.
despite the complexity of finding shortest slices we have identified a number of heuristic based techniques that could help shorten history slices and possibly derive .
c l a s s dog i n t age set dog enemies new hashset dog public dog i n t a age a void barking system .
out .
p r i n t l n bark !
boolean f i g h t i n g dog other barking enemies .
add other return !
age age age other .
age c l a s s testdog test public t e s t f i g h t dog d1 new dog dog d2 new dog asserttrue d1 .
f i g h t i n g d2 line descriptions 1 3new hashset dog new hashset 2 bark!
bark!bark!
3 !
age age age age fig.
.
example illustrating different types of false positives.
minimal ones.
in this section we define minimal semantic slice and discuss a few such techniques for minimizing history slices obtained from phase .
.
minimal semantic slice we say a sub history h ofhis a minimal semantic slice ifh is semantics preserving and it cannot be further shortened without losing the semantics preserving properties see definition .
definition .
minimal semantic slice .
given a semanticspreserving slice h such that h th.h is a minimal semantic slice of hif hsub h hsub h hsub th .
for our running example in section the solution produced by cs licer is not only minimal but also optimal as there does not exist any other sub history which is semanticspreserving.
however a minimal semantic slice does not always correspond to the global optimal slice.
in other words there might exist a shorter semantic slice hoptwhich is not a sub history of h .
empirical evidences show that minimal slice of a semantics preserving slice such as h returned by algorithm is a good approximation to hopt see section .
.
.
.
sources of imprecision the cs licer algorithm algorithm presented in section assumes that any change on the functional set can potentially alter the final test results and thus all functional changes are kept during slicing.
but this assumption is often found to be too conservative in practice.
we observed many cases of false positives during change classification in our experiments details in section which can be divided into two groups namely semantics preserving changes and oracle unobservable changes.
figure shows an example illustrating the two types of false positives.
the fighting method of the dog classis tested using two newly created instances.
the executed code entities include initialization of the field enemies class constructor the barking and thefighting methods.
however none of the changes 1 2 and 3 has any influence on the asserted result line .
specifically 1 is a syntactic rewriting which does not change the semantics of the program at all 2updates the barking method to produce a different console output but the output is never checked against an oracle 3changes the returned expression of method fighting but the returned value is not affected at runtime.
semantics preserving changes.
an example of semanticspreserving changes is code refactoring .
refactoring changes are program transformations that change the structure or appearance of a program but not its behavior e.g.
1 .
refactoring is important for improving code readability and maintainability.
however refactoring changes create problems for text based scm systems especially during merging.
based on the study by dig et al.
merging changes along with code refactoring causes significantly more merge conflicts compilation and runtime errors.
the common practice is thus separating refactoring from functional changes which gives developers the flexibility to replay the refactoring changes after merging is done.
therefore the slice minimization phase aims to produce logically clean and easy to merge history slices by isolating all semantics preserving changes.
renaming of code entities is one commonly seen refactoring change.
in fact existing code refactoring detection techniques focus on renaming and movement of structural nodes i.e.
packages classes methods and fields.
however such changes would alter ast structures as well as node identifiers and thus often have a repercussion on later changes.
for instance once a class renaming change is applied all successive