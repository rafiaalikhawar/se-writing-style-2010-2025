inferring hierarchical motifs from execution traces saba alimadadi northeastern university boston ma usa saba northeastern.eduali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.cakarthik pattabiraman university of british columbia vancouver bc canada karthikp ece.ubc.ca abstract program comprehension is a necessary step for performing many software engineering tasks.
dynamic analysis is effective in producing execution traces that assist comprehension.
traces are rich sourcesofinformationregardingthebehaviourofaprogram.however it is challenging to gain insight from traces due to their overwhelming amount of data and complexity.
we propose a generic technique for facilitating comprehension by inferring recurring execution motifs.
inspired by bioinformatics motifs are patternsin traces that are flexible to small changes in execution and arecaptured in a hierarchical model.
the hierarchical nature of the model provides an overview of the behaviour at a high level while preserving the execution details and intermediate levels in a structured manner.
we design a visualization that allows developers to observe and interact with the model.
we implement our approach inanopen sourcetool calledsabalan andevaluateitthrougha userexperiment.theresultsshowthatusingsabalanimproves developers accuracy in performing comprehension tasks by .
ccs concepts software and its engineering software maintenance tools keywords program comprehension behavioural model hierarchical motifs acm reference format saba alimadadi ali mesbah and karthik pattabiraman.
.
inferring hierarchical motifs from execution traces.
in icse icse 40th internationalconferenceonsoftwareengineering may27 june3 gothenburg sweden.
acm new york ny usa pages.
.
introduction programcomprehensionisanessentialfirststepformanysoftware engineering tasks.
developers spend a considerable amount of timeunderstandingcode.about50 ofmaintenanceeffortisspent oncomprehensionalone .unfortunately codeunderstanding is challenging.
to understand code developers typically start by work performed while a phd student at the university of british columbia ubc .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
for clues in the code and the environment.
then they go backandforthontheincomingandoutgoingdependenciesto relate pieces of foraged information.
throughout the process they collect information they find relevant for understanding the code on an as needed basis .
however developers often fail in searching and relating information and lose track of relevant information whenusingsuchad hocstrategies .further developersform mentalmodelsofcode thatareofteninaccurate .thus there is a need for systematic and automated techniques for program comprehension .
dynamic analysis which collects and utilizes data traces from programexecution isapopulartechniqueforprogramcomprehension.however duetothe amountofinformationobtained during the execution the traces tend to become complex and overwhelming andthusdifficulttounderstand .existingtechniques target this problem e.g.
by summarizing traces structuring and visualizing collected data or inferring system specifications .however thefirsttechniquelosessomeofthe data that may still be valuable and the rest become overwhelmingfordevelopersandarenotflexibletosmallvariationsofdata.
the problem can also be approached by finding patterns in the execution.
however prior work in the area has predominantly focused on generic and predefined design patterns low level architecturalrelationsbetweenprogramartifacts orvisualizationsofall detailsofexecution .whileuseful theseapproaches donotcapturethebehaviouralpatternsthatareneitherdefinednor known prior to analysis but form and recur with small variations throughouttheexecutionofaprogram.eveninmoretraditional programming languages patterns in execution do not repeat exactlyinthesamemannerorsamesequence.further presenceof programminglanguagesfeaturessuchasdynamism asynchrony and non determinism in the execution makes the analysis more problematicandburdensome andrendersconventionaltechniques ineffective.
hence program comprehension through dynamic analysis still remains challenging .
in this paper we propose a novel technique for program comprehension by inferring a model of execution motifs.
motifs are abstract and flexible recurring patterns in program execution that serve a specific purpose in the functionality of the program.
the termisinspiredby sequencemotifs whicharerecurringpatternsin dna sequences that have a biological function .
our approach discovers motifs from traces containing function executions and events.ourproposedalgorithmcomparesatraceobtainedfromaninteractionsessionagainstadatabaseofpreviously collectedtraces.
ititerativelyexaminessegmentsoftracesfordetectingsequences of function executions that may recur in execution.
it is tolerant of small variations in different manifestations of each motif allowing abstraction in inferred motifs.
the algorithm discovers hierarchies acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. alimadadi et al.
email address occupation select one ... student... degree select onea b submiti bii a window validateemail checkaddress occupation studentformsubmitiii figure i a sample registration form.
ii a sample executiontrace andb hierarchyofinferredmotifs.iii dynamic call graph of example between motifs as they emerge from details of execution.
the hierarchicalstructureofinferredmotifsrevealshowhigher levelkey pointsofexecutionareformed.itallowsuserstohaveanoverviewofthetrace whilestillhavingaccesstoallexecutiondetailsaswell as all intermediate levels.
the main contributions of our work are as follows we propose an automated approach for inferring a modelof program behaviour which encompasses hierarchies ofabstract recurring motifs extracted from execution traces.
our approach is inspired by techniques from bioinformatics wheresimilarchallengesariseininvestigatingsimilarities in large sequences of dna.
the motifs facilitate program comprehensionbyhighlightingthemaincharacteristicsof behaviour and abstracting the details and variations of execution.
wedesignandbuildavisualizationtechniqueforpresentingthemotifstodevelopers toprovideassistancewithprogram comprehension.ourmethodiscomplementarytoexisting toolsandtechniques andisdesignedtobeutilizedalongside existing programming environments.
weimplementourapproachinatoolcalledsabalanthat supports javascript based web applications.
our tool is non intrusiveforgeneratingtraces andinfersmodelsofrecurring motifs from execution trace in an automated manner.
we evaluate our approach through a controlled experiment conductedwith14participants onasetofreal worldprogram comprehension tasks.
the results show that using sabalan helps developers perform program comprehension tasks more accurately than other tools.
challenges and motivation toassisttheprocessof searching relatingandcollecting information many techniques collect execution traces analyze them and or visualizetheresultsforthedevelopers.despiteprovidingthegrounds forpreciseanalyses dynamictracesbecomeverylargeandcause informationoverload.further theybecomeverycomplexdueto dynamism asynchrony and non determinism in program execu tion.
these challenges render large traces ineffective in assisting program understanding.
form 2email input type email id email 3address input type text class addr 4occupation div class dropdown id occupation button class dropbtn choose one button div class dropdown content a href academic a a href industry a div div input type submit value submit submit input form figure initial dom state of the running example.
email .addeventlistener change validateemail false .addr .click checkaddress .dropdown content .addeventlistener change occupation arrowhookright false 4function validateemail do stuff 7function checkaddress do more stuff figure javascript code of the running example.
in this section we use a simple example to illustrate these challenges figures .
we selected javascript for the examples since it is the lingua franca of web development.
it has been recently votedasthemostpopularprogramminglanguageonstackoverflow andisthemostusedlanguageongithub .javascript applicationsarehighlydynamic asynchronousandeventdriven and heavily interact with the document object model dom and theservercode .thesefeaturescanhelpdemonstratetracecomplexity within small code segments.
while our approach is general we use javascript in this paper to demonstrate it.
overload by information in large traces.
the amount of information a trace carries matters due to the cognitive load that understandingthetraceimposesondevelopers e.g.
astudy foundthatonegboftracedatawasgeneratedforeverytwoseconds of executed c c code .
for modern applications which areoftendistributedamongmanynodeswithmanycomponents involved the traces become incomprehensible for developers very quickly.sometechniquestrytoaddresstheproblembyreducing thetraceduring afteritscollection byfocusingonmore important entities or filtering the details of the executions.
these techniqueshavebeenabletomaketracesmoreusefulbydecreasing the information contained in the traces .
however even with a technique that creates a smaller trace the trace is still not necessarily understandable for developers as some of the data might be lost or missed by developers.
complex and hidden dependencies.
revealing abstract and higher levelpatternsthathighlightthekeypointsofaprogram s behaviourcanfacilitatecomprehension.thefocusofthedeveloper canbeguidedthroughahierarchyofrecurringpatternsofexecution whileallcollectedinformationarestillpreservedforfurther inquiry.however extractingsuchpatterns motifs ischallenging duetothedynamism asynchronyandnon determinisminprogram execution expecially in javascript applications.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
inferring hierarchical motifs from execution traces icse may june gothenburg sweden first therearemanycomplexandhiddendependenciesbetween entities in the system which can affect the execution.
understanding the impact of a user action or asynchronous communication with the server are examples of relations that are difficult if not impossible tocapturefrommerelyanalyzingthecodeorthecall graph.
they act as media for connecting segments of execution together that otherwise would not be related in the code itself.further for a part of behaviour to be distinguished as a motif it should recur during the execution.
different executions of what is conceptually the same motif may vary in details and thus may not convergetorevealthesamemotif.thealterationsareintensified whenprogramshaveuserinterfaces aredistributed orinvolvegeneraldynamism andasynchrony .
however suchvariations should not prevent the analysis from recognizing the high level blueprint ofthebehaviouralmotiftheyallmanifest.ananalysisthatisoverly dependent on execution details may not allow higher level motifsto reveal themselves.
example.
consider the example shown in figure showing a partofaformrequiredforregisteringauser.specificeventsontheinputfieldsoftheformhavehandlersthatvalidatetheinputbefore theformcanbesubmitted.
verifyemail andcheckaddress lines1 2offigure3 arehandlersfor emailandaddress fieldsof part a of the form lines of figure .
the two function are always executed together in a successful registration scenario and are a consistent part of the motif representing that scenario due totheirplacementinthedom.however thisrelationcannotbe inferred from the code figure or the call graph figure .iii .
moreover asuccessfulsubmissionrequirespropersubmissionof allthefields.however theformcanchangeinsection b offigure1basedontheinputof occupation lines4 11offigure2 .iftheuser choosesstudent a drop down menu appears and the appearance content andfunctionalityoftheformchangesbasedonuser sinput.however theconceptualpurposeofsubmittingtheform andhence themotif remainthesame.shouldananalysisbetoodependent on exact execution details these two executions will be considered different.however amorerepresentativeanalysisshouldrecognizethatregardlessofoccupationoftheuser theessenceofthemotifisthe same and it should support both options.
there is often neither priorknowledgenortemplatesoftheapplication specificmotifs.
hence ausefulcomprehensionmethodshouldaccomodateadegree of flexibility in inferring motifs to allow abstract motifs to form independently from unimportant contextual details.
overview of the methodology for execution traces such as the one depicted in figure .ii.a our goalistoinferahierarchyofitsrecurringmotifs byutilizingthe knowledge of previous executions of the application.
the model of extractedmotifsassistscomprehensionoftheprogrambehaviour byfacilitatingthecycleof searching relating and collecting information.havingourproposedapproach developersareabletogainanoverallunderstandingofthehighlightsofexecution manifested as motifs at a glance.
further they would have the means to understand the details of such motifs their hierarchies and relations upon inquiry figure .ii.b .our approach takesadvantage ofprecision of dynamic analysis but prevents developers from being trapped and overwhelmed by the execution details.ourproposedapproachfirstinstrumentsandinterceptstheapplication on the fly to obtain traces.
having a knowledge baseof previously collected traces and a query trace our algorithmthenextractsmotifsofdifferentlengthswithintraces andinfers hierarchies and relations of motifs.
our algorithm is inspired by bioinformaticsalgorithmsforaligningbiologicalsequences.finally ourapproachcreatesabehaviouralmodelfromthemotifsandtheir relations which we visualize for developers.
execution traces.
to obtain the traces required for the algorithm we instrument theapplicationsandcollectdynamicexecution information automatically.
our instrumentation allows our technique tointerceptall function executions and collect their contextsensitive information.
it also intercepts all events that can occur duringtheexecution.theiraddedknowledgecanassistthealgorithm in inferring conclusions about motifs and their causal and temporal relationswith a synchronousevents.
next our approach eliminates low level details included in the raw trace such as auxiliaryevents low levelandlibrarymethodcalls andframeworkspecificdetails.theprunedtraceisthenusedastheinputtothealgorithm.
note that our method is non intrusive and preserves the original behaviour of the application under investigation.
algorithm for inferring motifs in this section we propose our algorithm for detecting motifs in ordertocreate ahigher levelmodelof behaviour.we definemotifs asabstract andhierarchical sequencesoffunction executionsthat recurthroughoutthelifetimeofanapplication.whileeachmotif eventuallysupportsconcretesequencesoffunctionexecutions itisbynatureacompositeelement andcanrepresentmorecomplicated structures.
we define a motif as an ordered set of two or more members m0tomi whichinclude motifs abstractentities andcontext sensitivefunctionexecutions.theconfidenceofamotifineachofitsmembersisrepresentativeofthemannerthatmember is observed within different executions of the motif and is shown asc0tocifor all motif s members respectively.
m angbracketleftm0 c0 angbracketright... angbracketleftmi ci angbracketright i mi function execution sub motif abstract entity our approach draws the attention of developers to the main observed motifs presumed to represent highlights of behaviour preventing their view to be obstructed by low level details.
the underlyingmodelstillpreservesdetailsthatcanbedemandedby users as necessary.
.
inspiration from analyzing biological sequences in designing the algorithm we were inspired by bioinformatics where there is a constant need to explore compare and analyze largedatasequences.mostrelevanttoourapproachare sequence alignment algorithms which find similarities in sequences of dna rna andproteinbyarrangingandcomparingthem .webegin ourcorealgorithmbyusingaheuristicforfindingexactmatches betweentracesequences.forcomparisonofthetracesequences weadapttheideaofblast basiclocalalignmentsearchtool alocalsequencealignment algorithmwhichwemodifytofitthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. alimadadi et al.
k 2k expandedbaz.
..db traces exact match occupationvalidateemail checkaddress bazbar foo bar submit barindes.html removepopupchange showpopupchange transition grouped stacked foo bazoccupationvalidateemail checkaddressfoo barquery trace studentform submit bar change transitionexact matcha b ... ... ... figure4 this figuredepictsadboftraces a andasample query trace b of an application on the left and right side respectively.
exact matches of length and between thequery trace and different db traces are marked.
domain of execution traces.
we then expand the matches by maximizingsimilaritiesintheirneighbouringentitiesinthetraces.this phase is accomplished using a dynamic programming algorithm in order to allow more flexible and more abstract motifs.
throughout this process our method infers existing motifs and reveals their relationsandhierarchies.inthissection weusealgorithms1 and figures to explain our algorithm.
our algorithm takes theapplication app anditsknowledge base db asinputand returns the extracted motifs as output.
please note that we have eliminated and or merged many details for the sake of brevity.
the details can be found in the repository of our open source tool .
.
forming a knowledge base our algorithm requires a knowledge base of multiple previous executions i.e.
a set of traces named database db traces db whichcaninitiallybecollectedbyexecutingthetestsuite crawling orexploratorytestingandexercisingtheapplicationmultipletimes.duringeachinteractionsession ourapproachcollectsatrace called thequery trace q which will be analyzed and compared against all db traces for finding its motifs.
each query trace is itself added tothedbtracesafterthealgorithmisfinished.thispartisdepicted inlines2 4ofalgorithm1.partsaandboffigure4displaysample db traces and query trace of the running example figure .
.
finding exact matches next thealgorithmfindsalltheexactmatchesoflength kbetween thequerytraceandthedbtraces.westartbymatchesoflength function pairs .
we then increment the length of exact matches iteratively and repeat the search at each iteration until we have found all exact matches.
two sets of exact matches of length 2and are shown in figure between db traces part a and the query trace partb .
lines of algorithm iterateoverthe query trace for finding matches of length k and increment kat each iteration.
lines show that subsequences of length kare extracted from the query trace at each iteration and are compared against all k length subsequences of all db traces to find matches.
.
allowing abstraction in motifs inthenextstep weexpandeachmatchtoprogresstowardsfinding flexible and abstract motifs that are tolerant of small alterations.
this technique decreases dependency on specific execution details algorithm finding exact matches and expanding them procedure extractpatterns app db app application under analysis db algorithm knowledge base db traces modifiedapp instrument app rawtrace intercept modifiedapp q prune rawtrace k motifs fori k i q.length i do forj j q.length k j do subq extractsubtrace k q i j matches exactdbmatches db i subq form matches.length m do forn n matches .length n do dir initialexpansiondirection i qi startqiend dbistartdbiend ifexpandable q db ithen subdb matches expandedq q.expand sub q iq dir expandeddb db .expand sub db idb dir dir direxpansion toggle true db q i k.increment motif compare expandedq expandeddb k matches.push motif k motifs.add motif i adjustexpansionindices dir end if end for end for end for end for returnmotifs end procedure providesahigher leveloverviewofthesemanticsoftheapplication andpermitsflexiblemotifsofvariablelengththatmayincludegaps.
atthisstage ouralgorithmiterativelyperformsthefollowing steps.first itselectstwomatchesfromexistingmatches which were determined as the result of previous step figure .
then ititerativelyexpandsthequeryanddbmatchesfrombothdirections whilegraduallyincrementingthelengthofthemotifunder investigation lines of algorithm .
figure also shows an expanded match of two different sequences for measuringtheirsimilarities figure4.a .thisphasecontinuesuntilthe accumulated penalty of gaps interrupts expansion of the motif.
next thealgorithmfindsa sequenceofthosematchesthat have the maximum similarity.
at this step we adapt a dynamic programmingalgorithmcalled smith waterman forfindingpatterns in two molecular sequences .
this algorithm quantifies the sequencealignmentprocessbyassigningscoresformatchesand mismatches and penalties for gaps.
aligned sequences are then foundbysearchingforthehighestscoresinscoringmatrices.to adapt this algorithm to our domain and compare similarities oftwo traces we propose a similarity matrix that determines the similarityoftwomembersintraces.thesimilarityofthetracesare determinedbyacombinationofsimilaritiesofalltheirmembers based on a dynamic programming heuristic.
similarity matrix.
we propose a similarity measure for quantifying the similarities between function executions in traces.
our comparisonis basedontwo metrics functionnamesand parameters.
we devise three scores for comparison strong match weak match and mismatch leading to a carryover penalty .
if two functionsmatchintermsofnamesandparameternumberstheyarea strong match.
the match is weak if only the names are equal and not parameter numbers .
the reason for considering parameter authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
inferring hierarchical motifs from execution traces icse may june gothenburg sweden submit expanded match submitstudentformoccupationcheckaddres svalidateemail db tracedbtrace validateemail checkaddress occupation submitquery tracevalidateemail checkaddress occupation submitsubmitstudentformoccupationcheckaddres svalidateemailquery tracequery trace db trace occupationvalidateemail checkaddress submitoccupationvalidateemail checkaddress studentform submit dbtracevalidateemail checkaddress occupation submitsubmitstudentformoccupationcheckaddres svalidateemailquery trace submitstudentformoccupationcheckaddres svalidateemail dbtracevalidateemail checkaddress occupation submitquery trace su nooccupationvalidateemail checkaddress abstract a c db ef match?
pattern figure5 thisfigurebrieflydepicts a theprocessoftaking twoexpandedtracesubsets b c formingascoringmatrixbased on similarities between sub traces and d e findingamatchinmannerthatmaximizesthesimilaritiesbetweensub traces.
the final motif can be seen in f .
countasaseparatemetricisthenatureofjavascript whereafunction call does not need to be faithful to the function signature in terms of arguments known as function variadicity .
two function executionsdonotmatchifbothmetricsaredifferent.thestrong andweakmatchesareassignedpositivescores whilethemismatch is assigned a negative score as it can represent gaps in the motif which can accumulate and disrupt a motif.
the base scores for matches and penalties are determined using empirical data.
moreover our matrix needs to support comparison of motifs to accommodateanotherextensionoftheoriginalalgorithm which permits hierarchies between motifs.
the function execution members of a motif are compared as explained above.
should a motif containanabstractnode thenallvalidexecutionsoftheabstract nodeshouldbecomparedwiththeothersequence.throughoutthe processof comparingmotifs our algorithminfers hierarchiesand abstractions of motifs should they exist as explained below.
then we perform our adaptation of the smith waterman algorithm on the two expanded sequences as shown in line of algorithm which creates a scoring mechanism for comparing thetwosequencesbasedonaone by onecomparisonofalltheir entities based on our similarity matrix.
the result is a scoring matrix of overall scores of comparing two sequences mk k .
this processis shown forthe two sequencesof the runningexample from the previous step in figure .a c. to find the common motif in these sequences we find the sub sequences that hold the highest collective similarity as a group.
we start by finding the highest score in the matrix line of algorithm figure .d and then trace the matrix back determining the aligned motif at this stage lines figure .e .
for navigating the motif back in thematrix ourdynamicprogrammingalgorithmchoosesthemaximumneighbouringscoreateachstep line5 .basedontheselected neighbour thealgorithmdetermineswhetherthatmotifmember comes from one or both of sequences and whether an abstract entityshouldbeinjectedtoshowdifferentalternativesofthemotif.
themotif sconfidenceinthatmemberisthenupdatedbasedonalgorithm inferring motifs procedure compare s1 s2 k s1 s2 two trace sequences k sequence length mk k smithwaterman s1 s k angbracketleftbig imax jmax angbracketrightbig maxscorelocation mk k whileimax andjmax 0do dir maxneighbour i max jmax ifdir diagthenmotif.insert abstract s1 s2 elsemotif.insert function s1 s2 end if angbracketleftbig imax jmax angbracketrightbig backtrack mk k s1 s2 dir end while ifs2.type motifthenbuildhierarchy s2 motif end if returnmotif end procedure how it is selected lines of algorithm .
the inferred motif of therunningexample figure5.f hasfivemembers oneofwhich isabstract.theabstractmemberwasadvisedtoenablethemotif to support both sequences shown in figure .a which have the same functionality registration but are executed in a slightly different manner.
the abstract member demonstrates that observing thestudentform functioninthemotifisarbitrary andthemotif caneitherbeobservedeitherwithfivetotalmembersincludingthe function orwithonlyfourmemberswhichdonotincludefunction.
.
inferring hierarchies of motifs inthenextstep wedeviseanotherextensiontotheoriginalalgorithm whichenablesustoinferandrevealhierarchicalrelations between motifs.
by definition our motifs are composite entities which can contain other motifs as their members.
during the analysis our algorithm mayencounter cases where the matchthat isbeingcomparedisamotifitself and theexpansionleadsto discovery of a new motif.
in such cases a hierarchical relation is addedbetweenthetwomotifs.thismeansthatnotonlythe sub motif was observed independently within the execution but it also contributes to the formation of the new and larger motif.
our analysis follows a bottom up approach starting with function executions as building blocks of the trace.
it iteratively works the way up to higher level and more abstract motifs that allow flexibilityin execution.
at each iteration of the algorithm new motifs can be revealed which may have hierarchical relations with existing motifs.
as such motifs emerge our algorithm captures the process of their formation and hierarchies in a model section .
in the running example we first find an exact match with k which is a motif itself but with no abstraction figure .
later duringexpansion wefindthatthismotifisamemberofalarger motif figure .f with two other members an abstract member and a function execution .
the algorithm creates a hierarchy line 11of2 whichthenmanifestsinthemodel figure6 asanedge from the new abstract motif node to the sub motif node .
creating and visualizing the model in this section we explain our methodology for inferring the hierarchical model of behavioural motifs and visualizing it.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. alimadadi et al.
vertices pattern functionabstract dependentexclusive attributeweak strongregistration validateemail checkaddress occupation submit studentformclick1 8hierarchy abstraction edges4 figure sample model of the running example.
the root node is the highest level inferred motif.
node is a sub motif of node marked by the hierarchical edge betweenthe two.
node is abstract allowing variations of its childnodetooccurinthemotif.theleavesof nodes4 arecon crete function executions in the trace.
.
creating the motif model asmentionedabove duringtheprocessofextractingmotifs our approach infers the hierarchies and other potential relations be tween them.
such structural relations are preserved in a model represented as a directed acyclic graph dag which evolves as the algorithm proceeds as explained below.
vertices.
verticesofthegraphcanbefunctions motifs abstract entities ordependentvertices.
functionverticesareatomicnodes representing specific and context sensitive function executions.
motifvertices are semantically composite classes.
each motif conceptually contains an ordered set of its members.
abstractvertices arethemodel smeansforsupportingflexibilityinmotifs.should there be alterations in different observations of a motif an abstract node is used for accommodating all valid cases.
dependent vertices hold additional attributes of other types of vertices.
and exist only to provide more information about other vertices.
e.g.
an event contributingtoafunctionexecutionisshownasadependentvertex.
edges.theverticesofthegraphareconnectedthroughdirected andorderededges.theedgesareresponsibleforconnectingmotifs to their members.
the direction of an edge is from a motif node to its members which are orderedbased on the time they were observedintraces.theedgesalsorepresentthe confidence ofthe algorithm in the respective member strong or weak based on the manner of observation of the member.
edges may contain other specialattributes dependingonitstypeandthepurposeitserves in the model.
for instance the edge exclusion property is used to show that only one of the variations of an abstract node is valid at a given time.
figure6representsthemodeloftherunningexampleoffigure1.
therootofthedag node1 isamotifrepresentingregistration.it consist of three members a sub motif an abstract node and afunctionexecution .thefirstmemberisamotifitself which contains a sequence of three functions from the trace marked .
thestrongedge to the sub motif and from there to its children shows the high confidence of the algorithm in the sub motif.
node is an abstract node acting as a place holder for valid versions of the node manifested in its children.
this node exists due to the variation in two observations of the motif figure .a .
in the case ofourexample the exclusivetypeofthechild edgedemonstrates ab e dc db motifs figure a screenshot of visualization.
a query trace.
b inferred motifs depicted on the table.
c motifhierarchies.
d allmotifs.
e codepaneldisplayingselected function motif code.
that occurrence of this node is optional in the motif studentform is observed or not .
further the weakedge type displayed the algorithmlowconfidenceinthisnode.node8 thefinalmemberof is an execution of function submit.
all leaves of the dag are concrete function executions from the trace.
nodes at higher levels of a graph involve abstractions and hierarchies to represent the incremental process of emergence of motifs from details of trace.
motifrelations.
thehierarchiesthatformbetweenmotifsare one type of relations that are preserved through the model.
thealgorithmalsodiscoversothertypesofrelationsbetweenmotifs such astemporal orcausalrelations.
the integration of all these relations depicts how semantics of the program are shaped from bottom small specific motifs to the top larger and more abstract motifsrepresentingkeypointsofbehaviour .themotifsmaybe semanticallyrelatedinmannersthatarenotquiteobviousfromthe code.
for instance motif m1maycausemotifm2 or they may be ordered but not dependent due to the design and the architecture ofthe system.queryingthe modelallows ustorevealpatternsof motifsthemselvesandevendiscoverpatternsthatarenotknown tothedeveloper arecreatedunintentionally orareimposedonthe system by other factors such as third party frameworks.
.
visualizing the model finally wevisualizethemotifstofurtherassistprogramcomprehensionbytakingadvantageofinformationvisualizationtechniques.
our web based visualization provides twomain views for displaying the motifs recorded in a specific query trace and all motifs discovered in the behaviour db traces .
trace motifs.
to allow developers to focus only on a part of behaviour that is of interest to them this view displays motifsthat are found within the query trace freshly recorded from aninteraction session figure a and b .
section a of the figure displays thepruned query trace wheretime proceeds from topto bottom.section b displaysthemotifs distinguishedbycolourand index.
the saturation of each cell of a motif displays the motif s confidenceinthatmember.eachmotifmayrecurmultipletimesin the same trace or may contain hierarchies of motifs figure 7c .
allmotifs.
thesecondviewismeanttoprovideaglobaloverview ofapplicationbehaviourbydisplayingallitsmotifs extractedfrom all db traces figure 7d .
these motifs may display system use cases feature implementations or other higher level sequences authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
inferring hierarchical motifs from execution traces icse may june gothenburg sweden thatsomehowdescribethefunctionalityofthesystem.theydonot conform to a single trace and thus each motif has its own separate trace.
in both views hovering the mouse over each entity displays moreinformationregardingthatentityinthetooltip.clickingon anentitydisplaysitsrespectivecode functionormotif onthecode panel figure7e .displayingonlythecoderelevanttothemotif allows developers to only focus on their specific task without the added burden of understanding the whole application.
implementation sabalan weimplementedourapproachin anopen sourcetool calledsabalan.
the entire tool is implemented in javascript.
we create our ownexpress.jsserverfor implementingthealgorithm theinstrumentationunit andthevisualization.wedevelopthebioinformaticsinspired algorithms from scratch for execution traces.
we use a proxytoautomaticallyinspectapplications .forinstrumenting thecode wecreateanastofthecode modifyit andserializeit back into javascript .
sabalan is publicly available .
evaluation we empirically evaluate our approach by investigating the characteristicsoftheextractedmotifs aswellastheusefulnessofour approach for developers and its overhead through the following research questions.
rq1.what are the characteristics of typicalmotifs inferred by sabalan from execution traces?
rq2.does using sabalan improve developers performance for common comprehension tasks?
.
motif characteristics to address rq1 we performed our analysis on seven javascript applications listed in table .
design.we selected seven open source javascript applications fromgithub .theseapplicationscovervarioussoftware domains and were selected based on their popularity and usage.
basedoneachapplication sspecifications weselectedamethodfor collectingitstraces runningthetestsuiteordesigningscenarios for exploratory testing .
we provided the traces db and query as input and analyzed their extracted motifs and investigated their main characteristics.
we measured the number of unique motifs inferredfromalltracesforeachapplication calculatedtheirlengths and analyzed their hierarchies.
we registered the size of db traces in terms of number of different traces as well as the size of a trace.
results anddiscussion.
the resultsof the analysisare depicted intable1.thesecondcolumndisplaysthenumberoflinesofcode foreach application while thethird columncontainsthe number of motifs found in the applications.
the next column representsthe number of db traces collected for each application.
column five shows the average size of traces of each application collected by sabalan in one minute interaction sessions.
note that our tool performsaleveloffilteringwhileloggingexecutiondetails.columnsixshowstheaveragetracesizecollectedbygooglechrome sjavascript profiling and timeline.
it can be seen that the average trace sizeusingsabalanis77kbs whilewithoutsabalanthereisan average of96 mbsofdata forthe sameinteraction session.these values emphasize the extent of the information contained in thetable characteristics of traces and inferred motifs motif length application loc of m. of dbtrace size kb raw trace mb avg min max o funqh.
phormer same game simple cart browserquest adarkroom doctored.js hextrix average .
raw traces even for modest sized applications which makes it challenging for developers to analyze them.
however using ourapproach developers have an average of recurring high levelmotifs for each interaction session each with an average lengthof columns to guide them through the understanding of the behaviour.
the last column displays the number of unique hierarchicalrelationsbetweenuniqueinferredmotifs.thenumbers show the existence of hierarchies of motifs.
further assessment ofthestructuresofmodelgraphsdepictthebottom upformation of higher level key points of behaviour based on smaller motifs through such hierarchies.
thereareafewcasesintheresultswherethealgorithmwasnot able to find many meaningful motifs or any hierarchies.
upon further investigation we found that these applications rely heavily on external and graphic libraries which we had disabled in our analysis.
these features can be activated in the future if needed.
animportantfactorthatcanimpacttheefficacyofthealgorithm is therequirements of the db traces.
the number of initial traces in the knowledge base their coverage of the application s functionality andtheirsimilarities ordifferences arefactorsthatcanimpact the quantity and quality of the final motifs.
we aimed to maximize the features we covered with the db traces.
we stopped collecting new db traces when we observed that adding a trace did not affect the inferred motifs average of .
db traces per application .
.
controlled experiment next we conducted a controlled experiment to assess the effectivenessofourtechniquefordevelopersinpracticeandaddressrq2.
we divided the participants into control and experimental groups.
theexperimentalgroupusedourapproach whilethecontrolgroup usedthetooloftheirchoice.theparticipantsaccomplishedaset ofcomprehensiontasks andtheirperformancewasmeasured.the tasks were designed based on common software comprehension activities .wedefinedtheperformanceofadeveloperbythe combination of time and accuracy of completing the tasks.
our hypothesiswasthatusingourapproachwouldenhancedevelopers performance in understanding the overall behaviour main use cases and recurring motifs of a web application.
.
.
experiment planning.
the goal of our experiment is to investigate the following research questions.
rq2.
.does using sabalan decrease task completion durationfor common comprehension tasks?
rq2.
.does using sabalan increase task completion accuracy for common comprehension tasks?
rq2.
.issabalanbettersuitedforcertaintypesofcomprehension tasks?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. alimadadi et al.
table comprehension tasks used in the study.
task description activity t1.a understanding all common usecases a1 a7 a9 t1.b determining the most used scenarios a6 a7 t2.a locating the implementation of a feature for reuse a1 a3 t2.b estimating the quality of said implementation a4 a5 a8 t3 understanding the addition of a new feature a1 a2 a3 variable selection.
our design involved one independent variable iv the variable we controlled which was the type of tool used i.e.
anominalvariablewithtwolevels.werefertothefirstlevel as sabalan since they had to use our tool.
the second level representedusage ofothertools whichwerefer toasother.our goal wastomeasuredevelopers performanceincompletingthetasks.
we quantified it using two variables task completion durationand accuracy bothcontinuous thatwereour dependentvariables dv .
selectionofobject.
we chose phormer photo gallery application as our object which has about lines of code and over downloads.
it is an open source php based application that allows users to store photos categorize and rate them and view aslideshow.sincewehadallocatedlimitedtimeforeachsession we had to choose an application that is simple and yet exhibits realistic motifs in its behaviour these criteria are met by phromer.
selection of subjects.
we recruited participants for our experiment.
they were all graduate students in computer science and engineering and many of them had professional software devel opment experience.
the participants consisted of females and males aged between and .
knowledge of programming and familiarity with web development and particularly javascript wereouronlyrequirementsforpickingtheparticipants.overall ourparticipantshad1 10yearsofwebdevelopmentand1 18years of software development experience respectively.
experimental design.
ourexperimenthada between subject design.toavoidthecarryovereffect wedividedourparticipants into two groups.
the experimental group were given access to sabalan for performing the tasks while the controlgroup used googlechrome sdevelopertools i.e.
devtools forcompleting the session.
all our participants were familiar with devtools accordingtotheiranswerstothepre questionnaireformandchoseto useitduringtheexperiment.nomemberoftheexperimentalgroup were familiar with sabalan prior to the study session.
to avoid bias in favour of one of the groups in terms of their proficiency levels wecollectedhistoricaldataaboutourparticipantspriorto schedulingthesessions.weassignedeachparticipantaproficiency score basedonacombinationofmetrics includingtheirexperience withsoftwaredevelopment knowledgeofjavascript andhowthey perceived theirown expertise.
we balancedthe proficiency levels in both experimental and control groups.
experiment tasks.
wedesignedfivecomprehensiontasks outlined in table based on common program comprehension activities proposed by pacione et al.
.
as the name suggests these activities representfine grainedactivities thatdevelopers needto performforunderstandingsoftware regardlessofthelanguageand the platform used.
table shows how each of our tasks covers one ormoreactivities allactivitiesarecoveredinourdesign.moreover each task also included a mini questionnaire which asked about howparticipantsperceivedthedifficultyofthetask therequired accuracy t1a ctrl t1a exp t1b ctrl t1b exp t2a ctrl t2a exp t2b ctrl t2b exp t3 ctrl t3 exp total ctrl total exp figure notched box plots of accuracy results.
green plots display experimental sabalan group and gold plots display the control group.
higher values are better.
time andthe requiredexpertise levelfor accomplishingthe task.
we have made all the tasks and datasets publicly available .
.
.
experimental procedure.
the procedure of the experimental sessions consisted of three main phases.
pre study.
werequiredallparticipanttofillapre questionnaire form to gather some demographic data about them.
further weusedthedataregardingtheirexperience programming habits andself perceivedexpertiselevel toassignparticipants expertisescores.thescoreallowedustofairlybalance theexpertiselevelsinbothexperimentalandcontrolgroups.
training.
atthisstep theexperimentalgroupweregiven a tutorial on sabalan which they were encountering forthe first time.
then both groups were given some time tofamiliarize themselves with the setting of the experiment.
we then started the tasks when the participants were ready.
tasks.duringthisphase theparticipantscompletedthefive comprehensiontaskssummarizedintable2.basedonour design wewantedtomeasureboth durationandaccuracy of completing the tasks.
to measure time we prepared each taskonaseparatesheetofpaper.westartedatimerwhenwe handed atask sheetto aparticipant and askedher toreturn itto us withthe answer assoon asshehad completed the task whichiswhenwestoppedthetimer.thisallowedus torecordthetimetheyspentoneachtask.weevaluatedthe accuracyofeachtasklater basedonrubricswehadprepared prior to conducting the experiment.
moreover we wanted to gather some data regarding how theparticipantsperceivedthetasks.thus weprovidedthem withasetofmetatasks thatquestionedthemabouttheperceiveddifficulty time consumption andrequiredexpertise level for each task.
finally the participants filled a postquestionnaire form regarding their experience in the study.
.
.
results.
wefirstrantheshapiro wilktestonallcollected datasets todetermineiftheywerenormallydistributed.fornormally distributed data of accuracy we used two sample t tests.
the duration data did not pass the normality test and thus we used the mann whitney u test for it.
fortheaccuracy theresultsofrunningthetestsshowedasignificant difference with a high confidence for the experimental authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
inferring hierarchical motifs from execution traces icse may june gothenburg sweden group using sabalan mean .
stddev .
compared tothecontrolgroupusingchromedevtools mean .
stddev .
p value .2e .theaccuracyresultsareshown infigure8.
overall usingsabalanincreaseddevelopers accuracy in performing comprehensiontasks by an average of54 over other tools.
rq2.
.
we further analyzed the impact of using sabalan in accuracy of individual tasks.
the results of running the statisticaltestsshowedsignificantdifferenceinfavourof sabalanfor all tasks expect t3.
the accuracy of results of t1a through t2b weresignificantlyhigherusingsabalan.theresultsfortaskt3 although not statistically significant were on average more accurate when participants used sabalan.
for the times the collected task completion duration data were comparableforparticipantsofbothexperimentalandcontrolgroups.
running thetests did notreveal any statisticallysignificant difference in task duration between the two groups rq2.
.
finally we analyzed the collected data from the questionnaire form participants filled regarding each task.
they perceived the difficulty of tasksfrom2.15to2.
basedona5 pointlikertscale whichshows an average level of difficulty for all tasks.
we compared the difficultyofeachtaskasperceivedbyparticipantswiththeresultsof durationandaccuracyofthesametask.wefoundnocorrelation between the perceived difficulty ofa task by participants and how they perform the task using the pearson correlation coefficient .
.
discussion the results of the experiment revealed that sabalan improves developers performanceincomprehensionbysignificantlyincreasing their accuracy by rq2.
.
the results however did not show a significant difference for duration rq2.
.
domain knowledge and use cases.
one of the first steps towardsprogramunderstandingisgeneralunderstandingofitsdomain and overall dynamic behaviour by identifying the components that provide a solution to the domain.
our results show that sabalan significantly increases the accuracy of such tasks t1 .
this task consisted of two main parts understanding the overall behaviour and use cases of the experimental object t1.a and decidingontheirimportance t2.b .usingsabalansignificantly improvedtheaccuracyofthesetwotasksby49 and78 respectively.
the results show that using sabalan not only provides a more accurate overview of an application s behaviour comparedto ad hoc approaches but also helps developers obtain a betterunderstanding of the importance and usage of the main system components and their interactions rq2.
.
feature location.
feature location is one of the main tasks performedduringprogramcomprehension andhasmanyapplications suchasreuseandtesting.ourresultsshowthatusingsabalansig nificantlyimprovedtheaccuracyoffeaturelocation rq2.
rq2.
.
the experimental group were able to find components involved in the implementation of a feature and infer their relations more accuratelythanthecontrolgroup t2.a .theywerealso42 moreaccurateinestimatingthequalityoftheimplementationofthesaid feature t2.b .investigatingtheanswersrevealedthatthecontrol group missed many connections in the code that lead to discovery of different parts of the implementation and thus failed to create acompleteandaccuratemodeloftheinvolvedcode.duetotheirincompleteunderstandingofthefeature thecontrolgroupwasnot abletoestimateandmeasurethe qualityoftherespectivepartof application as well.
the experimental group however could assess thequalitybasedonthemoreaccuratemodelofthebehaviourthat extracted the feature as a behavioural motif rq2.
.
softwarechangeandroot causedetection.
thelasttask t3 involvedunderstandingthesysteminordertomakeachange by findingtherootcauseofaparticularobservedbehaviour.theexperimentalgroup wereableto performthetask moreaccurately withsabalan althoughtheresultswerenotstatisticallysigifnificant rq2.
.using sabalan theywereable to focuson a much smallerpartofthecodethatwasrelevanttothefeaturethatneeded change.however becausewedonothavedebuggersupportwithin sabalan using common debugging techniques such as setting breakpoints and watching variables in such tasks required the participants to frequently switch between the visualization and theapplication.
we plan to integrate our prototype with a debugger such as chrome devtools in the future.
accuracy over speed.the results did not show any significant difference for task completion duration in favour of sabalan.
we believe this is not a significant issue due to three reasons.
first accuracy of performing a task is mor e important than its speed .
the significant improvement of task completion accuracy with sabalan and the test s high confidence in the result em phasize the challenges of comprehending traces as well as the usefulness of sabalan in improvingdevelopers performance for completing said tasks.
investigating the answers further we found that many participants in the control group had finished the tasks assuming they had the right answers.
while in fact they were not evenawarethattheyaremissingcrucialpartsoftheanswer which resulted in them having lower accuracy than sabalan users.
next we believe that the unfamiliarity of our participants with sabalan mighthavecausedthemtospendmoretimetryingtouseit.this theory is strengthened when we analyze individual tasks results.
weobservedthattheexperimentalgrouphadtheworstspeedratio compared to the control group for the first task t1.a after which theyquicklyimproveandsurpassthecontrolgroupinlatertasks.
finally dividing the locus of attention may have also played a role intheresults.whilethecontrolgrouponlyfocusedonthebrowser thesabalangrouphadtoswitchbackandforthbetweentheapplication and the tool.
we believe this can be solved by extending the tool or integrating it into an existing programming environment.
participants perception of tasks vs. performance reality.
therewerenocorrelationsbetweenthedifficultyofataskasperceived by participants and their measured performance scores.
all participants deemed all tasks to be of moderate difficulty.
however the control group scored significantly lower accuracy marks for all tasks.thisshowsthattheirinterpretationofthetaskrequirements didnot matchthe realityof thetaskthey hadjust performed.the results confirm the challenging nature of trace comprehension.
performance overhead.
we used the experimental object of our userstudy phormer toobtaindataregardingtheadditionaloverhead of our approach in one minute interaction sessions.
we measured three sources of potential performance overhead into account.
the overhead caused by instrumentation phase the imposed overhead on execution of instrumented code and data collection authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. alimadadi et al.
and the overhead of analysisof traces and motif extraction which were respectively measured as .
.
and .
seconds on average.
thisisnegligibleforallpracticalpurposes andisbarelynoticeable during the interaction with the application.
thus the performance overhead of sabalan was entirely acceptable for this application.
.
threats to validity theexternal threats ofconducting anexperiment suchas ours typicallyarisefromrepresentativenessoftasks participants and object selected for the experiment.
we mitigated the threat of task selectionbydesigningourtaskssothattheycoveredallcommon comprehensionactivitiesinpacioneet.al.
whicharerepresentativeofroutinecomprehensiontasks.avalidconcernisregarding the representativeness of the participants of the developer population since we recruited students.
we tried to address this concern byrecruitingonlygraduatestudentswhohadpriorexperiencewith javascript many of whom had experience working in industry.
to address the threat of representativeness of the experimental object we chose an open source javascript application phormer with about lines of code and over downloads at the time of conducting the study.
an internal threat that concerns our method is the bias towards assigning participants into control and experimentalgroups orthepopulation selectionproblem which we addressed by balancing the expertise levels between the two groups.otherthreatscanariseduetothepossiblebiasoftheexam iner us regardingthemeasurementofbothdurationandaccuracy of task completion.
we mitigated the time measurement threat by designing a method for time measurement that both the participantandtheexamineragreedupon namelyphysicallyexchanging thetasksheetbetweentheparticipantandtheexaminer.wemitigated the bias towards measuring accuracy by creating a rubric prior to conducting the experiments and abiding by the rubric for markingthetasksinordertoaddressthisthreat.thefinalthreat we address is the tool used in the experiment.
we chose google chrome s developer tools which is very popular for client side webdevelopment andall our participantswere previously familiar with it based on the pre questionaire they filled out .
related work traceanalysisandvisualization.
severalpapersassistprogram comprehension through dynamic analysis and visualization.
their proposed techniques allow users to explore large traces or performreduction compactionandpruningtechniquesontraces .
a popular trend is using standard visual protocols suchasumldiagrams .othersproposemorecustomized visualization techniques through synchronized views provide program s landscape focusing on communications allow user interactions with the visualization visualize similarities in traces or present many other techniques for representing the traces .extravis isthefirstsuch technique that was quantitatively measured in a user study followedbyothers .anothergroupofmethodscaptureand analyzelow levelinformationintracesusingtechniquessuchas extracting behavioural units described in usecase scenarios profiling dividing the trace into segments identifying feature level phases by defining an optimization problem orsimilar methods .
heuzeroth et al.
propose to find patterns in execution.
others aim at providing higher level representationsoftrace .however unlikeourapproach these approaches do not infer a hierarchical behavioural model whichrevealsthekeypointsofbehaviour whilestillpreservingthe details and permitting users to navigate them on demand.
further ourapproachinfersabstractmotifs whichreducesthedependency of our analysis on details without losing the data.
featurelocation capture replay.
manypapershavefocused on featurelocation .
recordand replaytools aidunderstanding and debugging by providing a deterministic replay of ui events without capturing their consequences.
tracing techniques collect traces of javascript selectively.somepapersfocusonvisualizationforhelpingprogram understanding .
however these methodsare committed to preserving the exact sequence of events and replaying them.
their analyses do not permit abstraction of implementation details and inferring higher level motifs.
they are not concerned with creatingabehaviouralmodelandprovidingahierarchicaloverview of execution for assisting comprehension unlike our work.
specification mining.
assistingcomprehensionbyminingsoftware specifications from traces has been well explored .
many methodshaveassessed orimprovedtheperformanceofminers by pruning and clustering traces supporting equivalent states orfindinginconsistenciesinresourceutilizations .otherscomparedifferentmodelinferencetechniques synergize orcombinethem orfacilitatedeclarationofalgorithms .
other work uses markov models and analyzes them using model checking .
unlike our approach these techniques do not provide a hierarchical model of abstract recurring motifs of programexecution.specificationmininghasbeenimprovedwith novel use of object hierarchies .
however this technique only supportsexistinghierarchiesbetweenjavaclassesandpackages and not application specific motifs which are not defined or specifiedpriortoanalysis.unliketheseapproaches ouralgorithmallows our analysis to abstract out the low level details and tolerate small changes which allows recurring motifs of behaviour to emerge.
concluding remarks in this paper we proposed a generic technique for inferring a hierarchical model of application specific motifs from execution traces.
our motifs inspired by bioinformatics algorithms are recurring abstract patterns of execution that abstract out alterations and are closertothehigher levelfeaturesofasystem.wedesignedavisualizationforourtechniquethatallowsuserstoobserveandquerythe motifs for program understanding.
our technique is implemented in a tool called sabalan which is publicly available.
the results of ouruser experiment showedthat usingthe systematic analysis of sabalanenabledparticipantstoperformcomprehensiontasks more accurately than other state of art tools.