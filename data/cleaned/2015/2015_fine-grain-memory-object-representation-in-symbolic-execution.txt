fine grain memory object representation in symbolic execution martin nowack department of computing imperial college london uk m.nowack imperial.ac.uk abstract dynamic symbolic execution dse has seen rising popularity as it allows to check applications for behaviours such as error patterns automatically.
one of its biggest challenges is the state space explosion problem dse tries to evaluate all possible execution paths of an application.
for every path it needs to represent the allocated memory and its accesses.
even though different approaches have been proposed to mitigate the state space explosion problem dse still needs to represent a multitude of states in parallel to analyse them.
if too many states are present they cannot fit into memory and dse needs to terminate them prematurely or store them on disc intermediately.
with a more efficient representation of allocated memory dse can handle more states simultaneously improving its performance.
in this work we introduce an enhanced fine grain and efficient representation of memory that mimics the allocations of tested applications.
we tested gnu coreutils using three different search strategies with our implementation on top of the symbolic execution engine klee.
we achieve a significant reduction of the memory consumption of states by up to .
mean dfs bfs cov.
allowing to represent more states in memory more efficiently.
the total execution time is reduced by up to .
mean dfs bfs cov.
a speedup of 49x in comparison to baseline klee.
index t erms symbolic execution memory representation i. i ntroduction dynamic symbolic execution dse a method for analysing programs automatically gained traction recently due to its many applications.
it can be used for generating extensive test suites finding bugs automatically reverseengineering software or automating security analyses .
despite its many applications the two fundamental challenges remain the state space explosion problem and high constraint solving costs.
the former is due to a possibly infinite number of control flow paths through a tested application which makes it difficult to validate each path.
the latter arises with the constraints collected along each path.
as a path becomes longer the complexity of constraints increases so does its solving costs.
even though different techniques have been proposed to cope with the state space explosion problem like state merging or directed exploration of the state space a symbolic execution engine still needs to represent many states simultaneously in memory for efficiency.
each state mimics the memory representation of an application including allocated heap and stack memory at a specific moment of execution.1char x ... zero initialised 2char y calloc zero initialised 3int input symbolic symbolic input 4if input input x x else x x listing example of single byte modifications of larger objects the effective representation of the allocated memory of a tested application has received little attention.
with symbolic input the control flow can diverge if conditional branches depend on symbolic input values.
symbolic execution handles this by cloning the state branching to track control flows independently with constraint subsets of the input.
for example in listing the control flow at line depends on the value of input from line .
therefore the engine needs to follow the control flows independently either line or line .
each outcome will modify the array x line in a different way.
if for example the condition line is part of a loop dse will need to represent many slightly different copies of the state to reason about them.
handling a lot of states simultaneously can drastically increase the memory usage of a symbolic execution engine.
if the maximum capacity is reached states have to be saved or terminated prematurely .
copy on write techniques help to reduce the memory consumption i.e.
the same unmodified object y line will be shared between states.
if a state needs to modify an object x line it creates a copy of the object and modifies the copy.
however with dse changes can range from a single bit to a whole object.
with many states representing small changes in large objects the overall memory consumption can be high for a symbolic execution engine that tracks changes with object granularity and unmodified memory is duplicated.
in contrast a dse engine could track changes to memory in a very fine grain way e.g.
bytelevel which would lead to additional computational tracking overhead.
especially if a dse engine needs to execute many concrete but memory intensive instructions.
in this paper we introduce a layered representation of memory objects that can achieve a fine grain but efficient tracking of changes.
beside substantial memory savings we 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
also show how it improves performance.
our main contributions are a layered representation of memory which allows tracking changes efficiently including properties like the initialisation status of each byte different optimisations enabled by the layered representation an open source implementation on top of the state ofthe art symbolic execution engine klee a thorough evaluation of our contribution on gnu coreutils using multiple search strategies first we will introduce the different requirements that a memory representation in the context of symbolic execution needs to fulfil ii .
we continue with a detailed description of our approach iii followed by a description of our implementation based on the state of the art symbolic execution engine klee iv .
we then evaluate our approach v and finish with an overview of existing approaches vi and our conclusion vii .
ii.
o verview a. background we first recap how native applications handle memory allocations before we detail how symbolic execution mimics this behaviour of tested applications.
if we execute an application natively it will allocate memory of a certain size.
this can be either on the stack listing or dynamically on the heap e.g.
malloc calloc lst.
.
an allocation reserves part of free memory which can be referred to by its address addr .
using the address the application can both read from the allocated memory and write to it arbitrarily.
multiple writes into the same memory object will update it with the newest value e.g.
x x symbolic execution needs to reproduce the behaviour of an application.
for that it tracks the memory that an application has available and how it accesses it.
however with the many control flows that an application can have symbolic execution needs to represent a large number of states simultaneously.
this makes it hard to track the whole virtual address space e.g.
4gib for a 32bit for all states.
instead many state of theart symbolic execution engines only track the allocated memory and its accesses.
such an allocation can be represented as an array of data a and its associated metadata like size n domain d range r and also the base address of the allocation the address of the first byte of the allocated memory a v0 v1 ... v n with size nand i vi r i dand address base referencing v0.
symbolic execution mimics how an application writes to an address addr or reads from it in two steps first searching for 1we assume a memory model that follows sequential consistency i.e.
read returns the value of a memory location that was written last to it.
3init i.write ii.read iii.write sym1 sym1 iv .read sym2 sym1v.
write sym3 sym1 vi.read fig.
example of memory accesses of a byte object.
each row reflects the memory object after a modifying operation on it.
the right memory object a that is associated with the address addressing and second accessing that object accessing .
b. addressing memory object lookup for the lookup symbolic execution engines search through a list of memory objects associated with the current state to find the single object that is associated with the address addr .
in this paper we focus on languages that allow pointer arithmetic like c or c .
therefore the address might point inside of an object and not only reference it.
hence the object lookup will search for potential candidates by checking if the address addr is within the object s bounds with base as the first byte of the object addr base base width .
assuming that the address refers to a correctly allocated object to access the memory within that object the correct index is calculated by using the actual address and subtracting the base address index addr base .2if the dse cannot resolve an address to an object an out of bounds access has been detected.
in case the address is a symbolic expression dse branches the state for each memory object the address can be resolved to.
c. accessing memory object access if a native application updates a memory location it overrides the old value with the new one.
symbolic execution needs to model the same behaviour.
however in addition it has to cope with symbolic values.
that is the index orvalue that is written or read can be symbolic.
we summarise the different access combinations in tab.
i and will discuss them now in more detail.
as an example we assume the lookup of the memory object was successful and we got a reference to a byte memory object initialised with zeroes.
a concrete write with a concrete value will update this array e.g.
write .
reading from this array with a concrete index will return the latest value written e.g read .
if we write a symbolic value to a concrete index e.g.
write sym1 similarly we fill the cell at index with the value sym1.
things become more complicated and exciting with symbolic indices.
for example if we read from 2we assume that an allocation returns a non zero sized memory object if successful.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a symbolic index e.g.
read sym2 the returned value depends on the actual value sym2can be resolved to.
in our example assuming sym2is inbounds sym2 it can be v sym1.
similarly if we write to a symbolic index we do not know which exact location is modified e.g.
write sym3 this could potentially override any location.
this has an impact on all subsequent operations on this objects.
for example a read with a concrete index read can return more complex expressions e.g.
read .
there are two main observations first write operations modify the current state of an object second read operations return a snapshot of the current state of the object.
d. the impact of branching the implication for a symbolic execution engine is that it is not enough to manage memory objects with a byte wise representation similar to the native execution of the tested application which would be much faster .
however instead it has to be able to memorise arbitrary changes with symbolic indices or symbolic values.
for example if a native application updates a four byte array times the final size of the array will be four bytes.
for a symbolic execution engine this can be bytes plus times the representation of symbolic and concrete updates.
after a detailed look into handling memory accesses within a single state we want to focus on how state branching intensifies the problem.
while executing a state the symbolic execution engine might reach an instruction which depends on a symbolic value.
in that case the engine might be forced to follow different subsets of the values domain.
for that it will create copies of a state to be able to follow them independently which is often referred to as state branching .
the cause of the branch is either due to symbolic dataor control flow dependencies.
data dependencies result from a read or write operation that can resolve to multiple memory objects.
in case of control flow dependencies it can be either conditional control flow changes with the condition depending on a symbolic expressions e.g.
listing line or the control flow target can be a symbolic expression e.g.
dynamic function calls with a symbolic target call symbolic value .
following different control flows symbolic execution needs to validate them first by checking the branch condition against the collected path constraints.
it then follows the feasible path.
solving those queries can be computationally expensive.
if table i possible combinations of read write accesses of a memory object with symbolic concrete indices or values.
method index value example type type read concrete conc.
sym.
value read symbolic conc.
sym.
value read sym1 write concrete concrete write concrete symbolic write sym2 symbolic concrete write sym3 symbolic symbolic write sym4 sym5 concrete update list root3 idx val2 sym 2object state fig.
klee s simplified representation of a memory object and its object state with an update list.
multiple paths are possible symbolic execution branches the state which will create a copy of the state representation and add additional constraints that reflect one control flow.
equivalent to native execution during the lifetime of a state the state allocates many memory objects and the number of memory objects in a state can be significant.
to reduce performance penalties memory objects are not copied with each branch but referenced by each state copy.
if one of the states needs to update the values the object state is copied entirely copy on write and updates applied to the statespecific copy.
there is redundancy and wasted memory if the changes to an object in comparison to the object s size are small.
for applications that branch heavily these costs can be prohibitive.
e. memory representation in the state of the art symbolic execution engines to understand how state of the art symbolic execution engines handle memory we analysed klee an opensource symbolic execution engine for c and c .3we will summarise in this section how klee handles memory before we introduce our approach iii .
klee uses states that represent an execution path with all its allocated memory objects and path constraints.
an allocation is handled as a byte sized array by two entities amemory object and an object state .
the memory objects contain metadata like the address and the width of the allocated memory.
the object state contains the actual content of the memory.
if a tested application accesses reads or writes from an address klee looks up the memory object and the associated object state object state fig.
with it.
the simple case is when the index is concrete and the memory object has not been modified using a symbolic index before.
in this case a write can modify the object state in place.
and in the case that a memory object is shared between multiple states a copy of the object state is created and modified.
for read operations the specific value of the object state is used.
in the case an object was modified with a symbolic index klee memorises this update and all subsequent changes in a linked list update list with the most recent updates as the root of the list .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
if the memory object is shared new modifications are as simple as adding a new item to the update list that is only referenced by the modifying state.
the downside is that no update can be made in place.
instead every modification is added as a new entry to the list.
if objects are often modified with a concrete index and seldom with a symbolic e.g.
as it happens in tight loops a lot of memory is used.
for read operations klee creates a read expression that