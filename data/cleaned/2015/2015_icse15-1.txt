directfix looking for simple program repairs sergey mechtaev jooyong yi and abhik roychoudhury national university of singapore mechtaev jooyong abhik comp.nus.edu.sg abstract recent advances in program repair techniques have raised the possibility of patching bugs automatically.
for an automatically generated patch to be accepted by developers it should not only resolve the bug but also satisfy certain humanrelated factors including readability and comprehensibility.
in this paper we focus on the simplicity of patches the size of changes .
we present a novel semantics based repair method that generates the simplest patch such that the program structure of the buggy program is maximally preserved.
to take into account the simplicity of repairs in an efficient way i.e.
without explicitly enumerating each repair candidate for each fault location our method fuses fault localization and repair generation into one step.
we do so by leveraging partial maxsat constraint solving and component based program synthesis.
we compare our prototype implementation directfix with the state of theart semantics based repair tool semfix that performs fault localization before repair generation.
in our experiments with sir programs and gnu coreutils directfix generates repairs that are simpler than those generated by semfix.
since both directfix and semfix are test driven repair tools they can introduce regressions for other tests which do not drive the repair.
we found that directfix causes substantially less regression errors than semfix.
i. i ntroduction simple is better!
when repairing a program it is preferable to construct patches which are simple and readable.
this is because responsible software maintainers would not blindly accept a suggested patch rather they would review and inspect a patch carefully before accepting it which occurs only if they judge that the patch is correct i.e.
the bug is resolved and safe i.e.
no new bug is induced .
they would also modify the patch and add more tests if necessary.
thus simple and small patches would be more easily accepted by maintainers than more complex alternatives.
the ease of acceptance as well as abundance of small simple patches are confirmed by the studies of .
hence it is instructive to have program repair tools produce small patches.
to the best of our knowledge existing automatic repair tools such as genprog semfix and par do not explicitly take into account of the simplicity of a patch while generating patches although more general issues about patch quality e.g.
patch maintainability and users willingness to accept patches have been raised and studied in recent years.
finding a simple repair we use repair and patch interchangeably is not necessarily simple.
in fact it is challenging to find the simplest or a simple enough repair among many possible repairs without enumerating each repair.
note that even for finding one repair existing repair tools often take substantial amount of time.
we propose in this paper an efficient test driven repair method and its implementationdirectfix that can find simple repairs.
our repair method is test driven as in genprog semfix and many other existing repair methods.
our key observation is that the simplicity of a repair is influenced by the choice of the program location that is modified in a repair.
if unsuitable program locations are chosen to be modified the corresponding repair is also likely to be suboptimal meaning unduly complex repairs .
in the next section we show examples of such unnecessarily complex repairs.
existing test driven repair methods rely on statistical fault localization to choose program locations to modify often called fault locations in the literature .
in general fault locations are selected in proportion to their suspiciousness scores.
high suspiciousness scores are assigned to the program locations that execute more frequently in failing tests.
however the simplicity of repairs is not a part of suspicious score equations and thus these scores have no direct relationship with how simple a repair is.
to include the simplicity of repairs into the logic of choosing fault locations we perform fault localization and repair generation simultaneously in a combined manner.
the main intuition behind our approach is to a fuse the fault localization and repair steps into a single step via partial maxsat solving b ensure that the resultant fused method still remains scalable by using the buggy program as a reference we choose repairs which will cause minimal changes to the buggy program.
themain technical contribution of this paper is to integrate fault localization and repair generation in an efficient way without explicitly enumerating each repair candidate for each fault location.
we achieve this by reducing the problem of program repair into an instance of the maximum satisfiability problem more specifically a partial maxsmt problem .
for a given buggy program and a test suite we formulate a logical formula in a way that a model satisfiable assignment of this formula is the simplest repair simplest in the sense that the structure of the original buggy program is preserved as much as possible.
while the nature of maxsmt allows removing existing expressions of a buggy program our simple repairs are suggested at the expression level we can replace those removed expressions with new ones by using componentbased program synthesis .
we implement our approach into a tool directfix that formulates a necessary formula and solves it using our partial maxsmt solver implemented on top of z3 smt solver .
we also evaluate our tool on in total buggy versions of sir programs and real bugs of gnu coreutils which exemplify the mistakes programmers can1x e1 e1 represents an expression.
2y e2 e2 represents an expression.
3s1 s1 represents a statement.
neither x nor y is redefined by s1.
i f x y fault the conditional should be x y return 6else return a a buggy program snippet a bug is in line .
1x e1 y e2 2if x y s1 return this line is one possible repair.
3s1 i f x y return 6else return b a repair that resembles a genprog repair 1x e1 2y e2 3s1 i f x y simple fix is substituted for return 6else return c an alternative simpler repair an operator is replaced.
fig.
.
the first motivating example often make.
despite the limited size of our subject programs and tool limitations inherited from the underlying tools upon which directfix is built most notably vcc which transforms a c program into a logical formula currently cannot handle floating point arithmetic in such cases we designated the transformable suspicious functions assuming that developers have insight about potential buggy functions the overall experimental results are promising.
directfix suggests repairs successfully of the time.
moreover of those repairs are equivalent to the ground truth repairs and of them alter the same program line s as the ground truth versions.
such figures are significantly higher than when semfix is applied to the same subjects with the same test suites and the same information about suspicious functions i.e.
more than times of equivalent repairs and more than times of same line repairs .
recall that semfix performs fault localization and repair as separate steps and does not consider the simplicity of the repairs.
we also found in our experiments that directfix repairs cause regression errors when checked against the test universe and not just the test suite driving the repair less frequently than semfix repairs.
ii.
m otivating examples we present three simple yet motivating examples in this section in section vii we also present our repairs for actual programs .
consider the program snippet in fig.
a .
this program is supposed to return 0ifx y holds at the end of the program otherwise it should return .
however the developer of this program made a small mistake of not considering a case of x y .
here fig.
b and c show two different valid repairs.
notice that the former repair is more complicated than the latter one.
most developers would prefer the second simpler repair.
to the best of our knowledge existing repair1 i f x y fault the conditional should be x z i f x z fault the conditional should be x y out else out 6else out return out a a buggy program snippet bugs are in line and .
i f x y i f x z out else out 6else out return x z ?
x y ?
this line is one possible repair.
b a repair that resembles a semfix repair i f x z simple fix zis substituted for y i f x y simple fix yis substituted for z out else out 6else out return out c an alternative simpler repair operators and variables are replaced.
fig.
.
the second motivating example tools do not take account of how simple a repair is.
they stop looking for a repair once one is found no matter how complex that repair is.
indeed a repair in fig.
b resembles a repair generated by genprog .
genprog grafts existing code onto a buggy program in an attempt of repair.
as a result genprog often generates repairs that look nonsensical to human developers as pointed out in .
meanwhile a more recent repair tool semfix seems to generate simpler repairs than genprog user studies are yet to be conducted to fully validate this but intuitively this is so because semfix performs repair at the expression level unlike genprog that performs repair at the statement level .
however semfix still often generates repairs that are more complex than necessary.
fig.
shows such an example.
given a buggy program in fig.
a the first two lines are mistakenly swapped and the equal signs are omitted semfix can generate a repair shown in fig.
b .
compare this repair with an alternative repair shown in fig.
c .
the latter repair is simpler despite that it modifies two lines of a program semfix cannot modify multiple lines .
these two examples also show that a buggy program can be repaired in multiple ways producing repairs of varying simplicity.
there is one more important reason for selecting a repair carefully the reliability of a repaired program the likelihood that the repaired program not only resolves bugs in the given test suite but also does not introduce new bugs shown by tests outside the test suite varies depending on a selected repair.
consider a buggy program in fig.
a that checks whether the character cis included in the string character array s. the table in fig.
b shows the expected and actual input output relationship.
the first test fails because all the characters of string sare not scanned while looking for the same character as the one in c. notice in the table that variable kdoes not1 fault k is not equal to the length of array s. for i i k i i f s c return true return false a a buggy program that checks if the character cis included in string s. input output s c k expected actual ab?
?
true false ab?c ?
true true !ab !
true true b expected input and output for i i k i the following line is one possible repair.
i f c ?
c !
return true return false c a buggy repair that passes the above tests for i i k i simple fix is substituted for i f s c return true return false d a more reliable repair fig.
.
the third motivating example hold the value of the length of s it holds a value one less than the length.
as before more than one repair exist for this buggy program.
fig.
c and d show two possible repairs both repairs pass all the tests in fig.
b .
however the first repair fig.
c looks hazardous.
what if a character other than ?
or !
is searched for?
while such potential hazard of a repair can be diminished by choosing a right test suite what is a right test suite is another important research question that has not been thoroughly addressed yet.
meanwhile the second simpler repair fig.
d preserves the original correct behavior as well as correcting the buggy behavior.
the contrast between these two repairs suggests the following hypothesis.
the rationale behind the hypothesis is that simpler repairs are likely to modify the behavior of a program in a more restricted fashion.
hypothesis.
simple repairs are less likely to change the correct behavior of the original version than more complex repairs.
thus simple repairs are likely to be less hazardous.
existing test driven program repair tools perform fault localization upfront and search for a repair around the program locations marked suspicious at the fault localization phase.
therefore a straightforward way to find the simplest repair is to iteratively generate a repair at each combination of suspicious program locations and select the simplest repair.
however it is apparent that this straightforward approach would not scale considering the fact that even finding a single repair often takes substantial amount of time.
to find simple repairs more efficiently without explicitly enumerating each repair candidate we integrate the two phases of program repair i fault localization and ii repair search into a single step.iii.
b ackground directfix is a semantics based program repair approach that exploits recent advances of smt solvers.
it reduces repair problem to maximum satisfiability problem.
particularly this approach constructs a logical formula a solution to which corresponds to a fix.
our encoding is based on componentbased synthesis extended to produce syntactically minimal changes as well as to improve scalability.
a. preliminaries the satisfiability problem in propositional logic sat is the problem of determining whether a given formula has a model.
maximum satisfiability maxsat is a generalization of sat whose goal is to find the maximum number of clauses of a given formula that can be satisfied.
satisfiability modulo theories smt is a satisfiability problem with respect to given background theories.
maxsmt is a generalization of maxsat on smt.
partial maximum satisfiability pmaxsat for a set of soft clause sand a set of hard clauses his a problem of finding the maximum subset smax of clausess such thatsmax his satisfiable.
pmaxsmt is a generalization of pmaxsat on smt.
directfix utilizes program semantics expressed through a logical formula called trace formula in the literature .
definition trace formula .a trace formula tf of a deterministic program pis a logical formula that satisfies the following property.
given the input iof program p tf i o is satisfiable if the output of piso unsatisfiable if the output of pis noto where tf i o denotes the trace formula tfwhose input variable is bound with i and output variable with o. b. component based synthesis expressions and in general programs that satisfy given requirements can be generated automatically through component based synthesis cbs .
here we present the original cbs technique our extensions and optimizations are given in section v .
definition .
letvbe a variable vbe a set of variables such thatv 2v fbe a set of operators obe a constraint over fvg vcalled oracle.
component based synthesis v v f o is a problem of finding an expression esuch that eis constructed using a subset components c v f and constants o v e is satisfiable.
this approach constructs expressions by connecting primitive building blocks called components with each other.
components could be constants or variables or operators.
the correct linkage between components is determined using an smt solver.
specifically semantics of components semantics of the connections between them as well as the oracle constraint are used to construct an smt formula which we call componentbased encoding cbe .yout xy in out in 0xout 2l out l in l in l xout l yout l vin fig.
.
the inputs and output of the components of expression x y are allocated in the interval .
the output is bound by the variable v. the idea of cbe is to consider expressions as circuits.
each component has a set of inputs and an output.
then to synthesize desired expression the solver needs to find the right connections between components inputs and outputs.
in order to capture information about connections for each input and output a numeric variable called location variable is defined.
the meaning of location is straightforward an input and an output are connected iff they have the same location.
cbe defines relationship between values and locations of components inputs and outputs.
for each input and output we introduce a variable that corresponds to its value.
we use the following notation for component c the variable cout corresponds to the value of its output the variable cin kis the value of its k th input.
we indicate the number of inputs of casni c .
we denote location variables using the function l. for example the location variable of the first input of the component cisl cin .
fig.
demonstrates an example of an assignment of locations variables.
the components of the expression x y are allocated within the interval .
the output of the variable xhas location the output of the variableyhas location and the output of the operator is located at .
the first input of is linked tox the second input of is linked to y. assume that the output of the expression is bound by the variable v that isv x y .
the output of the circuit is marked by the bullet and is indicated by the constraintl vin .
the expression x y can be trivially reconstructed using the values of the location variables.
we assume that there is a function lval2prog that builds an expression from an assignment of location variables.
cbe consists of three types of constraints well formedness constraints semantics constraints andconnections constraints .
well formedness constraints wpf restrict location variables so that any satisfying assignment to these variables corresponds to an expression of a valid structure.
these constraints include range constraints range that allocate all components inputs and outputs within a range consistency constraints cons that ensure that the output of each component has unique location and acyclicity constraints acyc that forbid cyclic connections.
wpfdef range cons acyc rangedef c2fvg c l cout jcj k2 l cin k jcj consdef c s 2c c c6 sl cout l sout acycdef c2c k2 l cout l cin k semantics constraints lib are defined for each component.
they specify the semantics of the component as the relations between its inputs and output.
for example semantics constraint for the component ccorresponding to the addition operation is defined as cout cin cin .
semantics constraints for a component ccorresponding to a variable xis defined as cout x. similarly the semantics constraint for a component ccorresponding to a constant aiscout a. connections constraints conn capture the semantics of an expression to be synthesized through the semantics of the components and the connections between them.
conndef c s 2c fvg c k2 l cout l sin k cout sin k theorem .
letvbe a variable vbe a set of variables such thatv 2v fbe a set of integer operators ois a constraint overfvg v. wpf lib conn o is a componentbased encoding that is lval2prog produces a solution to the component based synthesis problem v v f o taking as inputv c v fand any model of as an assignment of the location variables.
described cbe is only suitable for representing oracle corresponding to a single test case.
indeed if we conjoin input output constraints for different test cases the formula is trivially unsatisfiable.
to extend this encoding for several test cases we rename variables in the encoding formula so that each test case uses unique variables names.
then the formula that captures all given input output relationships is a conjunction of renamed formulas for each test case.
iv.
o verview of our approach to find a repair we first translate a given buggy program into a trace formula.
for example fig.
b demonstrates the trace formula for the function fooshown in fig.
a .
this function is buggy and its test test foo fails we use a single test in this example for simplicity .
the given test is translated into the following oracle constraint odef x1 y1 result the conjunction buggy o is unsatisfiable reflecting the fact that the test fails.
our goal is to find which expressions of buggy need to be modified and how they should be modified so that this modified formula repair makes repair o satisfiable.
in our example the ground truth repair is as follows 1if there are multiple tests say two we formulate rename buggy o1 rename buggy o where function rename returns the input formula after replacing its variables with fresh variables.
int foo int x int y i f x y fault the conditional should be x y y y else y y return y 9void test foo assert foo a a buggy function and its test buggy if x1 y1 then y2 y1 else y2 y1 result y2 b the trace formula buggy forfoo variables xiandyicorrespond to the program variables x and y respectively and result to the return value of the program fig.
.
a trace formula is constructed from a buggy program and its tests repairdef if x1 y1 then y2 y1 else y2 y1 result y2 essentially our repair method views a program as a circuit.
to generate a fix it i cuts some of the existing connections and ii adds new components and connections.
to obtain the simplest the least destructive repair we want to cut as few connections as possible.
we achieve this by reducing the problem of program repair into an instance of the maximum satisfiability maxsat problem more specifically a partial maxsmt pmaxsmt problem.
to generate a repair based on pmaxsmt we construct a formula that we call repair condition .
given a trace formula buggy the repair condition rcis the following rcdef ifv1then y2 v2 else y2 v3 result v4 cmpnt v1 x1 y1 cmpnt v2 y1 cmpnt v3 y1 cmpnt v4 y2 the above formula rcis semantically identical with buggy.
the only difference is that we substitute fresh variables vifor the rvalue expressions of buggy while keeping the equality relationship between each viand the expression it represents e.g.
v1 x1 y1 inside the cmpnt function.
this function componentizes its parameter expression into a circuit form following the idea of component based synthesis.
to obtain the simplest the least destructive repair we use a pmaxsmt solver.
in pmaxsmt a formula is split into i hard clauses clauses that must be satisfied and ii soft clauses clauses that do not have to be satisfied .
in hard clauses we include the clauses that express the semantics of the component and the oracle data.
meanwhile with soft clauses we constrain the structure of the program expressions.
for example we construct the structure constraint for the expression x y as follows which is essentially equivalent to the circuit diagram in fig.
l in l xout l in l yout l out l vin in the above constraint we bind the output of the expression with a fresh variable v that isv x y .
as shown thisyout xy in out in in out in 1xout fig.
.
repairing expression x y by replacing with .
constraint specifies the connections between the components of the expression as well as its output binding.
after splitting rc ointo hard clauses and soft clauses as described above we feed rc o into a pmaxsmt solver.
then the solver removes some structure constraints if necessary and returns a model corresponding to a fix.
fig.
shows how a solver can modify the expression x y using an additional component in order to repair the program.
specifically it removes one connection between the outputs of and the input of vcorresponding to the structure constraintl out l vin and adds three new connections i between the output of xand the first input of ii between the output of yand the second input of and iii between the output of and the binding variable v. such new connections are obtained by using a model for the repair condition namely the values of the location variables.
we note that by looking for a model that maximizes the number of satisfied clauses of rc o we effectively cut and add connections simultaneously.
in other words we perform fault localization and repair generation at the same time.
v. m ethodology while automated program repair has been shown to be effective automatically generated patches can damage the structure of the original program and introduce regressions.
to address this problem we devise an approach that searches for syntactically minimal fixes.
our approach combines fault localization and correction into a single step which is achieved by reducing repair problem to partial maximum satisfiability problem.
our pmaxsmt encoding is based on componentbased synthesis encoding extended to capture the structure of the original program as well as to tackle scalability problems.
a. repair problem and repair condition unlike in cbs our goal is to modify the existing expressions of a buggy program in a way that changed expressions make all tests pass.
for this reason we modify the synthesis problem definition into the following repair problem.
definition repair problem .letvbe a variable vbe a set of variables such that v 2v fbe a set of integer operators obe a constraint over fvg vcalled oracle.
let e be a possibly faulty expression constructed using a subset of components c v fand constants such that o v e isnot satisfiable.
repair problem v e v f o is a problem of finding a repaired expression e0such that e0is constructed using a subset of components c v f and constants.
o v e0 is satisfiable.
to solve a repair problem we construct a logical formula which we call repair condition that consists of two groups of clauses hard clauses and soft clauses.
algorithm describes how we generate a repair condition given a test suite tsand a trace formula tfas input.
our algorithm substitutes fresh variablesvifor the rvalue expressions the expressions of tf that are originated from the conditionals or right hand side expressions of a given buggy program2 to construct the formula tf .
the formula tf v ivi ei is semantically equivalent to the initial trace formula tf.
however expressions eithat we allow to modify are now distinguished from the rest of the formula.
algorithm applies cbe to all the components of xi eitogether with additional component and the formula v icbe vi ei tf i o is returned as hard clauses of the repair condition for each test case i o 2ts.
meanwhile we also extract the structure constraint struct of each binding vi ei and classify structas a soft clause.
the structure constraint of vi eiencodes the structure of expression eiusing location variables.
it also encodes the binding of eitoviusing location variables.
in the previous section we showed that expression x y is encoded into the following structure constraint struct structdef l in l xout l in l yout l out l vin wherevis a fresh binding variable.
the structure constraint is obtained via the inverse function of lval2prog lval2prog is a bijective function .
once a repair condition is obtained through algorithm we feed this repair condition to a pmaxsmt solver.
if the solver finds a model this model can be used to construct a repair expression using lval2prog introduced in section iii.
note that a pmaxsmt solver preserves as many original connections as possible which guarantees that directfix changes the minimal number of program expressions as formally described below.
definition simplicity of repair .letpbe a program ts be a test suite with at least one failing test case eibe a subset of the expressions of p cbe a set of components.
we call p0 asimple repair ofpif p0passes ts p0can be obtained from pby substituting some of the subexpressions of eiwith expressions constructed from the components c there is no program that passes tsand can be obtained frompusing a smaller number of such substitutions.
2the expressions of our tf are annotated with source code locations.algorithm repair condition generation input trace formula tf and test suite ts output repair condition as a pair of hard and soft constraints hard soft true true hard and soft clauses expr fejeis a rvalue expression of tfg fortest case i o 2tsdo fore2expr do v a fresh variable c0 select additional component for e tf i o tf i o replaceewithv cbe for components of eand components c0 struct structural constraints for v e hard hard soft soft struct end for to be able to bound a variable with a different value in each test we call function r ename .
hard rename hard tf i o soft rename soft end for return hard soft b. optimization the use of soft constraints reduces synthesis time.
our experiments demonstrate that a pmaxsmt solver implemented on top of an smt solver can find a solution for a formula with soft constraints for some of the considered benchmarks while the smt solver for the same formula without soft constraints does not terminate within the timeout for all the benchmarks.
this fact suggests that the use of the structure of the previous buggy versions improves synthesis performance.
for repairing some bugs it is not sufficient to use only components that are already present in the buggy expressions.
for such cases we select additional components for each expression in the program.
selecting many additional components makes this approach not scalable.
to address this limitation we devise optimizations and heuristics that reduce the negative effect of additional components.
sharing components selecting additional components for program expressions can significantly increase the search space for repair which harms the scalability of the approach.
for instance if there are program expressions and program variables that we consider as additional components then selecting each variable for each expression yields variants to choose a single variable for repairing one of the expressions.
however proceeding on the assumption that the program is correct with the exception of a small part we do not consider each component for each of the program expressions.
instead additional components can be shared by several expressions.
for instance a variable can be shared by all the expressions from its scope.
the original cbe does not allow to share components between several expressions in the original cbe each expression has a fixed interval for allocating components and consequently a fixed set of available components.
to alleviate this limitation we extend cbe so that components of all the expressions are allocated in one big interval consisting of floating subintervals for each expression.
in ?
in out xoutyoutaoutbout xy in out in 1ab in out in s0xout s0 1s0 2s1aout s1 1s1 2s1 fig.
.
allocating components of the expressions x y anda band the additional component on the same interval using floating separators.
cross expression connections are forbidden.
allocating component for all the program expressions in one big interval requires introducing additional constraints to prevent invalid connections between component of different expressions.
for this we introduce a set of separator variables fsigthat define subintervals for each expression.
specifically all the components of the expression ejand the connections between them are allowed only within the interval sj sj .
fig.
shows how the expressions x y anda band the additional component can be placed using such encoding.
note that the intervals for each expression are not fixed and can be extended to add the component .
at the same time we forbid the connections of the component to cross the separator between x y anda bto prevent our tool from generating expressions of invalid structure.
assume that we generate encoding for a set of program expressionsfeigfori2 .
the following constraints ensure that only valid connections are permitted rangedef c2c i j scope c k2 si l cout sj si l cin k sj i m j0 sm l cout k2 sm l cin k l cout sm k2 l cin k sm a where function scope maps a component cto an interval representing the range of program expressions where ccan be used for repair.
the first line of this formula specifies that each component is allocated within the intervals of the expressions from its scope.
the second and third lines ensure that for each separator the inputs and the output of each component are all placed either to the right of this separator or to the left implying that connections do not cross the borders between expressions.
cons acycand connare defined in an analogous manner to cbe taking account of components scopes.
apart from components constraints we enforce the interval consistency constraint intcons over separator variables to ensure that the interval for each expression is well defined s0 sn jcj i j si sj wherecis the set of all available components.test suite buggy c program vcc boogietrace formula rc generator rc repair condition pmaxsmt solvermodel post processor repair fig.
.
the workflow of directfix typed based space reduction if the program to be corrected is statically typed it is possible to use type information to reduce the search space for repair.
we implement heuristics for the repair encoding that reduce the number of possible connections the number of components and the number of candidate repair locations.
in order to ensure that only welltyped expression are considered for repair we modify the connection constraints so that inputs can be connected only with outputs of the same type.
selecting a large number of additional components for repair yields considerable performance reduction.
for this reason we group component by their types into several levels constants boolean operators arithmetical operators comparison operators and variables.
for each level we generate and solve a separate repair condition.
grouping additional components by type allows us to utilize the following two heuristics.
firstly we can prune program expression that cannot be repaired using additional components due to their type.
for example the statement v a bcannot be repaired using integer arithmetics components.
secondly we can reduce the number of connections between components in the original program expressions.
specifically we do not split an expression into subexpressions if these subexpressions have incompatible type with the additional components and consider whole expression as one compound component.
for example the expression a x y can be split into components a andx y if we consider only boolean operators.
c. handling loops for a loop we unroll it ktimes our trace formula guarantees that there is no execution paths requiring more than kunrolling.
the consequence of loop unrolling is that the trace formula includes multiple instances of the program expressions that are executed several times inside loops.
in order to make it possible to apply the fix generated by our tool to the original program we need to ensure that all these expressions are modified synchronously .
this is achieved by binding components locations of these expression through auxiliary components called phantom components .
phantom components do not have semantics and are used only for binding location variables.
vi.
i mplementation we implement the repair methodology described earlier into a prototype tool directfix.
the overall workflow oftable i subject programs subject loc versions description tcas air traffic control program replace text processor schedule process scheduler schedule2 process scheduler coreutils collection of os utilities directfix is shown in fig.
.
to obtain a trace formula from a buggy program we use two third party tools vcc and boogie .
vcc translates a c program into a boogie program.
subsequently the boogie verifier takes as input a boogie program and generates a verification condition a formula used to prove the absence of an error.
both vcc and boogie can handle pointer arithmetics.
a verification condition generated from boogie is very similar to a trace formula we need.
the following shows the verification condition vcof function foowe earlier showed in fig.
a if x1 y1 then y2 y1 else y2 y1 result y2 notice that the trace formula buggy we showed in fig.
b can be obtained by negating vcand replacing with .
due to these subtle differences buggy testis unsatisfiable as needed while vc testis satisfiable.
we modified the boogie verifier in order to obtain a trace formula instead of a verification condition.
our trace formula is in smt lib2 format annotated with source code locations.
the trace formula of a buggy program and its test suite are fed into the rc repair condition generator of directfix which is an implementation of algorithm .
subsequently the generated repair condition is fed into our pmaxsmt partial maximum satisfiability solver we implemented on top of z3 .
our pmaxsmt implementation is the unsat coreguided algorithm of fu and malik .
finally a model satisfiable assignment found by our pmaxsmt solver is post processed to construct a patch.
currently directfix shows which expressions are modified and how they are modified.
vii.
e xperimental results in this section we present the experimental evaluation of directfix.
we also compare the repairs generated by directfix with those generated by semfix .
we ran our experiments on intel core i7 cpu with ubuntu .
bit operating system.
table i shows our subject programs comprised of eighty nine buggy versions of four subject programs from sir software artifact infrastructure repository the number of versions for each subject is shown in the versions column and nine buggy versions of coreutils reported by cadar et al .
these subjects are the same as the ones used intable ii experimental results subjectrepairs total equivalent e same loc s diff d tcas .
replace .
schedule .
schedule2 coreutils overall .
the semfix paper .
all our subjects come also with their correct versions and we compare each of our repairs with its correct versions if a repair is found.
the timeout used in our experiments is 106milliseconds minutes and seconds .
for the subjects larger than tcas we designated the suspicious functions to reduce the search scope assuming that developers have insight about which function might be buggy for example if a test fails after creating or modifying a function foo then a bug is probably located in fooor its callees.
for a library function whose source code is not available we provided a model for it.
table ii shows the results of our experiments.
overall of buggy versions are repaired by directfix.
more interestingly of those repairs are equivalent to the code in the correct versions.
we take a repaired version as equivalent to its correct version when i the same program location is altered by the repair and ii that alternative repair expression is logically equivalently to the corresponding expression in the correct version.
note that some expressions e.g.
x and x are logically equivalent to each other even though they are not syntactically identical.
table ii also exhibits that of the repairs suggested by directfix alter the same program locations as those that differ from the correct versions equivalent repairs mentioned above are included in this category by definition .
for example directfix can suggest a new magic number instead of a buggy constant used in a buggy version.
although it is difficult to suggest the correct magic number in the absence of formal specification the finding that simple replacement of a constant have all tests passing can be a good hint about where a bug is and what a repair should be.
as intended our repairs are simple in most cases.
to measure how simple our repairs are we compare the original buggy version and a repaired version and see how much they differ.
more specifically we compare the asts abstract syntax trees of those two versions and count i the number of ast nodes that are deleted from the buggy version and ii the number of ast nodes that are added into the repaired version.
for example if a buggy expression x y is repaired into x y then the counted number is two because operator is deleted from the buggy version and is inserted into the repaired version.table iii comparison with semfix estands for equivalent sstands for same loc d stands for diff and rstands for regression subject totaldirectfix semfix e s d r e s d r tcas .
.
replace .
.
schedule .
.
schedule2 coreutils overall .
.
the diff column of table ii shows how much original buggy versions and their repaired versions differ in terms of ast differences described earlier.
overall the differences between two versions are as low as .
which is close to the optimal number the optimal number cannot be obtained sometimes when even the simplest repair requires changes of a few lines of a program or complicated changes .
the majority of our repairs are equivalent to ground truth repairs and about of our repairs alter the same program locations as ground truth repairs alter.
a quantitative comparison with semfix we compare our repairs with those of semfix .
similar to directfix semfix also searches for repairs by analyzing the logical semantics of a program and uses component based synthesis to generate repairs.
further comparison between directfix and semfix is given in section ix.
the core difference between semfix and directfix is that directfix can search for simple conservative repairs whereas semfix does not consider the simplicity of repairs.
thus the comparison with semfix is a good indicator about how effective our new approach is in terms of finding simple conservative repairs.
we ran semfix for the same subjects with the same tests as used for the directfix experiment.
we also provided the same information about suspicious functions so that only those suspicious functions and their callees can be modified.
table iii compares the repairs that could be generated by both directfix and semfix.
overall the rates of equivalent repairs and same location repairs are significantly higher in directfix than in semfix vs and vs respectively .
also directfix repairs are simpler less complex than semfix repairs as shown with diff numbers .
vs .
.
we also compare how frequently regression errors are observed between directfix and semfix.
this is to test our hypothesis that simpler repairs are more likely to be safer.
to observe regression errors we apply the entire tests of our sir subjects to repaired versions.
sir subjects have a huge number of tests and we use no more than tests to generate repairs in our experiments.
we classify that there is a regression error if a repaired version produces a different output from the correct version in one ofbool non crossing biased climb int upward preferred int upward crossing situation bool result upward preferred inhibit biased climb down separation i f upward preferred result !
own below threat own below threat !
down separation alim else result own above threat cur vertical sep minsep up separation alim return result bool own below threat return own tracked alt other tracked alt bool own above threat return other tracked alt own tracked alt a snippet of tcas version bool own below threat directfix replaced with .
return own tracked alt other tracked alt bool own above threat directfix replaced with .
return other tracked alt own tracked alt b a directfix repair identical with the ground truth repair bool non crossing biased climb int upward preferred int upward crossing situation bool result upward preferred inhibit biased climb down separation i f upward preferred result !
own below threat own below threat semfix replaces !
down separation alim with the following.
!
other rac own tracked alt else result own above threat cur vertical sep minsep up separation alim return result c a semfix repair fig.
.
comparison of repairs for tcas version the entire tests.
as shown in column r of table iii regression errors are observed less frequently in directfix repairs than in semfix repairs vs .
this results coincides with the high rate of equivalent repairs of directfix equivalent repairs by definition do not cause a regression error.
however directfix is slower than semfix.
for tcas for which we do not designate suspicious functions directfix took an average of minutes seconds while semfix took an average of seconds.
for other benchmarks subjects where only specific functions are allowed to be modified we perform repair on the unit level by reducing programs to only these functions as well as their dependencies.
these reduced programs were given to both tools for fair comparison after which both directfix and semfix took less than a minute.
b qualitative comparison with semfix lastly we provide a couple of concrete examples of repairs generated by directfix and semfix.
fig.
b shows a directfix repair from tcas buggy version .
despite that two program locations are modified the overall repair is simple only two operators are replaced.
this repair is identical with the groundbool locate character c char pat int offset int i bool flag false i offset pat while i offset i f c pat flag true i offset else i i return flag bool omatch char lin int i char pat int j .
.
.
i f lin !
newline !
locate lin pat j .
.
.
a snippet of replace version bool omatch char lin int i char pat int j .
.
.
directfix replace parameter j with j .
i f lin !
newline !
locate lin pat j .
.
.
b a directfix repair identical with the ground truth repair bool locate character c char pat int offset int i bool flag false i offset pat while i offset semfix replace c pat with i .
i f i flag true i offset else i i return flag c a semfix repair fig.
.
comparison on repairs for replace version truth repair.
meanwhile fig.
shows two different repairs from directfix and semfix for replace buggy version .
directfix successfully found the simple ground truth repair it replaces a function parameter jwith j 1of function locate .
meanwhile semfix repaired function locate itself by changing an if guard c pat toi .
although the repair is valid for the given test suite this destructive repair causes a regression.
as compared with semfix directfix repairs are simpler more frequently identical with the ground truth repairs and less frequently cause a regression error.
viii.
t hreats to validity our subject programs mostly require small changes for repair.
while software mining research shows that small fixes are abundant in the field some fixes inevitably require more sizable changes.
in such situations time would be exhausted before directfix can find a repair.
our subject programs do not represent such scenario.
in our experiments we assumed that developers have insight about which function might be buggy.
if an incorrect function is designated as buggy directfix cannot generate the the ground truth repair.
our conjecture is that our repair method is better suited for fine tuning a program and looking for a small fix whereas search based methods such as genprog have advantage in their scalability.
combining these two contrasting methods seems possible for example after a search based method aggressively narrows down the search space directfix should be able to find the smallest patch in that reduced search space at a subsequent phase.ix.
r elated work a large volume of research has been conducted on automatic program repair.
a number of them repair specific defect types while directfix is designed to be a general purpose program repair tool.
unlike specificationsbased methods directfix falls into the category of the test driven method whose goal is to find a patch that makes all tests in the given test suite pass.
genprog and jaff use genetic programming gp to search for a patch.
using gp statements can be deleted or moved.
the fitness function of gp guides such mutations towards a patch.
it was empirically shown that this approach scales to large programs such as php .
however it often generates nonsensical patches as pointed out in due to its inherent nature of random mutation.
to alleviate this problem mut apr mutates only pre selected binary operators thereby restricting the defect types it can handle and par uses fix templates mined from actual human patches instead of gp.
meanwhile semfix synthesizes a patch by semantic program analysis via dynamic symbolic execution instead of performing syntactic search.
similar to directfix semfix also synthesizes a patch at the expression level by using component based program synthesis .
more recently nopol also took this semantic approach to fix controlrelated bugs e.g.
buggy ifconditions .
autofix exploits contracts such as pre post conditions to generate random tests localize faults and generate a repair.
in all existing repair methods fault localization is performed upfront before looking for a patch.
we in contrast combine fault localization and repair generation and as a result obtain the unique capability to take into account the simplicity of a patch.
for this purpose we exploit partial maxsmt pmaxsmt .
similarly bugassist exploits pmaxsat for fault localization.
however unlike in directfix pmaxsat is not used for repair synthesis bugassist does not fuse fault localization and repair generation.
x. c onclusion in this paper we have proposed directfix as a method that generates the simplest repair following the thesis that small patches are easier to inspect and introduce less regressions hence safer .
directfix is a semantic analysis based repair method which differs from all existing repair methods in its integration of fault localization with repair generation.
we have shown how those two phases can be integrated based on partial maxsmt and component based program synthesis.
patches produced by directfix are found to be simpler and safer than those produced by semfix the state of the art semantic analysis based repair method.