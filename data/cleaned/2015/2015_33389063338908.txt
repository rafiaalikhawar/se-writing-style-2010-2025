concolictesting formodels ofstate basedsystems reza ahmadi queen s university kingston ontario canada ahmadi cs.queensu.cajuergen dingel queen s university kingston ontario canada dingel cs.queensu.ca abstract testingmodelsofmoderncyber physicalsystemsisnotstraightforwardduetotimingconstraints numerousifnotinfinitepossible behaviors and complex communications between components.
software testing tools and approaches that can generate test cases to test these systems are therefore important.
many of the existing automatic approaches support testing at the implementation level only.theexistingmodel leveltestingtoolseithertreatthemodel asablackbox e.g.
randomtestingapproaches orhavelimitations whenitcomestogeneratingcomplextestsequences e.g.
symbolic execution .
this paper presents a novel approach and tool support forautomaticunittestingofmodelsofreal timeembeddedsystems by conducting concolictesting a hybrid testing technique based onconcreteandsymbolicexecution.ourtechniqueconductsautomatic concolic testing in two phases.
in the first phase model is isolatedfromitsenvironment istransformedtoatestablemodel and is integrated with a test harness.
in the second phase the harness tests the model concolically and reports the test execution results.
we describe an implementation of our approach in the context of papyrus rt an open source model driven engineering mde toolbasedonthemodelinglanguageuml rt andreport the results of applying our concolic testing approach to a set of standardbenchmarkmodels to validate our approach.
ccs concepts software and its engineering software testing and debugging.
keywords concolictesting model driven engineering statemachine acmreference format reza ahmadi and juergen dingel.
.
concolic testing for models of state based systems.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august 26 30 tallinn estonia.
acm new york ny usa 12pages.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 26 30 tallinn estonia associationfor computing machinery.
acm isbn ... .
introduction modern real time embedded software rte plays a fundamental role in controlling many products and devices found in telecommunicationsystems automobiles aircraftandmanyothercyberphysical systems.
in such complex systems the behavior of the system depends on real time constraints as well as on complex communications with the environment using various protocols.
usingcode centric onlyapproachesfordevelopingcomplexrte systems is very challenging.
mdetechniques tackle this challenge by raising the level of abstraction on which the developers construct software.
if a software model contains faults these faults willpropagateto anyrefinementofthatmodelorthecodethatis generatedfromthemodel.therefore findingandresolvingfaults atthemodelleveliscriticalfordevelopinghighqualitysoftware.
although mdeprinciplesincludingabstraction automation and analysis canhelpdealwiththecomplexityofsoftware models ofmodernindustrialsystemsstilloftenarelargeandcanbecome overwhelming.
thus testing of such models is challenging without automatictoolsupport.
symbolic execution is able to automatically generate test cases for a program that achieve high coverage of the program executions.
however symbolic execution typically results in pathexplosion whenexecutinglargesystems.thesituation can be worse in analysing concurrent systems where the state spaceislarger.thescalabilityissuehasbeenpartiallyaddressed e.g.
by distributing the computations on a cloud or by conductingselectivesymbolicexecution .buttherearesome other issues e.g.
since symbolic execution is typically static it may not be precise in some situations e.g.
when there are statements in the program that call library functions that are hard to reasonabout e.g.
callsto operating systemlibraries orwhen the programincludes pointer manipulationsorpointer aliases .in addition symbolicallyexecutingprogramsormodelswithcomplex constraints or data structures is challenging e.g.
symbolic executionwillbestuckifitfacesnon lineararithmeticpathconstraints .
besides symbolic execution typically constructs and maintainsasymbolicexecutiontree set tokeeptrackofpath constraints for executions where for complex systems it is computationally intractableto precisely maintainand solve constraints for test generationdueto numerous executionpaths .
concolictesting ontheotherhand executesaprogrambothconcretelyandsymbolically.inthistechnique aprogramisexecuted on some random inputs and symbolic constraints are collected during the course of that execution.
then the collected constraints are negated and solved again to execute alternative branches in the program.
this process is run in a loop until all branches are executedorauser specifiedcoveragecriterionismet.thefactthat symbolicconstraintsarecollectedduringaconcreteexecutionof the program allows the generation of test inputs that will force esec fse august tallinn estonia rezaahmadiandjuergendingel theprogramalongtheexactsameexecution.therefore everyerrorcaughtbytakinganexecutionpathbytheconcolictestingis guaranteedtobesound .inaddition aprogramthatincludes function calls to external libraries will prevent the symbolic executionfromcollectingpathconstraints sincetheprogramincludes statements that involve constraints that are outside the scope of thesymbolicexecutionengine.concolictestingengines suchas dart typicallysolvethisproblembyrandomlygenerating inputsandrunningthefunctioncallstoreasonaboutthepredicates andto collectconstraints .
mdeis becoming more prevalent and software models tend to becomelargeandcomplex.forinstance modelsofrtesystemsin automotive and aerospace domains may encompass many interacting state machines that communicate using various protocols with complex action code on the transitions of the state machines.
in suchmodels testingsomebranchesonastatemachinecanbevery challenging since the execution of such branches may need a sequence of events where these events are highly constrained by the inputparameters.itbecomesmorechallengingwhentheexecution of an eventis guarded by aconditionalwhere that conditionaldepends on previous event parameters.
observe that in complex rte systems event parameters are often of complex data types rather thanprimitivetypes .concolictestingcanbeaneffectivetechnique fortestingthesesystems.however asopposedtoconcolicprogram testing model level concolic testing has not been addressed in the literature.
one may propose using the current code centric concolictesting enginesfor testing thebehavior of modelsby testing the code generated from the models.
however there are currently concolic testing engines for only a few languages so it may not be possibletotestprogramsgenerated inanarbitrarytargetlanguage frommodels.inaddition theinformationcollectedduringtesting the programs is not easily traceable to the models.
therefore more work is needed to leverage concolic testing for software models in particularfor models ofreactive andreal timesystems.
in this paper we present a novel approach and prototype tool for automatic concolic testing models of rte systems.
to this end we automatically generate a harness for a model to simulate its environment.theharnessisintegratedwithamodel levelconcolic enginetodynamicallygeneratetestinputsforthemodelandstimulateitwiththegeneratedinputs.wehavebuiltourconcolicengine on uml rt a domain specific language whose constructs come from standard uml constructs .
uml rt is a popular industrialmodelinglanguagethatisusedformodelingindustrial systemsandissupportedbyseveralopen sourceandcommercial tools eclipsepapyrus rt eclipseetrice ibmrsa rte hcl rtist and ibm rosert .
our prototype implementationusestheopensource mdetoolpapyrus rt.toevaluateour approach weuseanindustrialcasestudyprovidedbyoneofour industrialpartnersaswellasasetofotheracademiccasestudies ofdifferentsizesandcomplexities.
in the next section we briefly introduce uml rt with an example model and an overview of the current state of the art in theprogram andmodel levelconcolictesting.then weexplain our approach.
next the implementation of our concolic testing approach is presented.
we then briefly describe our prototype tool alongwithan evaluation ofthe approach andthe tool.
background developing executable models in uml rt.
constructing complex often distributed real time systems needs powerful welldefined modeling constructs as well as strongtool support.
these constructs and tools can be used to design a well defined architectureforsuchcomplexsystems whicheasesnotonlythedevelopment of the initial system but also facilitates maintenance and evolution .
uml for real time uml rt is a domain specific languagededicatedformodelingreal timesystems.uml rtisa umlprofile similarto e.g.
marte andsysml .since uml rt focuses on modeling real time systems it is compared to uml asmall languagewithlight notation.
the main concepts of uml rt are capsules ports andconnectors .
a capsule is an independent active class with its own controlflow.capsulesownports allowingthemtocommunicate viamessagepassing.statemachinesmodelthebehaviourofcapsules.
a uml rt state machine is an extension of a mealy state machine augmentedwithextrafeatures includingstateactions composite states anddeep history.
uml rt code generators generate complete executable code for the structural and behavioral aspects of a model.
since uml rt is both a specification and implementation language the action codewritteninthemodelisintegratedaspartofthecodegeneratedfromamodel.fig.
1presentssomebehavioralandstructural aspects state machine sample action code and capsules of a collisionavoidance ca system.thissystempreventsormitigates collisions by continuously monitoring the road ahead and parts of the side fronts of the vehicle.
whenever an obstacle is detected it notifiesthedriverbyaudibleorvisualalerts.inaddition thesystem automatically brakes vibrates or steers the wheels in the opposite directionifitdetectsanimminentcollision.basedonthefigure the ca controller capsulecommunicateswith four othercapsulesvia theports lidar panel brake andsteer observetheactioncodeon transitionsinfig.
.thefirstportreceivesthreatmeasurements from four lidarcomponents.
lidar uses the laser to estimate the distance between objects and the direction of the potential collisionswithobjects.thecontrollersendserrororwarningsignalsto theuserpanelcomponentviatheport paneltoinformthedriver usingaudibleandvisualalerts.thecontrolleralsocommunicates withthe brake and steeringwheel systems by sendingcommands to the ports brakeandsteerto apply the brake and to vibrate or to steer the steering wheel based on the threats measured.
this samplemodelwillbeusedinthefollowingsectionstodemonstrate our approach for model level concolictesting.
programsymbolicandconcolicexecution.
the key idea behindsymbolicexecutionistousesymbolicvaluesinsteadofconcretedatavaluesforprograminputsandmaintainacollectionof symbolic expressions over the symbolic values to represent the programvariablesthroughouttheprogramexecution .symbolic execution maintains a path constraint which consists of quantifier freefirst orderformulasoverthesymbolicexpressions and asymbolic state which maps each program variable to a symbolic expression.
at execution time initially istrueand is an empty map.
these two variables are updated throughout the program execution.
for instance if at a location in the program inputisreadusing v input thenv mapsto sisaddedto wheres 5concolic testingformodelsof state basedsystems esec fse august tallinn estonia figure the structure oftheca controllermodelandits environment left.the statemachineofca right isafreshsymbolicvalue.theexpressionmeansafreshsymbolic variableisallocatedforeachinputvariable.duringexecution at every assignment statement v e symbolic execution updates by mapping vto e where e is the symbolic expression obtainedbyevaluating ein .ataconditionalstatement if e then s0elses1 thepathconstraint isupdatedto eandanewpath constraint isconstructedandupdatedto e.atthispoint of execution if eis satisfiable then a new symbolic execution branch is created and the execution proceeds from the thenbranch.
similarly if eissatisfiable anewbranchisconstructedand the executionis continuedfrom the elsebranch.observe that this kind of execution gives rise to a tree of symbolic executions which iscalledsymbolicexecutiontree set .
attheendoftheexecutionorwhenanerrorhappens e.g.
atan assertionviolationorprogramcrash thecurrentpathconstraint intheset issolvedusingaconstraintsolver andtestinputsare generated.byexecutingtheprogramusingthegeneratedinputs theprogram follows thesamepath asthesymbolicexecution.
for more details aboutsymbolic execution pleaserefer to .
concolictestingexecutesaprogrambothconcretelyandsymbolically .
in this technique symbolic execution is conducted dynamically which means the program under test is executedandduringthatexecution symbolicexpressionsandpath constraintsarecollected.concolicexecutionmaintainstwomaps of program variables the symbolic state that maps the variables to symbolicexpressionsandtheconcretestatethatmapsthevariables toconcretevalues.thistechniqueneedssomeinitialprograminput whichisgeneratedrandomlytoinitiatetheexecution.attheend ofeachexecution aconstraintinthecollectedpathconstraintsis negated theconstrainttonegateiseitherselectedrandomly systematicallyorbasedonsomeotherheuristics andtheprogram is executed again using the newly generated inputs by solving the negated constraint to steer the program along a new execution path.theconcolictestingconductsthistaskeithersystematically untilallfeasibledistinctexecutionpathshavebeenvisitedorthe testing budget runs out.
observe that in concolic testing a set isnotgenerated ratheralistofpathconstraintsisgeneratedand updated throughout the whole execution and thus there is not the issueofsavingandupdatingthe set.
program concolic testing has already proved its potential for achievinghighcodecoverage forcatchingbugsinprograms that are otherwise very hard to catch using other approachesincludingstaticanalysistoolsandrandomtesting.one examplesuccessfulapplicationofconcolictestingintheindustry is sage that has been used by microsoft for catching many vulnerabilitybugsinlargeprojectsincludingwindows7 .however concolictestingofmodelshasnotbeenstudiedbeforeeven thoughmdeisbecomingmoreprevalentandmodelstendtobecome larger and more complex.
for instance the simple model shown in fig.
1specifies the behavior of a reactive system that executes by frequent communications with its environment.
these types of models have action code on their transitions to conduct various computations including to process incoming messages update attributes and produce outgoing messages.
these systems execute only when they are in their appropriate environment e.g.
are connected todevices thatsends them the required stimuli.
to test these systems during development one needs to mock the environment for the system for instance through a test harness such that the harness sends a sequence of messages in a specific orderwithappropriateinputparameters.itischallengingandlabor intensive to manually craft a test harness for each model this task includescreatingacapsuleasthetestharness ports andconnectors as well as the behavior of the test harness .
therefore to automate testing one may need to generate the structure and behavior of the test harness dedicated to each model under test.
to archive highcoverage theharnessshouldintensivelytestthemodeland monitor and report the test coverage information.
in the following sections we explain our approach for concolic testing such models.
approach given a state machine under test and a test budget can be the allotted time for testing or the maximum number of consecutive transitions to execute as input the objective of our approach is to automatically test the state machine to exhibit as many executions asthe testbudgetpermits to increase the chance for findingbugs in the state machine.
in this section we start with a motivating example and an overview of our approach before we elaborate different steps of our technique for model level concolic testing.
throughoutthissection wecallthestatemachineundertest the model wherethetest harness isresponsible for testingthis model.
6esec fse august tallinn estonia rezaahmadiandjuergendingel .
motivating example the simple model presented in fig.
1has three bugs two of which canbedetectedifthelines8and16ontheactioncodeofthetransitiont5 incoming transition to the state mitigate are executed.
for instance toexecuteline8 thestatemachinemustreceivethefollowingmessagesandparametersvaluesmustsatisfytheconstraintsin parenthesis lidarmsg threat to executethetransition idle warn andlidarmsg threat computedirection cd true toexecute the transition warn mitigateand execute the second ifstatement.
so in this case solving the path constraints pcs threat0 threat1 computedirection cd0 true allowsgenerating test inputs that will force the state machine to reach and executeline8.toexecutethecorresponding elsebranch line10 theconcolicenginenegatesthelastconstrainttoendupthepcs threat0 threat1 computedirection cd0 true so by solvingitthe elsebranchisexecuted.observethatthethird ifstatement line executes if and only if hvienabled has been enabled in previous transitions where this predicate gets enabled if the transition t1executesatleastthreetimes suchthatthepredicate warnings holds warnings is a global variable .
therefore as shown theexecutionofabranchonatransitionisdependenton the valuation of a global variable in a specific way.
this system shouldnotvibrateandsteerthewheelatthesametime .that is it vibrates the steering wheel if it detects a forward collision andsteersthecarintheoppositedirectionifitdetectsamerging collision thetypeofthecollisioniscomputedbyalibraryusing thecdinputparameter .astransition t5shows iftheflag mergingcolholds and vibrate is enabled by a message from the user this requirementisviolated.sothislastbugissubtleandcanbecaught byanalyzingtheexecutiontracesonly ashasbeenproposedin .
.
approach overview in our approach a test harness is responsible for constructing messages and parameters and sending them to the model to trigger transitions on the model and hence execute the action code on the model.
a transition might be executed several times to exercise all possible executions on the transition action code.
to this end beforeconductingtesting themodelistransformedbyaugmentingit bynew modelelementsto enabletheharness tocontrol the executionofthemodelandtosteerthemodelalongitsdifferentexecutions.moreover asmentioned inconcolicexecution themodel isexecutedbothconcretely executingthestatemachinethrough thegeneratedinputparameters andsymbolicallytocollectpath constraints on values at symbolic variables constructed in terms of inputparameters.toenablethesesidebysideexecutions during themodeltransformations weconductasetofinstrumentationson the actioncode ofthe statemachine undertestbyaddingnew actioncodebesidetheexistingone whichisresponsibleforcollecting symbolic path constraints.
once the model is transformed we generatetheharnessaswellastheextraelementsrequiredtointegrate the harness and the model.
finally we rely on the standard code generatortogeneratecodefromboththeharnessandthemodel as wellasthegluecodeforintegratingthetwo.thecodegenerated is executed so harness and the model execute concurrently.
in the following sections we present all the steps mentioned above indetail.
we first explain the steps of our model transformations and the rationalebehindthem.
.
model transformations model harnesssynchronization.
theharnessandthemodelunder test execute concurrently and asynchronously.
the harness should testamodelwithasequenceoftestinputsandaftertheprocessing of each input the model should send an acknowledgment to the harness.tothisend duringinstrumentation newactioncodestatementsareaddedtothestatessuchthatuponcompleteexecution of each transition on the model the model informs the harness so the harness can send the next test input.
for instance if a model has transitions that are enabled by timers the harness is not aware of the exact timeout of a timer on the model so sending messages from the model to the harness upon execution of a transition helps tosynchronizetheharnessandthemodel.themessage newstate added on the instrumented model in fig.
3informs the harness about a newly visited state so the harness can prepare and send the nextappropriate messageto the modelundertest.
path constraint collection.
we instrument the action code on the transitions by inserting extra commands on the action code .
the instrumented transition executes as the original one but also invokes the symbolic execution engine for collecting path constraints pcs .theinstrumentationsshowninthelastrowof table1serveasanotherpurpose thancollectingpcs whichare explained later.
given the fact that a transition may be guarded by an expression a transition is enabled iff it receives the required messagetriggerandthetransitionguardexpressionholds anda statemachinemayinclude choicepoints statesthathavemultiple outgoingbrancheswherethedecisiononwhichbranchisexecuted is based on the guard on that branch before the instrumentations we first conduct the following small transformations on the model.
transformingchoicepoints ifthetargetstateofatransition t isachoicepoint foreachguardexpressiononthechoicepoint s outgoingtransitionsweaddnewcorrespondingifstatementblocks on the action code of t. therefore the corresponding path constraints are collected for each outgoing transition so proper test inputisgeneratedtocoveralltheoutgoingtransitions.forinstance asshowninfig.
threat?
isachoicepointwithtwooutgoing transitions.
the guards on these two outgoings give rise to two newifstatements onthe transformedtransition t3.
transformingguards asmentioned anytransitionisinitially executed by receiving random data and hence the concolic engine may not be able to execute guarded transitions initially since it is very likely that random data does not satisfy the guard predicates .
therefore such transitions need some transformations that by preservingtheoriginalbehavior enablethetooltoexecutethemby some random data.
to this end if there is a transition t0 s0 s1 as shown in fig.
two new transitions t1andt2and a choice pointcare created.the transition t1is theincoming transitionto c andt0andt2are its outgoing transitions.
as shown in the figure t0now connects the choice point to the state s1.
in addition the actioncodeof t1nowforcestheconcolicenginetocollecttwonew constraintsthatcangiverisetogeneratinginputsthatsatisfythe guardoft0andcausetheexecutionoftheactioncodeof t0.more examples ofthis transformation are infig.
.
7concolic testingformodelsof state basedsystems esec fse august tallinn estonia figure2 transformingguards.left originalmodel right transformed one.
table action codeinstrumentations transitionaction code transition type beforeinstru.
afterinstru.
reading input v input v mapsto s v input others assignment v e m0 v mapsto eval sym e v e others conditional if e thens0 elses1 e eval sym e if e then e s0 else e s1 others reset vars save pcs iteration action codefullcoverage.
traditionally thenotionofcoverage in testing state machines includes transitions states or predicate coverage so to test a state machine completely one should generate as many as test cases as necessary to trigger all transitions on the state machine or satisfy all guard expressions on all transitions.inourapproach weconsiderexploringallthebranch pointsonthetransitionactioncodeaswell whichmeansweshould notonlyconsiderexploringallthetransitions butalsotheaction codeonthosetransitions.theactioncodeonatransitionmayhave multiple branch points e.g.
due to if statements and hence the transition should be executed multiple timeswith different inputs in order to exercise all possible executions.
since after each execution the state of the system changes either by transiting to a new state or by updating some global variables the model should be able to restore its original state after each execution.
to this end duringthetransformations themodelisaugmentedbynew instructions such that after each execution the test harness can movethemodelundertestbacktoastartingpoint suchthatthe variable values are restored so the execution can be conducted on the original global variable values.
to this end a transition from each state to the initial state is created to form a loop and we callthenewtransitionan iteration.wecallthetransitionsinthis loopatransitionset .aniterationallowstheharnesstoexecutea transitionsetmultipletimes.forinstance thetransitions iterate1 anditerate2in fig.3represent two iterations.
as shown in the last rowofthetable thetwolinesofactioncodethatareexecuted on an iteration are reset vars andsave pcs .
the former one restores the state machine s variable values and the later one saves the collected path constraints of a transition set into a file.
the harnesssendsnewinputstothemodelineachiteration andthat happensbyrestoringtheconstraintscollectedbythemodel and negatingandsolvingthemuponcompletionof the executionofa transitionset.we willelaboratethis inthe following sections.
.
concolictestingofthestate machine in ourapproach atestharnessis generatedfor eachmodel under testandisintegratedwiththemodelautomatically .based figure a simplified version of the ca model shown in fig.1before top and after bottom the model transformations.
model elements dashed are the elements that are newlyadded updated duringthe transformations.
figure integrating amodelwith atestharness onthefigure themodeloriginallycommunicateswithfourother models through their ports fig.
on the left .
the harness mocks theexternalenvironmentforthemodel fig.
ontheright sothe modelcan be testedas aunitinisolation.
oncethestatemachineisinstrumentedandisintegratedwith a test harness the state machine can be tested.
in the remainder ofthissectionweelaborateonhowthetestharnessconductsthe concolictestingusing the example modelshowninfig.
.
fig.5presentsanabstractbehaviorofthetestharnessviaastate machineandfig.
6presentssomeofthefunctionsandattributes of the test harness.
as shown in fig.
the test harness starts by readingatestconfigurationfile tospecifytestbudget suchastotal iterations andthenentersthestate msgsending .whenentering this state the harness calls the function sendmessage shown in fig.
to select the next transition for execution the candidate transition andtosendamessagetoenablethattransition.inthe functionsendmessage selecttransition line12 selectsthecandidate transition from the outgoing transitions of the current state.
since a transition set is executed iexectimes the candidate transition is selected based on the following rules in an iteration i where i iexec if none of the outgoing transitions has been executed before then selecttransition chooses one of them randomly otherwisethetransitionthathasbeenexecutedintheiteration i 1is selected where i iexec .thisisbecausetheinputsgenerated from path constraints collected during execution of a transition set executethesametransitionset sametransitionsandsameorder of execution but forces a different execution pathin transitions 8esec fse august tallinn estonia rezaahmadiandjuergendingel actioncode.ifatransitionsetisexecuted iexectimes startingfrom theinitialstate theharnesspicksanoutgoingtransitionthathas not been executed before or a random transition if all the outgoing transitions have been executed iexectimes.
observe that if in a statemachinethereisaself transition st atransitionwhosesource and destination states are identical stcan be selected tslen the transitionsetlength timessothenexttransitionsneverexecute.
tohandlethis issue the harnesstakes as inputa loopbound texec infig.
so inan iteration the harness does not select any transition more than texectimes collectively.
in line the harness readsinputseitherfromfileifalreadyexistsinputgeneratedbythe symbolic execution engine otherwise it generates random data for a candidate transition.
then the harness constructs a message and sends itto the modelundertest lines14 .
since the transitions on the model are instrumented observe fig.
uponreceptionofthemessagebythecandidatetransition theactioncodeonthetransitionisexecuted whichleadstocollecting orupdating pathconstraints andthemodelsends newstate to the harness which causes the harness to move to the state msgreceived wheretheharnesscallsitsfunction nextstep shown infig.
.thisfunctionfirstupdatesthecoverageinformation line anddecideswhether theharnessmustrestartthemodel under testforcingittomovetoitsinitialstate ortocontinueexecuting the next transitions.
this decisionis basedonwhether ornot tslen transitionsetlength numberoftransitionshavebeenalreadyexecuted lines3 .iftheharnessdecidestocontinue thenitsetsa timer line so once the timer times out after some milliseconds the harness ends up in the state msgsending so it can prepare and sendthenextmessage.ifnot theharnesssendsthemessage iterate to the model which causes the model to move to its initial state and send a new newstate message which causes the harness to movetothechoicepoint iterate?
.inthisstate ifthetotalnumber of executed iterations equals totaliter or there is no more branchestoexecute thenthestatemachinemovestothestate end otherwise it moves back to the state msgsending and the function negate solve isexecuted.observethatifthetestingtimebudget exectime runsout theharnessalways automaticallyterminates.
we have not shownthat functionalityhere dueto spacelimits.
as shown in fig.
after each iteration the model stores the symbolicexecution se objectintoafile bycallingthefunction save sym .
so the function negate solve in the harness restores this se line and based on the selected heuristic either random or systematic which we will elaborate later in this section aconstraintintheseisnegated lines19 .notethatthepath constraintscollectedforatransitionsetistheconjunctionofallthe constraints collected for each transition so the test harness always maintains only one path constraint throughout the execution of the whole model as opposed to symbolic execution that maintains a tree of path constraints for all paths in the system .
the harness then solvestheresultingnegatedconstraintsandwritestheinputs generatedtoafile lines24 soitcanlater inthestate msgsending send themto the model.
example.
assuming transition set length is the sequence diagram shown in fig.
7presents the communication between the harness the instrumented model shown in fig.
3and the symbolicexecution engine.based onfig.
thestate idlehas only one figure asimplified statemachineofthe testharness input astate machine sm and a testconfigurationobject testconf with these attributes heuristic h total iterations totaliter execution time exectime transition set lengthtslen iterationexecutions iexec and transition executions texec.
harness attributes executed transitions sym ex obj .
output the branch transition and state coverageresults.
procedure nextstep updatecoverage if executed transitions testconf.tslen then timer.set let executed transitions executed transitions else iterate.send let executed transitions endif endprocedure procedure sendmessage letcandidate selecttransition sm.currstate .outgoingtransitions letinputs readinputs candidate letmessage getmsg candidate inputs message.send endprocedure procedure negate solve let sym ex obj readsymexobjfromfile if h then random branch selection negate rand sym ex obj else systematic branch selection negate sys sym ex obj endif letinputs solvesymexobj sym ex obj writeinputstofile inputs endprocedure figure the behavior ofthe testharness outgoing transition t1 so the test harness sends the message lidarmsg parameter is randomly generated so t1is executed and executing its action code gives rise to constructing the path constraints threat0 .
now the model informs the harness with anewstate message so the harness sends the next message againwithsomerandomparameters lidarmsg whichexecutes t3as well as t5 since the t5guard holds and the resulting pcs will be threat0 threat1 .
now the number of executed transitions is and hence the harness sends the message iterate whichresultsin restartingthemodel negatingthelast part ofthe constraints resulting in pcs threat0 threat1 and generating new inputs e.g.
threat0 1andthreat1 which this time will execute the transitions t1andt3 andt4 respectively.
dfs vs. bfs transition execution.
in our approach we can test a model by choosing a value for the parameter iteration length large enough to execute all the transitionsstarting from theinitial state all the way through to some final state a state with no outgoing transitions so the execution and testing of transitions will be basedonthedepthfirstsearch dfs traversal.conversely taking 9concolic testingformodelsof state basedsystems esec fse august tallinn estonia figure communication of the harness the model under test mut andthesymbolicexecution engine smallernumbersastheiterationlengthandincreasingthatnumber iterativelycansimulatethebreathfirstsearch bfs traversalfor testingthe transitions.
heuristicsforbranchselection.
weimplementedtwodifferenttechniques for selecting the next branch for execution from the next executablebranches randomandsystematic.assumingthenumber ofconstraintscollectedthroughexecutingatransitionsetis n then intheformercase arandomnumber xisgeneratedsuchthat x n toselectthe xthbranchforexecution.inthiscase itispossiblethat abranchonanyofthetransitionsonthecurrenttransitionsetgets executed.
in the later case the harness systematically executes the branches on the transitions and in the order that the transitions have been executed.
for instance if in a transition set the transitionst1 t2 ..tnareexecutedandtheconstraints tc1 tc2 tc1 ... tc1nare collectedinitially thenthenextpathconstraintsareconstructedby negating the constraints in the same order.
we note that executing abranchonatransitionmaygiverisetocollectingnewconstraints due to nested conditionals.
therefore always constraints on the sametransitionareselectedfornegationuntilallthebrancheson thattransitionare executed.we refertothesetechniques random concolic rc andsystematic concolic sc respectively.
.
behavior preservation the instrumentation in our approach preserves the original behaviorofthemodelandonlyenablescollectingpathconstraints similar to other tools .
since collecting and solving complex constraintstake some time we needed to consider this factor formodelswithtimerstopreventimpactonthebehaviorofsuch models.
to this end as mentioned in our approach solving the constraints is always carried out during the execution of an iterationtransition ratherthanateachstatewherethesolvingtime may be long enough such that some timer on the next outgoing transitions may fire before the constraint solver generates the data.
usingthistechnique wedidnotobserveanyimpact introducedby the overhead of constraint solving on the timed systems based on ourexperimentsonseveralcasestudymodels thatwewillpresent later .asanotherobservation solvingtheconstraintsisfairlyquick intheorderofmilliseconds whichisconsiderablylessthanthe timervaluesthatweobservedonthecasestudymodels.hencethe tool evenwithoutthetechniqueabove wouldnotinterferewith the behaviorofthe models.
figure the overview ofour prototype tool experimentalevaluation .
toolimplementation we have implemented a prototype tool called mcute model level concolicunittestingengine toconcolicallyexecutestate based models using the approach that we presented.
we have conducted severalexperimentsusingourtoolonanumberofindustrialand academic models with different sizes and complexities.
mcute whichisopensource wasimplementedpartlyinjava staticparts relatedto e.g.
modelprocessingandmodeltransformations and c the core libraries for concolic testing .
we have integrated ourtoolinpapyrus rt whichisaneclipse basedopensource software modeling ide with an active user community.
our tool can be integrated to othereclipse based ides including rsa rte andrhapsody.theschematicdesignofourprototypetoolisshown infig.8andvariouscomponentsofourdesignareexplainedbelow.
modeltransformer implementsasetoflibrariesontopofeclipse modeling framework emf to connect to a model and collect information on model elements such as transitions states and action code.
this information is collected statically and is stored in some vectors before testing the model.
this module then uses this informationtoconfigurethetestharnessbytakingthestructure of the model into account.
this module is also responsible for transforming the model and instrumenting its action code.
the transformation is done using emf libraries and the action code instrumentationisconductedusing cil .
model level concolic engine module contains a test harness configuredbythemodeltransformermodule integratedwithoursymbolic execution engine which was built by extending crest .
the harness implements algorithms for concolic testing some libraries for measuring themodelcoverage including states transition andactioncodecoverage aswellasheuristicsfortransition andbranchselections.thismoduleinitializestheharnesswithuserprovided test configurations keeps track of the path constraints collected and feeds the harness with newly generated test cases.
themodule storesthe coverageinformationforeachtransition in anobject.thecoverageinformationisupdatedaftereachiteration so the module chooses the candidate branches for negation for a transition from its coverage object.
observe that to initiate testing wegeneratecodefromboththemodelundertestanditsharness andwe executethe generatedcode.
thecodegenerated fromtest harnesses varies slightly for each model but a test harness was on averagearound 3k linesof c code.
10esec fse august tallinn estonia rezaahmadiandjuergendingel table our case study models modelmodel complexity total transitionstotal statestotal action codetotal brancheslocof the generated code ar .3k fdm .2k acc .5k ca .5k pbx 11k rsm .5k .
the benchmark models our criteria for selecting the candidate case study models include i thecasestudiesshouldhavealargenumberoftransitions action code and complex branches in their action code ii the case studiesshouldincludetransitionsthathavedependenciesoverglobal variables.thefirstcriterionaboveservestoevaluatethescalability ofourtoolandapproach sinceinthesecasestudies thetoolmay need to collect and solve large and complex path constraints.
in addition the large number of branches may give rise to numerousexecutions whatinsymbolicexecutionmayleadtothepath explosion problem .
the second criterion evaluates our tool and approachforitseffectivenessinexploringbrancheswhosepredicate is highly dependent on previous constraints and consequently the effectiveness of the approach in finding bugs that may only be revealed if certain branches are executed.
below we will briefly introduce our casestudiesfor this experiment.
collisionavoidance ca thatwasexplainedinprevioussections.
autonomousrover ar isasystemthatcontrolsavehicleequipped withfourwheelsdrivenbytwoenginesandsensorstocollectinformation from the environment and to detect obstacles.
fabric dyeingmachine fdm isasystemtocontrolafabricdyeing machine.itwasdesignedinitiallyinroom .wemanuallyconverted it to a behaviorally equivalentsystem inuml rt.
adaptive cruise control acc is a system that adjusts the vehicle speed and distancetothatofatargetvehicleandwasoriginallydesignedin autofocus .pbx privatebranchexchange isasystemthat models theinteraction of auserwith aprivatetelephonenetwork used within an organization.
randomly synthesized model rsm wealsochallengedourtoolonalargemodelgeneratedrandomly.
themodelgeneratorgenerateswell formedexecutablemodels i.e.
allthetransitionshaveatrigger andallstatesarereachablefrom the initial state.
the tool generates well formed executable pieces of c code as action code similar to the program generator tool csmith that generates c code fragments for testing compilers withmultiplebranchpointsoverthetransitioninputparameters.it took just more than minutes for our model generator to generate thismodel afully instrumentedand transformedmodel whichis ready for testing and around 2minutes for the codegenerator to generatecodefromthemodel.moreinformationaboutallofour models can be foundintable .
.
the experiment setup coverage methodology.
we used state transition and branch coverage as widely understoodanduncontroversialmetrics to evaluate theeffectivenessofmcute.thetoolmeasuresthecoverageduringtestingandfinallyreportsthecoverage.regardingbranchcoverage weonlyconsiderfeasiblereachablebranches i.e.
thebranchesthat areindeedexecutable andwedonotcountthenumberofbranches in the library code.
even though mcute needs to successfully executethe library code inorder to executethe modelitself.
differenttypes ofbugsonthe models.
models of rte systemsmay define a tricky execution space that is built from many pointer operations includingcasting andnumerousnestedconditionals.this code must often process inputs received from other programs that mayincludenetworkpacketsorsystemcallparameters whichmay cause run time errors.
we refer to these bugs as model crashing bugs.
on the other hand some bugs do not crash the system but cause the system to generate wrong outputs which are referred to asoperation bugs .
these types of bugs are detected by analyzing the model s execution tracesonly.
prior work has proposed propertymonitors tocatchthesebugs .finally mcutecancatch codegenerator bugs sincemcute runsthecodegeneratedfrom the models.
some examples of these bugs caught by mcute are describedinsection .
.
the baseline for comparison.
we compare our approach for testingstatemachineswiththetwotechniquespresentedin .the first one random testing is a black box random test generation technique for state machines that generates a large volume of test casesrandomlyandmerelybasedonthecombinationsofvarious possiblemessagesthatastatemachinecanreceive.thesecondone simpleexploration isawhiteboxtechnique thatgeneratesthetest cases by systematically exploring transitions of a state machine.
in thistechnique startingfromtheinitialstate outgoingtransitions in each state are explored and the trigger for each transition is collectedandisaddedasatestinputtoavector.theprocesscontinues untilthetestcaselengthcriterionismet orthecurrentstatehasno more outgoing transitions.bothofthese two techniquesgenerate random data for input parameters bounded by user defined ranges.
theauthorshaveshownthattheactioncodecoverageusingthe abovetwotechniquesisverylow.inthatexperiment thesetechniquesaregivenaconsiderableamountofresources intermsof thetestgenerationtimeandthenumberofgeneratedtestcases andyettheyfailtodiscoversomebugsintheactioncode.themain reasonisthatrandomtestingblindlygeneratestestsequencesand both techniques generate random data for messages.
therefore actioncodethatisinnestedconditionalsorisontransitionsthat need a long sequence of messages in a specific order to execute as wellastransitionsthatareguardedbycomplexpredicates arechallenging to execute.
we will show how our approach using concolic testingcanimprovethestatemachinetestcoverageconsiderably.
in the current experiment we define a time frame as the testing budget.thatis allthethreetechniques ourconcolicengineaswell as the other two techniques are executed during the allotted time budget and their performance is measured in terms of coverage and thediscoveredbugs.
weperformedourexperiments using a computer equippedwitha3.
ghz cpuand8gb of ram.
.
results .
.
testing coverage.
fig.9presents the performance of each technique in branch coverage.
based on the graph on the left after around minutes systematic concolic sc covers nearly all 11concolic testingformodelsof state basedsystems esec fse august tallinn estonia figure9 left branchcoverageforrsmmodel right coverageforothercasestudies.sc systematicconcolic rc randomconcolic se simpleexploration rt randomtesting thebranchesinrsm model 600branches .besides asthe numberof branches increasesto around sc starts to outperform random concolic rc considerably eventhoughboth techniques are concolic.
the reason is that in rsm there are a large number of transitions and branches which gives rise to large transition sets and consequently collecting a large set of constraints.
now as opposedtosc rcnegatesbranchesrandomly andconsequently many branches are executedmultipletimes.
the plots alsoshow thattheperformanceof randomtesting rt andsimpleexploration se isconsiderably lower thanthe othertechniques even though the results of se as a random technique is promising.
the graph ontherightshowstheresultsoftestingothersystemsexceptfor rsm performanceforthenon rsmsystemswassimilarandaggregatedbecauseofthepagelimit whereinthis casethenumberof branches are around collectively.
as the graph shows sc and rcshowalmostthesameperformance.observethatinthiscase thetechniquesdonotcollectlargenumberofconstraintsduring theexecutionofindividualsystemsduetorelativelylessnumber of branches as opposed to the case for rsm where hundreds of constraints are collected during an execution from the initial state to afinal state .
therewasaninterestingobservationregardingthestatesand transitionscoverage.theseandrttechniqueswereabletoachieve thesamecoverageastheconcolictesting butonlyinsomemodels.
for instance in some cases they were not successful in generating therequireddatatosatisfythetransitionsguards andhencethe generatedtestcasescouldonlyexecuteinitialstatesandtransitions.
that is final states were not reachedinthesecases.
note that given the fact that a state machine may encompass a large set of states transitions and consequently action code in practice it might be hard to cover all possible executions of the state machine using concolic execution due to numerous possible executions whichmightaffectthecompletenessofourapproach or the approach may not be scalable to larger models.
however the action code in state machines is usually relatively small but asexplained muchofthecomplexityofconcolictestingstatemachines lies in the dependencies between action code of different transitions and therefore constructing path constraints that can exhibittheirexecutions.
.
.
bugs found.
we foundseveral bugsin our case studiesthat are shown in table the message parameters with curly braces represent non primitive data i.e.
each value is a field in a structure data type .
concolic testing both sc and rc could catch thesetable bugsfoundby mcute bugdescriptionsampleinputsto reproduce the bug bug generated incorrect define macros fdm setup status bug indexout of bounds fdm create create bug wrong output generated by state machine ca lidarmsg lidarmsg bugs afterfewminutes secouldonlycatchthebug whichdid notneedcomplexinputmessagesanddata afteraround10minutes.
rt could not catch any of these bugs.
the bugs were confirmed by running the test cases generated by mcute on a raw version of the models modelisneither instrumentednortransformed .
modelcrashingbugs.
we foundabuginthefdmsystem.
this systemconsistsofseveralconcurrentstatemachines including dyeingsystem thatdynamicallyinstantiatesnew dyeingunits where each is dedicated to a dyeing task.
the transition action code belowisexecutedinaloopuntil totaltasks numberofdyeingunits arecreated thetransition sguardchecksthis .
dyeingunits isan array and its size is equal to totaltasks .
the attribute idxis always incremented whetherthe method createdyeingunit createsan object or not this method fails due to e.g.
type incompatibility or ifthereisnotenoughroominthecapsuleforanewinstance .
consequently eventhoughthe dyeinunits arrayhasstillroom the systemcrasheswithan index outof bound errorat line7.
dyeingtask dyeingtask dyeingtask msg getparam 2boolvalid false 3if dyeingtask temprature dyeingtask runtime 4void du createdyeingunit valid idx 6if valid dyeingunits du operation bugs.
an example of this bug was explained in previous sectionsinthecasystem.asexplained thecamustnotgenerate avibratemessageand reversesteering messagesatthesametime sinceitmaydistractthedriver .asshownintable mcutecould generate inputs for the system such that an execution violated this requirement.
on this case the dfs strategy helped us to find the bugquicker.tothisend wechoseaniterationlengthlargeenough in this case such that mcute could always reach transition t5and execute it so no iteration before executing t5 and finally mcutecould hit the bug.
bugs in the code generator.
if a state shas some incoming transitions each with some parameters the code generator should generate a macro using definestatement for each parameter as shownbelow suchthatallthetransitionsparametersarevisible atthestate s.inthe fdmcontroller we detectedabug thecode generatorgeneratedonlyone definestatement insteadoftwo at the state setupthat has two incoming transitions one to receive other component s status and one to initiate a dying task using the parameter runningdata 231voidcapsule dyeingruncontroller entryaction setup constumlrtmessage msg define data construnningdata msg getparam umlrtgen userregion begin 12esec fse august tallinn estonia rezaahmadiandjuergendingel cout temp data .
temprature value endl the harness triggers both incoming transitions to the state running in two iterations once by sending a status an integervalue to trigger the first transition and once by sending a dying task information an instance of the struct runningdata to trigger the secondone.inbothcases theinputparameterswerecasttointeger whichinthe latercasecausedarun time errorat line235.
related workand discussion program concolictesting approaches .mostof the work inthe literature address the development of concolic testing for programs .
program concolic testing was originally implemented in dart to automate concolic testing c programs with high coverage.
later cute was introduced to support pointers as input parameters.
crest was later developed with a set of heuristics to improve path coverage.
there are also multiple research works on generating optimal searchheuristicsforagivenprogram .exe andklee implemented the execution generated testing egt technique which again mixes concrete and symbolic execution but in a slightly different manner.
the tool pre processes the program tocheckwhethertherearefunctionswithconstantinputs sothe tool runs thosefunctionsconcretely.
this avoids unnecessary overheadsthatcouldotherwisebeintroducedbythesymbolicexecution .
other program concolic tools include pex where thetesterwritesparametrizedunittests put andpexgeneratestestinputsforallfeasiblepathsintheput.then theinputs are used to instantiate the puts in order to gain a set of unit tests that exhaustively test the program.
in the authors introduce a hybrid concolic testingtechnique that benefitsfromboth random andconcolictesting whererandomtestingisusedtoquicklyput the system under test into particular states which are otherwise expensivetoperformusingconcolictesting duetomassivenumber of execution paths .
when random testing saturates the algorithm automatically switches back to concolic testing to perform exhaustive searching to find anewcoveragepoint.
concolictestingofmodels .theresultsofapplyingthetoolsmentioned above are promising in terms of increasing branch coverage and the chance of finding bugs in programs.
however the techniques and tools above are not enough to conduct testing on state machines that compared with programs have a different execution semanticsandmodel anddifferentstructure.concolicallytesting the code generated from the models might seem like an option.
however for model level testing and tracing the executions to modelelements theactualmodelisrequired.moreover tothebest ourknowledge notoolforconcolicexecutionofc thelanguage of the generated code exists.
our approach leverages model information such that only the action code on transitions which we assume to be in c needs to be executed concolically.
there aresometechniquesandtoolsfortestingandanalysingstatemachinesthatuseeitherin house oroff the shelfsymbolic execution engines such as klee .
however observe that withsymbolicexecution itisdifficulttodealwith e.g.
heap based data pointers callstolibraryfunctions andtimers inourconcolic approach the engine has access to runtime information such as timer status .
polyglot for instance translates the structureandbehaviorofthestatemachines modeledindifferentsemantics intojavaandteststhemusingjavapathfinder .theauthors in proposeasemi automaticapproach sinceitrequiresamanual user annotation for symbolic execution of concurrent process.
however concolic execution and testing models to generate test casesdynamicallyandautomaticallyhasnotbeenstudiedbefore and we think our technique and tool is the first of this kind.
for instance the technique proposed in extracts event handlers fromajavaapplication takesasinputatargetlineforexecutionin aneventhandler andgeneratesasetofinputmessagesanddatato reach thattarget.
thistechnique isnotautomatic sinceone needs tospecifyastatemachinethatrepresentstheimplementations.the tool presented in also extracts a state machine from programs butforguidingtheconcolicexecutiontogainbettercoverage.similarly thetechniquepresentedin extractsastatemachinefrom awebapplicationandtestcasesarederivedfromthestatemachine butdoesnotusesymbolicorconcolicexecution.thetechniquepresentedin proposesanalyzingdependenciesbetweentransition guards input parameters and global variables to assign weights to each transition such that transitions with greater weights have higherpriorityforexecution sothetechniqueseemstoimprove coverageforstatemachineswithhighdependencybetweentransitions only.
the work in presents a technique for concolic testing simulink which is mostly used in automatic control and digital signal processing domain than for modeling real time applications models.inboththerecentlymentionedtechniques theauthorsdidnotconsideractioncodeontransitionsandthecomplex data structures used as input parameters between interacting components.modelsofreal timeembeddedsystemmayhaveafair amountofactioncodetocontrolthebehaviorofamodelandoften include complex data structures for messageexchanges.
othertechniques .there are test generation techniques for state machines that work basedondifferent coveragecriteria.comparedtoours thesetechniquesdonotusesymbolic executionanddonotconsidertheactioncodeonthestatemachine whichcan be the sourceof bugsinthe system.
conclusion and futurework in this paper we have described and implemented an approach for concolic testing of state machines.
we demonstrated our approach andtoolforexhaustivetestingbyconductinganempiricalevaluation on a set of uml rt models.
based on our results concolic testing could increase the branch coverage and could find more bugs compared to other techniques including random testing.
our approachhassomelimitations.forinstance inthecurrentimplementation we only support systematic testing of the transitions leaving a state which means we execute all the outgoing transitionsofastateinorder.moreover we use randomanddepth first techniques for action code branch negation and execution.
using a diversesetofheuristicsfortransitionandbranchselectionmight helptogainbettercoverageinmodelstesting.forinstance theconcolic engine might be able to rely e.g.
on the structure of the state machineorthedependencies betweenthemodelelements to prioritizethetransitionsandthebranchpointsandchoosetheones with the highest priority.
we intend to address these features in future work.
13concolic testingformodelsof state basedsystems esec fse august tallinn estonia