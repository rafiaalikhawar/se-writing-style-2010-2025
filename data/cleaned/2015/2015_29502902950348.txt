detecting sensitive data disclosure via bi directional te xt correlation analysis jianjun huang xiangyu zhang department of computer science purdue university usa huang427 xyzhang cs.purdue.edulin tan electrical and computer engineering university of waterloo canada lintan uwaterloo.ca abstract traditional sensitive data disclosure analysis faces two c hallenges to identify sensitive data that is not generated by specific a pi calls and to report the potential disclosures when the disclosed d ata is recognized as sensitive only after the sink operations.
we a ddress these issues by developing b idtext a novel static technique to detect sensitive data disclosures.
b idtext formulates the problem as a type system in which variables are typed with the tex t labels that they encounter e.g.
during key value pair ope rations .
the type system features a novel bi directional propagatio n technique that propagates the variable label sets through forwa rd and backward data flow.
a data disclosure is reported if a parame ter at a sink point is typed with a sensitive text label.
b idtext is evaluated on android apps.
it reports apps that have sensitive data disclosures with apps having log base d disclosures and having disclosures due to other sinks such as http requests.
existing techniques can only report .
of what bidtext reports.
and manual inspection shows that the false positiv e rate for b idtext is .
ccs concepts software and its engineering software testing and debugging security and privacy software security engineering keywords sensitive data disclosure bi directional text correlati on android apps .
introduction sensitive data disclosure has been a long standing challen ge for data security.
by accessing the disclosed sensitive inform ation adversaries can learn about the system and then conduct attack .
a prominent example is the openssl heartbleed vulnerability disclosed in .
the openssl versions with such a fla w allow remote attackers to retrieve sensitive data for exam ple user authentication credentials and secret keys .
attac kers canthen compromise the target systems with the disclosed sensi tive information.
the proliferation of mobile devices makes the situa tion even worse since mobile devices process a lot of sensiti ve user data.
previous studies showed that it is common that mobile a pps undesirably disclose sensitive user information .
many techniques have been proposed that work at the system level o r the application level static or dynamic .
haris et al.
provide a comprehensive list of the approaches to detecting sen sitive information disclosures in mobile computing .
all thes e approaches require definition of the sensitive data sources u sually certain apis whose return value is sensitive.
with the defini tion if forward data flow is observed between taint sources and sinks disclosure defects are reported.
later researchers realized that some generic apis may return sensitive values depending on the c ontext although they may return insensitive values in many ca ses.
supor and uipicker aimed to identify which user inputs on the user interfaces can be sensitive.
then the sensit ive inputs are associated with the variables in the code such that s tatic or dynamic forward data flow analysis can be applied to detect the potential sensitive user inputs disclosures.
sensitive us er inputs are identified in the context of the user interfaces which contai n text or graphical information to instruct what the users should ent er.
however the above solutions still have limitations.
sensi tive data may come from generic api methods not related to ui e.g.
loading data from some file or receiving data from network .
i n these cases most existing approaches would not work proper ly.
we cannot simply treat the generic apis as the taint sources as t hat will lead to a large number of false warnings.
in addition forwar d data flow analysis is insufficient.
in many cases a piece of data ma y be first emitted through a sink and then later typed as sensitive .
there may not be any forward data flow from the type revelation point to the sink point.
in this paper we develop b idtext a technique to detect data disclosures by examining the text labels correlated with va riables.
the text labels either from the code e.g.
the textual keys in keyvalue pairs or the ui provide rich information about the da ta contained in the variables.
b idtext extracts these labels and leverages a novel type system to propagate these labels through bo th backward and forward data flow.
data disclosures are reporte d when a parameter at a sink point is typed with a sensitive text ual label.
the bi directional propagation scheme is unique and different from the traditional unification based type inference sy stems.
it features the capability of avoiding undesirable unificat ion of text labels enabling a low false positive rate.
backward propag ation allows b idtext to capture cases in which data sensitiveness is revealed after the data is sent through some sink.
our work makes the following contributions permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
fse november seattle wa usa acm.
... .
artifact evaluated by fse 1classcampaignactivity 20 implements handler.callback 2campaignactivity act 3campaignactivity 20 campaignactivity a 4this.act a 6public boolean handlemessage message msg 7bundle b msg.getdata 8string dt b.getstring data 9log.d campaignactivity got data back dt sink 10runnable r newcampaignactivity 20 1 dt 11act.runonuithread r 12return false 15classcampaignactivity 20 1 implements runnable 16stringjsonstring 17campaignactivity 20 1 string data 18jsonstring data 20public void run 21jsonarray jsonarray newjsonarray jsonstring 22intlen jsonarray.length 23for inti i len i 24jsonobject json jsonarray.getjsonobject i 25string url json.getstring avatar url 26imageview iv ... omitted 27displayimage url iv omitted 28string un b json.getstring username b json.getstring created at 29textview tv ... omitted 30tv.settext html.formhtml un 31string c json.getstring content 32textview ctv ... omitted 33ctv.settext html.fromhtml c ... figure motivating example from app com.buycott.android .
we propose b idtext a novel method to detect sensitive data disclosures.
b idtextleverages constant text labels and features a novel type system that performs bi directional t ext label propagation.
we implement a prototype of b idtext for android apps and evaluate it on apps.
b idtext reports apps that have sensitive data disclosures with apps havin g log based disclosures and having disclosures due to other sinks such as http requests.
existing techniques can only report .
of what b idtext reports.
and manual inspection shows that the false positive rate for b idtext is .
bidtextis available at .
bidtext.
.
motiv ating example we use a real world android app com.buycott.android to motivate our technique.
it is an app that allows users to check t he company vendor of a product by scanning the product s barco de.
it even allows users to view the family tree of the company ve ndor.
users can then make decision on whether this is a company that rips off its customers so that they do not want to have bus iness with.
users can also start join campaigns against specific c ompanies .
fig.
shows a piece of simplified code snippet from the app.
th e app sends a request to the web server and obtains a list of post messages.
the http response is converted to a string in the app an d then sent to a handler via a message object.
the following operations are present in the code snippet.
at line a key value m appingdt sink data jsonstring jsonarray json json.getstring username 28call call assignment new instance call call 28username figure data flow solid arrows and type propagation dashed arrows for fig.
.
is retrieved from the message object.
then the data string of the message is obtained from the mapping at line .
right after th at the data string is written to the log file at line .
note that wr iting to a log file is usually considered as a sink for data disclosur es because log files can be accessed by malware1.
after the logging operation the app instantiates a runnable object with the data string at line which runs in the ui thread line to allow interactions with ui elements.
the data string is transmitted to the runnable instance via the instantiation at line .
inside the constructor at line the data is stored in a field variable jsonstring at line .
when the ui thread is running the run method at line is invoked.
the data string is converted to a jsonarray object at line which is then iterated.
every element in the array is a jsonobject line .
the app then obtains the url for the avatar image t he corresponding user id the time of creation and the content o f the post message by looking for the values via corresponding key s in the json object lines and .
all such information i s shown on some ui elements e.g.
line .
now let s consider the potential sensitive data disclosure in this running example.
based on the above description the data fa lling into the sink at line comes from the web server.
we later know that the data contains some sensitive user account informat ion.
in other words the app retrieves the sensitive user account in formation from the server and writes it to the local log file without any encryption.
this is a typical kind of undesirable informati on disclosure that emits sensitive information from serv er such as user account balance in bank account and employee salar y to local files.
traditional sensitive data disclosure analysis inspects t he data flow between some sensitive source point for example an api call whose return value can be easily recognized as sensitive e.g.
tele phonymanager.getdeviceid in android and a sink point e.g.
a file write or a socket send .
if forward data flow can be discovered from the source point to the sink point a disclosure problem is reported.
in this example while we do have data flow fro m the web server response to the logging operation but we canno t determine whether the response contains sensitive data from the operations along the data flow .
if we treat all data from server sensitive a lot of false alarms will be produced but if we simply ignore them we miss true disclosures as in this example.
different from the traditional disclosure analysis our te chnique 1the recent version of android has substantially mitigated t his problem by limiting access to log files.
but there are still a l arge number of devices running old versions of android.
note that bidtext is general to support various configurations of sink points.
170relies on the observation that the sensitiveness of data use d in applications can be recognized through examining the textual information involved in the operations.
such texts are constant s trings in either the code or the user interfaces.
we randomly sampled android apps and found that on average each app contains .
constant strings in layout files i.e.
xml files used to statically define uis and constant strings in app code.
these consta nt strings often provide rich information about what is being h eld by the corresponding variables.
for example in fig.
method call json.getstring username at line uses a constant string username .
we can infer that the json object contains some sensitive user id.
since the json object is part of the we b server response according to the work flow we can conclude t hat the response contains sensitive information.
thus the logg ing operation at line should be reported as a sensitive data discl osure.
note that even if we recognized that the json object at line contains sensitive information we could not detect the dis closure problem using traditional analysis techniques that try to fi nd forward data flow from source points to sink points.
we show the da ta flow via solid arrows in fig.
starting from retrieving the d ata from the key value mapping line .
if we treat line as a so urce point we cannot get a forward data flow path from the source po int to the sink point.
thus the disclosure defect is still missed after we augment traditional techniques with our new sensitive data recognition method.
bidtextsolves the problem by introducing bi directional propagation.
instead of propagating tags like tainted anduntainted in traditional techniques our approach uses the constant str ings as the tags and propagates both backward and forward.
as the dashed arrows in fig.
show constant text username is propagated backward from the method call at line to the variable json created at line and so on.
consequently variables jsonarray jsonstring data and finallydtare tagged with the text username .
intuitively it means all these variables contain sensit ive user id information.
next we forwardly propagate the tag fro m line to the sink point at line .
therefore the logging statemen t operates on variables that are associated with text username .
by applying this approach to the whole code snippet we obtain the set of correlated text as campaignactivity got data back data avatar url username created at content .
the first two textual tags are associated to the variable directly at the s ink point.
tag data is propagated to the variable at the logging statement in a forward manner.
the remaining texts are propagated to th e sink point via a bi directional manner discussed above.
bidtext also associates ui texts to variables.
ui often contains texts that also indicate the sensitiveness of data sho wn on the ui see .
we examine the corresponding layout file to get the texts add them to the tag set of the related variables and propagate them like the texts found in the code.
in the example we can find several code locations that interact with the ui e.g.
line through which we identify the corresponding layout files to c ollect ui texts.
however the content of the ui is dynamically creat ed and none of the ui elements holds constant texts.
therefore no g ui texts are propagated to the sink point in this example.
next we apply a natural language processing nlp technique to the tag set of the sink point to find out if the texts can tell the sensitiveness of the variable dt.
among the collected texts username matches a predefined sensitive keyword.
thus our technique r eports a sensitive data disclosure problem for the logging op eration at line .
.
design we propose b idtext a static bi directional text correlation anal program p s statement s v t constant string in code v i ui related id v c values of other types v v1 unary assignment v v v2 binary assignment call m v a vf v a vfactual formal arg v return m v r m returns v rto v v apicall m v a api call to method m if v s t else s f loop s loop structure v vt vf value merging in ssa variable v method m string t id i value c non str non id values figure language.
ysis approach to detect sensitive data disclosures.
b idtext combines both the bi directional propagation and the new appro ach that uses internal constant texts to identify sensitive variabl es as illustrated in section .
.
language abstraction to simplify our discussion we introduce an abstract langua ge.
the language is presented in fig.
.
we only model the languag e features that are related to explaining the text correlatio n analysis and the bi directional propagation.
others are abstracted away or simplified.
as we discussed in section we leverage the cons tant texts in the code as well as in the ui to tag variables and deter mine whether sensitive data is disclosed at sink points.
therefo re constant strings in the code and constant ids that are associate d with ui are of special interest and explicitly modeled in the lang uage.
for simplicity we do not allow constant strings ids to appe ar in complex operations e.g.
binary operations and method calls.
for such scenarios the constant is first assigned to a variable which is further used in the complex operation.
this is similar to how android apps handle constant values in dex bytecode.
for examp le the method call json.getstring username at line in fig.
is converted to two statements tmp username json.getstring tmp .
an invocation to method m vf is modeled by two separate statements call m v a vf passing the actual argument va to the formal argument vfandv return m v r returning the value invrinm tovin the caller.
the separation allows us clearly model the data flow at the entry and the exit of a method call.v apicall m v a abstracts invocation to an api functionm whose implementation is usually excluded or not available during analysis e.g.
the runtime c library and the framework methods for android apps.
the language also supports conditional branches and loops.
there are different loop structures such as for loops andwhile loops.
we ignore these differences and use a loop statement to model them.
loop conditions are not relevant to our analysis and he nce not modeled.
any side effects in the loop conditions are ex plicitly modeled as assignments in the loop body.
our language is a kind of ssa language so that function is used to merge values from different branches of a predicate .
as we will show later in section .
.
functions require delicate consideration during bi directional propagation.
.
type system and bi directional propagation as discussed earlier we use the constant texts in either the code 171const binding v t ui bindingresource id i v i unary assignment v t v1 t v v1 binary assignment v t v1 t1 v2 t2 v v1 v2 phi assignment v t v1 t1 v2 t2 v v1 v2 method call param va t vf t call m va vf method call return v t vr t v return m vr api call va t v t v apicall m va figure bi directional propagation rule.
or the ui to tag the correlated variables and propagate the ta gs bidirectionally.
we formalize this approach in a type system i.e.
the set of tags associated with a variable is treated as the type o f the variable .
since the type is a set we also call it a type set in this paper.
the mappings from variables to their type sets form th e context of the type system which is iteratively updated during analysis until a fixed point is reached.
for example at the be ginning is empty.
upon a statement tmp username is updated to tmp username .
at this point we have tmp username which means under context variabletmp is typed with set username .
in other words tmp username where tmp evaluates variable tmp in the context to obtain the corresponding type set.
when a statement is evaluated the context may be updated.
we use s to indicate that under context evaluating statement supdates the context from to .
we use to represent an update to the context.
specifically if no mapping is found for variable var in context the mapping is added into the context.
but if there exists some ma pping forvar the rule substitutes the existing type set for var with the given type set t. multiple mappings can be updated simultaneously e.g.
updates the context for two variablesvar andvar .
given two type sets tandt t t unions the two sets while t t returns a new type set which contains all elements belonging totbut nott .
with the language in fig.
and the above definitions we define the bi directional type set propagation rules in fig.
.
the propagation is iterative.
that means once the analysis starts it does not terminate until the context reaches a fixed point.
.
.
binding constant value as mentioned earlier we focus on constant texts in the code a nd the constant ids that are associated to ui.
an assignment of a constant string to a variable adds a new mapping from the variabl e to a set holding the string to the context.
for a constant id we ne ed to make sure the id is indeed a resource id e.g.
layout id in android apps or an id for a specific ui element .
this check is modeled b y predicateresource id .
if the prerequisite satisfies updating the context is similar to the constant string assignment ex cept that the type set is the extracted texts from the corresponding ui through functionextract text .
for instance if the constant id is as sociated with a typical login screen the extracted text set may often be username password login .
.
.
propagation for assignment rule unary assignment updates the context for both the lhs and rhs variables with the union of the two separate type sets .
note that it allows the tags from lhs to propagate to rhs and vice versa through the union operation i.e.
bi directional propagation .
use the statement jsonstring data at line in fig.
as an example.
assume before evaluating this statemen t jsonstring avatar url username created at content and data data via previous evaluation steps.
after evaluating this statement the type sets for both variables jsonstring and data are updated to avatar url username created at content data .
this shares some similarity with type unification in classic type inference.
however as we will see next unification does not properly model the intended propagation behavior for bi nary operations and functions.
for a binary assignment we cannot simply union all the type sets of the lhs and rhs variables and associate the resultant type set to all the variables which is what classic type inferenc e would do.
we observe that this is undesirable as it allows the type s et of a rhs variable to be propagated to another rhs variable while the operation does not induce any data flow between the two variab les.
intuitively assuming the two rhs variables are v 1and v2 v1being associated with a sensitive tag does not entail v 2having the same sensitive tag by the operation .
thus as specified by rule b inaryassignment the propagation is conducted as follows.
the ty pe sets of the rhs variables are unioned and inserted to the type set o f the lhs variable.
only the part of the lhs type set that is not in th e type set of v 1is propagated to v 2and only the part of the lhs type set that is not in the type set of v 2is propagated to v .
there is a corner case in which the two rhs variables are the same one e.g.
a b b. the updated type set for bis b a b which is equal to a b .
in other words this special case behaves the same as a unary assignment.
the propagation for statements has the same nature rule phi assignment .
we use a real example from an android app com.mojo.animewall paper to show how our propagation rule for statements eliminates false alarms.
the simplified code snippet is shown in fig.
5a.
if a certain condition satisfies the device id is assigned to var iablexat line .
the detail of acquiring the device id is omitted but ev en1721if ... 2x getdeviceid x is tagged with android id else 4x some random uuid gen random value for x 5log.d random x sink 7use x a simplified code snippet.
x x x x x sink android id b data flow and type propagation.
figure code example and bi directional propagation for from app com.mojo.animewallpaper .
tually a constant string android id is added to the type set of x. if the condition doesn t satisfy a random value is generate d as the requested id at line and stored to variable x which is immediately used at a sink point at line .
after the branch variabl ex whose value is either the real device id or a random value is u sed elsewhere.
from the perspective of representation we know that right before thexis used at line we have a statement as x x x .
the data flow for the several occurrences of xis described by the solid arrows in fig.
5b and the propagation relations a re shown by dashed arrows.
consider a naive bi directional propagation that simply un ions all the type sets.
during the first iteration android id is propagated tox via forward propagation.
nothing is backwardly propagated to x orx fromx .
therefore at the end of the first iteration x x android id and x .
then during the second iteration if we directly propagate the type set of x to both x andx we would get x android id which is later propagated to the sink point at line .
thus a sensitive data disclosure is reported which is a false alarm.
in contrast our propagation rule supports the mutual exclu sion of the type sets in the two respective branches.
specifically w e only backwardly propagate x x i.e.
an empty set to x .
at last the type set of x stays unchanged and the sink point does not observe any sensitive type for the variable.
t hus no sensitive data disclosure is reported.
.
.
propagation for method calls propagation through a method call occurs at passing argumen t from the caller and returning value from the callee.
therefo re we define two separate rules for these two events.
note that thes e two rules handle method calls whose implementations are includ ed in the analysis.
we also propose a special rule for propagation over api functions the implementations of which are typically i nvisible during analysis.
rules method call param and method call return union the type sets.
a concrete example for rule method call param is the i nstantiation call at line in fig.
.
the constructor at line is invoked and the value held by variable dtis passed to variable data .
then constant value data associated with dtis propagated to data and username associated with data is backwardly propagated todt.
rule api call does not directly propagate the type sets betw een parameters and the return value.
b idtext relies on the model for the api function for proper propagation.
prior static taint analysis have shown that it is effective to simply propagat e from all parameters to the return value and the receiver object i.e.
this reference in instance method calls .
however this naive ap proachcheckalert if v c alert v m a specialized statement.
check alert vc t vm t if vc alert vm b propagation rule.
figure abstraction and propagation rule for check andalert cases.
does not work well in bi directional propagation.
we need to investigate the type correlations for the variables involved in an api call including all the parameters and the return value.
some api functions may not support fully bi directional pro pagation among the variables.
for example variable name can be used to type value in statement value hashmap.get name but not the reverse according to the semantics.
specifically if name holds some sensitive constant strings we can infer that value may hold sensitive information but not the other way around .
if we ignorethis reference after evaluating the statement under context we have name name and value value name .
many api functions on the other hand can be applied with the naive propagation policy unioning the type s ets of all variables.
for example we have ret str ret str after evaluating statement ret str.touppercase under context .
in the rule the behavior depends on functions model fwd andmodel bwd which define the propagation policies from vatovand from vtova respectively.
we formalized our approach to identifying and bi direction ally propagating constant texts in a type system and developed a s et of propagation rules based on our abstract language in fig.
.
w hile the rules are general for our language in practice we need to perform a number of enhancements to the rules to handle real wor ld language program features.
these enhancements are discus sed in next section.
.
practical enhancements there are two main practical enhancements to our formal mode l that are critical to the effectiveness of b idtext.
.
.
check and alert it is common in real programs to prompt some alerts to the user or write to the log file if a condition check fails.
in this case we can use the alert log message to infer what the correspondin g variables involved in the condition check may hold.
for example an android app can alert the user about some previous errors e.g.
some required inputs are missing by showing a short message on the screen.
a typical implementation looks like the followi ng.
1if str null str.isempty 2toast.maketext this please enter password we can type variable str with the constant text please enter password and propagate it through the aforementioned rules.
the abstraction and the corresponding propagation rule are shown in fig.
.
this applies to a set of api functions called the alert functions.
.
.
string concatenation string concatenation is common in real world apps.
a concat enation operation may involve both constant values and multi ple variables.
if we simply union the type sets of all the involve d variables and update the variables with resultant type set we ma y introduce false positives.
furthermore the associations be tween the constant strings involved in the concatenation and the va riables involved in the concatenation also need to be properly ide ntified.
173const0 builder0const1 builder1 unbuilder2 pbuilder3 url username pwd pwd figure propagation graph for a simple string concatenati on.
str apiapi w str m va e string partition m e v apicall m va figure propagation rule for string concatenation.
a simple strategy that associates all constant strings to al l variables also produces a lot of false positives.
for example buildin g a url often involves multiple variables each holding a value as p art of the http request.
the variables can be either sensitive e.g.
password or insensitive e.g.
user comment .
we need to distinguish the exact types correlated to the variables.
consider the fo llowing example in which a typical url is constructed.
1url un pwd p at the bytecode level the above statement is converted to 1builder0 new strinbuilder 2builder1 builder0.append un 3builder2 builder1.append pwd 4builder3 builder2.append p 5url builder3.tostring assume the model for api stringbuilder.append entails fully bi directional propagation i.e.
we propagate the type sets of all involved variables to each other.
the constant st ring is propagated to builder0 build er1 un builder2 andp.
a later text analysis would indicate that bothunandpare associated with the sensitive text username which is incorrect for variable p. similarly pwd will be propagated to un which causes a false alarm.
however if we do not allow the propagation from the stringbuilder instance e.g.
builder0 to the appended variable e.g.
un that is the red and blue edges are removed from fig.
then neither username nor pwd could be propagated to unor p. as a result we cannot infer that these two variables may hol d sensitive information.
the expected propagation according to the semantics of the url string is that username is propagated to un and pwd top exclusively.
we observe that it is impossible to enforce such p ropagation through api models e.g.
the model for append as an api call may only represent a local operation that does not ha ve the global view of the concatenated string.
to address the pr oblem we need to analyze the entire concatenated string produced a t the end.
in our example we ought to examine the final result assoc iated withurl in order to associate the appropriate text to variables unandp.
therefore we need to enhance our type system with the following string analysis.
rule str api in fig.
determines if an api call has a string ar gumentvawith a well defined format through function api w str .
for example new url str is such a function as it implies the variable str is a string of the url format.
if so the string is of interest.
b idtext computes an abstract string eforva which is stored in a string context that maps a variable to an abstract string.
an abstract string is a regular expression including both constant strings and variables .
the abstract string is partitioned by the function string partition so that the variables in the regular expression are associated with the appr opriatestrcat v1 e1 v2 e2 v strcat v1 v2 strcat nil v1 nil v2 e2 v strcat v1 v2 str const assign v t str if st t sf f t v et f v ef if st else sf str loop closure s v v e v e0 loop s str loop simple s v e v ne ationslash e loop s figure computing abstract strings.
texts.
for the above example the rule produces un username p pwd .
we then combine into the current context and further propagate the generated texts.
next we will first explain how the abstract strings are computed and then t he string partition function.
the rules for computing abstract strings are shown in fig.
.
the interpretation of the rules is similar to that for our type sy stem.
one difference is that we use the string context instead of the type context .
rule strcat simply concatenates the two abstract strings of the operands.
rule strcat nil handles the case in which the first operand does not have any mapping meaning that it is a string variable encountered for the first time.
in this case the variable itself is concatenated to the resulting string.
it is similarly handled when the second operand does not have mapping and the rule is elided.
rule str const assign handles the constant string assignment.
rule str if specifies that for a conditional statement b idtext computes the string contexts for the true and false branches separately.
for any variable that is present in the string contex t s the resulting abstract string is an alternation of the abstract strings in the branches.
consider the following code snippet.
1if c str strcat userid uid 2elsestr strcat sessionid sid the abstract string for variable str is userid uid ses sionid sid .
rule str loop closure specifies that for a loop b idtext first computes the string context for the loop body with an empty st ring context and then aggregates the resulting abstract strings to the original string context.
in particular if the abstract str ing for a variablevalso contains v it indicates the resulting string has recursive structure caused by the loop b idtext hence associates vto a kleene closure in the context outside the loop.
tail recursi on is similarly handled.
currently b idtext only handles regular languages which is sufficient for most cases we encountered.
ru le str loop simple specifies that if there is no recursive stru cture the abstract strings are simply copied from the context of th e loop body to the context outside the loop.
for the following examp le bidtext produces the abstract string output a for variablestr.
1str output 2for ... 3str strcat str a as shown by rule str api the abstract string at an api that specifies the format of the string is partitioned to acquire t he texts for the variables within the abstract string.
this is done by calling 174string partition .
this function has a number of built in parsers that can parse the different string formats based on the api name.
for example if the api is url it uses the parser for url.
particularly the parser searches for symbol ?
the part after the symbol is parsed by with the first part being the key and the second part the value.
if the key is a constant tand the value is a variable v is updated with the mapping from vtot.
bidtext also has parsers for other formats such as sql queries.
for example two mappings v1 password v2 userid can be extracted from an abstract string denoting a sql update update table set password v1 where userid v2.
for the prior url example append is essentially a strcat .
according to the rules the final abstract string for url is un pwd p. it is partitioned so thatunis mapped to username andpis mapped to pwd .
.
disclosure analysis after the type set computation converges b idtextchecks whether arguments at the sinks points hold any sensitive data vi a textual analysis.
if the type set information indicates the sensiti veness of an argument we report a potential disclosure.
algorithm sensitiveness determination.
determine sensitiveness t s kwd for allt tdo t preprocess t ift matches in kwd then ift is a word ort doesn t match any negation template then s s t end if end if end for the process to determine the sensitiveness of a variable wit h a set of associated constant texts is presented in algorithm which assumes the text set tand a set of sensitive keywords kwd .
for each collected string i.e.
word phrase or sentence b idtext first conducts some preprocessing.
for example emailaddress is converted to email address .
if a string contains more than one sentence it is split using the standard sentence division m ethod implemented in stanford parser .
if the string matches a ny keyword we check whether it is a single word.
if so we put the string into swhich holds all sensitive strings.
scan be used to decide what sensitive information is disclosed after the al gorithm finishes.
if the string is a phrase or a sentence we need to che ck if it is the negation of a sensitive keyword.
for example do not enter password here tells the user that the input field should not contain any password.
even though the string matches a sensi tive keyword password we do not consider it sensitive.
so if the corresponding variable does not have any other associated sens itive texts it is treated insensitive and the sink does not have a s ensitive data disclosure problem.
we use stanford parser to parse a phrase or a sentence int o a syntax tree which is then converted to a dependency relati on please refer to .
based on the dependency relation b idtext searches the negation word not and then checks the auxiliary word right before the negation word.
it also examines if ther e exists a subject noun word before the auxiliary word.
by combining t he auxiliary word and the possible subject word b idtext can identify whether the phrase sentence is imperative or declarat ive.
for example do not and you should not are imperative negations but you did not is declarative negation.
b idtext only considers the imperative negation as a negation of sensitive keyw ord .
in such cases the text is not sensitive.
.
implementation we implemented b idtextto detect sensitive data disclosures in android apps.
b idtextis built on top of wala which parses the android dex bytecode to intermediate representations.
we implemented the algorithm in to collect possible entry points e.g.
oncreate for an activity in the target android app.
for each entry point b idtext builds the call graph and the dependency graph.
the constant strings are propagated on the grap hs.
we do not distinguish the correlated text for each ui element as in .
instead all elements in one layout file are associated with all the texts found in that layout file.
bidtext relies on a keyword set to determine the sensitiveness of computed texts.
to acquire the keyword set we ran b idtext on randomly selected apps and extracted all texts disc overed for each sink.
we then manually inspected these texts to cons truct the keyword set.
in order to detect traditional data closure s that are due to data flow between source apis and sink apis instead of texts we assign some sensitive textual keywords to the so urce apis that must expose sensitive information so that b idtext can propagate the keywords.
for example we assign imei to api telephonymanager.getdeviceid .
we leverage stanford parser as the engine for analyzing phrases and sentences.
b idtext currently only supports english.
for better efficiency b idtext also performs on the fly type set reduction.
specifically when a text set reaches a certai n size garbage collection is conducted by filtering out the texts in the type set that do not indicate sensitiveness and those that are red undant.
.
ev aluation all experiments are performed on an intel core i7 .4ghz machine with ubuntu .
.
the task of analyzing each app is giv en the maximum memory of 10gb and the maximum analysis time of minutes.
the subjects are a collection of android a pps downloaded from google play in march .
the sink points used in the evaluation contain all the logging operations in android and the apache http access apis that are commonly used in android apps.
this is also the standard setup for many existing static taint analysis .
the other types of sink points can be easily added to b idtext.
.
pilot study as discussed earlier b idtext heavily relies on accurate propagation models for api method calls.
however android framew ork contains thousands of api functions making it almost infea sible to manually build the models for all api functions.
our approac h is to randomly select apps and run b idtext on these apps.
then we inspect the results to discover popular api functions and create models only for those functions.
these models are later used in the larger scale study.
during the pilot study we also observe a kind of false positi ve that appears frequently.
it is caused by a facebook library u sed by many apps.
the library logs an error message when it fails t o obtain the device id.
the code snippet is abstracted as follo ws.
1try acquire device id 2catch exception e utility.logd android id e the message eis typed with android id which is a sensitive keyword.
but the meaning of this message is indeed that the ac tion of acquiring the device id fails.
solving this issue require s in depth semantic analysis of ewhich is not supported by b idtext.
since the pattern is fixed we post process all the reports to filter out this pattern for both the pilot study and the later large scale stu dy.
figure distribution of accumulative analysis time for a ll apps.
.
.
.
.
.
.
.
.
.
apps cdf figure distribution for the analysis time in minutes o f the apps reported with sensitive data disclosures.
.
unification vs. bi directional propagation in classic type inference given an assignment statement su ch as z x y andz x y the updated type sets of x y andzare the union of all three original type sets.
in section .
.
r ules binary assignment and phi assignment in fig.
we mentio ned that such a unification based approach may produce a lot of fal se positives and hence b idtext makes use of a bi directional propagation strategy that avoids propagating type sets between righthand side operands i.e.
xandyin the example .
in this experiment we want to compare these two propagation strategies.
due to the lack of ground truth such a study requires manuall y inspecting the reported disclosure defects and determinin g if they are false positives.
among the apps tested in the pilot s tudy we selected the first apps whose data disclosure path i.e.
the data flow subgraph that includes the path from the source to th e sink and the path that the sensitive text is propagated from its or igin to the sink involves statements and or binary operations with the unification based propagation policy.
we re run b idtext on the apps with the bi directional propagation policy and comp are the two sets of results.
among these apps of them are reported by both the unification policy and the bi directional policy of them con tains flows only reported by the unification policy.
note that the tw o do not add up to because some apps have multiple reported disc losures some being reported by both policies and the others be ing only reported by the unification policy.
we manually studied the cases reported by the unification policy and found that the y are all false positives.
we have shown one sample false positive in section .
.
.
.
large scale evaluation in this experiment we use apps not covered by the pilo t study.
the apps have a minimum size of .46kb for the apk files and a maximum size of .94mb.
the average size of the apk files is .17mb.
among these apps there are two that do not con tain any dex bytecode in the apk files.
for the remaining apps the minimum size of the bytecode files classes.dex is bytes and the maximum size is .32mb.
the average size of the bytecode files is .53mb.
.
.
results the total analysis time for the apps is .
hours.
fi g. presents the distribution of the cumulative analysis time f or all the apps.
we divide the total analysis time into three par ts according to how the analysis on an app terminates.
as mentione d above we set the analysis timeout to minutes for each app.
in our evaluation apps .
time out and the total analy sis time account for of the total time consumed for the text only .
api only .
text api .
text gui .
api gui .
text api gui .
gui only .
a by sources.
logging only .
non logging only .
both .
b by sinks.
figure breakdown of the reported apps.
.
.
.
.
.
.
.
traditionalsupor bidtext a all sinks.
.
.
.
.
.
.
.
traditionalsupor bidtext b non logging sinks.
figure comparing bidtext with static tainting tracking specific apis and supor .
apps.
we have other apps of which the analysis ran out of memory.
the total time for these apps accounts for .
for the remaining apps that finished normally take only of t he total analysis time.
observe in fig.
that the first ap ps take less than of the total time.
among the apps the mini mum analysis time is .
seconds and the maximum time is .
seconds.
the median is .
seconds while the average time is .
seconds.
the largest app that terminates normally has the ap k size of .94mb and the bytecode size of .32mb.
overall b idtext reports apps with sensitive data disclosure problems.
we show the analysis time distribution of the se apps in fig.
.
the blue bars show the number of apps that finished within a time period.
for instance apps took more than m inutes but less than minutes.
we also see that apps timed ou t in the experiments although partial results were collected b efore the analysis terminated.
the red line presents the cumulative a nalysis time .
of the apps were analyzed within minutes.
we ca n conclude that b idtext is efficient to be applied to market scaled apps.
we also show the breakdown of the apps by the sources of data disclosures in fig.
12a.
there are three types of sources text constant texts in the code that denote sensitive data api sensitive api recall that b idtext also detects data disclosures originating from sensitive apis by associated artificial texts to the source apis such aslocation.getlatitude and ui constant texts retrieved from user interfaces that denote sensitive data.
observe that the majority of disclosures are can be detected by the s ensitive text labels.
some data disclosure defects can be recogn ized through multiple sources e.g.
text api meaning that there are some bi directional data flow paths from a sensitive ap i to a sink and from some constant text to the same sink.
consider the following example.
the data flow path denotes a disclosure originating from text i.e.
android id and the path denotes a disclosure originating from api i.e.
getdeviceid .
1if fails to obtain imei 2id settings.secure.getstring resolver android id else 4id telephonymanager.getdeviceid 6json.putstring id id 7http sink json.tostring sink the breakdown of the apps by the sink types is shown in fig.
12b .
note that .
of the reported apps contain disclosures due to logging.
although data disclosure through logging is subst antially .
.
.
.
.
.
.
.
.
.
.
.
.
figure length distribution of the emitted paths for the r eported apps.
x axis shows the length of the paths.
table manually inspected evaluation results for apps .
text api ui total only fp mitigated by access control in the latest version of android it is still a security concern for legacy android systems such tha t most existing works report these disclosures.
about .
of the reported apps .
of all the apps evaluated contain s ensitive data disclosures due to to non logging sinks.
they are s erious threats even in the latest android systems.
fig.
shows how b idtext compares with an implementation of the traditional taint tracking technique tracking disc losures from source apis through forward data flow similar to and su por which is a technique that tracks disclosures from s ensitive ui elements e.g.
input boxes through forward data flow.
bidtext always reports a super set of those reported by the classic tainting and supor.
in the figure the numbers of apps repo rted by tainting and supor are normalized to those reported by b idtext.
observe that they only report .
and .
of those reported by b idtext respectively.
even combining the two can only detect .
.
if only taking non logging disclosures i nto account they report .
and .
of those reported by b idtext.
this attributes to both the new text label correlation analy sis and the bi directional type set propagation strategy.
we present the length distribution of the emitted data discl osure paths for the apps in fig.
.
though some paths tend to be very long more than elements most of them are relativ ely short.
more than of the paths require less than steps fr om the origination of the sensitive texts to the sink points.
false positives and false negatives.
it is critical to understand the quality of the reported defects.
due to the lack of ground tru th we had to perform manual inspection.
studying the full set of re sults is infeasible.
hence we randomly chose reported apps wi th a uniform size distribution for manual inspection.
the resu lts are presented in table .
the columns indicate the sources of the disclosures.
row total shows the total number of reported apps for each sources.
row only shows the number of apps that only have reported disclosures falling into one category.
the last row shows the number of fa lse positives.
observe that the false positives are exclusive.
therefor e the false positive rate is .
the causes for false positives wi ll be discussed in section .
.
.
we do not count the false negativ es because we don t have the ground truth.
among the apps where disclosures are reported by code text analysis apps contain paths that can be only detected by o ur approach via text correlation analysis i.e.
the data used at sink points neither come from any ui inputs nor from traditional source a pis.
in other words of them cannot be detected by classic taint ing or supor.
this ratio is consistent with that in fig.
for the la rger experiment.
the other reported disclosures have the sensit ive data coming from these two categories of sources.
they are report ed by both b idtext and the existing technique s .
another interesting finding is that b idtext often produces a shorter disclosure path.a typical scenario is that there is a long data flow path from a u i input element to a sink.
however mid way through the path th e sensitive data is put get to from some container with a se nsitive textual key which allows b idtext to report a shorter path from the put get operation to the sink.
the benefits of shorter pat hs are two folded less human efforts needed for inspection and de tecting more disclosures because the full path from the source poin ts to the sink points might be complicated involving inter compone nt communications such that the tool may fail to traverse the full path .
.
.
case studies we observe many cases in which sensitive textual keys appear together with data in key value operations e.g.
constructing a name value pair e.g.
com.gunsound.eddy.fafapro inserting data into a hash map e.g.
me.tango.fishepic retrieving adding data to persistent storage through an instance of sharedpreferences e.g.
com.ifreeindia.sms mazaa or putting data into a json object e.g.
com.mobilegustro.war.battle.air.force .
b idtext recognizes the sensitiveness of corresponding data via text correlation a nalysis.
in the following we show a code snippet adopted from app com.
pro.find.differences that discloses sensitive device information to web servers.
1voidobtaindeviceinfo 2tcore.aid settings.secure.getstring resolver android id 4voidconnectwebserver 5map map newhashmap 6safeput map android id tcore.
aid 7string params converturlparams map omitted 8http sink params sink 10voidsafeput map map string k string v 11map.put k v the method call at line returns system information based on the given key value.
for example a unique id for the device is obtained if android id is given as the key.
if the key is enabled input methods the return value contains a list of input methods that are currently enabled.
therefore the sensitivene ss of the return value depends on the key.
b idtext works by correlating the textual key with the return variable to decide whether a l ater sink operation involves sensitive data or not.
in the above example the variable tcore.aid is typed with the constant text android id at line which is later propagated to parameter vof method safeput at line .
vis inserted into the hash map at line .
note that android id at line is propagated to k which is further propagated to the hash map and variable vaccording to the corresponding api model for propagation.
along the data flow the constant text is propagated to params that is eventually used at the sink point at line .
b idtext reports the data disclosure.
.
.
false positives one of the false positives is caused by unmodeled api functions.
the corresponding code snippet is from app at.zuggabecka.
radiofm4 .
1uidx cursor.getcolumnindex username 2iidx cursor.getcolumnindex id 3id cursor.getlong iidx 4sink id at line a sensitive keyword username is correlated with the receiver object cursor that is related to a database query.
then all uses ofcursor propagate the text label to other variables e.g.
the return value of a relevant method call.
thus idat line is typed 177with username .
later when it is used at a sink point b idtext reports a sensitive data disclosure after analyzing the cor responding type set.
to remove this false alarm we can build a model for a pi cursor.getcolumnindex key to only propagate type set fromkey to the return value avoiding propagating to the receiver object.
then in the above code snippet only variable uidx is typed with username .
variable idthat appears at the sink point is only typed with id which is not considered as a sensitive keyword.
therefore there is no disclosure problem with the m odel.
all the other nine false positives are caused by incorrect re cognition of text two for code text and seven for ui text.
app com.netcosports.andalpineski contains a text label as apps lang which indicates the language of the app.
however it contains a predefined sensitive keyword lng which is mostly used as an abbreviation of longitude .
failing to understand the meaning of the text b idtext incorrectly reports a sensitive data disclosure.
app com.wactiveportsmouthcollege has a ui text of pin to desktop where sensitive keyword pin is used as a verb.
failing to understand it leads to a false positive.
all other false posi tives have similar causes sensitive keywords in a phrase or sente nce do not indicate any sensitive information.
possible soluti ons for this type of false positives include integrating more advan ced nlp techniques with program analysis to understand the meaning s of the text.
.
discussion one limitation of b idtext lies in that the text in code may not be in a generalized format.
for example some developers use lng for longitude whereas others use long for it which is a more general word in english.
if we treat long as a sensitive keyword we can expect many false positives.
in addition developers tend to combine several words or abbreviations into a single word which makes it more difficult to determine whether the correlated d ata are sensitive or not.
in the future we plan to improve our approach in the followin g aspects.
the first one is to discover text labels in the names o f method calls if they are not obfuscated and variable field names.
the second improvement is to consider code comments if sourc e code is available.
the third one is to improve the nlp aspect b y putting the keywords in their program context.
so we m ay be able to recognize long indeed means longitude.
.
related work a lot of prior research has focused on detecting sensitive da ta disclosures either statically or dynamically for mobile apps .
most of them consider specific apis as sensitive sou rce points while b idtext analyzes text labels to determine if a variable can hold sensitive data.
s usi gives a comprehensive list of the data sources in android but it does not assume the data obtained from the sources must be sensitive.
in addition ev en if the state of the art static detectors e.g.
flowdroid and droidsafe had been enhanced with various ways of determinin g data sensitiveness they would likely not be able to detect s ome sensitive data disclosures reported by b idtext such as our motivating example where the sensitiveness of the data is deter mined after the sink point and there is no forward data flow from the sensitiveness revelation point and the sink point.
b idtext however leverages bi directional propagation to address this prob lem.
huang et al.
developed type based taint analysis to detect information leaks in java based web applications and android app s via type inference .
they abstract the information flow a nalysis into a type system and check if any type error occurs.
the irtechnique scales well without using advanced points to ana lysis .
their technique still follows the traditional definiti on of data disclosure which is a forward data flow path from the source t o the sink.
in other words it does not propagate data sensitivene ss in a backward fashion.
as such it may not be able to report many di sclosures reported by b idtext including the motivating example.
furthermore their type system does not leverage text infor mation.
ernst et al.
also developed a type based taint analysis system .
their technique associates a few security types such as lo cation internet and sms to sources and sinks and have a set of predefined policies such as location can only be compatible or type checked with internet.
so if location reaches a program point with the sms type a leak is reported.
their flo w analysis is forward whereas b idtext is bi directional.
and b idtext leverages text labels.
supor and uipicker discover sensitive informatio n on user interfaces through static analysis.
however they e ssentially belong to the traditional forward data flow based tec hniques.
asdroid collects the set of api calls in an event handler and compares the meaning of these api calls with the ui text of the event to detect unwanted unexpected app behavior.
in contr ast bidtext types individual variables in the program with text labels and leverages a type system that allows bi directional propagation.
researchers also combine code and comment analysis to detect bugs or inconsistencies .
we envision com ment analysis can leverage our bi directional type system so tha t the information in comments can be leveraged to analyze fine grain ed and in depth app behavior.
in addition w hyper and autocog apply nlp techniques to app s descriptions to obt ain a comprehensive view of the app and check if the required permi ssions are appropriately specified in the descriptions.
besi des and apply nlp techniques on api descriptions or documen ts to infer method specifications.
we can leverage these techni ques to automate the generation of api models used in b idtext.
.
conclusion we propose b idtext a novel static technique to detect sensitive data disclosures.
b idtext identifies text labels appearing in both code and ui treats them as types associates them to the corresponding variables bi directionally propagates the ty pes through data flow and eventually attributes them to sink points that p otentially disclose sensitive information.
at the end the para meters at the sink points have type sets of correlated texts.
textual a nalysis is applied to the type sets to determine if the variables may hol d sensitive data.
we implement b idtext and evaluate it on apps downloaded from google play store.
b idtext reports apps that have sensitive data disclosure problems including apps disclosing sensitive information through logging and through non logging channels.
existing techniques can only report .
of cases reported by b idtext.
manual inspection shows the false positive rate is .
the overhead of b idtext is reasonable.
.