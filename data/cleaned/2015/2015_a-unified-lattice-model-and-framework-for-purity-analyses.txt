a unified lattice model and framework for purity analyses dominik helm tu darmstadt germany helm cs.tu darmstadt.deflorian k bler tu darmstadt germany kuebler cs.tu darmstadt.demichael eichberg tu darmstadt germany eichberg cs.tu darmstadt.de michael reif tu darmstadt germany reif cs.tu darmstadt.demira mezini tu darmstadt germany mezini cs.tu darmstadt.de abstract analyzingmethodsinobject orientedprogramswhethertheyare side effectfreeandalsodeterministic i.e.
mathematicallypure has been the target of extensive research.
identifying such methods helps to find code smells and security related issues and also helps analysesdetectingconcurrencybugs.
puremethodsarealsoused by formal verification approaches as the foundations for specifications and proving the pureness is necessary to ensure correct specifications.
however so far no common terminology exists which describes the purity of methods.
furthermore some terms e.g.
pureorsideeffect free are also used inconsistently.
further all current approaches only report selected purity information making them only suitable for a smaller subset of the potential use cases.
in this paper we present a fine grained unified lattice model which puts the purity levels found in the literature into relation and which adds a new level that generalizes existing definitions.
we have also implemented a scalable modularized purity analysis which produces significantly more precise results for real world programs than the best performing related work.
the analysis shows that all defined levels are found in real world projects.
ccs concepts theory of computation program analysis software and its engineering automated static analysis keywords purity side effects static analysis lattice java.
acm reference format dominikhelm floriank bler michaeleichberg michaelreif andmira mezini.
.aunifiedlatticemodelandframeworkforpurityanalyses.in proceedingsofthe201833rdacm ieeeinternationalconferenceonautomated software engineering ase september montpellier france.
acm newyork ny usa 11pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
introduction static analyses that identify side effect free and also deterministic i.e.
mathematicallypure methodsinobject orientedprogramshave been the target of extensive research .
identifying such methods helps to improve analyses detecting concurrency bugs and to find security related issues .
pure methods written in programming languages such as java are also used by formal verification approaches as the foundation for the respective specifications .
in that case it is necessary to prove a method s purity to ensure that the formal specifications are correct.
the identification of mostly pure methods further facilitates program comprehension provides opportunities for code optimizations andsupportstestingaswellasautomated verification .
recent trends towards a more functional style of programmingrelyingonpuremethods alsodemonstratethe overall relevance.
however no common terminology exists which describes the purityofmethods andsometerms e.g.
pureorside effectfree arealsousedinconsistently.further allcurrentapproachesonly report selected purity information andare thus only suitable for a small subset of potential use cases.
identifying side effect free and deterministicmethodsenablescompilerstoperformcompiletime evaluations.formalverificationapproachesneedtheinformation to ensure correctness.
detecting concurrency bugs and code smells requiresjustside effect free methods while code comprehension can benefit from all levels and also weakened forms of purity.
in this paper we present a fine grained unified lattice model for specifying a method s purity.
in the model each of the lattice elementshasawell definedsemanticsandisputintorelationtothe purity levels found in the literature.
the model is extended by the level contextualpurity whichgeneralizestheso called external purity .
being able to ignore specific operations in specific contexts e.g.
logginginbusinessapplications isalsosupported andgeneralizedto domain specificpurity.theproposedmodelis sufficiently detailed for all identified use cases.
furthermore the purity levels external andcontextual purity support purity analyses to rate methods as pure if the called methods have side effects thatarelimitedtothecaller.therefore thelatticemodelisalsoa suitable target for modular purity analyses that reason about each methodinisolation.additionally wepresentascalable purityanalysis that produces more precise results for real world code thanthestate of the art.theanalysisinferspurityforindividual methodsinisolationandreliesontheresultsofseveralindependent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france dominik helm florian k bler michael eichberg michael reif and mira mezini analyses.
using the analysis we will show that all defined levels are relevant when analyzing real world projects.
insection 2wewilldiscussthestate of the art.afterthat we will present the unified lattice model in section .
the implementation of the proposed analysis opium1 is discussed in section and evaluated in section .
section 6concludes the paper.
related work inthefollowing wediscusspreviousresearchonpurity.wewill presentthepuritydefinitionsfoundintheliteraturealongsidewith the proposed analyses.
we will start with those approaches that focus on identifying side effect free methods independent of the question whether the methods are also deterministic or not.
after that wewilldiscussthoseapproachesthatrelyonstricter purity definitions .
.
side effect free methods one of the most commonly used definitions of method purity is given by s lcianu and rinard where a method is pure if it does not mutate any object that exists in the pre state i.e.
the program state right before the method invocation .
this definition does not capture deterministic behavior but it ensures the absence ofside effects.theiranalysisiscombinedwithapointeranalysis and also supports the identification of individual parameters that areread only orsafe.
read only parameters are parameters of a method where no object transitively reachable through this parameter is mutated by the method.
safe parameters additionally require that no new externally visible paths to objects reachable throughthemarecreated.toclassifytheparameters theiranalysisisabletodeterminewhichmemorylocationsmaybemodifiedbya method.
the analysisis used in the korat tool to checkthe purity of methods specifying the behavior of data structures.
the same definition of purity is used by huang et al.
.
they propose to extend the java type system and present a type inferencealgorithmtoannotatereferencesas read only.inthetype system pure methods are those that do not modify global state through static fields and that do not have any parameters inferred as mutable.
the authors suggest to use the approach to find errors or to do optimizations in concurrent programs.
pearce uses a similar definition.
his jpure system checks that methods annotated as puredo not modify previously existing program state.
it is also capable of inferring purity annotations for code that is not annotated.
genaimandspoto againrefertoamethodaspure ifitdoes notmodifytheheapstructuresreachablefromanyofitsparameters.
theirconstancyanalysisidentifiestheparameterswhicharenot used to modify the reachable heap.
the analysis uses alias relationships between the parameters expressed as boolean formulas.
inthe approach proposedby ierusalimschyand rodriguez side effect free methods are allowed to allocate new objects and returnthemaslongasthepre stateisnotmodified.theyrelyon manual annotations that mark methods as side effect free.
theirgoal is to extend the type system and to automatically check the respective methods for conformance at compile time.
1opal purity inference based on a u nified lattice m odel.incontrast adynamicanalysistofind puremethodsisdescribed bydallmeier .theanalysisexplicitlydealswithmultithreading and especially the fact that constructors while they may assign to fieldsofthecurrentlyinitializedobject canbepure.hisanalysis results are used for adabu a tool for mining object behavior that requires information about side effect free methods for classifying methods as observers and mutators .
the definition of side effect free methods used by rountev is stricter than the previous ones.
while it does allow allocation of newobjects thesemaynotescapetothecaller.theproposedmodel assumessingle threadedexecutionasthepre stateofthemethod couldbemodifiedbyconcurrentlyexecutingmethodsotherwise.
they describe two analyses based on rta and a points to analysis to identify side effect free methods in partial programs.
naumann andbarnett et al.
introducethe idea of observationalpurity.suchmethodsareallowedtohaveside effects thatarenotobservablebytheircallers.thisdefinitionespecially allowsforcaching intermediate results asisdoneinmemoization.itisonlyvalidinlanguageswithoutunrestrictedpointerarithmetic where noninterference properties can be proven .
methods that areobservationally pure could be used in program specifications written in e.g.
esc java and jml .
traditionally these languages requiredstronger restrictions no useof methods inesc javaatallandonlyprovablypuremethodsinjml .theanalysis they propose to determine observational purity is built upon an information flow analysis .
esc java2 usesside effectfreemethodsforspecifications but relieson programmer specified annotations toidentify them.
the authors also recognize that determinism is required for specifications butdonotprovideawayofidentifyingmethodsthatare deterministic and side effect free.
table1summarizesthedifferentapproachestodetectingsideeffect free methods and the terminology used by the authors.
.
deterministic purity aside from not performing side effects deterministic behavior i.e.
producingthesameoutputswheneverinvokedwiththesameparameters isanecessaryconditionformethodstobereferentially transparent.
this is required for compiler optimizations as well as formal specifications.
the term functionally pure for methods that are deterministic and side effect free is introduced by finifter et al.
.
they use a subsetofthejavalanguagecalledjoe ethatrestrictssomefeatures ofjavathatarenon deterministicorcauseside effects including mutablestaticstateandaccesstothestacktraceofexceptions.pure methods are automatically thread safe as they can never interfere withotherthreads andnosynchronizationisrequired.thisallows for verifying security properties such as the correct behavior ofencoding and decoding methods.
they also suggest using sideeffect free methods for assertions and specifications.
similar to the concept of huang et al.
methods that only have immutable parameters can never cause side effects or be non deterministic so pure methods can be easily identified.
intheirworkondynamicpurityanalysis xuetal.
define several levels of purity.
strongly pure methods must be side effect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a unified lattice model and framework for purity analyses ase september montpellier france table summary of analyses for side effect free methods authors analysis type purity levels as named by authors s lcianu rinard pointer analysis pure huang et al.
type system extension pure pearce annotations pure genaim spoto parameter mutability pure ierusalimschy rodriguez type system extension side effect free dallmeier dynamic purity analysis pure rountev static purity analysis side effect free barnett et al.
information flow analysis strongly pure observationally pure table summary of analyses for deterministic pure methods authors analysis type purity levels as named by authors finifter et al.
type system restricted language side effect free functionally pure xu et al.
static dynamic purity analysis strong moderate weak once impure zhao et al.
static purity analysis pure benton fischer type and effect system pure read only externally pure externally read only stewart et al.
type system extension strict strong weak externally pure freeanddeterministicandareonlyallowedtohaveprimitiveparameters thereby excluding reference type parameters completely.
they may also not create any new objects or call impure methods eveniftheeffectsofbotharenotvisibletothecaller.
moderately puremethodsaresimilarintheconstraintsontheirinputs butmay create new objects as long as they don t escape the method execution context similar tothe definition ofrountev above.they may also call impure methods if their effects are not observable by the caller.
the restriction on reference types is partially lifted in weaklypure methodsthatmayaccessfieldsofobjecttypeparameters.
a rather unique concept is once impure purity that allows methods to be impure on their first but not on subsequent invocations.
the authors do not detail the uses cases but it seems that they want to support lazy initialization patterns.
while their work focuses on dynamic analysis they also present a static analysis for strongpurity.theanalysisdividesthebytecodeinstructionsexecuted bya methodinto impure andpure instructions.
forweaker purity levels some instructions are considered pure only when they are performed on locally allocated non escaping objects.
the analysis results are used to support automated memorization of methodresults.thisispossiblebecausetheresultsofpuremethods are the same when invoked again with the same parameters.
zhaoetal.
exploredifferentapproachestofindpuremethods automated checking of programmer supplied annotations and two static analyses based on a method s bytecode.
the purity informationisthenusedinsidethejikesvm tosupportfurther analyses and optimizations such as the elision of method calls.
unnecessarysynchronizationcanberemovedaspuremethodsdonot require synchronization with another thread.
externalpurity isintroducedbybentonandfischer .externallypuremethodsareallowedtoreadandmodifymutablestate but only on the receiver object of a call.
constructors that leak the reference to currently initialized objects are ignored as the authors considerthistoberare.theweakerpuritylevel externallyread onlyallows methods to modify the state of the receiver object as above andtoreadanymutablestate.theyshowthatalargepercentage of methods in object oriented programs fulfills these conditions using a type and effect system .
stewart et al.
extend reiminfer by combining previous definitionsofpurityintofivelevelsofside effects.fortwoofthe proposed levels strict purity no local variable assignments are allowed and strong purity no allocation of objects are allowed no use cases were identified and as the authors admit both are of nopracticalrelevance.theyalsodiscussthreepropertiesrelatedto input outputanddeterminism buttreatthemasorthogonaltothe puritylevels.acoherentlatticemodelisnotdefined.lastly thetool is not available rendering an empirical evaluation of it impossible.
a summary of approaches identifying deterministic pure methods and the terminology used by the authors is given in table .
model inthefollowing wediscusstheunifiedlatticemodelbydefiningthe differentpuritylevelsandtheirrelationsaswellasbycomparing them to the levels defined in the literature.
the presented modelis generic and can be used for any object oriented programming language.
examples in the following sections are in java.
.
purity levels wefirstintroduce side effectfree asitbuildsthefoundationforother levels.
we will then proceed to discuss purity before we finally present weaker purity levels.
.
.
side effect free methods.
definition .
a method is side effect free if all object graph manipulations which are performed by the method or its callees are only visible to the method while it is executed i.e.
all manipulations are invisible to a method s client.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france dominik helm florian k bler michael eichberg michael reif and mira mezini here the object graph is considered to also include the system s resources e.g.
the file system network etc.
and therefore methods manipulating these resources are not side effect free.
thisdefinitionrefinesdefinitionsfoundinpreviousworkwhich are based on pre state manipulations.
in a multi threaded environment amethodinvocations exactpre stateandwhetherchanges toobjectsallocatedonconcurrentthreadsconstituteaside effect is unclear.
a particularly problematic definition is that of rountev wheretheobjectgraphmustbeequivalentbeforeandafter the method invocation.
with concurrently executing threads even atemporarychangeoftheobjectgraphcanaffecttheresultsofthe program.
the proposed definition can be applied in multi threaded environments as it explicitly refers to the visibility of side effects i.e.
itdoesnotmatterwhetherthemethod spre stateismodified or not.
this definition also allows side effect free methods to return newly allocated objects as the modification of the object graph only become visible to the direct caller after the method execution.
side effectfree methodsmayinvokemethodsthatarenot sideeffect free themselves iff the caused side effects are confined to the calling method i.e.
the side effect is invisible to callers of the sideeffect free method.
an example is shown in the following listing 1classcountervalue 2public static int counter 3private int value 4public static countervalue getcurrentvalue 5countervalue current newcountervalue 6current.settocounter 7returncurrent 9private void settocounter 10value counter listing a side effect free method.
as the method settocounter modifies its receiver object it has a side effect.
however when settocounter is invoked by getcurrentvalue thisside effectisconfinedtothemethod sscope i.e.
the side effect occurs on a newly allocated object that is invisible to other methods than getcurrentvalue until it finishes execution.
thus getcurrentvalue isside effect free.
java.lang.system.currentmillis is a java example of a side effect free method.
further methodsthatperformsynchronization exceptlocking of objects inaccessible by other threads are not side effect free astheychangethemonitor s statecausingchangestoanobject s objectgraph.hence concurrentlyexecuted side effectfree methods can not cause deadlocks livelocks or race conditions since they do not modify any state that is visible outside their execution scope.
side effect freeness is the foundation of further purity definitions and many authors refer to side effect free methods as pure e.g.
.inordernottoconfuseside effectfreenesswithfunctional purity thatalsorequiresdeterministicbehavior wewillrefer tonon deterministicmethodswithoutside effectsas side effectfree as in .
.
.
pure methods.
definition .
a method is pureif it isside effect free and additionally produces a structurally equal deterministic result each time themethodisinvokedwithidenticalparametersduringoneexecutionofaprogram.tworeferenceparametersareidenticaliftheyreference the same object.
the results are structurally equal if the returned object graphs are isomorphic ignoring aliasing relationships.
primitive parameters are identical and structurally equal if both values are the same.
this definition is similar to that of weak purity as described by o r andensures referential transparency i.e.the possibility of replacing the method s invocation by its result.
1final static double pi .
2static double getarea double radius returnradius radius pi listing a pure method.
themethod getarea showninlisting ispurebyourdefinition.
it deterministically computes the circle s area with the givenradius and is free from side effects.
deterministicbehaviorcanbeachievedwhenneithermutable globalstateisusednornon deterministicmethodsarecalled.please note that determinism is not influenced by immutable global state likethemathematicalconstant piinlisting 2and therefore use of immutable global state is allowed.
in multi threaded programs fields of reference type parameters may change during the execution of the method due to concurrent threads.
we therefore restrict accesses to immutable fields.
others have opted for more restrictive approaches e.g.
xu et al.
onlyallowvalue typeparametersfortheirdefinitionsof strongly andmoderately puremethods .alternatively onlyimmutable reference type parameters can be allowed .
we do not apply special treatment to data that is immutable duringtheexecutionofaprogram butmaybeinitializeddifferentlyinanotherprogramexecution.
puremethodsmayusesuchdataand mayreturndifferentresultsacrossdifferentprogramexecutions.as long as the results are identical during a single program execution those methods are considered pure.
duetotheexistenceofaliasing itisnecessarytodefinewhen parameters of different invocations are considered equal.
we re quirepuremethods to return the same result when objects with the same identity are passed as parameters i.e.
objects at the same memory location.
this restriction eases the implementation asit allows to treat comparisons for reference in equality as deter ministic.
as mutable state from objects may not be accessed bypuremethods it is not necessary that all objects reachable via a parameter or primitive fields of a parameter object are identical too.
if the parameter object itself has the same identity different field values can only arise for mutable fields that can not be accessed by puremethods anyway.
for a method s result we require structurally equal object graphs i.e.
isomorphic graphs without respectofaliasingrelationships.therefore methodsareallowedto return a newly allocatedobject for every execution.
a potentially counterintuitiveconsequenceisthatitisunsoundtoreusea pure method sresultinsteadofreevaluatingitwhentheresultmaybe subject to a reference equality test as in listing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a unified lattice model and framework for purity analyses ase september montpellier france 1object a puremethod 2object b puremethod 3if a b listing a problematic reference equality check.
withoutfurtheranalysis thismayneitherbereducedtoasingle call nor may the calls be compile time evaluated to a single or two distinct result objects.
one important limitation of this definition is that puremethods canonlyreturnthosemutableobjectsforwhichtheobjectgraph is guaranteed to be structurally equal across method calls with identical parameters.
for example getarray depicted in listing is notpure as the content of the array may change in between methodinvocations.whileitisdifficulttoprovestructuralequality oftheobjectgraphingeneral manypracticalcasesareeasytofind e.g.allocationanddeterministicinitializationofamutableobject will yield deterministic results if the object does not escape the method s execution context before being returned.
1final static int array new int 2static int getarray 3returnarray listing a method that is not pure.
.
.
external purity.
definition3.
amethodis externallypure externallyside effect free if its invocation may lead to a modification of its receiver but is pure side effect free otherwise.
externallypure methodscanbeusedtoidentifyadditionalmethodsaseither pureorside effectfree whencallersofrespectivemethods know that the receiver object is confined to their context i.e.
the receiver of the externally pure method does not escape the methodsscope.furthermore aclientanalysiscanusethispurity level to trivially identify methods that break abstractions boundariesby e.g.
mutatingglobalstate.asrecognizedbybentonand fischer it is beneficial to identify such methods to improve program comprehension.
1public class a 2public int f 3public void setfield int value 4f value listing a field s setter that is externally pure.
listing5gives an example of an externally pure method.
it is deterministic and its only side effect is the write to the field fwhich belongs to the same receiver object as the method.
finding methods that are externally pure is essentially a specialized form of side effect analysis.
external purity also applies to methods that use synchronization on the receiver object.
this includes methods that have the synchronized modifieraswellasmethodswithexplicitsynchronizationonthereceiverobject.thisfollowsdirectlyfromtheabovedefinition as the monitor that is used to perform the synchronization is modeled as a property of the object.
in contrast to benton and fischer we treat methods reading the receiver s mutable state as side effect free instead of externally pure.
this enables us to classify methods with calls on non confined receiverobjectsas side effectfree ratherthan impure.thedrawback is that a caller that invokes such methods on a confined receiver object can not be pureanymore.
.
.
contextually pure.
definition4.
amethodis contextuallypure contextuallysideeffectfree ifitsinvocationmayleadtoamodificationofatleastone of its parameters but is pure side effect free otherwise.
we define contextual purity as an extension of external purity.i t captures methods that potentially modify any of their parameters instead of only their receiver.
while contextually pure methods breakabstractionboundaries theyarestilllessproblematicthan methodswithside effectson static globalstate.also theyallow identifyingmoreside effectsasconfinedifitisknownthatnoneof their actual parameters are visible outside of their caller.
1public class a 2public int f 3public static void modifya a a intvalue 4a.f value listing a contextually pure field setter consider modifyainlisting .itsonlyside effectistomodify parameter a sstatedeterministically.thus itis contextuallypure.
anexampleofaveryfrequentlyused contextuallypure javamethod issystem.arraycopy .itmodifiesthegiventargetarrayandis used in implementations of many core data structures.
.
.
domain specific purity.
definition5.
amethodis domain specificpure domain specific side effect free i fi ti s pure side effect free when the effects of certain instructions belonging to a certain domain are ignored.
here two parameterized instructions with different parameterizations are considereddifferent instructions e.g.
twofield accessinstructions on different fields.
sometimes methodsperformside effectcausingoperationsthat neithercanbeclassified purenorside effectfree byusingtheproposeddefinitions.however whenhavingacloserlook thoseoperations neither influence the method s result nor lead to effects on other methods.
for instance a method that writes a log file admittedly causes a side effect but this kind of side effect can be toleratedbecauseithasnodirectinfluenceonanyothermethod.
this property kind was previously identified by steward et al.
.
1static final double pi .
2static double getarea double radius 3system.out.println called getarea 4returnradius radius pi listing a domain specific pure method performing logging.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france dominik helm florian k bler michael eichberg michael reif and mira mezini impuredomain specific contextually side effect freedomain specific externally side effect free contextually side effect free domain specific contextually puredomain specific side effect free externally side effect free domain specific externally pure contextually pureside effect free domain specific pure externally purepure figure the unified lattice for purity information consider the method getarea in listing usually the program s execution will not depend on the output from the println statement.
thus themethod can be considered as domain specific pure.
the possibility of classifying logging as pure is important for theanalysisofenterpriseapplicationsthatincludelogginginmany methods.
anotherexampleofdomain specificbehaviorisraisingexceptions.thisisnotpure asnewlyconstructedexceptionscontainthe currentstacktraceandthatisnotdeterministicw.r.t.parameters of the method invocation.
for example two method invocations withidenticalparametersmaynotleadtoexceptionswiththesame stack trace.
however as the stack trace is usually not inspected by theprogram treatingitas domain specificpure allowstoclassify further methods as effectively deterministic.
incontrasttopreviouswork e.g.
whichonlytreatsexplicit exceptionsandignoresimplicitones e.g.
nullpointerexception s raised by the jvm our handling allows to consistently treat implicitly and explicitly thrown exceptions.
.
.
orthogonal purity properties.
the previously defined purity levelscapturefourdifferentproperties deterministicandnondeterministic behavior pure vs.side effect free modification ofthereceiverobject externalpurity modificationofformal methodparameters contextualpurity and non deterministicor impureactionsthatmaybeconsideredpureinsomecircumstances domain specificpurity .thesepropertiesareorthogonaltoeach other i.e.
everypropertycombinationispossibleexceptfor external andcontextual purity as the latter subsumes the first.
we define the combinations of externally pure andcontextual purewithdomain specificpure togetthebenefitsof externaland contextualpurity.thisallowstoapplytheconceptof domain specific purityto methods that modify their receiver or parameters.
definition .
a method is domain specific externally pure domain specificexternally side effectfree ifitis externallypure externally side effect free and ignores the effects of specific instructions.
definition7.
amethodis domain specificcontextuallypure domain specificcontextuallyside effectfree ifitis contextually pure contextually side effect free and ignores the effects of specific instructions.
.
.
impurity.
when a method does not have any of the previously described properties and therefore no previous purity level can be assigned we refer to it as impure.
.
purity lattice we arrange the purity levels defined above into a single unified latticethatcapturestheir relationships.
thelatticeenablesamonotone framework for increasingly precise purity analyses that are able to refine previous analyses results.
the purity lattice is depicted in figure .
its top element is pure thestrictestpuritylevel.eachstepdownthelatticeloosens exactly one restriction on the method side effect free allows for non deterministicbehavior domain specific allowsdomain specific side effects like logging and externally allows modifications on theimplicit thisparameter.
contextually loosensfurtherrestrictions allowingmodificationallformalmethodparameter including this .impurerepresentsbottomvaluethatplacesnorestrictions on the method.
purity analysis the purity analysis implementation is based on the fix point computations framework fpcf provided by opal .
the framework supports a decoupled implementation of mutually dependent analysesandautomaticallyresolvescyclicdependenciesinasound manner.
using this framework enabled us to factor out analyses that provide generally useful information into separate modules to facilitate the comprehension of the purity analysis.
figure provides an overview of the analyses that are used by the purityanalysis and their dependencies.
we used independent analysesfor determining a class im mutability the locality of fields the freshness of return values and to enable inference of escape informationforlocalvariables.inthefollowing whenwetalkabout the analysis we are always referring to the purity analysis opium.
all createdanalyses use opal sthree address code representation of java bytecode.
the latter is based upon an intra procedural data and control flow analysis and natively provides def use informationaswellasrefinedlocaltypeinformation.furthermore lambdaexpressionbased invokedynamic callsareresolvedusing standard virtual methods calls and objects.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a unified lattice model and framework for purity analyses ase september montpellier france field locality class immutability type immutabilityescape virtual method escape return value freshness virtual method return value freshnessfield mutability purity virtual method purity figure dependencies between analyses used for purity analysis .
analysis workflow our analysis purityin figure determines the purity level cf.
figure1 for each non abstract method.
it works as follows when westartanalyzingamethodweassumethatitis pure thelattice s topvalue.wethencheckeachstatementofthemethodifitviolates thecurrentlyassumedpurityleveland ifso reducethepurity leveltothenextbeststatethatisnotviolated.e.g.
whenthecurrently assumed level is pureand an exception object is created the level is decreased to side effect free .
statements that access fields or other methods are initially ignored instead a dependency on themisrecorded.afteranalyzingallstatements theinitialresult which consists of the currently assumed purity level and all dependencies is passed to the framework.
the information about the dependencies is used by the framework to call back the analysis when the required information regarding dependencies is updated.
theanalysesthenupdatesitsassumedpuritylevelaccordinglyand also the set of still relevant dependencies and passes both back to the framework.
the analysis of a method has completed if there arenomoredependenciesthatmayaffecttheassumedpuritylevel the later is then the final purity level.
if a cycle is found by theframework it is automatically resolved by assuming the currentderived purity level for the methods within the cycle.
the latter is correct as it is the best solution that takes all dependencies into account.
.
effect of instructions in the following we discuss the instructions that may affect a method spurity.instructionsrelatedtomathematicaloperations andconstants typechecksandcasts ortothecontrolflow e.g.
add if o rgoto never affect a method s purity and thus are ignored.
fieldaccesses fieldreads getfield orgetstatic introduce non determinismwhenthereadfields valuescanchange i.e.
when the fields are not effectively final.
therefore the best possiblepurity level will be side effect free unless the receiver object of thefieldaccessislocaltothemethod.forexample accessestoa field of a newly created non escaping object are ignored.
a field s mutability is determined by the respective analysis.
notethatitissufficienttorequirethatfieldsthatareaccessedare effectively final this ensures that the read value is never changed.
while the read value may be a reference to a mutable object or array thatmutabilitycanonlybeobservedifanotherfield array access is performed on the acquired reference.
writingstaticfields putstatic alwaysreducesthemethod s purity to impure.
instance field writes putfield effect the purity if the written object is not local cf.
locality .
if the receiver of thefieldaccessistheselfreference this ofthemethod thebestpurity levelwillbe externalpurity .ifthereceiverisaformalparameterof the method the method is at most contextually pure.
array accesses we consider arrays as being objects where all fields arrayentries aremutable.
arrayload andarraystore instructionsarehencehandledequivalentlytoinstancefieldaccesses.
synchronization wetreatexplicitacquisitionsandreleasesof monitors monitorenter monitorexit aswritesofan implicit field monitor.
return frommethod amethodwhichreturnsareferenceis deterministic only if the returned object graph is guaranteed to be structurally equal cf.
section across method invocations.
otherwise the best possible level is side effect free .
structural equality is guaranteedifthereturnedreferenceisfreshandnon escapingor ifthereturnedobjectisimmutable.thelatterpropertyisderived by an independent class and type immutability analysis.
methodcalls thepurityofthecalledmethod independent of the underlying instruction e.g.
staticcall virtualcall determines the purity of the caller as follows if the callee s purityispure side effectfree domain specificpure orimpure thebest possiblepurity levelforthecallerwill bethatofthe callee.foranexternallypure callee the best possible level for the caller depends on the receiver object of the call.
the caller can be pureif it is local and non escaping.
if it is the receiver object of the caller or oneofitsformalparameters thecaller spuritycannotbebetter thanexternally pure orcontextually pure respectively.inallother cases thecallermustbe impure.contextuallypure callee sarehandled in the same way except that all of their parameters including theirreceiverobject mustmatchthegivencondition.callerswithacombinedpuritylevelarehandledlikeseparatecalleeswiththeindividual levels e.g.
a callee that is domain specificexternalside effect freerequiresthatthecallerisnotbetterthaneachof side effectfree domain specific pure andthepuritylevelthatwouldbetheresult of anexternally pure call on the same receiver object.
in case of a virtual method call the callees are identified using a class hierarchy analysis based call graph.
results by rountev showthattheuseofamorecomplexcall graphalgorithmhasonly minor impact on purity results.
we manually assigned purity levels to some native methods e.g.
strictmath.sqrt system.arraycopy toimprovetheprecision of the analysis.
as other purity analyses we also use this mechanism to specify the following methods as pure hashcode equals and compareto .
however we do not handle tostring specially as others since assigning correct purity levelsfor stringbuilder andstringbuffer sappendandtostring methods suffices to correctly classify most tostring methods.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france dominik helm florian k bler michael eichberg michael reif and mira mezini calls that are part of logging or console output are treated asdomain specific i.e.
domain specific pure is used instead of the callee s actual purity level.
allocation of objects allocations of objects in general do not influence a method s purity besides the effect that invoking their constructor has according to the rules for method calls asabove.
the constructor of throwable the superclass of all exceptions is however impureby definition because it invokes fillinstacktrace which might be impurely overridden by a subclass.
this is a problem as exceptions occur frequently and should not in general result in impurity.
wetherefore treat throwable s constructor as side effect free2and individually examine all subclassesof throwable thatoverride fillinstacktrace .call sites of exception constructors are treated as domain specific pure.
.
special cases besides explicit statements there are implicit effects on a methods purity that are also checked by the analysis.
synchronizedmethods ifamethodis synchronized assuch the purity level will be at most externally pure it is equivalent to writing an implicit field monitor on the method s receiver object.
implicit exceptions exceptions may not only be allocated explicitly butthejavavmalsoraisesexceptionsonseveraloccasions e.g.
anullpointerexception is raised when a method call s receiver is null.
we recognize these implicit exceptions by examination of the control flow graph for exceptions that terminate themethod sexecution aswellas caughtexception statements.
thoseareagaintreatedas domain specificpure astheconstructors ofallexceptiontypesthatarepotentiallycreatedbythejavavirtual machine knowingly do not have any side effects.
.
locality modifications of objects that are constrained to the scope of a specificmethodcanbeignoredwhencomputingthepurityofsuch methods insuchcasestheside effectisconfinedandthemethod canstillbepure.suchobjectsarecalled localandinordertoidentify them we implemented an escape analysis.
the analysis derives three different escape values namely noescape escapeviareturn andglobalescape cf.
.objectswithalifetimethatisbounded tothecreatingmethod sscopehavetheproperty noescape .ifsuch an object is returned by a method the escape value is escape via return.global escape is used for all other objects.
theescapeanalysiscomputestherespectivepropertyforeach intra proceduraldefinitionsite.thatis forallformalmethodparameters everyobjectandarrayallocationsite allcallsofmethods that return an object and all field reads.
the def use information providedbyopalisusedtoidentifyeveryusesiteandtopropagatetheeffectoftheusesitebacktothedef site.forexample iftheonly use site is a return statement the escape state of the respectiveobject is escape via return .
the analysis is field insensitive i.e.
whenever an object is stored in a field it assumes a global escape.
usingtheresultsofthebasicescapeanalysis weidentifylocal objectsbyexaminingalltheirdefinitionsites.areferenceisconsideredlocalifitis freshlyallocated a fresh return value 2themethodisnot pureastheincludedstacktracedependsonthecurrentlyexecuted method s context and not only on its parametersor alocal field .
whereas the locality for new allocations is trivially computed we designed separate analyses both depending on the escape analysis results that identify fresh return values and local fields.
a method s return value is considered fresh if it is a newly allocated object or the result of a call to a method with a fresh return value.
furthermore it must have the escape propertyescapeviareturn .whenretrievingthereturnvaluefreshness information for virtual calls where the precise type of the receiverisnotknown weaggregatetheresultsforallpotentialcall targets.afieldisconsideredlocal whenitsowninginstance is local all objects stored in the field are local and no read value escapes noescape .thelatteranalysisrequiresspecialhandlingof java.lang.object sclonemethod which creates a shallow copy of an object including all private fields of the object.
hence a fieldmightescapeevenifno getfield instructionispresent.as mitigation the analysis determines whether the object s class whose field is under examination overrides cloneand stores a local object into the field of the new object.
for classes that neither override clonenor implement the cloneable interface we can assume that the field is local if the class is final.
in case of a non finalclass wheretheruntimetypeispreciselyknown thefieldmayalso be considered to be local.
furthermore we have extended the field and return value analyses in order to deal with getter methods i.e.
instance methods that retrieve and return a field with thisas receiver.
.
threats to soundness ouranalysisconsidersmethodsforwhichtheimplementationis not available this in particular includes native methods as impure unless explicitly specified differently.
therefore it is sound even in thepresence oflocal useofreflection or sun.misc.unsafe which leadstotheinvocationofnativemethods.non localeffectsofsuch callsaswellasreflectivefieldwrite accessesmayhoweverbreak theanalysis assumptions andthereforeresultinunsoundresults.
evaluation our evaluation focuses on answering three research questions rq1arethepuritylevels cf.figure inparticularthenew levelcontextually pure found in real world applications?
rq2isananalysisthatsupportstheidentificationsofallpurity levelscompetitivew.r.t.precisionandrecallwiththestateof the art which supports only specific level?
rq3does the analysis scale to large applications?
for rq1 we evaluated our analysis on the oracle jdk update scala .
.
and the xcorpus .
the latter contains programs programs from the qualitas corpus and six additional ones that make use of modern dynamic language featuresofthejavavm.wehadtoexclude jasperreports .
.
dueto invalidbytecode.forrq2 wecomparedouranalysisresultsagainst jppa jpure and reim .
for this comparison we use the jolden benchmark.
it consists of ten small java programsfromdifferentdomainsthatalltoolswereabletoanalyze.to answerrq3 wereportanalysisandperformanceresultsfortworeal worldapplications batik .
andxalan .
.
fromxcorpus and compare them to reim.
we chose these two applications authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a unified lattice model and framework for purity analyses ase september montpellier france table purity results on xcorpus jdk and scala application xcorpus jdk scala total methods pure .
.
.
domain specific pure .
.
.
side effect free .
.
.
domain specific side effect free .
.
.
externally pure .
.
.
externally side effect free .
.
.
domain specific externally pure .
.
.
domain specific externally side effect free .
.
.
contextually pure .
.
.
contextually side effect free .
.
.
domain specific contextually pure .
.
.
domain specific contextually side effect free .
.
.
impure .
.
.
becausewewereabletoanalyzethemwithreim.neitherjppanor jpure were able to analyze these applications.
.
rq1 quantitative results thefirstcolumnoftable 3showsthedifferentpuritylevelsgrouped bysimilar expressiveness.the lastline liststheremaining impure methods.
columns two to four show cf.
table the total number of methods as well as the percentage of methods that were derived per purity level for xcorpus jdk and scala.
the analysis shows that pureandside effect free methods are commonplace.inallthreecases ofallmethodsareinthese twocategories.additionally upto12.
ofthemethodsare domainspecific pure orside effect free .
the analysis also identifies between .
to .
of all methods as being externally pure side effect freemethods.
in this case we only found externally side effect free methods in scala but a higher number of domain specific externally side effect free methods when compared to java projects.
this deviation is at least partly due to the different treatment of exceptions in these programming languages.
in scala exceptions neverneedtobecaughtandthereforelessexceptionsareexplicitly caught.
hence many more instructions may cause an abnormal returnfrom amethod.
thesameeffect albeitsmaller can beseen for domain specific side effect free methods in scala.
furthermore wefoundmultiple contextuallypure side effectfree methods.ifwealsotakethe domain specific levelsintoaccount we found methods in the jdk with this property which is about .
ofallmethods.giventhatonly0.
ofallmethodsinthe xcorpusandlessthan0.
inscalahavetherespectivelevel the prevalenceofthesepuritylevelsseemstobestronglydependent ontheanalyzedtarget.ingeneral theeffectsof contextual purity may improve when better contextual information is provided by supporting analyses.
based on the results we conclude that all defined puritylevels areactually foundin real worldapplications.
.
rq2 comparative analysis wecomparedouranalysis opium againstjppa jpure and reim .
reim is the most recent one representing the state of the art.allthreetoolsidentify side effectfree methodsand were downloaded from the authors websites.
thesetsofallmethodsthatareanalyzedbythetoolshavesmall differences.
jppa only analyzes methods transitively invoked by themainmethod jpureandreimanalyzeallmethodspresentin the source code and our approach analyzes all methods present in the class files which in particular includes static initializers andautomatically generated default constructors.
furthermore the reportsofjpureandreimalsoincludeaggregatedpurityresultsforabstractmethods.aggregatedinformationisinourcaseprovidedby thevirtual method purity analysis not by the base purity analysis.
allproducedanalysisresultsareshownintable .itlistsforeach of the jolden projects the number of methods that each systemidentified as side effect free including puremethods for opium andthenumberof methods thesystemhasanalyzed.jpurefailed toanalyzetsp.for opium thetableadditionallygivesthenumber ofpure including domain specific pure methods identified by our analysisandthenumberofmethodswithadditionalpuritylevels i.e.externalandcontextual purity and variants thereof .
for this comparison we treat the levels pureandside effect freeas well as their domain specific variants as side effect free .
our analysis resultsarecompetitivewithreimandsignificantlyoutperformsjppaandjpure.hence ouranalysisiscompetitivewith state of the artanalysesfor side effect free methods.additionally our analysis identifies puremethods and a significant number of externally andcontextually pure side effect free methods which are not found by the other projects including reim.
thedifferencesbetweenjppaandjpurewhencomparedtoreim and our analysis in programs like powerandtreeaddis due to a high number of constructors.
these are not identified as side effect freebyjppa savailableimplementationandjpure.for tsp jppa classifies several methods using java.util.random asside effect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france dominik helm florian k bler michael eichberg michael reif and mira mezini table at least side effect free sef methods in jolden program bh bisort em3d health mst perimeter power treeadd tsp voronoi jppa analyzed methods at least side effect free methods jpure analyzed methods at least side effect free methods reim analyzed methods at least side effect free methods opium analyzed methods at least sef methods pure methods ext.
context.
pure sef methods table at least side effect free methods in batik xalan program batik xalan reim analyzed methods atleastside effectfreemethods .
.
execution time 103s 140s opium analyzed methods atleastside effectfreemethods .
.
pure methods .
.
ext.
context.
pure sef methods .
.
execution time 197s 187s free eventhoughtheyarenot randommodifiesglobalstatewhen an instance is created while reim fails to identify a pure constructor.
we manually verified that all classifications performed by opium were sound and identified further potential for improvementswherewewouldbeabletoidentifymethodsaspureifthe supporting analyses would be more precise.
to foster an understanding of our analysis on real code we compareditwithreimon batikandxalan.theresultsarelisted in table5.
it again presents the number of methods identified as side effectfree oreven pure byreimandouranalysisalongside thenumberofanalyzedmethods.thenumberof puremethodsand thenumberofadditional externally orcontextuallypure side effect freemethods is given for opium.
the table also lists the execution time for both systems when analyzing batikandxalan.
on these applications our analysis outperforms reim we identify up to more side effect free methods and up to of all methodsasbeingexternallyorcontextuallypure side effectfree methods.wecanconcludethatouranalysisiscompetitiveandalso identifies all the defined purity levels .
rq3 performance evaluation the evaluation was performed on a mac pro with an intel xeon e5 processor ghz and gb ram running lubuntu .
with oraclejdk8update161 thejavavmwasgiven24gbheapspace.theexecutiontimeforourandreim spurityanalysisislistedin table5.
it shows that our sequential analysis with sfor batik and187 sforxalan isslowerthanreim whichneeds103 sand140 s toexecute.theincreaseinruntimehasmultiplereasons first it alsoanalyzesthejdkandalllibrariesrequiredbytheapplication whereasreimreliesonapre annotatedjdk.second thegeneration ofthree addresscode thateasestheimplementationandprovides moreprecisetypeinformation takesmorethan45 oftheoverall executiontime.however ouranalysisderivesmorefine grained resultsandidentifiesasignificantlyhighernumberofside effect free methods than reim cf.
table .
we can conclude that the proposed analysis scales to large projects the execution time is less than four minutes for methods including the jdk and library dependencies.
conclusion in this paper we proposed a fine grained unified lattice model for purity coveringallusecasesfromtheliterature.wealsoprovide precisedefinitionsforeachlatticeelementtoestablishacommon terminology.furthermore weimplementedascalablepurityanaly siswhichderivesallpropertiesofthelatticeandwhichoutperforms state of the art purity analyses.
in future work we will explore the use of the purity analysis asasupportinganalysisforupstreamones.additionally wewill leveragethemodularityoftheanalysestoexchangethesupportinganalysesagainstmorepowerfulonestoassesstheeffectofthelatter when identifying pure methods.
opiumis available at