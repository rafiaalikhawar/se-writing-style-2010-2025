feedback directeddifferentialtesting ofinteractivedebuggers daniel lehmann departmentof computerscience tudarmstadt germany mail dlehmann.eumichael pradel departmentof computerscience tudarmstadt germany michael binaervarianz.de abstract to understand localize and fix programming errors developers oftenrelyoninteractivedebuggers.however asdebuggersaresoftware they may themselves have bugs which can make debugging unnecessarilyhard or evencause developers to reasonabout bugs that do not actually exist in their code.
this paper presents the first automated testing technique for interactive debuggers.
the problemoftestingdebuggersisfundamentallydifferentfromthe well studiedproblemoftestingcompilersbecausedebuggersareinteractiveandbecausetheylackaspecificationofexpectedbehavior.
ourapproach calleddbdb generatesdebuggeractionstoexercise the debugger and records traces that summarize the debugger s behavior.
by comparing traces of multiple debuggers with each other we finddiverging behavior that points to bugs and other noteworthy differences.
we evaluate dbdb on the javascript debuggers offirefoxandchromium finding19previouslyunreportedbugs eightofwhichare already fixedbythe developers.
ccs concepts software and its engineering software testing and debugging softwaremaintenance tools keywords interactive debuggers differential testing javascript acmreference format daniel lehmann and michael pradel.
.
feedback directed differential testingofinteractivedebuggers.
in proceedingsofthe26thacmjointeuropeansoftwareengineeringconferenceandsymposiumonthefoundations of software engineering esec fse november 4 9 lake buena vista fl usa.
acm new york ny usa 11pages.
.
introduction interactivedebuggersareapowerfultooltofindandcorrectbugsin programs.unlikemuchsimplermethods suchas printf debugging interactive debuggers allow the developer to directly follow the programatruntime.inparticular onecanpausetheexecutionat pointsofinterestthrough breakpoints closelyexaminecontrol flow throughstepping andinspect intermediateprogramstate suchas the callstack andthe valuesofvariables.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
figure javascript debugger of firefox incorrectly pausesatabreakpointindeadcode.bugfoundwithdbdb.
as debuggers are a crucial tool in the development workflow theyobviouslyshouldbecorrect.figure 1demonstratesthatthis isnotalwaysthecase evenwhendebuggingaseeminglysimple program sincetheif conditionevaluatesto false thestatement at line is never executed and nothing gets written to the console.
yet when a breakpoint is set at line in the firefox debugger it pauses whichgives the impressionthat deadcode isexecuted.
suchbugsindebuggersareveryconfusingbecausetheycanlead developers to believe their code is wrong even though it is correct.
evenworse bugsindebuggerscanmakeithardorevenimpossible to understand actual bugs e.g.
when a developer cannot set a breakpointatavalidcodelocation 2whenvariablesareshownwith wrongvalues 3orwhenthe debuggerobscuresthe actualcontrolflow by not pausing where it should.4even when a debugger is not as blatantly wrong as shown in figure there are often subtle differencesbetweentwodebuggerimplementationsforthesame programming language.
such differencesare equally worrying not justbecausedevelopersareconfusedwhenbehaviorchangesjustby switchingtools butalsobecauseitshowsthatsomeoftheintended behaviorofdebuggers isnot well specified.
relatedideas.
findingbugsandotherunexpectedbehaviorindebuggersisasurprisinglyunderstudiedproblem.theclosestexisting lineofworkaddressesthecorrectnessofcompilersandinterpreters.
one approach is software verification which has been successfully applied e.g.
in compcert .
when the programming language is well specified many compilers and interpreters can also build onextensiveconformancesuites orlargetestsuitesthatare manuallywrittenbythedevelopers .unfortunately manual tests are laborious to write and thus often insufficient.
the lack of manualtestinghasleadtoresearchon automatictesting ofdeveloper tools where the tool under test is executed with generated programs.suchtechniqueshavefoundhundredsofbugsincompilers interpreters andotherprogrammingtools such as refactoring engines .
challenges.
unfortunately debuggers differ from compilers and interpretersinkeyaspectsthatmakeitchallengingtodirectlyapply theaboveideas.first unlikecompilers debuggerstakenotjusta program as input but also allow the user to steer the debugging .
.
.
.
610esec fse november4 9 lake buena vista fl usa daniellehmann andmichaelpradel session oftenthroughagraphicaluserinterface gui orcommandline interface.
the debugging actions a user issues there such as setting breakpoints and stepping determine the debugger s behavior.achallengeforeffectivedebuggertestingistogeneratesuch debuggingactions alongside agiven program to debug.
second interactive debuggers as thename implies differfrom compilers because debuggers interact with the user instead of takingallinputsatonceinthebeginningandproducingoutputs only at the end of the execution.
after each debugger input e.g.
astepaction thedebuggerpausesandonlythenshowsthenext outputs e.g.
thelinethatisexecuted waitingforthenextinput fromtheuser.theproblemiscompoundedbythefactthatprevious outputsdeterminethenextpossibleinputs.forexample steppingis nolongerpossiblewhentheexecutionisfinished.forthesereasons automatictestingofdebuggerscannotsimplygenerateallinputs offline before the debuggingsession unlikeincompilertesting.
third debuggersoften lackaprecisespecification oftheintended behavior.whereasmanycompilersandinterpretersfollowalanguage standard we are only aware of few attempts to specify the behavior of debuggers none of which target real world debuggers .withoutaspecification conformancetestingand formalmethodscannotbe appliedto debuggers.
approach.
we present dbdb an automatic differential testing techniqueto detect divergingbehaviorsof debuggers.
thebasic idea is to automatically interact with two supposedly equivalent debuggerstofindadivergenceoftheirbehavior.webaseourwork on a simple model of interactive debuggers as finite state transducers.
inthismodel debuggerstakedebuggingactionsas inputs suchassettingabreakpointinaspecificline resuming orstepping and returnoutputsthat capture thebehavior of the debugger e.g.
which line is currently executing or the values of local variables.
given twodebugger implementationsfor thesameprogramming language dbdb generates debugging actions executes them in parallelinboth debuggers and compares theirbehavior.sincedebuggers are interactive the approach iterates betweengenerating actions and comparing outputs until finding diverging behavior.
thelackofacommonlyacceptedspecificationofdebuggersresults inalargenumberofthesedivergingbehaviors toomanyfordirect manual inspection.
to reduce the inspection effort we assign each divergingbehavioranequivalenceclassandthenonlyinspectthese equivalence classes.
results.we evaluate dbdb on the widely used javascript debuggers of firefox and chromium.
we exercised them with a total of generated actions in debugging sessions.
after less then executed actions already .
of the debugging sessions show diverging behavior between firefox and chromium.
among these diverging behaviors are at least bugs of which were previously unknown and we thus reported to the respective developers.
of the five reported chromium bugs four are alreadyfixedbythedevelopers.inthefirefoxdebuggerwereported 14bugs fourofwhichare nowmarkedasfixed.apartfrombugs we have also found many subtle differences between the firefox andchromiumdebuggers.understandingtheseundocumenteddifferencescanpavethewaytoaprecisespecificationoftheintended behaviorofdebuggersandcouldhelpdifferentvendorstoagreeon acommon debugger interface.
var foo function a ... programsto debuggenerate actionscompare outputsdebugger a debugger b differential testing feedback a paused in line b paused in line traces with diverging behavior assign to equivalence class equivalence classes of diverging behaviorsfigure2 dbdboverview differentialtestingfindsdiverging behaviors which are then assigned to equivalence classes.
contributions.
in summary this paper contributes the following weidentifycommonfunctionalitiesofinteractivedebuggersand modelthemasafinite statetransducerthattranslatesdebugging actions to outputs section .
.
we present the first differential testing technique for debuggers.
thetechniqueusesfeedback directedtestinputgenerationto accountfortheinteractivenatureofdebuggersandassignsdiverging behavior to equivalence classes to reduce the manual inspection effort.
section .2to3.
.
we provide empirical evidence that the approach effectively revealsbugsandotherdivergingbehaviorinwidelyuseddebuggers.
section .
we make our implementation and results available to the public under .
overview and motivating example this section gives an overview of our approach and explains the mainstepswithasimpleexample.figure 2showsthemainpartsof ourapproach.theinputtodbdbisaprogram to debugandtwo debuggersthataresupposedtoprovidethesamedebuggingfunctionalities.for ourrunningexample supposethesedebuggersare the javascriptdebuggers of firefox and chromium.
the approach interactswithbothdebuggersside by sidebygenerating debugging actions such as setting breakpoints andstepping through the program.
during this interaction the approach tracks the behavior of both debuggers and searches for any inconsistencies.
when dbdb detects any diverging behavior it stops the interaction and reports the difference as apair of executiontraces.
asarunningexample considerthejavascriptcodeinfigure .
the code iterates through an array and then executes two ifstatements that each define a local variable.
the letkeyword indicates that these variables are local to the surrounding block scope i.e.
they are visible only within their respective then branches.
supposethatdbdbstartsdebuggingthecodeinfigure 3bysetting a breakpoint at line .
because both debuggers indicate that settingthebreakpointwassuccessful theapproachgeneratesanother action by setting a second breakpoint at line .
the chromium 611feedback directeddifferential testingofinteractive debuggers esec fse november4 9 lake buena vista fl usa 1vararray 2for propinarray 3console.log hi bug cannot set breakpoint here 5if array.length 6letfirstvar first 8if array.length 9letsecondvar bug appears to be first figure runningexample.
debugger confirms the breakpoint at line .
in contrast the firefox debuggerslidesthebreakpointtoline .breakpointsliding isacommon debugger feature to prevent users from setting breakpoints at e.g.
empty lines and comment only lines.
but the difference observedhereisclearlyunintended asitmakesitimpossibletodebug the statement at line .
our approach detects this difference which has been fixed in firefox after we reported it to the developers.
after finding a difference between the two debuggers dbdb continues to explore more behavior.
suppose that dbdb starts debugging the code by setting a breakpoint at line .
then the approach starts the program s execution and the code hits the breakpoint in both debuggers.
as the next action suppose that dbdbissuesa stepinactionandthedebuggersubsequentlypauses executionatline .wheneverthedebuggerispaused ourapproach compares the program state reported by both debuggers.
in this example thecomparisonshowsthatfirefoxclaims secondvar to havethevalue first whereasthechromiumdebuggerclaims secondvar tobeundefined .thissurprisinginconsistencyisdueto abuginfirefox whichaccidentallyshowsthevalueof firstvar eventhoughthatvariableisnotinscopeatline .wehavereported thisproblemandthefirefoxdevelopersconfirmedthatitisabug.
theexampleillustratesthatreal worldinteractivedebuggers as anyothersoftware arenotfreeofbugs.sincedevelopersheavily rely on these tools to debug their own code finding such problems is important.
the following section presents our approach for finding unexpectedand underspecifiedbehaviorofdebuggers via differential testing.
approach this section formally defines the problem addressed by dbdb and describesourapproachindetail.thebasisofourapproachisafinitestatemodelof interactive debuggers section .
.
buildingontop of thismodel section .2defines the problem of finding diverging behaviors for a given pair of debuggers.
section .3presents our algorithmtoaddressthisproblemthroughautomatic differential testing.finally section .4describesatechniquetoassigndiverging behaviors to equivalence classes which eases the task of manually inspecting andunderstanding differences between debuggers.
.
finite state model ofinteractivedebuggers implementations of real world interactive debuggersare complex and analyzing them is non trivial.
to keep our approach generic and independent of a specific debugger or programming language we abstract interactive debuggers intoaformalmodel.the model .
.
bpaction execaction actions bpaction setbreakpointat line remove breakpointat line execaction start execution resume stepin stepout stepover bpoutput outputs programstate executionfinished bpoutput breakpointsetat line removed not removed programstate line callstack vars callstack name vars name type value?
line n linenumbers meta variables name identifiers type types value primitive values figure grammars ofdebugging actions and outputs.
focuses on features common tomost real world interactive debuggers and abstracts away properties of debuggers that are irrelevant for analyzing them.
ourmodelisbasedonfinite statetransducers fsts .fstsare avariantoffinite statemachineswhereeachtransitioncanboth consumeinputandproduceoutput.theyarewidelyusedinnatural languageprocessing e.g.
formachinetranslationorpart of speech tagging .anfstmodelfitstheinteractivenatureofdebuggers whereinputsaredebuggingactionstriggeredbyauserandoutputs represent the resulting behavior of the debugger.
more formally we represent adebugger as follows definition1 debugger .
adebuggerforaprogram pisa5 tuple q q0 p where qisafinitesetofstates q0 qisthe initialstate is a set of input symbols that represent debugging actions the usercan trigger isasetofoutputsymbolsthat represent debugger behavior p q q isatransitionrelationthatmapsthecurrent state and some debugging action to the behavior produced by the debugger andthe nextdebugger state.
figure4summarizestheinputsandoutputsconsideredinthis workbyshowingthegrammarsfortheinputandoutputlanguages and .debuggingactionsin areeitherrelatedtobreakpoints bpaction or control the execution of the program execaction .
debuggingoutputsin areeitherbreakpoint related bpoutput provide details about thecurrent program state programstate or indicate that the program has terminated.
we will explain the symbols and how they relate to real world debuggers in the following.
figure5showsthestates qandthetransitionrelation pofa debugger.
we model debuggers as having three states not running running andpaused.thedebuggertransitionsbetweentwoofthese statesqandrwhentakinganaction xasinputandinturnexhibits somebehaviorrepresentedbyadebuggingoutput y.inthefigure 612esec fse november4 9 lake buena vista fl usa daniellehmann andmichaelpradel paused at line call stack fn fn ... variables name value ... start execution set breakpoint at line breakpoint set at line execution finished resume step in out over remove breakpoint at lineremoved not removed running running pausednot figure5 interactivedebuggersasfinitestatetransducers.in transitions separatesinputs green fromoutputs blue .
and in the following definitions we use the notation qx y rfor suchatransition q x y r p.atransitionwheretheinputisthe emptyword indicatessomebehaviorthatisnotdirectlytriggered bytheuser.likewise weassignanoutput todebuggingactions that donot have an immediate output.
besides debugging actions the behavior of a debugger depends ontheprogram to debug p.wemodelthisdependencybyindexing the transition relation pwithp.
sincepcan keep internal state thenextdebuggerstateandoutputdependsnotonlyonthecurrent debugger state and action but also on p s state.
apart from p all other parts of our model are independent of the program to debug.
initially the program to debug pis not executing and the debuggerisinthestate q0 not running .inthisstate userscanset and remove breakpoints either by clicking on line numbers in a guiorinapromptof e.g.
gdborlldb.setbreakpointactions and remove breakpoint actions have an immediate output the line where the breakpoint was set and whether removing a breakpoint wassuccessful respectively.
thestartexecutionactiontransitionsthedebuggertothe runningstate and runs the program p. in the running state debuggers do not display any information about the execution to the user.
only when a breakpoint is hit or a step completes the debugger transitionstothe pausedstateandduringthattransitionoutputs information about the current program state.
in our model this output of program state comprises three pieces of information line callstack vars inwhich linethe program has paused thecallstack as asequenceoffunctionnames and the setvarsof local variables along with their types and for primitive types theirvalues.
issuing a resume action e.g.
by clicking on in a graphical debuggerorbytyping continue inaprompt transitionsbacktothe runningstateuntilthenextbreakpointishit.similarly stepping through the program continues execution until the next step of computationcompletes.we modelthree kindsofsteps step in which executes the next statement and if it is a function call stops at the beginningofthe callee.
step out which executes all statements until the end of the currentfunction.
stepover whichexecutesthenextstatementand ifitisa function call does not enter the function for debugging.the execution of the program to debug can also just finish with a transition back to the not running state.
this case happens when theprogramterminateswithouthittinganyfurtherbreakpointand withoutpausing after astep.
itis important to pointout thatitdiffers significantly from programmingtoolsconsideredinrelatedwork inparticular compilers.
whentestingcompilers andotherdevelopmenttools the input consists of only a program.
in contrast debuggers expect user actions as an additional input.
another difference is that existing compiler testing is non interactive i.e.
the produced program produces only a single output such as its exit code.
in contrast debuggers alternate between taking inputandproducing output.
.
problemstatement basedonthefinite statemodelofdebuggersindefinition wenow define the problem addressed in this work.
the overall goal is to findand understand diverging behaviors between two supposedly equivalent debuggers for the same programming language.
the following formally definesdivergingbehavior.
definition2 divergingbehavior .
givenaprogram p twodebuggers q q0 p and tildewideq tildewideq0 tildewide tildewide tildewider p havedivergingbehaviorif twosequencesoftransitionsexist q0x y ..x y rand tildewideq0 tildewidex tildewidey .. tildewidex tildewidey tildewider whereq0 tildewideq0 x tildewidex y tildewidey x tildewidex butwhereeither y nequal tildewidey orr nequal tildewider.
thatis giventhesamesequenceofactionsdispatchedtoboth debuggers divergingbehaviormeansthateithertheoutputs y and tildewidey differorthat the states rand tildewiderreachedbythe debuggers differ.
thegoalofourapproachistofindsequencesofinputsthatlead todivergingbehavior.weassumethattheprograms to debugare provided.
the problem of finding suitable programs is related to generatinginputsforcompilertesting andourapproachmaybe combined with existing work on generating programs.
we further assumethatthedebuggerandtheprograms to debugaredeterministic which is a common assumption to make testing reproducible.
.
interactivedifferential testing weaddresstheproblemoffindingdivergingbehaviorbetweentwo debuggersthroughinteractivedifferentialtesting.thebasicidea is to compare two supposedly equivalent debuggers by continuously generating debugging actions and by checking the resulting behaviorfor inconsistencies.
challenges.
tomotivateourinteractiveapproach wefirstoutline several challenges inherent to testing of debuggers.
many typical uses of debuggers involve a combination of actions e.g.
firstsettingabreakpointandthensteppingonceitishit.unfortunately generatingasequence ofsuchactions aheadoftime based on the grammar for is ineffective for three reasons.
first once the program to debug terminates the debugger cannottakemore actions and any remaining actions have been generated in vain.
second some actions that are legal according to the grammar of areillegalforreasonsonlyknownatruntime.considersettinga breakpointatline 7offigure .bothdebuggersslidethebreakpoint tothenextlinebecausethereisnocodetoexecuteattheclosing brace.
now setting a second breakpoint in line 8is not allowed 613feedback directeddifferential testingofinteractive debuggers esec fse november4 9 lake buena vista fl usa andourapproachmustnotgeneratesuchanaction.7third once anactioncausesdiverging behaviorbetween debuggers the analysis has reached an inconsistent state that will only cause more diverging behavior.
consider again the example in figure .
when requesting a breakpoint at line firefox slides it to some later line due to a bug whereas chromium correctly sets it at line .
executing more actions e.g.
resumes and steps after this first divergence is uninformative since they will likely result in more diverging behaviorbecausethebreakpointsweredifferent.suchfollow up divergences are not relevant on their own but merely the result of havingreachedan inconsistentstate earlieron.
our algorithm addresses the challenge of testing interactive debuggers by issuing actions to two debuggers side by side and comparing theirbehaviorafter eachaction.the approach is feedbackdriven in the sense that the behavior triggered by previous actions influenceswhatactionstotriggernext.oncetheapproachobserves adifferenceinbehaviorbetweenthetwodebuggers itstopsand reports twotraces that summarize the executions.
definition trace .
a tracetis the result of interacting with a debugger don a program p. the trace is a sequence e1 .. en ofnevents whereeacheventiseitheranactionoranoutput i.e.
ei i n. the goal of dbdb is to find traces taandtb one per debugger that share a common prefix but then diverge in the resulting behavior after the final action.
for an example of two such traces considerfigure 6a.thefirsteventinbothtracesisasetbreakpoint action followed by the corresponding debugger output.
the traces sharethesameactionsandoutputsuptothefinal stepover .only then thedebugger behaviors diverge with chromium pausing in line25 ofthe program whereas firefox pauses inline26.
algorithm 1summarizes the main steps of our approach for obtaining such traces by automatically interacting with two debuggers daanddb onaprogram p.thecurrentstateofadebugger d isgivenby d.state.weindicatewith d.action thatdbdbtriggers oneoftheactionsdefinedby figure4 .weassumeeachtriggered action isaddedto the trace ofthe corresponding debugger.
the algorithm consists of three parts manipulating breakpoints beforerunningtheprogram startingtheprogramexecution and stepping and resuming during program execution.
the first part lines2to13 sets breakpoints at randomly chosen lines and probabilistically removes them again until obtaining a configurable overallnumberofbreakpoints.foreachsetbreakpoint thealgorithmcomparestheactualbreakpointlocationchosenbythetwo debuggers.theintendedandtheactualbreakpointlocationsmay differ e.g.
becausedebuggersslidebreakpointsinsteadofadding them to empty lines.
if the actual locations differ the algorithm has detected diverging behavior and therefore stops and returns the trace.
otherwise the algorithm tries to remove the breakpoints again and checks whether both debuggers agree that removing the breakpoint is possible.
while it may appear obvious that removing breakpoints is possible we found a bug in a debugger that ignored ausersrequest to remove abreakpoint.
7settingtwobreakpointsinthesamelineispreventedingui baseddebuggersbecause clicking on line numbers toggles a breakpoint.
but in lower level debugging apis e.g.
of chromium anerroris thrown when settingtwobreakpoints at the same line.
.algorithm1 interactive differential analysis input debugger da dbandprogram p output tracesta tbof actions andoutputs assume da.state db.state not running manipulate breakpoints bps while bps max number of breakpoints do l randline p ifl bpsthen continue la da.setbp l lb db.setbp l ifla nequallbthen return divergingbehavior bp location ifrandprob prob.of removingbreakpoint then oka da.rmbp l1 okb db.rmbp l2 ifoka nequalokbthen return divergingbehavior bp removal else bps bps la lb start program execution da.startexec db.startexec stepandresume repeat waituntil da.state nequalrunninganddb.state nequalrunning ifda.state db.state not running then return program finished ifda.state nequaldb.statethen return divergingbehavior termination ifda.programstate nequaldb.programstate then return divergingbehavior program state action randpick resume stepin stepout stepover da.action db.action untilmax number of executionactions thesecondpartofthealgorithm line startstheprogram s execution with the debugger attached to it.
the execution will continueuntilstoppingatabreakpointoruntiltheprogramterminates.
the third part of the algorithm lines 15to22 repeatedlysteps through the program or resumes execution until hitting a breakpointorprogramtermination.thealgorithmwaitsuntilbothdebuggersleavetherunningstateandthenchecksiftheirbehavior is consistent.9if one but not the other debugger has reached the end of the program then the algorithmreports adiverging behavior.
otherwise if both debuggers pause the execution then the algorithmcomparestheprogramstates line callstack vars and tildewidestline tilde6callstack tildewidestvars reportedbythedebuggers.ifthestatesdiffer e.g.
because the debuggers have paused at different locations or because they show different call stacks then the algorithm returns a trace that summarizes the diverging behavior.
finally if there isnoobservabledifferencebetweenthetwodebuggers thealgorithm triggers a randomly selected execution action resume or steps inbothdebuggers.thisprocesscontinuesuntilreachinga configurable maximum number of actions.
9we assume that the program to debug terminates.
if a debugger never leaves the running state then it has a bug that can be detected without any differential analysis.
wehavenot encountered thiscase in ourevaluation.
614esec fse november4 9 lake buena vista fl usa daniellehmann andmichaelpradel program ... 25for leti i i console.log i ... firefox debugger setbreakpoint at line breakpoint setat line ... start execution ... at line25 call stack... stepover atline26 call stack...chromium debugger setbreakpoint at line breakpoint setat line ... start execution ... at line25 call stack... stepover atline25 call stack... a program1and corresponding pair of traces.
program ... 42varx 43for varj j x j some statements ... firefox debugger setbreakpoint at line breakpoint setat line ... start execution ... at line43 call stack... stepover atline44 call stack...chromium debugger setbreakpoint at line breakpoint set at line ... start execution ... at line43 call stack... stepover atline43 call stack... b program2and corresponding pair of traces.
figure example ofequivalent divergingbehaviorsexposed by twodifferentprograms.
.
equivalenceclassesofdivergingbehavior running dbdb once with a single program to debug may or may notexposedivergingbehavior.foreffectivetesting weapplythe approachtomultipleprogramsandrepeatedlydebugeachprogram with different random seeds.
the random seed controls all nondeterministicdecisionsmadebyalgorithm suchaswhichactions totrigger.asweshowinsection repeatedlycomparingreal world debuggersproducesthousandsoftraceswithdivergingbehaviorsin a few minutes.
while this abundance of diverging behavior shows theeffectivenessofourdifferentialtestingapproach italsoleads tothenon trivialchallengeofinspectingthedivergingbehaviors.
manuallyinspectingalldivergingbehaviorsispracticallyinfeasible.
one way to address this challenge is to uniformly sample all divergingbehaviorsandtoinspectonlyasubsetofthem.however we findthatmanydivergent behaviorsare similarand likelyhave thesamerootcause.asamotivatingexample considerfigure whichshowstwoprograms to debugthateachexposedivergingbehaviorbetweenthejavascriptdebuggersoffirefoxandchromium.
belowprogram1and2 therespectivepairsoftracesthatexpose thedivergingbehaviorareshown.eventhoughthedivergingbehaviors are caused by different programs three key characteristics are common between figure 6aand6b the last action is a step over thatactionisissuedatafor loop and thediverging behaviorsareduetoprogramstate inparticular thelineswhere the debuggers pause.
weavoidmanuallyinspectingtoomanyofthesesimilarcases byfirstdividing divergingbehaviors intoequivalence classes definition4 equivalenceclassesofdivergingbehavior .
letp1and p2betwoprograms to debug andlet daanddbbetwodebuggers.
suppose that the pairsoftraces t1 a t1 b and t2 a t2 b both expose a divergingbehavior where ti xistheresultofdebuggingprogram piindebugger dx.thetwodivergingbehaviorsareinthesame equivalence class if the last debuggingaction isthe same in t1 a t1 b t2 a andt2 b the ast node type of the source code line where the last action wastriggeredisthe same for both p1andp2 and the type of diverging behavior between t1 aandt1 bis the same as for the divergingbehaviorbetween t2 aandt2 b.to compute the ast node type of a source code line l we parse theprogram to debugandthensearchthelowestastnodethatincludesalltokensin l.wecompareastnodetypesandnotprogram lines directly because ast node types abstract away programspecific properties such as concrete linenumbers oridentifiers.
the type of diverging behavior is determined by the return valueofalgorithm .specifically therearesixtypesofdiverging behaviors linenumbers refer to algorithm breakpointsare setat differentlocations line .
breakpointscannotbe consistently removed line .
one but not the otherdebugger terminates line .
the program state in both debuggers is different line subdividedbywhichpart exactly differs see figure the debuggers pausedat differentlines or the function names onthe callstack differ or the variables andtheir types andvaluesdiffer.
then we draw our samples for manual inspection from the equivalence classes inaroundrobinmanner instead ofuniformly sampling all diverging behaviors.
the technique is a heuristic that is independent of the programming language and we show in section5that it results in a more diverse set of inspected diverging behaviors whichultimately leads to more foundbugs.
reiterating on the example in figure our technique assigns the two diverging behaviors to the same equivalence class because all three conditions from definition 4are met.
in this particular case thetwodivergingbehaviorsareevencausedbythesameroot cause thechromiumdebuggeralwayspausesateachsubstatement whensteppingoverafor loopheader whereasinfirefoxa step over alwaysgoes to the nextline.
implementation wehaveimplementeddbdbintypescriptandrunit aftercompilation to javascript in node.js.
firefox and chromium offer a programmaticinterfacetotheirdebuggersthroughtheirrespective remotedebuggingprotocols rdp .thatis wedonottestthedebuggers for example by clicking in the gui but directly exchange rdp messages with the debuggers via a websocket connection.
615feedback directeddifferential testingofinteractive debuggers esec fse november4 9 lake buena vista fl usa for chromium we build on the chrome remote interface library which already offers a simple abstraction e.g.
to attach the debugger to a javascript program set breakpoints and perform other debuggingactions.forfirefox weimplementtherdpourselves sincenoup to daterdplibraryhasbeenavailable.ontopofthese low level remote debugging protocols we implemented a common higher levelapiforbothdebuggers.tomakesurethateveryfound divergingbehaviorisnotjustvisibleattheremotedebuggingprotocol level we also manually reproduced every bug in the debuggers guis.
in particular all our bug reports include videos of the visibly wrongbehaviorinthegui.theimplementationispubliclyavailable under .
evaluation .
experimentalsetup we apply dbdb to two popular javascript debuggers firefox .
and chromium .
.
.
.
we run dbdb on a laptop with 8gb of system memory and an intel core i5 5200u cpu.
the operating systemisubuntu16.
bit.
we use javascript programs to debug that are obtained from threesources first weuse26programsfromsunspider ajavascript benchmark version1.
.
whichaccordingtotheoriginalannouncement cover a wide variety of numerical array oriented objectoriented and functional idioms .
second we use javascript puzzlesforstudentsfromaprogramanalysislectureattudarmstadt.thepuzzlescovercornercasesofthelanguage makingthese programs also a potential challenge for developers of debuggers.
third we use four programs written by us that cover newer language features such as letorconst as these features are not used intheotherprograms.toensurethattheprograms to debugare deterministic wefixthecurrenttimeandreplace math.random with adeterministic function.
.
qualitativeanalysis applying dbdb to the programs to debug reveals various diverging behaviors between debuggers.
they range from clear bugs in one of the debuggersto underspecifiedbehavior where neither of the debuggers is clearly wrong but that is nevertheless interesting.wehavefound20clearbugs 19of whichwerepreviously unknownandwhichwehavesubsequentlyreportedtothedevelopersoffirefoxandchromium.sevenofthereportedbugshave alreadybeenfixed.thefollowingdiscussesaselectionofdiverging behaviors inadditionto the ones presentedearlierinthe paper.
chromiumissue730177.
example1intable 1showsabugrelated tobreakpointsinthechromiumdebugger.abreakpointissetin the last line of the 3d cube.js sunspider program shown as an excerpt.
although line is empty we would expect the breakpoint to stay there since the program ends with this line.
firefox exhibits thecorrectbehavior butchromiummovesthebreakpointtothe first line of the program.
this diverging behavior was caught by dbdb we subsequently submitted a bug report which has been confirmedandfixed.
issue .12example demonstrates a bug in the pausing and stepping behavior of a debugger.
by comparing pause locations between debuggers dbdb has found that the firefox debuggerdoesnotstepthrougheachiterationofafor in loopinthis excerptfromthesunspiderprogram regexp dna.js .inparticular whenpausedattheloopheader line2 issuingonlytwostepin actions takesthedebuggerpastthelooptoline5 eventhough its body executes more than once.
chromium behaves correctly andpauses twice andmore often at line3.
firefoxissue1362432.13inexample3 thedebuggerseverelymisrepresents the actual program state during execution.
it was found bydbdbwhendebuggingoneoftheaforementionedjavascript puzzlers.javascriptallowsdeveloperstorepeatparameternames when declaring functions.
inside the function foo paramshould be bound to the second supplied argument second .
the runtimebehavioriscorrect confirmed by theoutput but thefirefox debugger showsthe variable withthe wrongvalue first .
besidesclearmisrepresentationsoftheactualruntimebehavior we havealsofoundotherdivergingbehaviorsbetweenthefirefoxand chromium debuggers.
these diverging behaviors are also valuable todetect firstly becausedivergingbehaviorsareconfusingwhen switchingdebuggersandsecondly becausetheyindicatethatthe intendeddebugger behaviorisnot well specified.
possiblebreakpointlocations.
severalinstancesofunderspecifiedbehaviorarerelatedtothequestionwhereitshouldbepossible to set breakpoints.
example in table 1demonstrates that firefox allows to set a breakpoint at the literal truein line and subsequently pauses there when execution is started whereas chromium slides the breakpoint to the next line.
neither is clearly wrong and it is open for specification whether setting breakpoints atallfunctionargumentsshouldbepossible forconsistencyand so that developers can inspect each individually or only at nonliterals becauseitisunclearwhatisactuallyexecutedatliterals .
dbdb found several more such cases e.g.
firefox allows to set breakpointsat while true but chromium does not.
step semantics and whitespace.
another large class of underspecifiedbehaviorsisrelatedtosteps.whilefirefoxandchromium agreeonsteppingoverasinglefunctioncall itisnotclearwhatthe correctbehaviorshouldbewhensteppingoverotherstatements.
thelastexampleintable 1showsthatasinglestepinfirefoxjumps over multiple statements if they are in a single line.
chromium on the other hand steps over each statement individually and thus pauses multiple times in the same line.
even to a firefox developer the correct intendedbehavior was not clear.15phrasedmore generally itisopenwhetherdebuggingshouldbealtogether independent of whitespace or other non semantic tokens .
that is should e.g.
thenumberofstepstoreachsomestatementalways be the same even if such tokens are inserted?
overall the examples illustrate that the diverging behaviors found bydbdbaffectallkindsofactionsandoutputsourdebuggermodel 14seecomment at .
15seecomment at .
616esec fse november4 9 lake buena vista fl usa daniellehmann andmichaelpradel table examples ofdetected divergingbehaviors.
idaffected debuggerexcerpt ofprogram to debugexcerpt oftrace with detecteddifferencedescription 1chromium1 beginning of program 2displarea null 3eofsetbreakpointat line3 breakpointsetat line 1breakpointsetinemptylast line wrapsaround andissetat beginningof program.
2firefox1for kinsubs 2dnainput ... 4varexpecteddnaoutputstring ...pausedat line2... stepin pausedat line3... stepin pausedat line 5stepinpauses only onceat for in loopbody even though multiple iterations are executed.
gives impressionthat loopis executedonly once.
3firefox1function foo param param 2console.log param 4foo first second pausedat line2... variables param first function parameterwithrepeated name isshownwithwrongvalue but executioniscorrect .
4both1function bar ... 2function foo a b 3foo 4true 5bar setbreakpointat line4 breakpointsetat line ... start execution pausedat line 5firefoxallowssettingbreakpointsat literals andalsopauses there chromium does neither.
5both 1a foo b bar c baz pausedat line2 stepover pausedat line 2stepover infirefox pauses at next line even if currentlinehas multiple statements.chromium steps onceper statement.
considers.outofthe20foundbugs eightarerelatedtosettingand removingbreakpoints e.g.
whenbreakpointscannotbesetbutare slidedawayfromvalidprogramconstructs orwhenbreakpoints cannotberemoved.sevenbugsarerelatedtosteppingandpausing e.g.
when the debugger does not halt at breakpoints or after steps orwhenthedebuggerpausestoooftenorevenatdeadcode see figure1 .finally five bugs are related to otherprogram state e.g.
whenthedebuggerdoesnotshowsomevariablesatallorshows themwithwrongvalues.
.
quantitativeanalysis .
.
effectiveness of finding diverging behavior.
we evaluate the effectiveness ofdbdb bymeans ofthree questions howoftendoestheapproachfinddivergingdebuggerbehavior?
howmanyactions are requiredto find divergingbehavior?
whichtypes ofdivergingbehaviorare the mostcommon?
we can answer all three questions with the help of figure .
thexaxis shows how many actions have been generated.
in the leftmost case onlybreakpointactionsweregeneratedandtheprogram todebug is not yet running.
at x only the start execution action is generated and from x resumes and steps are generated as well.
the y axis shows how many test runs have cumulatively completedafter xactions.adifferentialtestruncompleteseither becausethe program to debugfinishes executingwithout finding divergingbehavior programfinished green part ofthe bar or because of diverging debugger behavior the rest of the bar all othercolors .
effectiveness.
afteratmost x 20generatedexecutionactions i.e.
start execution resume and steps we have found some typeof diverging behavior in .
of the runs which substantiates our claimthatdifferentialtestingiseffectivefordebuggers.thehigh numberoffounddivergingbehaviors 1692intotal hasalsomotivated assigning them into equivalence classes for more effective manual inspection.
numberofactions.
weseeat x 0thatonlybysettingbreakpoints and without starting the programs to debug .
of thetestrunsalreadyfinddivergingbehaviorbetweendebuggers.
after a single start execution action x an additional of the test runs find diverging debugger behavior not due to breakpoints.
several programs to debug .
also immediately finish execution presumably because all breakpoints were set in not executed code.
with each additionally generated action more diverging behaviors are found which affirms that debugger testing is more effective when combining several debugging actions.
after fiveactions however thegraphquicklysaturatesandadditional actions find only marginally more diverging behaviors.
after generated execution actions .
of the runs have completed and only runs have to be stopped becausethe maximum numberofactionsisreached.thismakesclearthat20execution actions issufficient inmostexecutions.
differencetypes.
assaidbefore mostdivergingbehaviors .
arefoundwithout everexecutingtheprogram to debug but simply by comparing breakpoints between debuggers.
when comparingtheprogramstatebetweendebuggersfrom x 1on wesee that the majority of differences are either because one debugger already finished executing while the other is still running light blue .
at x or because the debuggers do not agree on their pause location dark blue .
.
both cases are indicative 617feedback directeddifferential testingofinteractive debuggers esec fse november4 9 lake buena vista fl usa bps only1 maximum number of execution actionscompleted runs cumulative completed with result program finished variable di fference call stack di fferencepause location di fference termination di fference breakpoint di fference figure completed test runs and their results per maximum numberofgenerated execution actions.
table2 thetop6equivalenceclassesofdivergingbehavior.
diff.
type last action ast node size in setbreakpoint setbreakpoint program .
setbreakpoint setbreakpoint arrayexpr .
setbreakpoint setbreakpoint binaryexpr .
pausedline stepin forstmt .
setbreakpoint setbreakpoint property .
pausedline stepover forstmt .
of a debugger either not pausing where it should or pausing too often.onlyaminorityofthedifferencescomefromcomparingcall stackandvariables .
and4.
respectively whichcorrelates with the smaller number of bugs we have found related to these debugger features.
.
.
effectiveness of equivalence class sampling.
the large number of found diverging behaviors cannot all be manually inspected and we thus need to restrict ourselves to a subset.
in section .
wearguedthatmorediversedivergingbehaviorscanbefoundby first assigning each diverging behavior to an equivalence class and then sampling these classes in a round robin manner for manual inspection.we evaluatethe effectivenessof thisheuristic through twoquestions how many equivalence classes exist and is it feasible to inspect at leastone divergingbehaviorper class?
doessamplingdivergingbehaviorsfromtheseclasses instead ofsamplinguniformlyoveralldivergingbehaviors helpfinding more unique root causes per inspecteddivergingbehavior?
equivalence classes.
in total there are equivalence classes which is a manageable number to manually inspect in particular compared to the total number of traces with diverging behavior.
this strong reduction is mainly caused by some large equivalenceclasses thetopsixareshownintable .thelargest equivalenceclasscontainsalmostathirdofalldivergentbehaviors.
as indicated by the difference type and last action these diverging behaviors are caused by setting a breakpoint at the program ast node.
programis the root of the javascript ast so this means a breakpoint was set in an empty or comment line.
almost all divergent behaviors in this class are instances of a single bug inchromiumrelatedtobreakpointslidingforemptylinesandcomments.16similarly theequivalenceclassesofsettingbreakpoints atarrays binaryexpressions orobjectpropertiesarelargebecause firefox allows to set breakpoints at literals which are common at theseastnodes whereaschromiumdoesnot.finally weseetwo largeclassesrelatedtosteppingand forstmt whichinstancesof the difference in step semantics between firefox and chromium that we explainedinsection .
.
moreeffectivemanualinspection.
inresponsetothesecondquestion we evaluated the number of unique root causes we find when uniformly sampling diverging behaviors compared to when we sampleoutoftheequivalenceclasses.
arootcause iseitheranid fromtheissuetrackersforbugsthatwereported oranidentifier for consistent semantic differences we foundbetween firefox and chromium.
figure 9shows that manually inspecting divergingbehaviorsfromequivalenceclasseshaveledustoidentify24 uniquerootcauses whereasuniformlysamplingfromalldiverging behaviorsuncoversonly12.oneexplanationforthisisrootedin the large equivalence classes discussed before.
when uniformly sampling diverging behaviors we get many instances out of these large classesthat are mostly causedbyjust asinglebug.
regardingthetimespentonanalyzingdivergingbehaviorsfrom equivalence classes and reporting all bugs including manually creatingminimaltestcases weestimatetheeffortaslessthana weekforoneperson.wedonotevaluatethetruepositiverateof dbdb because defining true positives is difficult in the absence of aclear specification ofexpecteddebugger behavior.
.
.
performance.
we evaluate the runtime of our approach to assesswhetherdbdbcouldscaletomanymoreprograms to debug.
since the assignment of diverging behaviors to equivalence classes isperformedjustonceafteralldifferentialtestingcompletedand takes less than two seconds we exclude it from our measurements.
to evaluate the differential testing of our approach we debug each of the programs times with different seeds.
that is even though the program execution itself remains the same dbdb sets different breakpoints andperforms e.g.
different steps or resume actions.
figure 8summarizes the runtimes of the approach.
the averagetestruntook448ms soperformance wiseourapproach can be applied to many more programs to debug.
obviously the runtime includes execution ofthe program to debug itself which iswhy someprograms taking consistently more time thanothers.
related work compiler testing.
compiler testing has a long history .
more recent approaches include csmith which randomly creates c programs and equivalence modulo inputs which createsvariantsofsuchprogramswithsupposedlyequivalentbehavior.
other work empirically compares compiler testing techniques prioritizesgeneratedtestprogramstoexecutebug revealingprograms earlier generates test programs guided by a type and effect system andenumeratesalltestprogramswithinsome bounds .
lidbury et al .
and donaldson et al .
target compilersforopenclandglslprogramsrunningongpus.all of these approaches put an emphasis on generating programs as 618esec fse november4 9 lake buena vista fl usa daniellehmann andmichaelpradel controlflow recursivebitops nsieve bitsaccess nsieve access fannkuch math spectral normmath partial sumsaccess nbodycrypto sha1string fastapuzzler access binary treescrypto md5manual date format xparbdate format to e 3d raytracecrypto aespuzzler string validate inputpuzzler 11manual string base64puzzler 3puzzler 7puzzler 1puzzler 5puzzler 2puzzler 83d cubepuzzler 10puzzler 4manual 2math cordicmanual bitops bits in bytebitops bitwise and bitops 3bit bits in bytestring tagcloud3d morph string unpack coderegexp dna program to debugruntime in ms log scale figure runtime of the differential testing per program to debug.
since actions are randomly generated medians middle band andfirstandthirdquartile bottomandtopofbox areshownafter50runs.whiskersindicateminimumandmaximum.
number of inspected diverging behaviorsunique root causes foundsampling strategy round robin from equivalence classes all uniformly figure found unique root causes when sampling differenceequivalence classes compared to raw differences.
inputsfortesting whereasourworkondebuggersalsoconsiders the problem ofhowandwhen to create useractions.
differentialtesting.
theterm differentialtesting wasoriginally coined by mckeeman .
apart from compilers it has been appliedtootherdevelopmenttools suchasrefactoringengines symbolicexecutionengines x86disassemblers andbinary lifters .
our work differs by generating not only programs but alsodebuggeractionsassociatedwiththeprogram andbyusing executionfeedbacktoguidethegeneration.beyonddevelopertools differential testing can e.g.
be applied to code clones similar library implementations and supposedly behavior preserving subclasses .arelatedconceptis n version programming where multiple versions of a program are created to increase fault tolerance.experimentswithithaveshownthatsimilarerrorswere made by independent programmers hinting at a potential shortcomingofourapproach ifbothdebuggershavethesamebug dbdb cannotfind it.
inspecting warnings.
a recurring problem in automated testing isthehighnumberoftestcasesthatneedtobemanuallyinspected.
our heuristic of drawing diverging behaviors from equivalence classesinsteadofuniformlysamplingrelatestoworkbypodgurski et al.
who try to cluster software faults.
for evaluating our equivalence classes we use a method similar to chen et al .
.
anotherwaytoimprovehowusersinspectwarningsreportedbya toolistoaskspecificquestionsthatmayeliminatefalsealarms .
interactivetesting.
unlikecompilers debuggersareinteractive whichprecludesgeneratingalltestinginputsbeforehand.ourinteractiveapproachthatalternatesbetweengeneratinginputsand comparingoutputsissimilartopriorworkonautomatedtestingof guis whichare alsointeractive.
cross browser testing.
our implementation of dbdb targets thedebuggersinfirefoxandchromium.assuch itisalsointhelineofmanyworksthatperformcross browsertesting.roychoudhary et al.
visually compare websites to identify issues in rendering by different browsers and mesbah and prasad additionally incorporateuserinteractionintothecomparisonofbrowserbehavior.
treefuzz compares javascript implementations of browsers by fuzz generatingjavascript programs .
debuggerandtoolingcorrectness.
animportantsteptoimprove the correctness of debuggers is specifying their intendedbehavior.
bernsteinandstark formallydefinethesemanticsofadebugger for a small functional language but not for a debugger used in practice.
the differences discovered by dbdb may help to identify situationsthatrequiremoreprecisespecification.similarinspirit to our work is the vision of cadar and donaldson .
they postulate that even though much effort goes into developing program analyzers the tools themselves are often not put under enough scrutiny.theycallfor analyzingtheprogramanalyzer andour firststep isto find bugsindebuggers.
conclusion and outlook this paper presents the first approach for automatically testing interactive debuggers.
dbdb compares the behavior of two debuggers by exercising them with generated sequences of debugging actions.
our work builds upon a finite state model that captures commonfeaturesofreal worlddebuggers.weevaluatedbdbwith the javascript debuggers of firefox and chromium where we find clear bugs and several other noteworthy differences.
eight of these bugs have already been fixed by the respective developers andourresultshavespurreddiscussionsabouttheintendedsemantics of debuggers.
while testing compilers has received significant attention we hope this work motivates more researchers to also put other development tools under scrutiny.
it is worrying that debuggers a fundamental development tool for understanding programs arethemselvesbuggyandevenmoresothattheintended semanticsofseeminglysimplefeatures suchasstepping arenot preciselyspecified.findingbehavioraldifferencesbetweenexisting debuggers isafirststep towardsfixing theseproblems.