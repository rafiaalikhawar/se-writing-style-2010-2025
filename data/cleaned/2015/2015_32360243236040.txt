how should compilers explain problems to developers?
titus barik microsoft redmond wa usa titus.barik microsoft.comdenae ford nc state university raleigh nc usa dford3 ncsu.eduemerson murphy hill nc state university raleigh nc usa emerson csc.ncsu.educhris parnin nc state university raleigh nc usa cjparnin ncsu.edu abstract compilers primarily give feedback about problems to developers through the use of error messages.
unfortunately developers routinely find these messages to be confusing and unhelpful.
in this paper we postulate that because error messages present poor explanations theories of explanation such as toulmin s model of argument can be applied to improve their quality.
to understand how compilers should present explanations to developers we conducted a comparative evaluation with professional software developers and an empirical study of compiler error messages found in stack overflow questions across seven different programming languages.
our findings suggest that given a pair of error messages developers significantly prefer the error message that employs proper argument structure over a deficient argument structure when neither offers a resolution but will accept a deficient argument structure if it provides a resolution to the problem.
human authored explanations on stack overflow converge to one of the three argument structures those that provide a resolution to the error simple arguments and extended arguments that provide additional evidence for the problem.
finally we contribute three practical design principles to inform the design and evaluation of compiler error messages.
ccs concepts human centered computing empirical studies in hci software and its engineering integrated and visual development environments keywords communication theory compilers debugging error messages explanations stack overflow acm reference format titus barik denae ford emerson murphy hill and chris parnin.
.
how should compilers explain problems to developers?.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction compilers primarily give feedback about problems to developers through the use of error messages.1despite the intended utility of error messages researchers and practitioners alike have described their output as cryptic difficult to resolve not very helpful appalling unnatural and basically impenetrable .
while poor error messages are paralyzing for novices even experienced developers have substantial difficulties when comprehending and resolving them.
a study conducted at google found that nearly of builds fail due to a compiler error and that the median resolution time for each error is minutes .
surprisingly the costly errors that developers make are rather mundane relating to basic issues such as dependencies type mismatches syntax and semantic errors.
barik et al .
conducted an eye tracking study with developers and found that they spent up to of their task time on reading error messages.
in addition developers in a study by johnson et al .
reported that error messages were often not useful because they did not adequately explain the problem.
it isn t difficult to come up with instances of poor error message explanations even for routine problems.
consider the following java code snippet 2void m final int x while true x read and the resulting error message from the openjdk compiler f.java error variable x might be assigned in loop x read error although the location of the message is reasonable intuitively this is a poor explanation.
the problem isn t just that the variable x is being assigned in a loop this particular variable also happens to be marked final line .
a final variable can only be assigned once.
what if we had received the following error message instead?
f.java error the blank final variable x cannot be assigned within the body of a loop that may execute more than once.
x read this second message gives a better explanation and developers in our study preferred it significantly over the first section .
.
1modern compilers allow developers to turn warning messages into error messages for example by applying a werror flag.
thus in this paper we treat warning messages as identical to error messages.
esec fse november lake buena vista fl usa titus barik denae ford emerson murphy hill and chris parnin specifically the second message not only indicates that there is a problem the blank variable x cannot be assigned but also supports this claim by offering evidence or grounds that clarify why this is a problem because x cannot be assigned within the body of a loop that may execute more than once .
that is to say the second message has a better explanatory structure than the first.
this message also delivers more specific content .
in contrast to the relatively vague variable x in the first message it is immediately apparent in the second message that x is ablank final without being too verbose.
if compiler error messages are framed as explanations then it follows that we can apply theories of explanation to understand why some error messages are more effective than others .
to that end this paper applies toulmin s model of argumentation section a theory for the structure and content of messages in everyday discourse to the design and evaluation of compiler error messages.
to understand if developers find explanatory error messages helpful we conducted a comparative study between two compilers for the same programming language and had experienced developers within a large software company indicate which message they would prefer in their compiler.
then to understand why some error messages produced by compilers are less helpful than others we conducted an empirical study through a popular question andanswer site stack overflow.2from stack overflow we extracted question answer pairs posted by developers about compiler error messages across seven different programming languages.
for every question answer pair we qualitatively coded the compiler error message found within the question and the accepted humanauthored answer through the theoretical model of argumentation.
we characterized these question answer pairs both in terms of the structure andcontent of their explanation.
from this analysis we can better understand the structure and content that compilers should use in explanations to developers.
the results of our studies provide support for presenting compiler error messages to developers as explanations.
we find that developers when shown a pair of error messages prefer the error message with a proper argument structure over the message with a deficient argument structure but will prefer the deficient argument if it provides a resolution to the problem section .
and human authored explanations converge to argument structures that offer a simple resolution or to structures with proper arguments section .
.
they do so using a catalog of content within the structure section .
.
from these results we contribute three design principles for compiler authors to inform the design and evaluation of error messages section .
background on explanations arguments are a form of justification explanation in which reasons are used as evidence to support a conclusion .
argumentation theory provides a lens through which we can evaluate the effectiveness of arguments .
within argumentation theory toulmin s model of argument is one such informal reasoning model.
the model characterizes everyday arguments or how arguments occur in practice through ordinary human dialogue .
specifically toulmin s model of argument is a macrostructure model.
claimresolution warrant a simple argument layout grounds claim qualifier rebuttalresolution warrant backing b extended argument layout figure toulmin s model of argument for a simple argument layout and b extended argument layout.
extended arguments add a rebuttal backing or qualifier to a simple argument.
macrostructure examines how components combine to support the larger argument within this macrostructure microstructure examines the phrasing and composition of the sentence level statements.
for clarity we will refer to macrostructure simply as structure or layout and microstructure as content .
in a simple argument layout figure 1a the first component is a claim the assertion view or judgment to be justified resolutions are also a form of claim though resolutions are optional in an argument layout.
the second component grounds are data that provide evidence for this claim.
the third component is a justification or warrant which acts as a bridge between the grounds and the claim for example because .
together the claim with optional resolution the grounds and the warrant provide a simple argument layout.
the simple argument layout is the minimal proper argument structure.
arguments that do not have at least these three components are considered to be deficient .
specific to error messages are claim resolution the first claim states the problem and the second claim states the resolution or fix.
although these are not proper argument structures they are nevertheless useful.
toulmin also devised an extended model of argument to acknowledge the possibility of needing to infuse additional components within an argument figure 1b .
in addition to the simple argument components the extended argument layout offers a rebuttal when an exception has to be inserted into the argument.
the claim may also not be absolute in this case a qualifier component can temper the claim.
finally a warrant may not be immediately accepted by the other party in which case additional backing is 634how should compilers explain problems to developers?
esec fse november lake buena vista fl usa error java incompatible types c bad return type in lambda expression bc w g java.lang.string cannot be converted to void b figure a compiler error message from java annotated with argumentation theory components.
this particular message contains all of the simple argument components to satisfy toulmin s model c claim bc w implied because warrant g grounds.
it also includes an extended argument component b backing.
needed to support the warrant.
if anyof these additional components are used in the argument the argument becomes an extended argument.
an example of how a compiler error message is mapped to an argument structure is illustrated in figure in this example the error message is an extended argument because it has a backing.
methodology .
research questions in this study we investigate the following research questions and offer the motivation for each rq1 are compiler errors presented as explanations helpful to developers?
if explanatory compiler error messages are useful to developers then given a pair of messages where one of the messages provides a proper argument and the other message provides a deficient argument developers should prefer the message with the proper argument.
if this is not the case for the pair then perhaps developers prefer the error message presentation because of other factors such as the verbosity of the error message.
rq2 how is the structure of explanations in stack overflow different from compiler error messages?
if compiler error messages and stack overflow accepted answers use significantly different argument layout components this would suggest that structure differences in argument play an important role in the confusion developers face with compiler errors.
while some approaches to improving compiler error messages focus on the content for example confusing wording in the messages structure differences emphasize how components combine to support the larger argument rather than the statements themselves.
content improvements may be ineffectual without a supporting structure.
further the answer to this question helps us to understand the types of argument layouts that are used in accepted answers.
in other words toolsmiths can use the design space of argument layout to model and structure automated compiler error messages for developers.
importantly the argument layout space can also be used as a means to evaluate existing error messages and to identify potential gaps in argument components for these messages.
rq3 how is the content of explanations in stack overflow different from compiler error messages?
once the argument layouts are identified learning how the components within these layouts are instantiated provide content details for what information developers find useful within each component.
for example one way to instantiate backing for a warrant might be to provide a link to external documentation and if we find that acceptedtable openjdk and jikes error message descriptions tag compiler error message e1 openjdk variable x might be assigned in loop.
jikes the blank final variable x cannot be assigned within the body of a loop that may execute more than once.
e2 openjdk cannot find symbol symbol variable varnam location class foo jikes no field named varnam was found in type foo .
however there is an accessible field varname whose name closely matches the name varnam .
e3 openjdk static method should be qualified by type name foo instead of by an expression.
jikes invoking the class method f via an instance is discouraged because the method invoked will be the one in the variable s declared type not the instance s dynamic type.
e4 openjdk method remove in class a.b cannot be applied to given types required no arguments found int reason actual and formal argument lists differ in length jikes the method void remove int x contained in the enclosing type a is a perfect match for this method call.
however it is not visible in this nested class because a method with the same name in an intervening class is hiding it.
e5 openjdk illegal static declaration in inner class a.b.
modifier static is only allowed in constant variable declarations.
jikes this static variable declaration is invalid because it is not final but is enclosed in an inner class b .
answers do so toolsmiths may also consider incorporating such information in the presentation of their compiler error messages.
635esec fse november lake buena vista fl usa titus barik denae ford emerson murphy hill and chris parnin .
phase i study design for comparative evaluation to answer rq1 we asked professional software developers to indicate their preference between corresponding compiler error messages that explained the same problem but were produced by different compilers.
compiler selection rationale.
we needed to compare two compilers which produced different error messages for the same problem in the code preferably where one compiler produced error messages with better explanatory structure than the other.
we selected the jikes and openjdk compilers for this purpose.
jikes is a java compiler created by ibm for professional use with a primary design goal of high quality explanations produced by the compiler .
though now discontinued jikes has been lauded by the developer community for giving better error messages than the jdk compiler .
task selection.
to select candidate error messages the first author wrote source code listings that induced an error message in both jikes and openjdk.
although jikes has possible compiler errors it is not possible to map all errors directly to openjdk because the compilers are not isomorphic.
that is source code accepted by one compiler may be rejected by the other.
from this set the first author examined error messages produced by jikes and identified those which contained argument structure.
to determine if an error message contained any elements of argument structure the first author tagged each message using labels from toulmin s model of argument claim and resolution grounds warrant qualifier rebuttal and backing.
we found error messages which used at least a simple argument in jikes.
we then examined the corresponding openjdk messages and found only error messages used simple arguments.
to keep the study brief we deliberately selected openjdk and jikes compiler error messages that address the same problem but differ in argument structure.
for each pair of error messages we consulted with two compiler experts to form a hypothesis on how differences in argument structure would influence the results e1deficient argument vs. simple argument.
both openjdk and jikes make a claim that the variable might be assigned in a loop.
but jikes completes a simple argument by presenting aground for why this problem is actually a problem if the loop executes more than once.
e2deficient argument vs. extended argument.
again openjdk only presents a claim .
jikes presents a ground there is an accessible field varname which is qualified through a rebuttal however .
e3claim resolution vs. extended argument.
theshould in the openjdk message would suggest that this is an extended argument but the error message has no ground.
thus it is a claim resolution structure which is not formally considered an argument.
the jikes message is an extended argument because of discouraged but jikes does not offer a resolution for how to address the problem.
e4different claim same extended argument.
both messages provide an extended argument but for different claims.
openjdk assumes that the developer is trying to recursively call thecurrent method remove .
jikes assumes that the developer wants to a call a class method remove int x from the method remove .
since the developer does not know which fix is actually intended their judgment about which message is correct should be influenced by quality of the content and not the argument structure.
thus we expected participants to prefer jikes.
e5same claim same simple argument.
both openjdk and jikes present the same argument but is enclosed in an inner class b is simply the long form of a.bin the openjdk version .
the content of both messages are essentially the same with minor variations in wording final versus constant .
participants.
we recruited developers at a large software company to participate in this study.
as we were primarily interested in professional software development we selected our population from full time software developers excluding interns or roles such as testers or project managers.
we invited developers to participate in our study and received responses.
the average reported experience of our participants was .
years.
participants self reported being proficient in java and self reported being proficient with some other oop language e.g c .
procedure.
we designed a questionnaire which could be distributed and answered electronically.
in the questionnaire we asked demographic questions including years of programming experience and proficiency in programming languages.
to measure preference for compiler messages we presented participants with a forced binary choice for either the jikes or openjdk version of the error message alongside the source code listing that produced the two error messages.
we randomized error message order.
on average participants took seven minutes to complete our study.
.
phase ii study design for stack overflow to answer rq2 and rq3 we conducted a study on stack overflow.
research context.
previous research on stack overflow by treude et al .
identified questions regarding error messages as being one of the top categories and other research supports that stack overflow today is a primary resource for software engineering problems .
additionally stack overflow provides an open access api through stack exchange data explorer 3that allows researchers to mine their database.
an initial query against this dataset confirmed that questions about compiler error messages exist in stack overflow across a diversity of programming languages and platforms.
data collection.
we extracted all posts of type question or answer tagged as compiler errors or compiler warnings yielding compiler errors and compiler warnings but not including compiler errors as some warnings are also tagged as errors .
because some systems allow developers to flag warnings as errors we included these warnings in our set.
a subset of these questions links to an associated accepted answer which in this paper we term question answer pairs .
an accepted answer is an answer marked by the original questioner as being satisfactory in resolving or addressing their original question.
636how should compilers explain problems to developers?
esec fse november lake buena vista fl usa table compiler errors and warnings count by tag question count1 tag errors2warnings3total acc.
cov.
c java c c obj.
c swift python subtotals totals 1questions may be counted more than once if they have multiple tags for example candc .
2questions tagged as compiler errors .
3questions tagged with compiler warnings but not compiler errors .
4percentage of questions that have accepted answers.
5coverage of tag over the most popular languages from the stack overflow developer survey .
although a question may have multiple answers only one may be marked as accepted.
we used accepted answers as a proxy to identify helpful answers.
of messages have accepted answers .
for each question we extracted the compiler error message from the question.
if the question did not contain a verbatim compiler error message the question answer pair was dropped from analysis.
sampling strategy.
to target diversity rather than representativeness in programming languages we used stratified sampling across the top programming languages in our corpus until we covered over of the most popular languages from the stack overflow developer survey .
this threshold was exceeded at python table .
within each stratum we used simple random sampling for selecting question answer pairs to analyze in which each question answer pair has an equal probability of being selected.
as we sampled we discarded questions that did not refer to or display a specific error message were incorrectly tagged for example not relating to an error message were related to issues in not being able to invoke the compiler in the first place for example g not found or were unambiguously trolling such as through deliberately bogus questions.4the time required to manually categorize question answer pairs has high variance from minutes depending on the complexity of the pair.
thus to balance breadth of languages and depth of error messages in each language while still keeping categorization tractable we continued this process until we obtained question answer pairs for each of the top seven languages for a total of question answer pairs.
4for example the post why is this program erroneously rejected by three c compilers?
attempts to compile a hand written c program scanned as an image through three different compilers.
the offered answers are equally sardonic.
closed coding.
the first and second authors performed closed coding that is coding over pre defined labels for each compiler error message extracted from the stack overflow question and over the complete stack overflow accepted answer for that question.
we tagged these using labels from toulmin s model of argument claim and resolutions as claim grounds warrant qualifier rebuttal and backing.
thus we had a total of seven labels and a compiler error message or stack overflow accepted answer may be assigned more than one label.
during the coding process we employed the technique of negotiated agreement as a means to address the reliability of coding .
using this technique the first and second authors collaboratively code to achieve agreement and to clarify the definitions of the codes thus measures such as inter rater agreement are not applicable.
validity of negotiated agreement.
though negotiated agreement is established in other disciplines this qualitative coding technique has only recently been applied to software engineering research notably by hilton et al .
.
thus to assess the validity of negotiated agreement we recruited two independent evaluators iev1 iev2 to classify random question answer pairs that is messages or approximately of the pairs .
evaluators were provided with the definitions of argument layout components as well as a diagram of proper and deficient argument layouts figure .
evaluators classified messages in the question answer pairs as either claim only claim resolution simple argument or extended argument.
we then calculated cohen s between the evaluators and against our negotiated agreement classifications iev1 and iev2 .
iev1 and negotiated agreement .
and iev2 and negotiated agreement .
.
cohen s supports the validity of negotiated agreement .70is considered substantial agreement by landis and koch good by bland and altman and fair good by fleiss et al .
.
follow up revealed that evaluators were hesitant to apply the tag backing due to inexperience with toulmin s model of argument.
therefore cases of disagreement between independent evaluators can be explained by evaluators shifting extended arguments to simple arguments.
supporting verifiability.
if using a supported pdf reader quotations from stack overflow are hyperlinked and can be clicked to take the reader to the corresponding stack overflow page.
analysis .
rq1 are compiler errors presented as explanations helpful to developers?
for the analysis of rq1 we performed a chi squared test on each of the five error messages e1 e5 table using the developer responses as the observed values for openjdk and jikes.
if we use a null hypothesis where both messages are equally acceptable then the expected values would be split such that openjdk and jikes receive roughly half of the counts.
in effect this situation is essentially analogous to a coin toss problem where heads is say openjdk and tails is jikes.
the null hypothesis is rejected .
if the observed values are significantly different from the expected values.
5these