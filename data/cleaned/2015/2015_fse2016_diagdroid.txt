diagdroid android performance diagnosis via anatomizing asynchronous executions yu kangyzy angfan zhou xhui xuyzmichael r. lyuyz school of computer science fudan university china yshenzhen research institute the chinese university of hong kong china zdepartment of computer science and engineering the chinese university of hong kong china xengineering research center of cyber security auditing and monitoring ministry of education china abstract rapid ui responsiveness is a key consideration to android app developers.
however the complicated concurrency model of android makes it hard for developers to understand and further diagnose the ui performance.
this paper presents diagdroid a tool speci cally designed for android ui performance diagnosis.
the key notion of diagdroid is that ui triggered asynchronous executions contribute to the ui performance and hence their performance and their runtime dependency should be properly captured to facilitate performance diagnosis.
however there are tremendous ways to start asynchronous executions posing a great challenge to pro ling such executions and their runtime dependency.
to this end we properly abstract ve categories of asynchronous executions as the building basis.
as a result they can be tracked and pro led based on the speci cs of each category with a dynamic instrumentation approach carefully tailored for android.
diagdroid can then accordingly pro le the asynchronous executions in a task granularity equipping it with low overhead and high compatibility merits.
the tool is successfully applied in diagnosing real world open source apps and we nd of them contain performance issues.
it shows the e ectiveness of our tool in android ui performance diagnosis.
the tool is open source released online.
ccs concepts software and its engineering !software performance keywords android performance diagnosis ui responsiveness .
introduction as daily use personal devices smartphones are required to provide quick response to the user interface ui .
ui performance of a smartphone app is a critical factor to its user experience and hence becomes a major concern to developers .
many recent research e orts have therefore beenput on addressing the performance issues of android apps e.g.
asynchronizer panappticon .
however poor ui performance of android apps remains a widely complaint type of issues among users .
app developers are still lacking a handy tool to help combat performance issues.
android provides a non blocking paradigm to process ui events i.e.
user inputs for its apps.
the ui main thread dispatches valid ui events to their corresponding ui event procedures i.e.
the ui event handling logic .
a ui event procedure generally runs in an asynchronous manner so that the main thread can handle other ui events simultaneously.
after the asynchronous part is done the ui can be updated with a call back mechanism.
this paradigm will lead to complicated concurrent executions.
the asynchronous execution processes may bear implicit dependency during their runtime.
for example two may be scheduled to run in the same thread by android and one may consequently wait for the other to complete.
such unexpected waiting may result in longer delay for a ui procedure leading to ui performance issues.
however it is hard to predict such runtime dependency during the coding phase due to the complications of android s asynchronous execution mechanisms .
performance issues are hence inevitable.
concurrency is a notorious source of bugs .
current tools for diagnosing android ui performance issues generally consider either the synchronous part of the ui event procedure or the execution process of one ui event procedure per se .
they do not focus on the dependency of multiple asynchronous execution processes.
hence they are still not enough to cope with the ui performance issues largely caused by such runtime dependency.
long term testing is a well known viable means to trigger bugs caused by concurrency .
unfortunately we lack an automatic mechanism to verify whether there exists a performance issue in the long term testing.
manual inspection of the tremendous traces produced by current method tracing tools e.g.
traceview is extremely labor intensive if not infeasible not to mention their huge overhead.
we nd that unlike general concurrent programs an android ui event procedure can be anatomized into a set of trackable tasks which can then be properly pro led so as to facilitate the detection and localization of performance issues.
speci cally although android supports tremendous ways to schedule asynchronous executions we conclude that they can actually be abstracted as ve categories.
executions of each category can be tracked and pro led in task granularity according to their speci cs.
ui performance can hence be modeled by the performance of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
410file d svn perf test paper fse2016 perftest fig original asy nctask.java page of 1public class myactivity extends activity private class retrievedatatask extends asynctask string void string ... will be executed asynchronously in a worker thread protected string urls ... retrieve content from internet return content onpostexecute will be invoked in the main thread after completes which shows the downloaded content in the ui.
protected void onpostexecute string content this .textview.settext content ...private class myonclicklistener implements onclicklistener protected void onclick view v retrievedatatask task1 new retrievedatatask textview1 call execute method according to the example of official document task1.execute url1 figure an asynctask example the tasks.
we further tackle the complication of runtime dependency via examining the dependency of tasks which can be solved by checking whether the tasks request the same execution unit e.g.
a thread pool .
via modeling task performance by not only its execution time but the time when it waits for execution i.e.
the time between when it is scheduled and when it starts execution we can model how a task is in uenced by the others.
thus performance issues due to asynchronous executions can be properly captured.
hence this paper proposes diagdroid performance diagnosis for an droid a novel tool to exercise pro le and analyze the ui performance of an android app without modifying its codes.
first via a light weight static analysis of the target app diagdroid obtains the necessary information for pro ling.
then it employs a plugin testing approach e.g.
monkey to exercise the original app.
the required runtime data are then captured during the testing run via its pro ler.
the data are then processed o ine to generate a human readable report.
the report can unveil potential performance bugs to developers and direct them to suspicious locations in the source codes.
human e orts can greatly be reduced in diagnosing ui performance issues.
finally diagdroid solves the compatibility and e ciency challenges generally faced by the dynamic analysis tools by slightly instrumenting only the general android framework invocations with a dynamic instrumentation approach.
hence it can be applied to most o the shelf smartphone models and apps.
we have implemented and released diagdroid .
we show it is easy to apply it to real world apps with light congurations.
in the open source real world apps we study performance defects in apps are found and we receive positive feedbacks from their developers.
these defects are caused by the complicated dependency of asynchronous executions which can hardly be located with current diagnosis practice.
this shows the e ectiveness of diagdroid .
.
android application specifics .
ui event processing designed mainly for user centric usage patterns android apps are typically ui oriented an app will iteratively process user inputs and accordingly update the display to show the intended contents.
the main thread of an app is the sole thread that handles the ui related operations such as processing user inputs and displaying ui components e.g.
buttons and images .
when a valid user input i.e.
a ui event comes the main thread can invoke its corresponding ui event procedure i.e.
the codes that handle the ui event.
some ui event procedures may be time consuming e.g.
file d svn perf test asynchook app src main java com cudroid xposed activityhook various async exec.java page of 1package com.cudroid.xposed.activityhook import android.app.downloadmanager import android.app.intentservice import android.content.context import android.content.intent import android.net.uri import android.os.asynctask import android.os.handlerthread import java.util.concurrent.executorservice import java.util.concurrent.executors created by curid on .
public class asynctasks extends context private class downloadrunnable implements runnable downloadrunnable string url override public void run private string url public class downloadservice extends intentservice public static string urlkey public downloadservice string name super name public downloadservice super override protected void onhandleintent intent intent public class downloadtask extends asynctask public downloadtask string url override protected object objects return null public void asynctasks create a new thread and download in that thread thread thread new thread new downloadrunnable url thread.start download in one thread of a thread pool with capacity executorservice threadpool executors.newfixedthreadpool threadpool.execute new downloadrunnable url download with aysnctask asynctask asynctask new downloadtask url asynctask.execute download in a handlerthread by posting a task on the attached handler handlerthread handlerthread new handlerthread downloadhanderthread handlerthread .start download in a user defined service intent downloadintent new intent this downloadservice.
class downloadintent.putextra downloadservice.urlkey url use standard downloadmanager service utilizing threadpoolexecutor implictly downloadmanager dm downloadmanager getsystemservice download service downloadmanager.request req new downloadmanager.request uri.parse url dm.enqueue req thread threadpool executor handler intent service download managerasynctaskfigure asynchronous execution examples one to download a le from the internet.
to avoid blocking the main thread ui event procedures conduct heavyweighted work in an asynchronous manner so that the main thread can handle other ui inputs simultaneously .
after such asynchronous executions are done the ui can be updated in the main thread with a call back mechanism.
figure shows the codes of an activity i.e.
a window container for the ui components to be displayed .
it retrieves data from the internet and displays the data in a textview i.e.
a ui component to display text after a button is touched.
the internet access is done asynchronously in another thread while the textview update is done in the main thread.
more speci cally the retrievedatatask extends the asynctask class.
it overrides the method to allow accessing the internet asynchronously in a worker thread.
its onpostexecute method is a call back mechanism to allow the corresponding textview object update in the main thread.
these codes are abstracted from restc project which shows a common coding practice.
.
asynchronous executions android provides high exibility to implement asynchronous executions.
there are tremendous ways for an app to start asynchronous executions e.g.
using asynctask threadpoolexecutor and intentservice .
actually we nd hundreds of classes or methods in the android framework that can start asynchronous executions.the implicit ways to start asynchronous executions include for example those via the customized classes that override the android framework classes such as asynctask orhandlerthread .
figure shows various ways of conducting asynchronous executions.
for a simple task to download internet contents we could name at least ways including examples shown in figure and figure .
choosing which way generally depends on the developer s own preference.
no matter how an asynchronous execution starts it is executed by the operating system os via the thread mechanism so as to implement concurrency.
however android may start a new thread or reuse a running thread for the asynchronous execution.
as a result di erent asynchronous executions may share the same thread and run sequentially.
in other words they may compete for the same execution unit.
unfortunately it is hard for the developer to be aware of such dependency of asynchronous executions she may not know exactly how the asynchronous executions run.
the complex ways of starting asynchronous executions together with their complicated runtime dependency make it di cult for developers to comprehend the performance of the ui event procedures they write.
performance issues are hence hard to be eliminated without a proper tool.
next we will show a representative performance issue.
.
a motiv ating example synchronous part of a ui event procedure may cause laggy ui if it contains time consuming codes .
however addressing performance problems solely in the synchronous part is far from enough.
when a user is su ering from laggy ui she is actually experiencing a long period of time between her ui operation and its corresponding display update.
even if asynchronous executions are introduced to make the synchronous part completing quickly she still experiences laggy if the asynchronous executions are slow and consequently cause the slow intended display update.
as android allows complex ways to start asynchronous executions it may introduce various tricky performance issues.
the issues may lie in simple widely adopted and seeminglycorrect codes.
next we show a subtle performance issue caused by unexpected sequentialized asynctask s. suppose an event procedure will show internet contents in three textview s in an activity .
as the contents are independent developers expect to download them in parallel.
they may instantiate three retrievedatatask objects dened in figure and invoke their execute methods which is given as a usage example in the o cial guide as follows.
new retrieveinfotask .execute url1 new retrieveinfotask .execute url2 new retrieveinfotask .execute url3 they may believe every retrievedatatask s will be executed in separated threads and hence calling their execute methods makes them run in parallel.
however the codes contain a subtle potential performance issue.
in the recent versions of android the execute method de ned in the superasynctask class will insert the corresponding tasks into a global thread pool with capacity one.
thus all retrievedatatask s will be executed in sequence in one thread instead of in parallel in multiple threads.
this incurs more time to complete the download tasks and to accordingly update the ui.
as a result the user may experience a laggy ui.
such a code defect can be resolved by calling executeonexecutor to customize a larger thread pool instead.
it is also worth noting that such sequential execution mechanism is introduced in android .
or above.
in the earlier versions the codes will run in parallel as expected.
it is easy for developers to neglect such changes and introduce potential performance issues.
such defects are common.
our experimental study nds eight such cases in real world apps.
the above performance issue actually can hardly be tackled by current tools.
strictmode and asynchronizer consider only the synchronous part of a ui event procedure which cannot locate the issues caused by the asynchronous executions.
other tools like panappticon method tracing can track such executions.
but they largely do not focus on the runtime dependency of asynchronous executions.
it is hard to nd out such dependency via examining the tremendous traces produced by these tools.
hence they are still not enough to cope with ui performance issues.
fixing this gap is one major aim of diagdroid .
.
ui performance diagnosis we notice the key to pinpoint the above performance issue is to know not only the execution time of an asynctask but the time between when it is scheduled and when it starts to execute i.e.
the queuing time as well as the other asynctask s that are in the same thread pool.
speci cally an unexpected long queuing time of an asynctask indicates a app binary runtime datatestexecute dependency aware performance diagnosisdefects asynchronous execution based profilingstatic analysis cases app info figure diagdroid overview performance issue.
we can know there are too many asynctasks in the pool.
by examining which asynctask s are in the pool and the pool capacity we can locate the cause.
the above notion can also be applied to other mechanisms that start asynchronous executions.
this is the basis of the diagdroid design which we overview in figure .
diagdroid anatomizes the android ui event procedures into a set of tasks and then quantize them so that data analysis can be conducted towards automating performance diagnosis.
speci cally as shown in figure diagdroid rst performs a light static analysis of the target app and obtains some required information to assist runtime pro ling.
it then exercises the original app via a plugin testing approach which can involve random test cases e.g.
monkey or user de ned ones e.g.
robotium uiautomator .
during the testing run the pro ler can track asynchronous executions so as to anatomize the ui event procedures into a set of tasks.
the performance of the tasks together with their runtime dependency can then be captured.
based on the pro ling data diagdroid detects performance issues and analyzes their causes.
a report can nally be generated with an aim to direct the debugging process.
to this end we need to address several critical considerations.
next we will discuss the pro ling granularity of diagdroid and the required runtime data for modeling asynchronous executions and their runtime dependency in section .
.
then we illustrate how such data can facilitate ui performance diagnosis in section .
.
.
modeling tasks and their dependencies as shown in section the subtle runtime dependency of asynchronous tasks can result in tricky performance issues.
analyzing such dependency is a key concern to diagdroid .
we analyze the app runtime in tasklevel de ned as follows.
de nition .
anasynchronous task or task is a segment of codes that run in sequence in a single thread.
it de nes a developer intended asynchronous execution process.
diagdroid pro les the app runtime in task granularity.
the reasons are as follows.
first it is good enough for performance diagnosis to pro le in such a granularity.
a task is a short segment of codes that can also be well understood by its developer.
if the developer can know which task is anomalous she can instantly reason its cause by inspecting the task related codes.
second such a granularity will not incur too much pro ling overhead compared with the ner granularity e.g.
in method level or in line level .
most importantly pro ling app runtime in task granularity can well capture the runtime dependency of two asynchronous tasks.
as a result ui performance issues caused by such dependency can be easily detected and located.
the task performance naturally re ects the performance of the entire ui event procedure a slow task may result in a slow ui event procedure leading to a laggy ui.
next we discuss modeling task performance.
we are aware that a task is possibly queued in an execution unit before it is executed.
as a result the execution time as well as the queuing time 412main threadasynctask capacity task 1task 2task task queuing task executing task scheduling task completiondefault thread poolfigure asynchronous tasks runtime in the unit should be considered in the performance model.
de nition .
the queuing time of a task is the interval between when the task is scheduled e.g.
when execute is called to start an asynctask and when it starts to execute.
we propose using both the queuing time and the execution time to model the task performance.
note that this is generally di erent from the current diagnosis practice with tools like traceview and dumpsys .
it is hard if not infeasible for these tools to obtain such data as they focus only on the execution time of individual methods.
the queuing time of a task is in uenced by the other tasks that may compete for the same execution unit.
we formally de ne task runtime dependency as follows.
de nition .
two tasks bear execution dependency if they run in the same execution unit and one task is scheduled in during the other task s queuing time.
as shown in section task runtime dependency is a critical factor that in uences the ui performance.
we propose employing three queue related features the queuing time thepool capacity and the queuing length of a task to model the task execution dependency.
de nition .
the pool capacity of an execution unit is the maximum tasks that the unit can simultaneously execute.
for example for a thread the pool capacity is while for a thread pool the pool capacity is its size.
pool capacity is usually set once and remains unchanged during runtime.
supposektasks bear runtime dependency in an execution unit with capacity nandk n .k ntasks have to wait for execution in the unit.
then when one task completes its execution one of the waiting tasks can be executed.
de nition .
the queuing length of a task is the total number of tasks waiting for execution in the execution unit after it is scheduled.
a queuing length lindicates that the task should wait for the completion of other ltasks before it can be executed.
figure illustrates how the three tasks discussed in section are executed.
the thread pool capacity of asynctask is .
when task is scheduled it has to wait until task nishes its execution.
so the queuing length of task is .
similarly the queuing length of task is .
the queuing time of a task re ects how other tasks in uence its performance.
the queuing length and pool capacity indicate the cause of a bad performance task.
such information can greatly help performance diagnosis.
however existing tools for performance diagnosis e.g.
panappticon method tracing cannot provide such information.
as a result it is di cult for them to diagnose the subtle performance issues caused by execution dependency.
we will elaborate how diagdroid collects these runtime data in section .
next we will rst discuss how diagdroid conducts performance diagnosis with the collected data.
.
dependency aware diagnosis a laggy ui indicates that a ui event procedure requires longer time to complete.
as discussed this can be rooted in either the synchronous or the asynchronous executions.
although many tools e.g.
have addressed the for mer case diagdroid moves a step further by focusing on the latter case a far more di cult task in addressing the subtle performance issues caused by the asynchronous executions.
if the asynchronous part is laggy it means at least one of the asynchronous tasks requires more time to complete.
consequently diagdroid should detect performance anomaly by checking whether there are any anomalous asynchronous tasks.
human inspection of all the involved tasks is prohibitively labor intensive.
diagdroid requires an automatic way to detect anomalous tasks.
a possible approach is to group the tasks in such a way that we can assume the tasks in the same group have similar performance.
then we can perform anomaly detection in a group basis.
but easy as it looks how to group the tasks is challenging.
an instant way is to consider the method call stack when a task is scheduled.
we name such call stack the execution context of the task.
the execution context actually links to the source codes that de ne the task and how the codes are reached.
two tasks with the same execution context mean that they are corresponding to the same speci c source code segment and execution sequence.
hence they should naturally be grouped together.
but this simple consideration will result in extensive debugging e orts.
a code defect may manifest in similar tasks with slightly di erent execution contexts.
reporting all such tasks one by one based on their execution contexts is very tedious and even makes the diagnosis di cult with such tedious information.
for example two ui event procedures of two buttons may invoke the same buggy asynchronous task in the source codes .
in these two cases the two task invocations have di erent execution contexts since they are invoked by di erent event procedures.
but we should group them together to reduce human e orts for code inspection.
diagdroid addresses the challenge by putting similar tasks into a group with properly de ned task similarity .
by considering each method call as a symbol an execution context can be encoded into a vector.
then the di erence of two tasks is the edit distance of their execution contexts.
we adopt such an edit distance as a similarity measure due to following considerations.
first it is suitable to model the di erences of two tasks.
consider the above example if two ui event procedures of two buttons invoke the same buggy asynchronous task the edit distance of execution contexts of the two task invocations will be close.
as a result they can be grouped together.
second it considers the invocation order information where such order is important to describe the app runtime.
consequently two close execution contexts indicate that the corresponding tasks are similar during runtime.
with such a similarity measure diagdroid conducts the single linkage clustering a widely adopted sequence clustering method to form groups .
diagdroid examines whether performance anomaly manifests in each group of tasks with the execution context queuing time and execution time.
diagdroid considers both the maximum value of queuing time and the execution time of all tasks within each group a. the values are denoted by mq a max q a andme a max e a 8a2a q a ande a are queuing time and execution time for task arespectively.
mq a andme a are the performance metrics of group a since either a long execution time or a long queuing time can result in anomalous performance.
diagdroid considers a group is anomalous if one of its two performance metrics is larger than a threshold .
it ranks 413table categories of asynchronous tasks category type representative classes reusing existing threads looper handler handlerthread intentservice pool based executor threadpoolexecutor asynctask creating new threads thread thread the anomalous groups according to their performance metrics as well as their execution contexts.
since each group is corresponding to a speci c source code segment the rank can direct the manual debugging e orts towards a suspicious code segment that may cause the performance anomaly.
moreover a key consideration of diagdroid is that the runtime dependency of tasks may also cause performance issues.
in other words the anomalous task per se is not always the root cause of its poor performance.
especially when the queuing time of the task is too long it is usually caused by other tasks that bear runtime dependency.
therefore diagdroid also employs the performance data the queuing length and performance of such tasks to locate the root cause.
we will show in our experimental study that the localization approach can greatly save human e orts.
we consider maximum values instead of average values as performance metrics.
a large average means that many tasks in the group perform poorly hence is a good indicator of performance issues.
however a small average for cases that only a small portion of the tasks perform poorly can still be an important symptom of performance issues .
since for the above two situations the maximum remains large we consider the maximum as performance metrics.
we have considered a performance threshold as an indicator of poor performance tasks.
is selected empirically based on the developers consideration on laggy ui.
previous work e.g.
has suggested user tolerable waiting time in web browsing mobile web browsing and mobile services which ranges from two to several seconds.
one second is considered as the limit for the user s ow of thought to stay uninterrupted .
we regard that mobile app users are more sensitive to ui response time.
thus we use ms as the value of .
we will show in our experimental study in section that such a value is an e ective choice.
.
profiling asynchronous tasks diagdroid requires to pro le the queuing time the execution time and the queuing length of a task as well as the pool capacity of an execution unit.
hence diagdroid must rstly track the life cycle of a task i.e.
when it is scheduled when it is executed and when it completes.
however there is no sole entry exit points for hundreds of ways to implicitly explicitly start asynchronous tasks mentioned in section .
it is di cult if not infeasible to design speci c pro ling mechanism for each.
we attack this challenge with a separation of concerns approach.
we rst classify the tremendous ways to start tasks into ve categories section .
.
then we can speci cally track and pro le the necessary runtime data for each category section .
.
.
categorizing asynchronous tasks we notice that the underlying mechanisms for android to execute a task can be narrowed down into two approaches reusing existing threads created beforehand and creating a new thread.
the former case can be further dividedinto two types one directly schedules a task pool based executor mechanism and the other requests the scheduling of a task by a delegate via sending a message looper handler mechanism .
we list them in table together with their representative classes in android.
both handlerthread and intentservice depend on the looper handler mechanism to start tasks.
they create a worker thread and wait for new tasks to the looper associated with the thread.
the request of scheduling a task is sent via ahandler attached to the looper.
the requested task will then wait to be processed in the worker thread.
since there is only one worker thread it can process one message at a time.
other requests should wait in a queue.
threadpoolexecutor and asynctask both use the poolbased executor mechanism.
they maintain a pool of worker threads with its size not exceeding a preset capacity.
a new coming task will be executed in one thread in the pool if there are available threads i.e.
the number of busy threads is smaller than the capacity .
otherwise the task has to wait for an available thread.
thread mechanism starts a task immediately in a new thread.
its building basis i.e.
the thread class in android is the same as the traditional java one.
the underlying mechanisms of numerous ways to implicitly or explicitly start asynchronous tasks are based on these ve representative classes.
for example the asyncqueryhandler class which conveniently queries data from a content provider is based on handlerthread .
the cursorloaderclass which acquires data from the database is based on asynctask .
moreover the downloadmanager mentioned in section employs the threadpoolexecutor .
each of the ve classes for conducting asynchronous tasks has its pros and cons.
the thread class is exible which enables fully control on the threading mechanism while more management e orts are required.
moreover creating a new thread per task consumes system resources.
the handlerthread class requires many development e orts to customize both the background threads and the handler for the tasks.
the threadpoolexecutor class as a traditional java class for multi threading is widely used to manage a pool of worker threads.
however comparing to the asynctask class it is unsuitable for tasks updating ui since android prohibits ui updating in worker threads.
the intentservice class can start a background service independent of the activity life cycle.
it is a relatively heavier container which requires more system resources on execution.
choosing which way depends on the speci c programming requirements as well as the developer s preference.
.
profiling asynchronous tasks diagdroid tracks tasks with a dynamic instrumentation mechanism on android framework methods.
it requires no changes to the target app or recompiling the underlying os and the android framework.
this can guarantee the compatibility of diagdroid with diverse android versions and smartphone models.
moreover it requires little human e orts in installing and applying the tool.
speci cally unlike general linux processes android processes of its apps are all created by duplicating a system process called zygote .
android framework functionalities have already been loaded in zygote before such duplication.
therefore we can instrument the zygote process and hijack the android framework methods of interest be414forehand.
then when an app runs by forking zygote the method invocations are inherently hijacked by diagdroid .
hence we can easily track methods.
we adopt such a mechanism implemented in the tool named xposed usually used for modifying ui .
we program our own codes to hijack the methods of our interest.
next we introduce how diagdroid tracks tasks in each category.
thread an asynchronous task that implements as a thread always starts with the start method.
hence we can instantly obtain the time when it is scheduled by tracking the start method.
however the task is executed in the overridden runmethod of a runnable object which is an abstract method that cannot be instrumented directly.
hence we resort to static analysis to nd the implementations of the abstract runmethod and instrument them instead.
the static analysis is performed via the tool apktool .
it decompiles the binary into well structured dalvik bytecode.
they can be parsed to obtain the implementations of the abstract runmethod which can direct our dynamic instrumentation approach to obtain the execution time.
note that diagdroid only decompiles and discovers these methods instead of modifying and recompiling the app.
handlerthread handlerthread is a thread that provides a looper object attached to it.
a handler is associated with the looper object and handles messages for the looper .
hence we can obtain the request time of a task by tracking the time when a message object is sent to the handler .
since eventually sendmessageattime orsendmessageatfrontofqueue must be invoked to send a message we record the invocation time of these two framework methods as the time when a task is scheduled.
handler performs the task by processing its corresponding message we track task execution by instrumenting its dispatchmessage method.
intentservice an intentservice task always starts by invoking the startservice method of the framework class contextimpl .
hence the invocation time of this method is the task scheduling time.
intentservice actually relies on the servicehandler class which inherits from hanlder to process the task.
hence we track task execution by tracking the dispatchmessage method of handler .
threadpoolexecutor threadpoolexecutor is a poolbased execution mechanism which has an elegant pattern.
a task is always requested via invoking the execute method.
moreover the task always starts immediately after the beforeexecute method and is followed by the afterexecute method.
hence we track tasks via these methods.
asynctask a task can base its implementation on the complicated java class inheritance of the basis asynctask class.
however it is always scheduled by the execute or executeonexecutor methods eventually regardless of class inheritance layers.
hence the task scheduling time is the invocation time of the two methods.
for both cases asynctask actually relies on the threadpoolexecutor .
hence we track task execution similar to that of threadpoolexecutor .
for the tasks in categories they are put in a queue before executed.
to model their task runtime dependency we use the hash code of the execution unit e.g.
threadpoolexecutor object as the queue identi er .
such a hash code is easy to obtain during runtime according to java speci cs.
two tasks with the same queue identi er may bear runtime dependency.
finally the pool capacity is obtained via checking some internal elds of the queue object e.g.
the maximumpoolsize eld of a threadpoolexecutor object .table representative performance issues found rank ranking of the buggy issue total issues reported category issue description class app rank not awaring asynctask.execute method results in undesired seqential executionlawlistfragment openlaw loading tens of icons in sequence applistarrayadapter afwall improper cancelation of asynchronous tasks getroutefaretask bart runnerandroid not canceling obsolete queries when new query arrivesasyncquerytripstask liberario failed to set optimal size of the thread pool zlandroidimageload er fbreader use the same pool for loading app list and app iconsmainactivty afwall posting various types of tasks e.g.
update progress store book to the samebackgroundhandlerreadingfragment pageturner executing filter method of autocompletetextview occupies the handler of a publicmessage queuelocationadapter liberario not canceling the tasks implemented by third party library android asynchronoushttp client loopjheadlinecomposeradapter openlaw use the deprecated findall method of webview class which causes blockingmainactivity lucid browser 5misusing third partylibrarysequential execution forgetting cancelingexecution improper threadpool overloading messagequeue .
experimental study we have implemented diagdroid and released the project online .
in our experimental study we target on opensource apps since we need the source codes to verify the e ectiveness.
to this end we download such apps from fdroid an app market that hosts only free and open source android apps .
it is also a popular app source for the research community .
we employ monkey the o cial random testing tool to exercise our target apps.
it is also known as the most e cient tool in terms of code coverage .
among the apps we download we exclude those that require a login account for convenience consideration so that we do not bother to register new accounts .
note that diagdroid can easily handle such apps by applying a login script which is trivial and will not in uence the e ectiveness.
we thus get target apps covering diverse categories including reading multimedia science education navigation security and internet .
we verify the compatibility of diagdroid on four smartphone models covering a wide range of device capacities samsung gt i9105p android .
.
huawei g610 t11 android .
.
huawei u9508 android .
.
and lenovo k50 t5 android .
.
experiments are conducted on the four devices simultaneously to save time.
we also conduct stress tests by injecting loads on cpu memory sdcard io and network respectively with customized android background services.
we implement ve background services occupying cpu ve background services occupying memory ve background services consuming internet downloading threads each two background services each reading le and writing le on sdcard in separate threads.
the parameters are chosen by common practice.
developers could con gure with their own preferences.
we design a system app to guarantee that these services would run persistantly i.e.
they will not be terminated by lowmemorykiller .
four devices with ve con gurations each four with load injections and one without load injection come up to test con gurations each con guration is under monkey testing for minutes.
we run minute test in total for the apps.
diagdroid reports overall performance issues marked as highly suspicious for apps on average issues per app.
the reports are published online.
via inspecting the related source codes in the reports .
asynchronous tasks with context c1 .
max queuing time 1650ms .
pool capacity .
cases with queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .00ms .
runtime dependency c2 context c class name de.jdsoft.law.data.lawsectionlist call stack android.os.asynctask.executeonexecutor native method android.os.asynctask.execute asynctask.java de.jdsoft.law.lawlistfragment.oncreate lawlistfragment.java ... context c2 class name de.jdsoft.law.data.
updatelawlist call stack android.os.asynctask.executeonexecutor native method android.os.asynctask.execute asynctask.java de.jdsoft.law.lawlistfragment.oncreate lawlistfragment.java ... public void oncreate bundle savedinstancestate load actual list final lawsectionlist sectiondb new lawsectionlist lawsectionlist.type all sectiondb.execute adapter and parallel update the list from network updatelawlist updater new updatelawlist updater.execute adapter ... ... ... .
asynchronous tasks with context c1 .
max queuing time 1650ms .
pool capacity .
cases with queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .00ms .
runtime dependency c2 context c class name de.jdsoft.law.data.
updatelawlist call stack android.os.asynctask.executeonexecutor native method android.os.asynctask.execute asynctask.java de.jdsoft.law.lawlistfragment.oncreate lawlistfragment.java ... context c2 class name de.jdsoft.law.data.lawsectionlist call stack android.os.asynctask.executeonexecutor native method android.os.asynctask.execute asynctask.java de.jdsoft.law.lawlistfragment.oncreate lawlistfragment.java ... public void oncreate bundle savedinstancestate load actual list final lawsectionlist sectiondb new lawsectionlist lawsectionlist.type all sectiondb.execute adapter and parallel update the list from network updatelawlist updater new updatelawlist updater.execute adapter ... ... ... report .
asynchronous tasks with context c1 .
max queuing time 1650ms .
pool capacity .
cases with queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .00ms .
cases with queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .00ms .
runtime execution dependency c2 context c class name de.jdsoft.law.data.lawsectionlist call stack android.os.asynctask.executeonexecutor native method android.os.asynctask.execute asynctask.java de.jdsoft.law.lawlistfragment.oncreate lawlistfragment.java ... context c2 class name de.jdsoft.law.data.
updatelawlist call stack android.os.asynctask.executeonexecutor native method android.os.asynctask.execute asynctask.java de.jdsoft.law.lawlistfragment.oncreate lawlistfragment.java ... public void oncreate bundle savedinstancestate load actual list final lawsectionlist sectiondb new lawsectionlist lawsectionlist.type all sectiondb.execute adapter and parallel update the list from network updatelawlist updater new updatelawlist updater.execute adapter ... ... ... codes figure report and code segments of case for several minutes per case and understanding the original project we surprisingly nd of the target apps contain performance issues.
the bug cases are ranked highly in the report with an average rank of .
.
although unfamiliar with the target app design we nd it very convenient for us to pinpoint the root causes of the issues.
we categorize detected issues into categories.
ten representative issues are shown in table with their causes defect locations and rankings in the reports.
we have reported the issues to app developers many of which have been con rmed and corrected accordingly.
we have got positive feedbacks like for faster search results i ve modi ed and i see the performance improvements.
after developers x the issues.
next we elaborate our experiences of performance diagnosis via ve representative cases.
.
case studies case unwanted sequential executions we provide our experiences on diagnosing openlaw which provides access to over laws and regulations.
diagdroid reports highly suspicious issues.
after half an hour inspecting of related source codes according to the report we summarize performance issues and localize the causes.
one case is that the queuing time of the task group with context c1is longer than the threshold ms. this case is found in test con gurations mostly under those with heavy cpu or sdcard io load which indicates the case may be related to some io intensive operations.
we demonstrate the content of diagdroid report in figure line numbers are added for discussion convenience .
we instantly nd that such a long queuing time is because the task should wait in queue till the completion of other long executing tasks based on lines .
we know on average onetask line bears runtime execution dependency with an anomalous task of which the context is c2 c2task for short line .
in other words anomalous c1tasks are due .
asynchronous tasks with context c1 .
max queuing time 31885ms .
pool capacity .
cases of queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .60ms .
runtime dependency c1 c2 .
execution time of c1 max .00ms avg.
.95ms .
execution time of c2 max .00ms avg.
.69ms protected string paramsarray params params paramsarray if !iscancelled return getfarefromnetwork params else return null report .
asynchronous tasks with context c1 .
max queuing time 31885ms .
pool capacity .
cases of queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .60ms .
runtime dependency c1 c2 protected string paramsarray params params paramsarray if !iscancelled return getfarefromnetwork params else return null codes figure report and code segments of case to the heavy weighted c2tasks.
the pool capacity is only line which indicates the tasks have to run in sequence.
waiting for the completion of another heavy weighted task should generally be avoided via proper scheduling.
thec1andc2contexts are included in the report figure .
we can conveniently nd the related source codes and how they are scheduled.
the comment parallel update indicates developers intend to execute the two tasks in parallel.
but we notice this is the same mistake in section .
the x is to call executeonexecutor with a larger pool instead.
usually developers wrongly assume the availability of the execution unit during task scheduling.
even worse such sequential tasks may be de ned and scheduled across several source les making it harder to capture their dependency manually.
in the example openlaw handles tens of ui events.
it is hence di cult to manually test and detect performance issues in all ui event procedures.
even if developers notice the laggy ui procedure e.g.
loading lawlistactivity they can hardly pinpoint the defect by inspecting nearly hundred lines of codes in several les which even involves complicated third party library invocations.
existing tools focus on the execution time of methods.
generally they lack the capability to model the queuing time of tasks and to identify the execution dependency.
therefore developers can hardly detect the subtle symptoms and reason the defect caused by task dependency.
note that the method tracing based tools will generate a trace of thousands of methods for a ui event procedure.
the performance diagnosis based on such data is like nding a needle in the hay stack given the fact that method tracing will produce about 36gb of data for our minute testing run per app.
in contrast diagdroid properly models the task execution dependency and provides tidy but helpful information to guide the diagnosis process.
we show that it can greatly reduce the human e orts by directing the developer to several lines of codes that cause the performance issue.
case not canceling obsolete tasks the cancelation of a time consuming task is necessary when the task is no longer required.
for example when a user performs activity switching by a sliding operation the previous content downloading task becomes obsolete since its associated activity is invisible.
obsolete tasks occupy resources e.g.
internet bandwidth and therefore deteriorate the ui performance.
sometimes they even block other tasks by occupying the thread pool.
however canceling obsolete tasks is not obligatory and hence often neglected by develop4161.
asynchronous tasks with context c1 .
max queuing time 514ms .
pool capacity .
cases of queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .29ms .
runtime dependency c1 private static final int image loading threads number todo how many threads?
private final executorservice mypool executors.newfixedthreadpool image loading threads number new minprioritythreadfactory void startimageloading final executorservice pool image.sourcetype zlimageproxy.sourcetype.file ?
mysinglepool mypool pool.execute ...... ... report .
asynchronous tasks with context c1 .
max queuing time 514ms .
pool capacity .
cases of queuing time 500ms .
avg.
queue length .
avg.
execution time of the in queue tasks .00ms .
cases of queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .29ms .
runtime execution dependency c1 private static final int image loading threads number todo how many threads?
private final executorservice mypool executors.newfixedthreadpool image loading threads number new minprioritythreadfactory void startimageloading final executorservice pool image.sourcetype zlimageproxy.sourcetype.file ?
mysinglepool mypool pool.execute ...... ... codes figure report and code segments of case ers.
we reveal that many popular apps contain performance issues caused by not canceling obsolete tasks.
diagdroid nds performance issues for bartrunnerandroid a public transport app.
we can conveniently locate bugs in the source codes with the report.
speci cally we detect the anomalous c1tasks under all test con gurations.
the corresponding content of the report is demonstrated in figure .
similar to case we can instantly nd the queuing e ect caused by execution dependency lines to .
we can simply apply a x similar to case here i.e.
by allowing tasks to run in separate execution units.
however we notice both c1andc2tasks can be executed for a long period lines and they often block each other.
by inspecting the codes we nd developers have already intended to cancel the obsolete tasks.
c1tasks inherit from getroutefaretask whose source codes for executing are shown in figure .
the cancelation checking is done before the task begins thus the task will not be canceled during execution when it is obsolete.
similar analysis could be applied to c2.
in other words the developers fail to conduct proper cancelation steps via cancelation checking.
the correct cancelation involves steps invoke cancel method in onstop method of the container activity and periodically check iscancelled method in method release the resource when true.
note that releasing the resource in oncancel method is also a common mistake.
case improper thread pool size improper thread pool size is a common cause of long task queuing since the pool is often busy.
we show how to diagnose such defects on fbreader a popular e book reader.
diagdroid reports only one issue for this app figure .
we detect this case under all test con gurations.
we pinpoint the issue in source codes in minutes.
both the execution and queuing time of c1tasks are anomalous.
we can quickly con rm that the image loading tasks reasonably execute for long.
however it is undesired that a c1task has to wait long for other c1tasks to complete lines .
unlike case c1tasks cannot be canceled since images are loading simultaneously.
hence a quick x is to set a larger pool size may be good according to the report .
properly setting a pool size is often hard during the coding phase.
we nd four such cases in our experiment.
developers are hard to predict the possible number of concurrent tasks in the same pool.
for example in this case study developers are not sure about the proper pool size and hence put down a to do comment in the source figure .
finally note that the existing approaches can not .
asynchronous tasks with context c1 .
max queuing time 6138ms .
pool capacity .
cases of queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .31ms .
runtime dependency c1 this method could be optimized a lot but hey processors are fast nowadays protected filterresults performfiltering resultlist autocomplete.execute .
get .getlocations ... ... ...report figure report of case .
asynchronous tasks with context c1 .
max queuing time 664ms .
pool capacity .
cases of queuing time 500ms .
avg.
queue length .
.
avg.
execution time of the in queue tasks .00ms .
runtime dependency c1 public void ontextchanged wv.findall s.tostring ... report figure report of case identify issues caused by defects in cases and since these approaches focus only on the execution time.
even if developers notice the bug symptoms existing approaches lack a way to automatically analyze the runtime dependency of tasks.
as a result it requires daunting manual e orts to nd that a task sometimes has to wait for other tasks by the inspection of tremendous runtime traces.
case overloading message queue message handler is also a queue based execution unit with only one thread.
if messages come from separate ui operations i.e.
continuous text inputs too quickly a message should wait for processing previous messages.
this type of issues can also be easily pinpointed with diagdroid .
we nd two such cases and take the transportr a public transport app case as an example.
diagdroid reports two highly suspicious issues from which we nd two code defects in less than an hour.
developers x the cases accordingly.
we can see from the report that c1tasks are with anomalous queuing time and execution time figure .
this problem is detected under all test con gurations.
a c1task has to wait long for other c1tasks to complete lines while the long execution time indicates that a c1task may long occupy the handler.
via inspecting the source codes of c1 we can easily nd the reason.
the c1task is a handler for ltering input text which invokes performfiltering directly.
the method involves a time consuming internet query on requesting a list of suggested locations with an incomplete input.
consequently the upcoming messages will have to queue in the message queue for previous inputs.
actually the old queries are no longer useful and hence should be canceled when processing new messages.
note we can know the long execution time with existing tool .
but we may falsely accept the time consuming internet query.
moreover panappticon an event tracing tool to identify critical execution paths in user transactions is unaware of the dependency between tasks invoked in different ui operations.
in this case tasks bearing execution dependency are invoked by independent text inputs in the autocompletetextview .
it is hard to know how a long execution time in uences other tasks without a tool like diagdroid to model the dependency of the concurrent tasks.
case misusing third party library misusing third party libraries is also a source of performance issues.
without knowing the implementation details developers misunderstand the usage of the third party library and introduce performance issues.
for example unaware of the asynchronous tasks in a third party library the context c context c context c .
de.jdsoft.law.data.updatelawlist de.jdsoft.law.data.updatela wlist de.jdsoft.law.data.updatelawlist .
android.os.asynctask.executeonex ecutor native method android.os.asynctask.executeon executor native method android.os.asynctask.executeon executor xposed .
android.os.asynctask.execute asyn ctask.java android.os.asynctask.execute as ynctask.java android.os.asynctask.execute as ynctask.java .
de.jdsoft.law.lawlistfragment.oncr eate lawlistfragment.java de.jdsoft.law.lawlistfragment.on create lawlistfragment.java de.jdsoft.law.lawlistfragment.on create lawlistfragment.java ... ... ... .
android.support.v4.app.fragmentact ivity.oncreateview fragmentactivit y.java android.view.layoutinflater.creat eviewfromtag layoutinflater.jav a android.view.layoutinflater.creat eviewfromtag layoutinflater.jav a ... ... ... figure similar contexts without clustering developer will neglect to cancel obsolete tasks.
diagdroid can also save the e orts in troubleshooting such defects.
we detect three such cases and show the defect in lucid browser a web browser app as an example.
we infer this issue from the suspicious issues reported by diagdroid .
we can know this is an unintended sequential execution case similar to case lines figure .
checking the source codes related to c1 we can locate the invocation of thefindall method in the third party library webview .
it nds the occurrences of a speci c text in a webpage when the text is changed.
revisiting findall we can nd that it is deprecated and should be replaced by findallasync .
note that the case is only detected on devices other than lenovo k50 t5 android .
.
findall does not introduce performance issues in android versions above .
because thechromium based webview replace the webkit based webview.
panappticon requires to recompile the kernel can work only on a small set of devices can not cope with such defects that do not persist in all android versions .
.
why clustering as mentioned in section .
to reduce the number of reporting suspicious cases we cluster the execution contexts i.e.
call stacks belonging to the same asynchronous task triggering by similar running sequences.
first we extract two features via scanning through massive contexts similar call stacks are similar in line level and similarity of callstacks is transitive.
then we perform clustering accordingly.
in this section we show that the clustering is necessary and e ective with a randomly selected example of app openlaw .
foropenlaw there are totally distinct contexts found under all test con gurations.
as a result suspicious performance cases are reported.
however we nd many of the reported cases are with similar contexts.
we select three similar contexts as examples in figure .
actually the three contexts refer to the same asynchronous task updatelawlist presented as context c1in case study .
they are the same until the 9th line of the call stacks more specifically they have slight di erence in low level vm processing sequences.
there is only one performance issue instead of three in developers viewpoint.
to lighten the workload of developers the three contexts should be grouped into one.
considering the aforementioned features we cluster contexts with a customized edit distance feature plus singlelinkage strategy feature .
after the clustering we successfully reduce the amount of total contexts from to groups .
moreover only performance cases are reported without losing meaningful cases.
this result indicates the e ectiveness of our clustering mechanism.
.
performance enhancement diagdroid is able to present to developers with the performance enhancement after xing performance issues.
difigure message handler blocking delays before left and after right x of transportr figure queuing delay of showing apps before left and after right x of afwall agdroid o ers the distribution of the queuing execution delays of asynchronous executions .
besides con rming the disappearing of the related case in the report of the xed version developers can ensure the performance gain via doublechecking the delay distributions of related asynchronous executions before and after xing the issue.
next we illustrate how to visualize the performance enhancement via demonstrating two o cial xes by developers.
notice the example distributions are simpli ed yet good enough to demonstrate the enhancement.
developers could tune the parameter to obtain ner distributions.
developers of transportr x an issue of message queue overloading with our report.
they modify les with additions and deletions.
since the message processing is network related we show the performance enhancement on the huawei g610 t11 with network load injected.
the result is depicted in figure .
similar patterns can be found in other test con gurations.
it could be seen that there is no more blocking problem for the new app version.
with our report developers of afwall x the sequential loading issue on displaying the app list.
they modify the source from new getapplist .setcontext this .execute to new getapplist .setcontext this .executeonexecutor asynctask.thread pool executor .
we notice that the queuing e ect is more obvious with cpu load injected on a poorer device.
we illustrate in figure the distribution of queuing delay of the asynctask with testing con guration of samsung gt i9105p with cpu load injected.
similar patterns can be found in other test congurations.
it could be seen that there is no more queuing problem in the new app version.
.
discussions next we discuss the threats to the validity of our experiments and the measures we take to address them.
first is the overhead of diagdroid i.e.
how it a ects the test e ciency.
we employ the time command to obtain the cpu time for conducting monkey operations msinterval between two consecutive operations with diagdroid on and o .
the overhead shows that diagdroid does not have a considerable impact on testing e ciency.
instead of relying solely on monkey test executor is a plugin in diagdroid .
incorporating script based testing tools likeuiautomator and monkey runner is allowed.
we test minutes for each of con gurations per app to show the capability of diagdroid in such a short term test.
the settings can be changed to explore the speci c app more thoroughly.
note that diagdroid also carefully addresses 418its compatibility issues.
parallel testing in multiple device models is feasible as already shown.
finally diagdroid resorts to dynamic analysis as we focus on the performance issues caused by complicated runtime dependency of asynchronous executions.
it is hard for the static analysis approaches to deal with such issues.
for example determining the proper pool size based only on the source codes is hard since it is impossible to predict the possible number of concurrent tasks.
moreover it is hard to know when to cancel a task beforehand.
the aim of diagdroid is to save inevitable human e orts rather than approaching the task of automatic code correction.
as shown in our case studies such e orts are light.
diagdroid is able to provide a small set of possible issues.
the issues that really contain bugs are with high rankings.
as shown in table the buggy cases rank .
averagely.
this indicates we can easily be directed to where the code defect lies.
the debugging time of each case is generally less than an hour even for us who are unfamiliar with the app implementations.
.
related work performance diagnosis has long been studied in many systems.
much work is conducted on predicting performance of con gurable systems .
caramel detects unnecessary loop executions with static analysis.
yu et al.
propose a performance analysis approach based on real world traces.
but such traces are lacking in our problem.
ppd resorts to dynamic instrumentation for goaloriented known performance issues search.
lag hunting aims at nding performance bugs in java gui applications in the wild without addressing concurrency issues.
existing work also considers thread waiting time i.e.
the time when a thread waiting for other threads during its execution as a metric to nd performance bottlenecks.
in contrast we focus on queuing time i.e.
the time when a task waiting before its execution to model task dependency.
performance issues of javascript programs are also studied .
sahand visualizes a behavioral model of full stack javascript apps execution.
but it does not take the contentions of asynchronous tasks into consideration.
performance is critical to mobile apps .
blocking operations in the main thread are widely known as a cause of many performance issues .
strictmode aims at nding such operations.
asynchronizer and asyncdroid provide a way to refactor speci c blocking operations into standard asynctask andintentservice further to eliminate the memory leakage problems.
clapp nds potential performance optimizations via loop analysis.
however such static analysis based tools cannot capture runtime execution dependency.
banerjee et al.
design static analysis driven testing for performance issues caused by anomalous cache behaviors.
tango outatime and cedos optimize wifi o oading mechanism to keep low latency of app.
smartio reduces the app delay via reordering io operations.
these approaches solve speci c performance issues.
diagdroid in contrast aims at solving general ui performance issues caused by runtime task dependency.
ui performance diagnosis captures much research attention.
method tracing is an o cial tool used to diagnose known performance issues due to its high overhead.
qoe doctor bases its diagnosis on android activity testing api which can only handle pre de ned operations.
appinsight is a tracing based diagnosis tool for windowsphone apps.
it traces all asynchronous executions from a ui event to its corresponding ui update and identi es the critical paths that in uence the performance.
panappticon adopts a similar approach on android.
but these approaches generally neglect the runtime dependency between tasks especially tasks executed for di erent ui operations.
moreover it su ers from low compatibility since they largely require to recompile the android framework and os kernel.
performance diagnosis often requires to exercise the target app automatically.
script based testing is widely used e.g.
uiautomator monkey runner and robotium .
mobiplay reran and spag c are record andreplay approaches which record the event sequence during the manual exercising and generate replayable scripts.
complementary to these semi automatic testing fuzz testing approaches for example monkey dynodroid and vanarsena generate random input sequences to exercise android apps.
symbolic execution base testings e.g.
mirzaei et al.
acteve jensen et al.
evodroid and a3e aim at exploring the app functions systematically.
model based testings e.g.
android ripper and swifthand aim at generating a nite state machine model and event sequences to traverse the model.
test case selection techniques e.g.
can also be adopted to exercise the apps.
app exercising mechanisms work as plugin modules of diagdroid enabling the developers to exploit their merits under di erent circumstances.
.
conclusion in this paper we design diagdroid for diagnosing android performance issues.
to make diagdroid a practical handy tool we carefully consider the system design requirements like compatibility usability exibility and low overhead.
speci cally diagdroid relies solely on the general features of android.
hence it works for most mainstream android devices depending on no manufacturer speci cs.
moreover diagdroid is convenient to use via a simple installation.
it requires no e orts to recompile the os kernel and the android framework.
with a plugin mechanism diagdroid provides the exibility in selecting the test executor to exercise a target app.
finally diagdroid keeps low overhead by instrumenting slightly on the framework.
to conclude this paper focuses on an important type of android performance issues caused by task execution dependency.
we carefully model the performance of the asynchronous tasks and their dependency.
diagdroid is implemented accordingly for task level performance diagnosis.
it is equipped with a set of sophisticated task pro ling approaches based on the android multithreading mechanisms.
we show diagdroid can e ectively reduce human e orts in detecting and locating performance issues by applying the tool successfully in nding bugs in tens of real world apps.
.