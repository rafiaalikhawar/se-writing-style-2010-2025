an empirical study ofreal worldvariability bugs detected byvariability oblivioustools austinmordahl universityof texasat dallas usa austin.mordahl utdallas.edujeho oh universityof texasat austin usa jeho.oh utexas.eduugur koc universityof maryland collegepark usa ukoc cs.umd.edu shiyiwei universityof texasat dallas usa swei utdallas.edupaul gazzillo universityof centralflorida usa paul.gazzillo ucf.edu abstract many critical software systems developed in c utilize compiletime configurability.
the many possible configurations of this software make bug detection through static analysis difficult.
while variability aware static analyses have been developed there remainsagapbetweenthoseandstate of the artstaticbugdetection tools.
in order to collect data on how such tools may perform and todevelopreal worldbenchmarks wepresentawaytoleverage configuration sampling off the shelf variability oblivious bug detectors andautomaticfeatureidentificationtechniquesto simulatea variability aware analysis.
we instantiate our approach using four popular static analysis tools on three highly configurable real world c projects obtaining warnings of whicharevariabilitywarnings.weanalyzethewarningswecollect from these experiments finding that most results are variability warnings of a variety of kinds such as null dereference.
we then manually investigate these warnings to produce a benchmark of confirmed true bugs of which are variability bugs useful for future developmentofvariability aware analyses.
ccs concepts generalandreference empiricalstudies softwareand its engineering automated static analysis software testinganddebugging .
keywords staticanalysis configurable c software variability bugs acmreference format austin mordahl jeho oh ugur koc shiyi wei and paul gazzillo.
.
an empirical study of real world variability bugs detected by variabilityoblivious tools.
in proceedings of the 27th acm joint european software permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 26 30 tallinn estonia associationfor computing machinery.
acm isbn ... .
esec fse august 26 30 tallinn estonia.
acm new york ny usa 12pages.
introduction systems developed in c form some of the largest and most importantsoftwareinfrastructure.thissoftware suchasthelinux kernelorthebusybox embeddedtoolkit isusedinabroadrange ofapplications fromlarge scaledatacenterstomillionsofinternetof thingsdevices.cprogrammersuse compile timevariability to enableasingle codebasetobecustomizedtothisdiverserangeof settings.
theyimplement software configurations inthe makefile and c preprocessor to decide which part of the source code is built by the compiler allowing for billions or trillions of variations of the compiledprogram.
variabilitybugs arebugsthatonlyexistundercertainconfigurationsofthesoftware.thesearemadepossiblebythebuildand configurationsystem whichmodifythesourcecodetofitachosen configuration.1suchconfigurablecode isnecessaryforcodebases to support a wide variety of hardware and application settings but studies show it also creates problems for debugging and maintenanceofhighly configurable codebases .
variability bugs create a serious challenge for automatic bug detection.moststaticanalysistoolsoperateononeconfigurationat a time i.e.
are variability oblivious orusead hoc heuristics makingthemblindtocodeinotherconfigurations.checkingconfigurations one at a time is intractable when even small configurable systemshave trillions ofconfigurations .
to address this problem researchers have developed variabilityawareanalyses thatprocessallconfigurationssimultaneously.tothebestofourknowledge thestate of the artvariabilityaware bug detector applies control and data flow analyses to discover bugs such as double free and freeing of static memory .
while these advances in bug detection are highly promising they are still in the early stages when compared to widely used variability obliviousbugdetectorssuchasinfer whichuses separationlogictofindmemorysafetybugs andcbmc which usesabstractinterpretationandmodelchecking.theseanalyses whichcandetectbugssuchasbufferoverflow array out of bounds andsecurity vulnerabilities are inwide use.
1inthisworkwefocusonvariabilitybugsduetocompile timevariability butsuch bugs canalso bedue to run time variability.
esec fse august tallinn estonia austinmordahl jehooh ugur koc shiyiwei andpaulgazzillo the continued development of variability aware analyses is important.
but given the gap between such tools and state of the art bugdetectors thereisstillalackofdataabouttheutilityofsuch analyseswhencomparedtotheirvariability obliviouscounterparts.
moreover thereisalackofbenchmarkstoprovidegroundtruthsfor developingvariability awareanalysis.tothebestofourknowledge thelargestvariability bugdatabase containsbugs encountered byusersoverthepastdecade makingitdifficulttoreproducethese bugsinthe originalsoftware.
how can we find variability bugs that existing variability aware analysismaynotdetect?ideally wewouldliketotakeoff the shelf bugdetectorsandconvertthemtobevariability awaretogather data and develop benchmarks.
but this herculean task requires largetimeresourcesandwoulditselfbenefitfromhavinggroundtruthbenchmarks duringdevelopment.in ordertocollectdataon howsuchtoolsmayperformandtodevelopreal worldbenchmarks wepropose simulating variability awarenesswithoff the shelfbug detectors.
simulatingvariability awarenessisbasedonasimpletechnique runbugdetectorsonasampleofconfigurations.samplingofconfiguration spaces has been studied extensively and some previous work hasappliedabugdetector to samplesofconfigurations in the context of comparing sampling algorithms.
but tobeasimulation wearguethat i thesampleofconfigurations should be representative of complete variability awareness and ii itshouldintegratetheresultsofthemanyvariability obliviousruns intovariability awareresults.toachievearepresentativesample we use a recent advance in configuration sampling that guarantees uniformityyetscalestocolossalconfigurationspaces .previous sampling algorithms could doone orthe other but not both.
to achieve integration we have developed a new simulation frameworkthatwrapsexistingbugdetectors.itautomaticallyappliesabugdetectortoallsampledconfigurations aggregatesand deduplicates the resulting warnings and finds feature interactions therebysimulatingtheoutputofavariability awareanalysis.using thisframework weanalyzethewarningsfromfouroff the shelf bugdetectiontools infer cbmc clang andcppcheck onthree highly configurablecodebases theaxtlswebserver thetoybox andbusybox embeddedtoolkits .
thesecodebases have hundreds of configuration options leading to trillions of valid configurations.
representingweeksofcomputing time wecollected36 061warnings ofwhich28 almost80 are variability warnings.
we performed data analysis of the resulting warnings that confirmsmostwarningsareduetovariability thatshowsvariability warnings are of many types even those not currently supported by existing variability aware analysis tools and that proves warnings may appear in few configurations indicating the need for variability awareness.perhapssurprisingly wealsoshowthatall warningsproducedbyany tool programcombinationcan be covered by a small numberof configurations.
our data demonstrate a trade offbetweentheaddedcomplexityofvariability awareness and the need to cover all possible defects e.g.
for safety critical software.
finally weconstructareproducibledatasetincludingvariability bugs in recent real world software useful as a benchmark for future analysis development.
we manually investigated many of our variability warnings to confirm whether they are true bugs.
ifdefconfig bigint sliding window 2for j i j j work out an optimum size window size work out the slide constants 5precompute slide window ctx window size bi else just one constant 7ctx g bigint malloc sizeof bigint 8ctx g bi clone ctx bi warning 9ctx window 10bi permanent ctx g endif figure an example of a confirmed bug found during our experiments.
fromaxtls crypto bigint.c.
this investigation yielded a set of true positive bugs showing that our simulation framework can be used to find new variability bugs.wehavemadeourframeworkanddatasetpubliclyavailable.
the contributionsofthis paper are the following a framework that simulates variability aware analysis by integrating off the shelf static analysis tools and running themonuniformrandomsamplesoftheconfigurationspace section3 .
anempiricalevaluationofthewarningsproducedbyfour static bug detectors on three highly configurable c codebasesandananalysisofwarningsthatshowspotentialdefectsare indeedobscuredbyvariability section .
areal worldvariabilitybug benchmark foundby manually investigatingthewarningsfromourevaluationaswellasthe feature interactions that lead to these bugs.
this benchmark isbeneficialfortooldeveloperstoevaluatefutureanalyses section5 .
whatare variabilitybugs?
figure1is an example of a variability bug in this case a null dereference found during our experiments running the infer static analysis tool on axtls.
line sets ctx gto the return value of malloc which can be null and line dereferences that value ctx g withoutcheckingfornull awell knowndefect.3this isavariabilitybug becauseitonlyappearsincertainconfigurations ofthe codebase.
even though static analyses suchas inferare sound 4theyonly operate on a single configuration at a time i.e.
the soundness guarantees only apply to the chosen configuration.
to see why thisisthecase noticethatthisvulnerablesourcecodeisguarded byapreprocessorconditional indicatedbythe ifdef else and endifonlines1 and11 respectively.preprocessorconditionals arenotpartoftheclanguage butareevaluatedbeforethecsource code iscompiledto implement variations of the sourcecode.
config bigint sliding window is apreprocessor macro that the preprocessor conditional tests to decide whether to include either lines 2 5 or lines 7 10 but never both.
the macro is set via theconfigurationsystembytheuser.thisusageofthepreprocessor illustrates howcompile time variability istypicallyimplemented.
in our example in figure the null dereference bug on line only appears when the config bigint sliding window configuration option is disabled because that line is never compiled 3cwe .
4theyaresoundwithrespecttoasubsetofthelanguagesemantics i.e.
soundiness .
51anempirical studyof real worldvariabilitybugs ... esec fse august tallinn estonia figure anoverview ofour approach.
into the final binary.
therefore if a static analysis tool even a sound one is only run on a configuration that enables the option it will not find the bug.
interestingly there is a different null dereference bug when the option is enabled.
inside of the precompute slide window functioncalledonline5isacodeclone of lines 7 10. these two bugs live in mutually exclusive configurations so finding and fixing one does nothing to help with the other.
if there were a small number of configurations trying every combination of configuration options might be feasible but axtls has94configurationoptionsandaroundtwotrillionvalidcombinationsofthem.checkingallconfigurationsisnotfeasible andwe donot knowaprioriwhichconfigurationsmaybe vulnerable.
in c configurations are typically implemented using the preprocessor asshownintheexampleabove andwithmakefilesor a related build specification language e.g.
kbuild .
the configuration system takes configuration option settings from the user andpassesthemtothebuildsystemandthepreprocessor which then select a subset of the source code to compile and link into the final binary.
prior work shows how extensively configurable code is implemented with the preprocessor and makefiles 4 .compile timevariabilityresultsincodebasesthatareboth highly configurableandefficient resultinginasmaller fasterbinary particularlyimportantfor low level systemssoftware.
asweseeinfigure however thisconfigurabilityalsoobscures software defects.
previous studies show that such configurable codeisdangerous ithasbeencorrelatedwithmorebugs and shown to be more difficult for developers to debug .
we use our simulation framework to find variability bugs.
frameworkand studysetup figure2shows an overview of our simulation framework.
it takes in a codebase and produces a set of warnings for later manual investigation.
the framework itself consists offour main steps i thesamplegeneration usinganexistingtooltogetuniformrandom samples for the given codebase ii automatically applying a chosen static analysis tool on all sampled configurations iii aggregating and deduplicating the results finding which warnings appear in multiple configurations and iv identifying features usingthelistofconfigurationseachwarningoccurredintoinfer whichconfigurationoptions i.e.
features produce the warning.
we apply this framework to multiple static analysis tools and highly configurable codebases.
after running our framework ontable details ofthe targetprograms.
program version c sloc options valid configs axtls .
.
.
toybox .
.
.
busybox .
.
.
eachcombinationoftoolandcodebase wehaveacollectionofwarningsforeachcombinationthatsimulatesvariability awareanalysis results.
the remainder of figure 2shows our process for manually investigating these variability warnings to collect a dataset of true bugs useful as abenchmark.
we nowdescribe eachstep of our approach indetail.
.
samplegeneration generating a configuration sample is not as simple as randomly combining configuration options as constraints exist between different options e.g.
some options are mutually exclusive.
a configuration is invalid if the constraints defined by the configuration systemarenot satisfied.
off the shelfbugdetectorsoftenrequire compilation of the program to resolve preprocessor directives and generate intermediate representations for the analysis.
we thus require every configurationinthe sample be valid.
the state of the art toolfor generating representative samples from highly configurable software is smarch .
smarch is a uniform sampling algorithm for software product lines based on a satsolver .smarch scalesto largeconfigurable softwareby obviating the need to exhaustively enumerate configurations from the constraints.
instead smarch generates a uniqueconfiguration from a randomly chosen number on demand.
sampling of valid configurationsrequiresfirstknowingthesetofconstraintsbetween configurationoptions i.e.
thefeaturemodel.thestate of the art tool kclause from thekmax project isusedfor automaticallyextractingtheseconstraintsfromthekconfigspecification languageusedinourtargetprojects.itworksbyinterpretingkconfig language constructs as formal logical models and optimizing themto reduce the size of the reusltingmodel.
while our framework is modular and accepts samples from any sampling algorithm that generates valid configurations a uniform randomsamplingalgorithmallowsustodrawstatisticallysound conclusionsaboutthepopulationofconfigurationsbasedonsample results within a small margin of error and confidence level.
for example with a configuration sample having a margin of error and1 confidencelevel ifweobservethat80 ofallbugsdetected inasamplearevariabilitybugs wecansayweare95 surethat between79 and81 ofallbugsthatexistinthetargetsoftwareare variabilitybugs allowingustoforeseetheresultsofavariabilityaware analysis.
weusedtheprogramslistedintable 1forourempiricalstudy becausetheyall i areopensource ii arehighlyconfigurable and iii usekbuild whichallowstoautomaticallyextractconfiguration constraintswithkclause.foreachtargetprogram wegenerated valid configurations.
this sample size ensures the results are within a5 margin oferrorand1 confidence interval.
.
usingoff the shelf bug detectors we chose four off the shelf bug detectors from a list for our investigation cbmc .
facebook infer .
.
cppcheck 52esec fse august tallinn estonia austinmordahl jehooh ugur koc shiyiwei andpaulgazzillo table descriptions ofthewarningtypes.
warning type description array bounds array accessed beyond allocated length.
assertion failedassertions eitherprovided bythe userorgenerated automaticallyby the model checker.
overflow overflowofintegers.
nan floating point arithmetic producing nan i.e.
infinitiesorthe resultsofcomputationswithinfinities .
pointer mismatched types between pointer usage and definition.
null deref dereferencinganull pointer.
dead store values thatarestored in variables butneverused.
memory leak memory that is dynamically allocated but never freed.
resource leak resources e.g.
file descriptors sockets that are opened butneverclosed.
uninitialized val values thatareused withoutbeing initialized.
api improperuse ofvariousapis.
unix api improperusage ofaunixapi.
logic error a wide variety of warnings such as unallowed function callsafter vforksandundefined behaviors.
memory error memory andresource leaks.
security useofinsecurefunctioncalls e.g.
vfork .
undef behavior undefinedbehavior ofconstructionsorexpressions.
.
andthebuilt inanalyzerinclang7.
.ourcriteriafor choosingbugdetectorswerethat i theyworkedonccode and ii they produced bug warnings asopposed to other codemetrics such as linecounts.
the detectors we chose reported a variety of warnings defined intable2.cbmcreportsarray bounds assertion nan overflow pointer andnull deref.inferreportsdead store memory leak null deref resource leak anduninitialized val.clangreports api unix apis dead store logic error memory error and security.
cppcheck does not report discrete warning types so we manually mapped cppcheck warnings to types that were found in othertools array bounds memory error null deref overflow anduninitialized val.additionally wedefinedtheundef behavior warning type for cppcheck.
these detectors represent two different ways of running an off the shelf bug detector.
cbmc and infer attach themselves to the build process in all of our target programs this was make collectinginformationaboutthebuildprocessandgeneratingintermediate representations of the program.
for these we use a script thatiterativelyrunstheappropriatetoolasanattachmenttothe build process.
cppcheck and clang both run on individual files so for those we instead use custom scripts that first preprocess the code.we then run the toolsiterativelyoneachpreprocessedfile.
inourstudy werantheseexperimentsontwodifferentmachines.
preprocessingofbusyboxtookplaceonadesktoppcwithanintel corei5 3570kcpu .40ghzand16gbramrunningdebian9.
all other experiments took place on a server with intel xeon silver4116cpus .10ghzand128gbramrunningubuntu16.
lts.
we used a virtual machine to ensure the consistencies in environment across the machines.
in total experiments took on theorderofweeksofprocessortimetorun however wewereable to reduce this inreal time throughparallelization.
.
deduplicationandformatting althoughconfigurationoptionsgoverntheinclusionorexclusion ofdifferentpartsofsourcecode someofaprogram scodebaseis commonacrossallconfigurations.therefore manyofthewarnings obtained by running a bug detector on each configuration in the sampleareduplicates.weperformpost processingtodeduplicate thesewarnings andthen outputtheminaunifiedformat.
weconsidertwowarningsequivalentiftheyrefertothesame lineinthesamesourcecodefile.5wewritetheuniquewarnings setforeachtool programcombinationinjsonformatforeasier processing.figure 3showsthejsonoutputofthevariabilitybug wediscussedinsection .the variability fieldisourautomated estimation of whether this warning is a variability warning or not.
inourstudy awarningisestimatedtobe generic i.e.
thevariability field is false if it was detected by the tool in all the configurations in our sample.6otherwise we regard a warning as variability i.e.
thevariabilityfieldistrue .the automatic features fieldrefers to the configurationoptionsidentifiedinthe following step.
variability true description pointer ctx g last assigned on line could be null and is dereferenced at line column .
num configs tool infer filename crypto bigint.c line type null dereference configs target axtls 2 1 4 automatic features figure the json format of the warning in figure .
the list ofconfigurationsis truncated forspace.
.
automaticfeatureidentification we perform automatic feature identification by referencing the list ofconfigurationseachwarningispresentin.foranywarning w letcwbe the set of configurations in which wwas emitted and letc wbe the set of configurations in which wwas not emitted.
we automatically determine the set of configuration options f that are common to cw and the set of configuration options f thatarecommonto c w.ifforanyconfigurationoption f where fdenotes the option being turned on and f denotes the option being turned off if f fandf nelementf then we select fas the configurationoptionassociatedwiththiswarning similarly if f fandf f then we consider f to be associated with w .
we do notconsideraconfigurationoptiontobeassociatedwithawarning iffiscommonacrossboth cwandc w.thismethodologycanbe extendedtodeterminewhenconjunctionsordisjunctionsofoptions are associated with a warning.
as an automated algorithm this processsucceededinestimatingassociatedconfigurationoptions inmostcases.
5recall that cppcheck and clang run on preprocessed files.
the preprocessed files containlinemarkersthatallowustomappreprocessedcodetoitsoriginalsourcecode line.
6a warning we estimateas generic may be a variability warning if thereexists some valid configuration notin the sample on which a tool cannot reportthe warning.
we believethisestimationisaccurate based onourinvestigation of bugs in section .
53anempirical studyof real worldvariabilitybugs ... esec fse august tallinn estonia .
manual classification we performmanual classificationof warningsby codeinspection andteamreviews.ourcriterionfordeterminingwhetherawarning is a true or false positive is whether the description emitted by the bugdetectoriscorrect.foreachwarning wehand tracedexecution aroundthereport recordingthevaluesofvariablesandpointers.
the manual classification was performed by the first author of the paper andthenpresentedtoallmembersinthisproject.weasa teamexaminedthewarningsclassifiedastruepositivesandconfirmedthem.
ourprimarygoalwassoundness in our bug dataset i.e.
avoidreportingawarningasatruepositivewhenitwasafalse positive.
it is possible however that there were still true positives mistakenly labeled as false positives since we did not construct exploits.
.
manual featureconfirmation we manuallyverifytheresultsoftheautomaticfeatureidentificationthroughcode inspection.
we perform the following tasks findcpreprocessordirectivesthatsurroundthesourcecode withthebug andextracttheconfigurationoptionsconstrainingthe directives.
find makefile commands that compile the c file containing thebug andextracttheconfigurationoptionsthatactivate the commands.
toensure correctness checkwhethertheconfigurationoptions found from the above two steps appeared in the automaticfeature identification result.
.
discussion newanalyses andprograms eachstepinthesimulationframeworkisautomated andisdesigned topermit pluggingin newstaticanalysistoolsandnewcodebases to investigate.
to add a new codebase we need two things a featuremodeldescribingtheconfigurationconstraintsforsampling and asmallsetofshellinstructionstoconfigureandbuildthetool for a given configuration.
technically our framework can support anysamplingalgorithm becausetheexecutionenginetakesonlya set of configurations to evaluate.
currently our evaluation is on codebases that use kbuild the linux build system because the sampling toolwe use isknown to samplethese uniformly but we havetesteditonothercodebasesforwhichwedonothaveuniform sampling.
addingnewstaticanalysistoolsisassimpleascreatinganew script that executes the tool.
the challenge of supporting a new static analysis tool however is due to their idiosyncrasies.
for instance theclangstaticanalyzerprovidesaconvenienttoolcalled scan buildthatuses poorman sinterposition toanalyzeanentire project .
this tool does not always work as the manual warns requiring us to customize the analysis process for codebases we evaluatebutarenotsupportedbyscan build.foreachcombination of tool and codebase we have created plugins that overcome most of thelimitations of thestatic tools for the complex build systems ofour codebases.
empiricalevaluation ofwarnings weappliedourframeworktothethreehighlyconfigurablecodebasesshownintable andthefouroff the shelftoolsdescribed insection .
.thegoalofthisempiricalevaluationistoevaluatewhatkinds of variability warnings off the shelf bug finders detect and to what extentsuchwarningsareaffectedbyconfigurability.tothisend we ask three researchquestions rq1whatvariabilitywarningscanoff the shelfbugdetectors find?
rq2howare variabilitywarnings distributedoverthespace ofsampledconfigurations?
rq3howdoourresultscomparetocheckingamaximumor minimumconfiguration?
rq1.weexpecttodiscoverhowoftenandwhattypesofvariabilitywarningsarefound.iftherearemany thisconfirmsprior work thatshows variability bugsare a serious problem forhighlyconfigurable software .
moreover if the types of variability warnings include serious potential defects that current analyses do not support e.g.
null deref then we provide further justification for the research community to continue developing such analyses.
ontheotherhand ifvariabilitywarningsarerare variability aware analysesmaynot be needed.
rq2.examiningthedistributionofvarioustypesofwarnings across the set of samples will show us how difficult it is to identify suchwarningswithoutvariability awareanalyses.ifonlycertain typesofwarningsarevariabilitywarnings perhapstheresearch community shouldinitially focusonanalysesfor specific kindsof bugs.
if more serious warnings tend not to be variability warnings then this would provide evidence that such analyses may not be necessary.
moreover we examine how many configurations are requiredtocoverthesetofwarnings.ifmanyconfigurationsarerequired this provides further justification for variability awareness while few configurations may mean that further effort on algorithmsfor configurationcoverageisneeded.
rq3.wecomparetheresultsofrunningthebugdetectorson the maximum configuration defined by each of our codebases.
if we find thatthemaximum configurationsfindvery fewwarnings this provides further justification for variability aware analyses.
otherwise suchanalysesmaynotbemuchmoresuccessfulthan selecting one good configuration.
note that our results are only fromasampleofconfigurations sowecannotruleoutallvariability warnings in all configurations.
additionally we compare against the minimum and the default configuration if provided by the codebase asabaselinefor thenumberof warningsinour dataset.
.
rq1 whatvariabilitywarnings can off the shelf bug detectorsfind?
we use a large representative configuration sample with our approach allowing us to examine how often the same warning appearsacrossdifferentconfigurations.byusingthededuplication approach described in section .
we can examine the subset of configurations in which a warning occurs to discover how it is distributedacrosstheconfigurationspace.whenawarningappears in all sampled configurations we can assume it is unlikely to be a variability warning.
ruling out such warnings our results still showalargenumberofvariabilitywarnings i.e.
thosethatonly appear inasubsetofthe sampledconfigurations.
table3shows thenumber ofwarnings produced byeachstatic analysistoolforeachtargetcodebase.eachrowshowsthenumber 54esec fse august tallinn estonia austinmordahl jehooh ugur koc shiyiwei andpaulgazzillo a cbmc b clang c infer d cppcheck figure numberofvariabilityandgeneric warnings overallprograms categorized by warningtype.
table summary of warnings found for each combination of target codebase and static analysis tool.
no warnings were foundforcppcheck.
inferdidnotrun on busybox.
cbmc clang infer cppcheck axtls total warnings variability count variability percent toybox total variability count variability percent busybox total variability count variability percent of total warnings and the numberand percentage of the total that are variability warnings.
each column shows these numbers for each of the four static analysis tools tested.
note that infer did not run on busybox because it threw an assertion failure from its clang backend.
overall the data show that variability warnings are not uncommon.
in most combinations of target system and analysis tool the majorityofwarningsfoundarevariabilitywarnings.whenlooking at toybox and busybox the proportion of variability warnings is high and fairly consistent across all four static analysis tools ranging from to .
axtls had a lower number of variability warnings.
indeed cppcheck reported no warnings at all in our axtls sample.
in spite of this the clang static analyzer appears to find a higher percentage of variability warnings.
because the numberofwarningsissosmallinthiscase itisdifficulttocome to any conclusions for axtls.
while not necessarily conclusive for all configurable systems thisprovidesevidencethatmoreconfigurabilitycouldbecorrelated tomorepotentialdefectsmadehardertofindduetoconfigurability.we observed that most c files in toybox and busybox require turningonatleastoneconfigurationoptiontobeincludedinthe compilation.
therefore warnings from these files will be classified asbeingduetovariabilityaslongasthereexistsomeconfigurations inour sample that do not compilethem.
we conclude from the data that variability warnings are very frequent andthat existingstaticanalyseswouldrevealmorepotential defectsifmadevariability aware.
tofurtherunderstandtheaboveresults wecategorizethewarnings by their types.
figure 4shows the distribution of variability andgenericwarningsundereachtype.eachbarinfigures 4ato4d aggregates the warnings from all three programs of a certain type.
overall variabilitywarningsspanalltypesof warnings except forthesingleunix apigenericwarningreportedbyclang.certain types dominate the total number of warnings for each tool.
of the cbmc warnings are null deref or overflow of the clang warnings are logic error or dead store uninitialized val countsfor86 ofcppcheckwarnings oftheinferwarnings are uninitialized val null deref or dead store.
nevertheless the percentage of variability over all warnings of each warning type islargelyconsistentwiththeoveralltoolperformance.forexample of clang warnings are due to variability.
when categorizedbytypes thepercentageofvariabilitywarnings exceptthe unix api warning ranges from for memory error to for logic error .
the only type that has more generic warnings than variability warnings is null deref by infer i.e.
generic warnings vs. variability warnings.
in summary these data show that variability warnings represent alltypesofwarningsfoundbythesestaticanalysistools including thepotentially dangerous null deref and overflow .
.
rq2 howarevariabilitywarnings distributed overthespaceofsample configurations?
rq1 provides evidence that variability warnings are very frequent and we would like to evaluate how these warnings are distributed 55anempirical studyof real worldvariabilitybugs ... esec fse august tallinn estonia a cbmc b clang c infer d cppcheck figure numberofconfigurationsreporting variabilitywarnings overallprograms categorized by warningtype.
figure6 thesubsetofconfigurationsthatfindallwarnings.
acrossthesampleset.foreachwarning wecountthenumberof sampled configurations in which it appears.
this quantity gives us anideaabouthow rare awarningis i.e.
howlikelywearetofind this warning when checking a single configuration.
examining the distribution of configuration counts across all warnings gives us insightabouthowvariabilitywarningsaredistributed.forthese experiments we only consider variability warnings since generic warnings are assumed to appear in all configurations and rq1 already showshowcommon such warnings are.
figure5showsbox and whiskerplotsofthedistributionofvariability warnings across the sampled configurations.
each chart representsthedistributionsforonestaticanalysistoolbytypeof warning.eachbox and whiskerisanaggregateofthevariability warningsfromallthreeprograms exceptforcbmcinfigure 5a which summarizes axtls and toybox results due to the failure to analyze every sample configuration of busybox.
in figure the median number of configurations of most warning types is between400and600.thethreeoutliersarenanfromcbmc memory error from clang and api from clang .
in order to determine whether there were actual statically significant differences between the different warning types or if the differenttypeswere independent weperformedanova testsoneach tool soutput.inallcasesexceptcppcheck anovarejectsthenull hypothesisofindependence at .
.
we additionally observe wide distributions of the number of configurations in most warning types.
this means that some warnings were detected in either a small or a large subset of sampled configurations.forexample inferdiscovered9toyboxwarnings in configurations.
we found that these variability warnings exist in the same toybox file i.e.
ps.c .
this file is included in compilationifanyoneoffiveconfigurationoptionsisturnedon specifically these options are ps pkill pgrep iotop andtop.
thisdisjunctiveconstraintissatisfiedinmostconfigurationsinour sample resultinginthe detection of thesevariability warnings.
on the other hand the toybox warning that was detected by cppcheck with least number of configurations i.e.
appears in the file axhttpd.c .
upon checking the feature interaction associatedwiththiswarning wefoundthatitisaconjunctionof5 configuration options which explainswhyitcan only be detected ina fewconfigurations.inanotherexample onetoybox warning wasonlydiscoveredbycppcheckin4configurations.thiswarning is emitted by the tool only if the configuration option lsm none is turned on.
in our sample only configurations turned on this option because toybox s build system only allows this option to beturnedonwhenmanyotheroptionsareturnedoff.theabove observations illustrate that the detection of variability warnings from a sample is affected by the build system implementation of thetargetprogram aswellasthegenerationofsamples.overall figure5hasshownthat whilethemajorityofvariabilitywarnings are detected in many configurations in our sample some can only be detected in afew due to the configurability ofthe target software .
figure6showsthesubsetofconfigurationsinoursamplethat may produce the same results for each tool and program combination.
the number above each column shows the size of the subset 56esec fse august tallinn estonia austinmordahl jehooh ugur koc shiyiwei andpaulgazzillo and the different colors patterns in each column indicate different configurations.
we computed this subset by greedily searching for the configuration that adds the most warnings.
algorithm describes this processindetail.
data cis the set of configurations wis the set of warnings sis a subset ofc result s c c w w s letw cdenotethesetofwarnings w w thatareinconfiguration c whilew is notempty do findc c thatproduces the most w w s s c w w w c c c c end algorithm1 findasubsetofconfigurationswithallwarnings.
infigure atmost29configurations forcbmc busybox were neededtocoverallwarningsthatwerefoundbyoursamples.itonly required 4configurationstodetect all toybox warningsby clang.
on average the subsets cover and of values of a single option and of the2 way combinations of options in theconfigurationsample respectively.thisresultsuggeststhat runningstatic bugdetectorsona small well constructedset ofconfigurationsmay revealmanyvariabilitywarnings .weregardthisasanimportant future researchdirection.
fordevelopersdecidingbetweenvariability awareorvariabilityobliviousanalyses theseresultsindicateatradeoff.forsituations where software reliability is less of a priority than faster bug detection using a variability oblivious analysis may be sufficient albeit findingtherightsetofconfigurationstotestmaybedifficult.on the other hand for critical software finding every potential defect requiresusingvariability awareanalysestoguaranteethesafety ofevery configuration.
.
rq3 howdoourresults compareto checking amaximumor minimum configuration?
tofurtherunderstandhowthevariabilitywarningscanbedetected and affected by the choice of configurations we compare the warnings of sample configurations to that of minimum default and maximum configurations.
table4shows the results of our comparison to maximum minimum anddefaultconfigurations.toyboxandbusyboxshipwith adefault butnotaxtls.turningonmoreconfigurationoptions typicallymeansmorecode thereforeaconfigurationwithmoreoptionsshouldthenresultinmorewarnings.whilethe allyesconfig command for these codebases build systems will generate a maximumconfiguration duetothesystemdependencies noneofthe allyesconfig syieldbuildableconfigurationsonwhichtorunbug finderssuccessfully.instead wegenerateda maximum configuration for each target program using the optimization algorithm presentedbyohetal.
.similarly totestthetools capabilities in discovering warnings when most options are set to false we generated a minimum configuration using the same optimization algorithm.
we madethe following observations from table .table comparisons to warnings detected by maximum default and minimum configurations.
each cell shows the number of configurations that are shared by the configurationandourresults onlyinthesingleconfiguration oronly in our sampled results i.e.
shared single sample .
no warningswerefoundbycppcheckonaxtls.
inferdidnot run on busybox.
cbmc clang infer cppcheck axtls maximum .9k minimum .6k toybox maximum .2k minimum .5k default .2k busybox maximum 26k .7k minimum .1k 26k default .1k 26k first maximumconfigurationsoftenproducedalargeportionof warnings discovered by running the tool on our sample but never discoveredallwarnings .morethan90 ofcbmcandinferwarnings were found by maximum configurations.
in other cases maximum configurations discovered cppcheck busybox to clangtoybox ofallwarnings producedbyour sample.
second minimumconfigurationsdiscoveredfewerwarnings but also discovered some new warnings .
it is expected that with most configurationoptionsturnedoff minimumconfigurationswould miss most warnings found by our study samples.
for example only out of and out of busybox warnings were found by clang and cppcheck running on the minimum configuration respectively.
note however that minimum configurations also discovered several warnings that were never found in our samples for example new axtls warnings when using cbmc.
upon inspection webelieveonecauseisthatastaticbugdetectormay consider certain code feasible only when most all configuration optionsare settofalse.
anotherreasonisthat someoptionswere never enabled in our configuration samples due to the constraints we enforce.
third manywarnings maybe missed if tools are onlyrun on default configurations .
almost of busybox warnings from cbmc would have been missed if only the default configuration was used.
similarly abouthalfoftheaxtlswarningsfromclangandinfer wouldhave been missed.
the above results suggest that it is not sufficient to only test and analyzethedefault oranothersingle configurationofthetargetsoftware while it may be worthwhile to include the special configuration e.g.
minimum as partofthe test .
bug dataset using the methodology described in section .
we manually classifiedallclang infer andcppcheckwarningsexceptforclang s warningsonbusyboxanduninitialized valwarningsemittedby cppcheckonbusybox.allwarningtypesexceptdead store7were 7whileadead storecanbeasymptomofanotherbug theconfirmationofdead store warningsoften resultsin optimization insteadof bugfixes in the code.
57anempirical studyof real worldvariabilitybugs ... esec fse august tallinn estonia table manually inspected true positive bugs from our study ofvariability warnings.
nowarnings were foundfor cppcheck.
infer did not run on busybox.
we did not investigate clangbusybox warnings.
clang infer cppcheck axtls variabilitybug generic bug toybox variabilitybug generic bug busybox variabilitybug generic bug figure the distribution of number of configurations reporting variabilitybugs.
inspected.
because we confirm each true bug and its associated feature interactions as a team to gain more confidence on the results manual classification of all warnings were prohibitive for thethousandsofcbmcresults the324clangonbusyboxwarnings andthe117uninitialized valwarningsraisedbycppcheck onbusybox.
nevertheless we have generateda truebug dataset consisting of previously unpublished bugs from recent versions of axtls toybox and busybox .
among them are variabilitybugs.thisbugdatasetalsocoversawiderangeofbug types null deref logic error uninitialized val security memory error resource leak memory leak array bounds and undef behavior .
we now study the bug characteristics to providemore insightsonthis dataset.
figure7shows the distribution of the number of configurations on which variability bugs were discovered.
the majority of variability bugs were detected by about half of the configurations in our samples consistent with our observation from figure .
figure 8showsthenumberofconfigurationoptionsaffectingthebugs.recall that these options were initially automatically identified then manuallyconfirmed section .
.inourdataset 40variabilitybugs areassociatedwithonly1configurationoption.amongthesebugs 30aredefinedinmakefiles and10aredefinedwithcpreprocessor directivesinthesourcecode.additionally wesee9bugsassociated with some kind of dependency.
figure 9shows an example of a configurationoption axhttpd inamakefile whichgovernstheinclusionofafile axhttpd.c inwhichwefoundfourbugs.figure figure feature interactions ofvariabilitybugs.
ifndef config axhttpd web server else web server target figure anexample ofvariabilityinan axtls makefile.
shows another configuration option http has authorization which depends on axhttpd i.e.
http has authorization can onlybeenabledif axhttpd isenabled .
http has authorization includes the file htpasswd.c inwhichwe foundtwobugs.
menu axhttpd configuration depends on config axhttpd ... config config http has authorization bool enable authorization default y ... endmenu figure an example of dependencies between configurationoptionsinanaxtlskconfigfile.alloptionsdefinedin thismenudepend on config axhttp.
the other bugs are associated with or options.
figure shows that regardless of the number of options those options can come from either preprocessor directives or from makefiles.
in bugsthatare causedbythe interactionof or options thoseoptionscanoriginatefromanycombinationofmakefile preprocessor anddependencyonanotheroption.thisresultsuggeststhatitis importanttoconsiderthebuildsystemconstraints makefile and preprocessorsaccurately to detectsomevariability bugs.
webelievethisbugdatasetcanserveasavaluablebenchmarkfor futurestudies bothintestingvariability awareanalysesandintestingmethodsoffindingvariabilitybugswithvariability oblivious analysis.wealsobelievethatalthoughwecouldonlymanuallyclassify a small percent of the emitted warnings this dataset supports our methodology as being useful for findingvariability bugs.
threats to validity weidentifytwothreatstothevalidityofourconclusions.first our empiricalstudyusedfourstaticbugdetectorsandthreeopensource c programs.
although these are real world tools and programs 58esec fse august tallinn estonia austinmordahl jehooh ugur koc shiyiwei andpaulgazzillo theymaynotberepresentativeofbugdetectorsandconfigurable c software as a whole.
second there are approximations in our approachthatcouldleadtoinaccurateresults.ourdeduplication processmayidentifytwowarningsasequivalenteveniftheyare not so long as they are on the same line and in the same source code file.
our estimation of variabilitymay incorrectly label some variabilitywarningsasgenericwarnings.ourmanualclassification approachmayproduceincorrectresults.weincreasetheconfidence thatthetruebugswereportaretruebyconfirmingtheseasagroup.
related work our work is related to i recent studies on variability bugs and dataset generation ii research in finding variability bugs and iii methodsthat identifyfeature interactionsanddependencies.
variability bug study and dataset.
abal et al.
studied previouslyreported andfixed variabilitybugsfromthebugrepositories of apache busybox marlin and linux software.
they createdadatabaseof98variabilitybugs eachofwhich hasafeature interactionandsimplifiedcodeversion.thesebugsareofsimilar types to the ones that we find.
bugs in this dataset span over a decadeofsoftwaredevelopmentandonesthatexistinoldsoftware versions are challenging to be reproduced.
our work was inspired by their effort to create a variability bug dataset.
instead we focus on previously unpublished bugs in recent versions of the target programsthatcanbefoundbystaticanalysistoolstosupportthe evaluation offuture analysis.
other empirical work has been performed to study variability bugs .forexample medeirosetal.
investigatedc programstofindundeclared unusedvariablesandfunctionsarising from variability through global analysis using typechef .
they found how those issues were introduced from revision histories andobservedthatthoseissuesoftentookalongtimetobefixed.
propersamplingstrategy is beneficialfor earlydetectionofthose issues.thisworkcreatedadatasetconsistingof39variabilitybugs.
variabilitybugdetection.
twoimportantlinesofresearchinfindingvariabilitybugsarecombinatorialinteractiontesting cit 44 46 andvariability awarestaticanalysis.citaimstosystematically sample configurations that satisfy certain coverage conditions .manyadaptationsofcithavebeenproposedto addresstheneedsofdifferentconfigurationspaces e.g.
accounting for configuration constraints test case constraints and cost aware cit .
although cit approaches have been shown to be effective in finding variability bugs cit test suites are not adequate to isolate and identify the specific interactions ofconfigurationoptionsthatleadtothedetectedvariabilitybugs.
usinguniformrandomsampling ourapproachfocusesonstudying warnings and bugs to make observations that are representative of thecompleteconfigurationspace.also weintegratestaticanalysis toolsto detectvariability bugs.
overthelastdecade researchershavedevelopednewvariabilityaware static analysis techniques .
rhein et al.
presentedaframeworkthatimplementedmultiplevariability aware bugdetectors.theresultsoftheseanalyseswerecomparedwith three sampling based approaches demonstrating the effectiveness and efficiency of variability aware analyses.
characteristics of the warnings detected were also studied.
our study complements this worktounderstandthetypesofvariabilitywarningsreportedbyoff the shelf static bug detectors.
in addition we have generated a bugdatasetviamanualclassification potentiallyusefulforevaluatingthis andothervariability aware analyses.
understanding feature models of existing systems.
understandingthefeaturesandtheirdependenciesfromexistingsystems is vital for understanding the variability.
researchers developed methodsandtoolstoidentifyfeatureinteractionsanddependencies statically from source code make systems and configuration specifications or dynamically running the systems .
for example nguyen et al.
presented igen that dynamically discovers feature interactions with counter exampleguidedrefinement.ourframeworkpresentsanalgorithmfor automaticallyidentifyingfeatures andwealsostudythefeature interactions of the dataset.
several works in this line of research e.g.
igen can potentially be integrated into the framework we built as an alternative approach to identifying feature interactions.
conclusions futurework variability bugsin configurable csoftware presenta seriouschallenge for automatic bug detection through static analysis.
state ofthe art variability aware static analyses are promising but there is currently a gap between them and variability oblivious tools.
our work shows how to simulate variability awareness with these toolsthroughourframework.weappliedthisframeworktoseveral state of the art but variability oblivious bug detectors and several highly configurable codebases.
with our results we gain a deeper understanding of how these tools would perform showing that variability warnings are very frequent represent many kinds of potential defects and are distributed across the configuration space.
to support future research on highly configurable code and analyses ourbugdatasetprovides77truepositivesbugsthatwe know can be found with static analysis tools.
we hope this dataset willbe avaluable benchmarkfor future tooldevelopers.
webelievethatthefindingspresentedinsections 4and5will helpdrivefutureresearchintovariability awareanalysis.oneof ourmostinterestingfindingswasthatgivenanysetofwarnings obtainedfrom1 000configurations thatsamesetofwarningscould be obtained from a small subset of those configurations.
finding an algorithm to identify these configurations in advance would improve variability aware testing.
future analyses of the small configurationsetspresentedinsection 4mayleadtoinsightson how to carefully construct configuration sets that exhibit a wide varietyofvariability warnings.
we have plans to continue to develop our toolchain and dataset togatherfurtherdataonvariabilitybugs.weintendtomakeour framework pluggable to new bug detectors.
we plan to continue to improve our framework with better feature identification and deduplicationalgorithms.specifically wewouldliketodeduplicate bugsacrosstools allowingustocomparedifferenttools.wealso plan to perform more classification of warnings to expand the bug dataset.leveragingtestingtools likeprogramslicers and tracers canbothspeedupclassificationandenableclassificationofmore complex warnings.