rethinking pointer reasoning in symbolic execution emilio coppa daniele cono d elia and camil demetrescu department of computer control and management engineering sapienza university of rome italy coppa delia demetres dis.uniroma1.it abstract symbolic execution is a popular program analysis technique that allows seeking for bugs by reasoning over multiple alternative execution states at once.
as the number of states to explore may grow exponentially a symbolic executor may quickly run out of space.
for instance a memory access to a symbolicaddress may potentially reference the entire address space leading to a combinatorial explosion of the possible resulting execution states.
to cope with this issue state of the art executorsconcretize symbolic addresses that span memory intervals larger than some threshold.
unfortunately this could result in missing interesting execution states e.g.
where a bug arises.
in this paper we introduce m emsight a new approach to symbolic memory that reduces the need for concretization henceoffering the opportunity for broader state explorations and moreprecise pointer reasoning.
rather than mapping address instances to data as previous tools do our technique maps symbolic address expressions to data maintaining the possible alternative states resulting from the memory referenced by a symbolic address in a compact implicit form.
a preliminary experimentalinvestigation on prominent benchmarks from the darpa cyber grand challenge shows that m emsight enables the exploration of states unreachable by previous techniques.
blessed are the forgetful for they get the better even of their blunders.
friedrich nietzsche i. i ntroduction symbolic execution is a technique for program property verification largely employed in the software testing and security domains .
by taking on symbolic rather than concrete inputvalues multiple execution paths can be explored at once witheach path describing the program s behavior for a well definedclass of inputs.
nonetheless the number of paths to explorecan be prohibitively large e.g.
in the presence of unbounded loops or when a pointer to be dereferenced is represented by a symbolic expression.
we base our discussion on the simplerunning example reported in figure .
void bomb char a char i char j char boom a if a boom else boom assert !boom fig.
.
motivating example can we defuse the bomb?the function takes as inputs an array aand two indexes i andj.
we assume that acan point to a large memory area possibly the whole memory and we do not pose any constraintoniandj.
we are interested in characterizing inputs that defuse the bomb i.e.
that do not trigger the assert statement.
previous research and state of the art tools typicallymodel memory as a mapping between concrete addresses andexpressions over concrete and symbolic values.
in this setting different scenarios become possible for handling a symbolicaddress when referencing memory.
a symbolic executor can concretize an address by using one valid model for the symbolic expression under the currentpath constraints.
this strategy naturally arises for instancein dynamic test generation in which values from a concreteexecution are maintained at the same time.
previous researchhas however pointed out that concretization can fail to exerciseprogram branches and paths .
on the other hand treating thememory as fully symbolic would allow an executor to reason about all possible addresses either by forking the execution to account for each concrete address matching an expression or by capturing the uncertainty on the address through nested ite i.e.
if then else expressions over its possible values.
unfortunately fully symbolic memory as described above hardly scales in practice.
hence state of the art executors often trade performance for soundness by implementing apartial memory model in which writes are always concretized while reads are modeled as in fully symbolic memory only in the face of a manageable number e.g.
up to in ofpossible address values and concretized otherwise.
to simplify the discussion of our example let us assume that the involved memory is initially zero filled so to avoid bombdefusing from pre existing storage.
full concretization of both a and a would likely result in an assertion failure unless the same value is used for iandj.
a partial memory model would concretize the symbolic read too as the memory a spans is large.
even when calling context information yields intervals of manageable size the symbolic read a would account for each a j address instance individually leading the executor to find only one bomb defusing input i.e.
the one in which concrete address a j equals the value chosen for a i by the write concretization strategy.
a fully symbolic approach would instead reveal the property that allinputs in which i j holds defuse the bomb.
.
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research new ideas613 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
symbolic execution of the bomb example of figure .
expressions a i and jdenote the concrete addresses of the corresponding variables.
the bomb does not detonate only if the assert succeeds i.e.
if v prime that isv which happens for instance if i j. contributions.
in this work we discuss a different perspective in the design of symbolic pointer reasoning we show how to compactly associate values with symbolic addressexpressions rather than concrete addresses and investigate efficient implementations of a fully symbolic memory usingapaged interval tree.
our approach which we call m emsight natively accounts for state merging a mainstream performance enabler in modern executors and has been integrated in the angr framework.
preliminary results show that m emsight allows for broader state exploration on prominent benchmarks revealing behaviors that previoustechniques would miss or use too much resources to identify.
ii.
t echnique to illustrate how m emsight works we start from a simple base version and then we refine it to make it more generaland efficient in practice.
we target a general setting in whicha symbolic engine maintains for each explored state a set of path constraints reflecting path choices taken at each branch based on the values of symbolic inputs.
an smt solver is invoked to check for path feasibility at branch instructionsand to retrieve models for symbolic values and expressions e.g.
to apply concretization.
data is stored in a memory objectaccessible through load and store operations over expressions describing addresses.
unless otherwise stated we assume thatall addresses and values are expressions over concrete and orsymbolic terms.
furthermore an engine may decide to merge the effects from multiple paths into one to seek for efficiency thus requiring a merge of the respective memories as well.
a. base v ersion we model symbolic memory mas a set of tuples e v t whereeis an expression that denotes an address and vis an expression that denotes the value at address e. attribute tis the logical time at which the tuple was created and is used by load operations to determine the latest value written at agiven address.
to support merge of memories we account for a predicate reflecting specific conditions under which the tuple is valid is typically computed by the executor in terms of diverging path constraints between the states to be merged.
the base version of our symbolic memory data structure is shown in algorithm .
to explain how it works consider againthe example of figure .
in order to determine whether thereis any bomb defusing input we set up a symbolic executor to associate pointer awith symbolic value aand indexes iand jwith symbolic values iand j respectively.
the program s effects on the symbolic state are illustrated in figure .
to keep track of logical time the state includes a timertthat starts at zero.
initially the memory mincludes the address value mappings resulting from parameter passing.for the sake of compactness we denote tuple e v t as e mapsto v ... t ... omitting tift and if true.
algorithm memsight base version m symbolic memory initially empty t timer initially function store e v t t m m e v t true function load e v forx mby ascending timestamp do v ite e x.e x. x.v v returnv function merge sother other ta for x m x.t t a do m m x. x. for x sother.m x.t t a do x. x. other m m x t max t sother.t authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
memory loading and storing to perform a the program first loads the values of variables aandi.
aload e operation algorithm builds an iteexpression that attempts to match eagainst all addresses previously assigned in m considering the most recent tuples first.
the else case of the innermost iteaccounts for uninitialized memory locations which for the sake of simplicity we consider set to zero by default in this base version.
in our example load a yieldsite a a a ite a i i ite a j j which can be simplified to a. similarly load i yields i. the assignment is done by a store a i operation that adds a i true i.e.
a i mapsto t t om after updating t. the test if a performs a load a j operation which constructs an iteexpression vthat selects the appropriate value at address a j. this is done by first matching a jagainst the most recent written symbolic address i.e.
a i and later considering parameters a i and j. the execution then forks off a new state sother mother tother for the then branch where mother is a clone ofmandtother t. this branch is taken iff v .
state merging as the value of the boom variable depends on the taken branch a merge operation algorithm reconciles the states by fusing mandmother intom.
the operation takes four parameters v negationslash is the path condition of the else branch that kept on working on m sother is the state resulting from the then branch while other v is its path condition finally ta is the timestamp of the least common ancestor of the two branches.
the merge updates all tuples added to msince the branch point at time taby guarding them with the else branch condition lines and then adds to mall tuples added to mother sinceta guarding them with the then branch condition other lines .
in our example this results in tuples boom mapsto v negationslash t and boom mapsto v t present in mafter merging the states figure .
finally the program loads and returns the value of boom building the simplified expression v prime ite v .
symbolic execution can therefore conclude that any model of v prime e.g.
such that i j will defuse the bomb.
b. refinements in its initial naive formulation the proposed scheme suffers from a few generality and performance issues.
we discuss anumber of refinements that lead to algorithm .
address range selection one of the main drawbacks of algorithm is that load andmerge operations need to scan the entire memory which can be highly time and space consuming.
we note that it is common for a symbolic addressto be constrained within a certain interval .
hence a moreeffective approach is to index each tuple e v t with the smallest range that includes all possible values ecan attain line of store in algorithm .
the range can be computed by the smt solver lines .
a load e operation can therefore scan just the tuples whose ranges intersect withthe minimum and maximum values of e lines .
memory cleanup algorithm naively adds one tuple at each store.
a useful improvement is getting rid of older tuples that are no longer needed one approach is to remove a tuple if its address is equivalent to the one being written line of store in algorithm i.e.
they lead to the same concrete address for any possible valuation of symbols.
symbolic uninitialized memory identifying how a program may behave when accessing uninitialized memory re gions is crucial for testing and vulnerability exploitation.
inour base version we have assumed that an uninitialized cellholds zero which limits the precision of the analysis.
theload e v operation of algorithm supports symbolic uninitialized memory by performing an implicit store that assigns a new symbol to address eifeis not fully covered by address expressions already in m lines .
a subtle issue is how to make sure that accessing an uninitialized memory address consistently yields the same symbolic value.
more precisely for any two load e vandload e prime v primeoperations if is a valuation of symbols such that e e prime x and address xis uninitialized then v v prime.
to achieve this property we use a tie breaking strategy based on negativetimestamps for tuples created by implicit stores.
observe thatour treatment of uninitialized memory shares similarities with algorithm memsight improved version m symbolic memory initially empty current path constraints t positive timer initially t negative timer initially sat defines equiv e e prime definessat e negationslash e prime range m a b defines x m negationslash function store e v a min e b max e t t m m x range m a b equiv e x.e m m a b e v t true function load e a min e b max e ifsat x range m a b e negationslash x.e then t t m m a b e new symbol t true v forx range m a b by ascending timestamp do v ite e x.e x. x.v v returnv function merge sother other ta ta for x m x.t t a x.t ta do x. x. for x sother.m x.t t a x.t ta do x. x. other m m x t max t sother.t t min t sother.
t authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
how constraint solvers deal with uninterpreted functions.
multi byte load and store the solutions presented in this section work with byte memory objects.
multibyte operations can be supported by issuing separate store andload operations for individual bytes and combining the results.
for instance a load e sizeof int can be obtained by concatenating the values produced by load e load e load e and load e .
this strategy is adopted in several symbolic executors e.g.
klee1 .
c. discussion previous work hinted that certain bugs can only be revealed when writes are modeled symbolically.
however classic approaches may not scale.
for instance remarksthat a repeated read and write using the same symbolic indexwould result in a quadratic increase in symbolic constraints or the complexity of the stored symbolic expressions .
our solution offers a more compact encoding that does not require an explicit enumeration a possibly expensivetask for a solver of valid addresses to either fork thestate or build iteexpressions section i .
as we discuss next range intersection operations can be offloaded to efficient datastructures.
our example also suggests that reasoning overexpressions allows for an easier input class characterization.
iii.
i mplementation in this section we describe a prototype implementation of memsight as a plugin of angr .
we start by presenting angr and then describe the techniques implemented in our prototype while seeking for efficiency.
a.angr angr is an open source framework for binary analysis.
it provides a powerful platform agnostic symbolic execution engine that reasons on vex bytecode and relies on z3 assmt solver.
angr recently participated in the darpa cyber grand challenge and has received considerable attention from many reverse engineering and security practitioners.
angr adopts a partial memory model in which iteexpressions are constructed for a symbolic read if the spanned rangeis not too large.
z3 is queried for the maximum and minimum values that the address can assume and if they differ at mostby angr will ask z3 to enumerate all the solutions and construct an iteaccordingly otherwise the address will be concretized.
optionally write addresses can be treated assymbolic too with a default threshold of for range size.
in order to relieve the solver from the burden of repeated queries and improve efficiency a number of optimizations areimplemented in the claripy constraint solving wrapper.
to improve scalability angr implements an extended veritesting merging strategy that analyzes the control flow graph todetermine at which places is profitable to condense the effectsof separate chunks of code using iteconstraints.
prototype we devise m emsight as a plugin2implementing the memory abstraction required by the simuvex symbolic engine of angr so it can easily be interchanged with the default plugin for partial memory modeling.
as the abstraction explicitlyaccounts for a merging primitive strategies such as veritesting can run on top of m emsight with no extra effort required.
the first practical challenge we have to overcome is supporting range operations from algorithm efficiently.
one possibility is to maintain an interval tree to allow for efficient retrieval of all stored intervals that overlap with a given one.however we should keep in mind that when a branch isencountered an executor typically clones the state along withthe associated memory.
to allow better space usage we thuspropose a memory wise paged interval tree.
we partition the address space in pages a primary interval tree built on topof page indexes holds pointers to secondary interval trees thatcontain the tuples in m. each tuple is contained in exactly one secondary tree.
the page size is empirically determinedto minimize the maximum tree size in the data structure.
boththe primary and the secondary trees are maintained using acopy on write strategy that minimizes the need for cloningand promotes memory sharing among different states.
another crucial aspect to take into account is that the majority of memory accesses in a symbolic exploration typically happen on concrete addresses.
capturing concrete stores in an interval tree would result in maintaining information about many ranges of size .
we thus extend our representation witha concrete memory object that associates concrete addresseswith expressions representing values.
each expression is an notated with a timestamp so it can possibly be combined withvalues mapped to symbolic addresses during a load operation.for the sake of efficiency concrete memory is implementedas a paged hashmap with copy on write cloning for pages similarly as in angr s default memory implementation.
iv .
e v aluation in this section we report on a preliminary investigation of the practical impact of m emsight compared to previous memory representations for symbolic execution.
a. experimental setup and methodology our experiments are based on benchmarks from the cromulence cromu darpa performer group of the cyber grand challenge cgc .
tests were conducted on a server equippedwith an intel r circlecopyrtxeonr circlecopyrtcpu e5 v3 .40ghz with cores and gb ram running linux centos .
.
we compare m emsight against three different angr memory concretization strategies angr conc which concretizes all accessed symbolic addresses angr part the default of angr which concretizes all read addresses that span ranges larger than and all written addresses and angr full 2our prototype was tested in angr v5.
and is available at com season lab memsight.
creating it has required a substantial implementation effort due to its complex interplay with the different layers of angr .
along the way we have discovered and fixed a few subtle bugs in angr .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symbolic store fig.
.
example of symbolic store excerpted from the cromu cyber grand challenge benchmark.
which performs no address concretizations by raising the read and write thresholds to an infinite value.
we symbolically execute m emsight angr conc angr part and angr full on the cromu benchmarks with a budget of hours and gb of ram.
to characterize the breadth of the exploration enabled by the memory model in use we measure the number of explored paths.
to makea meaningful comparison across different memory models inour experiments symbolic execution explores states in roundsusing a first in first out strategy a new round starts only when all states in the previous round have been explored.
hence at any round the set of explored paths with some concretizationstrategy is always a subset of the paths that would be exploredby performing fewer concretizations.
b. case study we now discuss a real world code example that shows how m emsight can maintain fully symbolic addresses in a context where previous techniques are instead forced to concretize them.
cromu is a service included in the darpa cgc suite that produces random numbers and generates chartsfor numeric data including bar charts and sparklines.
thebenchmark dereferences pointers that span very large portionsof the address space.
this arises for instance in functionread data shown in figure which fills a buffer data of symbolic size datum cnt with values read from the input.
an inspection of the x86 binary code reveals thatthe dynamic stack allocation uint32 data line makes the stack pointer register esp symbolic.
later in the code line parameter passing on stack to functionread causes a store to the symbolic esp.
the range of possible addresses esp can assume at that point is as large as due to previous constraints on the maximum stacksize imposed by the program.
this triggers concretization in angr part forcing the symbolic execution to reason on a buffer of fixed size3.
since the symbolic range for esp is very large angr full fails to produce a result due to excessive resource consumption.
in contrast m emsight keeps esp symbolic considering in the analysis all possible sizes of thedata buffer.
as confirmed by our experiments the ability to 3we observed that since the stack grows downward and angr concretizes symbolic writes by default using the maximum possible address then the analysis ends up reasoning on the smallest rather than the largest buffer size.
a segment dependent concretization strategy would yield better results here.consider a buffer of variable size impacts the breadth of the exploration allowing m emsight to push symbolic execution through states that remain hidden to angr part .
c. experiments the first question we address is how broad are the symbolic address dereferences performed by the cromu benchmarks?
to this aim we measure the range of symbolic loads andstores throughout the analysis.
this is a structural property of the considered benchmarks independent of the chosen memorymodel.
the left half of table i reports the total number ofmemory accesses to a symbolic address with a range size larger than c oncr and the maximum size of the ranges of symbolic addresses accessed by load and store operations throughout the execution.
notice that for some benchmarksthe ranges are much larger than the thresholds one can affordto use in practice in partial memory models.
our second question is to what extent does concretization restrict state explorations?
the right part of table i comparesthe number of distinct control flow paths explored by thememory models we considered.
to allow direct comparison the snapshot of the number of paths is taken at the same exploration depth kfor the same benchmark in all memory versions.
we first observe that full concretization angr conc may restrict the number of explorable paths confirming the findings reported in .
we also note that for somebenchmarks that exhibit large ranges for symbolic addresses a partial memory model angr part does not capture all explorable paths.
explicit fully symbolic memory angr full fails to complete due to excessive resource requirements.
full exploration is instead supported by m emsight which can visit a larger portion of the execution state space.
v. r elated work a number of projects have addressed the problem of modeling symbolic pointers.
the memory model of exe allowssymbolic reads by emulating pointers as offset referencesto array objects concretization is used for multiple pointerdereferences while symbolic writes are not discussed in detail.
klee implements a similar strategy but clones the execution state when a pointer can refer to multiple objects constraining the pointer to be within a single object in a clone.
sage takes advantage of concrete values from dynamic test generation to support symbolic pointers confining them authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i preliminary experiments on the cromu c yber grand challenge benchmarks .
benchmark c oncrmax range size p a t h sa tr o u n dk load store k angr conc angr part angr full memsight cromu 00001 cromu 00006 failed cromu 00009 cromu 00014 cromu 00018 failed cromu 00024 cromu 00027 cromu 00031 cromu 00032 cromu 00033 within the memory regions in which the corresponding concrete values fall.
the work also discusses the relevance ofmultiple pointer dereferences and symbolic writes in testing.
mayhem introduces partial memory modeling and proposes a number of clever optimizations such as valueset analysis and fine grained query caching to reduce the burden on the smt solver when assessing range sizes.
our work shares several analogies with the segment offsetplane model proposed in which stores data in separateplanes based on their type.
each plane holds a list of write records and a solver is invoked for each read operation to check whether a stored expression collides with the given typed symbolic address.
we believe our approach is moregeneral as it is not affected by the type safety of a language it provides support for state merging that is compelling forscalability and it explicitly accounts for uninitialized memory.
the framework presented in to describe concretization policies for symbolic values and addresses sheds light on aninteresting research problem paving the way to a systematicstudy of concretization strategies and policy tuning.
we also believe that pointer concretization strategies might benefit from the delayed concretization technique with uninterpretedfunctions proposed in to handle non linear constraints.
vi.
c onclusion we believe that the key concept of generalizing a symbolic memory so that it maps symbolic address expressions rather than just concrete addresses to value expressions can leadto further interesting developments.
the refinements introduced in algorithm and the optimizations applied to our prototype implementation can sig nificantly affect the performance of the basic version of theapproach.
nonetheless the design space to explore in opti mization is large leaving significant room for improvement.
as a first observation static analysis techniques such as value set analysis can be used to refine ranges as in and ease constraint solving.
also the expressions returnedbyload operations could be amenable to simplification as expressions from recent symbolic writes may together supersede other expressions stored earlier in the execution.similarly the paged interval tree may periodically be rebuilt or modified in a lazy fashion to prune outdated values.
an executor might also decide to trade performance forsoundness at a later stage by concretizing certain symbolic address expressions or limiting the ranges they span usingspeculative heuristics.
investigating the benefits of delayedpointer concretization in symbolic execution and possiblestrategies for it remains an interesting open question.
a cknowledgments this work is partially supported by a grant of the italian presidency of ministry council and by cini cybersecuritynational laboratory within the project filierasicura fundedby cisco systems inc. and leonardo spa.
r eferences r. baldoni e. coppa d. c. d elia c. demetrescu and i. finocchi a survey of symbolic execution techniques corr vol.
abs .
.
.
available b. elkarablieh p. godefroid and m. y .
levin precise pointer reasoning for dynamic test generation in proc.
of issta .
acm .
.
available s. k. cha t. avgerinos a. rebert and d. brumley unleashing mayhem on binary code in proc.
of sp .
ieee computer society .
.
available t. avgerinos a. rebert s. k. cha and d. brumley enhancing symbolic execution with veritesting in proc.
of icse .
acm .
.
available y .
shoshitaishvili r. wang c. salls n. stephens m. polino a. dutcher j. grosen s. feng c. hauser c. kr ugel and g. vigna sok state of the art of war offensive techniques in binary analysis in proc.
of sp .
ieee computer society .
.
available c. cadar d. dunbar and d. engler klee unassisted and automatic generation of high coverage tests for complex systems programs in proc.
of osdi .
usenix association .
.
available n. stephens j. grosen c. salls a. dutcher r. wang j. corbetta y .
shoshitaishvili c. kruegel and g. vigna driller augmenting fuzzing through selective symbolic execution in ndss .
c. cadar v .
ganesh p. m. pawlowski d. l. dill and d. r. engler exe automatically generating inputs of death in ccs .
acm .
.
available e. duesterwald ed.
analyzing memory accesses in x86 executables ser.
cc .
springer berlin heidelberg .
.
available m. trt k and j. strej cek symbolic memory with pointers ser.
atv a .
cham springer international publishing pp.
.
.
available r. david s. bardin j. feist l. mounier m. l. potet t. d. ta and j. y .
marion specification of concretization and symbolization policies in symbolic execution in proc.
of issta .
acm .
.
available c. s. p as areanu n. rungta and w. visser symbolic execution with mixed concrete symbolic solving in proc.
of issta .
acm .
.
available authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.