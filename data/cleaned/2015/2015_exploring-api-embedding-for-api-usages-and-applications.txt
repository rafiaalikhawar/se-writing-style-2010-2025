exploring api embedding for api usages and applications trong duc nguyen anh tuan nguyen hung dang phan electrical and computer engineering department iowa state university email trong anhnt hungphd iastate.edutien n. nguyen computer science department university of texas at dallas email tien.n.nguyen utdallas.edu abstract word2vec is a class of neural network models that as being trained from a large corpus of texts they can produce for each unique word a corresponding vector in a continuous space in which linguistic contexts of words can be observed.
in this work we study the characteristics of word2vec vectors called api2vec orapi embeddings for the api elements within the api sequences in source code.
our empirical study shows that the close proximity of the api2vec vectors for api elements reflects the similar usage contexts containing the surrounding apis of those api elements.
moreover api2vec can capture several similar semantic relations between api elements in api usages via vector offsets.
we demonstrate the usefulness of api2vec vectors for api elements in three applications.
first we build a tool that mines the pairs of api elements that share the same usage relations among them.
the other applications are in the code migration domain.
we develop api2api a tool to automatically learn the api mappings between java and c using a characteristic of the api2vec vectors for api elements in the two languages semantic relations among api elements in their usages are observed in the two vector spaces for the two languages as similar geometric arrangements among their api2vec vectors.
our empirical evaluation shows that api2api relatively improves .
and .
top and top accuracy over a state of the art mining approach for api mappings.
finally as another application in code migration we are able to migrate equivalent api usages from java to c with up to .
recall and .
precision.
keywords word2vec api embedding api usages migration i. i ntroduction software library plays an important role in modern software development.
to access the functionality of a library developers use application programming interfaces api elements apis for short which are the classes methods and fields provided by the library s designers.
a certain combination of api elements is used to achieve a programming task and is called anapi usage .
an example of a java development kit jdk usage for reading from a file could involve the sequence of the apis of file and scanner and the control unit while to iterate over the file s contents.
the combination of api elements allows intricate and complex api usages yet in many cases the api usages that developers write are repetitive .
as an evidence of that researchers have been able to mine api usage patterns which are frequently occurring api usages from large code corpora .
in other words the sequences of api elements in api usages are natural i.e.
have high regularity .
existing works have explored the regularity of api usages to build api recommendation engines by using the statisti cal modeling of natural utterances and applying it to api sequences to suggest the next api call in a program editor.
typical natural language processing nlp models for api call suggestion include n gram model deep neural network model and graph based generative model .
in this work we focus on exploring the naturalness of api usage sequences from a different perspective by investigating the embeddings of api elements in a continuous vector space created by word2v ec .
let us call them api embeddings or api 2vec .
word2v ec has been shown to be able to capture the similarities of the relations between pairs of words in sentences pairs of words sharing a particular relation have word2v ec vectors with constant similar vector offsets .
via visualization with principal component analysis pca and vector operations researchers have observed the syntactic relations e.g.
base comparative base superlative singular plural base past tense etc.
.
semantic relations among words can also be captured via vector operations .
for example for state capital v france v paris v italy v rome wherevdenotes word2v ec and the minus sign is for vector subtraction.
other types of semantic relations are also observed city state famous name profession company famous product team sport etc.
.
if these observations hold for the relations among api elements we could leverage api 2vec to support the tasks related to api usages e.g.
api code completion usage migration api pattern detection etc.
toward that goal we conducted experiments on a large number of java and c projects to answer the following research questions in a vector space produced by api 2vec on api elements do nearby vectors represent the apis that have similar usage contexts defined as similar surrounding api elements of those apis ?
by vector offsets can api 2vec reveal similar usage relations between api elements defined as co occurring relations between api elements in api usages ?
our empirical results confirmed that close proximity of the vectors for two api elements reflects their similar usage contexts.
we also showed that api 2vec can capture similar usage relations between the apis in usages by vector offsets.
we demonstrated the usefulness of api 2vec vectors for apis in three applications by using those characteristics.
first we built a tool to mine pairs of api elements sharing the same usage relations among them.
for example we can mine that the relation checking the existence of the current element be2017 ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fore retrieval is shared between listiterator.hasnext and listiterator.next and between stringt okenizer.hasmoret okens and stringt okenizer.nextt oken despite that they have different names for similar functionality.
thus given the pair listiterator.hasnext listiterator.next and stringt okenizer.hasmoret okens our tool can suggest stringt okenizer.nextt oken using vector offsets.
the other applications are in the domain of code migration.
we build api 2api to automatically learn api mappings between java and c i.e.
the api elements in two languages with the same similar functionality .
it is based on a characteristic of api embeddings in two languages as follows.
in the two languages despite that the respective apis might have different names since if they are used to achieve the same similar functionality each of the api elements would have the same similar role in its respective api usage and the relations between two api elements would have the same similar meaning as the relation between the corresponding api elements in the other language.
for example the relation checking the existence of the current element before retrieval exists between listiterator.hasnext and listiterator.next in java as well as between the corresponding apis ienumerator.movenext and ienumerator.current in c .
a usage could have multiple api elements e.g.
the above api usage could include list.iterator since we first need to obtain an iterator of a list .
however the relation between two java api elements in a usage will exist and be interpreted as the same meaning as the relation between the two respective apis in c .
thanks to the above vector offset characteristic in both java and c vector spaces in our experiment we were able to observe that the api elements in the corresponding api usages in java and c have their vectors in similar geometric arrangements in the two vector spaces for java and c .
for example fig.
shows similar arrangements of the vectors for the apis in the usages with filereader and filewriter in java and streamreader and streamwriter in c .
this is reasonable since each element and its corresponding api element play the same similar role in the corresponding usage.
then due to similar geometric arrangements we can learn the transformation e.g.
rotating and or scaling between the vector spaces if we know some api mapping pairs in a training data.
to find the mapped c api for a given java api jwith its vector vj we use the learned function to compute its transformed vector vcin the c space.
the c api cwith the vector most similar to the transformed vector vcis considered as the mapped api of j. to evaluate api 2api we conducted an empirical study.
our result shows that for a given java api in .
of the cases the correct respective c api is listed on the top of api 2api s resulting list.
it has .
and .
relative improvement in top and top accuracy respectively over the state of theart approach staminer .
to show the third application we used our resulting api mappings in a phrase based machine translation tool phrasal to translate a jdk usage sequence into the equivalent .net usage with multiple api elements .
the result showed that with the mappings our tool achieves high precision up to .
and recall up to .
in migrating api usages.
our key contributions includeapi vector api api api api api api api api api api api apiapi sequenceslarge code corpus cbow word2vec modelingsequence extraction .
wi n wi ... wi wi n ... .
hidden inputoutput n dimv dim fig.
v ector representations for api elements with cbow an extensive study on the characteristics of api 2vec embeddings vectors for api elements in api sequences an application of api 2vec for api elements in mining the pairs of api elements that share same usage relations api 2api an approach to mine api mappings via vector projection without a parallel corpus of respective code an empirical study to show api 2api s accuracy in mining api mappings and migrating api usages from java to c .
ii.
b ackground on word 2v ec word2v ec is a class of neural network models in which after being trained in a large corpus of texts they can produce for each unique word a corresponding vector in a continuous space in which linguistic contexts of words can be observed.
it represents words by encoding the contexts of their surrounding words into vectors.
mikolov et al.
introduce two word2v ec models named continuous bag of words cbow and skipgram models.
we show cbow model in fig.
as we used it.
let us summarize the cbow model.
basically cbow has a neural network architecture with three layers input hidden and output.
the input layer has a window of nwords preceding the current word wiand a window of nwords succeeding wi.
the total context window s size is n. the output layer is for wi.
each word is encoded into the model as its index vector.
an index vector for a word is an vvector with vbeing the vocabulary s size and only the index of that word is and the other positions of the index vector are zeros.
the word2v ec vector for each word wiis the output of the hidden layer with ndimensions which is the number of the dimensions of the vector space.
to compute word2v ec vector for wi cbow first takes the average of the vectors of the ninput context words and computes the product of the average vector and the input to hidden weight matrix wv n shared for all words v wi 2n w i n ...w i w i ... w i n .wv n v wi is the word2v ec vector for wi.2nis the window s size.
wv nis the input to hidden weight matrix.
w i n ... w i n are the vectors of the words in the context window.
training criterion is to derive the input to hidden weight matrix wv nand the hidden to output weight matrix authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
w prime n vsuch that word2v ec correctly classifies the current wordw wifor all words.
details can be found in .
iii.
api 2vec api e mbeddings for api u sages a. api 2vec for api usages in api usages one needs to use api elements in certain orders.
thus apis are often repeatedly used in similar contexts i.e.
similar surrounding api elements in which each of them has a specific role.
we aim to verify if word2v ec vectors can capture the regularity of apis via maximizing the likelihood of observing an api element given its surrounding elements in the api usages.
let us call them api2vec vectors.
specifically in word2v ec the regularity of words is expressed in two key characteristics.
first it has been shown that in the word2v ec vector space for texts the nearby vectors are the projected locations of the words that have been used in the similar contexts consisting of similar surrounding words .
thus our first research question is to verify whether the close proximity of the vectors in the api2vec vector space represent the api elements that have similar usage contexts .
two apis have similar usage contexts if they have similar sets of surrounding api elements in their api usages .
examples of apis with similar contexts are the apis in the same class or the classes with similar purposes e.g.
stringbuffer and stringbuilder .
they are often surrounded by similar sets of apis in usages.
second in nlp the regularity of words is observed as similar vector offsets between the pairs of words sharing a particular relation.
for api usages apis are used in certain ways with semantic dependencies relations among them.
for example the relation check if the current element exists before retrieval occurs between listiterator.hasnext and listiterator.next and between xmlstreamreader.isendelement and xmlstreamreader.next .
such relations among apis called usage relations are parts of api usages and occur regularly in source code.
thus our second research question is to verify if similar usage relations between apis can be observed via vector offsets .
b. building api sequences for api usages for training we process a large code corpus to build the sequences of annotations to represent api elements in usages.
we traverse an ast to build an annotation sequence according to the syntactic units related to apis including literals identifiers api elements method constructor calls field accesses variable declarations array accesses and control statements while for if etc.
.
for a non control unit we collect data types method field names return types and roles literals variables receivers arguments .
such annotation is expected to increase regularity and characterize api elements.
the names of types classes methods fields are kept.
those of variables identifiers are discarded since different usages could use different names.
table i shows the key rules to build annotation sequences in java.
similar rules are used for c not shown .
is used to denote the function to build an annotation sequence api sequence for short .
it is initially applied on a method and recursively called upon the syntactic units in the code until we have all terminal annotations.
a terminal annotation is eithertable i keyrules e tobuild api s equences in java syntax t typeof rettype return type expression literal e t lit e lit e.g.
abc string identifier e t id var e id e.g.
writer filewriter var methodcall e e1 ... en rettype m ret e rec e t e .m t e1 arg ... t en arg e.m e1 ... en discard ei i feiis id or literal discard e rec if e is a class name e.g.
dict.get vocab integer ret hashmap rec hashmap.get string arg constructor e e1 ... en t c .new e new t e1 arg...t en arg c e1 ... en e.g.
new filewriter a filewriter.new string arg field access e t f ret e rec t e .f e e.f discard e rec if e is a class name e.g.
reader.lock object ret reader rec reader .lock v ariable decl e c var e1 e cid1 ... e.g.
filewriter writer filewriter var arrayaccess e e t a t a access t e arg e a discard e ifeis id or literal e.g.
list string string access integer arg lambda expr e e1 ... en e e e1 ... en t e1 arg ... t en arg e statement forstmt s s for i1 ... in e u1 ... um s1 for i1 ... in e e.g.
for it.hasnext u1 ... um s for bool iterator var iterator.hasnext s while e s1 while e s1 s if e s1 s if e s1 else exprstmt s e s e block s s1 .
sn s s1 ... sn a method call e.g.
reader.read field access or a type with without a suffix annotation e.g.
string filewrite var hashmap rec string arg .
the final sequence contains only terminal ones.
literal we keep only its type.
identifier we concatenate its type with annotation var .
method call we keep its full signature including the return type and the types not the concrete names of its receiver and arguments.
for example for dict.get vocab w eh a v e integer ret hashmap rec hashmap.get string arg .
such type information could help predict the current api call given the return type and its arguments types or predict the current argument given the name of api call its return type and other arguments.
we keep the receiver s type since we want to capture the following relations an object invokes an api call and a call returns an object with a specific type.
if a method call is an argument of another call m n the sequence for n is created before the one for m becausen is executed first.
constructor call or field access similar to method call.
for a constructor call no return type and receiver s type is needed.
v ariable declaration we keep its type and annotation var e.g.
filewriter var .we discard its name to increase its regularity.
array access we keep the types of the array the elements and the index e.g.
list string string access integer arg .
statements the rules for while for if and other statements are similar however those keywords are also kept.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1hashmap dict new hashmap dict .
put a 3filewriter writer new filewriter vocabulary.txt 4for string vocab dict .
keyset writer .
append v o c a b dict.
get vocab r n writer .
close fig.
an api usage in java jdk table ii da tasets to build api 2vec vectors projects classes meths locs v oc size java dataset .1m 7m 352m 123k c dataset 900k .3m 292m 130k for example in fig.
we produce the api sequence hashmap var hashmap .new string ret hashmap rec hashmap.put string arg integer arg filewriter var filewriter.new string arg for string var string ret hashmap rec hashmap.keyset string ret hashmap rec hashmap.get string arg filewriter rec filewriter.append string arg filewriter rec filewriter.close such sequences for all methods in a dataset is used to train cbow.
an api annotation sequence for a method is called a sentence .
each element in a sentence is considered as the current one.
assume that the current api is hashmap.keyset used for the output layer fig.
.
if the context window s size is we use elements preceding and succeeding it for the input.
after training the output of the hidden layer gives the vector for the current api which is called api embedding .
iv .
c haracteristics of api e mbeddings we conducted experiments to answer the following questions rq1.
in a vector space for the apis in usages do nearby vectors represent the apis that have similar usage contexts?
rq2.
can vector offsets in api 2vec capture similar usage relations i.e.
co occurring relations among apis in usages ?
data collection table ii the first dataset collected from allamanis et al.
is for training word2v ec model to build the vectors for jdk apis.
for vectors for .net apis we chose c projects with the ratings of stars in github.
a. rq1.
nearby v ectors represent apis with similar contexts we first randomly selected jdk api methods and fields in our dataset.
for each api we computed the top api method calls and field accesses that are closest to that api in the vector space.
we processed those groups of api methods fields one main api of the group and top closest ones to verify if each of those elements shares similar usage contexts with the main api i.e.
used with similar surrounding apis .
for such verification we wrote a program to take two apisaandband search through our java dataset to compute two setsaandbof api elements that have been frequently occurred with aandb respectively threshold in the methods in the dataset.
if aandboverlaps more than we consider aandbshare similar surrounding apis in usages.table iii examples of api s sharing similar surrounding api s g1.
file.new g4.
list.iterator system.getproperty processbuilder.directory path.tofile filedialog.getfile jarfile.newsynchronousqueue.iterator arraylist.iterator arraydeque.iterator collection.iterator v ector.iterator g2.
system.currenttimemillis g5.
string.hashcode calendar.gettimeinmillis threadmxbean.getthreadusertime thread.sleep file.setlastmodified calendar.settimeinmillisinteger.hashcode date.hashcode class.hashcode boolean.hashcode long.hashcode g3.
string.compareto g6.
map.keyset integer.compareto comparable.getclass boolean.compareto long.compareto comparable.tostringidentityhashmap.entryset enummap.entryset abstractmap.keyset navigablemap.keyset identityhashmap.keyset table iv t test results for vector distances of api s in the same and diffferent classes and packages for java a n d c t df p value confidence interval java class .
.
.2x10 .
java package .
.
.2x10 .
c class .
.
.2x10 .
c package .
.
.2x10 .
among pairs of apis groups and comparisons each we found that pairs .
of them have similar surrounding apis in their usages.
thus this gives a positive answer to our rq1.
for the other .
this is because an api has multiple contexts and some contexts with infrequently used apis were not captured with insufficient data.
table iii displays a few groups of those nearby api vectors.
the groups on the left share similar surrounding api elements despite that their names are quite different.
the groups on the right have members sharing the names.
for illustration we show only the groups with the members in different classes.
b. v ectors of the apis in same classes packages in this experiment we aim to verify if an api method call or field access to be projected closer to the other apis of the same class than the apis of different classes .
we computed the cosine distances among the vectors of the api methods and public fields in the same class and the distances among the vectors of the apis from different classes.
for every api method field m we computed the distances fromm to all other api method fields in the same class withmand to all other methods fields in different classes.
to verify for all the distances in the entire set of apis we conducted the independent samples t test with significance level .
.
we chose the following alternative hypothesis the distances among the vectors of the apis within a class are smaller than the distances among the vectors of apis belong to different classes .
the null hypothesis is those distances are equal .
we also performed the same procedure for the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g25 g19 g13 g26 g26 g15 g25 g27 g20 g26 g26 g28 g26 g29 g30 g31 g32 g30 g33 g15 g25 g27 g20 g26 g26 fig.
distances of jdk api v ectors within and cross classes api methods fields with respect to the boundary of packages.
table iv shows the results for both java and c vectors.
as seen with the p values we can confirm our alternative hypothesis the distances among the vectors for apis in the same class package is significantly smaller than the distances for apis in different classes packages.
thus we can verify .
fig.
shows the boxplot for the distributions of distances among the vectors of the methods fields in the same classes for the most popular jdk classes in our dataset.
we also show the boxplot for the distributions of distances between the vectors of the apis in each class and those in other classes.
as seen the two boxplots for each class are quite separated.
in brief the apis in the same class package perform functions relevant to the class package s theme and often share similar surrounding apis.
they tend to have nearby vectors .
c. rq2.
similar v ector offsets reflect similar relations we first mined the frequent pairs of apis by collecting all the pairs of the apis in the same methods in our java dataset.
we ranked the pairs by their occurrence frequencies.
we then manually checked the most frequent pairs and collected of them which are placed into groups of pairs representing different relations.
similarly we collected a set of correct pairs of c apis placed into groups.
we used those two sets of pairs in jdk and .net as our benchmarks.
we processed the pairs as follows.
for each group of pairs of apis representing a relation we randomly picked a seed pair e.g.
list var list.add .
for each of the other pairs in the group e.g.
map var map.put we applied the vector offset from the seed pair to the vector of the first api of the current pair to compute the resulting vector e .
g .
x v list.add v list var v map var .
we then searched for the vectors that are closest to x e.g.
map.put and considered them as the candidates ranked by their respective cosine distances .
if the second api of the current pair in the benchmark is in the top k of the candidate list we count it as a hit.
accuracy is the ratio between the number of hits over the total number of cases.
there are .
of the correct apis in those relations showing up in the top candidate lists.
.
are actually at the top one.
table v shows examples of groups of relations in our oracle for jdk apis and the ranks of the correct apis in the candidate lists.
as seen api 2vec can capture similar relations between apis and rank highly the correct apis even when the respective names are different.
for example in the relationtable v example rela tions via vector offsets in jdk r1.
check the current element before retrieval rank listiterator.hasnext listiterator.next enumeration.hasmoreelements enumeration.nextelement stringtokenizer.hasmoretokens stringtokenizer.nexttoken xmlstreamreader.isendelement xmlstreamreader.next r2.
obtain property after creating system stream system var system.getproperty properties var properties.getproperty xmlstreamreader var xml...reader.getattr...v alue r3.
add an element to various types of collections list var list.add map var map.put hashtable var hashtable.put dictionary var dictionary.put r4.
parse a string into different types of numbers float var float.parsefloat double var double.parsedouble integer var integer.parseint long var long.parselong r5.
avoid adding duplicate element to a collection set.contains set.add map.containskey map.put linkedlist.contains linkedlist.add hashtable.containskey hashtable.put add an element to various types of collections as using list one uses list.add however map.put is used for map .w e were also able to observe interpret the same relations in c check size before removal e.g.
dictionary.count dictionary.remove add an element to a collection e.g.
hashtable.new hashtable.add read a file with different types e.g.
binaryreader.readint64 system.int64 check the current element before retrieval e.g.
ienumerator.movenext ienumerator.current etc.
we also build a tool to derive pairs of api elements with the same similar relations.
the tool takes as input a pair of api elements in the same class e.g.
list var and list.add and another api in a different class e.g.
hashtable var .
it then uses the vector offsetting operation to derive the corresponding api hashtable.put without understanding the meaning of the relation.
one could use this tool to derive that list.add could be used to achieve the similar functionality as hashtable.put .
this is useful for developers who are new to the apis.
v. m ining api m appings between java a n d c a. api mappings this section presents an application of api embeddings in code migration.
migrating code from one language to another requires not only the mappings between the language constructs e.g.
statements expressions but also the mappings between the apis in the two languages that have the same similar functionality.
for example in jdk one uses system.out.println while in .net s he could use console.writeln .t o authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
filereader.readfilereader.close filereader var filereader.newfilewriter.close filewriter.write filewriter var filewriter.new filewriter.appendstreamreader.readlinestreamreader.close streamreader var streamreader.newstreamwriter.close streamwriter.write streamwriter var streamwriter.new streamwriter.writelinejava jdk c .net y x .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.0y x .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
fig.
distributed v ector representations for some apis in java left the corresponding apis in c right reduce manual effort several approaches have been proposed tomine api mappings from a parallel training corpus of the libraries client code that already had two respective versions in two languages .
however building such corpus with parallel implementations in general requires much effort.
b. mappings via transformation between two v ector spaces in this work we introduce api 2api an approach tool to automatically mine api mappings between java and c without requiring a parallel corpus.
api 2api is based on a characteristic of the api 2vec vectors for api elements in two languages semantic relations among apis in their usages are observed in the two vector spaces for the two languages as similar geometric arrangements among their vectors .
for motivation we conducted an experiment in which we picked groups of apis in java jdk filereader and filewriter and the corresponding apis in c .net.
the vectors for the respective apis in jdk and .net in each group were projected down to two dimensions using pca .
we visually observe that the group of filereader and that of the respective one streamreader have similar geometric arrangements in the two vector spaces.
this suggests further exploration.
with this projection to d spaces we were able to compute a transformation matrix that converts those two groups of apis in java to the respective ones in c .
that is similar geometric arrangements enable us to find a transformation with rotating and scaling between the vectors in the two vector spaces.
the rationale is that the usage relations e.g.
in the usage open a file read and close it among filereader var filereader.new filereader.read and filereader.close are observed as the vector offsets in the java api vector space.
in c those usage relations are also captured via the vector offsets among the corresponding apis in the c vector space streamreader var streamreader.new streamreader.readline and streamreader.close .
the distance vector offset between the api vectors with such a relation in the java space might be different from the distance between the g1 g2 g3 g4 g5 g6 g7 g2 g8 g3 g9 g10 g7 g4 g11 g12 g7 g13 g14 g15 g16 g1 g2 g3 g2 g4 g5 g6 g7 g8 g9 g10 g11 g1 g2 g12 g13 g4 g5 g6 g7 g8 g9 g10 g11 g1 g3 g1 g3 g4 g1 g2 g1 g2 g3 g2 g4 g8 g9 g4 g12 g13 g14 g10 g2 g15 g11 g16 g9 g10 g17 g2 g8 g18 g9 g15 g4 g19 g2 g8 g10 g18 g20 g17 g3 g18 g3 g19 g7 g2 g13 g20 g21 g16 g22 g11 g12 g7 g13 g16 g15 g23 g24 g19 g7 g2 g13 g20 g21 g16 g22 g11 g12 g7 g13 g16 g15 g1 g2 g3 g2 g4 g5 g6 g7 g8 g9 g10 g4 g5 g6 g7 g8 fig.
training for transformation matrix corresponding api vectors with the same relation in the c space.
however as in nlp such a distance vector offset for two api vectors in java space can be interpreted as the same relation as the distance offset between two vectors for the corresponding apis in c space.
for example both v filewriter.new v filewriter.append and v streamwriter.new v streamwriter.writeline can be interpreted as the relation open and append to a file .
thus the respective vectors in two vector spaces could form similar geometric arrangements.
c. transformation matrix to compute single api mappings from the above observation we aim to learn the transformation between the two vector spaces for apis from some priorknown api pairs and then use the learned transformation to locate the c vectors corresponding to other unknown java apis.
fig.
shows how we train the transformation model.
first we collect the single mappings between jdk in java and .net in c into a training set in our empirical evaluation we used a set of api mappings that was provided as part of the migration tool java2csharp .
for example filereader in jdk is mapped to streamreader in .net.
then we use the trained word2v ec models for jdk and .net to collect the vectors for all the pairs of apis in the training set.
in training the pairs of vectors of those respective apis are used to derive the transformation matrix from java to c as follows.
let us have a training set of api pairs and their associated vector representations ji ci i ..n wherejiis a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g1 g2 g3 g2 g4 g5 g3 g6 g4 g1 g3 g5 g4 g1 g3 g6 g4 g4 g3 g7 g4 g8 g3 g1 g4 g2 g3 g5 g7 g4 g3 g4 g8 g5 g3 g2 g8 g4 g3 g9 g8 g8 g3 g6 g9 g2 g3 g1 g10 g11 g10 g1 g10 g7 g10 g9 g10 g5 g10 g10 g12 g13 g14 g15 g5 g12 g13 g14 g15 g11 g12 g13 g14 g15 g2 g12 g13 g14 g15 g1 g12 g13 g14 g15 g4 g12 g13 g14 g15 g5 g10 g16 g17 g17 g18 g19 g20 g17 g21 g15 g22 g23 g24 g54 g87 g68 g48 g76 g81 g72 g85 g36 g51 g44 g21 g57 g40 g38 fig.
comparison in top kapi mapping mining accuracy vector in the java vector space with d1dimensions and ciis the corresponding vector in the c space with d2dimensions.
we need to find a transformation matrix tsuch that t jiapproximates ci.
adapted from we learn the matrix twith the dimensions d2 d1by minimizing the least square errors min wn summationdisplay i t ji ci training process is done with stochastic gradient descent .
for prediction for a given api in java j we compute c t j. the api in c whose vector is closest to cvia cosine similarity will be the top result.
we produce multiple candidates with their scores using the cosine similarity measures.
for all jdk apis in its vocabulary we use the computed matrix to compute their corresponding single mappings in .net in c .
that is we have ji ci i .. v withvis the vocabulary of jdk apis.
note that our mining approach works in the other direction as we can compute the transformation matrix from c to java in the same manner.
d. accuracy comparison this section presents our experiments to evaluate api 2api s accuracy in mining api mappings between java and c .
beside the two datasets table ii to train the respective word2v ec models in java and c we also used api mapping pairs between java jdk and c .net provided by the migration tool java2csharp as the oracle.
we used part of those mappings to compute the transformation matrix.
for a test jdk api j api 2api produces a resulting list.
if the true mapping api in c .net for jis in the top kresulting list we count it a hit.
top kaccuracy is computed as the ratio between the number of hits and the total of hits and misses.
quantitative comparison we conducted an experiment to compare api 2api with the state of the art approach staminer .
staminer could mine both single api mappings as well as the mappings for the usages with multiple api elements.
for comparison with api 2api we configured staminer to mine single api mappings.
in staminer the authors showed that it performs better than the existing mining approaches such as mam aura and hima thus we do not compare with those existing tools.
we trained staminer in the same dataset used in its paper table of with pairs of respective methods in java and c in projects that have been developed in java and semi automatically ported to c .f o r api 2api we usedtable vi newl y found api mappings not in java 2cs harp benchmark java api c api java.util.hashmap.size system.collect...generic.dictionary.count java.util.list.size system.collections.generic.ilist.count java.util.map.entry.getkey system.coll...generic.keyv aluepair.key java.util.arraylist.ensurecapacity system.collections.generic.list.capacity java.sql.resultset.getshort system.data...sqldatareader.getint16 java.sql.resultset.getint system.data.....sqldatareader.getint32 java.sql.resultset.getlong system.data...sqldatareader.getint64 java.io.file.canwrite system.io.fileinfo.isreadonly java.io.inputstream.read system.io.stream.readbyte the training datasets in table ii to produce word2v ec vectors for the apis.
we configured api 2vec with the number of dimensions of vector spaces n and the window size of word2v ec model n .
for both tools we used fold cross validation on java2csharp s api mapping dataset.
as seen in fig.
api 2api achieves high accuracy.
for a given java jdk api it can correctly derive the corresponding api in c .net in .
of the time with just a single suggestion .
that is the correct corresponding .net api is on the top of the resulting list in more than half of the suggestion cases .
moreover for a given jdk api the correct corresponding api in .net is in the list of suggested .net apis in almost out of cases .
.
that is in .
of the time users just need to check a list of suggested apis to find the correct c api for a given jdk api .
this result shows that it is practical to use api 2api in helping code migration.
importantly as seen api 2api outperforms staminer about at top accuracy i.e.
.
relative improvement.
at top accuracy the relative improvement is .
.
api 2api is able to detect a large number of pairs of apis with different names.
some examples are shown in table vi.
qualitative comparison investigating further the result we reported the dis advantages of two approaches.
first staminer requires a parallel corpus of corresponding usages in two languages.
it is not always easy to collect a statistically significant number of parallel code.
second both tools have out of vocabulary issue i.e.
requiring to see the apis in the training dataset to produce their mappings.
third staminer has a stronger requirement that the mapped apis must be in respective pairs in the parallel corpus .
using transformation api 2api does not need a parallel corpus with respective api usages.
however it requires a training dataset of single api pairs.
it would be better if the training api pairs are diversely selected in multiple packages discussed in section v e1 .
fourth it needs a high volume of code to build high quality vectors.
this issue is easily mitigated due to a large wealth of open source repositories.
in this study with our easilycollected datasets table ii api 2api performs better than staminer with pairs of respective methods.
finally this result leads to a potential direction to combine two approaches.
newly found api mappings interestingly we found that api 2api correctly detected a total of new api mappings that were not manually written in the latest mapping file authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g1 g2 g3 g4 g5 g6 g3 g1 g2 g1 g3 g6 g2 g7 g3 g8 g2 g9 g3 g9 g10 g2 g3 g7 g2 g1 g3 g11 g10 g2 g3 g2 g7 g11 g3 g1 g7 g2 g3 g6 g7 g7 g3 g9 g6 g1 g3 g5 g4 g8 g4 g5 g4 g10 g4 g6 g4 g11 g4 g4 g12 g13 g14 g15 g11 g12 g13 g14 g15 g8 g12 g13 g14 g15 g1 g12 g13 g14 g15 g5 g12 g13 g14 g15 g2 g12 g13 g14 g15 g11 g4 g16 g17 g17 g18 g19 g20 g17 g21 g15 g22 g23 g24 g25 g20 g17 g26 g20 g27 g28 g29 g30 g20 g31 g28 g32 g15 g31 g28 g33 g28 g17 g34 g35 g13 g36 g37 g35 g38 g28 g19 g31 g35 g39 g35 g28 g32 g15 g31 g28 g33 g28 g17 g34 g35 g13 g36 fig.
top kaccuracy with different training data selections g31 g19 g36 g18 g2 g55 g82 g83 g3 g23 g31 g19 g36 g18 g21 g55 g82 g83 g3 g24 g31 g19 g36 g18 g22 g55 g82 g83 g3 g20 g19 g53 g88 g81 g81 g76 g81 g74 g3 g55 g76 g80 g72 g1 g2 g1 g3 g1 g4 g1 g5 g1 g6 g1 g7 g1 g8 g1 g3 g1 g4 g1 g5 g1 g6 g1 g7 g1 g8 g1 g9 g1 g10 g1 g2 g1 g2 g1 g1 g3 g1 g1 g4 g1 g1 g5 g1 g1 g6 g1 g1 g7 g1 g1 g8 g1 g1 g9 g1 g1 g10 g1 g1 g2 g1 g1 g1 g11 g12 g13 g13 g14 g13 g15 g16 g17 g14 g18 g19 g16 g20 g21 g22 g12 g23 g24 g25 g26 g27 g27 g12 g23 g28 g27 g29 g16 g20 g30 g25 g31 g14 g18 g19 g13 g24 g14 g22 g13 fig.
top kaccuracy with different numbers of dimensions in java2csharp currently we counted them as incorrect cases since those mappings are not in the java2csharp benchmark.
thus api 2api s actual accuracy is even higher .
some cases with different syntactic types and names are listed in table vi see our website for more .
those newly found mappings are correct and could be added to complement java2csharp s data file.
staminer can detect only new mappings.
e. sensitivity analysis impacts of factors on accuracy selecting different packages of api mapping pairs to train the transformation matrix as shown in section iv b the vectors for apis in the same classes packages are closer than those for other apis in different classes packages.
thus we aimed to answer the question of whether this characteristic affects the training quality of the transformation matrix and consequently affects accuracy.
we first divided our dataset of all api mappings into groups corresponding to jdk packages.
we used one group of mappings for testing and the other groups for training.
we repeated the process with every group as the testing group and accumulatively measured the top kaccuracy.
we compared this accuracy with that in which we conducted fold cross validation with the mappings in the training set being randomly selected from every package each package must have at least one pair .
as seen in fig.
randomly selecting training mappings in more diverse packages gives better accuracy than the first setting.
for top accuracy the difference is .
.
.
.
in the first setting the lack of mappings in the package used for testing really hurts accuracy.
this result implies that in addition to the large size of training data we need to have a diversity in api mappings used for training.
investigating further from the result in section iv b we found that the vectors for apis in the same classes packages or for apis sharingsimilar surrounding api elements are clustered into groups of nearby vectors.
we found that the vectors of jdk apis in the same cluster have similar arrangements as the corresponding vectors of .net apis in the respective cluster.
thus if we provide the mappings for some apis in a cluster they likely help derive other mappings in the cluster since they provide better information to learn the transformation matrix .
there are two implications from this result.
first if we want to derive the api mappings in some package we need to have in the training data the pairs of apis from that package.
second if one aims to manually build a training set of mappings s he needs to diversify the pairs in jdk packages.
varying numbers of dimensions of vector spaces the dimension nof vector space section ii is a crucial factor that could affect api 2api s accuracy.
in this experiment we configured the dimensions of the two word2v ec models for java and c apis ranging from njava nc n ... .
we performed fold cross validation on the pairs of api mappings.
we also measured running time.
fig.
shows the result.
as seen the very low dimensional vector spaces give low accuracy e.g.
.
top accuracy for n .
as we increase n accuracy increases gradually and reaches its peak across all top kaccuracy values around n .
this is reasonable since the low dimensional vector space does not fully capture the apis characteristics with regard to their surrounding apis in usages.
multiple features are compressed into same dimensions.
when nis large enough the characteristics of apis are better captured leading to higher accuracy.
however as we increase nmore n accuracy starts to decline gradually.
in this case a more complex model with larger nrequires larger training data.
as seen in fig.
training time increases significantly as n due to the significant increase in the numbers of models parameters.
to achieve both high accuracy and reasonable training time we use n hours of training as the default configuration for subsequent experiments.
time to derive a mapping for an api is a few milliseconds not shown thus api 2api is suitable to be interactively used in an ide.
varying word2vec window s sizes we varied the size of the window nof the word2v ec model and measured its impact on accuracy.
when nis small n the context is insufficient to represent each api element in api usages.
for our dataset with the window s size of apis before and apis after the current api accuracy reaches its peak not shown since the window can cover well the length of api sequences in an api usage.
when the window s size is larger running time increases much while accuracy is stable.
thus we use window s size of as a default setting.
varying sizes of training datasets for word2vec we varied the sizes of both training datasets in java and c table ii .
first we randomly selected of all the methods in java dataset and of the methods in c dataset to train the word2v ec models.
we repeated the fold cross validation as in the previous study and measured top kaccuracy.
next we increased the training data s sizes for both java and c by randomly adding more methods to reach authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g31 g19 g36 g18 g2 g3 g55 g82 g83 g3 g23 g31 g19 g36 g18 g21 g3 g55 g82 g83 g3 g24 g31 g19 g36 g18 g22 g55 g82 g83 g3 g20 g19 g45 g68 g89 g68 g3 g36 g51 g44 g3 g38 g6 g3 g36 g51 g44 g1 g2 g2 g3 g2 g2 g4 g2 g2 g5 g2 g2 g6 g2 g2 g7 g2 g2 g8 g2 g2 g9 g2 g2 g2 g9 g9 g2 g2 g9 g2 g10 g2 g1 g2 g3 g2 g4 g2 g5 g2 g6 g2 g7 g2 g8 g2 g10 g11 g4 g11 g9 g2 g11 g10 g4 g11 g4 g2 g11 g9 g2 g2 g11 g12 g13 g14 g15 g16 g17 g18 g19 g20 g18 g14 g21 g22 g22 g16 g23 g18 g24 g25 g26 g27 g24 g28 g28 g13 g17 g21 g28 g29 g18 g30 g11 g31 g32 g17 g21 g33 g34 g33 g34 g35 g18 g36 g33 g37 g16 g18 g30 g22 g16 g17 g28 g16 g34 g38 g18 g19 g20 g18 g20 g13 g39 g39 g18 g28 g19 g17 g22 g13 g27 g31 fig.
accuracy with v aried training datasets for word2v ec g1 g2 g3 g2 g4 g2 g5 g2 g6 g2 g7 g2 g8 g2 g9 g2 g8 g6 g10 g7 g1 g1 g5 g8 g3 g4 g4 g4 g3 g2 g5 g10 g6 g6 g2 g1 g6 g8 g8 g7 g7 g4 g11 g12 g12 g13 g14 g15 g12 g16 g17 g18 g19 g20 g21 g13 g22 g23 g24 g14 g17 g25 g26 g17 g27 g14 g15 g28 g29 g28 g29 g30 g17 g11 g31 g32 g17 g33 g15 g28 g14 g34 g35 g25 g33 g17 g10 g35 g25 g33 g17 g1 g35 g25 g33 g17 g3 g35 g25 g33 g17 g4 g35 g25 g33 g17 g5 g35 g25 g33 g17 g10 g2 fig.
accuracy with various numbers of training mappings and full training corpora.
as seen in fig.
as more training data added api 2api encounters more apis and usage contexts and the regularity of apis increases.
moreover as seen more mapped apis were observed we trained better the transformation matrix thus leading to higher accuracy.
varying number of mapping pairs to train the transformation matrix in this experiment we varied the size of the dataset to train the transformation matrix.
we divided all api mappings from java2csharp into equal folds.
first we chose the first fold as the testing fold .
we then used the second fold for training and measured accuracy.
next we added the third fold to the current training data consisting of the second fold and tested on the testing fold.
we repeated the process by adding more folds to the current training data until the 10thfold was used.
then we chose the second fold as the testing fold and repeated the above process.
the topkaccuracy for each size of training data was accumulatively computed over all executions for that size.
note that we do not need folds for training to run for one fold.
in fact api 2api produced mappings for all the java apis not in the training set.
as seen in fig.
as more training mappings are added top kaccuracy increases across all ks.
top accuracy increases from .
to .
when training data increases from to folds to mappings .
importantly with only of data it achieves top accuracy .
as of the mappings are used it achieves high top accuracy .
vi.
m igra ting equiv alent api u sage sequences we conducted another experiment to show a useful application of our approach.
we used api 2api s single api mappings in a phrase based machine translation tool phrasal thattable vii accuracy ingenera ting equiv alent api usage sequences projectwithin project cross project recall precision recall precision antlr .
.
.
.
db4o .
.
.
.
fpml .
.
.
.
itext .
.
.
.
jgit .
.
.
.
jts .
.
.
.
lucene .
.
.
.
neodatis .
.
.
.
poi .
.
.
.
takes a jdk api usage and produces a respective usage sequence with multiple api elements in .net .
for example given the java code in fig.
our phrasal based tool equipped with api 2api s api mappings will produce a sequence of apis in c dictionary var dictionary.new streamwriter var etc.
users will fill out the concrete variables to produce the complete code.
we did not aim to migrate complete code since it requires the mappings of all constructs in java and c .
settings and metrics.
we used the dataset oof pairs of respective methods as in the study in section v d1.
we parsed the methods to build the api sequences and used them and api 2api s single mappings to train phrasal.
we have two settings.
the first one is within project usage migration which supports the case that users partially migrated a project and our tool helps in migrating the remaining methods.
for each project we used fold cross validation on all of its methods.
we compared the resulting sequences of apis in c with the real sequences in the manually migrated c code in the dataset o. the second setting is cross project migration which supports the case that developers can use our tool to migrate the usages for a new project while using the migrated usages in the other projects for training.
in this setting we used the api sequences in the methods of a project for testing and those in the remaining projects for training.
we repeated the process for each of those projects and compared the result against the human migrated oracle o. to measure accuracy in migrating api usages we computed precision and recall of our translated sequences while also considering the orders of apis.
we computed the longest common subsequence lcs of a resulting sequence and its reference sequence in the oracle.
precision and recall values are computed as precision lcs result recall lcs reference .
they are accumulatively computed for all resulting sequences.
the higherrecall the higher coverage the migrated sequences.
recall means that the migrated sequences cover all the apis in the oracle in the right order.
the higher precision the more correct the migrated sequences.
precision means that the migrated apis are all correct and in the right order.
we also computed blue score for lexical matching .
result.
as seen in table vii the results in both settings are comparable since jdk and .net apis are very popular.
our phrasal based tool is able to migrate api sequences from java to c with high recall and precision .
specifically for a given authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sequence of jdk api elements the first resulting .net api sequence from our tool covers from .
.
out of needed .net apis and from .
.
out of generated .net api elements are in the correct order in that api sequence .
thus users just need to remove .
.
.net apis and search for additional .
apis out of elements.
blue scores n are from .
.
.
accuracy in the cross project setting is slightly higher than that in the within project one since the model observed more diverse api usages in other projects.
the improvement is not much due to a small number of projects.
vii.
t hrea ts to validity and limita tions our datasets and the randomly selected sets of api pairs might not be representative.
for api mappings we did not train and test of api mappings on the same package due to the small number of samples for each package in java2csharp oracle.
for fair comparison between models we measured invocabulary accuracy counting cases with already seen apis .
due to space limit we did not report the result from skipgram model.
cbow predicts target words from the words in their contexts while skip gram predicts context words from the target words.
we focused on cbow since it fits with our need better in characterizing an api via its surrounding elements.
we tried both and cbow gave slightly better accuracy.
api 2api has shortcomings.
first it works best with one toone mappings.
it cannot handle the cases with n to or tonmappings and the case of mappings to multiple alternative subclasses of a class.
second it needs a diverse training set of api mappings.
third to find a mapped api in c it needs to search in a large number of candidates.
finally it might not work for the pairs of libraries with much different paradigms.
viii.
r ela ted work deepapi uses recurrent neural network encoderdecoder to generate api sequences for a given text by using word embeddings and deep learning.
deepapi has a different goal as it learns the association of api sequences and annotated words to generate api sequences from texts .
we use word2v ec to capture the relations between api elements and generate c api sequences from java api sequences.
while deepapi uses a deep learning translation model between texts and api sequences we use transformation between two vector spaces to derive the api mappings between two languages.
api 2api is also related to the work by y e et al.
.
the authors used skip gram model on api and reference documents and tutorials to create embeddings for words and code elements.
semantic similarities among such documents are modeled via those embeddings.
the first key difference is that they aimed to quantify the relations between words and code elements while we focus on the relations among api elements in api usages.
thus they used documentation while we work on api sequences from source code.
finally their application is to improve text code retrieval while we support the applications involving api usages and code migration.
researchers have applied statistical nlp methods including word embeddings to software artifacts.
pam is a parameter free probabilistic algorithm to mine api patterns.
it uses aprobabilistic formulation of frequent sequence mining on api sequences.
allamanis et al.
suggest methods classes names using embeddings.
the elements with statistical cooccurrences are projected into a continuous space with the words from the names.
in comparison we use word2v ec and learn the transformation between two spaces.
their model works in the same space.
maddison and tarlow use probabilistic cfgs and neuro probabilistic language models for code .
researchers have proposed to use language models to suggest next tokens or api calls .
allamanis et al.
use bimodal modeling for short texts and source code snippets.
they use traditional probabilistic model and we use word2v ec for learning api embeddings.
na turalize suggests natural identifier names and formatting conventions.
api 2api is inspired from a work by mikolov et al.
where similar geometric arrangements were observed in english and spanish words for numbers and animals.
anycode uses a probabilistic cfg for java constructs to synthesize java expressions.
swim synthesizes code by using ibm model to produce code elements and then uses n gram for synthesis.
peng et al.
propose a deep learning model to learn vector representations for tree based source code.
mou et al.
introduce convolutional neural networks over tree structures.
we could use those models in place of word2v ec in api 2api.
to mine api mappings mam uses api transformation graphs and compares apis via similar names and calling structures.
hima and aura use call dependency and text similarity to identify change rules.
rosetta needs pairs of functionally equivalent applications.
our work staminer mines api mappings by maximizing the likelihoods of observing the mappings between api pairs from a parallel corpus of client code.
the resulting api mappings are useful for rule based migration tools .
our prior work slamc provides a code representation for our phrase based smt models in mppsmt and semsmt .
phrase based smt was enhanced with grammar structures .
smt is used to create pseudo code .
early work on api 2api was in a poster .
ix.
c onclusion we have shown that word2v ec for apis can capture the regularities of the relations of apis in api usages.
we demonstrate its usefulness in applications.
we build a tool to mine the pairs of api elements that share the same usage relations among them.
we also propose an approach to automatically mine api mappings by learning the transformation between the two vector spaces of apis in the source and target languages.
our experiment shows that for just one suggestion our approach is able to achieve high precision and recall.
in the final application we build a migration tool that migrate api usages between java and c and show its high accuracy.
x. a cknowledgments this work was supported in part by the us national science foundation nsf grants ccf ccf twc1723198 ccf and cns .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.