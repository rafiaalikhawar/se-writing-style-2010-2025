search driven string constraint solving for vulnerability detection julian thom e lwin khin shar domenico bianculli lionel briand snt centre university of luxembourg email julian.thome uni.lu lwinkhin.shar uni.lu domenico.bianculli uni.lu lionel.briand uni.lu abstract constraint solving is an essential technique for detecting vulnerabilities in programs since it can reason about input sanitization and validation operations performed on user inputs.
however real world programs typically contain complex string operations that challenge vulnerability detection.
state ofthe art string constraint solvers support only a limited set of string operations and fail when they encounter an unsupported one this leads to limited effectiveness in finding vulnerabilities.
in this paper we propose a search driven constraint solving technique that complements the support for complex string operations provided by any existing string constraint solver .
our technique uses a hybrid constraint solving procedure based on the ant colony optimization meta heuristic.
the idea is to execute it as a fallback mechanism only when a solver encounters a constraint containing an operation that it does not support.
we have implemented the proposed search driven constraint solving technique in the aco solver tool which we have evaluated in the context of injection and xss vulnerability detection for java web applications.
we have assessed the benefits and costs of combining the proposed technique with two state ofthe art constraint solvers z3 str2 and cvc4 .
the experimental results based on a benchmark with constraints derived from nine realistic web applications show that our approach when combined in a state of the art solver significantly improves the number of detected vulnerabilities from .
to .
for z3str2 from .
to .
for cvc4 and solves several cases on which the solver fails when used stand alone more solved cases for z3 str2 and more for cvc4 while still keeping the execution time affordable in practice.
keywords vulnerability detection string constraint solving search based software engineering i. i ntroduction malicious users can attack web applications by providing in input properly crafted strings that can exploit vulnerabilities in source code a successful attack may lead to leaking sensitive user data or to a denial of service.
according to the open web application security project owasp two of the most critical types of vulnerability are injection ranked and xss cross site scripting ranked vulnerabilities.
both types of vulnerability are caused by the improper use of user input strings in security sensitive program statements often these strings are not property validated or sanitized.
state of the art approaches for identifying these types of vulnerability are based on symbolic execution and constraint solving.
roughly speaking these approaches consist of solving the constraints corresponding to the attack condition obtained by conjoining the path conditions generated by the symbolic execution with attack specifications providedby security experts.
if the solver yields sat showing the satisfiability of the attack condition it means that the attack is feasible and that the analyzed path is vulnerable to the attack.
the main strength of this approach is that vulnerability detection yields a limited number of false positives since the concrete inputs determined with constraint solving prove the existence of vulnerabilities.
however the effectiveness and precision of these approaches are challenged by the degree of support for complex string operations provided by the constraint solver itself .
state of the art solvers such as kaluza stranger cvc4 s3 and z3 str2 support only a limited number of strings operations such as concatenation assignment and equality more complex operations like string replacement or standard sanitization functions are not supported or only partially supported.
existing solvers could be extended to provide native support for complex string operations but the task is non trivial and not scalable to the size of a complete string function library of a modern programming language or of sanitization libraries like owasp esapi and apache commons lang for example the classes string stringbuffer stringbuilder from the java standard library and the classes stringutils stringescapeutils from the apache commons lang library contain a total of methods.
alternatively complex string operations could be transformed into a set of equivalent constraints with only operations natively supported by the solver however such a solution would increase the complexity of the generated constraints potentially leading to scalability issues .
in practice existing solvers fail i.e.
they crash or return an error when they encounter an unsupported operation in the context of vulnerability detection this behavior could yield false negatives i.e.
it misses some vulnerabilities when the attack conditions are actually feasible.
in the context of vulnerability detection the goal of this paper is to address the challenge of supporting complex operations in string constraint solvers by proposing a searchdriven constraint solving technique that complements them.
we intentionally target a solution that does not rely on any assumption regarding the selected constraint solver and that can therefore be widely used in the future.
the idea is to solve the constraints in an attack condition through a two stage process.
in the first stage we take any constraint solver and use it to solve the constraints that contain ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
only operations supported by the solver itself.
the remaining unsolved constraints which contain operations not supported by the solver are handled in the second stage by means of a hybrid constraint solving procedure.
we treat the solver in the first stage as a black box and only assume that it terminates its execution either by failing when it encounters a constraint containing an operation that it does not support or by returning an answer which can be either unsat or sat and a solution .
the hybrid solving procedure in the second stage is executed only when the solver in the first stage fails.
in the second stage we solve the constraints containing unsupported operations by means of a hybrid searchdriven procedure that leverages the ant colony optimization meta heuristic .
this procedure searches for a solution that satisfies the constraints involving unsupported operations the search is driven by different fitness functions depending on the type of the constraints.
we call this procedure hybrid because we reduce its search space before running the search itself to make the latter scalable.
we perform the search space reduction by restricting the domains of the string variables involved in the constraints to solve.
to do so in our current strategy and given the state of the art we rely on an automatabased string constraint solver sushi .
we have implemented the proposed search driven constraint solving technique in a tool called aco solver .
we have evaluated the proposed technique in the context of injection and xss vulnerability detection for java web applications.
more specifically we have assessed the benefits and costs of combining the proposed technique with two state of theart string constraint solvers z3 str2 and cvc4 on a benchmark with constraints derived from nine realistic web applications.
the experimental results show that the proposed approach when combined with a state of the art solver significantly improves the number of detected vulnerabilities from .
to .
for z3 str2 from .
to .
forcvc4 and solves several cases on which the solver fails when used stand alone more solved cases for z3 str2 and more for cvc4 both benefits can be obtained while still keeping the execution time reasonable in the order of minutes.
furthermore we have also assessed the role played by the automata based solver in the search space reduction step that precedes the meta heuristic search the results confirm that it contributes to increasing the number of solved cases.
the overall results confirm that our search driven approach for string constraint solving when combined with existing solvers adds significant benefits in terms of cases that are solved while keeping the cost in terms of computation time affordable in practice.
we remark that these results should be interpreted in the specific context of vulnerability detection and cannot and do not aim to be extrapolated to the more general case of string constraint solving.
in summary the main contributions of this paper are a search driven technique for solving string constraints with complex string operations in the context of vulnerability detection the empirical assessment of the benefits and costs of adding the proposed technique to two state of the art stringconstraint solvers evaluated in the context of injection and xss vulnerability detection for java web applications.
the rest of this paper is structured as follows.
section ii provides some background on the concepts and techniques used in the rest of the paper.
section iii discusses the motivations for this work and illustrates a running example.
section iv illustrates our search driven approach for string constraints solving.
section v presents the evaluation of our approach.
section vi discusses related work.
section vii concludes the paper and gives directions for future work.
ii.
p reliminaries a. automata based string constraint solving in this paper we focus on string constraints i.e.
constraints on string variables that can be involved in stringmanipulating functions.
an example of such a constraint is id.contains ul where idis a string variable and contains ... is a string manipulating function from the java class library.
a solution for this constraint is a string value for variable idthat satisfies the constraint for example the string module is a solution for the above constraint.
one of the ways to solve string constraints is to consider their automata based representation .
more precisely an automata based string constraint solver uses finitestate machines fsm to encode the set of string values that a string variable can take.
string operations are modeled through automata operations such as concatenation and intersection.
if the constraint is satisfiable the solver returns sat and yields a solution automaton for each string variable this automaton accepts string values that satisfy the constraint in which the variable is involved.
for example an automata based constraint solver that supports among others the contains operation will solve the constraint above and will return for variable idthe fsm mid .
ul.
i.e.
the automaton that accepts string values containing the ulsubstring.
notice that we abuse the notation by defining an fsm by means of the regular expression characterizing the regular language it accepts.
b. ant colony optimization ant colony optimization aco is one of the most widely used meta heuristic search techniques for solving combinatorial optimization problems.
it is inspired by the observation of the behavior of real ants searching for food.
real ants start seeking food randomly when they find a source of food they leave a chemical substance called pheromone along the path that goes from the food source back to the colony.
other ants can detect the presence of this substance and are likely to follow the same path.
this path populated by many ants is called pheromone trail and serves as a guidance e.g.
positive feedback for the other ants.
in aco these observations are translated into the world of artificial ants which can cooperate to find a good solution to a given optimization problem.
the optimization problem is translated into the problem of finding the best path on a weighted graph.
artificial pheromone trails are numerical parameters authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that characterize the graph components i.e.
nodes and edges they encode the history in approaching the problem and finding its solutions by the whole ant colony.
aco algorithms also implement a mechanism inspired by real pheromone evaporation to modify the pheromone information over time so that ants can forget the search history and start exploring new search directions.
the artificial ants build their solutions by moving step by step along the graph at each step they make a stochastic decision based on the pheromone trail.
iii.
m otiv ations and running example in this section we present a motivating example that highlights the need to handle complex string constraints in the context of vulnerability detection based on constraint solving.
we will also use it as a running example in the rest of the paper.
although we crafted this example for illustrative purposes it can be considered realistic since it contains typical operations that are commonly found in modern web applications.
the program shown in figure contains a securitysensitive operation i.e.
a sink at line which corresponds to an xpath injection xpathi vulnerability within an xpath query.
it is vulnerable to xpathi because the variable sid containing a user input is not sanitized properly before using it in the xpath query.
indeed the standard sanitization procedure esapi.
encoder .encodeforxpath from owasp applied to variable sid only escapes meta characters such as and .
assuming that the element sid is defined as a numeric data type in the schema of the document students.xml one could still perform a successful attack without using those meta characters for example using the input 0o r1 .
this vulnerability can be discovered by using the following threestep vulnerability detection procedure path conditions generation through symbolic execution .
one of the path conditions generated by symbolically executing a path leading to the execution of the sink at line is pc18 subj .trim .substring .equals cd integer.parseint max op.trim .equalsignorecase gradequery sid.tolowercase .length integer.parseint max sid.contains id where subj max op sid are symbolic values for the variables initialized with the web request inputs lines .
definition of the attack specification .
in this step the values at the sink are checked against an attack specification defined by a security expert usually by means of threat catalogues and attack libraries .
attack specifications are defined in a way that properly characterizes security threats.
for example the following specification characterizes a security threat in the form of a tautology attack for variable sid attk esapi.encoder .encodeforxpath sid.
tolowercase .matches o o r r 1protected void dopost httpservletrequest req httpservletresponse res document doc getstudentdb .
students.xml xpath xpath xpathfactory.newinstance .newxpath string op req.getparameter option string sid req.getparameter id int max integer.parseint req.getparameter max string subj req.getparameter subjid sid sid.tolowercase if !subj.trim .substring .equals cd subj if max max if op.trim .equalsignorecase gradequery if sid.length max sid.contains id sid esapi.encoder .encodeforxpath sid subj subj.replaceall string query students grade sid sid and subjid subj mark nodelist nl nodelist xpath.evaluate query doc figure a java servlet program vulnerable to xpathi where esapi.encodeforxpath sid.tolowercase is the symbolic expression over the symbolic value sid representing the values of variable sidat the sink.
the expression matches o o r r describes a tautology attack pattern.
constraint solving .
the third step requires to solve the attack condition defined as the constraint obtained by conjoining the path condition with the attack specification this step is performed using a constraint solver.
if the solver yields sat showing the satisfiability of the constraint it means that the attack is feasible and that the analyzed path is vulnerable to the attack.
in the example the attack condition ac1 pc18 attk is satisfiable confirming the presence of the vulnerability.
this procedure assumes that the constraint solver is able to handle string operations like trim tolowercase parseint equalsignorecase length replaceall and encodeforxpath .
however state of the art solvers such as kaluza cvc4 s3 and z3 str2 do not support at least one of these complex operations.
from a more general standpoint the major challenge faced when adopting a vulnerability detection procedure based on constraint solving is the degree of support for complex string operations provided by the constraint solver itself .
one way to face this challenge is to modify or enhance an existing solver in order to provide native support for complex string operations.
however this task is non trivial and requires a deep understanding of string manipulating functions and constraint solving moreover it is not scalable to the size of a sanitization library like owasp esapi or of a complete string function library of a modern programming language.
alternatively instead of modifying the solver one could reexpress complex operations with their equivalent set of basic constraints that can be solved by the solver.
although relatively easier this alternative still requires significant effort and expertise and usually results in complex constraints that may still lead to scalability issues for constraint solvers .
for example consider one of the constraints in the above path condition op.trim .equalsignorecase gradequery as199 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
external solverconstraints with unsupported operations solutions of constraints with supported operationsautomata based constraint solver search based constraint solversat unsat timeoutattack condition figure two stage approach for string constraint solving suming the solver handles only length charat equals andsubstring one could re express this constraint as c1 c2 c1 c2 op.length such that op.substring c1 c2 .equals gradequery ...equals gradequery ... op.substring c1 c2 .equals gradequery i i c1 op.charat i j c2 j op.length op.charat j which uses equivalent constraints for equalsignorecase andtrim .
notice how the equalsignorecase operation is expanded into a disjunction of constraints with the equals operation which cover all the possible combinations of the characters denoting a case insensitive representation of the string gradequery also modeling the trim operation requires to add several auxiliary variables and predicates.
to work around this issue the current solution in practice is to have the constraint solver fail i.e.
it crashes or returns an error when it encounters an unsupported operation.
our experiments show that this is the case for state of the art solvers like cvc4 and z3 str2 .
however in the context of vulnerability detection such a behavior could yield false negatives i.e.
it misses some vulnerabilities when the attack conditions are actually feasible.
hence the challenge discussed above shows that in the context of vulnerability detection there is the need for scalable and precise techniques for constraint solving that can handle constraints with complex string operations.
iv .
s earch driven string constraint solving we address the challenge of supporting complex operations in string constraint solvers in the context of vulnerability detection by proposing a search driven constraint solving technique that complements their support for complex string operations.
the idea illustrated in figure is to solve the constraints corresponding to an attack condition acthrough a two stage process.
in the first stage we take any existing constraint solver and use it to solve the conjuncts in acthat contain only operations supported by the solver itself.
the remaining conjuncts in ac which contain unsupported operations are solved in the second stage by means of a hybrid constraint solving procedure that combines an automata based solver with a search driven solving procedure based on the ant colony optimization meta heuristic.
function cstrsolve attackcondition ac set of solution sol boolean externalsolved false set of set of constraint h getdependent setsofcstrs ac for all hi hdo angbracketleftexternalsolved sol angbracketright external solve hi if externalsolved then angbracketlefth prime i sol angbracketright automata solve hi ifh prime i negationslash then sol search solve h prime i sol ifsol then return timeout end if end if end if end for return angbracketleftsat sol angbracketright end function figure search driven string constraint solving algorithm the meta heuristic search in the second stage tries to find solutions for the variables involved in conjuncts of acthat contain operations that neither the solver in the first stage nor the automata based solver in the first step of the second stage supports.
nevertheless we invoke the automata based solver before the meta heuristic search in order to reduce the search space of the latter.
we specifically use an automatabased vs. bit vector based or word based constraint solver because it returns when successful a solution automaton for each variable occurring in the constraints it could solve based on the operations it supports.
this automaton accepts the language corresponding to the set of values for the variable that satisfy the constraints involving the operations that the solver supports.
in this way we are able to reduce possibly in a significant way the size of the domains of the variables involved in the constraint this is expected to make the search more scalable and effective.
a. overview the pseudocode of our string constraint solving algorithm is shown in figure .
it takes in input an attack condition ac expressed as a conjunction of constraints and returns whether it is satisfiable unsatisfiable or whether it timed out when it returns satisfiable it also returns the set of solutions found.
first it decomposes line the attack condition ac into the set hof sets of dependent constraints.
more specifically function getdependent setsofcstrs identifies the connected sub hypergraphs i.e.
the maximal connected components of the hypergraph equivalent to the constraint network representing the attack condition each set hi hcorresponds to a sub hypergraph.
for the attack condition ac 1in our running example we have h h1 h2 h3 with h1 cstr h2 cstr h3 cstr cstr cstr cstr where cstr subj .trim .substring .equals cd cstr op.trim .equalsignorecase gradequery cstr sid.tolowercase .length integer.parseint max cstr integer.parseint max cstr sid.contains id cstr esapi.encoder .encodeforxpath sid.tolowercase .matches o o r r authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
next the algorithm iterates through the sets of constraints hi inh performing the following steps lines .
first it calls function external solve line which invokes the external solver and returns a tuple angbracketleftexternalsolved sol angbracketright.
if the external solver supports all the operations used in the constraints contained in hi it will return a true value for the flag externalsolved and the set solwill contain a solution for each variable involved in the constraints in hi the algorithm can then proceed to the next iteration of the loop to process the set hi i. otherwise in case the external solver does not support an operation used in a constraint in hi it will fail and external solve will set the flag externalsolved to false and solto the empty set.
when the flag externalsolved is false the algorithm enters the second stage of our approach.
it calls function automata solve line which internally invokes the automata based string constraint solver sushi to solve the constraints in hithat use operations it supports i.e.
concat contains equals trim substring replace replaceall and matches .
if a constraint is satisfiable sushi yields a solution automaton for each string variable involved in the constraint.
function automata solve returns a tuple angbracketlefth prime i sol angbracketright.
the set h prime i hicontains the constraints in hithat could not be solved bysushi because they use unsupported operations.
the set solcontains the solution automata for the variables involved in the constraints in hi if a variable was involved only in constraints with unsupported operations its corresponding solution automaton is the default one accepting any string i.e.
the automaton accepting the regular language .
otherwise the solution automaton is the one determined by sushi .
notice that both external solve and automata solve internally terminate the entire constraint solving procedure and return unsat without proceeding to the following steps when they detect unsatisfiable constraints.
subsequently if the set h prime iis not empty meaning that there are unsolved constraints in hiusing unsupported operations the algorithm invokes the search solve function which implements a meta heuristic search algorithm detailed in the next subsection to solve the constraints in h prime iand returns an updated set of solutions sol line .
if the set solis not empty it means that the set of constraints hihas been solved and the algorithm can proceed to process the set hi i otherwise it means that the search solve function timed out and thus the algorithm returns timeout terminating the entire constraint solving procedure.
a time out can indicate either that a solution exists for the constraint but the solver could not find it or that the constraint is actually unsatisfiable the security analyst then has to decide possibly based on empirical studies how to treat it.
the algorithm returns sat and the set of solutions sol line only when the loop over hhas been completely executed meaning that all the constraints in the sets in hare satisfiable which is equivalent to say that the attack condition acin input is satisfiable.
for our running example the call to external solve with input h1will return angbracketlefttrue subj cd angbracketright mean ing that the external solver was able to solve the constraint determining the solution cd for variable subj .
however the call to external solve with input h2and h3will return angbracketleftfalse angbracketrightbecause the external solver cannot handle some of the operations used in the constraints inh2and h3 e.g.
the operations equalsignorecase encodeforxpath .
this means that the constraints in h2 and h3will be processed in the second stage.
in particular the calls to automata solve will behave as follows.
automata solve h2 angbracketleft cstr mop angbracketright with mop .
meaning that cstr 2could not be solved by sushi because it contains an unsupported operation .
automata solve h3 angbracketleft cstr cstr cstr msid mmax angbracketright where msid .
id.
and mmax .
meaning that sushi could only solve cstr and determine a solution automaton for variable sid.
b. solving constraints using meta heuristic search in this subsection we illustrate how function search solve works by explaining how we use meta heuristic search for solving string constraints that involve unsupported operations1.
our search procedure is based on the max min ant system proposed in .
in this algorithm the pheromone values are bounded by maximum and minimum values which are dynamically computed after every search iteration.
this avoids the relative differences between the pheromone values from becoming too extreme during the run of the algorithm and therefore mitigates the search stagnation problem in which ants traverse the same trails and construct the same solutions over and over again.
we chose aco over other well known meta heuristic search techniques such as hill climbing simulated annealing and genetic algorithms because it has inherent parallelism in which multiple candidate solutions can be searched in parallel for efficiency.
it is stochastic in nature which allows for escaping from local optima.
it is typically used for finding good solutions i.e.
paths that return good fitness values in graphs .
hence it can be easily adapted to our problem where the search space is defined in a graph form i.e.
an automaton.
differently from other search algorithms in aco modifying a candidate solution to get a different one is straightforward since it only requires having an ant exploring the solution automaton.
below we first present the fitness functions used within the algorithm and then the algorithm itself.
fitness functions any search based procedure requires defining one or more fitness functions to assess the quality of the potential solutions i.e.
their distance from the best solution.
a low er value for the fitness of a solution implies a high er quality for the solution itself.
since in the context 1in our implementation based on sushi function search solve is also used to solve numeric constraints which are also unsupported by sushi .
nevertheless we expect that most of the numeric constraints are already solved by the external solver in the first stage.
integrating a separate numeric constraint solver before the meta heuristic search is part of future work.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of this work we deal with both numeric and string constraints we use fitness functions specific to these domains.
for numeric constraints we use the korel function which is a standard fitness function for this domain.
we consider numeric constraints of the form c e1 trianglelefte2 where triangleleft negationslash and e1 e2are numeric expressions that can be numeric variables numeric constants or any other expression whose evaluation results in a numeric value e.g.
the length operation for strings notice that we treat boolean expressions also as numeric expressions.
let s be the vector of candidate solutions for the numeric variables x1 ... xninc and a s b s be the numeric values resulting from the evaluations of e1and e2 respectively after replacing the variables in them with the corresponding solutions in s the fitness of sis defined as f s braceleftbigg a s triangleleftb s is true a s b s ka s triangleleftb s is false where k when triangleleft and k otherwise.
for string constraints we use two different functions depending on the operations in which string variables are involved the levenshtein edit distance function and the equality cost function for regular expression matching both functions have been shown to be useful for search based generation of string values .
the levenshtein distance between two strings aand bis defined as the minimum number of insert delete and substitute operations of characters needed to convert ainto b. the regular expression matching function between a string aand a regular expression bis defined as the minimum levenshtein distance among aand the strings belonging to the regular language defined by b. we consider string constraints of the form c e1 trianglelefte2 where triangleleftis a string operation returning a boolean result and e1 e2are string expressions that can be string variables string literals or any other expression whose evaluation results in a string value e.g.
the concat operation for two strings .
let s be the vector of candidate solutions for the string variables x1 ... xninc and a s b s be the string values resulting from the evaluations of e1and e2 respectively after replacing the variables in them with the corresponding solutions in s the fitness of sis defined as f s braceleftbigg a s triangleleftb s is true a s b s a s triangleleftb s is false where is the equality cost function for regular expression matching when triangleleftis a regular expression based string matching operation e.g.
the matches operation for strings in java and is the levenshtein distance in all other cases for triangleleft.
we assume to have a list of operations classified as regular expression based string matching operations if there is an unknown regular expression based matching operation it will be treated as a generic case using the levenshtein distance function.
for both types of constraints the fitness of a candidate solution is set to an arbitrarily selected large value such as when the solution leads to an exception during the evaluation of the expressions in which it is used.
function search solve set of constraint h set of solution automaton k tuning parameters angbracketleft max min angbracketright settuning params population size a setnumber ants set of desirability value setdesirability val k set of pheromone setpheromones k set of solution component tbest fitness fbest fitness fpbest array of fitness tempf array of set of solution component tempt repeat loop atimes set of solution component t construct solutions k fitness f compute fitness t h tempf append tempf f tempt append tempt t end loop angbracketleftfbest tbest angbracketright best solution tempf tempt iffbest fpbest then angbracketleftfbest tbest angbracketright 2optlocal search k tbest end if update pheromones k fbest tbest fpbest fbest until fbest or timeout iftimeout then return end if return tbest end function function construct solutions set of solution automaton k set of desirability value set of pheromone set of solution component s repeat automaton k random select k fsmstate v getstart state k repeat set of fsmtransition e getouttransitions v fsmtransition e select transition e s s e v getnextstate e until isaccept state v mark asvisited k k until all the automata in khave been traversed return s end function figure ant colony search for string constraint solving search algorithm the pseudocode of our instantiation of the aco meta heuristic for solving string constraints is shown in figure .
the main function search solve takes in input a set of constraints h corresponding to the constraints not solved by the automata based solver in the first step and a set of solution automata k as determined by the automatabased solver for the solution of the constraints with supported operations .
the first steps of function search solve lines initialize the tuning and search parameters as follows the initialization value is indicated next to each parameter tuning parameters and determine the relative importance of the pheromone trail and the heuristicbased desirability information .
is the evaporation rate used to prevent the pheromone values from piling up max and min determine the bounds of pheromone values.
search parameters the number of ants a the set of desirability values e for each transition eof each automaton in k the set of pheromone values e maxfor each transition eof each automaton in k. in aco these parameters have to be defined specifically for the target problem we chose them based on the guidelines provided in and on our own preliminary experiments.
notice that for each transition e the parameter eis initialized authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to the value max as discussed in this allows for diverse explorations of the solutions during the first iterations of the algorithm because of the small relative differences between the pheromone values of the explored transitions and of the ones not yet explored.
the algorithm then loops through the following three main steps lines until the termination conditions are met construction of solutions.
this step lines consists of three sub steps building the set of solution components .
this step is represented by the call to function construct solutions which takes in input the set of solution automata k the set of desirability values and the set of pheromones values .
this function goes through lines the set of automata k and at each iteration it randomly selects an automaton k k. starting from the start state of k it traverses the outgoing transitions of the states in k. upon reaching a state where there are multiple outgoing transitions it selects line one of them say transition e based on the probability pe e e t e t t computed using the pheromone value eand the desirability e of the transition.
the selected transition is added to the local set of solution components s line and its reaching state is retrieved line .
the traversal selection of the transitions of an automaton is repeated until the final state is found2 which means that a solution for the variable associated with the current automaton khas been found.
in this case the outer loop moves to explore the next automaton in k and continues until all automata in khave been traversed.
at the end the function returns a set of solution components with one solution for each string variable.
determining the fitness of solution components.
this step computes the fitness for the solution components identified in the previous step.
function compute fitness evaluates each constraint in hwith the solution components and computes the corresponding fitness fusing one of the aforementioned fitness functions depending on the type of constraint .
to ensure that the search process is not biased towards solving the constraints with larger scale fitness values each fitness value fis normalized using the normalization function proposed in resulting in a normalized fitness value f f f .
we use this normalization function since it has proven to be useful in the similar domain of search based test input generation of string data types .
after computing the fitness for all the constraints in h the overall fitness foft is computed by taking the average of individual normalized fitness values f. selecting the best solution components.
the two steps above are repeated atimes with the values computed at each iteration stored as elements of the auxiliary variables tempt an array containing sets of solution components and tempf a n array containing the fitness values for the corresponding elements in tempt .
function best solution determines among them the solution components that have the minimum i.e.
2internally we represent solution automata as generalized non deterministic finite automata which have only one final state.best fitness and assign them to variable tbest representing the best solution of the current iteration of the outer loop.
application of local search.
this step lines is used to refine the set of candidate solutions built in the step above to locally optimize them.
more precisely if the best solution of the current iteration tbest is better than i.e.
its fitness is lower than the fitness of the best solution of the previous iteration we perform a local search procedure to see whether further improvements can be made with other solutions that are in the neighborhood of tbest.
the local search is performed using the opt local search algorithm which finds other paths or sets of solution components in each automaton in kthat reach the final state.
this algorithm replaces at most two transitions of the current path with one or more transitions if it finds a set of solution components with a better fitness value this set becomes the new tbest.
update of pheromone values.
this step line updates the pheromone values e for each transition eof each automaton in k. it first computes max 1 fbestand min max 2n where ndenotes the cumulative total number of states of all the automata in k then it sets e e triangle e where triangle e fbestif the transition eis part of the solution components in tbest otherwise.
if e max then it sets e max dually if e min then it sets e min.
the termination conditions of the loop at line correspond either to a time out or to the finding of a solution that satisfies all the constraints in h for which the fitness fbestis zero.
if there is a timeout the function returns an empty set of solutions otherwise it returns tbest.
v. e v aluation we have implemented our search driven string constraint solving approach for vulnerability detection in the aco solver tool .
the tool is implemented in java uses sushi as automata based constraint solver in the second stage and has a plugin architecture to support different solvers in the first stage we have developed plugins for cvc4 and z3 str2 .
in this section we report on the evaluation of aco solver in the context of vulnerability detection for java web applications.
we assess the benefits and costs of combining the proposed string constraint solving approach with two state ofthe art solvers by answering the following research questions rq1 how does the proposed approach improve the effectiveness of state of the art solvers for solving constraints related to vulnerability detection?
subsection v b rq2 is the cost in terms of execution time overhead of using our technique affordable in practice?
subsection v b rq3 does the automata based solver in the first step of the second stage of our approach contribute to the effectiveness of the search based procedure?
subsection v c a. benchmark and evaluation settings to evaluate our approach in terms of vulnerability detection capability we use a benchmark composed of nine realistic open source java web applications services with known xss authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
xml xpath ldap and sql injection vulnerabilities.
webgoat is a deliberately in secured web application service for the purpose of teaching security vulnerabilities in web applications.
roller and pebble are blogging applications that also expose web service apis.
webgoat roller and pebble have been already used as benchmarks in the vulnerability detection literature .
regain is a search engine known to be used in a production grade system by one of the biggest drugstore chains in europe.
the pubsubhubbub java shortened as psh tool is the most popular java project related to the pubsubhubbub protocol in the google code archive.
the rest auth proxy shortened as rap microservice is one of the most popular ldapbased web service java projects returned by a query on github.com with the search string ldap rest .tpc app tpc c and tpc w are the standard benchmarks provided by for evaluating vulnerability detection tools for web services the set of web services they provide has been accepted as representative of real environments by the transactions processing performance council this benchmark contains in total paths to sinks vulnerable paths and non vulnerable ones.
we generated the corresponding attack conditions using a java program slicing and symbolic execution tool developed in our previous work .
for each attack condition we established the ground truth i.e.
whether it is vulnerable or not via manual inspection and consultation of the vulnerability report of the corresponding application in the us national vulnerability database nvd .
we conducted our evaluation on a machine equipped with an intel core i7 .
ghz processor gb memory running apple mac os x .
and sushi v2.
.
we set the time out for solving each attack condition to s. b. effectiveness and cost of vulnerability detection we assess the benefits and costs of combining the proposed approach with two state of the art string constraint solvers cvc4 version .
and z3 str2 from the repository head commit 2e52601 .
for each of these solvers we run our benchmark first through the standalone solver and then through the solver combined with aco solver .
the evaluation results are shown in table i. columns vp and nvpindicate respectively the number of vulnerable and non vulnerable paths per application.
column tindicates the cumulative time taken to solve all the attack conditions of each application.
column indicates the number of failing cases i.e.
the number of attack conditions that the solver failed to solve due to an error or crashing we omit this column for z3 str2 aco solver and cvc4 aco solver since they did not fail.
column circledivideindicates the number of cases in which the solver timed out we omit this column for z3 str2 and cvc4 since they did not time out.
column check indicates the number of non failing cases.
column indicates the number of cases out of the failing cases of z3 str2 or cvc4 that aco solver helped solve.
columns tp tn fp fn and denote respectively true positives number ofvulnerable cases correctly identified true negatives number of non vulnerable cases correctly identified false positives number of non vulnerable cases reported as vulnerable false negatives number of vulnerable cases not detected number of additional vulnerable cases uncovered by aco solver .
column pdreports the recall i.e.
the percentage of vulnerable cases detected among the total vulnerable cases and is computed aspd tp tp fn .
notice that in the context of vulnerability detection when a solver fails or times out to solve an attack condition it neither detects a vulnerability nor produces a false alarm.
hence a failing or time out case may result either in a false negative or in a true negative depending on whether the attack condition is actually vulnerable.
we answer rq1 by examining the number of failing and time out cases and the recall in table i first when using a solver standalone and then when combined with aco solver .
when used standalone z3 str2 and cvc4 could not solve respectively and cases.
we manually inspected these failing cases and observed they are due to unsupported operations contained in the attack conditions.
for example both z3 str2 and cvc4 do not handle some string operations e.g.
tolowercase touppercase equalsignorecase and the sanitization operations of the standard apache security library .
also z3 str2 was not able to handle integer.parseint and string.valueof conversions and many of the regular expressions that reflect security threats in our attack conditions.
z3 str2 missed vulnerable cases out of failing cases resulting in a low recall of .
.
cvc4 missed vulnerable cases out of failing cases resulting in a recall of .
.
z3 str2 aco solver helped solve out of the failing cases of z3 str2 revealing additional vulnerabilities.
it timed out on cases however out of these time out cases are non vulnerable cases i.e.
the corresponding attack condition is unsat and thus the search is obviously expected to time out.
cvc4 aco solver solved failing cases of cvc4 revealing additional vulnerabilities.
it timed out on cases however all of them are actually non vulnerable ones.
z3 str2 aco solver improved the recall of z3 str2 from .
to .
.
cvc4 aco solver improved the one ofcvc4 from .
to .
detecting all vulnerabilities.
we remark that while most of these vulnerabilities had already been reported to the nvd we also discovered two new xss vulnerabilities one in regain and one in pebble while performing this evaluation we reported them to nvd and also to the corresponding developers.
the vulnerability inregain was detected by both z3 str2 and cvc4 used standalone the one in pebble was detected when both solvers were combined with aco solver .
though not shown in table i for space reasons we also remark that both solvers achieved precision i.e.
they reported no false positive .
the answer to rq1 is that the proposed approach when combined with a state of the art solver significantly improves the recall from .
to .
for z3 str2 from .
to .
for cvc4 and solves several cases on which the solvers failed when used stand alone more solved cases authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i comparison of vulnerability detection effectiveness and execution time between standalone solvers z3 str2 and cvc4 and the same solvers combined with aco solver z3 str2 aco solver and cvc4 aco solver app paths z3 str2 z3 str2 aco solver cvc4 cvc4 aco solver vp nvp t s checktp tn fp fn pd t s circledivide check tp tn fp fn pd t s check tp tn fp fn pd t s circledivide check tp tn fp fn pd webgoat .
.
.
.
.
.
.
.
roller .
.
.
.
.
.
.
.
pebble .
.
.
.
.
.
.
.
regain .
.
.
.
.
.
.
.
psh .
.
.
.
.
.
.
.
rap .
.
.
.
.
.
.
.
tpc app .
.
.
.
.
.
.
.
tpc c .
.
.
.
.
.
.
.
tpc w .
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
for z3 str2 and more for cvc4 .
hence combining a state of the art solver with our approach proved to be very effective to vulnerability detection.
since time outs with cvc4 aco solver are all unsatisfiable non vulnerable cases if such results were to be confirmed by additional benchmarks then one could conclude that the most cost effective and realistic decision strategy for the security analyst would be to treat time outs as non vulnerable cases.
to answer rq2 we compare the execution time t for running the standalone solvers to the one for running the solvers combined with aco solver .
the total execution of z3str2 took less than two minutes and solved cases z3 str2 aco solver took about minutes and solved cases the execution of cvc4 took about five seconds and solved cases cvc4 aco solver took about minutes and solved cases.
despite the increase in terms of absolute values the total execution time of our approach is still affordable considering that it can handle many cases that would otherwise fail and thus can detect more vulnerabilities vulnerability detection is typically an offline activity with no real time requirements.
hence we answer rq2 positively.
c. the role of the automata based solver to address rq3 and thus investigate the role played by the automata based solver in reducing the search space explored by the meta heuristic search we used a modified implementation of our approach.
we switched off the automata based solver in the first step of the second stage meaning that the search based algorithm is executed using a set of solution automata that accept any string and thus has a much larger search space.
we run our benchmark through both solvers combined with this modified version of aco solver which does not call sushi internally.
because of space reasons we present only the results of running cvc4 combined with this modified acosolver the results for z3 str2 are similar.
when executed with s time out cvc4 modified acosolver timed out on cases with a recall of .
and an overall execution time of .
min.
therefore the version ofaco solver without sushi helped solve only more case whereas the unmodified aco solver helped solve morecases.
since in this scenario we expected the search to explore a larger search space we also ran the solver with an increased time out of s however we obtained the same results as above in terms of solved cases and recall but the execution time increased to almost three hours.
from the above results we answer rq3 by saying that the automata based solver plays a fundamental role in achieving a higher effectiveness since it contributes to reducing the number of failing cases and increasing the recall.
d. v erifiability and threats to v alidity v erifiability the applications composing the benchmark the related attack conditions the instructions and scripts to obtain the aco solver tool and run the benchmark and the detailed evaluation results are available on our website .
threats to v alidity our results are based on solving the constraints corresponding to attack conditions extracted from a specific benchmark hence they cannot necessarily be generalized to all types of constraints.
we minimized this threat by choosing applications that vary in functionality and by sampling realistic projects which in many cases represent wellknown benchmarks in the context of vulnerability detection.
there are other benchmarks e.g.
the one used in and the kaluza suite that are widely used for comparing constraint solvers.
however they are not specific to the security domain e.g.
they are not annotated with vulnerability information and thus the constraints they contain cannot be used to assess the effectiveness of a solver in terms of vulnerability detection.
furthermore we remark that our results should be interpreted in the specific context of vulnerability detection and cannot and do not aim to be extrapolated to the more general case of string constraint solving.
as shown in subsection v c the role of an automata based solver is essential for our approach in order to reduce the input domains and scale the meta heuristic search process.
instead ofsushi which supports only basic operations we could use other more powerful automata based solvers like stranger and jst which support more operations.
nevertheless sushi was available from the authors fully functional and yielded a significant reduction in search space that was sufficient to make the approach practical.
by using an automata205 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
based solver with support for a larger set of operations we expect a reduction of the time taken by the meta heuristic search since it will have to explore a smaller search domain.
hence our results should be interpreted as the lowest bound for our search driven constraint solving approach.
vi.
r elated work our proposed approach is related to work done in the areas of constraint solving through heuristic search string constraint solving code based security analysis and searchbased test input generation for string data types.
constraint solving through heuristic search.
heuristic search has been already proposed for solving nonlinear arithmetic constraints with operations from unsupported numeric libraries the heuristics is optimized to explore an n dimensional space over real numbers.
contrastingly our approach targets solving string constraints with unsupported string manipulating operations and its search heuristics is optimized in terms of search strategy and fitness functions for string constraints.
further the approach in is evaluated in terms of coverage of test generators while we evaluated our approach in the context of vulnerability detection.
string constraint solving.
there are many constraint solvers that provide to a certain degree support for strings bit vector based solvers like hampi and kaluza automata based solvers like violist stranger abc strsolve pass stringgraph and jst word based solvers like norn s3 and the aforementioned sushi cvc4 and z3 str2.
among them stranger jst stringgraph s3 z3str2 and cvc4 support the most number of string operations e.g.
startswith endswith replace replaceall length and matches that are essential in the context of vulnerability detection they also support numeric constraints.
although hampi and kaluza have been widely used as benchmarks for evaluating other solvers see they actually support only a smaller set of string operations than the solvers listed above also hampi does not support numeric constraints.
support for regular expressions which are usually used in attack specifications is only provided often in a limited form by sushi stranger abc kaluza s3 z3 str2 and cvc4.
nevertheless none of them provides full support for a complete string function library of a modern programming language or for sanitization libraries like owasp esapi and apache commons lang.
this means that they fail when they encounter an unsupported operation in an input constraint in turn this may lead to missing vulnerabilities.
by contrast in our approach we use a search based meta heuristic algorithm to handle unsupported operations.
code based security analysis.
code based security analysis approaches can be broadly categorized into two types taint analysis and symbolic execution.
taint analysis approaches such as check whether application inputs are used in sinks without passing through known sanitization functions.
however these approaches tend to generate many false alarms since they cannot reason aboutthe implementation of sanitization functions.