relifix automated repair of software regressions shin hwei tan and abhik roychoudhury national university of singapore shinhwei abhik comp.nus.edu.sg abstract regression occurs when code changes introduce failures in previously passing test cases.
as software evolves regressions may be introduced.
fixing regression errors manually is time consuming and error prone.
we propose an approach of automated repair of software regressions called relifix that considers the regression repair problem as a problem of reconciling problematic changes.
specifically we derive a set of code transformations obtained from our manual inspection of real software regressions this set of code transformations uses sy ntactical information from changed statements.
regression repa ir is then accomplished via a search over the code transformation operators which operator to apply and where.
our evaluation compares the repairability of relifix with genprog on real regression errors.
relifix repairs bugs while genprog only fixes five bugs.
we also measure the likelihood of both approaches in introducing new regressions given a reduced test suite.
our experimental results shows that our approach is less likely to introduce new regressions than genprog.
i. i ntroduction regression captures the scenario where failures occur in previously passing tests.
as software evolves due to change s in software requirement and bug fixes regression bugs may be introduced.
even worse still fixing a regression bug is like ly to introduce another regression bug due to low quality patc hes and inadequate testing.
prior studies on regression errors primarily focus on techniques for localizing and understanding of regressions.
th e delta debugging approach searches for failure inducing ci rcumstances contributing to test failures i.e.
the set of c ode changes and the state differences between passing and faili ng tests using a divide and conquer algorithm .
given a reference program a buggy program and an input that fails o n the buggy program the darwin approach generates alternati ve input that fails on the buggy program then compare the executions of the two inputs to pinpoint the root cause of the error .
previous studies show promising results in loca ting the cause of regression errors.
however after locating the cause of regression errors how do we utilize the availabili ty of a previous working version to automatically repair such errors?
this is addressed in the current paper.
fixing regression errors manually is time consuming and error prone.
recent study stated that some regression erro rs could take up to .
years before they are detected and fixed by developers .
recently several automated program repa ir techniques have been introduced.
arcuri and yao suggested adapting evolutionary algorithms for automatic program ge neration .
weimer et al.
utilized genetic programming fo r automated program repair .
wei et al.
leverages software contract to automatically fix faulty eiffel classe s .nguyen et al.
employed symbolic execution and componentbased program synthesis for discovering the code required for fixing the buggy program .
kim et al.
proposed an automated patch generation approach i.e.
par that utili zes common fix patterns learned from manual inspection of human patches .
recent study shows that statements or expressions required for fixing exist in previous commits of the programs .
however existing automated program repair techniques have not fully exploited information fro m the software change history for automated repair of regression s. in this paper we verify the possibility of using syntactica l information between program versions and test execution history to repair problematic changes that causes regressi ons.
the key challenge in repairing regression errors is to retai n as much of the new functionalities introduced along with the new version as possible while reproducing the regression te sts behavior in the previous version.
criteria we want our automated repair of regression error to follow the following criteria c1 introduces small changes retains as much of the code of the new version as possible as more changes may lead to more regression errors.
c2 produces readable code generates source code that developers can understand and verify easily.
c3 passes progression tests progression tests that pass in the new version and fail in the previous version must remain passing after the repair.
c4 passes previously failed regression tests regression tests that fails in the previous version and pass in the curre nt version must be made passing in the new version.
c5 only change if no regression will be introduced if changes caused other tests in the test suite to fail then lea ve the source code unchanged.
the repaired version should not introduce further regression error.
we present a novel approach called relifix for automated repair of software regressions.
in particular our contrib utions can be summarized as follows new domain we focus on program fixing on a new domain specifically on repairing software regression errors.
this domain was not studied in prior work in automated program repair but various researches on fault localization and regression testing showed that thi s domain is important and widely represented in software development activities.
new perspective we formulate the software regression repair problem as a problem of reconciling problematicrelifix repair clang evaluate mutantgenerate mutantdiff program p program pstatement ranking filtering ochiai whole test suite p p rt pass fail fail pass pass pass testptreduced test suiteabbreviations rt regression tests that pass in earlier version fail in current program versi on pt progression tests that fails in earlier version pass in current program ver sion fig.
.
relifix s overall workflow changes.
we hypothesize that the fixes for regression bugs can be crafted using code from both the previous version specifically the preceeding version before the regressio n error occurs and the current program version.
we justify th is formulation further in section ii.
this formulation allows us to introduce fixes only to the changed lines.
program repair using previous version our approach leverages different program versions and code changes for guiding automated repair of regression bugs.
new contextual operators we manually inspected real regression bugs from the corebench benchmarks .
our manual inspection produces a set of operators that uses information from two program versions including changed statements and program location of the changed statements.
evaluation we applied relifix on seven open source c projects make find vim tar indent python and perl which have well developed and well tested code.
we compare the repairability of relifix with genprog on real regression errors.
relifix successfully repaired bugs while genprog only fixes five bugs.
to compare the likelihood of both approaches in introducing new regressions we also evaluated the regression rate of both approaches given the reduced test suite test suite that contains the tests with different test behaviors in the two program versions .
our experimental results show that our approach is less likely t o introduce new regressions compared to genprog.
ii.
r epairing regression as reconciling problematic changes when a developer fixes a regression error he or she needs to execute the failing regression test locate the cause of t he test failure and fix the current version of the program by referring to the previous version.
this suggests that while repairing regression we probably try to find a fix that replica tes the regression tests behavior in the previous version.
in f act trivial fixes exist in the context of regression execute the previous version for the failing regression test and run the current version for the remaining test cases.
such fixes are quick to issue and they pass all tests in the test suite.
howev er they are costly to maintain and difficult to understand.
wors e still the number of program versions will double when anoth er regression bug emerges.
thus a good repair must be ableto reproduce the regression tests s behavior in the previou s working version while maintaining the working functionali ties for the current version.
there are generally three types of software regressions.
local a code modification breaks existing functionality in the changed program element.
unmask a code modification unmasks an existing bug that had no effect to some test s behavior before the modification .
remote a code modification introduces a bug in another unchanged program element.
intuitively if a functionality works in the previous versi on thelocal regression error can be fixed by rolling back to its old implementation in previous version.
this intuition is supported by the revert to previous statement operator derived from the corebench benchmarks.
our hypothesis that fixes for regression errors exist in the immediate version before a regression error occurs is in line with this intuition.
rec ent studies that speculate on the probabilities of locating fixe s from multiple program versions further validate s this hypothesis.
in contrast if some source code in previous version had successfully hidden an existing bug the unmask regression error may be fixed by re masking the problematic changes.
in this case fixing regression involves searching for a condit ion under which the problematic code modifications have no effec t to the tests behavior.
this intuition is supported by the add condition operator derived from the corebench benchmarks.
we hypothesize that the condition for hiding the problemati c changes can be found among the program expressions in the current version.
some of the existing automated program repair techniques share similar hypothesis.
from these two observations we formulate the software regression repair problem as a problem of reconciling problematic changes.
iii.
e xperience about real life regressions we manually examined benchmarks obtained from four subject programs to understand how software evolves during real world regressions.
we used the corebench benchmarks1for our manual investigation.
this set of benchmarks is derived from regression errors that were systematically release corebench deduced from version control repositories and bug reports of four open source gnu projects i.e.
make2 grep3 findutils4 coreutils5 .
for each of the benchmarks we examined two set of code changes changes that occur between the version before the regression is introduced i.e.
version p1 and t he version immediately after p1 i.e.
version p2 and cod e changes that occur between the version before the regressio n is fixed i.e.
version p3 and the version after the regressi on is fixed i.e.
version p4 .
we refer to each program version as p1 p2 p3 and p4 to denote the corresponding program version for the rest of the paper.
we then derived a set of general code transformations by comparing version p3 with p4.
this set of code transformations form the operators that can be applied to repair the regression bugs.
table i shows the code transformation derived from the benchmarks toget her with the number of benchmarks that uses the corresponding operator in regression bug fixing.
the table is sorted with th e most commonly used operators at the top of the table.
the last row in the table shows that repairs that involves two code transformation operators the other repairs invo lve only one code transformation operator .
overall our manua l inspection shows that information given by code changes between program versions are often included in human patches.
a. contextual operators that use information from differen t program versions our manual inspection produces a set of operators that utilize information obtained from the previous version and from the code changes that occur between two consecutive program versions.
we refer to this set of operators as contextual operators due to their