predicting delays in software projects using networked classification morakot choetkiertikul hoa khanh dam truyen tran and aditya ghose school of computing and information technology university of wollongong australia email mc650 hoa aditya uow.edu.au school of information technology deakin university australia email truyen.tran deakin.edu.au abstract software projects have a high risk of cost and schedule overruns which has been a source of concern for the software engineering community for a long time.
one of the challenges in software project management is to make reliable prediction of delays in the context of constant and rapid changes inherent in software projects.
this paper presents a novel approach to providing automated support for project managers and other decision makers in predicting whether a subset of software tasks among the hundreds to thousands of ongoing tasks in a software project have a risk of being delayed.
our approach makes use of not only features specific to individual software tasks i.e.
local data as done in previous work but also their relationships i.e.
networked data .
in addition using collective classification our approach can simultaneously predict the degree of delay for a group of related tasks.
our evaluation results show a significant improvement over traditional approaches which perform classification on each task independently achieving precision improved recall improved f measure improved and area under the roc curve improved .
i. i ntroduction delays constitute a major problem in software projects .
approximately one third of it projects went over the scheduled time according to a recent study by mckinsey and the university of oxford in on large scale it projects .
in the standish group s well known chaos report the proportion of delayed projects recorded were even higher at .
these studies have also shown that ineffective risk management is one of the main reasons for the high rate of overrun software projects.
an important aspect of risk management is the ability to predict at any given stage in a project which tasks among hundreds to thousands tasks are at risk of being delayed.
foreseeing such risks allows project managers to take prudent measures to assess and manage the risks and consequently reduce the chance of their project being delayed.
making a reliable prediction of delays is therefore an important capability for project managers especially when facing with the inherent dynamic nature of software projects e.g.
constant changes to software requirements .
current practices in software risk management however rely mostly on high level generic guidance e.g.
boehm s top list of software risk items or sei s risk management framework or highly subjective expert judgements.
thus there is astrong need for providing automated contextual support for identifying risks of delay in software projects.
in order to address that need a number of recent proposals have leveraged data mining and machine learning technologies to predict delays in resolving software issues e.g.
or to estimate the fix time of a software bug e.g.
.
in line with a large body of work in data mining for software engineering these approaches employ traditional machine learning classification techniques to perform classification on each issue or bug independently using its attributes or features.
such approaches do nottake into account the role of the underlying network of inter relationships between the tasks of resolving those bugs or issues.
this is a gap given the preponderance of task dependencies in software projects approximately of tasks in the five open source projects selected for our study were related to at least one other task.
these task dependencies form the networked data that we will seek to leverage in this work.
networked data are seen in many different forms in our daily life such as hyperlinked web pages social networks communication networks biological networks and financial transaction networks.
they are used in various applications such as classifying web pages scientific research papers protein interaction and gene expression data .
we demonstrate that a similar class of networked data i.e.
networked tasks can also provide valuable information for predicting delays in software projects.
for example if a task blocks another task and the former is delayed then the latter is also at risk of getting delayed.
this example demonstrates a common delay propagation phenomenon in software projects which has not been considered by previous approaches.
we propose a novel approach to leverage task dependencies for predicting delays in software projects.
this paper makes two main contributions a technique for constructing a task network of software development tasks this technique enabled us to extract various relationships between tasks in software projects to build a task network.
task relationships can be explicit those that are explicitly specified in the task records or implicit those that need to be inferred from other task information .
explicit relations usually determine theorder of tasks while implicit relations reflect other aspects such as tasks assigned to the same developer tasks affecting the same software component or similar tasks.
predictive models to predict delays in software projects.
we developed accurate predictive models that can predict whether a software task is at risk of getting delayed.
our predictive models have three components local classifier relational classifier andcollective inference .
the local classifier uses 15non relational i.e.
local features of a software task discussion time waiting time task type number of repetition tasks percentage of delayed tasks that a developer involved with developer s workload task priority number of comments changing of priority number of fix version number of affect version changing of description number of votes number of watches and reporter reputation.
the relational classifier makes use of the task relations in a task network to predict if a task gets delayed based on the delay information of its neighbors.
finally collective inference allows us to make such a prediction simultaneously for multiple related tasks.
the performance of our predictive models were evaluated on five different open source projects.
we achieved precision recall f measure and area under the roc curve.
the evaluation results compared to the traditional approaches using only local classifiers show a significant improvement it improves precision recall f measure and area under the roc curve over the traditional approaches.
the remainder of this paper is organized as follows.
section ii describes a motivating example and section iii provides an overview of our approach.
section iv serves to describe how a task network is built for a software project.
section v presents our networked predictive models.
section vi reports the experimental evaluations of our approach.
threats to validity of our study are discussed in section vii.
related work is discussed in section viii before we conclude and outline future work in section ix.
ii.
m otivating example typically a software project requires a number of activities or tasks be completed.
each task usually has an estimated due date.
it is important for project managers to ensure as many tasks be completed in time i.e.
by their respective due date as possible since this has implications to the overall progress of a project e.g.
releasing a major version on a specified date .
however in practice project will never execute exactly as it was planned due to uncertainty.
for example figure shows seven tasks represented by their id extracted from the jboss1 project only two of which i.e.
tasks jbide and jbas14 were completed on time whilst there were three delayed tasks i.e.
jbas jbws and jbop .
one of the main challenges in project management is therefore predicting which tasks have a risk of being delayed giving the current situation of a project in order to come up with measures to reduce or such a risk.
in this example assume that we are trying to predict if tasks jbas and jbas will be delayed.
jbide 1469jbas 13jbop 1jbas 15jbas 14jbws 52blocksdelayed tasknon delayed taskjbas ?
?existing task?
fig.
an example of task dependencies in the jboss project recent work has proposed risk factors contributing to the delay of a software task completion.
those factors reflect a range of attributes associated with a software task which are referred to as local features such as task type task priority the workload of developers assigned to the task and so on.
based on these risk factors predict models were built to predict if a task will be delayed.
like many tradition machine learning methods in software engineering the work in has treated tasks as being independent which makes it possible to predict delay risks on a task by task basis.
for example using the local features the approach in predicted that tasks jbas would not be delayed.
in most cases the tasks in a project are however related to each other and the delay status e.g.
major delayed minor delayed or non delayed of one task may have an influence on that of its related task.
for example there are several blocking relationships between the seven jboss tasks in figure e.g.
task jbide blocks jbas indicating that the former needs to be finished before the completion of the latter.
the task dependencies form the networked data which contain interconnected tasks.
networked data provides additional valuable information which can be used to improve the predictive performance of techniques solely relying local features.
for example the local features are not sufficiently to provide accurate prediction for task jbas it was predicted as non delayed but it is in fact a delayed task.
on the other hand by examining its relationships with other tasks whose delay status are known jbas were blocked by delayed tasks and non delayed task see figure we may be able toinfer the risk of task jbas being delayed.
this example motivates the use of networked data to make within network estimation tasks for which delay status e.g.
delayed or non delayed is known are linked to tasks for which the delay status must be predicted.
here the data has an important characteristics tasks with known delay status are useful in two aspects.
they serves not only as training data but also as background knowledge for the inference process.
hence the traditional separation of data into training and test sets need to carefully take this important property into account.
in addition networked tasks support collective classification i.e.
the delay status of various related tasks can be predictedsimultaneously.
for example the prediction of task jbas can be used to influence the estimation of task jbas as they are linked thus we should do both predictions at the same time.
this example only demonstrates links that are explicitly specified in the tasks record.
in practice there are many instances where tasks are related implicitly e.g.
assigned to the same software engineers affecting the same software component or similar to each other.
our approach is able to extract different types of explicit and implicit task relationships and uses them for delay prediction.
iii.
o verview of our approach our approach leverages classification techniques in machine learning to predict the riskiness of a task being delayed.
a given task is classified into one of the classes in c1 c2 .
.
.
c k where each class cirepresents the risk impact in terms of the degree of delay e.g.
major delayed minor delayed or non delayed.
historical i.e.
completed tasks are labeled i.e.
assigned to a class membership based on examining the difference between their actual completion date and due date.
for example in our studies tasks completed by their due date are labeled as non delayed whilst tasks finished more than days after their due date are labeled as major delayed .
the basic process of our approach is described in figure .
the process has two main phases the learning phase and the execution phase.
the learning phase involves using historical data from past tasks to train classifiers which are then used for classify new tasks in the execution phase.
our approach extracts data associated with software tasks to build a task network which is defined as below.
definition task network .a task network is a directed graph g v e where each vertex v2vrepresenting a software task in the form of hid c attrs iwhere idis a unique identifier of the task cis the risk class i.e.
label e.g.
non delayed minor delayed or major delayed which the task belongs to and attrs is a set of the task s attribute value pairs attr i va l i i.e.
local features .
each edge e2erepresenting a link between tasks u and vin the form of hhu vi t yp e s w e i gh t s iwhere types is set of the link s type and weigths is set of link s weight.
the set of tasks or nodes vin a task network is further divided into two disjoint groups tasks with known class labels vk and tasks whose labels need to be estimated unknown class vuwhich vu v vk.
labeled tasks are used for training and also serve as background knowledge for inferring the label of tasks in vu.
a set of attributes attrs for a task are also extracted see table i .
these features represents the local information of each individual task in the network.
the local features are used to build a local classifier which treats tasks independently from each other.
traditional state of the art classifiers e.g.
random forest multiclass support vector machines table i local features of a software task feature short description discussion time the period that a team spends on finding solutions to solve a task waiting time the time when a task is waiting for being acted upon type task type task repetition the number of times that an task is reopened priority task priority changing of priority the number of times a task s priority was changed no.
comments the number of comments from developers during the discussion time no.
fix versions the number of versions for which a task was or will be fixed no.
affect versions the number of versions for which a task has been found changing of description the number of times in which the task description was changed reporter reputation the measurement of the reporter reputation developer s workload the number of opened tasks that have been assigned to a developer at a time per.
of delayed tasks the percentage of delayed tasks in all of the tasks which have been assigned to a developer number of votes the number of developers who voted a task number of watches the number of developers who watch a task or multiclass logistic regression can be employed for this purpose.
the second important component in our approach is the relational classifier .
unlike the local classifier the relational classifier makes use of the relations between tasks in the network represented by edges to estimate a task s label using the labels of its neighbors.
relational classifier models exploit a phenomenon that is widely seen in relational data the label of a node is influenced by the labels of its related nodes.
relational classifier models may also use local attributes of the tasks.
links between tasks in the network are established by extracting both explicit and implicit relations.
explicit relations refer to the task dependencies explicitly set by the developers e.g.
the block dependency .
on the other hand implicit relations can be inferred from the resources assigned to the tasks e.g.
assigned to the same developer or the nature of the tasks.
we will discuss these types of task relations in details in the next section.
each type of relationship can be assigned to a weight which quantitatively reflects the strength of the relationship.
another novel aspect of our approach is the collective inference component which simultaneously classifies a set of related tasks.
details of these approaches will be provided in section v. iv.
t ask network construction an important part of our approach is building a task network for past and current tasks.
in most of modern task tracking system e.g.
jira some dependencies between tasks are explicit recorded i.e.
in a special field in the task reports and can be easily extracted from there.
we refer to these dependencies as explicit relationships .
there are however other types of task dependency that are not explicitly recorded e.g.
tasks assigned to the same developer and we need to infer them from extracting other information of the tasks.
theselearning phaseexecution phase archive of past tasks identifying delay status of tasks extracting local features constructing task network building relationalclassifier trainedrelationalclassifierbuilding local classifierlabelledtasks predicted delaystatus of tasks trained local classifier collective inference existing tasks extracting local features task linksfig.
an overview of our approach jbide b. implicit network topologyjbide 788jbide 1329jbide 1769jbide 1457jbide 6217jbide 1636jbide 1547jbide 351jbide 1498blocksrelatesrelates fig.
example of explicit task relationships in jboss are referred to as implicit relationships .
we now discuss these types of relationships in details.
explicit relationships there are a number of dependencies among tasks which are explicitly specified in the task records.
these typically determine the order in which tasks need to be performed.
there are generally four different types of relationships of the preceding tasks to the succeeding tasks finish to start predecessor must finish before successor can start start to start predecessor must start before successor can start finish to finish predecessor must finish before successor can finish and start to finish predecessor must start before successor can finish .
for example blocking is a common type of relationships that is explicitly recorded in issue bug tracking systems.
blocking tasks are software tasks that prevent other tasks from being resolved which could fall into the finish to start or finish to finish category.
figure shows some explicit relationships between tasks in the jboss project which uses the jira task tracking system.
jira provides the task link attribute to specify the relationship between two or more related tasks.
the explicit relationships are extracted directly from the dataset.
for example jbide788 blocks jbide which is represented by a directed edge connected the two nodes.
in addition to blocking jira also provides three other default types of task links relates to clones and duplicates.
figure shows some examples of the relates to relationship e.g.
task jbide relates to jbide .
c. combined network topologyjbide 788jbide 1492jbide 1694jbide 1694repjbide 1492jbide jbide 799verdev same developerrep same reportercom same componentfix same fix versionver same affect versiontop same topicjbds 655fig.
example of implicit task relationships in jboss implicit relationships while explicit relationships are specified directly in the task reports implicit relationship need to be inferred from other task information.
there are different task information that can be extracted to identify a implicit relationship between tasks.
we classified them into three groups as described below.
resource based relationship this type of relationships exists between tasks that share the same human resource.
the resource here could be the developers assigned to perform the tasks or the same person who created and reported the tasks.
resource based relationship is important in our context since a resource s skills experience reputation and workload may affect a chance of delayed tasks i.e.
a developer who causes a delay of a current task may do so again in the future .
for example from figure jbide has a relationship with jbide since both of them are assigned to the same developer.
task jbide is also related to jbide since they were reported by the same person.
attribute based relationship tasks can be related if some of their attributes share the same values.
for example there is a relationship between tasks performed on the same component since they may affect the same or related parts of code.
for tasks recorded in jira we extract this type of relationship by examining threetable ii datasets and networks statistics project relationshipnum nodesnum edgesavg.
node degreenode assort.
apache explicit .
.
implicit .
.
all .
.
duraspace explicit .
.
implicit .
.
all .
.
jboss explicit .
.
implicit .
.
all .
.
moodle explicit .
.
implicit .
.
all .
.
spring explicit .
.
implicit .
.
all .
.
attributes affect version fix version andcomponent .
for example jbide and jbide affects the same version while jbide and jbide affects the same component as shown in figure .
content based relationship tasks can be similar in terms of how they are conducted and or what they affect.
the similarity may form an implicit relationship between tasks which can be established by extracting the description of the tasks.
different extraction techniques can be applied here ranging from traditional information retrieval techniques to recent nlp techniques like topic modeling.
we use latent dirichlet allocation to build a topic model representing the content of a software task.
we then establish relationships between on the basis that related tasks share a significant number of common topics.
figure shows some example of content based relationships in jboss e.g.
task jbide has the same topic with jbds .
the common topics shared between these two tasks are code access control exception and document types .
a task network is built by extracting both explicit and implicit links among the tasks.
we employ a number of measures to describe different properties of a task network the number of nodes the number of edges and the average node degree i.e.
the number of connections a node has to other nodes .
in addition assortativity coefficient is used to measure the correlation between two nodes the preference of network nodes to connect to other nodes that have similar or different degrees.
positive values of assortativity coefficient indicate a correlation between nodes of similar degree e.g.
highly connected nodes tends to be connected with other high degree nodes while negative values indicate relationships between nodes of different degree e.g.
high degree nodes tend to connect to low degree nodes .
as can be seen from table ii the inclusion of implicit relationships significantly increases the density of the network tasks across all the five projects that we studied.
by contrast the assortativity coefficient remains nearly the same with or without implicit relationships.a weight is also applied to each edge type in a task network.
this allows us to better quantify the strength of a relationship between tasks.
by default each edge is equally assigned the weight of .
however different weights can also be applied to different types of relationships.
more complex approaches can also be applied here.
for example the weights could be decreased over time to reflect the fading of the relationships e.g.
the tasks have been assigned to the same developer for long time ago.
v. p redictive models our predictive models are built upon three components local classifier as done in previous work relational classifier and collective inference.
local classifiers treat tasks as being independent making it possible to estimate class membership on a task by task basis.
relational classifiers posit that the class membership of one task may have an influence on the class membership of a related task in the network.
collective inference infers the class membership of all tasks simultaneously .
in the following we discuss the details of each components.
a. local non relational classifier there are several available state of the art algorithms and techniques that we could employ to develop local classifiers.
we employ the state of the art classifier which is random forest rf the best performing technique in our experiments.
b. relational classifier relational classifiers make use of information about related tasks to estimate the label probability.
for simplicity we use only direct relations for class probability estimation p c g p c ni where niis a set of the immediate neighbors of task vi i.e.
those that are directly related to vi in the task network g such that p c ni is independent of g ni.
this is based on a theoretical property known as the markov assumption which states that given the neighborhood also known as the markov blanket it is sufficient to infer about the current label without knowing the other labels in the network .
for developing a relational classifier we employ two highly effective methods.
one is weighted vote relational neighbor wvrn which is one of the best relational classification algorithms reported in .
the other is stacked graphical learning where classifiers are built in a stage wise manner making use of relational information in the previous stage.
weighted vote relational neighbor weighted vote relational neighbor wvrn estimates class membership probabilities based on two assumption .
first the label of a node depends only on its immediate neighbors.
second wvrn relies on the principle of homophily which assumes that neighboring class labels were likely to be the same .
thus wvrn estimates p c vi as the weighted mean of the class membership of the tasks in the neighborhood ni p c vi zx vj2niw vi vj p c nj where z p vj2niw vi vj andw vi vj is the weight of the link between task viand task vj.
our experiments applied the same weight of to all relationship types i.e.
w vi vj .
the optimized weights could be determined using the properties of a network topology such as assortativity coefficient .
we denote the prior class probability distributions from a relational classification as mr. stacked graphical learning one inherent difficulty of the weighted voting method is the computation of the neighbor weights.
since there are multiple relations estimating the weights are non trivial.
stacked learning offers an alternative way to incorporate relational information.
the idea of stacking is to learn joint models by multiple steps taking into relational information of the previous step to improve the current step.
at each step relational information together with local features are fed into a standard classifier e.g.
random forests .
we consider relations separately and the contribution of each relation is learnt by the classifier through the relational features.
the classifier is then trained.
its prediction on all data points vertices in the network will be then used as features of the next stage.
we adapt the idea from .
our contribution is in the novel use of random forests as a strong local classifier rather than linear classifiers as used in .the stacked learning algorithm is described in algorithm .
it returns tclassifiers for tsteps.
at the first step the local classifier is used.
at subsequent steps relational classifiers are trained on both local features and relation specific averaged neighbor probabilities.
c.collective inference collective inference is the process of inferring class probabilities simultaneously for all unknown labels in the network conditioned on the seen labels.
we employ two methods relaxation labeling rl and stacked inference si .
rl is applicable to any non stagewise relational classifiers e.g.
wvrn described in section v b1 .
it has been found to achieve good performance in .
si on the other hand is specific to stacked classifiers e.g.
see section v b2 .
relaxation labeling relaxation labeling rl has been shown to achieve good results in .
rl initializes the class probabilities using the local classifier model.
rl then iteratively corrects this initial assignment if the neighboring tasks have labels that are unlikely according to the prior class distribution estimated by mr see section v b1 .
algorithm describes the relaxation labeling technique.
stacked inference following the stacked learning algorithm in section v b2 stacked inference is described in algorithm .
it involved tclassifiers returned by the stack learning algorithm.
at the first step the local classifier is used to compute the class probabilities.
at t 1subsequent steps relational classifiers receives both the local features and relation specific weighted neighbor probabilities and outputsclass probabilities.
the final class probabilities are the outcome of the inference process.
vi.
e va l uat i o n tasks were collected from the jira task tracking system in five well known open source projects apache duraspace jboss moodle and spring see table ii and divided into a training set and a test set.
we try to mimic a real project management scenario that prediction on a current task is made using knowledge from the past tasks the collected tasks in training set are those that were opened before the tasks in test set.
the collected datasets are shown in table ii.
we have made our datasets publicly available at mc650 .
since the number of delayed tasks in our datasets is small we chose to use two classes of delay major delayed and minor delayed and the non delayed class .
table iii shows the number of tasks in training set and test set for each project.
major delayed tasks are those that have actual completed date resolved date greater than days from planned to completed date and less than days of delays is minor delayed.
note that the size of delayed can be defined by project managers who realize the impact of schedule overruns to the projects.
since major minor delayed tasks are rare and imbalanced we had to be careful in creating the training and test sets.
specifically we placed of the delayed tasks into the training set and the remaining into the test set.
in addition we tried to maintain a similar ratio between delayed and non delayed tasks in both test set and training set i.e.
stratified sampling.
table iii experimental setting projecttraining set test set major minor non major minor non apache duraspace jboss moodle spring a. performance measure reporting the average of precision recall across classes is likely to overestimate the true performance since our risk classes are ordinal and imbalanced and no delays are the default and they are not of interest to the prediction of delayed tasks.
hence our evaluation is focus on the predicting of risk classes as described below.
a confusion matrix is used to evaluate the performance of our predictive models.
as a confusion matrix does not deal with a multi class probabilistic classification we reduce the classified tasks into two binary classes delayed and nondelayed using the following rule ci delayed ifp i maj p i min p i non non delayed otherwisealgorithm the stacked learning algorithm adapted from train of the st local classifiers on training nodes ignoring relations forstep t .. t do compute the class probabilities for all data points using the t th classifier foreach node ido foreach relation rthat this node has with its neighbor do ifrelation weight exist then average all probabilities of its neighbors jwho have the relation rwith relation weight else set relation weight to average all probabilities of its neighbors jwho have the relation r end if prepare k 1features using these averaged probabilities k probabilities sum to end for concatenate all relational features together with the original features end for train the t th local classifier on training nodes and new feature sets.
end for output t classifiers one local t relational algorithm the relaxation labeling algorithm adapted from use the st classifier to predict the class probabilities using only local features forstep t .. t do estimate the prior class probabilities using the relational classifier mr on the current state of network reassign the class of each vi2vuaccording to the current class probabilities estimation end for output the class probabilities of vertices with unknown labels.
algorithm the stacked inference algorithm use the st classifier to predict the class probabilities using only local features forstep t .. t do prepare relational features using the neighbor probabilities computed from the previous step use the t th classifiers to predict the class probabilities using local features and relational features.
end for output the class probabilities of vertices with unknown labels.
where ciis the binary classification of task i and p i maj p i min and p i non are the probabilities of taskiclassified in the major delayed minor delayed and nondelayed classes respectively.
basically this rule determines that a task is considered as delayed if the sum probability of it being classified into the major and minor delayed classes is greater than the probability of it being classified into the non delayed class.
note that our work on this paper focuses on predicting delayed and non delayed tasks.
our evaluations thus emphasize on measuring the performance of predicting whether tasks will cause a delay.
we however acknowledge that the ability to distinguish between major and minor is also important.
hence future work involves using several appropriate performance metrics e.g.
macro averaged mean absolute error to measure the performance of our models in distinguishing between the two delayed classes major and minor delayed .
the confusion matrix is then used to store the correct and incorrect decisions made by a classifier.
for example if a task is classified as delayed when it truly caused a delay the classification is a true positive tp .
if the task is classified as delayed when actually it did not cause a delay then the classification is a false positive fp .
if the task is classified as non delayed when it in fact caused a delay then the classification is a false negative fn .
finally if the task is classified as non delayed and it in fact did not cause a delay then the classification is true negative tn .
the values stored in the confusion matrix are used to compute the widelyused precision recall and f measure for the delayed tasks to evaluate the performance of the predictive models precision the ratio of correctly predicted delayed task over all the tasks predicted as delayed task.
it is calculated as pr tp tp fp recall the ratio of correctly predicted delayed task over all of the actually task delay.
it is calculated as re tp tp fn00.
.
.
.
traditionalwvrn rlstacked learningprecision00.
.
.
.
traditionalwvrn rlstacked learningrecall .
.
.
.
traditionalwvrn rlstacked learningf measure00.
.
.
.
traditionalwvrn rlstacked learningauc a. precision b. recall c. f measure d. aucapacheduraspacejbossmoodlespringfig.
evaluation results of traditional classification wvrn rl and stacked learning f measure measures the weighted harmonic mean of the precision and recall.
it is calculated as f measure pr re pr re area under the roc curve auc is used to evaluate the degree of discrimination achieved by the model.
the value of auc is ranged from to and random prediction has auc of .
.
the advantage of auc is that it is insensitive to decision threshold like precision and recall.
the higher auc indicates a better prediction.
b. results comparison of different classification approaches w e compare three different settings local classifier using random forrests traditional classification weighted vote relational neighbor wvrn with relaxation labeling rl and stacking method with stacked inference .
figure shows the precision recall f measure and auc achieved by three different classification approaches.
the stacking method uses random forests as the base classifier.
the evaluation results indicate that the predictive performance achieved by stacked learning is better and more consistent than traditional classification and relational classification using wvrn rl.
as can be seen in figure a. stacked learning achieved the best precision of .
averaging across five projects while the traditional classification achieved only .
precision averaging across five projects .
it should however be noted that wvrn rl achieved the highest precision of .
for duraspace.
in addition the precision achieved by stacked learning is more consistent and steady in all projects.
by contrast the performance of wvrn rl are varied between projects.
relational classification with wvrn rl is based on the principle of homophily which may not always hold in some projects.
this is reflected by its low performance in some cases i.e.
only .
precision for apache .
on the other hand stacked learning provides a more generalized approach to learn the relationshipswithin networked data it achieved above .
precision across the five projects.
stacked learning also outperforms the other classification approaches in terms of recall and f measure it achieved the highest recall of .
and the highest f measure of .
averaging across five projects as can be seen in in figure b. and c. .
the highest recall of .
was also achieved by stack learning for the spring project.
the degree of discrimination achieved by our predictive models is also high as reflected in the auc results.
the auc quantifies the overall ability of the discrimination between the delayed and non delayed classes.
as can be seen in figure d. the average of auc across all classifiers and across all projects is .
.
all classifiers achieved more than .
auc while stacked learning is the best performer with .
auc averaging across five projects and .
for duraspace.
overall the evaluation results demonstrate the effectiveness of our predictive models achieving on average precision recall f measure and area under the roc curve.
our evaluation results also show a significant improvement over traditional approaches local classifiers improvement in precision in recall in f measure and in area under the roc curve.
the usefulness of collective inference the second aspect of our evaluation focuses on evaluating the predictive performance achieved by using collective inference.
to do so we have setup two experiments one using wvrn and the other using both wvrn and rl.
figure shows the comparison of the precision recall f measure and auc achieved by the relational classification with collective inference wvrn rl and without collective inference only wvrn .
overall the predictive performance achieved by relational classification with collective inference is better than that without collective inference in all measures.
as can be seen in figure the relational classification with collective inference achieves the highest precision of .
recall of .
f measure of .
.
.
.
.
non ciwith ciprecision00.
.
.
.
non ciwith cirecall .
.
.
.
non ciwith cif measure00.
.
.
.
non ciwith ciauc a. precision b. recall c. f measure d. aucapacheduraspacejbossmoodlespringfig.
evaluation results of relational classifier with collective inference and without collective .
.
.
.
precisionrecallf measureexplicitexplicit and resource basedexplicit and attribute basedexplicit and content basedall fig.
evaluation results on different sets of relationships and .
auc averaging across five projects .
although the predictive performance of relaxation labeling is lower than stacked learning as we discussed earlier the evaluation results still support that collective inference significantly improve the performance of relational classifiers.
however collective inference applied on top of the wvrn still follows a strong assumption of homophily theory and as a result it causes an inconsistent predictive performance among different projects.
the influence of explicit and implicit relationships w e have also performed a number of experiments to evaluate the predictive performance achieved by different sets of relationships.
we have tested with five different combinations networks with explicit relationships networks with explicit and resource based relationships networks with explicit and attribute based relationships networks explicit and contentbased relationships and networks with all explicit and implicit relationships.
as can be seen from figure the highest predictive performance is achieved by using both explicit and implicit relationships it achieved the highest precision of .
and the highest recall of .
averaging across five projects .
by contrast the networks using only explicit relationships achieved the lowest precision i.e.
.
while the networks using explicit and content based relationships produced the lowest recall.
in general using both explicit relationshipsand implicit relationships resource based attribute based and content based significantly increases the predictive performance .
increased in precision and .
increased in recall compare to using only explicit relationships .
.
.
.
.
.
.
.
f measureapacheduraspacejbossmoodlespringavg fig.
evaluation results on different sizes of training data the effect of the size of training data we have also performed a number of experiments to assess the proportion of past tasks i.e.
labeled tasks is needed to achieve a good predictive performance.
specifically in these experiments given a data set g v e vk i.e.
labeled tasks is created by selecting samples of of the training set see table iii .
the test set vu is then defined as v vk.
figure shows the predictive performance from samples of to of vin terms of f measure.
the results clearly demonstrate that f measure averaging across five projects increases as more labeled data is used for training.
vii.
t hreats to v alidity one relational setting involves the use of wvrn which assumes the homophily property among tasks that is related tasks should have similar delay risk.
this is a strong assumption and may not hold in reality and this has been revealed in our experiments.
we have addressed this threat by proposing stacked learning approach which does not rely on the the homophily assumption but rather estimates the contribution of separate relationships.
we have attempted to identify all possible relationships among typical software tasks.
however we acknowledge that the implicit relationships we have inferred are by no means comprehensive to represent all task dependencies.
another threat to our study is that our data set has the class imbalance problem over of the total data are non delayed tasks which may affect a classifier s ability to learn to identify delayed tasks.
we have used stratified sampling to mitigate this problem.
we however acknowledge such a sampling approach could be an external threat to validity.
further experiments to evaluate sampling techniques used in practice are thus needed.
in addition patterns that hold in the train data may not reflect the situation in the test e.g.
the team and management having changed their approach or managed the risks they perceived.
to address this threat instead of splitting the data randomly as done in traditional settings we deliberately chose the time to split training and test sets to mimic a real deployment.
we have considered task reports from the five projects which differ significantly in size complexity development process and the size of community.
although these are real data we however cannot claim that our data set would be representative of all kinds of software projects especially in commercial settings.
although open source projects and commercial projects share similarities in many aspects they are also different in the nature of contributors developers and projects stakeholders.
for example open source contributors are free to join and leave the communities i.e.
high turn over rate while developers in the commercial setting tend to be stable and fully commit to deliver the projects progress.
hence further study is need to understand how our predict models perform for commercial projects.
viii.
r elated work an automated risk prediction mainly supports software risk management which is under the umbrella of project management and crucial to the project success rate.
risk management consists of two main activities risk assessment and risk control.
our current work focuses on risk assessment which is a process of identifying risks analyzing and evaluating their potential effects in order to prioritize them .
risk control aims to develop engage and monitor risk mitigation plans .there are a number of works on applying statistical and machine learning techniques to use in different aspects of risk management.
for example letier et al.
used a statistical decision analysis approach to provide a statistical support on complex requirements and architecture.
the work in analyzed the correlation and causality of risk factors using bayesian network.
our work also related to the works on predicting and mining bug reports for example mining bug reports for fixtime prediction e.g.
blocking bug prediction e.g.
re opened bug prediction e.g.
severity priority prediction e.g.
delays in the integration of a resolved issue to a release e.g.
bug triaging e.g.
and duplicate bug detection .
another groups of the works on predicting is mining source code to predict software defects for example mining change history e.g.
and personalized defect prediction e.g.
anothe thread of related work resides in the use of networked data such as predicting software quality using social network analysis e.g.
predicting software evolution in terms of estimating bug severity efforts and defect prone releases using graph based analysis e.g.
and predicting software defects using network analysis on dependency graphs e.g.
.
those approaches mostly work at the level of source code and have not addressed delay prediction at the task level as in our work.
ix.
c onclusions and future work in this paper we have proposed a novel approach to predict whether a number of existing tasks in a software project are at risk of being delayed.
our approach exploits not only features specific to individual tasks but also the relationships between the tasks i.e.
networked data .
we have developed several prediction models using local classifiers relational classifiers and collective inference.
the evaluation results demonstrate a strong predictive performance of our networked classification techniques compared to traditional approaches achieving improvement in precision improvement in recall improvement in f measure and improvement in area under the roc curve.
in particular the stacked graphical learning approach consistently outperformed the other techniques across the five projects we studied.
the results from our experiments indicate that the relationships between tasks have an impact on the predictive performance.
hence as part of future work we will investigate which types of task relationships should be selected to give optimal results and how this can be done automatically for software projects.
a related future investigation would involve applying different weights to different task relationships and assessing their impact to the results.
we also plan to investigate if there are any other kinds of implicit relationships which can be inferred from the task information and the general context of a software project.
our future work would involve expanding our study to commercial software projects and other large open source projects to further assess our predictive models.
finally delay prediction which has been addressed in this paper is just only the first part of the solution.
the next task is making actionable recommendations such as which tasks having a risk of being delayed should be dealt with first and which measures could be used to mitigate the risks.