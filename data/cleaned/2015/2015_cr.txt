zoomin discovering failures by detecting wrong assertions fabrizio pastore and leonardo marianiy university of luxembourg centre for security reliability and trust luxembourg luxembourg yuniversity of milano bicocca department of informatics systems and communications milano italy email ffabrizio.pastore uni.lu mariani disco.unimib.it g abstract automatic testing although useful is still quite ineffective against faults that do not cause crashes or uncaught exceptions.
in the majority of the cases automatic tests do not include oracles and only in some cases they incorporate assertions that encode the observed behavior instead of the intended behavior that is if the application under test produces a wrong result the synthesized assertions will encode wrong expectations that match the actual behavior of the application.
in this paper we present zoomin a technique that extends the fault revealing capability of test case generation techniques from crash only faults to faults that require non trivial oracles to be detected.
zoomin exploits the knowledge encoded in the manual tests written by developers and the similarity between executions to automatically determine an extremely small set of suspicious assertions that are likely wrong and thus worth manual inspection.
early empirical results show that zoomin has been able to detect of the analyzed non crashing faults in the apache commons math library requiring the inspection of less than .
of the assertions automatically generated by evosuite.
i. i ntroduction to reduce manual verification effort test case generation techniques can be used to automatically generate unit integration and system test cases that extensively sample the behavior of the application under test.
developers can thus focus their manual effort on the cases that have not been well addressed by the automatic tests.
unfortunately automatically generated test cases can easily discover problems like crashes anduncaught exceptions but cannot reveal problems that require explicit oracles to be detected .
for instance an automatic test might reveal that a sum operation implemented by a calculator crashes when two negative numbers are added but cannot reveal that a sum operation erroneously behaves as a multiply operation.
modern test case generators have the capability to synthesize tests that include assertions encoding the behavior observed during test case execution .
for instance evosuite can generate a test case that invokes an add method with values and and incorporates the assertion asserttrue add in the test.
these assert statements are useful for regression testing to detect if a change unintentionally modifies the behavior of the system but are almost useless to reveal bugs on the first place.
for instance if the add method erroneously behaves as a multiply operation the assert statement automatically included in the test would look like asserttrue add .
thishappens because test case generators produce assert statements that capture the actual behavior of the tests the execution of add returned rather than capturing the expected result the execution of add should return .
the difficulty to automatically generate correct assert statements is an instance of a well known problem the oracle problem .
solving the oracle problem even partially would dramatically increase the effectiveness of test case generators resulting in a major improvement in software testing the automatic tests would scale from tests that can only detect faults that cause crashes and uncaught exceptions to tests that can potentially detect any functional fault .
in principle it is possible to turn the assertions encoding the behavior observed during test execution into assertions encoding the expected behavior by manually inspecting and fixing every assert statement generated by test case generators.
however this approach does not scale to non trivial programs.
for instance in our experiments evosuite generated tests and assertions for classes in the apache commons math library .
so many tests and assertions cannot be manually inspected in a reasonable amount of time.
as an alternative to manually fixing assertions researchers investigated the use of the crowd .
however to be successful crowdsourcing requires a qualified crowd which is not easy to find and a monetary investment that might be significant when many tests and assertions need to be inspected.
the automatic tests that expose faulty behaviors without failing due to the lack of proper assert statements such as the example of the test with the assertion asserttrue add might be also detected using anomaly detection solutions .
anomaly detection can be used to automatically identify the anomalous executions that occur in a set of executions.
under the assumption that failures are sparse in the execution space anomaly detection techniques can be potentially used as an oracle to distinguish failures from successful executions.
so far anomaly detection approaches have not been precise enough to be used as test oracles as demonstrated in a recent study by nguyen marchetto and tonella where anomaly detection techniques produced poor results when used to address the oracle problem.
in particular anomaly detection generates far too many false positives to be useful.in this paper we show that anomaly detection can be effectively used to address the oracle problem if equipped with proper mechanisms that exploit both the tester s knowledge of the application under test and the degree of similarity between anomalous and regular executions.
our empirical results show that anomaly detection without these additional mechanisms is ineffective confirming the results obtained in the study by nguyen marchetto and tonella while it can reveal several faults with little inspection effort when augmented as described in this paper.
the approach that we have defined called zoomin is a technique that can be integrated with any unit test case generator that synthesizes assertions as part of the automatic tests.
zoomin can heuristically detect wrong assertions and consequentially expose faults that would otherwise go undetected .
in contrast with state of the art techniques the objective of zoomin is not to detect all the wrong assertions or to recognize all the failing tests which is hardly doable without generating many false positives but to pinpoint an extremely small number of likely wrong assertions that require the attention of the developers.
zoomin is based on two key ideas to exploit the knowledge encoded in the test cases implemented by the developers to detect the erroneous behaviors in the automatic tests and to combine anomaly detection with code coverage to make the detection of erroneous behaviors precise.
on a technical perspective zoomin pinpoints the wrong assertions by comparing the executions produced by the manual test cases to the executions produced by the automatically generated test cases.
zoomin originally performs this comparison by working at two abstraction levels simultaneously .
the first level is code coverage that is zoomin compares the statements covered by manual and automatic tests.
the second level is program variables that is zoomin uses daikon to generate constraints about the values that can be legally assigned to program variables when the manual tests are executed.
zoomin detects anomalous variable values by checking the executions produced by the automatic tests using the constraints generated by daikon from the manual tests.
these two levels are combined according to the following intuition the execution of an automatic test case is likely to constitute a failure if it produces anomalous variable values while covering a case already tested by the developers .
in practice we assume that an automatic test case that follows a path similar to one covered by a manual test case while generating anomalous variable values is an automatic test case that reveals a failure bycovering a special untested case of an already tested functionality .
on the contrary an automatic test that produces unexpected variable values while executing a case not well tested by the manual test cases is not necessarily a suspicious test case.
for instance it could be a test case that covers untested features.
to properly assist developers zoomin does not simply pinpoint the test cases that are likely to fail but it directly points at the suspicious assertions that are likely to encode a wrong condition i.e.
the assertions that encode the actual behaviorof the application rather than the expected behavior .
fixing these assertions would cause the tests to fail thus revealing bugs in the program.
the early empirical results show that zoomin applied to test cases generated by evosuite can discover about of the faults covered by the automatic tests by recommending the inspection of less than .
of the generated assertions.
the major contributions of this paper are the definition of zoomin an anomaly detection technique that demonstrates how anomaly detection augmented with proper analysis mechanisms is suitable to address the oracle problem complementing and extending the previous findings about the lack of effectiveness of anomaly detection applied to the oracle problem .
the definition of a mechanism to extract information useful to guide anomaly detection from the manual tests designed by the developers.
the use of coverage information to identify the executions that can be soundly compared.
the definition of a strategy to pinpoint suspicious assertions.
the early empirical results that show that the novel mechanisms introduced in this paper increase the fault detection ability of the evosuite test case generator producing a tolerable set of false positives.
the paper is organized as follows.
section ii overviews the zoomin approach.
section iii presents how zoomin extracts information from manual test cases.
section iv presents how zoomin detects anomalous behaviors in automatic test cases based on the information extracted from the manual tests.
section v describes how zoomin filters out the irrelevant anomalies from the set of discovered anomalies.
section vi presents the ranking of the assertions in the automatic tests.
section vii presents the empirical results.
section viii discusses related work.
section ix provides final remarks.
ii.
z oom in zoomin takes as input the automatic tests generated for a unit under test and returns a set of assertions that must be inspected manually.
the analysis process is automatic and consists of four sequential steps as illustrated in figure .
the first step extracting knowledge from test cases extracts information about the behavior of the class under test when executed with the passing test cases designed by developers.
zoomin records both the return value and the parameter values for every executed method and runs daikon to derive method pre and post conditions generically referred as program constraints in this paper.
for instance step in figure shows the case of no precondition and one post condition derived by zoomin for method conjugate implemented by the class under test complex which is one of the classes studied in our empirical evaluation.
the post condition ret.imaginary!
indicates that the field imaginary of the object returned by method conjugate is expected to be always different than zero method conjugate returns an object of type complex .pre condi on post condi on ret.imaginay!
step extrac ng knowledge from test cases manual test cases program constraints coverage profile stm1 stm2 stm3 stm1 stm3 stm4 stm5 stm8 stm7 program profile1 profile2 violated constraint ret.imaginay!
anomalous value ret.imaginary step detec ng constraint viola ons constraint viola on coverage profile stm1 stm2 stm5 stm9 stm10 automa c test cases conjugate program step filtering constraint viola ons coverage profiles stm1 stm2 stm3 stm1 stm3 stm4 stm5 stm8 stm7 degree of similarity violated constraint ret.imaginay!
anomalous value ret.imaginary stm1 stm2 stm5 stm9 stm10 coverage profile constraint viola on for method conjugate step ranking asser ons violated constraint in.real !
ret.real filtered constraints viola ons assertfalse complex2.isinfinite assertfalse complex2.equals complex1 .
uniqueness score .
violated constraint ret.imaginay!
suspiciousness score .
suspiciousness score .
violated constraint in.real !
ret.real unsafe asser ons conjugate complex complex legend class under test fig.
.
the zoomin approach.
in addition to program constraints zoomin collects the coverage profile associated with every method in the class under test.
a coverage profile of a method mconsists of the set of statements in the class under test executed by a test until reaching an exit point of method m. the total number of profiles associated with a method depends on the number of times the method is executed by the manual test cases.
for instance step in figure shows the case of method conjugate associated with two profiles profile 1and profile .
in the example we use the generic label stm followed by a number to indicate a statement of the program.
the profiles of a method represent the set of program behaviors that have been used to generate the program constraints i.e.
the pre and post conditions associated with that method.
the second step detecting constraint violations detects the automatic tests that produce anomalous variable values when executed.
an anomalous value is a variable value that violates any of the constraints derived in step .
for instance step in figure shows the case of the constraint ret.imaginary!
violated by the method conjugate when returning a number with the imaginary part equals to .
zoomin uses the violated constraints to determine the most suspicious executions and assertions.
in general it is not enough that an automatic test violates a constraint to claim that the test failed as done by classic anomaly detection.
in fact an automatic test might generate anomalous values simply because it executes behaviors that have been never tested by the manual test cases.
zoomin addresses this problem exploiting the notion of coverage profile .
every time a constraint is violated zoomin records its coverage profile.
since the program constraints can only be method pre and post conditions the coverage profile of a violated constraint can be defined as the coverage profile of themethod associated with the constraint.
zoomin uses coverage profiles to assess if constraint violations have been observed in contexts that are comparable to the behaviors tested with the manual test suite.
for instance step in figure shows the case of a constraint violation associated with a profile composed of five statements.
the third step filtering constraint violations has the objective of eliminating from the analysis all the constraint violations that have been detected with automatic executions that are too different from the set of manual executions used to generate the program constraints.
the intuition is that a violated constraint is likely to detect a faulty behavior only if it is associated with a coverage profile that is similar to a profile already observed when executing the manual test cases.
for instance step in figure shows the case of the constraint ret.imaginary!
defined on the return value of the method conjugate violated by the anomalous value ret.imaginary .
the coverage profile of this constraint violation is compared with the profiles collected when executing the manual test cases.
if the same or a close coverage profile is found the violation is considered relevant otherwise it is dropped.
the fourth step ranking assertions splits the assertions in the automatic test cases into two groups the safe assertions and the unsafe assertions.
the safe assertions are likely correct assertions that do not need to be inspected.
the unsafe assertions are possibly wrong assertions that are worth inspection.
the unsafe assertions are ranked the higher the ranking of an assertion is the more likely the assertion is faulty.
zoomin determines the unsafe assertions and places them in a ranking based on the number of constraint violations that are related to them.
the intuition is that the assertions that use test variables that are related to program variables that producedone or more constraint violations are likely to be wrong .
zoomin uses dynamic data flow analysis to discover relations between program variables and variables in the assertions.
the assertions that are not impacted by any anomalous value are considered safe.
the rest of the assertions are considered unsafe and are included in the ranking.
to rank unsafe assertions zoomin takes into consideration the number of constraint violations produced by the related program variables.
however not all the constraint violations are equally important.
since erroneous behaviors are not frequent in adequately tested software zoomin weights each constraint according to the number of times the constraint has been violated.
the frequently violated constraints are likely imprecise constraints that erroneously detect legal values as anomalous values while constraints that are seldom violated are likely to carry useful information.
zoomin captures this aspect with the uniqueness score .
for instance step in figure shows the case of three constraint violations associated with different uniqueness scores.
zoomin associates the unsafe assertions with a score the suspiciousness score that represents the likelihood the assertion is wrong.
the suspiciousness score of an assertion depends on both the number and the uniqueness scores of the related constraints that are violated.
intuitively the highly scored assertions i.e.
the most suspicious assertions are the ones associated with several constraint violations with high uniqueness scores.
to keep the inspection effort low and the effectiveness high developers are assumed to inspect only the top assertions in the ranking.
results show that inspecting the top fiveunsafe assertions is enough to discover several faults without wasting time inspecting too many correct assertions.
in the following sections we present each step of the approach in detail.
iii.
e xtracting knowledge from testcases in the first step zoomin extracts information on the behavior of the class under test by executing the manual test cases.
we assume that testers have already written the manual test cases when the automatic tests are generated.
we also assume that either all the manual test cases pass that is the faults revealed by manual test cases have been fixed or the manual test cases that fail have been excluded from the analysis.
since analyzing all the variables in the program might be extremely expensive zoomin limits the analysis to the interfaces that is it observes the values assigned to any parameter and return value produced by any method and function in the class under test.
the values observed while monitoring the manual test cases are recorded in trace files.
the recorded values are used to synthesize program constraints encoding method pre and post conditions.
to obtain these constraints zoomin runs daikon which is an inference engine that can synthesize boolean expressions over a set of variables from a set of observations.
the generated expressions are statistically significant generalizations of theobservations reported in the trace files that is all the observations satisfy the expressions returned by daikon and there is a small probability that the expressions hold incidentally.
for instance in our experiments daikon generated the program constraint ret.imaginary!
for the method conjugate implemented in the class complex from the data recorded during the execution of the test cases available for the apache commons math library.
the program constraints derived in this phase represent the knowledge on the behavior of the class under test that has been automatically extracted from the execution of the manual test cases.
since the constraints are derived from passing executions they essentially represent the values that can be legally assigned to program variables.
of course it is not possible to completely prevent the generation of constraints that overfit the cases covered with the manual tests.
for instance in our experiments zoomin derived the over fitting constraint in.real !
ret.real for method divide complex in implemented by class complex it is clearly false that the real part of the divisor parameter in and the real part of the result return value ret cannot be the same.
zoomin handles over fitting constraints by keeping track of the executions used to derive them and employing the constraints only in comparable contexts.
intuitively an overfitting constraint is an accurate constraint in the restricted context used to derive it.
to enable this analysis zoomin uses the notion of coverage profile the coverage profile of a method mis defined as the set of statements that have been executed until reaching an exit point of m. zoomin records the coverage profile for all the executed methods.
as shown in step of figure once the execution of the manual test suite is completed each method of the class under test is associated with a set of program constraints representing method pre and post conditions and a set of coverage profiles these constraints are expected to hold for executions similar to the collected profiles .
iv.
d etecting constraint violations in the second step zoomin looks for evidence of failure in the automatic tests.
to this end it runs the automatic test cases and checks executions with the program constraints derived in step from the manual test cases.
every variable value that violates a constraint is an anomalous value which is interpreted as an evidence of failure.
for instance if an automatic test case causes conjugate to return an object of type complex with the fieldimaginary set to the value is considered anomalous because it violates the constraint ret.imaginary!
derived in step .
similarly if an automatic test case divides two imaginary numbers and the real part of the resulting number is the same as the divisor the values are considered anomalous because they violate the constraint in.real !
ret.real for method complex.divide complex in derived in step .
anomalous values can be generated for two reasons.
the first reason is that there is a fault in the program and whenthe fault is executed the application assigns wrong values to program variables.
the second reason is that the constraint is inaccurate and new legal executions incidentally produce values that violate the constraint.
clearly only the first class of violations are useful to zoomin.
zoomin filters out violations caused by inaccurate constraints by taking into account the characteristics of the executions that produced the violations.
if the execution is too different from the executions that have been used to generate the constraints the anomalous value is likely to be a new legal value produced by an untested scenario rather than a symptom of program failure.
thus the anomalous value should be dropped.
to enable this filtering strategy zoomin collects the coverage profiles associated with constraint violations.
in particular given an automatic test tthat executes a method mwith parameter and return values that violate a constraint conm i.e.
cis either a m s pre or post condition the coverage profile of the constraint violation is defined as the set of statements executed by tuntil exiting method m. note that the definition of coverage profile for constraint violation matches the definition of method profile given in section iii.
at the end of this step for every constraint violation detected during the execution of the automatic tests zoomin identified the violated constraint the anomalous values that violate the constraint and the coverage profile of the constraint as illustrated in the step of figure .
v. f iltering constraint violations in the third step zoomin filters out the constraint violations that should not be interpreted as evidence of failure.
the idea is that only the constraint violations detected while running the automatic tests that cover cases similar to the cases already covered by the manual tests are likely to indicate a problem in the program.
in the practice for each constraint violation detected during the execution of the automated tests see step zoomin compares the coverage profile of the violation with the coverage profiles recorded while running the manual tests see step .
more formally given a constraint violation cv detected by a program constraint cassociated with method m i.e.
cis either a m s pre condition or m s post condition zoomin compares the coverage profile associated with cvto the collected coverage profiles.
note that the coverage profile ofcvincludes statements in the body of meven if cis a precondition.
this is useful to discard the constraint violations generated by pre conditions violated with legal invocations that activate behaviors of mthat have been never executed before.
the comparison between two profiles returns a value in the range that defines the similarity between the profiles.
if none of the profiles is similar enough to the profile associated with the anomalous value the anomalous value is dropped.
zoomin uses the jaccard similarity index to compute the degree of similarity dos between two profiles.
formally given two coverage profiles prof1andprof2 the dos is dos prof1 prof2 stms in prof1 stms in prof2 stms in prof1 stms in prof2where stms indicates of the set of statements in a profile.
the jaccard index is a popular formula used to measure similarity between two finite sets.
in this case it computes the number of statements that are present in both profiles divided by the total number of statements in the profiles.
zoomin compares profiles to take decisions about constraint violations.
more formally given a profile profilecvassociated with a constraint violation cvand given a set of coverage profiles profiles the constraint violation cvis discarded if the following condition holds 69profile2profiles s.t.
dos profilecv profile that is the constraint violations detected with a coverage profile that shares less than of the statements with the most similar coverage profile collected by executing the manual tests are dropped.
the constraint violations that are not dropped are significant and used in step of the technique.
we set the threshold for filtering to 75based on our early empirical results.
we did not notice big changes on the results for small changes to the threshold.
a more extensive study aimed at empirically defining an optimal value for this parameter is part of our future work.
vi.
r anking assertions in the fourth step zoomin splits the assertions into two disjoint sets the safe assertions and the unsafe assertions.
the unsafe assertions are ranked according to their suspiciousness score which is a positive number that represents the likelihood the assertion is wrong.
since an automatically generated assertion encodes the behavior observed when running an automatic test the likelihood the assertion is wrong depends on the correctness of the execution produced by the test.
the rationale implemented in zoomin is that the more constraint violations are generated by an automatic test the more likely the assertions in the test capture a wrong behavior.
since zoomin runs the analysis at the granularity of the individual assertions not all the constraint violations generated by a test are relevant to every assertion.
zoomin discovers what constraint violations impact on what assertions using dynamic data flow analysis.
a constraint violation is relevant to a given assertion only if the anomalous values that violated the constraint contribute to the definition of the assertion.
zoomin discovers the anomalous values that contribute to the definition of the assertions in the automatic tests looking at dynamic data flow chains .
more formally we say that a variable vis defined by a statement eifesets the value of v. a variable vis used by a statement eifeaccesses the value of v. zoomin detects a dynamic def use pair when the execution of a test case produces the definition of a variable vand successively the use of the same variable v without redefining the value of vbefore the use.
zoomin detects a dynamic def use chain between variable vand variable wwhen the execution of a test produces a sequence of def use pairs hdi uiii n with d1definition of variable v ui di 8i n 1pairs ofuses and definitions produced by the same statement and un use of variable w. intuitively variables vandware connected by a dynamic def use chain if vcontributed to determine the value of win a concrete execution.
an anomalous value related to variable vis said to impact an assertion adefined in the automatic test tif the execution of t produces a def use chain that connects vto any of the variables used in the assertion a. a constraint violation cvaffects an assertion aonly if the anomalous values that generated cvimpact the assertion a. according to this definition each assertion in an automatic test can be associated with a possibly empty set of constraint violations that affect it.
for instance step in figure shows the case of two assertions one affected by one constraint violation and another affected by two constraint violations.
the assertions affected by no constraint violation are considered safe and dropped from the analysis.
the rest of the assertions are considered unsafe .
zoomin ranks the unsafe assertions according to the number and severity of the constraint violations that affect them.
since erroneous behaviors are not frequent in well tested software zoomin determines the severity of each constraint violation according to its observational frequency .
in particular the more frequently a constraint is violated the less the violations produced by that constraint are informative.
on the contrary tricky behaviors and erroneous corner cases are not expected to occur frequently.
to capture this intuition zoomin weights each constraint violation with a value in the range that we called uniqueness score .
given an automatic test suite atc and a constraint violation cvproduced by a constraint c the uniqueness score us of cvis defined as follows us cv viol c atc where viol c atc is the number of times the constraint cis violated by the automatic tests in atc.
the uniqueness score is used to properly weight the constraint violations when computing the suspiciousness of an assertion.
in particular given an assertion aand a set constraint violations cviwithi n that affect a we define the suspiciousness sosp ofaas sosp a pn i 1us cvi note that the value of the suspiciousness is not bounded and can arbitrarily increase depending on the number of constraint violations that affect the assertion and their uniqueness scores.
the suspiciousness value of the assertions in the automatic tests is used to generate a ranking.
zoomin does not aim to discover all the wrong assertions in the automatic tests but it is designed to focus the attention of the developers on the highly suspicious assertions that are likely to reveal new faults in the program when inspected.
although developers could inspect an arbitrary number of assertions following the ranking e.g.
all the unsafe assertions according to our experiments we recommend using zoomin to inspect no more than the top five assertions .
in this way the inspection effort is low and the effectiveness of the approach high.for example in the apache commons math library zoomin ranked the following assertion at the third position assertfalse complex2.equals complex1 withcomplex1 equals to and complex2 assigned with the conjugate of complex1 which is by definition still .
this wrong assertion exposes a fault in the program.
the fault has been covered by the automatic tests but would go unnoticed if this assertion is not inspected and fixed.
note that in our experiments zoomin automatically selected this assertion among assertions generated by evosuite.
vii.
e mpirical evaluation in this section we briefly illustrate the tool that we used for the empirical evaluation we present the subjects used for the evaluation and then we present a study that investigates the effectiveness of zoomin using more than assertions and six real life non crashing faults.
the study considers multiple inspection strategies and includes an empirical comparison between zoomin and classic anomaly detection.
early results demonstrate that zoomin can restrict the set of assertions that must be inspected to less than .
of the overall set of generated assertions and reveal of the faults while regular anomaly detection ineffectively selected more than of the assertions for inspection.
we also discuss zoomin qualitatively presenting one of the studied faults in detail.
we finally discuss threats to validity.
prototype implementation our zoomin prototype is implemented in java and integrates different third party libraries and tools.
program variables are monitored using the tptp probekit while execution profiles are collected using the jacoco library .
daikon is the inference engine used to derive program constraints from traces .
runtime checking of constraints generated with daikon is again implemented with tptp.
dynamic data flow analysis is implemented using the eclipse java development tools jdt .
finally we used the evosuite test case generator which is a test case generation tool that can synthesize test cases with assertions.
table i real faults investigated with zoom in class name bug id bug descriptor complex math browse math mathutils math browse math max math browse math min math browse math openmaprealvectormath browse math randomdataimplmath browse math subjects for the purpose of the evaluation we selected the apache commons math library which is a popular open source library available with a suite of test cases and with several publicly documented bugs.
to identify the specifictable ii results obtained with real faults classmanual testsconstraintsconstraint violationstestsassertionspositiontotal class tests total class cov all filtered all unsafe complex mathutils max min openmaprealvector randomdataimpl faults and classes for our study we selected all the bugs in the apache commons math bug repository that fulfill the following three criteria belong to either version .x or .x are not revealed by the commons math test suite and fail without generating crashes or uncaught exceptions but simply generating wrong outputs.
we then generated the unit tests for the classes with the faults using evosuite.
evosuite generated tests and assertions and has been able to cover non crashing faults.
we say that a test covers a fault if it executes the lines that have been modified in the official fix of the fault and at least one of its synthesized assertions fails when executed on the fixed version of the program.
table i shows for each fault the class containing the fault the bug id and the url pointing at the corresponding bug report.
note that none of these faults can be automatically revealed by state of the art test case generators.
in our evaluation zoomin addresses these faults by working on a set of assertions.
evaluation with real faults we applied zoomin to the subjects cases and manually inspected the ranked assertions to evaluate the technique.
table ii shows the results.
column class indicates the class with the fault.
column manual tests provides information about the manual test suite.
column total class tests reports the size of the entire test suite and the number of test cases that cover the class with the fault.
column total class cov reports the statement coverage achieved by the manual test suite on the whole library and on the class with the fault only.
column constraints indicates the number of program constraints i.e.
method pre and post conditions generated by zoomin when executing the test cases distributed with apache commons math.
column constraint violations all indicates the number of constraint violations detected by zoomin when executing the tests generated with evosuite.
column constraint violations filtered indicates the number and percentage of constraint violations used by zoomin to identify and rank the unsafe assertions the rest of the violations have been automatically filtered out by zoomin using execution profiles.
the column tests indicates the number of tests generated by evosuite.
the column assertions all indicates the number of assertions generated by evosuite.
the column assertions unsafe indicates the number and percentage of assertions that zoomin classified as unsafe.
finally column position indicates the position in the ranking of the first assertion that points at the fault in the program.
in case the assertion has the same ranking as other assertions the position is obtained by referring to the average case.
for instance if both thewrong assertion and a correct assertion are at position of the ranking the reported value would be .
.
the value between parentheses indicates the percentage of the generated assertions that need to be inspected before reaching the wrong assertion.
the symbol indicates that no assertion pointing at the fault is part of the ranking.
zoomin generated a variable number of constraints depending on the complexity of the case.
for instance it generated more than four thousands constraints for complex while it generated constraints for min.
the reason for this largely different results is the complexity of the parameters and return values that occur in the cases.
when methods exchange several complex objects that recursively include attributes that are objects zoomin recursively records the values of all these attributes and exploits them to generate many program constraints.
on the contrary when the parameters and return values mainly consist of variables with a primitive type the number of constraints that are generated decreases drastically.
when running the automatic tests zoomin checks the executions using the constraints generated from the manual tests.
again a variable number of constraint violations have been detected.
interestingly when a non trivial number of violations have been detected zoomin always filtered out many of the violations.
for instance zoomin filtered out of the constraint violations for complex and more than of the constraint violations for mathutils min openmaprealvector and randomdataimpl .
zoomin kept the majority of the constraint violations only for max where a small number of constraint violations were already detected on the first place.
these results provide evidence of the capability of the filtering step to rule out the violations that result from incomparable executions and focus the analysis on the most relevant constraint violations .
for all the cases evosuite generated a significant number of tests and assertions.
in particular it always generated more than assertions generating up to assertions in one case.
to discover the number of wrong assertions in the tests we executed the evosuite test cases on the correct version of the classes the investigated bugs have an official fix and we discovered that for all the six cases there is only one test with a single assertion that reveals the fault .
finding the wrong assertions within such a large set of assertions is extremely demanding for developers there are only assertions that can reveal the six faults among the generated assertions .
in this challenging setting zoomin demonstrated its effectiveness.
overall zoomin isolated unsafe assertionsfrom a total of assertions.
in the individual cases the percentage of unsafe assertions ranged from to of the total number of assertions.
this strong reduction has been obtained losing only half of the wrong assertions that is zoomin effectively selected less than of the assertions preserving of the wrong assertions .
in some cases the developers might decide to inspect all the unsafe assertions such as for max andmin where the set of unsafe assertions is small unsafe assertions formax and for min .
in some other cases such as forcomplex andopenmaprealvector the number of unsafe assertions might be too large.
it is thus important to direct the developers effort toward the most suspicious assertions.
zoomin efficiently implements this capability by ranking unsafe assertions.
in fact in the three cases with a faulty assertion zoomin ranked the faulty assertion fifth in the worst case.
this means that developers could discover new faults that would otherwise go undetected by just inspecting at most five assertions per case.
if we consider the total number of assertions we started from the reduction of the search space has been dramatic ranging from to of the overall set of assertions generated by evosuite .
top.
top.
top.
top.
top.
top.
top.
top.
top.
top.
number of inspected asser ons number of revealed faults fig.
.
effectiveness of inspection strategies.
stopping criterion in the practice developers do not know if there is any fault that must be discovered by inspecting assertions thus they need a criterion to decide when stopping the inspection of the assertions.
the main purpose of zoomin is to keep the inspection activity practical at the cost of missing some faulty assertions.
thus the recommendation is to inspect an extremely small number of assertions located at the top of the ranking and then stop inspecting.
according to the early evidence collected with the study presented in this paper inspecting the top five assertions is enough to detect most of the faults.
we investigated more in details the inspection strategy by analyzing the tradeoff between the inspection effort and the number of revealed faults.
figure plots the number of detected faults and the average number of inspected assertions for different inspection strategies.
in particular we consider the top n inspection strategy that requires inspecting the nassertions at the top of the ranking.
if after having inspected nassertions there are other assertions ranked at the same position than thelast assertion that has been inspected the criterion requires developers to also inspect the equally ranked assertions.
note that the average values represented in the plot consider all the six cases including the cases where the set of unsafe assertions includes no wrong assertion.
in the plot we only consider strategies from top to top assuming that inspecting more than assertions is impractical.
results show that the top strategy is the best compromise between the capability to discover faults and the number of assertions that need to be inspected .
on average .
note that in the case of the apache commons math this strategy corresponds to inspecting only assertions from a total of assertions.
however these results cannot be yet generalized thus inspecting a higher number of assertions for instance by applying the top or top strategy could be a safer option.
note that in our evaluation the top strategy requires inspecting less than assertions because the total set of unsafe assertions is often smaller than .
table iii comparison between zoom in and anomaly detection approach bugs inspected assertions zoomin top .
zoomin top .
anomaly detection .
comparison to anomaly detection we compared the effectiveness of zoomin to classic anomaly detection.
as already done in other studies we use anomaly detection to learn the legal behavior of the application i.e.
we learn the method pre and post conditions using daikon when the manual tests are executed and then we check the executions of the automatic tests against the inferred constraints.
the tests and the assertions included in these tests that violate the inferred constraints are reported to the user.
in practice anomaly detection implements the learning and the checking ability of zoomin but does not include any of the other capabilities that characterize zoomin such as the ability to collect coverage profiles the ability of identifying soundly comparable executions based on the profiles and the ability to correlate constraint violations to assertions.
results are reported in table iii.
for zoomin we report the results obtained applying both the top strategy which is the most effective strategy for apache commons math and the top strategy which represents a more conservative choice for the inspection strategy.
we can notice that although anomaly detection can detect all the faults it requires the inspection of a so large number of assertions that the result would not be practically useful in any context assertions must be inspected .
these results confirm the empirical observations reported in other papers such as .
on the contrary zoomin detected half of the faults with a manageable inspection effort or assertions must be inspected corresponding to .
or .
of the generated assertions depending on the strategy that is applied.
qualitative analysis to qualitatively demonstrate the ability of zoomin to identify the wrong assertions based onanomalous values we discuss more in details one of the cases considered in our empirical evaluation.
listing shows the code of one of the tests generated by evosuite for the complex class.
the test covers a bug in the complex class and includes a wrong assertion.
we indicated the wrong assertion with the comment wrong .
in our evaluation zoomin has been able to rank this assertion as a highly suspicious assertion it occurs at position of the ranking among more than generated assertions.
listing .
sample test generated by evosuite test public void t e s t throws throwablef complex complex0 complex .
i complex complex1 complex0 .
m u l t i p l y complex0 complex complex2 complex1 .
c o n j u g a t e a s s e r t e q u a l s .
complex2 .
abs .
1d a s s e r t e q u a l s .
complex2 .
g e t r e a l .
1d a s s e r t f a l s e complex2 .
e q u a l s complex1 wrong a s s e r t e q u a l s .
complex1 .
g e t r e a l .
1d g the fault that causes the generation of a wrong assertion is in the equals method of the complex class which returns a wrong result when an imaginary number with as imaginary part is compared to an imaginary number with the same real part but with as imaginary part.
the test generated by evosuite interestingly covered this situation through a non trivial sequence of method calls.
variable complex0 is initialized to the imaginary number i. the variable complex1 is then assigned to with as real part and as imaginary part as a consequence of the call to multiply .
the next invocation to method conjugate assigns to complex2 the conjugate of which is still with as real part and as imaginary part .
although the sign of the imaginary part should be ignored when comparing the two numbers the implementation of equals compares the bit level representations of these two numbers thus incorrectly taking into account the sign even if the compared value is .
zoomin ranks this assertion as a highly suspicious assertion because it is impacted by violated constraints with high uniqueness scores.
the two impacting constraints with the highest scores are returnvalue.imaginary !
and returnvalue.i.real !
returnvalue.imaginary both of them are associated with method conjugate of class complex .
since conjugate is the method that produces the number with as imaginary part the constraint violations exactly characterize the execution that produces the failure among all the executions of the class complex .
to determine the presence of a fault in the program the developer is only asked to inspect the test.
there is no need to inspect the execution trace or to look at the constraint violations that determined the ranking of the assertion.
for instance in this case it is enough to follow the test to see that complex1 andcomplex2 are both and thus the method equals must return true and not false as asserted in the test.
threats to validity the most relevant threats to validity concern internal and external validity.the main threat to the internal validity is related to the existence of a causal relation between the effectiveness of zoomin and its capabilities that is the capability to filter out the irrelevant constraint violations to filter out likely safe assertions and to create the ranking.
since it was not feasible to manually inspect all the constraint violations and all the executions considered in the study we addressed this threat by manually inspecting of the violations that have been filtered out and inspecting all the constraint violations associated with the assertions that revealed faults in the program.
the inspection of the discarded constraint violations confirmed that these violations are typically not related to any fault in the code but are related to over fitting constraints.
the inspection of the violations associated with the assertions that revealed the faults confirmed that the assertions have been properly ranked thanks to multiple well scored constraint violations that are clearly caused by the fault.
the case discussed in the previous section is a practical example of the way zoomin works.
we can thus claim that according to the early empirical evidence that we obtained the effectiveness of zoomin is directly related to the effectiveness of its heuristics.
the main threats to external validity relate to the generalizability of the results to other applications and test suites.
the good results obtained with different real faults mitigate this threat.
however more studies with more subjects and test suites need to be completed to claim the generalizability of the results to other classes of applications.
in the empirical evaluation reported in this paper we used evosuite as test case generator.
although we do not see any strong reason why the effectiveness of the technique should not generalize to other test case generators that synthesize assertions this aspect should be confirmed empirically.
viii.
r elated work in this section we discuss approaches for automatically detecting failures with special emphasis on techniques that do not require user defined oracles.
anomaly detection anomaly detection techniques analyze sets of executions to identify the ones that are anomalous i.e.
that differ significantly compared to the other executions in the set.
the assumption of anomaly detection techniques is that the executions that exhibit anomalous behaviors are also the ones that are faulty.
different techniques look at different aspects to determine what the anomalous behaviors are.
for instance zheng et al.
mine predicate rules that represent the conditions that hold at relevant program points such as branches and exit points .
the executions that violate these rules are classified as potential failures.
in a similar way raz et al.
mine constraints on the values returned by online data sources .
anomalous values are discovered by comparing newly collected data to the mined constraints.
other approaches identify anomalous executions by looking at the sequences of operations executed by an application rather than looking at the values assigned to variables.
for instance several techniques mine finite state models fromexecution traces and use these models to assess the correctness of newly collected executions .
anomaly detection techniques can easily generate many false alarms especially when applied to the oracle problem as demonstrated in a recent study .
in contrast with these approaches zoomin can isolate an extremely small number of assertions that require inspection thus always maintaining manual effort under control.
moreover assertions can be cheaply evaluated by inspecting the tests only while inspecting an entire execution isolated by a classic anomaly detection technique might be far more expensive.
spectra based techniques spectra based techniques compare executions according to a specific aspect of the program behavior.
the ability to compare executions can be exploited to cluster test cases and identify failing runs.
for instance yilmax et al.
show that hybrid program spectra can be effectively used to train a j48classifier that distinguishes passing and failing executions .
lo et al.
investigate the use of support vector machines trained with passing and failing executions to classify unknown executions .
the main limitation of these approaches is that they require a set of passing and failing executions to train the classifiers.
zoomin does not need to be trained with sample failing executions that are difficult to be obtained for multiple applications and multiple types of failures but it can be applied relying uniquely on the manual tests designed by the developers.
dickinson et al.
investigate the classification of unknown executions using unsupervised hierarchical clustering .
since failures are assumed to end up in clusters that only contain failures developers can inspect the output produced by this technique by inspecting one execution per cluster.
the technique by dickinson et al.
requires estimating the number of clusters that must be returned by the clustering algorithm.
an optimal estimate is difficult to produce and suboptimal choices might significantly impact the quality of the results.
if many clusters are generated a significant inspection effort is required while producing few clusters might lead to clusters that mix up failing and passing executions.
zoomin does not require these kinds of estimates and it always requires the inspection of a few assertions only.
specification based oracles software specifications have been extensively exploited to generate test oracles.
for instance carzaniga et al.
recently investigated how to generate oracles from a specification of the equivalent sequences which is a specification that indicates the sequences of method calls that have the same effect on an object state .
in some cases the specification can be part of the program.
for instance artoo uses contracts to generate tests and detect faults .
specification based approaches are extremely effective but require suitable specifications to be applied .
unfortunately specifications are often unavailable and when they are available are often incomplete outdated and inconsistent.
zoomin supports testers in the common case no specification suitable for the generation of program oracles is available.
test driven oracle generation several test case generation techniques can generate test cases that include assertions thatencode the observed behaviors such as randoop and evosuite .
techniques that produce a small but effective set of assertions have been also investigated .
zoomin augments these techniques with the capability to identify the assertions that are likely wrong due to faults in the program.
some approaches investigated the integration of test case generation and failure detection.
for instance eclat and dsdcrasher can augment an existing test suite with test cases that are likely to expose failures by causing executions that violate methods post conditions without violating methods pre conditions.
pre and post conditions are generated with daikon.
since this strategy can generate several false positives dsdcrasher only reports the program crashes.
compared to these approaches zoomin is more precise because it limits the number of false positives that are generated while maintaining the capability to reveal non crashing faults and more accurate because it works at the granularity of assertions instead of entire executions.
human centric approaches while specifying program oracles e.g.
writing assertions is a relatively simple activity for testers it is an extremely challenging task for computer programs.
for instance a recent study by staats et al.
demonstrated that developers may easily misclassify automatically generated invariants .
pastore et al.
early investigated how to involve humans in the synthesis of program oracles by using crowdsourcing to fix the assertions automatically generated by evosuite .
the results show that this solution is feasible although the performance of the crowd depends on the complexity of the domain and the economical advantage of this solution depends on the number of tests and assertions that must be inspected.
zoomin does not require the inspection of many daikon invariants and does not involve non experts in the process as potentially done by crowdsourcing.
zoomin only requires the developers of the application to inspect a few specific assertions generated by test case generation tools.
ix.
c onclusions test case generation techniques can automatically generate test cases that include assertions encoding the behavior observed when running the tests.
thus if a test reveals a fault that makes the program fail by producing a wrong output the synthesized assertion instead of detecting the failure will encode a wrong condition.
this fact significantly reduces the fault detection capability of test case generation techniques.
in this paper we presented zoomin a technique that can augment test case generators with the capability to pinpoint the assertions that are likely incorrect due to the presence of faults in the program.
the empirical results obtained by integrating zoomin with evosuite demonstrated the effectiveness of the approach.
in particular the most effective inspection strategy identified of the faults in the program by inspecting less than .
of the assertions synthesized by evosuite.
future work includes gaining experience with zoomin with other faults applications and test case generators to increase confidence on the generality of the results obtained so far.acknowledgment this work has been partially supported by the fonds national de la recherche luxembourg fnr p10 .