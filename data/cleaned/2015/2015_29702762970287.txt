visual contract extractor a tool for reverse engineering visual contracts using dynamic analysis abdullah alshanqiti reiko heckel department of computer science university of leicester uk amma2 leicester.ac.uk reiko mcs.le.ac.uktimo kehrer department of electronics information and bioengineering politecnico di milano italy timobenjamin.kehrer polimi.it abstract visual contracts model the operations of classes components or services by pre and post conditions formalised as graph transformation rules.
they provide a precise but intuitive notation to test document and analyse software systems.
however due to their detailed level of speci cation of data states and transformations modelling a real application is a complex and error prone process.
rather than adopting a top down modelling approach we follow a dynamic bottom up approach to reverse engineer visual contracts from object oriented programs based on tracing the execution of operations.
we developed the visual contract extractor vce a dynamic analysis tool which supports the reverse engineering of visual operation contracts from java programs.
we explore the main features of the tool using two case studies and discuss usage scenarios ranging from traditional program understanding to novel applications in the eld of model based engineering.
a screencast demonstrating the tool is provided at ccs concepts social and professional topics !software reverse engineering software and its engineering !dynamic analysis model driven software engineering visual languages software testing and debugging object oriented development keywords visual contracts graph transformation model extraction dynamic analysis reverse engineering speci cation mining .
introduction visual contracts vcs support high level behaviour modelling of software operations .
they consist of a pair of conditions that describe a system s state relevant to aspeci c operation before pre condition and after postcondition execution.
the pre condition speci es the conditions which must be ful lled such that the operation can be executed while the post condition declaratively describes its e ects .
based on a formal representation as graph transformation rules vcs can be used for model based oracle and test case generation run time monitoring as well as simulation and formal veri cation .
however visual contracts are complex to be modelled manually.
due to their detailed speci cation of data states and transformations they are closer to the implementation level than other modelling approaches such as state machines or uml sequence diagrams.
therefore reverse engineering them from implementations as a bottom up approach is a promising alternative to top down modelling of vcs and provides a valuable tool for program understanding.
the extraction of behavioural models from implementations can be performed statically by examining the source code to capture all possible behaviours .
however dynamic binding in object oriented software a ects the accuracy of static methods often leading to an over approximation of e ects or dependencies.
instead we follow a dynamic approach to reverse engineer visual contracts from object oriented programs based on tracing the execution of operations.
to that end we developed the visual contract extractor vce a dynamic analysis tool which supports the reverse engineering of visual operation contracts from java programs.
the resulting contracts give an accurate description of the observed object transformations their e ects and pre conditions in terms of object structures parameter and attribute values and allow generalisation by learning multi objects.
fundamental concepts and techniques of our approach have been published in previous work while this paper focuses on implementation and tooling.
in addition we discuss two novel application scenarios for our tool in the eld of modelbased engineering namely the use of visual contracts for model based or visual debugging as well as the automated learning of complex model editing operations by examples.
the paper is structured as follows.
sect.
brie y explains the overall approach and the architecture of the proposed tool.
in sect.
we explore the main features of the tool using two case studies focusing on its use in the context of program understanding while sect.
discusses two novel application scenarios in the eld of model based engineering.
related work will be reviewed in sect.
and sect.
concludes the paper along with an outlook on future work.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
.
extraction of visual contracts sect.
.
brie y explains our overall approach parts of which have been published in previous work .
sect.
.
provides an overview of our integrated tool the visual contract extractor vce and its high level architecture.
.
approach the extraction of visual contracts proceeds in three main steps as illustrated in fig.
.
the rst step a extracts actual behaviour by tracing yielding an instance level version of visual contracts referred to as contract instances orrule instances from each operation invocation.
we dynamically observe system execution as proposed in .
the java source code of a system is instrumented by weaving trace instructions using aspectj .
when being executed they result in a log recording object creation read and write access to objects and attributes etc.
we construct contract instances from such a log that capture the overall pre condition and e ect of the execution.
these contract instances describe only partial behaviour of the system i.e.
the model obtained is valid for the scenario that has been executed.
in step b we use our learning approach introduced in to generalise extracted contract instances.
this depends formally on typed attributed graph transformation rules and uses sub graph matching algorithms for learning.
for each contract instance we derive a so called minimal rule i.e.
the smallest rule able to perform the given transformation.
the generation of minimal rules results in a partitioning of instances by e ect all instances with the same minimal rule have the same e ect but possibly di erent preconditions.
to construct a maximal rule for each of these partitions we identify their common context elements i.e.
a maximal rule contains all the context that is present in all instances.
finally in step c we further increase generality of rules by inferring multi objects mos and attribute conditions adopting the inference approach presented in .
multi objects support universal quanti cation over unknown contexts in a rule.
in the case of iteration over collections for example the set of minimal rules is potentially unbounded but many may only di er in the number of objects being manipulated while performing the same actions across all of them.
rules with mos provide a concise way to specify constraints and actions across a set of objects of unknown cardinality.
in order to derive attribute conditions we use the dynamic invariant detection tool daikon that takes the actual data values of attributes and parameters obtained from the trace logs during the construction of rule instances as input and produces invariants in terms of logical formulae over attribute and parameter variables as output.
the produced invariants are used to increase the accuracy of generalised contracts particularly of maximal rules by including precise conditions on attributes and parameters.
in general contracts extracted by our dynamic approach will be neither correct i.e.
they may allow behaviour that is not implemented by the system nor complete i.e.
not all the system s behaviour may be captured by the extracted contracts .
correctness depends on the selected scope while completeness is linked to code coverage obtained when executing and observing the system.
the degree of correctness and completeness which needs to be achieved depends on the particular use case of the vce tool.
figure overall picture of the vce tool.
.
vce s architecture the architecture of the vce tool see fig.
comprises the following components a the tracer observing the behaviour of selected classes using aspectj and constructing contract instances b the generaliser for generalising contract instances to minimal and maximal rules c the inferencer for learning mo rules and attribute conditions using daikon d the visualiser for selective display and analysis of contracts and e an export facility particularly to the model transformation tool henshin for generating executable contracts.
vce relies on a mysql database as back end to e ciently handle large numbers of contracts.
to selectively trace a huge java program the tracer can be con gured i by selecting the relevant classes to de ne the scope of object types and ii by identifying methods of interest as each invocation of these methods will produce a single contract instance covering those objects which are typed over the selected classes.
in the remainder of the paper we focus on the visualiser with its main usage scenario of supporting program understanding and on the export facilities of the tool notably the export to henshin.
visualiser the main task of the visualiser see fig.
for its main user interface is to organise browse and display extracted contracts.
we support i the distinction in colour and style between elements of the minimal and maximal rule dotted edges and nodes with coloured background green for creation red for deletion and light golden for nodes with updated attribute values represent elements of minimal rules while nodes with white background and solid edges are context elements ii the alternative display of collections as to associations or using explicit collection objects iii the selective visualisation of rules e.g.
the minimal rule or the pre condition only with the exibility to change graph layouts and iv user interaction to con rm if inferred features are correct.
export to interface with the tool contracts can be exported to standard formats such as gxl or dot graphs.
most notably vce supports the export of generalised rules to henshin a model transformation language and system which is based on graph transformation concepts .
a visualisation of a contract instance b visualisation of a generalised rule figure graphical user interface of vce s visualiser component.
.
case studies in this section we illustrate the main features of the vce tool using two case studies nanoxml1 a non validating xml parser for java which provides a light weight way to manipulate xml documents and jhotdraw2 a customisable java gui framework for technical graphics editing.
the selected case studies are popular benchmarks for software testing and analysis and representative for the kind of system our method is appropriate for i.e.
they show signi cant and dynamic object structures in their object oriented core model.
in nanoxml this is the object representation of the xml tree for jhotdraw that of graphics objects.
nanoxml for conducting our experiments with nanoxml we use version .
.
which consists of three packages and java classes.
we focus on classes xmlelement and xmlattribute and select all xmlelement methods to generate contracts from them.
these classes provide the functionalities to manipulate xml documents.
we monitor execution of test cases generated by codepro3 some of which are modi ed manually to improve code coverage.
.
.
visualisation of contract instances fig.
shows two screenshots of vce s main user interface.
in a we present an instance extracted from an invoca3 818figure object access and code locations.
tion of operation xmlelement.setattribute string string string which represents in a pair of object graphs the preand postcondition.
this instance describes the creation of a new xmlattribute object and its incoming edge to link it with the existing vector object and the update of attribute vector.size .
the upper part of a gives information on the operation signature actual parameters and the extraction process.
in addition to the visual presentation of instance s pre and postcondition i.e.
relevant subsets of the program s object graph before left and after right the invocation of an operation we provide information on the access to individual objects with the corresponding locations in the source code.
they are available through a pop up window like the one in fig.
activated by clicking on the xmlattribute node in the right hand side of the instance in fig.
a .
.
.
visualisation of generalised rules fig.
b shows how generalised rules are displayed.
the top left shows a list of all rules organised by their operation signatures.
when selecting e.g.
a maximal rule all its constituting contract instances will appear in the table see the top right of b .
the lower part shows the maximal rule for xmlelement.addchildren ixmlelement .
an example of a rule with multi object is shown in fig.
as extracted from the maximal rule in fig.
b .
here one of the nodes of type xmlelement represents a multiobject shown with a 3d shadow .
the rule allows to add an arbitrary amount of xmlelement nodes as child of another xmlelement all the children being indexed by a vector .
figure a generalised rule with multi object.
.
.
export to henshin figure shows the generalised rules extracted from our experiments with nanoxml exported into the format of the model and graph transformation framework henshin .
in particular a maximal rule extracted for operation addchild .. is depicted in the visual syntax of the henshin transformation language.
in general this notation shows transformation rules in an integrated form the left and right hand sides of a rule merged into a single graph.
the left hand side lhs comprises all model elements stereofigure export of generalised rules to henshin.
typed by delete andpreserve the right hand side rhs contains all model elements annotated by preserve andcreate .
the integration with henshin allows i to evaluate and execute extracted contracts and ii to use the tool more widely in the context of model based engineering see sect.
.
.
jhotdraw for experimenting with jhotdraw we use version .
which has classes.
concerning the tracing instrumentation we select all classes to de ne the scope of object types focusing on the top level methods for the manipulation of drawings such as .addfigure .. .deletefigure .. .copyfigure .. .decoratorfigure .. and all undoable actions in .commandmenu.actionperformed comexe .
we use the gui testing tool windowtester4to generate test cases by recording user interactions.
.
.
simplification of complex contract instances the vce tool provides visualisation options that may be employed to view complex contracts.
as an example consider fig.
which shows a very complex contract instance extracted from an invocation of deletefigure .. after analysing objects.
details are shown in the upper part of a and b gives an impression of the overall size of the lhs best viewed with maximal zoom .
for better understanding such contract instances can be generalised by inferring a rule with multi objects and by just displaying minimal elements i.e.
hiding context elements that have no e ects.
as illustrated by the selective display shown in fig.
c which has been automatically generated by the tool upon request complexity can be reduced signi cantly.
.
.
rules with attribute conditions fig.
shows a maximal rule with inferred attribute conditions extracted from addfigure .. .
attribute conditions are shown in a separate dialogue window for selected nodes.
for example the 4th constraint in the popup window for the selected lhs node of type bouncingdrawing states that the value of its attribute thequadtee must remain with no change in the post graph n12661l pre thequadtree n12661r post thequadtree .
.
further applications in the previous section we illustrated how our tool can be used to aid program understanding.
moreover the integration with henshin turning visual contracts into executable a large contract instance with trace information b lhs c selective display of a generalised rule figure large contract instance and generalised rule extracted from deletefigure .. .
transformation rules allows us to evaluate and apply contracts more widely e.g.
as proposed in the context of modelbased testing .
in this section we brie y sketch two novel usage scenarios.
in sect.
.
we discuss the usage of dynamically extracted visual contracts for a new debugging paradigm which can be considered as visual or model based debugging.
sect.
.
proposes an approach to generate complex model editing operations automatically from examples.
.
visual debugging traditional debugging as supported by an ide such as eclipse allows programmers to interactively inspect and trace the dynamic behaviour of a program.
it requires to dene in advance breakpoints to hold execution at a certain point allowing to observe and investigate accessed objects variables and their actual values.
to apply this technique for tasks such as localising faults it needs su cient precision in identifying breakpoints which may be an intricate task.
de ning many breakpoints or a breakpoint inside a loop is usually not practical as it may lead to either stopping the execution many times or observing similar details with minor di erences at each stop.
in the worst case programmers single step through instructions and observe changes to the program state.
using extracted visual contract instances can serve as an alternative approach which can be considered as visual debugging .
the idea is to exploit the debugging interface provided by the java virtual machine to generate program snapshots which can be visually inspected.
this raises the level of abstraction from implementation based debugging to model based debugging.
accompanying trace information nally helps to localise faults in the source code.
the advantages of debugging at the model level have been discussed in the literature e.g.
in .
existing approaches figure a rule with attribute conditions.
however mainly focus on debugger frameworks for dedicated domain speci c languages and are not applicable to mainstream java programs.
the monitoring approach presented in shares similarities with our idea but we plan to investigate the usability and scalability of using visual contract instances as an ide plug in for debugging.
.
learning model editing operations complex editing operations such as model refactorings are a valuable con guration parameter for many tools in model driven engineering mde e.g.
to continuously improve model quality using refactoring tools or to describe the changes between two versions of a model in a meaningful way .
however mde platforms such as the eclipse modeling frameworko er only a generic low level api for model modi cation.
likewise editing operations generated from meta models e.g.
as proposed in are still primitive.
complex operations can be implemented manually or by specifying their e ect as a model transformation.
both approaches require a deep understanding of the meta model and its relation to the concrete syntax thus being only accessible to tool developers and language designers.
our approach can be used to learn complex editing operations automatically from examples speci ed by domain experts.
an example of a complex editing operation i.e.
the model states before and after a model refactoring can be speci ed using standard model editors.
example models are transformed into the graph representation of the vce tool generalised to transformation rules and nally exported to henshin.
the exported transformation rules can be integrated as complex editing operations in model editors.
in contrast to previous model transformation by example proposals requiring manual processing or augmentation of generated operations at the abstract syntax level our aim is to stick entirely to the concrete syntax notation domain experts are familiar with.
.
related work to the best of our knowledge the work presented in this paper is the rst that presents an integrated tool for inferring visual contracts with advanced transformation rule features from system s operations.
from a broader perspective tools comparable to ours can be found in the wide eld of reverse engineering.
among them we particularly have to mention tools for extracting models from implementation artefacts e.g.
reverse engineering of uml sequence diagrams activity diagrams entity data models from databases or graph grammars based on call graphs .
technically the generalisation of contract instances is related to the task of semi automatically learning rules from model transformations .
we go ahead by supporting in820ference of advanced rule features such as multi objects and attribute conditions.
moreover we support a fully automated inference of transformation rules while the process presented in relies on manual interventions e.g.
to adapt inferred pre and post conditions.
approaches for inferring invariants have been considered in component based veri cation and software testing e.g.
to address the test oracle problem or to generate logical test inputs .
we share with them the technique of using dynamic invariant detection by daikon .
.
conclusion and future work the main contribution of this paper is an integrated tool supporting the extraction and inference of visual contracts from java applications.
it provides a rich front end visualiser for selectively displaying and browsing inferred rules and is integrated with the model transformation tool henshin in order to generate executable contracts.
we illustrated how the tool supports the construction of concise and comprehensive rules and how this can aid program understanding in testing or maintenance scenarios.
finally we discussed two novel applications of our tool in the broader eld of model based engineering paving the way for two directions of future work.
firstly we intend to use contract extraction to support visual debugging evaluating its e ectiveness more comprehensively.
secondly we will use our tool for learning of complex domain speci c model editing operations.
we believe that this technology can unlock the potential for end user customisation of model editors.
.