automated refactoring of nested if formulae in spreadsheets jie zhang1 shi han2 dan hao1 lu zhang1 dongmei zhang2 1key laboratory of high con f idence so f tware technologies peking university moe beijing china 2microso f t research beijing china 1fzhangjie marina haodan zhanglucs g pku.edu.cn 2fshihan dongmeiz g microso f t.com abstract spreadsheets are the most popular end user programming so f tware where formulae act like programs and also have smells.
one well recognized common smell of spreadsheet formulae is nested if expressions which have low readability and high cognitive cost for users and are error prone during reuse or maintenance.
however end users usually lack essential programming language knowledge and skills to tackle or even realize the problem.
t he previous research work has made very initial a t tempts in this aspect while no effective and automated approach is currently available.
t his paper f irstly proposes an ast based automated approach to systematically refactoring nested if formulae.
t he general idea is two fold.
first we detect and remove logic redundancy on the ast.
second we identify higher level semantics that have been fragmented and sca t tered and reassemble the syntax using concise built in functions.
a comprehensive evaluation has been conducted against a real world spreadsheet corpus which is collected in a leading it company for research purpose.
t he results with over spreadsheets with million nested if formulae reveal that our approach is able to relieve the smell of over of nested if formulae.
over of the refactorings have reduced nesting levels of the nested if s by more than a half.
in addition a survey involving participants indicates that for most cases the participants prefer the refactored formulae and agree on that such automated refactoring approach is necessary and helpful.
introduction spreadsheets are the most popular end user programming tools .
one of the most important enabling factors is that spreadsheets provide immediate feedback so users can make a change in one place and immediately see the results .
underneath such an advantage formulae play an important role as end user friendly programs.
however end users typically lack essential knowledge and skills of programming and are easier to write formulae with bad smells .
one of the well recognized spreadsheet smells is nested if expressions .iffunctions1 i.e.
the syntax is if condition true branch f alse branch are widely used spreadsheet functions.
nested if expressions happen when end users write an iffunction inside another ifornested if function.
according to previous research nested if formulae in speadsheets are complex unreadable errorprone as well as hard to debug and maintain.
t here are also a lot of online discussions about the harm of nested if formulae.
some people have expressed their desire to reduce nested if s wherever possible .
1functions are prede f ined built in formulae already available in spreadsheet systems.what is worse the bad practice of using nested if expressions among end users is quite common our study of over realworld spreadsheets2reveals that for the worksheets containing if .
of them also contain nested if .
if we denote the maximum nesting level inside a nested if asif depth3 in our corpus each spreadsheet includes on average formulae with if depth over while the observed maximum if depth is with multiple instances.
formula refactoring is a practical solution to tackle this problem which was f irst proposed by badame and dig to perform semantic preserving formula transformations without changing the behavior with the purpose of removing formulae smells.
nevertheless such refactoring requires essential knowledge and skills of programming which is challenging for end users.
to help end users several previous works have proposed a few simple refactoring pa t terns trying to decrease the if depth but they either have very low coverage i.e.
the ratio of formulae that can be ameliorated or are non automatic.
in this paper we f irstly propose an ast abstract syntax tree based approach to systematically tackling this problem via automated refactoring.
t he general idea is two fold.
first there o f ten exists logic redundancy across different condition paths within a nested if .
reduction of the redundant logic can remove useless parts and simplify the nested if formula.
second some higher level semantics are o f ten fragmented into hierarchical combinations of if conditions in a nested if .
reassembling the fragmented syntax from corresponding if subtrees into built in functions can shorten the nested if formula.
to analyze and refactor both redundant logic and fragmented syntax our approach leverages and works on the ast abstract syntax tree structure as intermediate representation of nested if formulae.
t he evaluation is conducted on over real world spreadsheets with over million nested if formulae.
t he experimental results lead to the following three key takeaways.
first our approach is generally applicable over of the nested if formulae can be refactored and the refactor has been veri f ied as correct.
second our approach is effective over of the refactoring have achieved more than half of their if depth reduced while the nested if functions in most formulae are completely reduced or transformed with if depth .
t hird end users recognize our approach and its results.
a survey on participants indicates that most of them prefer the refactored formulae and believe the automated refactoring is necessary and helpful while only a few of them are equipped with the knowledge of manual refactoring.
t he main contributions of this paper are shown as follows.
an automated and highly effective approach to identify and refactor nested if formulae.
t he goal is to help end users 2in this paper we refer spreadsheet as a f ile consisting of one or multiple worksheets .
3e.g i f i f l1 f l1 i f l1 f l1 has an if depth of .arxiv .09797v1 dec 2017reduce the complexity and cognitive cost of nested if formulae in spreadsheets.
a comprehensive evaluation of the proposed automated approach.
we evaluated the correctness applicability effectiveness and usefulness of the approach.
a statistical study on the current usage of nested if formulae in real world spreadsheets.
we present detailed statistics ofnested if formulae against over real world spreadsheets collected in a leading it company for research purpose.
preliminary study our preliminary study aims to present the usage status of nested if formulae and to further motivate our approach.
t he investigation is based on a spreadsheet corpus including over real world excel f iles a.k.a.
spreadsheets workbooks which contain a total of over worksheets.
t he source of this corpus is a spreadsheet repository collected in a leading it company for research purposes.
and the f iles in our corpus are extracted by excluding those with technical complications as obstacles for interaction free processing e.g.
password protected external reference embedded requiring trust con f irmation .
compared to the corpora that have been widely used in previous research work the euses spreadsheet corpus enron spreadsheet corpus and hawaii kooker corpus our corpus has the following two advantages larger scale.
t he number of spreadsheets is much larger than the enron corpus euses corpus and hawaii kooker corpus .
table lists a detailed comparison between our corpus and the previous largest corpus enron4.
higher diversity regarding domains.
t he corpus contains diverse spreadsheets for various purposes across multiple domains while the other corpora either contain large numbers of toy spreadsheets or come from a single company of a speci f ic domain.
table comparison between enron and our corpus corpus enron ours total number of spreadsheets total number of worksheets average size of spreadsheets .
kb .
kb number of spreadsheets with formulae number of spreadsheets with iffunctions number of iffunctions based on this very large and diverse corpus we investigate the usage status of nested if formulae.
inside one spreadsheet many formulae may be created by dragging one formula down or to the right to repeat its calculation.
as in previous work we remove these formulae by clustering the formulae based on their r1c1 notation5.
we then pick one formula from each cluster to form the new formula set.
we call this new set the unique set and the original set the total set .
t he results are shown in table .
t he f irst two rows show the results of the formula number.
t he remaining rows show the number of formulae in different depth ranges.
column total unique 4we do not compare with the other two corpora because their f ile type is too old for python excel library openpyxl to parse.
t he r1c1 notation will stay the same even if the formula is dragged down or right.
m t mf q1 x1 q1t q1 x1t q1 x1 q1t falsefff figure ast example shows the results of the total unique set from the table among the total formulae and unique formulae over formulae have an if depth of over over total formulae and unique formulae even have an if depth of over indicating surprisingly heavy usage of nested if formulae.
table usage status of nested if formulae total unique formula number formula number per spreadsheet if depth in range if depth in range if depth in range if depth in range t his heavy usage of common nested if formulae would cause much harm as we mentioned in the introduction.
however endusers usually lack the awareness of such harm.
t hey also tend to lack enough spreadsheet function knowledge to manually refactor or avoid using nested if formulae.
consequently it is essential that automatic approaches should be constructed to help tackle these problems.
a f ter manually checking a sample of these nested if formulae6 we realize that many formulae contain unnecessary conditions which would cause dead branches7.
additionally a large part ofnested if functions actually combine together to ful f ill a certain functionality which can also be ful f illed by other high level functions already de f ined in spreadsheets like excel.
for example the following formula is a real case from our corpus if if q1 x1 q1 if q1 x1 if q1 x1 q1 if q1 x1 q1 if q1 x1 if q1 x1 .
if we use mto represent sub string if q1 x1 q1 if q1 x1 if q1 x1 q1 then the formula can be wri t ten as if m m .
to be t ter illustrate the formula structure in figure we present the general ast in the le f t as well as the ast of min the right.
from figure it is easy to tell that condition q1 x1 is redundant this condition is in the false branch of condition q1 x1 and thus is certain to be true.
additionally if m m actually equals to mno ma t ter what value mis.
if we remove these unnecessary ifexpressions the formula can be refactored into if q1 x1 q1 if q1 x1 q1 .
furthermore we can use the ifs function to transform if q1 x1 q1 if q1 x1 q1 into ifs q1 x1 q1 q1 x1 tru e q1 which is much cleaner than the original one.
inspired by this observation we propose our ast based approach to automatically accomplishing such kind of formula refactorings.
t he authors manually checked the nested if formulae in randomly sampled spreadsheets.
7a dead branch will never be executed.
approach .
overview by analyzing the ast structure of each formula our approach identi f ies optimizable nested if expressions and performs refactoring by replacing basic level and counter intuitive syntax with non redundant and high level syntax.
t he major rationale behind using ast is the desirable structural mapping between ast and nested if as follows.
an iffunction typically contains three parts condition true branch expression and false branch expression.
t herefore the asts of nested if expressions are binary trees with the true and false branch expressions being the two childnodes of the condition node.
consequently with ast it is easy to detect and locate nested if in a formula as well as convenient to conduct further analysis based on the tree structure.
in this section we f irst introduce a high level overview of our step algorithm framework followed by detailed introductions to the two key algorithms for redundancy removal and syntax reassembling respectively.
step1 ast generation.
we parse each formula and generate its ast to support the subsequent analysis.
ast is a tree representation of the abstract syntactic structure of source code wri t ten in a programming language.
in spreadsheet related research ast is usually adopted to indicate formula complexity .
t he larger depth height of the ast the higher complexity of the formula.
based on the ast of the formula we then traverse the ast and calculate the if depth .
speci f ically along each path of ast we record the number of iffunctions and regard the largest one across all paths as the if depth of the formula.
for example the if depth of formula if condition if condition v.altalue1 v.altalue2 if condition if condition v.altalue3 v.altalue4 v.altalue5 is .
anested if is identi f ied in a formula when its if depth is greater than and will be passed to the subsequent steps for refactoring analysis.
otherwise if the if depth equals i.e.
no ifin this formula or i.e.
no nested if in this formula our algorithm will bypass the formula directly.
step2 redundancy removal.
anifexpression can essentially be mapped to an if else branching statement in professional programming.
once the condition on some node remains deterministic due to its preceding evaluation at some ancestor node on ast it will become a redundant condition and one of its child branches must be dead code.
such redundant conditions are spreadsheet smells that require removal since they introduce unnecessary complications to the spreadsheet data thus may confuse end users.
we conduct such redundancy removal f irst because its existence may also obscure the ast structure from well understood pa t terns and thus put negative impact on our pa t tern matching for syntax reassembling.
more details of this step can be found in section .
.
step3 syntax reassembling.
we have observed another typical smell in real world spreadsheets where single and higher level semantics are o f ten fragmented by end user into lower level syntax pieces with nested if s. in fact for such semantics there are concise and easily understood forms in spreadsheet systems with built in functions.
t he goal of this step is to conduct reverse inference against such a smell i.e.
to recognize and reassemble such semantic fragmented ast regions into their more concise forms via pa t tern matching and replacement.
in this paper we have manuallyidenti f ied pa t terns for major types of semantics respectively.
t hese pa t terns are summarized based on our case analysis.
first we sampled around spreadsheets from the large scale corpus.
second we manually studied the samples and came up with the pa t terns by summarization and abstraction combining with our own knowledge.
each pa t tern corresponds to a spreadsheet built in functions8.
we present the name explanation and examples of each alternative function in table .
as of the composing of this paper there might be other function candidates that remain out of our knowledge.
nonetheless our proposed algorithm framework should be extensible for easy incorporation of new pa t terns and we do plan to continue related study in the future accordingly.
more details of this step can be found in section .
.
.
redundancy removal in this section we introduce how we identify and remove redundant conditions in a formula step .
t he procedure is presented in algorithm with the help of an example f low in figure .
nested if expression extraction .
first we extract outmost nested if expressions from each formula see line in algorithm function getparentiflist .
by outmost we mean the highest hierarchy in a nested branching logic or on an ast.
for example as shown in figure for formula su m if c1 v1 if !c1 v2 if c2 v3 v4 v5 there is only one target nested if expression the outmost if expression if c1 v1 if !c1 v2 if c2 v3 v4 for formula su m if c1 v1 v2 if c2 v3 if !c2 v4 v5 if c3 v5 if if c4 v6 v7 there are two target nested if expressions if c2 v3 if !c2 v4 v5 and if c3 v5 if if c4 v6 v7 .
please note that the nested if targets to be analyzed may also exist in predicates of a condition node and we also extract such ifexpressions.
for example if c1 v1 if !c1 v2 v3 is also extracted from the condition part of formula if if c1 v1 if !c1 v2 v3 v1 v3 if !c1 v4 v5 .
by so we do not miss the chance of optimizing the nested if at condition parts.
moreover in case thenested if would be reduced as simple predicates it would potentially increase the chance of eventually optimizing the outmost nested if .
branch collection .
based on the ast of each extracted nested if we create a dictionary dicconbranch as the key structure to help detect and remove redundant logic function afii10069.italetdicconbranch in line .
as shown in figure for each entry in the dictionary its key is the condition of an ast node such as c1 or c2 the dbranchlist value line stores a tuple of two ast sub trees corresponding to true and false branches respectively.
in addition each entry also has a nbranchlist value line for the negation of the key condition such as !
c1 and stores the tuple of true and false branches accordingly.
t he dictionary is constructed by visiting each condition node on the ast.
when the same condition or negation is hit for multiple times the ast sub tree tuples at each hi t ting site are appended to the dbranchlist ornbranchlist .
redundancy identi f ication and removal .
intuitively if any entry stores more than tuple in dbranchlist andnbranchlist collectively line it indicates existence of redundant branches on the ast about the condition at key.
we iterate such inspection 8most mainstream spreadsheet tools such as excel and google sheets support these functions.
3algorithm function removeredun input fm the current nested if formula input ast the ast of fm output fm the new formula 1containredun true 2while containredun do containredun false if list getparentiflist ast fm foreachif exp inif list do if t ree generateast if exp dicconbranch getdicconbranch if t ree foreach condition in dicconbranch do branchlist dicconbranch.get condition dbranchlist branchflist.directpart nbranchlist branchflist.negativepart ifdbranchflist.len 2then containredun true redundancy exists.
reduniflist generateredunlist condition dbranchlist foreach redunif in reduniflist do ifredunif in condition.truebranch then fm fm.replace redunif redunif.truebranch else fm fm.replace redunif redunif.falsebranch end end end ifnbranchlist.len 0then containredun true redundancy exists.
reduniflist generateredunlist condition nbranchlist foreach redunif in reduniflist do ifredunif in condition.falsebranch then fm fm.replace redunif redunif.truebranch else fm fm.replace redunif redunif.falsebranch end end end ast generateast fm end end 37end 38return fm against dicconbranch to detect and remove redundancies.
each detected redundancy site corresponds to one redundant ifexpression that can be replaced with either the true branch the condition is deterministic as true or the false branch the condition is deterministic as false .
t hus under each situation we generate the redundant ifexpression according to the condition and its branch list lines and and make replacement.
for example as the example in figure shows the nbranchlist of key c1 is not null indicating that ifexpression if !c1 v2 if c2 v3 v4 is redundant.
since this expression lies in the false branch of condition c1 condition !
cis deterministic as true.
t herefore we remove condition !
c1 and its false branch and only keep the true branch v2.
as a result the original formula becomes su m if c1 v1 v2 v5 .
such iteration repeats until no redundancy is detected.
.
syntax reassembling a f ter removing redundancies if the resultant formula still contains nested if expressions in this third step we further analyze the ast to detect and reassemble fragmented semantics into built in functions as listed in table .
.
.
general procedure.
in general this step is in a paradigm of iterative pa t tern matching and replacement.
for each remaining nested if a f ter step we further construct a threepartlist as the key structure to facilitate pa t tern matching.
each threepartlist consists of three lists for condition true branch and false branch respectively.
for example for expression if c1 if c2 if c3 v1 v2 v2 v2 the condition part is the true branch part is and the false part is .
subsequently based on threepartlist we infer the semantic of the ifexpression and check if it matches some spreadsheet functions.
if yes we transform the formula using the matched function and replace the nested if expression with the transformed one.
following the order shown in table we probe each pa t tern in sequence.
once a pa t tern is matched the probe jumps to the next iteration from the f irst pa t tern again.
t his iteration terminates with zero pattern match.
note that the pa t terns choose match looku p have higher priority than the pa t tern ifsduring the matching because they are more comprehensible and enable more concise expressions.
in the future we may consider to provide all alternative refactoring recommendations for end users to choose from.
.
.
alternative functions.
in this paper we have identi f ied categories of pa t terns corresponding to types of spreadsheet functions.
in this sub section we explain the pa t terns in details by text description ast and examples.
t he basic pa t terns with if depth of in all examples are illustrated in figure .
based on speci f ic structures of each pa t tern their pa t tern matching algorithms share the preceding general procedure and differ in minor details.
and pattern.
if anested if expression satis f ies the following conditions we infer it has the semantic of the and function as shown in figure f irst the false branches of each condition are all identical second the true branches of each condition are all if expressions except for the last true value i.e.
v1 .
such expressions can be replaced with if an d conditionlist truebranch f alsebranch .
for example the expression with the f irst ast in figure can be replaced with if an d c1 c2 c3 c4 v1 v2 .
or pattern.
if anested if expression satis f ies the following conditions we infer that it actually has the semantic of the or function as shown in the second ast of figure f irst the true branches of each condition are all identical second the false branches of each condition are all if expressions except for the last false value i.e.
v2 .
such kind of expressions can be replaced with 4keydbranchlistnbranchlistc1 c2 nullsum if c1 v1 if !c1 v2 if c2 v3 v4 v5 if c1 v1 if !c1 v2 if c2 v3 v4 keydbranchlistnbranchlistc1 c2 nullsum if c1 v1 if !c1 v2 if c2 v3 v4 v5 if c1 v1 if !c1 v2 if c2 v3 v4 c1v1t!c1v2tc2v3tv4fffc1v1t!c1v2tc2v3tv4fffc1v1tv2fc1c2c3c4v1tv2ftv2ftv2ftv2fandc1v1tc2v1tc3v1tc4v1tv2ffffora1 n1str1ta1 n2str2ta1 n3str3ta1 n4str4tfalseffffchoosea1 str1n1ta1 str2n2ta1 str3n3ta1 str4n4tfalseffffmatcha1 r1r2ta1 r3r4ta1 r5r6ta1 r7r8tfalsefffflookup a batbfmaxa batbfminc1v1tc2v2tc3v3tc4v4tv5ffffifs figure typical ast of function and or choose match lookup and ifs.strirepresents a string nirepresents a number rirepresents a reference.true branches of each condition are all identical second the falsebranches of each condition are all if expressions except for the lastfalse value i.e.
v2 .
such kind of expressions can be replaced withif or conditionlist true alue fa l s e alue .
for example the ex pression with the second ast in figure can be replaced withif or c1 c2 c3 c4 v1 v2 .
choose pattern.an if expression that matches thechoose pa ern should have the following features.
first allthe conditions are number equality evaluations the correspond ing numbers could form a arithmetic progression which can betranslated into a natural sequences.
second the false branches ofeach condition are all if expressions except for the last false value.
ird the true branch values are all strings.
for example if a1 str1 if a1 str2 if a1 str3 if a1 str4 couldbe transformed intochoose a1 str1 str2 str3 str4 expressionif a1 str1 if a1 str2 if a1 str3 if a1 str4 could be transformed intochoose a1 str1 str2 str3 str4 .
match pattern.an if expression that matches the matchpa ern should have the following features.
first all the condi tions are string equality evaluations.
second the true branchvalues are all numbers that could form a arithmetic progression which can be translated into a natural sequences.
ird the falsebranches of each condition are all if expressions except for thelast false value.
for example expressionif a1 str1 if a1 str2 if a1 str3 if a1 str4 could be transformed intochoose a1 str1 str2 str3 str4 expressionif a1 str1 if a1 str2 if a1 str3 if a1 str4 could be trans formed into choose a1 str1 str2 str3 str4 .
lookup pattern.an if expression that matches the lookup vlookup or hlookup pa ern should have the following fea tures.
first all the conditions are reference value equality evalu ations.
e