chopped symbolic execution david trabish tel aviv university israel davivtra post.tau.ac.ilandrea mattavelli imperial college london united kingdom amattave imperial.ac.uknoam rinetzky tel aviv university israel maon cs.tau.ac.ilcristian cadar imperial college london united kingdom c.cadar imperial.ac.uk abstract symbolic execution is a powerful program analysis technique that systematicallyexploresmultipleprogrampaths.however despite importanttechnicaladvances symbolicexecutionoftenstrugglesto reach deep parts of the code due to the well known path explosion problem and constraint solving limitations.
in this paper we propose chopped symbolic execution an o v e l form of symbolic execution that allows users to specify uninterestingpartsofthecodetoexcludeduringtheanalysis thusonlytargeting the exploration to paths of importance.
however theexcluded parts are not summarily ignored as this may lead to both false positives and false negatives.
instead they are executed lazily when their effect may be observable by code under anal ysis.
chopped symbolic execution leverages various on demand static analyses at runtime to automatically exclude code fragments whileresolvingtheirsideeffects thusavoidingexpensivemanual annotations and imprecision.
our preliminaryresults show that theapproach can effectively improvetheeffectivenessofsymbolicexecutioninseveraldifferent scenarios including failure reproduction and test suite augmentation.
ccs concepts software and its engineering software testing and debugging keywords symbolic execution static analysis program slicing acm reference format davidtrabish andreamattavelli noamrinetzky andcristiancadar.
.
chopped symbolic execution.
in icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction symbolic execution lies at the core of many modern techniquesto software testing automatic program repair and reverse engineering .atahigh level symbolicexecution systematically explores multiple paths in a program by running permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
executionenginesthusreplaceconcreteprogramoperationswith ones that manipulate symbols and add appropriate constraints on the symbolic values.
in particular whenever the symbolic executor reaches a branch condition that depends on the symbolic inputs it determinesthefeasibilityofbothsidesofthebranch andcreates twonewindependent symbolicstates whichareaddedtoaworklist to follow each feasible side separately.
this process referred to as forking refines the conditions on the symbolic values by adding appropriateconstraintsoneachpathaccordingtotheconditions on the branch.
test cases are generated by finding concrete values for the symbolic inputs that satisfy the path conditions.t ob o t h determine the feasibility of path conditions and generate concrete solutionsthatsatisfiesthem symbolicexecutionenginesemploy satisfiability modulo theory smt constraint solvers .
the challenge.
symbolic execution has proven to be effective at findingsubtlebugsinavarietyofsoftware and has started to see industrial take up .
however a key remaining challenge is scalability particularly related to constraint solving cost and path explosion .
symbolicexecutionenginesissueahugenumberofqueriestothe constraint solver that are often large and complex when analyzing real world programs.
as a result constraint solving dominates runtimeforthemajorityofnon trivialprograms .recent research has tackled the challenge by proposing several constraint solvingoptimizationsthatcanhelpreduceconstraintsolvingcost .
path explosion represents the other big challenge facing symbolicexecution andthemainfocusofthispaper.pathexplosion referstothechallengeofnavigatingthehugenumberofpathsin real programs which is usually at least exponential to the number of static branches in the code.
the common mechanism employed bysymbolicexecutorstodealwiththisproblemistheuseofsearch heuristics to prioritise path exploration.
one particularly effective heuristic focuses on achieving high coverage by guiding the explorationtowardsthepathclosesttouncoveredinstructions .inpractice theseheuristicsonlypartiallyalleviatethepath explosion problem as the following example demonstrates.
motivating example.
theextract octet function shown in figure is a simplified version of a function from the libtasn1 librarywhichparsesasn.
encodingrulesfroman inputstring.
theasn.1protocolisusedinmanynetworkingandcryptographic applications such as those handling public key certificates and electronicmail.versionsof libtasn1 before4.5areaffectedbya heap overflow security vulnerability that could be exploited via a crafted certificate.2unfortunately given a time budget of hours acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden trabish mattavelli rinetzky and cadar 1int extract octet asn t asn char str int str len int len3 counter counter end result int len2 get length str str len len3 counter len3 counter end str len while counter counter end call to get length leads to a heap overflow len2 get length str counter str len len3 if len2 decr len str len len2 len3 append value asn str counter len3 len2 else decr len str len len3 result extract octet asn str counter len3 str len if result !
success return result len2 str len should have been decremented at the beginning of the while block decr len str len counter len2 len3 return success figure a simplified excerpt from the extract octet routine in libtasn1.
the invocation of get length in line leadstoaheapoverflowbecause str lenhasnotbeendecremented before the call.
theanalysisofthe extract octet functionusingthestate ofthe artsymbolicexecutionengineklee failstoidentifythe vulnerability due to path explosion.
at each loop iteration lines the function decodes the length of the current data element with get length line .
function get length scans through the input string and decodes the asn.1fields.then theexecutioneitherrecursivelyiteratesoverthe input string line or invokes append value line .
function append value creates the actual node in the abstract syntax tree ast by decoding the input string given the obtained length.
this functionscansoncemoreovertheinputstring performsseveral checks over the selected element and allocates memory for the node in the recursive data structure.
path explosion in this function occurs due to several nested function calls.
symbolically executing function get length alone with a symbolic string of ncharacters leads to ndifferent paths.
function append value increases even more the number of paths andalsoaffectstheefficiencyofthesymbolicexecutionenginedue to a huge number of constraint solver invocations.
as a result the symbolic executor fails to identify the heap overflow vulnerability at line .
ourapproach.
identifyingthevulnerabilityfromtheentrypoint ofthelibraryisnottrivial toreachthefaultyinvocationoffunction get length theinputtriggeringthevulnerabilitytraverses 945callsto98differentfunctions foratotalamountof386 instructions.
our key observation is that most of the functions requiredduringtheexecutionare notrelevant forfindingthevulnerability.thevulnerabilityoccursduetoanincorrectupdateof theremainingbytesforparsing line21 whichresultsinamemory out of bound read when calling get length .
the bug thus occurs incodewhichdealswiththeparsing whichisindependentfromthefunctionsthat constructthecorrespondingasn.
representation such as append value .
therefore we could have quickly reached the bug if we had skippedthe irrelevant functions that build the ast.
in this paper we propose a novel form of symbolic execution calledchopped symbolic execution that provides the ability to specifypartsofthecodetoexcludeduringtheanalysis thusenabling symbolic execution to focus on significant paths only.
the skipped codeisnottriviallyexcludedfromsymbolicexecution sincethis may lead to spurious results.
instead chopped symbolic execution lazily executes the relevant parts of the excluded code when explicitly required.
in this way chopped symbolic execution does not sacrifice the soundness guarantees provided by standard symbolic execution except for non termination of the skipped functions which may be considered a bug on its own in that only feasible pathsareexplored buteffectivelydiscardspathsirrelevanttothe task at hand.
we developed a prototype implementation of chopped symbolic execution and report the results of an initial experimental evaluation that demonstrates that this technique can indeed lead to efficient and effective exploration of the code under analysis.
main contributions.
in summary in this paper we make the following contributions we introduce chopped symbolic execution a novel form of symbolic execution that leverages a lightweight specification of uninterestingcodepartstosignificantlyimprovethescalability of symbolic execution without sacrificing soundness.
wepresentchopper aprototypeimplementationofourtechnique within klee and make it publicly available.
we report on an experimental evaluation of chopper in two different scenarios failure reproduction and test suite augmentation andshowthatchoppedsymbolicexecutioncanimprove and respectively complement standard symbolic execution.
thispaperisorganisedasfollows.section2givesahigh level overviewofchoppedsymbolicexecution andsection3presents our technique in detail.
section briefly discusses our implementationinsidethekleesymbolicexecutionengine.section5presents theexperimentalevaluationofourtechnique andinparticularit showsthatchoppedsymbolicexecutioncanovercomethelimitationsofstate of the artsymbolicexecutors.section6surveysthe main approaches related to this work.
section summarises the contributions of the paper and describes ongoing research work.
overview in this section we give a high level overview of chopped symbolic executionusingthesimpleprograminfigure2.inparticular figure2ashowstheentrypointoftheprogram function main while figure 2c shows the uninteresting code which we would like to skip function f .
we start the chopped execution by executing mainsymbolically.
whenastatereachesthefunctioncallfor fatline7 wecreatea snapshotstate bycloningthecurrentstate andskipthefunction call.thesnapshotstateisshowngraphicallyinfigure2b where each gray oval represents a symbolic execution state.
with a snapshot created we then continue the execution on thecurrentstate butfromthispointwemustconsiderthatsome authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chopped symbolic execution icse may june gothenburg sweden 1struct point int x y z 3int main struct point p int j k symbolic f p k skip if j if p.y bug else allgood return a j j 0k k 0snapshotrecovery dependent k k 0recovery dependent recovery dependent recovery guiding constraints1 5p y recovery recovery 6p.y 1return b 15void f struct point p int k if k p z if k p x else p y c figure graphical illustration of chopped symbolic execution on a simple example.
load instructions may depend on the side effects of the skipped function f i.e.
the memory locations that fmay update.
in our example the side effects of fare the memory locations pointed toby p.z p.x and p.y whichareupdatedatlines17 and22 respectively.
wecomputethesideeffectsof fusingconservative staticpointer analysis before the symbolic exploration starts see .
we define those instructions that read from the side effects of the skipped functions as dependent loads.
on some paths symbolic execution does not encounter such dependent loads.
for example the path following the elseside of the branch at line accesses neither p.xnorp.ynorp.z s o no further action is needed on those paths and the exploration may correctly terminate without ever going through the code of f. indeed inrealprogramsthereareoftenpathsthatdonotdepend on the skipped functions and in such cases symbolic execution immediatelybenefitsfromourapproach irrelevantpathsaresafely skipped thus reducing path explosion.
however onother pathssymbolicexecutionencounters dependentloads.thishappensforourexampleonthepathwhichexplores thethenside of the branch at line when it loads the value of p.yat line .
at this point the current state needs to be suspended until the relevant paths in function fare explored and becomes a dependentstate.torecoverapath wecreateanew recoverystate which inherits the snapshot state generated before skipping fat line and start executing symbolically the function.
while symbolic execution is in the recovery state if the execution forks then the same fork is performed in the dependent state.furthermore aswerun therecoverystate anystorestothe memory location read by the dependent load are also performed in the dependent state.
for example if the symbolic execution of f traversesthe elsebranchatlines21 thenthevalueof p.y the memorylocationpointedtoby p y issetto1inthedependent statetoo.iftherecoverystatereturnssuccessfully thedependent state is resumed successfully.
if an error occurs while executing the recovery state e.g.
an invalid memory access or a division by zeroerror whichcould haveoccurredif p zwereset inline to p y the corresponding dependent state is terminated.
whenweexecutearecoverystate notallpathsmightbecompatible with the execution which the dependent state reached.
forexample if line were changed from if j toif k then the dependent state would have k in its path condition renderingthedependentstateincompatiblewiththepathin fwhere k .
onewaytofiltersuchincompatiblepathswouldbetoexecute allpossiblepathsthorough fduringrecovery andlaterfilterthe ones that are incompatible with the dependent state.
however this would potentially lead to the exploration of a large numberof infeasible paths.
we thus designed a more efficient solution eachstatemaintainsalistof guidingconstraints whicharethose constraints added since the call to the skipped function.
in our example the guiding constraints for the dependent state are j .
beforeweexecutearecoverystate weaddthese guidingconstraints fromthedependentstatetothepathconditionoftherecoverystate.by state is consistent with respect to its dependent state.
duringrecovery onecouldexecuteallpossiblepathsthrough theskippedfunction fwhicharecompatiblewiththedependent state aswecouldintheexampleabove.however forrealprograms this could be unnecessarily expensive as many paths do not influ ence the dependent load which started the recovery.
to avoid this possible path explosion and reduce the cost of constraint solving we aim to only execute the paths that could influence the dependentload.weaccomplishthisbystatically slicing the function fwithrespecttothestoreinstructionsthatwritetothe memorylocationreadbythedependentload thatis thesideeffectsobservablefromthedependentload.notethatfunction fcouldcall other functions so the slicing is done for all these functions too.
in our example the slicing would likely be able to completely remove theifstatement at lines which would halve the number of exploredpaths thusreducingpathexplosion.itwouldalsolikelyremovethe thensideofthe ifstatementatline19 whichinthis case does not bring significant benefits but it could if that side of thebranchwerereplacedbysay anexpensiveloop.slicingaway these code parts is possible because they do not update p.yon which the dependent load on line relies.
3in practice the success of the slicing algorithm in reducing the size of the code depends on the precision of the underlying pointer analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden trabish mattavelli rinetzky and cadar figure 2b shows how chopped symbolic execution works on ourexampleinagraphicalway.torecapitulate whenthecallto fis reached at line a snapshot state is created by cloning the current state step circlecopyrtin the figure .
then on the execution state thatreachesline9 thecurrentstatebecomesadependentstateand is suspended step circlecopyrt and a recovery state is created by cloning the snapshot state and adding the guiding constraints from the dependent state step circlecopyrt .
at this point function fis statically slicedwithrespecttothedependentload inourcaseremovingthefirstifstatementandthe thenslideofthesecond ifstatement.then the recovery state starts symbolically running the sliced version of f. when execution is forked at line then the dependent state is alsoforkedalongthesameconstraints steps circlecopyrtand5 circlecopyrt .oneofthe forked recovery states recovery updates the location p yon whichourdependentloadrelieson sothislocationisalsoupdated in the corresponding dependent state step circlecopyrt .
finally when a recovery state terminates it gets discarded step circlecopyrt and symbolic executionisresumedfromitsdependentstatesandothernormal states in the program.
chopped symbolic execution in this section we describe our technique in detail and provide the backgroundregardingthemainstaticanalysisitemploys namely pointer analysis .
algorithm presents the key steps in chopped symbolic execution whichwegraduallyexplain.thealgorithmoperatesona simple imperative c like heap manipulating language with assignments assertions conditional jumps dynamic memory allocation andreclamation andfunctioncallswithcall by valueparameter passing.4functionsmayhavepointerparameters.thus without lossofgenerality weassumethatfunctionsdonothaveareturn value.5tosimplifytheexplanation wenowassumethatwemay skipatmostonefunctioninvocationateveryexploredpath and discussthegeneralcasein .
.6forthesamereason wealsoassume that the program does not dynamically allocate memory and discuss this aspect in .
.
chopped symbolic execution begins by invoking function cse with aninitial symbolic state s0 and a set containing the names of the functions that the user wishes to skip skipfunctions .
we expect a symbolic state sto encode among other properties the next instruction to be executed denoted by nextinstruction s the activation record stack and a symbolic description of the programheap.forexample thechoppedsymbolicexecutiondescribed in section begins with s0in which the stack contains only the activation record of main with the next instruction at line an empty heap and skipfunctions f .
at the beginning of the algorithm the worklistis empty line andweinitializeitwith s0 line3 .then astandardworklist based algorithmstartsexecutinguntileithertheworklistisempty line4 or the algorithm exhausts the time budget elided .
as usual the algorithmselectsasymbolicstate stoexploreoutoftheworklist line5 .unconventionally however theworklistonlyhasthestates which are not suspended as suspended states are blocked until the 4our implementation operates on llvm bitcode .
5a function with a return value can always be rewritten with an additional parameter that points to the memory location of the return value.
6for completeness of presentation algorithms and handle the general case.algorithm chopped symbolic execution simplified .
worklist function cse s0 skipfunctions worklist worklist s0 whileworklist nequal do s select worklist inst nextinstruction s switchinstdo casecall f targetfunction s iff skipfunctions then snapshot createsnapshot s s.skipped s.skipped f snapshot else executecall s caseload addr getloadaddress s ifmaymod s s.skipped addr then createrecoverystate s addr else executeload s inst casebranch ifs.isrecoverystate then dependentstate getdependent s condition inst s prime fork s dependentstate prime fork dependentstate iffeasible s prime feasible dependentstate prime then worklist worklist s prime s prime prime fork s dependentstate prime prime fork dependentstate iffeasible s prime prime feasible dependentstate prime prime then worklist worklist s prime prime worklist worklist s else executebranch s casestore addr getstoreaddress s executestore s addr ifs.isrecoverystate then updatedependentstate s addr else s.overwrittenset s.overwrittenset addr casereturn ifs.isrecoverystate returninskipped s then terminate recoverystate dependentstate getdependent s resume dependentstate worklist worklist dependentstate else executereturn s end switch authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chopped symbolic execution icse may june gothenburg sweden algorithm auxiliary function createrecoverystate function createrecoverystate dependentstate addr foreach f snapshot dependentstate .skippeddo ifmaymod dependentstate f snapshot addr then suspend dependentstate gc getguidingconstraints dependentstate recoverystate fork snapshot gc recoverystate .isrecoverystate true slice recoverystate addr linkdependent recoverystate addr dependentstate worklist worklist recoverystate algorithm auxiliary function maymod function maymod s funclist addr foreach f snapshot funclistdo ifallocsite s addr modset f then ifaddr nelements.overwrittenset then returntrue returnfalse valueofthedependedloadisresolved see .thenextstepofthe algorithm depends on the instruction type line .
handling callinstructions lines a callinstruction is handled as illustrated by step circlecopyrtin figure see first the algorithm determines the name fof the invoked function line .
then iffisoneoftheskippedfunctions thealgorithmcreatesa snapshot of the current state s line and records the snapshot state at the end of its list of skipped invocations line .
a skipped invocation is represented as a tuple f snapshot composed of the name of a skipped function f and asnapshot of the symbolic state at the time fwas skipped.
conversely if fshould not be skipped the algorithm handles its invocation as usual in symbolic execution.
for brevity we omit the standard handling of commands by symbolic execution.handling loadinstructions lines15 choppedsymbolicexecutionuses maymod s s.skipped addr showninalgorithm3and explained in .
to determine whetherthe address from whicha valueisread addr mighthavebeenmodifiedbyoneoftheskipped functionsonthepathfollowedbythecurrentstate s.ifso thealgorithm generates recovery states by calling createrecovery state s addr .otherwise the loadinstructionishandledasusual in symbolic execution line .
function createrecoverystate is shown in algorithm .
the function handles loadinstructions as illustrated by step circlecopyrtin figure2 see ititeratesoverthelistofskippedfunctions line2 andusesmaymodtodeterminewhichoftheskippedfunctions f mighthavemodified addr line3 .onceitfindssuchafunction the currentdependentstateisimmediatelysuspended line4 .thefunction then generates the corresponding recovery state recoverystate byforking snapshot andbyaugmentingitspathconditionwiththe guidingconstraints gc lines5to7 i.e.thepathconstraintsaccumulated inssince the snapshot state was created.
the algorithm then invokesastaticprogramslicertoremovefromtheskippedfunction finstructions which cannot affect the address of the dependent load line records that dependentstate spawned recoverystateto determine the value written in address addrofdependentstate line and pushes the recovery state into the worklist line .
handling branchinstructions lines21 thealgorithmchecks whether the current state sis a recovery state.
if so then the branchinstruction is handled as illustrated by steps circlecopyrtand5 circlecopyrt in figure see it first retrieves the suspended dependent statedependentstate which spawned sas a recovery state line .
it then determinesthe branch condition line forksboth the current recovery state sandthedependentstate dependentstate and adds to their path condition lines .
after the fork it checks whether the resulting states are feasible i.e.
their path conditions are satisfiable line and if so adds the new recovery statetotheworklist line28 .ifeitheroneisnotfeasible thenewlyforkedrecoveryanddependentstatesaresimultaneouslydiscarded.
lines act similarly to lines except that we use the negation of the branch condition .
finally the original recovery statesis removed from the worklist line .
if the state sis not a recoverystate thenthe branchinstructionishandledasusualin symbolic execution line .handling storeinstructions lines the algorithm executesthe storeinstructiononthecurrentstateintwosteps.first it performs the actual store lines .
if sis a recovery state then the algorithm invokes updatedependentstate line function body elided for space reasons to update the dependent state as illustratedbystep circlecopyrtinfigure2.otherwise if sisnotarecovery state it updates the set of overwritten addresses in the currentstate to record that a value was stored in addrafter the skipped invocation andthusanyvaluetheymaywriteisnolongerrelevant line .
handling returninstructions lines43 if sisarecoverystate andthereturninstruction is invoked inside the skipped function line then the recovery is terminated and the instruction is handled as illustrated by step circlecopyrtin figure see specifically the recovery state itself is discarded line and the dependent state is resumed lines .
otherwise the returninstruction is handled as usual in symbolic execution line .
.
static inference of function side effects theauxiliaryfunction maymod s funclist addr shownin algorithm receives as parameters a symbolic state s a list of skipped invocations funclist and an address addrwhich is the target of aloadinstruction and determines whether one of the skipped functionsin funclistmaystoreavaluein addr.thefunctionmakes this decision using a points to graph computed by a preliminary pointer analysis stage .
morespecifically weperformawhole programflow insensitive context insensitive and field sensitive points to analysis which determines in a conservative way the memory location each pointer variablemaypointto.inthisanalysis memorylocationsareconser vatively abstracted using their allocation sites every definition of a localoraglobalvariableisconsideredtobeanallocationsite as well as every program point in which memory is allocated.
for example iftheprogramcontains while .. do l p malloc then we represent all the memory locations allocated in lby a single allocation site asl.
we then say that pmay point to allocation siteasl andiftheprogramcontains p q wesaythesameabout authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden trabish mattavelli rinetzky and cadar q.thenodesofthepoints tographofaprogramarethevariable names and allocation sites and its edges represent points to relations anedgefromnode vtowmeansthatthememorylocation represented by vmay hold a pointer to w. thepoints tograph whichiscomputedonceforeveryprogram conservatively represents all the possible points to relations in any possible program execution.
using the points to graph we use a standard may mod analysis see e.g.
in which we find the side effects of every function f i.e.
the set of possible locations represented by their allocation sites that the function itself or any function that it may transitively invoke may modify.
duringthechoppedsymbolicexecution weinstrumentthesymbolicstatetorecordtheallocationsiteofeverymemorylocation.
thisinstrumentation togetherwiththe programpoints tograph allows maymod to determine whether a skipped function may write to a given address.
recall that the pointer analysis is flowinsensitive andthusitmightrecordthataskippedfunctionmay modify a location which is updated later on in the symbolic ex ecution.
more specifically a loadinstruction from address addr isdependent on an invocation of a skipped function if and only if addrisamongthelocationsthat maybemodifiedbytheskipped function according to the may mod analysis and no stores to thatlocationhappenedbetweentheskippedinvocationfunction and the load.
in particular when the second condition does not hold no recovery is needed as the stores performed by the skipped functionareirrelevant.
maymod utilisestheinformationgathered during the symbolic execution regarding overwritten locations algorithm line to refine on the fly the detection of the relevant side effects of skipped functions.
.
multiple recovery states insomecases weneedtocreateseveralrecoverystatesduringa single chopped symbolic execution.
for example consider the following code fragment which replaces lines to of the main function in figure 7f p k skip next two branches depend on the side effects of f 9if p.x p.z 11if p.y p.z if we wish to skip the invocation to f then a recovery state andadependentstatearecreatedateachofthebranchesonlines9 and .
note that the second dependent state is produced from the first dependent one and that the resumed state encapsulatesthe changes made by the first recovery state.
assume that these changes involve a modification of the value of p.xinside the k branch at line .
if the symbolic execution of the second recovery state goes through the path in which p.yis updated k the induced combined execution would be infeasible.
to avoid this undesirable situation when a recovery state terminates it adds the newconstraintsaccumulatedinitspathconditiontothe guiding constraints ofitsdependentstate.theaddedconstraintsarethen used in subsequent recovery states.
in our example in figure the constraint k 0ispropagatedfromthe firstrecoverystatetothe first dependent state thus ensuring that the symbolic execution of the second recovery state does not follow an infeasible path.1struct point int x y 2void f1 struct point p p y 5void f2 struct point p if p y p x 9void g struct point p f1 p skip f2 p skip if p.x ... figure multiple skipped functions.
.
handling multiple skipped functions so far we have assumed that every symbolic state has at most one skipped invocation.
when multiple invocations are skipped andmore than one may modify the dependent load address addr w e needtodecidewhichfunctionstouseforrecoveryandinwhichorder.
we solve this issue by executing the skipped invocationsaccording to their order along the path thus ensuring that the value stored in addrat the end of the recovery process is indeed the last value written there along the chopped path.
anotherissuethatweneedtoaddresstosupportmultipleskipped functions is that a skipped invocation might depend on the side effectsofanearlierskippedfunction.whenthishappens weapply our recovery approach in a recursive manner and treat the currentrecovery stateas a dependent state.for example consider the code in figure .
when the execution reaches the dependentload at line we create a recovery state for f2 since f1does not modify the field x. when the created recovery state reaches the load instruction at line it identifies it as a dependent load.
choppedsymbolicexecutionthencreatesanotherrecoverystate whichexecutes f1.oncetherecoveryof f1isterminated wecan continue with the recovery of f2.
to make the symbolic execution more efficient in these cases we maintain for each state a recovery cache.
the recovery cache records foreach skippedinvocation andslice theresulting values which were written by the skipped function during the recovery process.thisenablesustoavoidre executingtherecoveryprocessincertaincases.forexample if ghadread p yaftertheinvocation off2 we could have found the value of p yin the cache.
.
memory allocations letusconsidertheexamplefromfigure4 wheretheskippedfunction fallocates memory with malloc.
after skipping the function callatline7 thechoppedsymbolicexecutionencounterstwodependent loads at lines and and thus spawns two consecutive recoverystates onewhichexecutesonlyline3 asline4isremoved by the static slicer and one which executes lines and .
if we allowed mallocto return two different addresses while executing the recovery states this could lead to an incorrect execution since the second recovery would write to a different memory address.
to prevent this and maintain consistency across recovery states authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chopped symbolic execution icse may june gothenburg sweden 1struct point int x y p null 2void f p malloc sizeof struct point p x 6void g f skip if p if p x ... figure example of skipped function with allocation.
originating from the same function call we maintain a list of returned addresses for each allocation site in f which are identified by theircall stack.this way subsequent recovery stateswill use this information while re executing allocating instructions.
other nondeterministic routines such as random can be handled in a similar way.
.
chopping aware search heuristic searchheuristicsarethe mainapproachtoreducepathexplosion andsteersymbolicexecutiontouncoveredpathsforamoreeffective exploration and chopped symbolic execution is noexception.however theseheuristicsdonottakeintoaccount the particular nature ofthestates inchopped symbolicexecution particularly the distinction between normal and recovery states.
weproposea chopping awaresearchheuristic whichattempts to optimize the exploration of chopped symbolic execution.
the search heuristic favors the selection of normal states which donot require any recovery thus fostering code exploration.
sincealways favoring normal states over recovery states may lead tosaturation in code exploration we allow the searcher to select arecovery state at a lower probability.
through experimentation we determined that choosing to execute a recovery state with a probabilityof0.2producesthebestresults andthisisthevaluewe use in our evaluation.
technically we maintain two worklists one for normal states andone forrecoverystates.
whenthesymbolic executionengine selects the next state to explore it first selects a worklist according tothespecifiedprobability andonlythenextractsthenextstate.
as a result it is possible to manage the two worklists according to different heuristics.
.
limitations the current main limitation of the technique is related to symbolic addresses.handlingasymbolicaddressisdifficult asitmayrefer to multiple allocation sites which in turn may lead to the recovery ofseveraldifferentskippedfunctions.moreover choppedsymbolic execution needs a concrete load address to update when stores are performed to that address during recovery.
choppedsymbolicexecutioncurrentlyfocusesonskippingfunctions.
however the approach is more generic in theory we could skip any arbitrarycode portion that preserves the control flowof the program.
we are currently working on such an extension particularly ondesigning an appropriateapi forspecifying arbitrary code portions to skip.
implementation we implemented chopped symbolic execution into chopper an extensiontothekleesymbolicexecutionengine .wemake chopper available at weforkedkleefromcommit b2f93ff.ausercanrunchopper byspecifying thelistof functionstoskip alongwith specific call sites via command line switches.
choppercombinesstaticanalysis inparticularmod refanalysisandslicing withsymbolicexecution.sincekleeoperateson llvm bitcode we rely on libraries that statically analyse llvm bitcode.
in particular we implemented a library for static analysis that exposes apis to klee so new or better static analyses can be integrated in chopper with ease.
we compute mod ref analysis by using the pointer analysis provided bysvf .
inparticular we rely ona flow insensitive and context insensitive pointer analysis based on the andersen algorithm .
we compute static backward slicing using the dg static slicer .
we modified the slicer to be able to generate slices of arbitrary functions and not only of the entry point of the program.
notethatstaticslicingiscomputedon demand whenarecovery isrequired.thesameslicemaybereusedformultiplerecoveries so each slice is computed only once.
experimental evaluation ourevaluationaimstoprovidepreliminaryevidencethatthisnovel form of symbolic execution can lead to significant scalability gains.
morespecifically weevaluateitseffectivenesswhenembodiedin the following two scenarios failurereproduction wheretheresearchquestionweexplore is howdoeschoppedsymbolicexecutionperformwithrespect to standard symbolic execution in generating an input that triggers a failure?
in particular can it reproduce more failures thanstandardsymbolicexecution orcanitreproducethesame failures faster?
testsuiteaugmentation wheretheresearchquestionweexplore is how does chopped symbolic execution perform when steered to generate test cases that improve the structural coverage of code?
can chopped symbolic execution complement the exploration of standard symbolic execution?
note that our objective is not to claim that chopped symbolic execution is generally a superior technique for a specific task and thus omits a direct comparison with other state of the arttechniques for each scenario but rather to assess the attainable benefitsofchoppedsymbolicexecutionwhenappliedtotechniques built upon symbolic execution engines.
wecomparechopperwithbaselineklee.weusethesameklee commit b2f93ff fromwhichwebasedchopper.bothtoolsare compiled with llvm .
.
and use stp .
.
as the constraint solver .weconductourexperimentsonserversrunningubuntu .
equippedwithan8 coreintelprocessorat3.5ghzand16gb of ram.
.
failure reproduction in thisexperiment weuse choppedsymbolic executionfor failure reproduction.inparticular werunasymbolicexecutortogenerate inputs that trigger known security vulnerabilities.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden trabish mattavelli rinetzky and cadar table security vulnerabilities and libtasn1 versions considered for reproduction.
vulnerability version c sloc cve .
cve .
cve .
cve .
benchmarks.
the subjects of this part of the evaluation are vulnerabilities taken from gnu libtasn1.
as briefly discussed in the introduction gnu libtasn1is a library for serialising and deserialisingdatainabstractsyntaxnotationone asn.
format.for example libtasn1is used in gnutls to define x. certificates.
weselectedthe libtasn1librarybecauseitscodeiscomplex with nested and deep function calls and can be successfully analysed by the klee symbolic executor.
table lists the vulnerabilities selected for our experiment which are memory out of bounds accesses.
note that each vulnerability requires the reproduction of a singlefailure exceptforcve forwhichthevulnerability canbeexploitedinthreedifferentcodelocations soweconsider three different failures.
therefore in this experiment we aim to reproduce a total of six failures.
methodology.
weproceedwiththefollowingevaluationprocess we manually create an execution driver for the libtasn1library to exercisethe library from itspublic interface simulating the interactions of an external program e.g.
gnutls .
wemanuallyderivethesetoffunctionstoskipbyinspecting thecodeandthevulnerabilityreportwhichusuallyincludesthe stack trace and sometimes results from a dynamic analysis tool e.g.
valgrind .for theselected casestudieswemanaged to identify a candidate set of function to exclude in less than 30minutesperfailure butadeveloperfamiliarwiththecode should be able to do so faster.
weinvokekleeandchopperonthesubjectwithseveraldifferent search heuristics for normal states random dfs and coverage based7 anddfsforrecoverystates.weuseatimeout of hours.
we also configure the symbolic executors to terminate the execution as soon as the vulnerability is identified.
wedothatbyaddinganewoptiontokleethat givenalistofcodelocations terminates the execution as soon as a vulnerability is discovered at all locations.
results.table summarises the high level results of our failure reproduction experiment.
for each vulnerability and search heuristicwereporttheeffectivenessofkleeandchopperatreproducing thefailureasthetimerequiredtogenerateaninputthattriggers the vulnerability.
as can be seen chopper outperforms klee on all but one case studybothintermsofnumberoffailuresreproducedandperformance regardless of the search heuristic applied.
overall klee reproducesfourfailures cve cve cve2015 and cve and only failure cve can be reproduced with all search heuristics.
this latter case seems 7klee searchoptions dfs random state andnurs covnew respectively.table results for the failure reproduction experiment on libtasn1.
for each case we report either the time requiredforexplorationifthevulnerabilitywasreproducedsuccess fully in mm ss timeout ifexecutionisterminatedafter24 hours or oom if the execution runs out of memory withthe respective time at which this happened .
vulnerability search klee chopper cve 1569random oom dfs oom coverage oom cve 1random dfs coverage cve 2random dfs timeout coverage cve 3random timeout dfs timeout coverage timeout cve 2806random dfs coverage oom cve 3622random timeout dfs timeout coverage to be relatively easy to identify since klee requires only a few seconds.ontheothercases kleerequiresbetween1and20hours.
the problem of path explosion in klee is particularly visible in cve 1569wherethesymbolicexecutorquicklyrunsoutof available memory mb and thus fails to reproduce the failure.
incontrast choppercanidentifyallvulnerabilitiesandgenerates a test case to reproduce each failure in less than minutes and often much faster.
overall for the vulnerabilities that klee can also reproduce chopper can significantly beat klee in terms of performance by at least an order of magnitude with the only exceptionof cve 1wherechoppercan be slowed by the cost of static analyses.
table3summarisesthedetailedresultsofchopperforthefailure reproduction experiment.
for each vulnerability and searchheuristicwereportthe numberof snapshots andrecoverystates generatedduringchoppedsymbolicexecution snapshotsandrecoveries respectively theexecutiontimesforchopperwithand withoutslicing sliced fandfullf respectively aswellasstatistics on the generated slices which includes the number of slices generated num and the total size of the original fsize and sliced s size skipped functions in terms of llvm instructions.
table shows that the number of skipped function calls as deduced by the number of snapshot states and recovery states varies with the nature of the case study the skipped functions and the search heuristic.
in the case of vulnerability cve chopper could reproduce the failure without recovering.
this is the exemplar case that highlights the benefits of chopped symbolic execution while klee spent hours interpreting code unrelated authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chopped symbolic execution icse may june gothenburg sweden table detailed results of chopper for the failure reproduction experiment on libtasn1.
vulnerability search snapshots recoveriesfunction slice fullfslicedfnumfsizessize cve 1569random dfs coverage cve 1random dfs coverage cve 2random dfs coverage cve 3random dfs coverage cve 2806random dfs coverage cve 3622random dfs coverage with the failure chopper excluded the uninteresting code portions and could proceed analysing only code of interest consistently identifyingthefailurewithallsearchheuristicsinaslittleasone minute.
table3alsoshowsthatthebenefitofslicingtheskippedfunctions depends on the case study.
for example for the cve 201434673vulnerability chopper is on average faster when slicing theskippedfunctions.conversely chopperperformsthebestwithout slicingin cve .a plausibleexplanation isthat the additional analyses requiredfor slicingwere moreexpensive than directly analysing the functions.
we plan to develop a lightweight analysis to speculatively identify when to apply slicing on the skipped functions.
.
test suite augmentation in this experiment we use chopped symbolic execution for test suiteaugmentation.wedothatbyrunningchopperonasubject program where we skip functions already exercised by an existing testsuite.asinitialtestsuitewerelyontestsgeneratedbyklee.
inessence wewanttoassesstheeffectivenessofchoppedsymbolic executionincomplementingstandardsymbolicexecutionintest generation for the goal of increasing structural coverage.
benchmarks.
thesubjectsofthispartoftheevaluationaregnu bc2.
libyaml .
.
andgnuosip4.
.
.
bc8isanarbitraryprecisioncalculatorthatsolvesmathematicalexpressionswrittenin a c style language.
libyaml9is a well known library for parsing and emitting data in yaml format which is a human friendly dataserialisationstandard.
osip10implementsthesipprotocoland providesaninterfaceforcreatingsipbasedapplications.wechoose benchmarksbecause klee hasa hard timegenerating highcoveragetests.asaresult thecodenotcoveredbykleeisusually related to complex features and we challenge chopper to exercise it.
for each program we rely on the program s documentation and personal experience with the subject to identify the best argument configuration that can maximise coverage.
methodology.
weproceedwiththefollowingevaluationprocess we generate the initial test suite by running klee on each subjectwiththecoverage basedsearchheuristicandatimelimit ofonehour.weusethisconfigurationtomaximisestructural coverageofthecodeunderanalysis inparticularwefocuson line and branch coverage.
we compute the structural coverage obtained with the test suites that klee generates using gnu gcov.
weusethecoverageinformationandthecallgraphtoselectfor eachprogramthesetoffunctionstoskip.forexample suppose that function fcalls function andh and that fandhare coveredbyatest.weincludeinthesetoftheskippedfunctions onlyh sincefis required to reach uncovered function .
we invoke chopper on the subjects with the coverage based search heuristic for normal states and dfs for the recovery states.
we use a timeout of one hour.
results.table summarises the results of our test suite augmentationexperiment.foreachcasestudywereportthestructuralcoverageofasymbolicexecutoraspercentagesoflinesandbranches coveredbyitsgeneratedtestsuite.forklee chopperwereport thestructuralcoverageresultswithandwithoutperformingslicing slicedfand fullf respectively .
table shows that chopper effectively complements klee and increases code coverage even on complex subjects.
specifically on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden trabish mattavelli rinetzky and cadar table line l and branch b coverage achieved by klee and klee chopper for bc libyaml andosipin one hour.
programkleeklee chopper fullf slicedf lblblb bc .
.
.
.
.
.
libyaml .
.
.
.
.
.
osip .
.
.
.
.
.
bc chopperincreasedstatementandbranchcoverageby4 and .
respectively on libyaml it approximately doubled coverage and inosipit also led to significant gains.
inbc chopper managed to skip expensive functions that initializetheparsingoftheinputfileandreachedtheactualparsing functions.unfortunately theanalysisquicklygotstuckintheparsing routine due to timeouts in theconstraint solver resultingin a limited increase in coverage.
in the case of libyaml we observed that klee spent almost allitsbudgetanalysingonefunctionthatcontainscomplexlogic responsibleforensuringthatthebuffercontainsenoughcharacters forparsingwhilehandlingdifferentencodings suchasutf 8or utf .
this function is invoked at the beginning of program execution and kleegot stuck in it not being able toexecute any subsequentlineofcode.conversely chopperskippedtheexpensive invocationandcontinuedtoexploreotherpartsofthecode.our chopping awaresearchheuristicalsoallowedustorecoverpaths insidetheexpensivefunctionwhilegivinghigher prioritytononrecovery states in turn resulting in a more in depth exploration of the code.
a similar scenario was encountered in osip where klee spent aconsiderableamountofresourcesonawhitecharacterprocessing routine which is invoked at the beginning of the execution.
by skipping this routine chopper was able to perform a deeper exploration of the code.
as for the previous experiment the benefit of slicing strictly dependsonthecasestudy.inthisexperiment slicingisnotbeneficial inlibyaml andosip while it leads to increased coverage in bc.
.
threats to validity herewebrieflydiscussthecountermeasuresweadoptedtomitigatethe threats to validity.
the internal validity depends on the correctnessofourprototypeimplementation andmaybethreatenedby the evaluation setting and the execution of the experiments.
wecarefully tested our prototype with respect to the original klee baseline and make it available for further inspection.
threats to external validity may derive from the selection of benchmarks.wevalidatedourapproachonthreereal worldsubjects.
different results could be obtained for different subjects.
the only way to further reduce the external validitythreatconsists in replicating our study on more subjects.
for this reason we make ourexperimentalpackagepubliclyavailabletootherresearchers.
related work the research community has invested significant effort in addressing the path explosion challenge in symbolic execution and this paper aligns with this line of work.
as we already mentioned in the introduction the most common and often most effective mechanism employed by symbolicexecutors are search heuristics whose goal is to guide programexploration to the most promising paths in the program.
popularheuristicsincluderandompathexploration generational search and coverage optimized search to name just a few.
unfortunately search heuristics only partly alleviate path explosion andsymbolicexecution canstillgetstuckinirrelevant parts of the code.
anothereffectivetechniqueistotrytopruneequivalentprogram paths .
for instance if a path reaches a program point with a setofconstraintsequivalenttothoseofapreviouspaththatreached thatpoint thenthesecondpath andallpathsthatitwouldhave spawned canbeterminated.thistechniqueissimilarinspiritto our approach but orthogonal as it does nothing to prevent the explorationofcodeirrelevanttothetaskathand.choppedsymbolic executioncanbecombinedwith pathpruning inorder topruneboth irrelevant paths as well as those relevant paths which are equivalent to other relevant paths.
merging paths can also help alleviate path explosion.
paths can be merged either ahead of time or at runtime .
a particular type of path merging are function summaries in which paths within a function are merged into a summary that can bereused on subsequent invocations .
path merging can lead to exponentialreduction in the numberof paths explored butthe cost is often offloaded to the constraint solver which has to deal with significantly harder constraints.
again chopped symbolic execution could be combined with path merging in order to get the benefit of both.
chopped symbolic execution makes use of program slicing in ordertoexploreonlytherelevantpartsofcodethroughtheskippedfunctions.programslicinghasbeenexploredinsymbolicexecution before e.g.
in the context of patch testing .
conclusion choppedsymbolicexecutionisanovelformofsymbolicexecution whichallows userstospecifyuninteresting partsofthecode that can be excluded during analysis thus focusing the exploration on those paths most relevant to the task at hand.
our preliminaryevaluation shows that chopped symbolic execution can lead to significant improv ements in scalability for different scenarios such as vulnerability reproductionand test suite augmentation.future work can explore these scenarios and others in more depth aim to further automate the identification of functions to skip and extend the approach with the ability to skip arbitrary code fragments.