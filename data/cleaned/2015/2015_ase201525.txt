developing a dsl based approach for event based monitoring of systems of systems experiences and lessons learned michael vierhauser rick rabiser christian doppler laboratory mevss johannes kepler university linz austriapaul gr unbacher alexander egyed institute for software systems engineering johannes kepler university linz austria abstract complex software intensive systems are often described as systems of systems sos comprising heterogeneous architectural elements.
as sos behavior fully emerges duringoperation only runtime monitoring is needed to detect deviationsfrom requirements.
t oday diverse approaches exist to defineand check runtime behavior and performance characteristics.however existing approaches often focus on specific types ofsystems and address certain kinds of checks thus impedingtheir use in industrial sos.
furthermore as many sos need torun continuously for long periods the dynamic definition anddeployment of constraints needs to be supported.
in this paperwe describe experiences of developing and applying a dsl basedapproach for monitoring an sos in the domain of industrialautomation software.
we evaluate both the expressiveness of ourdsl as well as the scalability of the constraint checker .
we alsodescribe lessons learned.
keywords systems of systems requirements monitoring constraint checking domain specific languages.
i. i ntroduction many software intensive systems today are systems of systems comprising heterogeneous and interrelated architectural elements.
common properties of sos are decentralized control support for multiple platforms inherently volatile and con flicting requirements continuous evolution and deployment aswell as heterogeneous inconsistent and changing elements .as the full behavior of sos emerges during operation only system testing is not sufficient to determine compliance withrequirements.
instead the behavior of the systems and theirinteractions need to be continuously monitored and checkedduring operation to detect and analyze deviations from theexpected behavior.
checks include the occurrence and orderof runtime events temporal behavior the interaction ofsystems structural behavior or properties of runtime data data checks .
different research communities have been developing runtime monitoring approaches for various kinds of systemsand diverse types of checks.
examples include requirementsmonitoring monitoring of architectural properties complex event processing or runtime verification to name but a few.
the expected runtime behavior oftenalso can be expressed formally using temporal logic .furthermore domain specific languages are used to facilitatethe definition of constraints which then can bechecked based on events and data collected from systems atruntime e.g.
via probes instrumenting systems .runtime monitoring in sos however is particularly challenging as e.g.
temporal structural and data constraints needto be checked for a high number of events.
furthermore many sos are cyber physical systems that need to runin mode for weeks or even months without interruption which means that constraints need to be defined and deployeddynamically to ensure live and instant feedback on require ments violations to users.
many existing runtime monitoringapproaches however emphasize particular technologies ortypes of constraints or are limited to offline analysis of eventtraces .
this paper describes experiences of extending an existing incremental consistency checker for design models to support event based runtime monitoring of sos .
ourwork is motivated by an industrial case of monitoring a metal lurgical plant automation system an example of a large scaleindustrial sos section ii .
we describe an industrial scenarioand discuss challenges for constraint checking at runtime.
toaddress these challenges we developed a domain specific constraint language aiming at industrial end users who often lackdeep programming skills to ease the definition of various typesof constraints section iii .
our dsl based approach allows toincrementally check constraints at runtime and was developed by extending an existing incremental checker sections ivand v .
this ensures that violations of requirements can bereported instantly to users monitoring an sos.
the approachfurther supports the definition and deployment of constraints at runtime i.e.
constraints can be added or modified withoutstopping the checker or the monitored systems.
we evaluatethe expressiveness of the dsl using real constraints from ourindustrial case and show the scalability of our checker in anindustrial monitoring scenario section vi .
we also discusslessons learned aimed at researchers and practitioners workingon similar challenges section vii .
we conclude the paperwith a discussion of related research and an outlook on futurework sections viii and ix .
ii.
i ndustrial case and challenges our industry partner primetals technologies a joint venture of siemens and mitsubishi heavy industries isone of the world s leading engineering and plant buildingcompanies in the iron steel and aluminum industries.
thecompany provides machinery hardware software and automa tion systems for steel producers around the globe.
we usethe example of a plant automation system pas developed 30th ieee acm international conference on automated software engineering .
ieee and maintained by primetals technologies to illustrate the runtime monitoring and constraint checking challenges.
thepas automates optimizes and tracks different stages of themetallurgical production process.
it comprises systems forprocess automation of melting iron ore and raw materialsto produce iron refining liquid iron and other materials toproduce steel and casting liquid steel into solid steel slabs.these independently developed automation systems for iron steel and continuous casting cf.
fig.
size up to severalmillion loc.
the systems have heterogeneous architectures they have been developed using diverse technologies and theyfrequently interact e.g.
when exchanging data controlling themetallurgical production process.
although the different pas software systems are engineered independently there are manifold dependencies in themetallurgical process that need to be considered when planningtheir joint operation.
for instance liquid iron is needed forproducing liquid steel which is then the input to castingsolid steel slabs.
the pas sos is further connected to legacyor third party systems leading to additional complexity.
fur thermore there are dependencies between components withinone particular system.
for instance a component optimizingthe arrangement of steel slabs on a strand in the caster to minimize scrap and to ensure steel quality relies oninformation provided by other components such as materialtracking.
besides such constraints which cross cut different systems or components there are also constraints affecting onlyparticular components.
for example the component handlingthe selection of material from a silo and the subsequenttransportation on a conveyor belt has to ensure that eventshappen in specific sequence and within a certain time span toguarantee the uninterrupted and continuous flow of material.
although such pas requirements and their dependencies are carefully managed during development it is crucial tomonitor them after deployment to detect inaccurate and er roneous behavior at runtime.
this is particularly importantafter upgrading components a frequent case when modernizingexisting plants.
furthermore the metallurgical production pro cess is supervised by operators in control rooms and manualintervention by an operator can have unforeseen effects onthe automation software and the production process againsuggesting a runtime monitoring approach.
for instance thecut length defined by an operator of the caster system mightconflict with required plan characteristics from the productionplanning system or the ladle finished event might not happenin steelmaking thus affecting the continuous casting process.
a. industrial runtime monitoring scenario in the following we describe a typical scenario for runtime monitoring based on an earlier qualitative study with developers and engineers of our industry partner .
the scenarioshows that constraints need to be defined and deployed dynam ically and checked continuously at runtime.
for the scenariowe assume that the pas is running at the customer s site andan infrastructure for runtime monitoring is set up to collectevents and data about the running systems.
the scenario shownin fig.
starts with a customer report describing a deviationfrom the expected system behavior after upgrading several fig.
industrial scenario for runtime monitoring of sos.
components the initialization of the casting system does notcomplete within the expected time frame thus delaying theprocess of casting liquid steel to solid steel slabs.
due to theinterplay of several systems there are many potential reasonsfor this behavior and both hardware and software issues mighthave caused the problem.
the service engineer reviews the incoming customer report and remotely connects to the customer s automation sys tem to investigate the issue by checking the running systems.
the service engineer uses the monitoring infrastructureto retrieve more details about the state of the system e.g.
by analyzing recorded event data to reveal the origin of thereported problem.
this task is simplified if constraints relatedto the issue have already been defined and violations havebeen recorded.
if necessary the service engineer addsnew constraints to the monitoring infrastructure.
dependingon the type of problem different types of constraints maybe necessary for instance to check event sequences or dataranges.
in the case of the delayed initialization of the caster theservice engineer adds a new constraint checking the executionof the initialization steps within a time frame of seconds.the constraint is immediately activated in the monitoringinfrastructure to detect deviations from the specified behaviorin the running system.
the service engineer is notified bythe monitoring infrastructure as soon as the initialization phaseis delayed again.
violations of the new constraint are detectedand can be instantly reviewed by the engineer.
b. challenges several challenges for defining and checking constraints can be derived from our industrial case constraint diversity.
different types of constraints are needed to monitor the industrial sos.
this covers global invariants and range checks of variables across the sos temporalconstraints on the occurrence and expected order of events or architectural rules constraining the allowed interactions ofcomponents.
constraints are further required to measure prop erties such as performance or resource consumption.
regardingruntime monitoring a wide variety of approaches exist thatfocus on particular types of constraints see section viii .while these approaches focus on specific types of constraints 716there is a lack of unified approaches covering multiple types of constraints as needed in our sos runtime monitoring context.
incremental definition and runtime management of constraints.
constraints are typically not defined once beforethe system is put into operation but rather incrementallywhen needed.
for instance as our industrial scenario showed engineers may need to define additional constraints wheninvestigating an issue reported by a customer.
furthermore sos evolve continuously and are configured to address specificrequirements.
the constraints thus do not remain stable butneed to co evolve with the system to adapt to certain monitor ing scenarios .
many existing constraint checkers do notsupport the dynamic definition and management of constraintsat runtime see section viii .
specifically although activating deactivating and parameterizing constraints at runtime is sup ported by some approaches adding new constraints at runtimetypically cannot be done without restarting the monitoringinfrastructure.
end user definition of constraints.
end user support for writing constraints becomes a primary issue as a runtime mon itoring environment and its constraint checking mechanismwill be used in practice by both engineers and maintenancepersonnel.
while many existing constraint languages addressthe needs of software developers see section viii writingnew or understanding existing constraints is much harder forusers without a deep programming background.
iii.
a c onstraint dsl for sosm onitoring existing constraint languages e.g.
requirements level methods uml based approaches orformal runtime verification techniques often supportspecific types of constraints.
for example some approachesfocus on monitoring performance properties while othersemphasize temporal properties or support aggregating andchecking data.
additionally most existing approaches havebeen developed for a particular application domain e.g.
service based systems or business processes and are hard to apply in other areas.
furthermore manyexisting constraint languages are deemed as inconvenient byindustrial end users as they require deep understanding offormal concepts or lack tool support.
we conducted a series of workshops and interviews with engineers and project managers of our industry partner toelicit requirements for a constraint language for sos runtimemonitoring based on concepts from existing constraint lan guages.
emphasizing usefulness and practical applicability wethen developed a dsl allowing engineers to specify temporal structural and data constraints on events and data.
we assume a stream of events observed at runtime by a monitoring infrastructure.
the events are collected in anevent model also managing arbitrary data attached to specificevents.
for example events in a material quality optimizationsystem show when the system starts initializes optimizes and stores the optimization results.
each event has a timestamp and data can be attached e.g.
the inputs used forinitializing the optimization system the computed optimizationresults or information on the performance of the optimizationcomponent.listing grammar of our constraint dsl for specifying pastoccurrence future occurrence and data constraints constraint trigger if event trigger event occurs pastoccurrence futureoccurrence datacheck .
pastoccurrence condition event event name has occurred events event name event name occurred previously in the last time futureoccurrence condition event event name occurs events event name event name occur within time datacheck condition data data data data dataitem operator dataitem value dataitem key itemname itempath function contains size time int milliseconds seconds minutes hours operator !
value double int boolean string the grammar of our dsl is shown in listing .
each constraint starts with a description of the trigger event activating the evaluation of the constraint cf.
fig.
e.g.
optimizationrequested .
to also allow specifying invariants the event typeof the trigger event can be defined as any .
the triggerspecification is followed by a condition statement.
conditions can be defined to check the past occurrence of a sequence of event s before the trigger event the future occurrence of a sequence of event s after the trigger event or data attached to the trigger event.
arbitrary or specific orders of sequencescan be defined.
conditions on the past or future occurrence of events are temporal constraints for checking restrictions regarding theoccurrence or sequential order of events i.e.
they are pre orpost conditions on these events.
for simple order restrictions an event of a certain type must occur before or after an eventof a specific type e.g.
one event of type b must occur afterany event of type a required sequence .
for hard time fig.
event stream and constraint types of our dsl.
717listing examples of three constraints from the pas future occurrence constraint checking a sequence of events with a hard time limit trigger if event controladapter .
requestoptimization occurs condition events optimizer .
optimize start optimizer .
fetchdata optimizer .
caculatefinished optimizer .
retrieveoptimizationresult cutting .
forwardoptimizationresult occur consecutively within seconds .
past occurrence constraint with a hard time limit trigger if event tundish .
ca rlockedincastposition occurs condition event tundish .
ladlearrived h a s occurred in the last milliseconds .
data constraint checking the data attached to the event system .
discinfo trigger if event system.
discinfo occurs condition data discdata drives freediscpercentage .
limits the occurrence of an event of a certain type is required within a certain time e.g.
an event of type b must occur withina maximum time of five seconds after an event of type a hasoccurred.
data constraints check certain items contained in runtime data objects attached to an event.
for numeric values boundarychecks are frequently used e.g.
to ensure a data item is withina certain range.
for character sequences usually only checksfor equality are used.
data conditions in our dsl can alsocontain functions e.g.
to count the number of elements in alist to check whether a list of data objects contains a certainitem or to calculate the maximum minimum or averageof a set of values.
it is also possible to combine past andfuture occurrence checks with data checks e.g.
to determineif a certain event occurred with the attached data fulfilling aparticular condition.
listing shows three examples from the pas a constraint checking the future occurrence of an event sequence in aparticular order including a hard time limit for the optimizationsystem cycle a constraint on the past occurrence of a particularevent with a hard time limit checking that the ladle has arrivedbefore starting casting and a data constraint checking that freedisc space is larger than .
checks on past and future occurrence as well as data checks have been sufficient so far to cover the constraints elicitedtogether with our industry partner cf.
section vi.a .
however it might be necessary to extend the language in the future tocover additional types of constraints.
we have thus developed adsl based approach that makes it easy to extend the language.
iv .
e xtending an incremental consistency checker to support sosr untime monitoring as runtime monitoring presumes the continuous re evaluation of constraints an incremental evaluation strategy isadvisable to ensure fast evaluation feedback to users in caseof violations.
we therefore decided to use an incrementalconsistency checker icc developed in ourprevious work on consistency checking of design models inan ide.
to address the challenges identified in section iiwe extended the original icc to support runtime checkingof events and data.
we also integrated this new runtimeincremental consistency checker ricc in our sos runtimemonitoring framework .
more specifically the ricc cf.
fig.
covers the existing runtime monitoring framework the extensions necessary touse the icc for runtime monitoring and the original icc.
ontop of the ricc we added the extensible dsl to support endusers defining constraints in a simple and intuitive manner.the constraints are translated to the underlying language ofthe icc which is java in our current implementation.
whendeveloping the ricc we reorganized the original icc whichwas integrated in an ide into several components.
we nowuse a client server architecture allowing multiple users tocontribute and modify constraints.
constraints can be addedto the checker at any time without restarting as the dsl codeis compiled dynamically to java.
furthermore we provide toolsupport for different monitoring tasks an editor to write newconstraints a tool for activating and deactivating constraintson the monitoring server and a tool for reviewing constraintviolations of different components and systems of the sos atruntime.
the ricc relies on events provided by the runtime monitoring framework which uses an event model to abstract from different systems and technologies.
the event modelenables checking across system boundaries by linking eventsprovided by probes instrumenting different systems.
it alsoprovides the foundation for tools visualizing behaviour per sisting event logs or checking constraints on events.
eventsare distinguished by their type.
types can be arranged hi erarchically to reflect the location in the system structure.for example in the pas caster system the event type op timizer.optimize start is a child of the optimizer type which again is a child of the caster type.
furthermore eventsare distinguished by their source i.e.
the probes instrumentingsystems or components in the sos.
each event has a time stampand arbitrary data can be attached e.g.
primitive data types objects as well as arrays and lists of data types or objects.event data can also carry performance information about theinstrumented system.
anevent model facade allows the icc typically running on a separate server to register to the event model as listenerand to connect with the runtime monitoring infrastructure i.e.
the event model .
the facade is informed about new incomingevents of certain types from specific possibly distributed sources.
the dsl editor provides support for writing constraints in our dsl including meta data such as a description acustom error message or a severity class.
we refer to aconstraint defined in the dsl editor as a constraint definition .
as soon as the constraint definition is transmitted to thechecking server it is compiled to java on the fly by thericc to a compiled constraint definition thereby making it usable by the icc.
the constraint manager allows activating deactivating and modifying groups of constraints.
the constraint instance store is a central component responsible for maintaining and instantiating compiled con straints.
an active constraint is not instantiated permanentlybut only if an event occurs that matches the trigger eventdefined for this constraint.
each created constraint instance is 718fig.
our runtime incremental consistency checker ricc and its integration with our runtime monitoring framework.
the numbers indicate how the different components interact in a typical scenario.
completely self contained and can be evaluated independently.
this ensures that even for a high number of incoming eventsonly selected constraints are instantiated and checked.
depending on the type of constraint a constraint instance may need to be evaluated immediately after instantiation e.g.
when checking data attached to the triggering event or the pastoccurrence of events or it may need to be postponed untilfuture events arrive.
this task is handled by the evaluation delay manager which extends the original icc and addscapabilities for intercepting constraint evaluation requests.
itdelays their evaluation and executes them only when requiredevents arrive or as soon as a specified timeout occurs.
if a constraint can be evaluated it is passed to the icc s constraint engine.
the constraint is evaluated by executingits code thereby accessing the event model via the eventmodel facade to retrieve events or data if necessary.
if theconstraint instance evaluates without errors the constraint con dition evaluates to true the instance is immediately destroyedand removed from the checker.
if the constraint instance isviolated and evaluates to false further information on theviolation is forwarded to the error handler.
this includes the events leading to the violation missing events or violateddata ranges.
listeners can register to this component to receivethis information.
for instance the runtime error manager tool displays this information as soon as it becomes availableto allow users reviewing occurring violations immediately.violations can also be persisted for later inspection.
v. i mplementa tion and tools the ricc has been developed using different components and technologies.
the event model has been implemented injava as part of the runtime monitoring infrastructure .
themodel provides interfaces for retrieving events of a certain typeor from a specific source.
it further allows registering changelisteners informing the ricc about new events.
the dsleditor and the constraint manager tool are both implementedin java using the eclipse rcp framework.
we employed the java based frameworks xtext and xtend for developing the constraintdsl end user guidance in the editor and support for thedynamic compilation of dsl code to java code.
the frame works allow adding new language constructs in a rather simplemanner as the dsl and the transformation steps are treatedseparately and automation is provided e.g.
for supportingsyntax highlighting and auto completion in the editor as shownin fig.
a .
the implementation of the ricc is based on an earlier implementation for checking the consistency of softwareproduct lines .
we split the original icc implementationinto a client and a server part and use the java compilerapi to dynamically compile and load constraints on demand.the evaluation delay manager has been implemented as aseparate java component intercepting evaluation requests fromthe icc and postponing them in case of future occurrenceconstraints.
the error manager provides interfaces retrievinginformation on violated constraints and for registering listenersto be notified as soon as constraint violations are detected.
at runtime a graphical overview is provided of all components of the sos and their current state as shown infig.
b .
the runtime error manager shown in this view allowsreviewing constraint violations related to a specific component missing events responsible for constraint violations andadditional information provided by the constraints.
a dsl editor and constraint manager.
b runtime system overview and runtime error manager.
fig.
tools for defining and managing constraints a and for monitoring and reviewing constraint violations b .
vi.
e v alua tion our cooperation with primetals technologies allowed us to evaluate our approach by applying the runtime monitoring infrastructure and the constraint checking approach to sev eral systems in a realistic setting.
we explore two researchquestions regarding the general applicability of our approach.specifically we investigate the expressiveness of our dsl andthe scalability of the ricc in a typical monitoring scenariobased on primetals technologies sos.
rq1 is the dsl sufficiently expressive to allow its use in a real world industrial sos?
we discussed monitoring needs together with architects and engineers in several workshopsand conducted a series of interviews to assess the current prac tices at primetals technologies for developing commissioning and operating their directed sos.
furthermore we studieddocuments and analyzed different systems part of the pas.
forthe evaluation we selected requirements covering the differentsystems of the pas and formalized them as constraints.
rq2 does the constraint checking approach scale to industrial needs in the context of a real world sos?
the company gave us access to their pas simulation environment which is used to test the automation software before and duringcommissioning.
we experimented with parts of the pas ina virtual environment simulating machinery and productionplanning components.
this allowed us to use our approach inan sos environment without interfering with real productionsystems in a metallurgical plant.
we describe the resultsof simulations to address rq2.
specifically in a ten hoursimulation run we measured the number of constraints instan tiated and checks performed the memory consumption of theconstraint checking engine and the average time necessaryto evaluate single constraint instances.
we also dynamicallyadded and removed constraints during the ten hour run to testour capabilities for dynamic constraint definition and checking.
a. rq1 dsl expressiveness we performed five two hour workshops and several followup meetings with seven system experts to capture requirements which have to be monitored at runtime from differentparts of the pas.
for example at sos level various non functional requirements concern monitoring the performanceof the systems hardware.
log and trace files dumps andstack traces are continuously created which can lead to lowdisk space requiring to monitor the remaining hard disccapacity.
other requirements cover the interaction of differentparts of the system e.g.
user interface and database or thechecking of the duration of certain sequences of events.
forexample one requirement regards the maximum duration ofa metallurgical calculation.
we also monitor the optimizationcomponent which calculates the optimal distribution of steelslabs on a casting strand and relies on input data from variousother components.
overall we identified requirements fromseveral different systems of the pas to be monitored.
for each of these requirements we discussed with engineers from primetals technologies how constraints couldbe defined for checking the expected behavior at runtime.for example one requirement on the timely calculation ofoptimizations led to a future occurrence constraint.
this con straint checks that after an optimization run is triggered eitherby the operator in his user interface or by another system the optimization result has to be available within secondsand then fed to the subsequent system.
another requirementon avoiding incorrect or missing quality calculations led to apast occurrence constraint checking that when a robotic armholding a ladle full of liquid steel is starting to move the dataabout the material in the ladle must already have been updated.yet another requirement on avoiding incorrect optimizationresults led to a data constraint checking that the cross sectionoptimization value is positive and in a certain range whenoptimizations are being calculated.
during these workshops we defined at least one constraint for each requirement leading to over different constraints.so far the types of constraints our dsl allows to express weresufficient.
however future workshops might reveal new typesof constraints requiring the extension of our dsl.
for now wecan claim our dsl is expressive enough to define constraintsfor monitoring the industrial sos.
720table i overview of the constraints used for the evaluation describing the number of checks performed checks and the median evaluation time met for each constraintduring the ten hour evaluation run.
const.
type name checks met cst future planchangeusercheck .
cst future castsequencev aliditycheck .
cst data checkcrosssectionrange .
cst data checkoptirunid .
cst past checkcastingarmprocedure .
cst data checkavailablediskspace .
cst data checkavailablestorage .
cst data checkcastwatchdogstates .
cst future checkopticalcrun .
cst future checkoptirunconsistency .
cst data checkstrandnumbersv alid .
cst future checkoptiruncycle .
cst past checkstrandspeedlength .
b. rq2 ricc scalability for evaluating the scalability and applicability of the checking approach to a real world sos we used our monitoringinfrastructure and the pas simulation environment to performa ten hour evaluation run.
not all constraints we defined can bemonitored in the provided simulator because it cannot run allrequired systems.
we thus selected constraints cf.
table i details are not shown due to non disclosure agreements toevaluate the scalability of the ricc as described below.
whilethis might seem like a small number the number of checks almost 70k performed on instantiated constraints based onalmost 500k events still allows us to demonstrate scalability.
the goal of our evaluation was to investigate whether the constraint checker can handle a realistic number of eventswithout significant increases in execution time and memoryusage.
we also assessed the capabilities for dynamically addingand removing constraints by incrementally adding constraintsand later again deactivating them.
we started with five active constraints cst cst and added added four constraints cst cst after onehour followed by four more constraints cst cst after another hour.
the evaluation then continued for sixhours with the full set of constraints active.
after eightrespectively nine hours we again reduced the number of activeconstraints by removing cst cst and cst cst .
the simulation environment and the monitoring infras tructure were set up on a standard desktop machine with anintel r core tm i5 cpu .60ghz 16gb ram runningwindows bit.
we measured the number of events that occurred the number of constraints instantiated from the constraint definitions i.e.
the checks performed the median evaluation time foreach constraint in ms the maximum number of constraintinstances alive at a certain point in time and the memoryconsumption of the constraint checker in mb .
during theten hours of the simulation run events and theirrelated data were captured and constraints checks wereperformed resulting in an average of checks per minute.
for each constraint instance we measured the time requiredfor executing the method which checks the constraint andgenerates violations in case of errors.
the goal was to assesswhether the number of active constraints negatively influencesthe evaluation time.
the median evaluation time for a constraint instance ranges from .
ms for cst up to ms for cst .
fig.
pro vides an overview of the evaluation times during the simulationgrouped by the different constraint types.
the comparably highmedian evaluation times for data constraints cst cst and cst can be explained by the size and complexity ofthe data items that need to be checked for these constraints.also there are a few outliers for constraints cst cst and cst details cf.
fig.
a .
nevertheless the evaluationtime was always less than one second which still allows toprovide instant feedback to users.
also the values indicate thatfor future occurrence constraints fig.
c past occurrenceconstraints fig.
b and data constraints fig.
d thenumber of active constraints does not at all influence theevaluation time.
the maximum number of active constraint instances for a measure point ranges from for most constraints to 137for constraint cst .
as described a constraint instance iscreated only when needed and immediately destroyed afterits evaluation.
this is also confirmed by the memory usageof the java virtual machine running the constraint checker.in case of cst due to its type i.e.
past occurrence andthe rather high number of instances that have to be evaluated constraint instances are queued before they are destroyed.still despite this queuing the memory usage does not increasenoticeably remaining between mb lower quartile and412 mb upper quartile during the simulation run.
c. discussion of results and threats to v alidity our evaluation confirms that we could express all constraints elicited for the pas sos so far rq1 and that the underlying constraint checker was able to handle the highnumber of incoming events and perform all constraint checksfast enough to provide instant feedback rq2 .
in terms of external validity the results and findings are based on a single directed sos in the domain of industrialautomation.
we thus cannot claim that the dsl is capableof covering all possible types of constraints in other systems.however our knowledge of other systems suggests similarconstraint patterns.
due to the flexibility and extensibility ofboth the dsl and the underlying constraint checker it is possi ble to consider additional constraint types if needed and adaptthe constraint checker accordingly.
also the requirements andconstraints selected for the evaluation might not cover the fullrange of requirements existing in the industrial sos.
however given the scale and complexity of the pas we consider ourevaluation a good starting point representing a realistic case.we plan to conduct further evaluations with different systemsin the future.
the evaluation focuses on the expressiveness of the dsl rq1 and on the scalability of the constraintchecker rq2 .
we deliberately did not discuss end user toolsin detail as this is part of a separate study assessing theusefulness of the different tools and editors for writing andmanaging constraints.
however the constraints and the dsl a boxplots of evaluation times in ms for all constraints.
b distribution of evaluation times for future occurrence constraints cst cst cst cst cst c distribution of evaluation times for past occurrence constraints cst cst d distribution of evaluation times for data constraints cst cst cst cst cst cst fig.
overview of median evaluation times for all constraints a and distributions of evaluation times separately for future occurrence b past occurrence c and data constraints d over the ten hour simulation run.
we activated constraints after oneand after two hours and deactivated them again after eight and nine hours as shown by the vertical lines.
were developed together with engineers of our industry partner leading to rapid feedback which resulted in several adaptationsand improvements during the development process.
regarding the rather small number of constraints used in our scalability evaluation the number of constraintinstances created at runtime and the number of constraintchecks performed have a much higher impact on the scalabilityof the checker.
we demonstrated in our evaluation that even forconstraints leading to many instances and checks cf.
cst our approach ensures immediate feedback.
our evaluation did not measure the overhead caused by the probes instrumenting the system.
we also did not considerthe performance of the monitoring infrastructure which isnot directly part of the constraint checking mechanism andrunning on a separate server.
however earlier evaluations confirm that the underlying infrastructure is capable of hand ling a high amount of events.
events used for checkingconstraints in our evaluation are provided by probes usingaspectj a separate evaluation weconducted shows that the overhead for our probes ranges from1 to for typical instrumentations but can go up to when serializing complex data structures that are later checkedin a constraint.
however the probes used in our evaluationare small atomic code fragments only collecting specific datain the sos and serializing complex objects was rather theexception.
furthermore all additional processing and analysistasks are performed independently on a separate machine tokeep the impact on the monitored systems low.vii.
l essons learned we summarize experiences and lessons learned of developing our dsl based checker which may be useful forresearchers and practitioners working on similar challenges.
systems of systems require an iterative language design.
the heterogeneous systems in an sos and the diverse teams in volved in their development and maintenance make it difficultto develop a language addressing the different needs.
whendeveloping our constraint dsl we started with interviewingdifferent teams responsible for different systems to identifycommon requirements for the language.
we showed eachversion of the dsl to these teams and refined it accordingto their comments.
this iterative language design helped tocome up with a solution that is acceptable for its users.
keep the yagni you aren t gonna need it principle in mind when developing a dsl.
when starting our collaborationwith primetals technologies we analyzed diverse existingconstraint languages and formal notations used for defining theexpected behavior of a running system.
although we foundseveral of these approaches quite appealing the reaction ofour industry partner was different.
this was mainly becausethe languages provided too many features not needed for theircontext and defining constraints was regarded as difficult usingformal notations.
they wanted to define the constraints as closeas possible to natural language and liked the structured prosetechnique we proposed to them.
a key lesson thus is to keepa language as simple as possible and to cover only what isnecessary for the concrete context.
the constraint language 722should be oriented towards end users and hide the complexities of the underlying constraint checker.
simplify and automate extending the dsl.
while keeping the constraint language simple definitely makes sense forpractical use new types of constraints and checks might still beneeded.
for example while we started with support for simplerange checks for data constraints with primitive data objects later the need arose for more complex checks of data objectsand their relations.
it is thus essential to allow extending thelanguage at any time.
we thus employed technologies suchas xtext and xtend which make it easy to compile to atarget language like java from a dsl and to generate end user support for a dsl based on a grammar.
keep the mapping of the constraint dsl to the constraint checker flexible.
during our project we also learned that itmight be required to exchange the underlying checker e.g.
when the number of events to be monitored becomes too highimpacting the checker s performance too much.
so far ourjava based incremental checker worked fine as demonstrated inthe evaluation.
however future needs might require switchingto a checker providing higher performance for certain typesof constraints.
it is thus advisable to define a clear interfacebetween the language and the checker to allow replacing both.for instance while keeping our simple dsl one could re place our checker with another checker that supports checkingtemporal and data constraints.
only the compilation of ourconstraints to the target language of the checker would thenhave to be changed.
support dynamic constraint management in runtime monitoring.
industrial scenarios demonstrate the need to add newor modify existing constraints even while the system andthe monitoring infrastructure are running e.g.
to investigatean unforeseen issue.
providing a dynamic approach is thusneeded.
a positive side effect is also the performance of theconstraint checker which dynamically instantiates constraintsand immediately destroys constraints after their evaluationresults have been stored.
viii.
r ela ted work different research communities have been developing approaches for monitoring systems to detect violations of re quirements at runtime.
examples include requirements mon itoring performance monitoring complex event pro cessing or runtime verification .
requirements monitoring approaches aim at determining the compliance of a system with its requirements duringruntime .
monitors are used to detect requirementsviolations and serve as a starting point for revealing the rootcause of problems.
for example robinson has proposedthe reqmon framework including a language for definingrequirements and tools supporting different user roles duringmonitoring.
reqmon supports formalizing high level goals requirements and their monitors.
it automates generating anddeploying monitors and provides traceability between high level descriptions and lower level runtime events.
performance and event monitoring approaches focus on monitoring specific aspects of a running system e.g.
relatedwith performance.
bubak et al.
for instance proposethe j ocm approach supporting programmers in developingmonitoring tools for distributed java applications at the virtualmachine level by providing uniform and extensible monitoringfacilities for communication between different components.their work is based on the online monitoring interfacespecification omis providing a standardized interfacebetween monitoring tools and the systems to be monitored.v an hoorn et al.
describe kieker an extensible frame work for event and application performance monitoring.
theframework provides capabilities for system instrumentation event recording event processing and basic visualization.
requirements monitoring and event monitoring approaches provide a solid basis for monitoring specific aspects of singlesystems e.g.
performance data flow or system communi cation but are limited regarding the diversity of constraintsand support for constraint checking in sos architectures.
complex event processing cep is an approach for monitoring arbitrary business processes.
it aims at combiningevent streams gathered from multiple sources to infer eventsor patterns of events.
event patterns are typically described byimplementing rules in some higher programming language orin an event description language.
while we are not focusingon monitoring business processes cep makes use of somecommon concepts that are related with our work i.e.
eventdescription languages can be seen as dsls useful to describeconstraints to be monitored.
furthermore in the domain of runtime verification various approaches have been proposed to support monitoring andverifying system properties.
for instance calinescu et al.
propose a three staged process of monitoring analysis andplanning.
a system model is verified to detect violations ofrequirements.
ghezzi et al.
present the spy runtimeapproach that relies on behavior models which are representedby finite state automata.
an initial model is inferred in a setupphase and then used at runtime to detect changes.
in these and other domains a wide variety of different constraint languages exist for defining requirements system properties or desired event sequences.
for example spanoudakiset al.
present serenity a framework for monitoringsecurity and dependability properties.
monitoring rules areexpressed as ec assertions a temporal formal language basedon the event calculus.
ec assertions are used to detect viola tions within streams of runtime events which are are providedby different distributed sources.
the language is xml basedand provides language support for event occurrences suchashappens holdsat o r terminates.
viswanathan et al.
developed two constraint languages for their mac moni toring and checking architecture pedl primitive eventdefinition language for writing low level specifications andmedl meta event definition language for defining safetyrequirements.
this separation allows to adapt to differentimplementation languages and specification formalisms e.g.
java mac for java programs .
baresi et al.
presentmlccl the multi layer collection and constraint languagepart of the ecoware framework for monitoring service basedsystems.
besides constraints for analyzing events the languagealso provides capabilities for defining how to collect messagesor key performance indicators and how to aggregate datafrom multiple objects.
montali et al.
present declare adeclarative business process constraint language part of the 723mobucon ec monitoring framework.
the language is based on the event calculus and allows defining sets of rules thatmust be satisfied in order to correctly execute a given process.they distinguish between four different types of constraints existence choice relation and negation.
bertolino et al.
present a property driven approach for runtime monitoring.
aproperty meta model allows the definition of quantitative andqualitative properties.
the approach further distinguishes be tween abstract properties for generic declarations descriptiveproperties describing guaranteed properties and perspectiveproperties describing system requirements.
the approach usesthe glimpse framework for monitoring distributed systemsand checking the properties at runtime.
aktug et al.
present an approach for monitoring security properties.
theyuse a security specification language called conspec to de scribe automata for security requirements.
existing constraint languages however do not support all three challenges in sos monitoring i.e.
coping with thediversity of constraints in large scale systems supporting theincremental definition and runtime management of constraints and providing end user support for constraint definition.
existing work also often uses temporal logic to support monitoring software systems.
several authors have shown theexpressiveness and usefulness of such formalisms .however these approaches usually operate on event tracesand do not support the incremental definition and runtimemanagement of constraints.
also they are often difficult touse by industrial end users at least in our experience.
developing domain specific languages to support industrial end users in complex tasks has been discussed in detailin related work e.g.
by hermans et al.
in the area ofweb services and by v oelter and visser in the area ofproduct line engineering.
hermans et al.
have identified severalsuccess factors for the use of dsls in an industrial context reliability usability productivity learnability expressiveness and reusability.
our experiences confirm these success factors.our evaluation focused on the expressiveness of the constraintdsl and the scalability of the checker.
we have also discussedthe reusability of our dsl i.e.
that it is flexible and canbe adapted an automated manner.
assessing productivity andreliability requires longitudinal studies which we plan toconduct as part of our future work.
also we plan to assessusability and learnability in studies with our industry partner.in this regard we will consider the experimental evaluationsperformed for p ropel an approach guiding users through the process of defining formal property specifications.
similarto we also plan to assess the usefulness of our dsl fordefining requirements to be used for runtime monitoring.
ix.
c onclusions and future work based on a scenario of monitoring an industrial system of systems we derived challenges regarding the definition andchecking of constraints at runtime.
existing languages andcheckers cannot easily be applied in an sos context due tothe diversity of constraints required the need to incrementallydefine and manage constraints and the required end usersupport.
we have described a constraint dsl for industrial endusers and an incremental checker we have been developing toaddress these challenges.our approach supports the incremental checking of constraints at runtime and provides live and instant feedback tousers.
our checker also supports the incremental definitionand dynamic deployment of constraints at runtime withoutstopping the checker and the monitored system.
we evaluatedthe expressiveness of our constraint dsl using real constraintsfrom our industrial case and the scalability of our checkerin an industrial monitoring scenario.
our experiences suggestdesigning a constraint dsl in an iterative manner and keepingit as simple as possible.
we also learned to keep the mappingof the dsl to the checking engine flexible to allow switchingunderlying checking technologies.
in our future work we aim to perform a usability assessment of our tools particularly the constraint dsl editor involving industrial end users.
we further want to applyour approach to systems in other domains and in longitudinalstudies.
furthermore we are currently working on a frameworkto support the systematic comparison of existing constraint lan guages and formalisms regarding their usefulness for particularmonitoring scenarios.
a cknowledgments this work has been supported by the christian doppler forschungsgesellschaft austria and primetals technologies.we particularly want to thank christian danner klaus sey erlehner stefan wallner and helmut zeisel for their feedbackand support.
special thanks go to benedikt aumayr for devel oping the first version of the constraint dsl and checker.
r eferences m. w. maier architecting principles for systems of systems systems engineering vol.
no.
pp.
.
m. dwyer g. avrunin and j. corbett patterns in property specifications for finite state verification in proceedings of the int l conference on software engineering.
ieee may pp.
.
n. maiden monitoring our requirements ieee software vol.
no.
pp.
.
w. n. robinson a requirements monitoring framework for enterprise systems requirements engineering vol.
no.
pp.
.
h. muccini a. polini f. ricci and a. bertolino monitoring architectural properties in dynamic component based systems in componentbased software engineering lncs .
springer pp.
.
m. v olz b. koldehofe and k. rothermel supporting strong reliability for distributed complex event processing systems in 13th int l conference on high performance computing communication banff canada.
ieee pp.
.
r. calinescu c. ghezzi m. z. kwiatkowska and r. mirandola selfadaptive software needs quantitative verification at runtime communications of the acm vol.
no.
pp.
.
c. ghezzi a. mocci and m. sangiorgio runtime monitoring of component changes with spy runtime in 34th int l conference on software engineering zurich switzerland pp.
.
m. viswanathan and m. kim foundations for the run time monitoring of reactive systems fundamentals of the mac language in theoretical aspects of computing 1st int l ictac colloquium revised selectedpapers ser.
lecture notes in computer science z. liu andk.
araki eds.
springer pp.
.
f. chen m. d amorim and g. ros u a formal monitoring based framework for software development and analysis in formal methods and software engineering.
springer pp.
.
h. gunadi and a. tiu efficient runtime monitoring with metric temporal logic a case study in the android operating system inproceedings formal methods fm .
springer pp.
.
a. bauer m. leucker and c. schallhart monitoring of real time properties in foundations of software technology and theoretical computer science fsttcs .
springer pp.
.
a. paschke rbsla a declarative rule based service level agreement language based on ruleml in int l conference on computational intelligence for modelling control and automation and int l conference on intelligent agents web technologies and internet commerce vol.
.ieee pp.
.
w. robinson extended ocl for goal monitoring electronic communication of the european association of software science andtechnology vol.
no.
pp.
.
l. baresi and s. guinea event based multi level service monitoring inproceedings 20th int l conference on web services icws .
ieee pp.
.
h. phan g. s. avrunin and l. a. clarke considering the exceptional incorporating exceptions into property specifications department of computer science university of massachusetts amherst ma vol.
.
m. mansouri samani and m. sloman monitoring distributed systems ieee network vol.
no.
pp.
.
t. bures p .
hnetynka and f. plasil strengthening architectures of smart cps by modeling them as runtime product lines in proceedings of the 17th int l acm sigsoft symposium on component based softwareengineering cbse .
acm pp.
.
c. jeffery m. auguston and s. underwood towards fully automatic execution monitoring in radical innovations of software and systems engineering in the future.
springer pp.
.
k. havelund and g. ros u efficient monitoring of safety properties int l journal on software tools for technology transfer vol.
no.
pp.
.
a. van hoorn j. waller and w. hasselbring kieker a framework for application performance monitoring and dynamic software analysis inproceedings 3rd joint int l conference on performance engineering pp.
.
a. egyed instant consistency checking for the uml in proceedings of the 28th int l conference on software engineering.
acm pp.
.
m. vierhauser p .
gr unbacher a. egyed r. rabiser and w. heider flexible and scalable consistency checking on product line variabil ity models in proceedings int l conference on automated software engineering pp.
.
m. vierhauser r. rabiser p .
gr unbacher k. seyerlehner s. wallner and h. zeisel reminds a flexible runtime monitoring framework forsystems of systems journal of systems and software .
m. vierhauser r. rabiser and p .
gr unbacher a case study on testing commissioning and operation of very large scale software systems in36th int l conference on software engineering.
hyderabad india acm pp.
.
r. rabiser m. vierhauser and p .
gr unbacher v ariability management for a runtime monitoring infrastructure in proceedings of the ninth int l workshop on v ariability modelling of software intensive systems v amos hildesheim germany january p. .
a. van lamsweerde requirements engineering from system goals to uml models to software specifications.
wiley .
j. skene and w. emmerich engineering runtime requirementsmonitoring systems using mda technologies in trustworthy global computing.
springer pp.
.
j. whittle p .
sawyer n. bencomo b. cheng and j. m. bruel relax a language to address uncertainty in self adaptive systemsrequirement requirements engineering vol.
no.
pp.
.
p .
zhang b. li h. muccini and m. sun an approach to monitor scenario based temporal properties in web service compositions inadvanced web and network technologies and applications.
springer pp.
.
k. kiviluoma j. koskinen and t. mikkonen run time monitoring of architecturally significant behaviors using behavioral profiles andaspects in proceedings of the int l symposium on software testing and analysis.
acm pp.
.
l. baresi s. guinea o. nano and g. spanoudakis comprehensive monitoring of bpel processes ieee internet computing vol.
no.
pp.
.
d. c. luckham event processing for business organizing the real time enterprise.
john wiley sons .
m. vierhauser p .
gr unbacher w. heider g. holl and d. lettner applying a consistency checking framework for heterogeneous modelsand artifacts in industrial product lines in model driven engineering languages and systems.
springer pp.
.
s. fickas and m. s. feather requirements monitoring in dynamic environments in 2nd ieee int l symposium on requirements engineering york england pp.
.
m. bubak w. funika m. smetek z. kilia nski and r. wism uller event handling in the j ocm monitoring system in parallel processing and applied mathematics.
springer pp.
.
t. ludwig r. wism uller v .
sunderam and a. bode omis online monitoring interface specification v. .
technische universit at m unchen tech.
rep. tum i9733 .
g. spanoudakis c. kloukinas and k. mahbub the serenity runtime monitoring framework in security and dependability for ambient intelligence.
springer pp.
.
m. kim m. viswanathan s. kannan i. lee and o. sokolsky javamac a run time assurance approach for java programs formal methods in system design vol.
no.
pp.
.
m. montali f. m. maggi f. chesani p .
mello and w. m. van der aalst monitoring business constraints with the event calculus acm trans.
intell.
syst.
technol.
vol.
no.
pp.
jan. .
a. bertolino a. calabr o f. lonetti a. di marco and a. sabetta towards a model driven infrastructure for runtime monitoring insoftware engineering for resilient systems.
springer pp.
.
i. aktug m. dam and d. gurov provably correct runtime monitoring in formal methods fm .
springer pp.
.
f. hermans m. pinzger and a. van deursen domain specific languages in practice a user study on the success factors in model driven engineering languages and systems ser.
lecture notes incomputer science a. sch urr and b. selic eds.
springer berlin heidelberg pp.
.
m. v oelter and e. visser product line engineering using domainspecific languages in 15th int l software product line conference splc .
munich germany ieee cs pp.
.
r. l. cobleigh g. s. avrunin and l. a. clarke user guidance for creating precise and accessible property specifications in proceedings of the 14th acm sigsoft int l symposium on foundations of softwareengineering ser.
sigsoft fse .
acm pp.
.