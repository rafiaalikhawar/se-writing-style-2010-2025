systematically covering input structure nikolas havrikov cispa helmholtz center for information security saarland informatics campus nikolas.havrikov cispa.saarlandandreas zeller cispa helmholtz center for information security saarland informatics campus zeller cispa.saarland abstract grammar based testing uses a given grammar to produce syntactically valid inputs.
to cover program features it is necessary to also cover input features say all url variants for a url parser .
our k path algorithm for grammar production systematically covers syntactic elements as well as their combinations.
in our evaluation we show that this results in a significantly higher code coverage than state of the art.
i. i ntroduction testing programs with randomly generated inputs or fuzzing is a cost effective means to test programs for robustness if a program has not been subjected to random inputs before the chances are high that some input will cause the program to fail.
to reach deeper layers of a program though inputs must besyntactically valid because invalid inputs would be rejected already during initial input processing.
to this end recent fuzzing approaches make use of grammars to specify the language of program inputs.
a grammar based test generator uses a grammar to expand a start symbol into further symbols often selecting from alternatives which it would repeatedly expand until only terminal symbols are left.
for the grammar shown in figure for instance the expr start symbol may expand into an addexpr and then a multexpr which again may expand into a unaryexpr which would eventually become a string of digits.
while the concept of producing inputs from grammars is simple any practical implementation has to struggle with two problems.
the first issue is to ensure an input does not grow beyond bounds.
in figure if the producer always selects the last expansion alternative the result will be an infinitely long arithmetic expression.
a producer thus needs means to determine which expansion to choose in order to avoid such growth.
the second issue of producing from grammars is to ensure input coverage.
intuitively a high variation in the inputs say operators induces a high variation in program behavior.
conversely if some input element is not present in the input say the code that processes it will not be executed.
it is thus desirable to cover as many different input elements and productions as possible.
in our expression grammar this means to cover all operators and all digits.
how does one maximize coverage?
one way suggested by purdom is to ensure that during production uncovered production alternatives would be preferred over covered production alternatives.
in figure we would first expand addexprexpr addexpr addexpr multexpr addexpr multexpr multexpr unaryexpr multexpr unaryexpr unaryexpr identifier unaryexpr unaryexpr unaryexpr unaryexpr decdigits addexpr decdigits decdigit decdigit identifier x y z figure grammar for javascript expressions simplified decdigit x0 x2 x3 x5 x6 x0 x1 x3 x4 ... x1 x2 x4 x5 x9 figure a decdigit rule variant that is hard to cover into the first alternative multexpr and the next time into the second alternative.
likewise once we have covered the alternative we d go for the alternative the next time.
over time purdom s approach would cover all alternatives.
unfortunately there are grammars where neither the random nor purdom s approach help in achieving coverage.
this becomes apparent when we reformulate the decdigit rules as shown in figure .
now the digits are no longer chosen and produced uniformly.
choosing a decdigit expansion at random yields a chance of producing a a chance of a and a .
chance of producing a .
clearly we would want to cover all terminals quickly but on average it would take inputs until we see produced.
purdom s approach helps a bit but is far from perfect in the first expansion of x0 it would mark as covered then expanding x1the second time with a chance of producing a .
however after having both covered and x1 it would no longer prefer one over the other still yielding expansions.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
identifier identifier character identifier character asciicharacter unicodecharacter asciicharacter asciiupper asciilower figure an identifier rule that is hard to cover if figure feels a bit too pathological consider figure listing possible rules for identifiers.
not only does this formulation result in identifiers consisting of one character only also both identifier alternatives would be quickly marked as covered by purdom s approach.
in other words our producer would have no incentive to systematically cover identifier characters or their categories.
the deeper the grammar the greater the extent of this coverage problem.
in this paper we introduce a novel grammar production algorithm called k path that addresses all these issues input coverage.
the k path algorithm ensures quick coverage of all grammar features.
specifically it chooses expansion alternatives that lead to input elements not covered yet applied on figure its first ten productions consist of the elements to on figure it produces long identifiers that cover all valid character elements.
combination coverage.
the k path algorithm ensures if wanted coverage of combinations of grammar features whose context size is controlled by k. applied on figure for instance it produces additions within multiplications multiplications within additions unary minuses within parentheses and all sorts of combinations one would want to test in a symbolic calculator for instance.
growth control.
the k path algorithm effectively limits growth beyond bounds.
if the number or depth of elements produced exceeds a certain threshold the k path algorithm will always choose alternatives that eventually end in terminal symbols thus ensuring a quick closure of production.
these features are effective.
compared against a state ofthe art grammar producer grammarinator our tribble prototype implementing k path results in a higher code coverage in the same time.
these benefits are not limited to text inputs alone.
we show that a number of classical testing domains configuration testing ui testing reactive systems can be encoded as grammars resulting in k path systematically covering all features interactions and commands as well as their sequences.
to the best of our knowledge k path is the first algorithm systematically and universally striving for deep coverage beyond individual production rules.
the remainder of this paper is organized as follows.
section ii introduces grammars their elements and derivations.
section iii details coverage criteria for grammars including k path coverage.
section iv derives the k path production algorithm which systematically satisfies these coverage criteria.
after giving implementation details section v section vi evaluates the k path algorithm comparing against the grammarinator state of the art producer.
section vii discusses further applications beyond text inputs encoding problems such asgrammar production production nonterminal alternation alternation concatenation concatenation concatenation atom atom parenleftbig alternation literal reference parenrightbigquantifier ?
quantifier ?
num num num num figure a grammar for context free grammars excerpt configuration testing ui testing or reactive systems as grammars that can be effectively handled by the k path algorithm.
after discussing related work section viii section ix closes with conclusion and future work.
ii.
g rammars and deriv a tions in this work we consider test generation based on contextfree grammars.
we assume the reader is familiar with the concept of context free grammars for the purpose of precision we introduce their syntax semantics and composition as used in this paper.
a. composition to name and define the individual elements of the grammars as used in this paper we use well a grammar that describes their names and syntax.
as detailed in figure a grammar consists of productions each of which expands a nonterminal into an alternation .
the grammar in figure for instance has seven such productions one for each nonterminal.
an alternation is a sequence of alternatives over non empty sequences of concatenations .
a concatenation consists of atoms which can be parenthesized alternations literals or