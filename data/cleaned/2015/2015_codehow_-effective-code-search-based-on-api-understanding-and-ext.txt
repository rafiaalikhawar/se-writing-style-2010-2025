singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems codehow e ffectiv e code sear ch based on api understanding codehow e ffectiv e code sear ch based on api understanding and extended boolean model e and extended boolean model e fei lv shanghai jiaot ong univ ersity jian guang l ou shanghai jiaot ong univ ersity shaowei w ang singapor e management univ ersity dongmei zh ang micr osoft resear ch beijing jainjun zh ao shanghai jiaot ong univ ersity follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the programming languages and compilers commons and the softwar e engineering commons citation citation lv fei lou jian guang w ang shaowei zh ang dongmei and zh ao jainjun.
codehow e ffectiv e code sear ch based on api understanding and extended boolean model e .
.
30th ieee a cm international conf erence on a utomated softwar e engineering ase lincoln ne no vember proceedings .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
codehow effective code search based on api understanding and extended boolean model fei lv hongyu zhangy jian guang louy shaowei wangz dongmei zhangy and jianjun zhaox school of software shanghai jiao tong university china lvfei sjtu sjtu.edu.cn ymicrosoft research beijing china fhonzhang jlou dongmeiz g microsoft.com zschool of information systems singapore management university singapore shaoweiwang.
phdis.smu.edu.sg xdepartment of computer science and engineering shanghai jiao tong university china zhao jj sjtu.edu.cn abstract over the years of software development a vast amount of source code has been accumulated.
many code search tools were proposed to help programmers reuse previouslywritten code by performing free text queries over a large scale codebase.
our experience shows that the accuracy of these code search tools are often unsatisfactory.
one major reason is that existing tools lack of query understanding ability.
in this paper we propose codehow a code search technique that can recognize potential apis a user query refers to.
having understood the potentially relevant apis codehow expands the query with the apis and performs code retrieval by applying the extended boolean model which considers the impact of both text similarity and potential apis on code search.
we deploy the backend of codehow as a microsoft azure service and implement the frontend as a visual studio extension.
we evaluate codehow on a large scale codebase consisting of 26k c projects downloaded from github.
the experimental results show that when the top results are inspected codehow achieves a precision score of .
i.e.
.
of the first returned results are relevant code snippets .
the results also show that codehow outperforms conventional code search tools.
furthermore we perform a controlled experiment and a survey of microsoft developers.
the results confirm the usefulness and effectiveness of codehow in programming practices.
i. i ntroduction programming is sometimes hard.
one of the challenges a programmer faces when writing new code is to find out how to implement a certain functionality e.g.
how to implement quick sort .
the other challenge a programmer faces is the reuse of an application programming interface api e.g.
file.appendtext in .net framework .
a large scale software framework such as the .net framework could contain hundreds or even thousands of apis.
programmers often do not remember exactly how a certain api method should be reused.
in a survey conducted at microsoft in .
respondents mentioned that there are obstacles caused by inadequate or absent resources for learning apis .
over years a huge number of open source and industrial software systems have been developed.
the source code of these systems is typically stored in source code repositories and can be treated as important reusable assets for developers.
previously written programs can help developers understand how others addressed the similar problems and can serve as abasis for writing new programs.
thus there is a great demand for automated tools that can help developers search through a large codebase to find relevant code for a specific programming task.
today s code search engines e.g.
krugle ohloh and sourcerer treat source code as plain texts and perform code search based on the text similarity between code snippets and a query utilizing information retrieval models such as the standard boolean model the vector space model vsm or the apache lucene model which is essentially a variant of vsm .
we evaluated the existing code search tools and found that the accuracy of these tools are often unsatisfactory.
the desired code snippets are often not found in the returned results.
as shown in our user study section vi developers consider only .
to .
of the top results returned by ohloh useful.
recently a number of techniques have been proposed to address the weakness of existing tools .
these techniques tackle the problem from the angle of query refinement.
they expand a user query using semantic similar words or using a reformulation strategy .
it was observed that automatically expanding a query with inappropriate synonyms may produce even worse results than not expanding the query .
we believe that one major limitation of existing code search tools is the lack of query understanding.
these tools often adopt conventional text similarity matching techniques such as boolean model or vector space model to retrieve relevant code snippets.
they do not consider query understanding and could therefore lead to inaccurate return results.
for example given a query read file and two code snippets a and b. suppose the code snippet a contains many irrelevant apis such as console.read file.exist and file.appendtext but does not contain the relevant api file.readlines .
code snippet b contains only one occurrence of the relevant api file.readlines .
among the search results a could be returned by the standard boolean model because it contains all the query terms.
a could even be ranked higher than b by the vector space model because of its higher term frequency.
if we could know that the api file.readlines is associated with query read file we could use this information to increase the ranking of snippet b and improve the query results.
this example shows that through api understanding more accurate code search could be achieved.
in this paper we propose codehow a code search approach that considers both api understanding and text similarity matching.
we understand a query by identifying the apis that the query may refer to.
to do so we enrich each api with its online documentation e.g.
the documentation at msdn and identify the apis whose documentations match the query.
having identified the potential apis for a query we need to incorporate the api information into the code retrieval process.
for this we propose to apply the extended boolean model which integrates the benefit of standard boolean model and vector space model.
we expand the user query with the identified apis and apply the extended boolean model to retrieve the code snippets that match the expanded query.
we have implemented the backend of codehow as a microsoft azure cloud service.
we evaluate codehow using realworld queries over a large scale codebase consisting of 26k c projects downloaded from github.
the evaluation results show that when the top results are inspected codehow achieves a precision score of .
i.e.
.
of the first returned results are relevant code snippets .
these results are better than the results achieved by a conventional lucene based code search tool.
we also perform a controlled experiment and a survey of microsoft developers.
the results confirm the usefulness and effectiveness of codehow in programming practices.
the contributions of this paper are as follows we propose a code search technique that could understand the apis a user query refers to and considers both text similarity and potential apis.
we propose to apply extended boolean model to incorporate the impact of both text similarity and potential apis on code search.
we have implemented codehow and deployed it as a scalable cloud service.
our experimental results show that codehow outperforms conventional code search tools.
the rest of this paper is organized as follows.
we present the overall structure of codehow in section ii.
we describe the api understanding component in section iii and the code retrieval component in section iv.
our in house experiment and user study are described in section v and section vi respectively.
we discuss our work and present threats to validity in section vii.
the related work is introduced in section viii.
we conclude the paper in section ix.
ii.
t heoverall structure of codehow figure presents the overall structure of codehow.
codehow constructs a codebase by collecting projects from open source repositories e.g.
codeplex github and an organization s local repositories.
after collecting the projects codehow performs preprocessing tokenization stemming etc on the source code and indexes the code at the method level using elastic search2.
open source local projects code basesource code data preprocessingbuild index source code index query slicing code snippetscode retrieval api understandingrelevant apis raw code snippetsfig.
.
the overall structure of codehow given a user query codehow first feeds it to the api understanding component section iii to figure out the potential apis that are relevant to the query.
the retrieval component section iv then expands the user query with the potential apis and retrieves relevant code snippets from the codebase.
a raw code snippet contains source code of a class method function which could be verbose and mixed with irrelevant code.
in order to make the returned code snippets compact and easy to understand codehow applies static slicing techniques to remove the irrelevant code and presents to users the sliced code snippets.
the backend of codehow is deployed as a microsoft azure cloud service3.
the elastic search engine is running on five azure virtual machines including master node and workers .
the front end of codehow is implemented as a microsoft visual studio extension which can help visual studio users search code during programming.
figure gives a screenshot of codehow user interface.
the distinctive features of codehow are its api understanding and code retrieval components which are described in details in section iii and section iv respectively.
iii.
api u nderstanding codehow tries to understand the potential apis that the users would like to query.
figure shows the outline of the proposed api understanding method.
for an api library such as microsoft .net framework codehow first collects the description of each api from its online documentation.
after obtaining the description of an api codehow computes the similarity between the textual description and the query as well as the similarity between the api name and the query.
it then combines the two similarity values for each api and returns the potentially relevant apis that match the query.
we elaborate the api understanding process in this section.
a. api enrichment and preprocessing we enrich apis by obtaining api descriptions from their online documents including the full qualified api name summary and the remarks full descriptions .
as an example .
text editor .
search box .
search result .
the accept button that accepts acode snippet into the program under development .
the next pre result page .
the original source code filefig.
.
a screenshot of codehow user interface fig.
.
the framework of the api understanding component table i. a nexample of .net api field text full qualified namesystem.io.file.readlines summary reads the lines of a file.
remarks the readlines and readalllines methods differ as follows when you use readlines you can start enumerating the collection of strings before the whole collection is returned... table i shows the description of the .net api file.readlines obtained from the online msdn document4.
we treat each api description as a document and use it for matching a user query.
for a free text query and a description of an api we perform three preprocessing steps text normalization stop word removal and stemming.
the goal is to break the text into terms that can be analyzed by an information retrieval technique.
first we perform text normalization which involves the removal of punctuation marks and tokenization.
second we remove stop words such as on the are and so finally we perform stemming which reduces inflected or derived words into a common root form.
for example the word reading and reads are reduced to the root form read .
we use the standard porter stemmer to perform this stemming step .
b. identifying relevant apis we now describe how we identify relevant apis for a user query.
the process consists of two components text matching component and name matching component.
in the text matching component for each api apiiin a library we compute the text similarity score apit i score between the query and the api s description using the standard vector space model vsm .
each document dis treated as a vector.
each value in the vector corresponds to the weight of a term tind.
the weight is calculated based on term frequency and inverse document frequency.
the similarity is computed as cosine similarity.
the top kapis that have the highest textual similarity are returned as candidate results.
we define the resultant apis obtained from the calculation of the text matching component as api text api text fapit apit apit kg in the name matching component we compute the similarity between the user query and the apis full qualified name fqn .
for each api apiiin a library we calculate the similarity scores apin i score between the query and the api s fqn using vsm and return the top kcandidate apis.
we define the resultant apis obtained from the calculation of the name matching component as api name api name fapin apin apin kg we define the apis appearing in both api text and api name asapi overlap and define the apis appearingonly in api text orapi name asapi notoverlap .
we rank the apis appearing in api overlap higher than the apis in api notoverlap because we assume the apis appearing in both candidate lists are more relevant than the ones only appearing in one candidate list.
we calculate the combined scores of the apis as follows apii score apit i score apin i score ifapii2api overlap minoverlapscore apit n i score maxnotoverlapscore a ifapii 2api overlap where minoverlapscore is the minimum score of all apis inapi overlap and maxnotoverlapscore is the maximum score of all apis in api notoverlap .
ifapiionly appears in api text then apit n i score equals to apit i score .
ifapiionly appears in api name then apit n i score equals to apin i score .
the parameter ais an adjustment factor to make sure that the score of api overlap is larger than that of api notoverlap .
in this study we empirically set ato .
.
equation says that if apiiappears in both api name andapi text candidate lists its score is the sum of the two scores.
otherwise its score is calculated based the similarity score in corresponding candidate list.
we compute the scores in above way to make sure that all apis are ranked according to the following criteria api overlap ranks higher than api notoverlap .
the api with higher similarity score ranks higher than the one with lower similarity score.
finally we rank all apis according to their scores and obtain the top kpotentially relevant apis api relevant fapi api api kg example suppose for the query how to read file line by line the name matching component identifies the following potentially relevant apis api text with similarity scores ffile.readlines .
file.readalltext .
file.readalllines .
g. the text matching component identifies the following apis api name with similarity scores ffileio.textfieldparser.readline .
file.readlines .
file.readalllines .
g. the overlapping apis api overlap are file.readlines and file.readalllines.
we compute their score as .
.
.
and .
.
.
respectively.
the non overlapping apis api notoverlap are readlinesfromfile.file and file.readalltext.
thus we get minoverlapscore value .
and maxnotoverlapscore value .
.
thus the scores for fileio.textfieldparser.readline and file.readalltext are .
and .
respectively.
finally the rank of potentially relevant apis api relevant are as follows file.readlines score .
file.readalllines score .
fileio.textfieldparser.readline score .
file.readalltext score .
.
iv.
c ode retrieval source code can be treated as texts.
conventional information retrieval techniques can be applied to search for code snippets that are relevant to a given user query based on thetext similarity between the query and code snippets.
through api understanding the apis that are potentially relevant to a user query are identified.
the api information can complement the conventional text based code retrieval.
in our work we propose an integrated retrieval method that considers both text similarity and api information.
in this section we describe the construction of queries and the retrieval of code snippets given the queries.
a. query expansion a query qtcontaining nterms is defined as qt t1 t2 t n for a code snippet we consider the following three features relevant apis the apis that the code snippet contains.
method body the method body which contains source code that implements a functionality.
method name the method s full qualified name fqn which gives a brief summarization of the method s functionality.
we define the three code snippet features as follows f f1 f2 f3 where f1stands for api f2stands for method body f3 stands for method name .
a query can thus be expressed in terms of fi tiwhere ti2qtandfi2ft.
it means to search a field fithat contains the term ti.
we construct a boolean query expression for retrieving code snippets that matches to the query in terms of text similarity qtext f2 t1 f3 t1 f2 t2 f3 t2 f2 tn f3 tn this query expression searches for code snippets that contain the terms t1 t2 ... tnin fields f2 method body and f3 method name .
after the api understanding phrase section iii we get kpotentially relevant apis api relevant .
in our work we set kto .
for each api apiiinapi relevant we tokenize its name and get a keyword list ai.
we then construct boolean query expressions for each api as follows qapii f1 apii f2 t1 f3 t1 f2 t2 f3 t2 f2 tk f3 tk where apii2api relevant andtk2 qt ai .
this query expression searches for code snippets that contain the potentially relevant api apiiin fields f1 api as well as other query terms in fields f2 method body and f3 method name .
note that we remove the terms that appear in aifrom the query qt.
this is because the impact of these terms have already been considered in the apiiitem.
each query expression defined above can be used to search for the code snippets.
a code snippet may be thus retrieved bymore than one query expressions.
we consider a code snippet that can be retrieved by multiple query expressions more important.
in our approach we combine the query expressions and obtain an expanded query for retrieving code snippets qexpand qapi1 qapi2 q apik qtext example for the following query how to save an image in png format?
the query terms qt save image png format .
the potentially relevant apis api relevant we obtain from the api understanding component section iii are system drawing image save and system drawing imaging imageformat png .
the associated query expressions are as follows qapi1 f1 system drawing image save f2 png f3 png f2 format f3 format qapi2 f1 system drawing imaging imageformat png f2 save f3 save qtext f2 save f3 save f2 image f3 image f2 png f3 png f2 format f3 format the resulting expanded query is therefore qexpand qapi1 qapi2 qtext .
b. applying extended boolean model to code search extended boolean model to retrieve relevant code snippets based on the queries we adopt the extended boolean model which is an intermediate between the standard boolean model and the vector space model.
in a standard boolean model when two query terms are related by an and connective both terms must be present in order to retrieve a document.
when an or connective is used at least one of the query term must be present.
therefore a standard boolean model is often too strict no results returned or too general too many results returned .
furthermore it does not consider the term weight and the ranking of the results.
a vector space model eliminates many disadvantages of the standard boolean model by weighting both query and document terms and by computing the similarity between query and documents.
vsm has been implemented by many text search engines such as apache lucene.
however vsm has limitation too.
it does not support structural queries consisting of complex and and or relations.
furthermore vsm may lead to inaccurate results in the context of code search due to the differences in term frequencies.
for example given a two term query a b vsm may prefer a code snippet containing a frequently and b less frequently over a code snippet that contains both a and b which both appear less frequently.
however the term a could be irrelevant to the code search.
an extended boolean model combines the characteristics of the vector space model and boolean model and ranks the similarity between queries and documents.
in the extended boolean model a document dis represented as a vector.
given query expressions q q1 q2 qt a generalized disjunctive and a generalized conjunctive query are defined as follows qor q1 pq2 p pqt qand q1 pq2 p pqtin an extended boolean model the similarity between a boolean query expression and dis computed using p norm a general form of normalized euclidean distance sim qor d wp t1 qwp t1 d wp t2 qwp t2 d wp tn qwp tn d wp t1 q wp t2 q wp tn q p sim qand d wp t1 q wt1 d p wp tn q wtn d p wp t1 q wp t2 q wp tn q p where wti qrepresents the weight of query term qi wti d represents the weight of query term qiin document d. the parameter pis the parameter used in p norm.
we set the value ofpempirically with a default value of .
more details on these equations can be obtained from .
retrieval of code snippets based on expanded query in our approach the weight of a term tin an expanded query with respect to a code snippet dis defined as follows wt d api score if term tis an api ft d id ft maxiid fi if term tis not an api in equation if the term is an api such as system.drawing.image.save its weight is the api score obtained from equation .
if the term is not an api such as png its weight is measured by its normalized term frequency.
ft dis the frequency of the term tin code snippet d and id ftis the inverse document frequency of the term t the constant .
is used for balancing the term weight.
in our approach matches in the fields f1 api or f3 method name are considered more important than matches inf2 method body .
therefore we set the weight of term wt qin an expanded query qas follows for the query term related to f2 t its weight is set to .
for the term related to f1 api or f3 t its weight is set to .
.
the similarity between the expanded query qexpand and a document dis defined as follows sim qexpand d kx i 1sim qapii d sim qtext d where sim qapii d is the similarity between an api query expression and the code snippet d.sim qtext d is the similarity between the text query expression and the code snippet d. these similarity values are computed according to equations and defined by the extended boolean model.
v. in house experiment to evaluate the effectiveness of codehow in retrieving relevant code snippets we perform an in house evaluation.
in this section we present our experimental setting evaluation metrics and experimental results.
a. experimental setting the codebase we use in our experiments consists of 26k c projects downloaded from github5 an open source project repository .
the total size of these projects is around ii.
t helist of queries used in in house experiment id query copy paste data from clipboard open url in html browser track mouse hover highlight text range in editor convert utc time to local time converting string to datetime get current date and time get file name without extension how can i decode html characters how can i download html source how do i round a decimal value to decimal places how to change rgb color to hsv how to convert an ipv4 address into a integer how to delete all files and folders in a directory how to execute a sql select how to generate random int number how to get color from hexadecimal color code how to get temporary folder for current user if a folder does not exist create it ping a hostname on the network process.start how to get the output sending email through gmail append string to file calculate md5 checksum how to deserialize xml document how to get mac address how to play a sound how to save image in png format read file line by line remove cookie verify folder exists how to reverse a string quick sort how to split string into words gb containing about .
million c source code files and .
million methods.
the code search workload including indexing and retrieving is performed by the elastic search engine running on microsoft azure.
the client side is an extension of microsoft visual studio ultimate .
we have used real world queries in the in house experiment as shown in table ii.
among them queries come from previous study6 queries are widely viewed queries collected from the stackoverflow website7.
the rest of the queries are collected from the actual microsoft bing search logs8.
b. research questions the objective of the in house experiment is to investigate the overall effectiveness of our approach.
we also want to investigate the benefit of distinctive features of our approach.
we have identified the following research questions rq1 how effective is codehow?
this rq evaluates the effectiveness of codehow in retrieving relevant code snippets based on user queries.
to answer this question we run codehow using the queries specified in table ii.
two authors of this paper manually inspect the top results returned from each query to judge whether they are relevant or not.
only the results receiving relevant feedback from both authors are labeled as relevant.
6most of queries in come from eclipse faq website and they are java programming language specific.
we filter out those java specific queries and obtain language insensitive queries.
our experiments we also compare our approach with a conventional lucene based code search approach.
apache lucene implements a variant of vsm and is behind many existing code search tools such as sourcerer .
sourcerer also incorporates several heuristics to rank the code snippets including code as text text similarity fqn of entities and code popularity.
in our implementation of the lucene based code search tool we consider both text similarity and fqn of the methods.
we do not include code popularity computed using pagerank in our implementation as adding pagerank does not significantly improve the code search accuracy .
no api understanding nor extended boolean model is used in the lucene implementation of code search.
therefore the accuracy of our lucene based code search tool should be similar to what sourcerer could achieve.
rq2 is the proposed api understanding method effective?
one distinctive feature of our approach versus existing code search approaches is the api understanding component that is described in section iii.
it tries to understand the potential apis that are related to the query before performing code retrieval.
answers to this research question help us evaluate whether this feature is useful for code search or not.
to answer this question we compare two versions of codehow one with query understanding and the other without query understanding referred to as codehow noqu .
in the implementation of codehow noqu we omit the api understanding component and feed the user query to the retrieval component described in section iv directly.
that is we do not identify any potentially relevant apis.
we consider only the impact of text similarity on code search.
rq3 is the proposed extended boolean model effective?
another distinctive feature of our approach versus existing code search approaches is the extended boolean model used in code retrieval section iv .
answers to this research question will shed light on whether this feature is useful for code search or not.
to answer this question we implement a variant of codehow referred to as codehow noeb which uses apache lucene to retrieve code snippets based on an expanded query.
we compare codehow using extended boolean model and codehow noeb using lucene .
the api understanding component remains the same for both implementations.
c. evaluation metrics to evaluate the effectiveness of codehow we make use of theprecision kmetric precision k jqjjqjx i 1jrelevant i kj k where relevant i krepresents the relevant code snippets for query iin the top kreturned results qis a set of queries.
precision ktakes an average on all queries whose relevant answers could be found by inspecting the top k k of the returned code snippets.
a better code search tool should allow developers to discover the needed code by examining fewer returned results.
thus the higher the metric values the better the code search performance.
we also make use of mean reciprocal rank mrr which is a statistic for evaluating a process that produces a list oftable iii.
t he comparison between codehow and lucene based code search codehow lucene based precision .
.
precision .
.
precision .
.
precision .
.
mrr .
.
percentage of queries when top results are examined codehow lucene based codehow lucene based codehow lucene based percentage of queries when top results are examined fig.
.
the percentage of queries that codehow performs better worse than lucene based code search possible responses to a query .
the reciprocal rank of a query is the multiplicative inverse of the rank of the first relevant answer.
the mean reciprocal rank is the average of the reciprocal ranks of results of a set of queries qand could be calculated as follows mrr jqjjqjx i rank i the value of mrr is between and .
the higher the mrr value the better the code search performance.
d. experimental results rq1 the overall effectiveness of codehow we evaluate codehow using the queries specified in table ii.
we also compare our approach with a conventional lucene based code search tool.
table iii presents the overall results.
when the top results are inspected codehow achieves a precision score of .
which means that .
of the first returned results are relevant code snippets.
when the top results are inspected codehow achieves a precision score of .
.
these results are considered satisfactory.
note that some queries in table ii are associated with explicit .net apis e.g.
the query how to save image in png format while some queries are not e.g.
the query quick sort .
codehow can effectively handle both of these queries.
table iii shows that the lucene based code search tool achieves a score of .
when the top results are inspected.
codehow achieves .
.
.
and .
improvements in terms of precision precision precision and precision respectively.
in terms of mrr codehow obtains a score of .
which also outperforms the lucenebased code search tool .
by .
.
figure shows the percentage of queries that codehow performs better worse than the lucene based code search tool.
fig.
.
the comparison between codehow and codehow noqu fig.
.
the comparison between codehow and codehow noeb we can see that when the top returned results are examined codehow wins in of the queries and loses in of the queries.
in terms of the top results codehow outperforms the lucene based tool in queries and loses in only of the queries.
we also perform a wilcoxon signed rank test .
the p values are all less than .
when the top and returned results are examined.
the results confirm that the improvement achieved by codehow is statistically significant.
rq2 the effectiveness of api understanding to answer this question we compare two versions of codehow codehow and codehow noqu .
we present the overall comparison results in figure .
codehow noqu achieves precision scores of .
.
.
and .
when the top results are inspected respectively.
codehow achieves .
.
.
and .
improvement in terms of precision precision precision and precision respectively.
in terms of mrr codehow achieves a .
improvement compared with codehow noqu .
we also perform a wilcoxon signed rank test and the result indicates that the improvement achieved by api understanding is statistically significant.
rq3 the effectiveness of the extended boolean model to answer this question we compare the complete implementation of codehow and codehow noeb .
we present the results in figure .
codehow noeb achieves precision scores of .
.
.
and .
when the top returned results are inspected respectively.
codehow outperforms codehow noeb in terms of these metrics.
in terms of mrr codehow achieves a .
improvement compared with codehow noeb .
a wilcoxon signed rank test confirms that the improvement achieved by the extended boolean model is statistically significant.
vi.
u serstudy a. a controlled experiment to evaluate the effectiveness of code search tools in practice we design a user study involving microsoft developers and interns.
the developers are software development engineers sdes whose programming experiences ranging from to years.
the interns are undergraduate and postgraduate students who are majored in computer science or information technology.
we first design three programming tasks and each participant is required to complete these three tasks using two code search tools codehow and ohloh9.
ohloh is chosen as it is one of the most popular commercial code search engines.
the three tasks are as follows task sending emails write a program to read a list of email addresses from a text file and then send an email with an attachment file to all the email addresses.
task converting text files to xml documents write a program to transform structured customer information recorded in a text file to an xml document.
task image format conversion write a program to read an image in jpeg format rotate it and then convert it to png format.
our goal is to evaluate the accuracy of two code search tools in retrieving code snippets based on user queries.
during the experiment participants entered a series of queries that described the given tasks and searched for the code snippets that are needed to complete the tasks using both code search tools.
we recorded the number of queries the participants used as well as the code snippets they examined for completing the tasks.
we also asked them to examine the top returned results for each query and mark which of them are helpful for completing the tasks.
our results show that the participants entered in total queries to each code search tool during the experiment.
table iv shows the percentage of relevant code snippets the participants marked for each code search tool.
codehow returns around more relevant results than ohloh for all the three tasks.
codehow also outperforms ohloh in terms of mrr which measures the rank of the first relevant returned result.
b. a user survey in march we demonstrated codehow in a companywide technology exhibition held in microsoft redmond campus.
we conducted a survey of microsoft developers who iv .
t he user study results percentage of useful results mrr ohloh codehow ohloh codehow task .
.
.
.
task .
.
.
.
task .
.
.
.
tried our tool in the event.
in the survey we asked them if codehow is helpful for their programming tasks by giving a score on a five point likert scale strongly agree is and strongly disagree is .
for the participants the average likert score was .
with standard deviation of .
.
.
participants stated that the search results returned by codehow are mostly or partially correct.
in the survey we asked the participants in which scenarios they think codehow is more effective helping figure out how to use an api or helping figure out how a functionality can be implemented or none of them .
out .
participants marked that codehow is more effective in helping with api usage and the rest of the participants considered that codehow is more effective in helping with a functionality.
all except participants .
expressed that they would like to search and reuse open source code such as those in github when licenses are in compliance .
overall the user study confirms the usefulness of codehow in programming practice.
vii.
d iscussions a. the incorrect return results although codehow is effective it still cannot locate relevant code snippets for all the queries.
one unsuccessful query example is convert utc time to local time .
we find that some returned results are actually about convert local time to utc time.
similar examples include how to change rgb color to hsv.
this is because our approach cannot distinguish semantic meanings of different orders of words.
another query example that leads to incorrect results is how to get color from hexadecimal color code .
some code snippets contain color code strings such as ffdfd991 .
however our approach cannot recognize these strings.
if there are no identifiers or comments describing the code codehow would miss these code snippets.
the same problem also appears when searching for sql linq and regular expressions.
the above examples show the importance of understanding the semantic meanings of query and code.
currently codehow can only understand the relevant apis a query implies.
in the future we plan to perform deeper natural language analysis of query and code aiming for achieving better understanding of query and code and more accurate search results.
b. the usefulness of code search tools through our experiments especially the user study we have obtained the following insights.
although these observations are obtained from our experience on codehow they may be applicable to other code search tools and can be used to guide the future development of these tools.
targeted problems code search can be considered as an opportunistic problem solving where developers need to find missing information for completing software development tasks .
gallardo valencia and sim further proposed three types of opportunistic problems that code search could help resolve remembering developers knew exactly what they are looking for and only wanted to remember syntax details or find facts clarification developers had a high level understanding of what they want to implement but did not know precisely how to do it and learning developers wanted to acquire new concepts .
through our experiments we find that code search tools such as codehow is effective in solving these three problems.
we also find that experienced developers can better use our tool as they could enter queries that are directly related to their problems while inexperienced developers may not realize some relevant code snippets even they contain apis that are useful for their tasks.
one user study participant also pointed out that codehow is more useful for querying a local codebase where a general search engine cannot reach.
code comprehension we observe that developers especially inexperienced developers often have difficulties in comprehending the returned code snippets.
this becomes an obstacle for using code search tools such as codehow.
developers may turn to a general search engine such as bing or google to study the api usage from online materials.
this problem could be partially mitigated by a better code summarization method which can automatically summarize necessary code fragments associated with the query.
designing a better user interface e.g highlighting matching code linking api to online documentation discussion forum etc could also increase the usability of the code search tools in practice.
reuse granularity we observe that the code search tools are more effective when used at a fine granularity level.
large code snippets that contain many lines of code may hinder program comprehension and are more likely to cause the architecture mismatch problem which occurs when the code snippet to be reused requires a different software architecture or a different object oriented framework.
c. threats to validity we have identified the following threats to validity threats to internal validity our empirical study involves human subjects.
the limited number and the programming capabilities of the human subjects may bias the results.
the process of determining the relevance of a code snippet could be also subjective.
in the future we plan to conduct experiments and user studies involving more subjects api methods and programming tasks to further reduce this threat.
threats to external validity we have used queries in our in house experiment.
although these queries are real world queries collected from the stackoverflow website bing search logs and the related work admittedly they do not cover alltypes of queries that a developer may ask.
also although our codebase consists of 26k projects and .
million methods it is just a tiny sample of all available source code.
in the future we plan to reduce the threats to external threats by investigating more queries over a much larger codebase.
viii.
r elated work a. code search currently many code search approaches have been proposed to help users find relevant code.
ohloh krugle and sando are code search engines that can return code snippets containing the keywords or regular expressions specified in a query.
strathcona is a code snippet recommender which locates a set of relevant code snippets by matching the structure of the code under development with the code snippets in codebase.
sourcerer is a lucenebased infrastructure for large scale code search.
bajracharya et al.
performed code search using structural semantic indexing which associates words to source code entities based on similarities of api usage.
s6 is a test driven code search engine that can map high level queries into relevant code fragments through a set of program transformations.
sniff annotates a code snippet with the documentation of java apis the code snippet contains and then performs free text queries over the annotated source code.
unlike the above work our approach performs api understanding before retrieving relevant code.
web search engines such as bing or google could also help developers reuse apis.
however stylos and myers observed many problems and inefficiencies in using general web search engines for code reuse because these search engines are not designed to specifically support programming tasks.
tools such as mica blueprint and assisme use general search engines to search for results and automatically extract relevant code snippets from the returned results.
exoadocs facilitates api reuse by embedding api documents with code examples mined from the web.
our approach supports free text queries.
there are also many approaches that treat an object a function or a partial program as a query and search for matching code snippets .
furthermore our work focuses on the selection of code snippets that answer user s queries.
there are many tools that focus on recommending a group of connected functions.
for example portfolio visualizes relevant functions and their usages and uses pagerank to mine the relationship of functions .
exemplar is a tool that finds relevant applications from a large archive of applications.
similar to our work exemplar also performs search over a large scale codebase based on user queries and utilizes api document information.
however exemplar returns executable projects while our tool returns code snippets.
our work is also related to concept location which is the process of linking textual descriptions to corresponding source code files.
concept location may also be referred to as feature location bug localization or trace recovery in different contexts.
for example antoniol et al.
applied both a probabilistic and a vector space model to recover linksbetween source code units and free text documents such as manual pages or requirements .
marcus and maletic used latent semantic indexing lsi for the similar purpose.
the underlying assumption is that programmers use meaningful words for code units and these words capture applicationspecific knowledge.
therefore text retrieval techniques can be used to link concepts expressed in natural language with code units.
b. query refinement recently several methods have been proposed to improve the effectiveness of code search or concept location via query refinement.
for example gay et al.
improved the effectiveness of concept location by incorporating user feedback using the rocchio algorithm.
haiduc et al.
proposed refoqus a tool that can predict the quality of a query and automatically recommend a query reformulation strategy.
wang et al.
proposed an active code search approach which incorporates user feedback to refine the query.
dietrich et al.
proposed an approach that utilizes feedback captured from a validated set of queries and traceability links to improve the efficacy of future queries.
many methods have also been proposed to expand a user query by retrieving the semantic similar words from websites or software .
hill et al.
proposed to automatically extract natural language phrases from source code identifiers and categorize them into a hierarchy which helps developers recognize alternative words for query reformulation.
it was observed that automatically expanding a query with inappropriate synonyms may produce even worse results than not expanding the query .
different from the above work our work identifies potentially relevant apis that a user query refers to expands the query with the apis and utilizes the extended boolean model to handle the expanded query.
it is also interesting to explore the synergy between our work and the existing query refinement work.
ix.
c onclusion in this paper we propose codehow a code search technique that applies extended boolean model to retrieve code snippets that match users free text queries.
codehow could recognize the potential apis a query refers to and incorporates the api information to improve the accuracy of the search results.
we have implemented the backend of codehow as a azure cloud service and the front end as a visual studio extension.
we have conducted experiments over a codebase containing 26k c projects.
our evaluation results show that codehow is effective and outperforms conventional lucenebased code search.
we have also performed a controlled experiment and a user survey involving microsoft developers and interns.
the results confirm the usefulness of the tool.
in the future we plan to address the issues discussed in section vii.
currently the codehow tool only supports code search for c programs.
we are planning to support more programming languages such as java.
we will also work on methods for synthesizing sample usage code from the code search results.
acknowledgment we thank all microsoft developers and interns who participated in our user study and provided us helpful comments.
wethank yi wei at microsoft research cambridge for providing us the query logs of bing code search and valuable suggestions.
we thank our colleagues at microsoft product teams especially chandrashekhar kaushik sumit saluja anuj jain shabbar husain and jialiang ge scott for the amazing effort on technology transfer.
this work was performed when the first and fourth authors were interns at microsoft research.
we also thank other intern students who helped with the implementation and maintenance of codehow especially wenhao song sheng tian peiyong lin senlan yao and qing ren.