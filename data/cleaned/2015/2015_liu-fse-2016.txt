understanding and detecting wake lock misuses for android applications y epang liuxchang xu shing chi cheungxvalerio terragnix xdept.
of comp.
science and engineering the hong kong univ.
of science and technology hong kong china state key lab for novel software tech.
and dept.
of comp.
sci.
and tech.
nanjing university nanjing china x andrewust scc vterragni cse.ust.hk changxu nju.edu.cn abstract wake locks are widely used in android apps to protect critical computations from being disrupted by device sleeping.
inappropriate use of wake locks often seriously impacts user experience.
however little is known on how wake locks are used in real world android apps and the impact of their misuses.
to bridge the gap we conducted a large scale empirical study on commercial and open source android apps.
by automated program analysis and manual investigation we observed common program points where wake locks are acquired and released types of critical computational tasks that are often protected by wake locks and eight patterns of wake lock misuses that commonly cause functional and non functional issues only three of which had been studied by existing work.
based on our ndings we designed a static analysis technique elite to detect two most common patterns of wake lock misuses.
our experiments on real world subjects showed that elite is e ective and can outperform two state of the art techniques.
ccs concepts software and its engineering software testing and debugging software performance general and reference empirical studies human centered computing smartphones keywords wake lock critical computation lock necessity analysis .
introduction nowadays smartphones are equipped with powerful hardware components such as hd screen and gps sensor to provide rich user experience.
however such components are big consumers of battery power.
to prolong battery life many smartphone platforms like android choose to put energyconsumptive hardware into an idle or sleep mode e.g.
turning screen o after a short period of user inactivity .
albeit preserving energy this aggressive sleeping policy may break the functionality of those apps that need to keep smartphones awake for certain critical computation.
consider a banking app.
when its user transfers money onlineover slow network connections it may take a while for the transaction to complete.
if the user s smartphone falls asleep while waiting for server messages and does not respond in time the transaction will fail causing poor user experience.
to address this problem modern smartphone platforms allow apps to explicitly control when to keep certain hardware awake for continuous computation.
on android platforms wake locks are designed for this purpose.
speci cally to keep certain hardware awake for computation an app needs to acquire a corresponding type of wake lock from the android os see section .
.
when the computation completes the app should release the acquired wake locks properly.
wake locks are widely used in practice.
we found that around .
of apps on google play store use wake locks for reliably providing certain functionalities see section .
despite the popularity correctly programming wake locks is a non trivial task.
in order to avoid undesirable consequences a conscientious developer should carefully think through the following questions before using wake locks .do the bene ts of using wake locks justify its energy cost for reasoning about the necessity of using wake locks ?
.which hardware components need to stay awake for choosing the correct type of wake lock ?
.when should the hardware components be kept awake and when are they allowed to fall asleep for deciding the program points to acquire and release wake locks ?
unfortunately we observe that in practice many developers use wake locks in an undisciplined way.
for example our investigation of popular open source android apps which use wake locks revealed that .
of them have suffered from various functional and non functional issues bugs caused by wake lock misuses.
these issues caused lots of user frustrations.
yet existing work only studied a small fraction of them .
developers still lack guidance on how to appropriately use wake locks and have limited access to useful tools that can help locate their mistakes.
to bridge the gap we performed a large scale empirical study on commercial and open source android apps aiming to investigate three important research questions rq1 acquiring and releasing points at what program points are wake locks often acquired and released?
rq2 critical computation what computational tasks are often protected by wake locks?
rq3 wake lock misuse patterns are there common patterns of wake lock misuses?
what kind of issues can they cause?
by automated program analysis of commercial apps and manual investigation of the bug reports and code revisions corresponding authors this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication fse november seattle wa usa c acm.
... artifact evaluated by fse 396running stoppedlaunch activity paused destroyedonstop .oncreate .onstart .onresume .onrestart .onstart .onresume onpause onresume ondestroy kill kill figure lifecycle of an activity component of open source apps we made several important observations.
for example we found that although in theory wake locks can be used to protect any computation from being disrupted by device sleeping in practice the usage of wake locks is often closely associated with a small number of computational tasks.
we also identi ed real wake lock issues from the open source apps.
by studying their root causes we observed eight common patterns of wake lock misuses only three of which had been studied by existing work.
such ndings can provide programming guidance to android developers and support follow up research on developing techniques for detecting debugging and xing wake lock issues.
based on our empirical ndings we designed a static analysis technique elite to detect two most common patterns of wake lock misuses.
unlike existing techniques elite makes no assumption on where wake locks should be acquired and released but automatically reasons about the necessity of using wake locks at various program points via data ow analysis.
we evaluated elite using six real issues from real world open source subjects and compared it with two existing techniques .
elite e ectively located ve of the six issues without generating any false alarm.
as a comparison the two existing techniques only located one real issue and of their reported warnings are spurious.
to summarize our work makes three major contributions we conducted a large scale empirical study to understand how android developers use wake locks in practice.
to the best of our knowledge this study is the rst of its type.
we collected real wake lock issues in popular opensource android apps .
by categorizing them we observed eight common patterns of wake lock misuses.
we designed and implemented a static analysis technique elite to detect common wake lock misuses.
our evaluation of elite on real world subjects showed that elite is e ective and can outperform existing techniques.
paper organization section briefs android app basics.
sections describe our empirical study methodology and ndings.
sections presents and evaluates our elite technique.
section discusses threats to validity.
section reviews related work and section concludes this paper.
.
background android is a linux based mobile os .
android apps are typically written in java and compiled to dalvik bytecode which are then encapsulated into android app package les i.e.
apk les for distribution and installation .
.
app components and event handling an android app typically comprises four types of components activities contain graphical user interfaces guis for interacting with users services run at background for performing long running operations broadcast receivers respond to system wide broadcast messages and content providers manage shared app data for queries.table wake lock types and their impact wake lock type cpu screen keyboard backlight partial on o o screen dim on dim o screen bright on bright o full on bright bright proximity screen o screen o when proximity sensor activates these types are deprecated in latest android versions but still often used.
powermanager pm powermanager getsystemservice context.
power service wakelock wl pm.newwakelock powermanager.
partial wake lock locktag wl.acquire acquire wake lock performing critical computation when the wake lock is held wl.release release the wake lock when critical computation completes figure example code for using wake locks android apps are event driven.
their logic is normally implemented in a set of event handlers callbacks that will be invoked by the android os when certain events occur.
to provide rich user experience the android platform de nes thousands of handlers to process various events of which we introduce three major types component lifecycle event handlers process an app component s lifecycle events e.g.
creation pausing and termination .
for example figure gives the lifecycle of an activity.
when the activity is created the handlers oncreate onstart and onresume will be invoked consecutively.
gui event handlers process user interaction events on an app s gui which usually consists of standard widgets e.g.
buttons and custom views .
for example a button s onclick handler will be invoked if the button gets clicked by user and its onclicklistener is registered.
system event handlers process system level events monitored by the android os such as incoming calls and sensor updates.
these handlers e.g.
onlocationchanged will be invoked if the corresponding events occur and their listeners e.g.
locationlistener are registered.
.
wake lock mechanism wake locks enable developers to explicitly control the power state of an android device.
to use a wake lock developers need to declare the android.permission.wake lock permission in their app s manifest le create a powermanager.wakelock instance and specify its type see figure .
table lists the ve types of wake locks supported by the android framework.
each type has a di erent wake level and a ects system power consumption di erently.
for instance a full wake lock will keep device cpu running and screen and keyboard backlight on at full brightness.
after creating wake lock instances developers can invoke certain apis to acquire and release wake locks.
once acquired a wake lock will have long lasting e ects until it is released or the speci ed timeout expires.
when acquiring wake locks developers can also set certain ags.
for example setting theon after release ag will cause the device screen to remain on for a while after the wake lock is released.
due to wake locks direct e ect on device hardware state developers should carefully use them to avoid undesirable consequences.
.
empirical study methodology this section presents our datasets and how we analyze them to answer our research questions.
.
dataset collection dataset binaries of android apps.
answering rq1 requires analyzing the code of android apps that use wake locks.
for this purpose we collected the binaries apk les of android apps from google play of appsmean a category size distribution dataset downloads in 1og scale 1k minmax mean .3kmean .8k b app download distribution dataset file size mb mean .9mb c apk le size distribution dataset of revisionsmean d revision number distribution dataset downloads in 1og scale 1m minmax mean .0mmean .1m e app download distribution dataset app size kloc mean .3kloc f app size distribution dataset figure dataset statistics figures b and e have two boxplots because google play store provides a download range decompilation dex2jar program analysis soot bcel statistical analysis retargeting appapk files tojava bytecode locating entry points analyzing api usagecorrelating apicalls with wake lock uses figure methodology for analyzing apk les algorithm .
finding the set of dynamically registered gui and system event handlers in an component class c .worklist handlers findalllifecyclehandlers c .while worklist not empty do .
h dequeue worklist .
regsites findeventlistenerregistrationsites h .
foreach regsite regsites do .
hnew resolveeventhandler regsite .
ifhnew null andhnew handlers then .
addhnewtohandlers andworklist .return handlers store by the following process.
first we collected the basic information app id category and declared permissions of android apps using a web crawler .
by permission analysis we found that .
of these apps declare permissions to use wake locks.
we then proceeded to download these apps using apkleecher .
in total we tried randomly selected apps and successfully obtained of them.
the downloading took months march to january with more than ten pcs and one server.
figure gives the statistics of our downloaded apps.
they cover all app categories and each category on average contains apps figure a .
they are popular on market more than half of them have achieved thousands of downloads and .
of them have been downloaded millions of times figure b .
we also give the size distribution of the downloaded apk les in figure c .
on average each apk le takes .
mb disk space.
dataset bug reports and code repositories.
answering rq3 requires studying the bug reports and code revisions of android apps that use wake locks.
such data are typically only available for open source apps.
to nd subjects for our study we searched four major open source software hosting sites github google code sourceforge and mozilla repositories .
we aimed to nd those apps that have over downloads popular a public issue tracking system traceable and over code revisions well maintained .
after manually checking more than candidates we identi ed apps that use wake locks and satisfy the three requirements.
figure gives the statistics of these apps.
as we can see they are popular on market .
of them have achieved millions of downloads figure e .
they are also well maintained containing hundreds to thousands of code revisions figure d .
besides they are large scale.
on average each of them contains .
thousand lines of code figure f .
.
analysis algorithms program analysis.
to answer rq1 we analyzed the apk les.
figure illustrates the overall process.
we rst decompiled each apk le to java bytecode using dex2jar .
we then analyzed each app s java bytecode using a static analysis tool we built on the soot program analysis framework and apache byte code engineering library bcel .
the analysis consists of two major steps step locating analysis entry points .
our tool rst performs class hierarchy analysis to identify all app component classes e.g.
those extending the activity class in an app.
it then locates the set of callbacks de ned in each app component including lifecycle event handlers gui event handlers and system event handlers.
lifecycle event handlers can be located by searching for the corresponding overwritten methods in an app component class.
finding gui and system event handlers requires a more sophisticated searching algorithm because event handlers can freely register other event handlers.
to nd all dynamically registered handlers 1our tool adopts a xed point iterative searching strategy which is illustrated by algorithm .
the high level idea is to iteratively extend the set of located event handlers which initially only contains component lifecycle event handlers line by adding new ones that are registered in latest located event handlers lines .
to nd the event handlers registered by a certain event handler h our algorithm traverses the call graph of h pinpoints all event listener registration sites line and resolves the type of each listener to locate its associated event handler line .
all located event handlers will serve as the entry points in later analysis.
it is worth mentioning that our tool also locates other entry points such as the callbacks de ned in custom views e.g.
ondraw and asynchronous tasks e.g.
.
their locating algorithms are essentially similar to the algorithms explained here.
step analyzing api calls.
then for each app component our tool traverses the call graph of each entry point in a depth rst manner to check whether wake lock acquiring and releasing api calls can be transitively reached.
if yes we consider the app component would use wake locks.
we understand that the call graphs constructed by soot may not be precise and complete.
however statically constructing precise and complete call graphs for java programs is challenging due to the language features such as dynamic method dispatching and re ection .
addressing this challenge is out of our scope but still to ensure the precision of our results our analysis would not visit obviously imprecise call graph edges caused by conservative resolution of virtual calls see section .
during the analysis our tool 1gui event handlers statically declared in an app s layout conguration les can be located by xml parsing.
398logs the following information for later statistical analysis the set of app components that use wake locks the set of entry points where wake locks are acquired and released and the set of apis invoked by each component.
note that for app components that use wake locks we only log the apis that can be invoked after the wake lock is acquired and before the wake lock is released.
statistical analysis.
with the data logged during program analysis we can analyze them to answer rq1 .
answering rq1 only requires straightforward statistical analysis and we do not further elaborate.
answering rq2 requires investigating the computational tasks that are performed by our collected apps.
to do so we analyzed the apis invoked by the apps in our dataset since api usage typically re ects the computational semantics of an app .
our goal is to identify those critical apis that are commonly invoked by app components that use wake locks locking app components for short but not commonly invoked by app components that do not use wake locks non locking app components .
these apis are very likely invoked by the apps to conduct the critical computations.
before we explain how to identify such apis we rst formally de ne our problem.
suppose that we analyze a set of apps a. each app a a can contain a set of napp components c a c1 c2 c n wheren .
then the whole set of app components to analyze isc a uni22c3a ac a .
with program analysis for each analyzed app component c c a we can know whether it uses wake locks or not and the set of apis it invokes.
let us use api to denote the ordered set of all concerned apis.
then after analyzing the apps in a we can encode the results as a bit matrix mof size divides.alt0c a divides.alt0 divides.alt0api divides.alt0 .
each row of the matrix is a bit vector that encodes the analysis result for a corresponding app component.
the rst bit of the vector indicates whether the app component uses wake locks or not.
the remaining divides.alt0api divides.alt0bits indicate whether corresponding apis are invoked by the app component or not.
with such formulation we can reduce our problem to the classic term weighting problem in the natural language processing area with the following mappings the set of analyzed app components c a can be considered as a corpus .
each app component c c a can be considered as a document .
each api invoked by ccan be considered as a term in the document that crepresents.
the set of locking app components can be considered as the positive category in the corpus and the set of non locking app components can be considered as the negative category .
with the reduction we can adapt term weighting techniques to identify the apis that are commonly invoked by locking app components but not commonly invoked by nonlocking app components.
to do so we applied the widelyused relevance frequency approach .
formally for each api api we count the following the number of locking app components that invoke api locking app components that do not invoke api non locking app components that invoke api.
we de ne the importance score ofapiby equation .
the rf api computes the relevance frequency score of apiand its de nition in equation follows the standard one .
the ltering function freqfilter api de ned by equation is to avoid assigning a high importance score to those apis that do not frequently occur in locking app components and very rarely or never occur in non locking app components when is very small compared to but uni226b the rftable acquiring and releasing program points results for activity components acquiring point pct.
releasing point pct.
onresume .
onpause .
oncreate .
ondestroy .
onpause .
onresume .
onwindowfocuschanged .
onwindowfocuschanged .
ondestory .
oncreate .
other callbacks .
other callbacks .
results for service components acquiring point pct.
releasing point pct.
onhandleintent .
onhandleintent .
onstartcommand .
onstartcommand .
onstart .
ondestroy .
oncreate .
onstart .
onmessage .
oncreate .
other callbacks .
other callbacks .
results for broadcast receiver components acquiring point pct.
releasing point pct.
onreceive .
onreceive .
other callbacks .
other callbacks .
they only have one major lifecycle event handler onreceive .
score will be exceptionally high .
assigning high scores to such uninteresting apis will waste our e ort as we will study the apis with high importance scores to answer rq2.
importance api freqfilter api rf api freqfilter api braceleft.alt41 if slash.left otherwise rf api log parenleft.alt42 max parenright.alt4 search assisted manual analysis.
to answer rq3 we manually studied the bug reports and code revisions of the open source apps aiming to nd wake lock misuse issues.
these apps contain thousands of code revisions and bug reports.
to save manual e ort we wrote a python script to search the apps code repositories and bug tracking systems for those interesting bug reports that contain certain keywords and those interesting code revisions whose commit log or code di contain certain keywords.
the keywords include wake wakelock power powermanager acquire and release .
after search bug reports and code revisions meet our requirement.
we then carefully studied them to answer rq3.
.
empirical observations we ran the analysis tasks on a linux server with cores of intel xeon cpu .10ghz and 192gb ram.
the majority of cpu time was spent on decompiling the apk les hours and the program analysis hours .
in total these apps de ned activities services broadcast receivers content providers and gui system event listeners.
we successfully analyzed .
apks and found app components that use wake locks.
the remaining apks failed to be analyzed because dex2jar orsoot crashed when processing them.
in this section we discuss our major ndings.
.
rq1 acquiring and releasing points first most apps acquire wake locks in broadcast receivers .2overall .
of our analyzed apps acquire wake locks in broadcast receivers.
for activities and ser2due to android fragmentation screen dim bright and full wake locks still account for .
and .
of all used ones.
399table computational tasks that are commonly protected by wake locks computational task related apisapi examples related permissionspermission example networking communications java.net.datagramsocket.connect receive data from internet logging le i o android.os.environment.getexternalstoragedirectory access usb storage le system asynchronous computation java.lang.thread.start android.os.asynctask.execute n a ui graphics rendering android.opengl.glsurfaceview.setrenderer draw over other apps inter component communication android.content.contextwrapper.sendbroadcast send sticky broadcast data management sharing android.database.sqlite.sqlitedatabase.query n a system level operations android.os.process.killprocess close other apps media audio android.media.audiotrack.write record audio security privacy javax.crypto.secretkeyfactory.generatesecret use accounts on the device sensing operations android.location.locationmanager.requestlocationupdates precise location alarm noti cation android.app.notificationmanager.notify control vibration system setting android.provider.settings system.putint modify system settings telephony services android.telephony.telephonymanager.listen directly call phone numbers notes n a means that the corresponding computational tasks do not require special permissions.
vices the percentages are .
and .
respectively.
we did not nd any app that acquires wake locks in content providers.
note that these percentages do not add up to because some apps acquire wake locks in multiple components.
this nding suggests that in practice wake locks are often used by apps when they process broadcast messages which are usually sent upon the occurrence of important events e.g.
servers push noti cations .
we further analyzed each type of app components to investigate in which callbacks developers often acquire and release wake locks.
table summarizes the results.
we can observe that wake locks are commonly acquired and released in major lifecycle event handlers .
for example in activities wake locks are mostly acquired in onresume handlers which are invoked by android os when the activities are ready for user interaction and released in onpause handlers which are invoked after the activities lose user focus.
this reveals developers common practice for avoiding energy waste as many apps do not need to keep device awake for computation when they are switched to background by users.
besides the major lifecycle event handlers we can also observe that developers may acquire and release wake locks at various other program points depending on the needs of their apps .
for instance our analyzed activity components acquire wake locks in di erent callbacks.
this is out of our expectation.
previous techniques for analyzing wake lock misuses often assume that wake locks are acquired when an app component launches and should be released at a set of program exit points.
this nding suggests that such assumptions may not hold in many cases and e ective techniques should not rely on pre de ned rules.
instead they should consider each app case by case by analyzing its semantics.
.
rq2 critical computation rq2 aims to identify the critical computational tasks that are frequently protected by wake locks.
to identify such tasks we performed api usage analysis on the successfully analyzed apps.
for each category of apps our tool computed the importance score of each invoked api and ranked the apis according to their scores a higher score leads to a higher rank .
overall these apps use different apis .
of which are o cial android and java apis.
after the analyses and ranking we manually examined the top apis commonly used by each of the app categories to answer rq2.
now we present our observations.
theoretically wake locks can be used to prevent devices from falling asleep during any kind of computation which could be app speci c. however by analyzing a large numberof apps we observe that developers often only use wake locks to protect several types of computational tasks .
particularly we identi ed apis that are commonly invoked by locking app components but not commonly invoked by other app components.
we then categorized these apis according to their design purposes .
for example apis in android.database and java.sql packages are designed for data management and we would categorize them into the same category.
after categorization we observed that these apis are mainly designed for types of computational tasks and many of them require the android os to grant certain permissions to run .
table summarizes our categorization results.
for each type of computational task the table reports the number of related apis and their required system permissions and provides examples to ease understanding.3we can see from the table that these computational tasks many of which are run asynchronously and could be long running e.g.
location sensing and media playing can bring users observable or perceptible bene ts .
take networking communications for example.
many apps frequently fetch data from remote servers and present them to users.
these tasks typically should not be disrupted by device sleeping when users are using the apps and expecting to see certain updates.
hence wake locks are needed in such scenarios.
another typical example is security privacy.
we found that a large percentage of apps e.g.
.
finance apps frequently encrypt and decrypt certain program data e.g.
those related to user privacy for security concerns.
such tasks should also be protected by wake locks as any disruption can cause serious consequences to users.
this nding can provide wake lock usage guidance to android developers and also facilitate the designing of useful techniques for detecting wake lock misuses see section .
.
rq3 wake lock misuse patterns for rq3 we manually investigated the bug reports and code revisions found by keyword search.
after investigation we found that bug reports and code revisions are related to wake lock misuses.
the other bug reports and code revisions are irrelevant but were accidentally included because they contain our searched keywords.
we then carefully studied these issues and categorized them after understanding their root causes.
by the categorization we observed eight common patterns of wake lock misuses covering issues and a ecting apps which are listed in table .
for each pattern the table lists the 3we failed to categorize of the apis because they are general purpose e.g.
hashmap apis .
400table common patterns of wake lock misuses found in open source android apps misuse pattern issues a ected appsexample issues app name downloads bug report id issue xing revision consequence unnecessary wakeup tomahawk 5k 10k n a 883d210525 energy waste wake lock leakage mytracks 10m 50m n a 17ece1cd75 energy waste premature lock releasing connectbot 1m 5m 540c693d2c crash multiple lock acquisition csipsimple 1m 5m crash inappropriate lock type 3sipdroid 1m 5m instability osmand 1m 5m 4d1c97fe7768 energy waste problematic timeout setting k mail 5m 10m instability inappropriate ags fbreader 10m 50m n a f28986383f energy waste permission errors firefox 100m 500m be42fae64e crash notes for some issues we failed to locate the associated bug reports the issues may not be documented and the corresponding cells are marked as n a .
public class musicactivity extends activity implements ... public void oncreate start playbackservice ... public void ontouch playbackservice.getinstance .playpause ... public void ondestroy stop playbackservice ... .
.
.
.
.
public class playbackservice extends service public void oncreate ... wakelock .acquire partial wake lock mediaplayer .start ... public void playpause if mediaplayer .isplaying mediaplayer .pause if wakelock .isheld wakelock .release else if !wakelock .isheld wakelock .acquire mediaplayer .start public void ondestroy if wakelock .isheld wakelock .release if mediaplayer .isplaying mediaplayer .stop ... .
.
.
.
.
.
.
.
.
.
.
.
.
.
figure unnecessary wakeup in tomahawk number of issues we found the number of a ected apps and provides a typical example.
we noticed that only three of the eight patterns marked with in table have been studied by existing work .
the remaining ve patterns that concern issues are previously unknown.
we now discuss each pattern in detail.
unnecessary wakeup is the most common pattern.
we observe that in many apps wake locks are correctly acquired and released on all program paths but the lock acquiring and releasing time is not appropriate.
they either acquire wake locks too early or release them too late causing the device to stay awake unnecessarily.
to ease understanding we discuss a real issue in tomahawk a music player app.
figure gives the simpli ed code snippet.
when users select an album tomahawk s musicactivity will start the playbackservice to play music at background line .
when the service is launched it acquires a partial wake lock sets up the media player and starts music playing lines .
users can pause or resume music playing by tapping the device screen lines and .
when users exit the app musicactivity andplaybackservice will be destroyed and the wake lock will be released accordingly lines and .
this is functionally correct and the music can be played smoothly in practice.
however since the wake lock is used to keep the device awake for music playing why should it be held when the music player is paused?
holding unnecessary wake locks can lead to serious energy waste.
developers later xed the issue by releasing the wake lock when music playing is paused line and re acquiring it when users resume music playing line .
wake lock leakage is the second common pattern.
as we mentioned earlier wake locks should be properly released after use.
however ensuring wake locks to be released on all program paths for event driven android apps is a non trivial task.
figure gives an example wake lock leakage in mytracks a popular app for recording users tracks when they exercise outdoors.
the app de nes a long running task public class exportallasynctask extends asynctask public exportallasynctask wakelock mytrackutils.acquirewakelock ... protected boolean void... params cursor cursor null try cursor mytrackutils.gettrackscursorfromdb for inti i cusor.getcount i if iscancelled break exportandpublishprogress cursor i finally if cursor !
null cursor.close if wakelock .isheld wakelock .release protected void onpostexecute boolean result if wakelock .isheld wakelock .release .
.
.
.
.
.
.
.
.
.
.
.
.
.
.figure wake lock leakage in mytracks exportallasynctask to export recorded tracks to external storage e.g.
an sd card .
when the task starts it acquires a wake lock line .
then it runs in a worker thread to read data from database write them to the external storage and notify users the exporting progress lines .
when the job is done the android os will invoke the onpostexecute callback which will release the wake lock line .
this process works ne in many cases.
unfortunately developers forgot to handle the case where users cancel the exporting task before it nishes.
in such a case onpostexecute will not be invoked after returns.
instead another callback oncancel will be invoked.
then the wake lock will not be released properly.
the consequence is that the device cannot go asleep causing signi cant energy waste.
later developers realized this issue and moved the lock releasing operation to line .
premature lock releasing is the third common pattern.
it occurs when a wake lock is released before being acquired and can cause app crashes e.g.
connectbot issue .
in our studied apps we often observed such issues.
one major reason is the complex control ows of android apps due to the event driven programming paradigm.
if developers do not fully understand the lifecycle of di erent app components e.g.
temporal relations among callbacks they may mistakenly release a wake lock in a callback that can be executed before another one that acquires the wake lock.
multiple lock acquisitions.
wake locks by default are reference counted.
each acquiring operation on a wake lock increments its internal counter and each releasing operation decrements the counter.
the android os only releases a wake lock when its associated counter reaches zero .
due to this policy developers should avoid multiple lock acquisitions .
otherwise to release a wake lock requires an equivalent number of lock releasing operations.
however due to complex control ows developers often make mistakes that cause a wake lock to be acquired multiple times.
for example in csipsimple a popular internet call app developers put the wake lock acquiring operation in a frequently invoked callback.
the consequence is that csipsimple crashes after acquiring the wake lock too many times issue which exceeds the limit allowed by the os.
401algorithm .
detecting wake lock misuses in an app .foreach component c appdo .
ifusewakelock c then .
componentsusingwakelocks add c .
summarizetoplevelmethods c .
infertemporalconstraintsbetweentoplevelmethods c .warnings uni2205 .foreach c componentsusingwakelocks do .
seqs generateallvalidtoplevelmethodcallseqs c length .
foreach seq seqs do .
foreach cp checkpoints seq do .
warnings add analyzelocknecessity seq cp .return aggregatebyrootcause warnings inappropriate lock type.
before using wake locks developers should gure out which hardware needs to stay awake for the critical computation and choose an appropriate type of wake lock.
inappropriate lock types often cause trouble in practice.
for example in sipdroid another popular internet call app developers used a partial wake lock for keeping the device cpu awake during internet calls.
however on many devices keeping cpu awake does not prevent wifi nic from entering power save polling mode which will signi cantly reduce the network bandwidth.
the consequence is that sipdroid s calling quality becomes unstable when device screen turns o issue .
to x the issue developers later used a screen dim wake lock to keep both device screen and cpu on when users are making phone calls.
this is an example of mistakenly using a wake lock with a low wake level.
we also observed cases where developers use wake locks whose wake levels are higher than necessary.
for instance when users use osmand a famous maps navigation app to record their trips during outdoor activities e.g.
cycling the app will acquire a screen dim wake lock for location sensing and recording.
however keeping screen on in such scenarios is unnecessary and will waste a signi cant amount of battery energy osmand issue .
developers later realized the issue after receiving many user complaints and replaced the screen dim wake lock with a partial wake lock.
problematic timeout setting.
when acquiring wake locks developers can set a timeout.
such wake locks will be automatically released after the given timeout.
setting an appropriate timeout enough for the critical computation to complete but not too long seems to be an easy job.
however in practice developers can make bad estimation.
for example in k mail an email client with millions of users developers used a wake lock that would get timeout after seconds to protect the email checking process.
they thought that it was long enough for the checking to complete.
unfortunately due to various reasons e.g.
slow network conditions many users complained that they often fail to receive email noti cations and this issue is annoyingly intermittent.
the developers later found the root cause.
they reset the timeout to minutes and commented this should guarantee that the syncing never stalls just because a single attempt exceeds the wake lock timeout.
inappropriate ags.
we mentioned in section that developers can set certain pre de ned ags when acquiring wake locks.
when they do so they need to be careful as setting inappropriate ags can cause unexpected consequences.
for example the developers of fbreader an ebook reading app found that setting the on after release ag when using a screen bright wake lock could cause seriousenergy waste on some users devices.
this is because with the ag set some android system variants i.e.
those customized by device manufacturers can keep the device screen on at full brightness for quite a long while after the wake lock is released.
they later removed the ag to x the issue.
permission errors.
using wake locks requires an app to declare the android.permission.wake lock permission.
forgetting to do so will lead to security violations.
this is a well documented policy but some developers still make mistakes.
for example one version of firefox did not declare the permission properly and users found that the app would crash because of this issue firefox issue .
the above issues recur throughout our studied apps.
we also observed two other issues that only occurred once.
one is the instability issue caused by concurrent wake lock acquiring and releasing in k mail.
developers xed the issue by putting wake lock operations in synchronized blocks revision .
the other is the duplicate wake lock issue in csipsimple.
developers mistakenly made two app components acquire two di erent wake locks of the same type but one is already su cient.
they later xed the issue by removing one wake lock revision .
.
detecting wake lock misuses based on our empirical ndings we propose a static analysis technique elite wake lock necessit y analyze r to detect the two most common patterns of wake lock misuses unnecessary wakeup and wake lock leakage.
.
algorithm overview the input of elite is an android app s apk le.
the output is a report of detected wake lock misuse issues.
to ease issue diagnosis elite also provides the method call sequences leading to each detected issue and the program points where wake locks should be released.
algorithm gives an overview of elite .
to detect wake lock misuses in an android app elite explores di erent executions of each app component that uses wake locks to locate the problematic program points where wake locks are not needed but acquired by performing an interprocedural analysis lines .
in android apps an app component s execution can be represented as a sequence of calls to the component s top level methods or entry points .
these methods include lifecycle gui system event handlers e.g.
oncreate in figure callbacks of custom views and asynchronous tasks e.g.
in figure and non callback methods that are exposed for other components to invoke e.g.
playpause in figure .
at runtime top level methods of an app component are invoked by the android os or other components to handle various events.
for event handling top level methods may invoke other methods.
therefore to emulate the executions of an app component c elite identi es the top level methods of c and generates valid sequences of calls to such methods line and section .
.
then for issue detection elite analyzes each sequence and locates program points where cunnecessarily holds wake locks lines and section .
.
to improve analysis e ciency before generating call sequences to interesting top level methods elite rst summarizes the methods potential runtime behavior by an interprocedural analysis line and section .
so that the summaries can be reused when analyzing method call sequences.
to make elite s analysis e ective we need to address two technical challenges.
first the execution of top level 402oncreate playpause ondestroy acq partial lock start media player start media player stop media player rel partial lock stop media player figure an example method call sequence methods follow implicit orders prescribed by the android platform.
it is a non trivial task to generate valid method call sequences.
second there are no well de ned criteria to judge whether it is appropriate for an app to use wake locks at certain program points.
to address the rst challenge elite infers temporal constraints from an app s code to model the execution orders of top level methods section .
.
to address the second challenge elite leverages our empirical ndings and considers that if an app s computation can bring users perceptible or observable bene ts the energy cost of using wake locks is justi ed section .
.
.
summarizing top level methods the rst step of elite s analysis is to identify top level methods in each app component cthat uses wake locks.
to identify top level methods that are callbacks which include lifecycle gui system event handlers and callbacks de ned in custom views and asynchronous tasks elite relies on the xed point iterative searching algorithm described in section .
.
to identify other non callback top level methods thatcexposes for other components to invoke elite iterates over non callback methods de ned in cand looks for those that can be directly invoked by other components without going through c s other methods.
for each identi ed top level method m elite then summarizes the following potential runtime behavior data ow facts of m acq the set of wake lock instances that may have been acquired after executing m rel the set of wake lock instances that may have been released after executing m start the set of asynchronous computational tasks that may have been started after executing m stop the set of asynchronous computational tasks that may have been stopped after executing m. elite tracks the asynchronous computational tasks started and stopped by each analyzed method because these tasks are likely long running and could be the reason that an app uses wake locks section .
.
to obtain these summaries elite performs an interprocedural reaching de nition styled forward data ow analysis on the control ow graphs cfgs of all identi ed top level methods to infer the data ow facts.
the data ow equations are de ned as follows srepresents a statement in a cfg in s uni22c3.disp p pred s out p out s gen s in s kill s in s and out s represent the set of data ow facts before and after executing s respectively.
gen s andkill s denote the data ow facts generated or killed by s. the de nitions ofgen s andkill s depend on analysis tasks.
for instance when inferring start of a method m if a statement sinvokes a location listener registration api gen s will have one element representing that smay start a long term location sensing task and kill s will be an empty set.
at the control ow con uence and method return points we use the union operator to combine data ow facts meaning that in s contains all data ow facts from the predecessors of sin the cfg equation .
out s is a union of the data ow facts generated by sand the di erence between the data ow factssinherits from its predecessors and those killed by s equation .
with these equations de ned elite then leverages soot s data ow analysis engine to summarize all top level methods in app components that use wake locks.
.
generating valid method call sequences next elite proceeds to generate valid sequences of top level method calls for each app component that uses wake locks.
elite considers a sequence valid if the invocation orders of the top level methods do not violate these temporal constraints prescribed by the android platform policy for lifecycle event handlers.
each app component typically passes through several phases during its lifecycle.
in each phase the corresponding lifecycle event handler s de ned in the component class would be invoked by the android os at a speci c time figure .
elite leverages such temporal constraints to decide the correct invocation order of lifecycle event handlers.
policy for gui system event handlers.
an app component may register multiple gui system event listeners.
the event handler de ned in each event listener lcan only be invoked when the top level method that registers l has been invoked and the top level method that unregisterslhas not been invoked since then.
elite also considers such constraints during method call sequence generation.
policy for non callback top level methods.
noncallback top level methods de ned in an app component class are usually exposed for other components to invoke.
for example in figure the playpause method of playbackservice can be invoked by the ontouch callback of musicactivity .
such methods can only be invoked after their declaring app components are set up e.g.
after the onstartcommand handler of playbackservice is invoked .
besides the three major types in our implementation elite also considers other temporal constraints to deal with the callbacks de ned in asynchronous tasks and custom views .
elite infers all constraints via static analysis.
it then leverages them to generate valid method call sequences each of which consists of three parts method calls to start components method calls to interact with the components and method calls to destroy the components.
to ease understanding figure provides a method call sequence elite generates for playbackservice of tomahawk figure .
the sequence contains three top level method calls the call to oncreate starts the service the call to playpause handles the user s touch on the musicactivity s ui and the call to ondestroy destroys the service.
it is worth mentioning that the number of all possible method call sequences can be unbounded since users can interact with an app in in nite ways.
for practical consideration elite limits the number of top level method calls in each sequence to generate a nite set of sequences.
other than this limit elite s sequence generation is exhaustive it will try all possible orders of top level method calls.
.
wake lock necessity analysis with the generated method call sequences elite then identi es checkpoints in each sequence and performs wake lock necessity analysis to detect wake lock misuses.
4when starting a service android system will also call the onstartcommand handler after calling oncreate .
we simpli ed the scenario to ease the presentation.
403identifying checkpoints.
similar to other event driven programs an android app will enter a quiescent state after it nishes handling every event .
an app may stay quiescent for a long time when there are no new events to handle.
therefore it is important to analyze such state transitioning time points which we refer to as checkpoints to see whether an app unnecessarily holds any wake lock when it enters a quiescent state.
as we discussed earlier at runtime an app s top level methods are invoked to handle various events.
an app will enter a quiescent state after invoking certain top level methods to handle an event.5then given a sequence of top level method calls uni27e8m1 m2 m n uni27e9 to identify checkpoints elite rst segments it into disjoint non empty segments uni27e8m1 m i uni27e9 uni27e8mi m j uni27e9.
.
.
uni27e8mk m n uni27e9 each of which contains only the top level method calls that handle one particular event.
since android s event handling mechanism is well de ned in the api guides the segmentation result is unique.
after sequence segmentation elite then performs analysis after the last method call mcpof each segment andcpis the identi er of the checkpoint.
for example for the sequence in figure elite will perform analysis after each method call since each of them handles one event.
reasoning about the necessity of using wake locks.
at each checkpoint cpof a method call sequence elite analyzes the data ow summaries of the methods m1 m cp and performs the following three checks to detect potential wake lock misuses and reports the earliest program points where wake locks should be released if the app might have acquired a wake lock wlbefore executing the method mcp is it possible that after executing mcp wlwould be released?
if yes elite exits with no warnings.
otherwise elite proceeds to the second check.
is it possible that after executing mcp the app might have stopped all previously started asynchronous long term computational tasks?
if yes elite reports a warning since the app would not be any computation after mcp but the wake lock wlmight have been acquired.
otherwise elite proceeds to the third check.
can the asynchronous computational tasks which might be left running bring users observable or perceptible bene ts?
if yes elite exits with no warnings.
otherwise elite reports a warning since the bene t brought by the computation might not justify the energy cost of keeping devices awake.
to analyze the bene t of a computational task elite performs api call analysis by leveraging our empirical ndings in section .
.
speci cally if any of our observed critical computation apis is invoked elite decides that the computational task can bring users bene ts.
let us illustrate the analysis process using the example in figure .
suppose that elite is performing analysis after the call to playpause .
the rst check will fail since there is no wake lock releasing operation in oncreate andplaypause .
then for the second check elite will nd that the music playing task started by oncreate might have been stopped by playpause and therefore the app might unnecessarily hold the wake lock afterwards.
it will report a warning accordingly.
finally after analyzing all checkpoints elite may generate many warnings.
in order not to overwhelm users elite will aggregate the warnings by the concerned long term computational tasks and the program points where the wake locks are supposed to be released.
to 5some events requires multiple top level method calls to handle e.g.
launching an activity component see figure .ease issue diagnosis and xing when unnecessary wakeup issues are detected elite will also report the locations of the late wake lock releasing operations so that users can consider moving them to more appropriate program points.
.
discussions elite s analysis may not be entirely sound and precise due to common limitations of static analysis.
first the lack of full path sensitivity may cause elite to report spurious warnings false positives or fps or miss certain wake lock misuses false negatives or fns .
second although we carefully handled the execution orders of various top level methods it is hard to guarantee that elite can generate and analyze all feasible method call sequences.
third elite analyzes app components separately assuming each one would take care of its own acquired wake locks.
this assumption is reasonable because each app component is a di erent point through which the android os can enter an app and hence it should carefully manage its acquired system resources.
however there is no language level mechanism to prevent an app component from delegating resource management tasks to other components.
if that happens elite may generate fps and fns.
lastly elite reasons about whether app computation can bring users perceptible observable bene ts by checking the invocation of prespeci ed platform apis.
this strategy has shown to be effective but may not work perfectly when the api set is incomplete or app computation involves native code or libraries whose implementation are unavailable for analysis.
although these factors may threaten the e ectiveness ofelite in our evaluation we only observed that the lack of full path sensitivity caused elite to miss one real issue.
.
evaluation in this section we evaluate the e ectiveness of elite .
we rst introduce some implementation details.
we implemented elite on top of soot and apache bcel .
in soot swjpp phase elite sets all non abstract methods as analysis entry points to construct whole program call graph.
in the wjtp phase elite identi es those app components that use wake locks and performs call graph analysis to associate them with their dynamically registered gui system event handlers custom view and asynchronous task callbacks.
in this process elite relies on bcel for type resolution e.g.
event listener type and handling generics e.g.
inasynctask s de nition .
then in the jtpphase elite performs data ow analysis to summarize top level methods in the app components that use wake locks.
finally after thejtpphase elite generates method call sequences and performs wake lock necessity analysis for issue detection.
.
subjects and experimental setup to study whether elite can e ectively detect wake lock misuses in real world android apps we conducted experiments using six real issues randomly selected from our identi ed wake lock misuses.
table lists the basic information of the issues and their containing apps which cover ve different categories diversity and have received thousands to millions of downloads popularity .
for our experiments we selected versions of these apps.
for each version table lists its revision id and lines of java code.
six of the versions contain unnecessary wakeup or wake lock leakage issues and the remaining six are the corresponding bug xing versions of these issues.
with this setup we can evaluate the 404table wake lock misuse detection results of the three techniques under comparison indexsubject information issue elite relda veri er app name category downloads revision sloc info.
warnings tps warnings tps warnings tps 1tomahawk music audio 5k 10kb4f339bb24 type1 883d210525 clean 3open gpstracker travel local 100k 500ka9663a7b8d type1 6e4e75934b clean 5mytracks health fitness 10m 50mf2b4b968df type1 7749d47238 clean 7fbreader books