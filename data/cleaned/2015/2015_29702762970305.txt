inferring annotations for device drivers from verification histories zvonimir pavlinovic new y ork university usa zvonimir cs.nyu.eduakash lal microsoft research india akashl microsoft.comrahul sharma stanford university usa sharmar cs.stanford.edu abstract this paper studies and optimizes automated program veri cation.
detailed reasoning about software behavior is often facilitated by program invariants that hold across all program executions.
finding program invariants is in fact an essential step in automated program veri cation.
automatic discovery of precise invariants however can be very di cult in practice.
the problem can be simpli ed if one has access to a candidate set of assertions or annotations and the search for invariants is limited over the space de ned by these annotations.
then the main challenge is to automatically generate quality program annotations.
we present an approach that infers program annotations automatically by leveraging the history of verifying related programs.
our algorithm extracts high quality annotations from previous veri cation attempts and then applies them for verifying new programs.
we present a case study where we applied our algorithm to microsoft s static driver veri er sdv .
sdv is an industrial strength tool for veri cation of windows device drivers that uses manually tuned heuristics for obtaining a set of annotations.
our technique inferred program annotations comparable in performance to the existing annotations used in sdv that were devised manually by human experts over years.
additionally the inferred annotations together with the existing ones improved the performance of sdv overall proving correct of drivers more while running faster in our experiments.
ccs concepts theory of computation !invariants software and its engineering !software veri cation formal software veri cation author did part of the work as a research intern at microsoft research bangalore indiakeywords program veri cation invariant generation learning invariants veri cation history big code .
introduction the performance of program veri ers depends on the discovery of precise assertions that hold during every program run called program invariants.
examples of such assertions are procedure pre post conditions and loop invariants.
the task of nding invariants is often broken down into nding a set of candidate facts or annotations and then using these facts to establish invariants.
for example predicateabstraction based tools such as slam or blast rely on discovery of useful predicates to construct program invariants.
tools such as ufo and duality rely on interpolation to generate candidates for procedure summaries.
each of these techniques however infer annotations by analyzing only the program given to be veri ed.
we propose a novel and complementary approach of inferring program annotations automatically by exploiting information available from prior veri cation runs.
we build on the insight that annotations useful for verifying a particular program are often already observed earlier during the veri cation of related programs.
for instance programs that use the same api probably require similar annotations for verifying contracts of that api.
we keep track of the verication history by accumulating a set of programs and the annotations required to construct their respective proofs.
we leverage this history to generate a small set of annotations that are useful for subsequent unseen programs.
there are two key challenges in making this approach work.
first annotations are logical formulas over program variables thus tied to program speci c variable names.
we abstract away from program speci c names by working with abstract annotations which are arbitrary formulas with holes .
abstract annotations are concretized to a program by lling the holes with the program s variables.
the set of all abstract annotations in the veri cation history has the nice property that it is su cient to establish the correctness of all programs observed in the history.
however this set is likely to be very large making the veri er spend a signi cant amount of time just discarding invalid annotations.
our second challenge is to keep the set of inferred annotations small.
we design a minimization algorithm that computes a set of abstract annotations such that it is enough to establish correctness proofs of all programs in the history and no smaller subset or syntactically simpler permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
set in a sense that we formalize later is enough to establish all correctness proofs.
our primary motivation behind these ideas is to improve the performance of microsoft s static driver veri er sdv .
sdv is an industrial strength tool for formal veri cation of windows device drivers.
sdv checks that drivers conform to certain properties called rules that establish correct usage of the windows kernel apis.
sdv currently uses manually tuned heuristics for obtaining a set of annotations that are passed to a program veri er.
using a repository of small in house drivers our techniques can not only replace the need for this manual e ort they even out perform these heuristics and improve the performance of sdv overall.
we summarize our contributions as follows given a veri cation history we formally de ne the notion of a minimal set of annotations and present an algorithm for computing it.
we apply the algorithm to sdv and experimentally show that inferring annotations from past veri cation e orts can potentially generate better annotations than ones provided by human experts.
the set of abstract annotations inferred by our algorithm improved the veri cation times by on average and reduced inconclusive results by in our experiments.
.
overview this section motivates the need for automatic inference of program annotations and provides an overview of our techniques.
.
static driver verifier the static driver veri er sdv has been an important success story for veri cation technology .
over a decade it has helped windows developers to statically nd bugs in windows device drivers.
the main veri cation engine of sdv was slam with several upgrades along the way .
sdv switched to using an smt based veri er called corral for superior performance.
an overview of sdv is shown in figure .
sdv accepts the source code of a windows device driver as input and links it against a model of the kernel called os model in the gure .
it then checks multiple rules that the driver must satisfy.
these rules and kernel contracts encoded in the os model are made known to driver developers via microsoft developer network msdn .1each driver and rule results in possibly multiple programs with assertions called veri cation instances that are fed to the veri er corral .
corral s job is to nd an execution that leads to an assertion violation in the veri cation instance.
such executions are reported as defects to the user.
corral operates by lazily inlining procedures and utilizing an smt solver to search through the partially inlined program.
to help corral sdv uses annotation based invariant generation.
sdv generates annotations based on the rule being checked and runs houdini on the veri cation instance to compute invariants constructed from these annotations.
these invariants are injected back to the veri cation .aspxinstance as assumptions which help corral prune search without compromising soundness.
corral has four possible outcomes as mentioned in figure .
corral uses over approximations re ned by invariants inferred by houdini hence it can prove correctness and return proof .
corral can also nd a bug and report the failing execution.
corral stops search when it hits an internal coverage bound and returns bound .
although this is an inconclusive verdict it is still considered more useful than a timeout outcome because the latter does not guarantee any coverage.
sdv has experienced several upgrades including major improvements to corral .
showing further improvements would truly build on the state of the art in the area.
this paper focuses on improving annotation generation in sdv.
the current process of generating annotations is guided by a set of heuristics that have been manually tuned and maintained over several years.
these heuristics can be found in our technical report .
what makes this approach feasible is that the heuristics only look at the rule being checked not the driver for generating the annotations.
while driver code is not known ahead of time the set of rules is xed and known to sdv developers before sdv s release.
the goal of this paper is two fold.
first we want to automatically generate annotations instead of requiring manual e ort.
second we wish to show that automated inference can out perform the expert driven heuristics.
we achieve these goals by learning useful information from past veri cation e orts.
.
examples of sdv rules we give two examples of rules properties that sdv checks.
the rules are described in an abstract manner without using the actual tool notation for clarity.
acquire release rules.
the os kernel provides multiple resources to help the driver accomplish its task.
the kernel expects that the driver speci cally the dispatch routines of the drivers must release all acquired resources when it exits.
sdv checks this property by instrumenting the acquire release api as shown in figure a .
the actual code of the api is immaterial while checking this property thus is not shown.
the rule introduces the model variable depth to keep track of the number of resources held the variable is asserted to be zero when the driver s dispatch routine exits.
this rule abstractly captures the spinlockrelease rule of sdv.
figure b shows a family of fake drivers that exercise this api correctly.
entry points of the drivers are the procedures pnandq.pnis parameterized by the value of n. it calls the routine dispatchpnwhere we use the notation nto denotenoccurrences of the statement st. these programs model typical usage of the acquire release api that we have seen in drivers while abstracting away irrelevant details .
sdv links the driver code figure b together with the instrumented api code figure a to produce a veri cation instance that is fed to corral.
the construction of a proof of correctness and the role of annotations is discussed in the next section.
irql based rules.
aninterrupt request level irql captures the priority associated with a task.
tasks with higher irql cannot be interrupted by tasks with a lower .aspx 451figure an overview of sdv s implementation.
irql.
drivers often raise the irql level to perform critical activity uninterrupted but are required not to spend too much time at the high irql for the sake of responsiveness of the system.
sdv checks that drivers do not call certain time consuming kernel apis when at a high irql3.
figure shows irql modeling and usage.
the os model variable sdv irql current records the current irql value of the processor.
kernel apis keraiseirql4 and kelowerirql can be used to change the irql value.
the rule simply asserts that the procedure do work at low irql is only called when irql is lowest possible value .
the program with entry point main is a fake driver that correctly exercises the kernel api.
.
annotations and proofs we now set up some notation to describe program proofs.
iffis a procedure and is a formula we use fto denote that is a valid postcondition of f. iffhas a loop starting at location lthen the notation f ldenotes that is a valid loop invariant for l. we model assertion failures as setting of a special okbit to false.
for a variable x let old x refer to the value of xat the beginning of the procedure or loop depending on the context in which it is used.
for instance f means that the execution of feither increments the value ofxor it fails an assertion.
in other words if fdoesn t fail then it increments x. f lmeans that the loop at location lof procedure fpreserves the value of xacross an arbitrary number of loop iterations.
aproof of correctness of a program is simply a sequence of mutually inductive postconditions of procedures or loops in the program that imply ok true at the end of the program.
for simplicity and without loss of generality we do not talk about procedure preconditions in this paper.
annotations are simply formulas that serve as candidates for postconditions.
figure c shows possible proofs for the previously introduced programs of figure .
the gure contains two possible proofs for pn marked as a and b and a single proof forq.
note that all postconditions in proof aofpndo not depend on the value of n whereas proof bis speci c to the value ofn.
generation of invariants from a given set of annotations which we call annotation based invariant generation is much 3see for example library windows hardware v vs. .aspx hardware v vs. .aspxsimpler than full blown veri cation often even decidable.
one may use for example predicate abstraction to construct invariants that are boolean combinations of the given annotations.
in our work we use the houdini algorithm to nd conjunctive invariants ones that are conjunctions of some subset of the given annotations.
this problem has a lower complexity than predicate abstraction and is very fast in practice for small to medium number of annotations.
for example given annotations fdepth g not knowing if they are valid postconditions or loop invariants it is very e cient to construct a proof for pn of type a using houdini.
.
minimal repositories our technique requires a repository of programs and their proof of correctness.
the proofs may be constructed manually or by using proof generating veri ers.
we do not expect to control the proof generation process.
suppose we have programs qandpnfor eachn2n for some large set n. further suppose we have proof of type b figure c for pnfor all values of n exceptn0 and pn0has a proof of type a. thesenprograms together with their corresponding proofs constitute a repository.
we extract all annotations present in the proofs which produces a large set a fdepth g f njn2n fn0gg.
retaining a large set of annotations is ine cient even for annotation based invariant generation techniques.
moreover some of the annotations are very speci c to a program e.g.
nis only useful for proving correctness of pn.
our technique minimizes awhile retaining its invariantgeneration power.
the power is captured using a cost metric based on the ability of a set of annotations to prove a set of programs correct given a xed veri er.
the cost is if some program cannot be proved otherwise it re ects the running time of the veri er.
our algorithm simpli es aby dropping annotations or making them syntactically simpler as long as the cost does not increase or only increases by atolerable amount the exact formulation can be found in section .
for illustration assume that the cost becomes 1as soon as the annotations cannot establish some loop invariant or postcondition of a recursive procedure intuitively because these are the critical parts of a proof and is unit cost otherwise.
starting with a our algorithm drops depth and from this set because these are not important for the inductive argument i.e.
cost remains unit after dropping them.
next if it tries to drop the cost becomes 1be452var depth int procedure init depth procedure acquire depth depth procedure release depth depth procedure d exit assert depth procedure pn call init call dispatchp n procedure dispatchp n n l1 while call acquire call release n call d exit procedure q call init call dispatchq procedure dispatchq l2 while call acquire call release call dispatchq call d exit a b de nitions i depth old depth i n old depth n depth n old depth ok proof a of pn init acquire release d exit dispatchpn l1 dispatchpn proof b of pn init acquire release d exit dispatchpn l1 dispatchpn proof ofq init acquire release d exit dispatchq l2 dispatchq c figure a an acquire release api b a family of programs exercising the api and c possible proofs of correctness of the programs.
cause the loop invariant of pn0is lost.
thus 0is retained ina.
next each of the nannotations get dropped.
even though these annotations were loop invariants in the original proofs they can be replaced by the more general annotation 0that is present in a. in this way learning from a large set of proofs increases the chances of nding annotations useful for many programs.
finally while cannot be dropped our algorithm tries to simplify its boolean structure.
the algorithm simpli es it to because having annotations f gis enough for annotation based invariant generation to establish as an invariant.
at this point the algorithm reaches a xpoint where no annotation can be dropped or simpli ed and it returns the set f g. the algorithm is non deterministic it could have chosen to drop in its rst iteration because was still present in a. in general our algorithm only guarantees a locally optimal solution with respect to a given cost metric.
globally optimal solutions are also possible to compute but at a higher cost which was not justi ed in our experiments.although the programs considered here are simple they are derived from real world code.
they re ect common usage patterns of acquire release kind of apis that we have observed in drivers.
the program qillustrates an uncommon but not rare scenario where recursion happens via kernel callbacks driver code itself typically does not exhibit recursion .
.
abstract annotations annotations are formulas over program variables.
in general di erent programs have di erent variables.
to abstract away from program speci c variables we introduce the concept of an abstract annotation that is a formula over only generic and shared variables.
we call the set of global variables common to all programs in the repository as the shared vocabulary .
we assume these variables serve a similar role in all programs e.g.
the depth variable of figure will be present in all programs that exercise the acquire release api and sdv irql current will be present in all programs that exercise the irql api of figure .
shared variables i.e.
variables in the shared driver procedure main var loc int call init call loc keraiseirql while call kelowerirql loc call do work at low irql call loc keraiseirql call kelowerirql loc rule procedure do work at low irql assert sdv irql current os model and rule var sdv irql current int procedure init sdv irql current procedure keraiseirql new irql int returns old irql int old irql sdv irql current sdv irql current new irql procedure kelowerirql new irql int sdv irql current new irql figure irql modeling and example of usage.
vocabulary can be freely used in annotations because they are present in all programs that exercise the same rule.
generic variables are not speci c to any program.
there are fours kinds of generic variables flocal global formalin formaloutg the kind of a generic variable is determined statically by inspecting the declaration of a program variable.
an annotation is converted to an abstract annotation by replacing variables by generic variables of the corresponding type.
for example consider the postcondition fon a procedure fwith formal input argument xand formal output argument y. this will get converted to the abstract annotation fin fout where fin and fout are generic variables of kind formalin andformalout respectively.
abstract annotations are concretized when applied to a program.
let pbe a program and proc a procedure in p. we de ne a concretization function p proc as follows.
for an abstract annotation a p proc a returns all annotations such that a generic variable of type global is substituted with some global variable of p a generic variable of type formalin is substituted with some formal in parameter of proc and similarly for formalout andlocal .
p proc must return all such annotations.
p proc leaves shared variables unchanged.
consider the driver in figure .
proving correctness of main requires a loop invariant that the value ofsdv irql current is unchanged across loop iterations which in turn requires that the value of locis maintained across iterations.
that is it requires the loop invariant loc old loc .
our technique once it observes a proof with this loop invariant will generate and keep the abstract annotation floc old floc where floc is a generic variable of type local .
with this abstract annotation when sdv is executed on a driver that exercises the irql rule the annotation will get instantiated with all local variables manipulated by loops in the driver and the annotation based invariant generation algorithm will be able to establish correctness of drivers that require preservation of local variable values similar to main of figure .
.
algorithm we now formally describe the annotation inference algorithm.
our presentation of the algorithm is general abstracting away from sdv speci cs for ease of presentation and to emphasize the use of veri cation histories.
however we evaluate the algorithm only on sdv in this work.
we leave generalization to other veri cation domains as future work.
we start by introducing the necessary notation and de nitions.
language.
we assume an imperative programming language with standard features such as global variables procedures assume andassert statements assignments etc.
we also assume that programs in this language do not have loops.
loops can be encoded using recursion.
this allows our framework to only concentrate on procedure postconditions for establishing proofs of correctness.
given a program p we denote the set of procedures in p withprocs p .
each procedure can be annotated with any number of rst order logic fol formulas.
these formulas are de ned over procedure parameters and global variables and they do not take part in program execution they are used by program veri ers as candidate postconditions for establishing program correctness.
abstract annotations.
letvbe a set of variables called the shared vocabulary.
all programs must contain vas global variables.
let gbe a set of generic variables.
none of the programs contain a variable from g. an abstract annotation ais a formula over variables in v g. further for every programpand procedure proc2procs p we assume a function p proc that maps an abstract annotation to a set of concrete annotations.
as de ned in the previous section p proc substitutes generic variables with the variables in scope ofproc.
we call a nite set of abstract annotations t2tatemplate .
given a program pand a template t annotate p t returns pwhere each procedure proc2procs p is annotated with the set of program annotationss a2t p proc a .
veri cation.
given a xed veri er for a program pand a template t we say that proves p t holds if the veri er can prove the correctness of annotate p t .
the veri er can use the procedure annotations as potential postconditions during the veri cation.
also we require that if proves p t and t t0 thenproves p t0 must hold as well.
in other words if a set of abstract annotations is su cient for proving some program correct then all of its supersets are also su cient.
.
problem our annotation inference problem is de ned using the notion of an objective relation.
such relations are used to 454encode what templates and hence annotations are more desirable for the current application in mind.
definition objective relation for a program .
we say!p t tis an objective relation for a program p i it is well founded and for each t2dom !p the setft0jt!pt0gis nite.
the objective relation is hence nite branching .
one example of such a relation is the proper subset relation i.e.
t!pt0 i t0 t. another example would be the relation where t0is a copy oftexcept that an annotation in t0is a sub formula of the corresponding annotation in t. this relation roughly corresponds to the syntactically simpler concept mentioned in section .
section presents the objective relation used in our experiments with sdv.
we extend the objective relation to a set pof programs p1 p n definition objective relation for programs .
we de ne!p t t an objective relation for a set of programsp fp1 pngas a well founded and nite branching relation t!pt0 v it!pit0.
we proceed by de ning the notion of a minimal template that intuitively stands for a locally optimal template.
the locality is de ned as a branching set of a template induced by a given objective relation.
definition minimal program template .
given a program p a template tsuch thatproves p t and an objective relation !p we sayt0is a minimal template i .proves p t0 .
there exists no t00such thatt0!pt00andproves p t00 the de nition states that a minimal template must prove a given program and none of its immediate !p successors do.
we point out that in the above de nition tonly ensures that pis correct and this de nition establishes no relationship between a minimal template and t. however the results computed by the implementations for nding minimal templates can be dependent on t. our inference algorithm is built around the notion of a minimal template.
we hence de ne the problem of nding a minimal template for a given program.
problem computing a minimal template .
given a program p a template tsuch thatproves p t and an objective relation !p the problem of computing a minimal template is nding a formula t0that is minimal subject topand the ordering !p.
we de ne a program repository asr whereproves pi ti for1 i n. repositories capture veri cation histories.
the set of programs in the repository r is denoted by pr.
the actual technique used for proving the correctness of pican be arbitrary.
however we envision that in practice a veri er will be xed for the whole repository.
we now de ne a locally optimal template for a veri cation history.
definition minimal repository template .
given a program repository r where proves pi ti for all i n and an objective relation !pr we say that tis a minimal repository template subject to!pr i the following holdsalgorithm computing a minimal program template require proves p t and!is an objective relation procedure mintemplate p t !
mint t loop for allt02ft0jt!t0gdo ifproves p t0 then mint t0 goto returnmint .proves pi t for all i n .there exists no t0such that t!prt0and proves pi t0 for all i n we are now ready to formally state the problem of inferring program annotations from past veri cation runs.
problem inferring program annotations .
given a program repository r where proves pi ti for all i n and an objective relation !pr the problem of inferring program annotations is to nd a template tthat is a minimal repository template subject to!pr.
in the sequel we suppress the subscripts of the !relations for brevity.
we now show algorithms for solving the problems of computing minimal templates.
.
solution we start with the solution for problem shown in algorithm .
the mintemplate algorithm assumes that a given template tis su cient to establish correctness of p and that!is an objective relation.
we start by considering tas a minimal template candidate line .
we continue by enumerating all immediate successors of tby!
line .
then the algorithm checks if any of the successors can prove p line .
if so then the algorithm sets such a successor as a candidate for the minimal template and repeats the whole process lines and .
otherwise the minimal candidate is returned as the solution line .
theorem .letpbe a program ta template and!an objective relation.
if proves p t then algorithm computes a minimal template for p t and!.
proof.
since!is nite branching we have that inner loop at line terminates.
from the fact that !is wellfounded it follows that the outer loop at line also terminates.
since lines and simply follow the de nition of a minimal template we have that the returned template is indeed minimal.
the complexity of the algorithm depends on !relation and implementation of proves .
assuming proves has unit complexity the running time of algorithm is o l m wherelis the longest well founded chain of !andmis the maximum size of the branching sets maxfjft0jt!t0gjjt2dom !
g. however proving a program correct is undecidable in general and expensive in practice.
further annotating a program p given a template tcan also be expensive if for proc2procs p 455algorithm computing a minimal repository template require proves pi ti for all pi ti 2r require !is an objective relation procedure minrepotemplate r !
mints for alli2 do p t r mints mintemplate p t !
c ?
for alli2 do c c for allt2ft0jc!fp1 pigt0gdo b true for allj2 do b b proves pj t ifbthen c t goto returnc the concretization function p proc has a large image tcan then potentially be instantiated with a large number of concretizations.
this high complexity of the algorithm can be remedied in practice by choosing p proc with smaller images and exploiting the structure of !if the relation is known beforehand.
we note that a result computed by the algorithm is not necessarily minimum.
as we show in section minimal templates su ced for all practical purposes in our experiments.
algorithm computes a minimal repository template by building on algorithm .
first we nd the minimum template for each program in the repository and store it in mints lines .
next the minimal repository template is set to the empty set of clauses line .
the outer loop lines has the invariant that after the ithiteration cis a minimal repository template for the sub repository .
the inner loop checks if an immediate successor of ccan prove the correctness of the programs p1 pi.
if so then cis updated to that successor template.
one possible optimization is to cache the clauses under which a program can cannot be proved.
therefore ifproves p t is in the cache and we later make a query proves p t0 wheret t0 then we can return true.
similarly if proves p t is in the cache and we make a query proves p t0 wheret0 t then we can return false.
theorem .letrbe a program repository and !an objective relation.
if proves p t for all p t 2r then algorithm computes a minimal repository template for r and!.
proof.
for every subrepository ri the relation!riis well founded and nite branching for any chosen reduction operator.
since the body of the loop at line follows the de nition of a minimal repository template then at the end of each iteration of the loop at line cis a minimal template for ri as pointed out earlier.
the result then follows from the case when i jrj.we also point out that the loop starting at line is in fact not necessary for optimality.
the algorithm can immediately start withcas the union of all minimal program templates stored inmints .
however such a ccould become impractically large.
in algorithm the size of cis kept moderate.
observe that the minimal templates computed using these two versions of the algorithm might not be the same.
this is because minimal templates are not unique.
.
application to sdv we use a speci c objective relation to infer useful program annotations for sdv on windows device drivers.
.
repository for internal testing sdv uses a set of toy drivers collectively called the rule test suite rts for quick smoke testing of sdv.
these drivers are small often a few hundred lines of code with relevant part in tens of lines of code only .
we use rts as the program repository for inferring a minimal repository template for each rule.
we will refer to such templates as inferred templates and to manually crafted templates simply as manual templates .
the use of rts as the training set is quite natural as it allows us to leverage existing test cases to learn and improve performance on real drivers.
rts consists of drivers totaling around 100kloc.
once we infer a template we measure the performance of sdv using the template on a set of real device drivers.
we use 66device drivers for this task totaling around 700kloc.
we note that the device drivers were functionally very di erent they included storage drivers modem drivers bus drivers etc.
sdv has hundreds of rules.
for this paper we concentrate on a collection of rules.
of these rules were selected because they were known to cause performance issues for sdv.
we added randomly chosen other rules.
these rules on the drivers produced a total of veri cation instances not all rules apply to all drivers .
obtaining annotations.
the rts suite consists of fairly small drivers that are easy to prove manually.
we however automated the entire process by running a proofgenerating veri er.
our implementation uses duality but conceptually we could have used tools such as slam and yogi as well.
our objective is to learn a template per rule.
for each of the28rules we form a repository of programs that assert the rule and their corresponding correctness proofs and de ne the shared vocabulary vto consist of model variables of the rule as well as os model variables.
every program in a repository is guaranteed to include the corresponding shared vocabulary as global variables.
.
objective relation we restrict abstract annotations to be clauses i.e.
a disjunction of formulas.
conjunctions at the top level are broken down into multiple annotations one for each conjunct.
for convenience we think of a clause as a set of formulas where disjunction is implied between the elements of the set.
the empty set corresponds to true .
given two annotations a1 anda2 bya1 a2we therefore designate that the formulas ofa1are a subset of the formulas of a2.
for a template t we de ne tto betconsistently indexed by the set f1 jtjg.
in other words t fa1 ajtjgwhereai2t ai2 t. 456for convenience we de ne t ai.
given two templates t1 andt2 we sayt2issimpli ed or simpler than t1 written t2 t1 i jt1j jt2jand t2 t1 for all i n. ift2 t1and there exists isuch that t2 t1 we sayt2 isstrictly simpler thant1 writtent2 t1.
finally t2 1t1 holds i t2 t1andj t1 t2j .
in other words t2is strictly simpler than t1but only at one abstract annotation we then sayt2is simpler than t1.
for example suppose a template t0istexcept that literal lis in t but not in t0 .
then we havet0 t t0 t andt0 1t.
given a program pand a template t leth p t be the result of running houdini on annotates p t .
further let cperf p t denote the number of procedures that corral inlined if it was able to prove correctness of h p t and 1otherwise.
cperf p t measures the performance of corral.
we use it as a proxy for the running time that is independent of the machine con guration.
we now de ne the corral objective relation.
given a program pand two templates t1andt2 t1!pt2holds i t2 1t1 cperf p t2 cperf p t1 the above de nitions encode our intention to nd those templates that are structurally simpler and smaller if one views making a clause empty as removing it.
the reason why we chose simpler relation instead of the general simpli cation is that we want to keep branching sets of the objective relation tractable.
this way we are sacri cing optimality for better inference times.
also note that our objective relation allows the performance of corral to get worse when using t2.
but corral must still be able to prove correctness.
we allow the degradation in performance to allow more opportunities for the templates to get simpli ed.
however we still restrict the performance to not get out of hand not more than a factor of .
this allows us to kill the execution of corral on h p t2 as soon as it inlines twice as many procedures as on h p t1 without waiting for a verdict.
lastly we de ne a repository objective relation.
for a set of programs p fp1 p ngwe de net1!pt2 v it1!pit2.
in other words we want to infer templates that are consistently optimal for all repository programs subject to the objective relation !p.
.
implementation we use a slightly modi ed version of algorithm for computing a minimal repository template.
we describe the algorithm by only explaining the modi cations that we introduced.
we rst note that the corral objective relation has to be computed by actually running corral.
while performing a greedy descent we simply enumerate all simpli ed templates and run corral on each of them.
this run tells us whether the program can be proved and the number of inlined procedures if any.
also we enumerate rst those annotations where the corresponding simpli ed clause is empty.
then we enumerate annotations where the simpli ed clause has one literal and then when it has two and so forth until we have enumerated all simpli ed templates.
this way we are heuristically choosing the well founded chains of smaller lengths while searching for a minimal template.
the second modi cation we introduce has the purpose of keepingcsmall in algorithm .
while computing a minimaltemplate for a single program we rst check whether any of the previously computed minimal templates is perhaps minimal for the new program.
if so then we continue by analyzing the next program.
as a result the number of distinct minimal templates in mints reduces and so does the size of c. further due to the de nition of proc p our algorithm can produce the same annotated program for di erent templates.
in that case the result of running houdini corral for the rst template is same as the result of running them on the other template.
we therefore use the concretized annotations to cache corral s outcome and reuse the results when possible.
we set a timeout of 8hours for the algorithm.
if the execution reaches a timeout we simply return the current value ofc.
in practice for sdv the template inference needs to be performed just once in a release cycle hence one can devote much more time for inference.
.
ev aluation we implemented our algorithms in a tool called proofminimization5.
it accepts a list of annotated programs written in boogie as input and computes the minimal repository template.
the shared vocabulary is automatically de ned to be the set of global variables common to all input programs.
the implementation is a simple wrapper of less than lines of c code around the implementation of corral .
we ran our experiments on a cluster of identical serverclass machines.
each of the servers had intel xeon cpus .
ghz gb ram and logical processors.
the total cpu time of our experiments exceeded well over a month.
we relied on parallelism extensively to produce results in a reasonable amount of time.
training modes.
our experiments evaluate two di erent ways of using the inferred templates.
in the rst mode called mt the inferred templates only augment the manual templates.
this is achieved by adding the manual templates to each p t pair in our program repository and requiring our algorithm to never throw out a manually generated annotation.
this mode of operation is more controlled it does not seek to replace existing manual e ort but rather to just augment it.
the second mode of operation called nt does not use manual templates at all.
this simulates the scenario when no manually generated templates had been added to sdv.
it answers how much of the manual e ort behind the design of manual templates can be automated using our techniques.
clearly the quality of inferred templates will depend on the quality of the training set i.e.
the repository used for inferring a minimal repository template.
because it was never intended to use rts for inferring templates the training sets are sometimes inadequate for our approach.
for instance for a few rules rts only contains buggy drivers.
inferring annotations from buggy programs is an interesting problem but outside the scope of this paper.
thus we also evaluate expanding our training set by sampling a randomly chosen fraction of the 66real drivers and including them in the training set.
the test set i.e.
the set of unseen drivers over which we evaluate the inferred templates then shrinks to the remaining drivers.
5implementation is available at boogie org corral tree master addons pminbench along with supplemental material and examples that the reader can use to experiment.
457figure annotation inference times for the rules.
lettrain f m where f 100andmis either mt or nt refer to the experiment where the training set consisted of all rts drivers and fpercent of the real drivers and the inference was done in mode m. an exception is the special case of train mt which denotes that all drivers were used in the training set as well as the test set.
we use train mt as a limit study on the quality of annotations that we can infer.
results.
for the experiment train nt the running time of proofminimization is shown in figure .
it takes just a couple of minutes for some rules while it timeouts after 8hours for ve rules.
not including the rules for which proofminimization times out it takes roughly hours on average to compute the result.
the results with various di erent training modes are reported in tables and .
each of the tables compares three versions of sdv.
the version called none does not use any templates and captures the performance of corral without any annotations.
manual refers to using manual templates which is the currently shipping production system.
inferred refers to using the set of annotations inferred by our tool.
each of the tables measures performance in terms of the number of timeouts to number of times the coverage bound was hit bnd the number of bugs reported bugs the average running time of houdini corral avg and the average running time of just houdini houd .
table left compares performance for train mt .
in this mode our inferred set of annotations was empty for of the 28rules.
the inferred set can be empty when the rts wasn t rich enough or because the manual templates were su cient.
in this case the performance of inferred matches with that of manual .
table compares performance on the remaining 16rules where we did infer annotations.
these results demonstrate that our extra set of annotations are useful.
the number of timeouts come down a fraction and the number of times the coverage bound was hit comes down signi cantly.
all of these previously inconclusive cases in number convert to a proved verdict.
in summary the total number of inconclusive answers drops down by .
moreover even though houdini ran slower because of the extra annotations the performance improvement in corral made the overall system much faster .
fortrain mt we did three runs each time sampling a di erent fraction of the drivers.
the variance acrossthe three runs was very small thus we stopped with three runs.
the results for inferred were averaged across the three runs and are shown in table right .
it is interesting that performance is similar to train mt .
using a fraction of drivers did not provide much new information.
however the results of train mt shown in table left do indicate that drivers potentially carry information not present in rts.
learning over all drivers increased the quality of inferred annotations signi cantly even though the running time of houdini is highest in this setting .
table right shows results of train nt .
with no help from manual templates corral s performance depends even more signi cantly on the inferred set of annotations.
we were able to achieve a similar quality of results compared to using manual templates.
there was a near equal split between rules on which inferred annotations do better and ones on which manual templates do better.
in consultation with the sdv team we realized that the exercise of setting up manual templates often borrowed annotations across rules where annotations useful for one rule would be generated for similar rules as well.
in our setting we did not explore sharing information between rules.
the number of abstract annotations per template on average was 78for the manual templates.
the train mt experiment produced annotations per template on average.
the train mt experiment produced annotations per template on average.
the train nt experiment produced 3annotations per template on average which is signi cantly smaller than the manual templates.
we supply the list of all rules and templates in the supplemental material.
here we summarize examples of useful annotations that our technique was able to infer but were missed by experts.
firstly for irql based rules the annotation floc old floc was necessary for establishing important loop invariants such as the irql value is unchanged across loop iterations see example in figure and discussion in sections .
and .
.
while the experts anticipated the latter i.e.
irql is unchanged to be a useful annotation they did not expect that an invariant over local variables would be required to prove it inductively.
a second instance of useful annotations found by our technique is for sdv rules with multiple model variables.
manual templates mostly have annotations that capture the e ect of a procedure s execution on a single model variable .
however these are insu cient to capture inter variable relationships.
we infer several annotations over multiple variables which helped signi cantly for such rules.
to summarize train mt results show that we can signi cantly improve the performance of a production system by augmenting existing manual e ort.
the results for train nt show that as new rules are developed and test cases are added to rts we can automatically generate useful annotations avoiding the need for further manual e ort in coming up with new templates.
.
related work this work falls into the category of predicting program properties from codebases.
for example jsnice learns from javascript repositories on github and predicts more legible identi er names and unveri ed type annotations .
in contrast this work is the rst attempt at inferring annotations from veri cation histories and demonstrating their use 458table left results for train mt on a total of 16rules with 873veri cation instances.
right results for train mt averaged across three runs on a total of 25rules with 1002veri cation instances.
time sec con g to bnd bugs avg houd none .
manual .
.
inferred .
.1time sec con g to bnd bugs avg houd none .
manual .
.
inferred .
.
.
table left results for train mt on a total of 28rules with veri cation instances.
right results for train nt on a total of 28rules with 1420veri cation instances.
time sec con g to bnd bugs avg houd none .
manual .
.
inferred .
.2time sec con g to bnd bugs avg houd none .
manual .
.
inferred .
.
in an industrial scale veri cation setting.
other approaches use codebases to predict di erent program properties rather than annotations .
for instance work presented in applies bayesian optimization on existing codebases to learn a strategy for deciding for which part of an unseen program a static analyzer should sacri ce time for precision while performing the analysis.
there are veri cation and testing approaches that leverage previous versions of a program under analysis.
for example improves performance of test generation for a program by leveraging existing tests belonging to a previous version.
regression veri cation veri es the equivalence of two successive versions of a program .
for similar programs argues that this veri cation task is easier than our goal here i.e.
formal veri cation of a stand alone program.
a recent generalization of regression veri cation is di erential assertion checking where a veri er checks that a bug is not introduced in going from one program version to another .
techniques in extrapolate from predicates used for verifying a program under sequential consistency to verify the same program under a relaxed memory model.
incremental veri cation attempts to reuse annotations corresponding to a program in the veri cation of its updated version .
in these works the history typically consists of revisions of the program under analysis.
we consider histories with programs that use the same kernel api but can be very di erent otherwise.
for example we can use annotations inferred from a storage and a modem driver to help verify an ieee bus driver.
also our technique uses the minimization mechanism to reduce the size of the accumulated annotations in order to retain practicality.
the techniques described in this paper can be used to infer invariants using veri cation histories.
previous approaches to invariant inference perform analysis only over the program under consideration.
these include invariant inference using static analysis or learning from concrete executions .
our work is complementary to these.
.
conclusion we present an algorithm for computing a small set of usefulprogram annotations from a repository of past veri cation runs.
we used this algorithm to improve the performance of sdv by generating better quality annotations than those produced by human experts.
by utilizing the inferred an notations we reduce the number of inconclusive answers by47 while running faster on average even for a heavily optimized system.
our approach bene ted from sdv s separation of verifying driver correctness into checking multiple rules.
by concentrating on one rule at a time our inferred annotations were tailored to a speci c property of drivers.
in future work we wish to study the generality of our algorithm in other veri cation domains that rely on annotations for constructing program proofs.
.