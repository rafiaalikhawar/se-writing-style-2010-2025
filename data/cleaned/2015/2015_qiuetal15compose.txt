compositional symbolic execution with memoized replay rui qiu guowei yang corina s. p as areanu and sarfraz khurshid university of texas usa ruiqiu khurshid utexas.edu texas state university usa gyang txstate.edu cmu nasa ames usa corina.s.pasareanu nasa.gov abstract symbolic execution is a powerful systematic analysis that has received much visibility in the last decade.
scalability however remains a major challenge for symbolic execution.
compositional analysis is a well known general purpose methodology for increasing scalability.
this paper introduces a new approach for compositional symbolic execution .
our key insight is that we can summarize each analyzed method as a memoization tree that captures the crucial elements of symbolic execution and leverage these memoization trees to efficiently replay the symbolic execution of the corresponding methods with respect to their calling contexts.
memoization trees offer a natural way to compose in the presence of heap operations which cannot be dealt with by previous work that uses logical formulas as summaries for compositional symbolic execution.
our approach also enables efficient target oriented symbolic execution for error detection or program coverage.
initial experimental evaluation based on a prototype implementation in symbolic pathfinder shows that our approach can be up to an order of magnitude faster than traditional non compositional symbolic execution.
i. i ntroduction symbolic execution is a powerful systematic program analysis technique that has found many applications in recent years ranging from automated test case generation and error detection to regression analysis security analysis continuous testing and program repair .
the technique enumerates the program paths up to a given bound and records the conditions on the inputs to follow the different paths as dictated by the branches in the code.
off the shelf constraint solvers are used to check the satisfiability of path conditions to discard those paths that are found to be infeasible.
in practice scalability is a major challenge in symbolic execution due to high computational demand.
compositional analysis is a well known general purpose methodology that has been used with success to scale up static analysis and software verification including symbolic execution .
the main idea is to analyze each elementary unit i.e.
a method or a procedure in the program separately and to store the analysis results in a summary for that method or procedure encoding the inputoutput behavior of the unit.
whole program analysis results are then obtained by incrementally composing and utilizing the previously built summaries.
this paper introduces a new approach for compositional symbolic execution .
our key insight is that we can summarize each analyzed method as a memoization tree that captures the crucial elements of symbolic execution i.e.
the choicesmade along each path and the input path conditions including constraints on the program s heap for complete paths.
the memoization tree succinctly summarizes the feasible paths through the method and it does not explicitly encode the method s outputs as is typically done in previous approaches.
instead we define a composition operation that uses the memoization trees in a bottom up fashion for efficient replay of symbolic execution of the methods in different calling contexts.
during composition constraint solving is only used at a method call site to determine which paths in the method summary are still feasible these paths are then explored without any further constraint solver calls and the search is guided by the choices recorded in the memoization tree.
this results in significant savings in analysis time due to reduced number of solver calls as compared to non compositional symbolic execution.
a key advantage of using the memoization trees is that they offer a natural way of handling the heap which cannot be dealt with by previous work that uses logical formulas as summaries for compositional symbolic execution .
when composing a method summary with the actual calling context we first perform a partial check of the heap constraints on the possibly symbolic heap of the calling context and then re execute the method guided by the memoization tree which naturally reconstructs the heap and re computes the outputs of the method.
we enhance our approach for two common application scenarios of symbolic execution error detection and test generation to achieve a certain coverage.
we introduce two heuristics that specifically target reachability of program statements and states of interest and thus facilitate error detection.
specifically we explicitly mark memoization tree nodes along paths that lead to a target e.g.
an assert statement that may lead to an assertion violation.
the heuristics use this information to prioritize and prune the exploration of symbolic paths in a bottom up incremental way with the goal of quickly propagating up the information about the specific target.
while our focus in this paper is on improving scalability of symbolic execution using our compositional approach it offers a number of other potential benefits.
for example our approach enables more efficient selective regression testing where the memoization trees are stored off line and re used e.g.
when the code in the caller method is modified but the callee is unmodified.
moreover our approach lends itself ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee 1int p int x int y if x y 3x else 5y if x y return x else return y 1int q int a int b if a b return p a b else return p b a fig.
.
caller method q and callee method p naturally to parallel analysis for both building and re use of summaries method summaries for different methods can be constructed in parallel and memoized path conditions can be checked for the current calling context in parallel.
we implemented our approach into a prototype tool that builds on symbolic pathfinder spf .
the experimental results on subjects show that compared to traditional noncompositional symbolic execution our approach is up to an order of magnitude faster and has up to reduction in constraint solver calls.
ii.
b ackground symbolic execution is a technique that analyzes a program using symbolic values for inputs rather than actual concrete inputs as normal execution of the program would.
in symbolic execution program variables and outputs are computed as expressions in terms of those symbols from inputs.
to determine what inputs lead to which paths of the program to be executed symbolic execution introduces path constraints pc that are boolean expressions in terms of input symbols for possible choice of branch conditions in program.
asymbolic execution tree represents the paths taken in a program during symbolic execution.
each node in the tree represents a state of the symbolic execution which reflects a set of states in actual concrete execution.
edges between nodes stand for transitions among states.
we illustrate symbolic execution on a program in figure that has two methods pandq.
method ptakes two integers xand yas input and returns an integer according to the relationship between xandy.
method qalso takes two integers aandbas input and invokes method pto return an integer.
we treat method qas the start point of symbolic execution.
figure shows the complete symbolic execution tree of method q. initially pcis true and symbolic variables aand bhave symbolic values aandbrespectively.
program variables are then set symbolic values in terms of aandb.
for example when method pis invoked in line in method q the values for input of method p xand y are a and b respectively.
for each conditional statement in the program pcwill be updated with all possible choices from the branch condition so that all possible paths are explored.
whenever pc is updated it is checked for satisfiability by calling the off theshelf constraint solver.
if pcbecomes false not satisfiable which means the corresponding path is infeasible symbolic execution does not continue for that path.
for example in method qthere are four paths that are infeasible due to the a a b b pc true a a b b pc a ba a b b pc a b p a b p b a x a y b pc a b a bx a y b pc a b a bx b y a pc b a a bx b y a pc b a a b x a y b pc a b a b a bx a y b pc a !
b a b a b x b y a pc b a b a a bx b y a pc b!
a b a a b return b 10pc false infeasible path return a 10pc false infeasible path pc false infeasible pathpc false infeasible path fig.
.
symbolic execution tree for method q unsatisfiable path conditions.
programs with loops may have infinite numbers of paths so symbolic execution needs to be bounded for these programs.
the exploration of paths can stop when a certain search depth is reached or a coverage criteria has been achieved.
symbolic pathfinder spf uses lazy initialization to handle dynamic input data structures e.g.
lists and trees .
the components of the program inputs are initialized on an asneeded basis.
the intuition is as follows.
to symbolically execute method mof class c spf creates a new object oof class c leaving all its fields uninitialized.
when a reference fieldfof type tis accessed in mfor the first time spf nondeterministically sets ftonull a new object of type twith uninitialized fields or an alias to a previously initialized object of type t. this enables the systematic exploration of different heap configurations during symbolic execution.
iii.
e xample compositional analysis this section illustrates our approach to compositional symbolic execution on the simple example from figure .
when traditional non compositional symbolic execution is applied on the method qshown in figure method p is executed twice since both branches of the conditional statement at line 2of method qare feasible.
the cost of method p s re execution can be reduced by compositional symbolic execution where we first build a memoization tree of method p and then efficiently perform symbolic execution of method qby replaying the symbolic execution of pin the two calling contexts using p s memoization tree.
figure a shows the memoization tree for method p.a memoization tree succinctly summarizes all the choices taken during symbolic execution .
other than the root node n0 each node is created whenever a conditional statement is executed recording the branch that is taken during symbolic execution e.g.
node n1in figure a indicates that the true branch of the conditional statement at line 2in program pis executed.
additionally the tree leaves are annotated with the path conditions for each complete path through the method.
out of the four paths in the program three paths are captured in this memoization tree because the missing path is infeasible with an unsatisfiable path condition x y x y .
to replay the symbolic execution of the callee method that has a memoization tree the feasible paths in the memoization 633n0 p root n5 p 0n3 p 1n4 p 0n1 p 1n2 p pc x !
y x ypc x y x ypc x !
y x y n1 q root n2 q 1n3 q n4 p n4n5 p n4 pc a !
b a b a b pc b !
a b a a b a b fig.
.
a tree built for method p. b tree built for method q tree are checked against the calling context to determine whether they are feasible or not.
we map the actual inputs of the callee method to the parameters stored in memoization tree.
for example when invoked at line 3of method q method p s actual inputs are a 1andb and its formal arguments arexand y.s ow em a p a xand b y. each annotated path condition in the memoization tree is transformed by replacing the parameters with the actual inputs using the map and then combined with the path condition from the calling context.
the combined constraints are then checked to decide if the corresponding path in pis feasible or not.
for the path in method pthat ends at node n5in figure a for instance the transformed path condition a !
b a b after replacing the formal arguments combined with the calling context constraint a b is not satisfiable and thus this path is not feasible in the calling context.
in this case the nodes along this path n2and n5 are marked so that the path will not be explored by symbolic execution in composition.
figure b shows the memoization tree built for method qby reusing method p s memoization tree.
for paths in p that are feasible in the calling context we do not put their corresponding nodes in q s memoization tree.
instead we use summary nodes to point to those paths in method p s memoization tree to reduce the memory cost.
for example nodes n4and n5in figure b are summary nodes.
in node n4 points to the path ended at node n4 n0 n1 n4 in method p s memoization tree.
in traditional symbolic execution whenever the path condition is updated it is checked for satisfiability using the underlying constraint solver.
therefore traditional symbolic execution makes 10constraint solver calls in total for symbolically executing method q according to the conditions encoded in figure .
in contrast our approach makes 8constraint solver calls i.e.
two calls for branch conditions in method qand3 calls each in method pin its two calling contexts line 3and line5in method q reducing the overall analysis time.
although in this particular example the saving for number of constraint solver calls is rather modest the benefits of the compositional analysis become more pronounced when there are many invocations of the same method e.g.
qis invoked in a loop and each invocation only costs and constraint solver calls for methods qandprespectively see section v for benefits .iv .
c ompositional symbolic execution overview.
in our compositional approach the methods of a program are processed in an order corresponding to a bottomuptraversal of the program s call graph starting with the ones that invoke no other methods and incrementally processing methods whose sub methods have already been processed until the whole program is analyzed.
for each processed method we use bounded symbolic execution to compute a method summary which consists of a tree that succinctly represents all the symbolic paths through the method together with the input path constraints for the complete paths the bound is specified by the user and it is stored in the tree.
the summary is stored memoized for future re use whenever that method is invoked from another method we say that the two methods are composed .
note that when deciding on the order to analyze the methods in a given system two main strategies can be followed.
a top down approach may be adequate if one wants to compute only the strictly necessary information.
however this approach does not guarantee that reuse of summaries is always possible and summaries may need to be recomputed for different calling contexts.
in contrast a bottom up approach ensures that the computed summaries can always be reused albeit at the price of computing summaries larger than necessary in some cases.
we follow the latter strategy in our framework.
at a high level our approach works as follows.
let us assume that program pconsists of an entry method m0and a set of methods m1 m2 ... m kthat belong to m0 s method invocation hierarchy.
in the hierarchy each leaf method i.e.
a method that invokes no other methods is analyzed first and its feasible paths and corresponding path constraints are summarized in a memoization tree.
then the methods that directly invoke these leaf methods are analyzed by leveraging the already built memoization trees.
the process continues in a bottom up fashion until the entry method m0is analyzed.
handling recursion.
if a method invokes itself we build the summary tree directly up to a pre specified bound.
for indirect recursion i.e.
a loop consisting of several methods in the call graph we randomly choose one method in the loop and build the summary tree for it without reusing other callee methods.
the summary built will consist of all methods in the loop up to a certain bound.
algorithm.
algorithm describes our overall approach.
procedure getstaticcallgraph p m line creates the call graph for prooted in m0.
procedure getleafnodes line identifies the leaf methods in the invocation hierarchy.
furthermore the algorithm checks whether each analyzed method has conditional statements using helper method containscondstmt line and skips the analysis of the method that does not contain any conditional statements since methods with no conditional statements would not give benefits during compositional symbolic execution.
procedure analyzemethod line performs a bounded symbolic execution for method mand builds its memoization tree using the previously computed memoization trees stored 634algorithm compositional symbolic execution input program p entry method m0 output a set of summary trees stfor methods in p st callgraph cg getstaticcallgraph p m0 set s cg.getleafnodes while s negationslash do for each method m sdo ifm.containscondstmt then summarytree t analyzemethod m st st.add t s cg.getnodestoprocess s return st in the set st. procedure getnodestoprocess line returns the nodes in the call graph whose corresponding methods have not been processed so far but the methods that they invoke have already been processed.
algorithm shows procedure analyzemethod for building section iv a and composing section iv b method summary trees.
we describe some of its key elements in more details below.
a. construction of memoization trees a memoization or summary tree is a recursive tree data structure that succinctly captures the crucial elements of symbolic execution for each analyzed method.
each tree contains two types of nodes normal nodes and summary nodes .
at a high level for each method mcaller invoking method mcallee normal nodes encode the choices taken for each condition in the code while summary nodes encode pointers to the paths in mcallee s summary that are found to be feasible at the invocation point from mcaller .
normal nodes.
a normal node n represents a choice taken at a conditional statement and it encodes m the name of the enclosing method offset the instruction offset of the conditional statement and choice choice taken by the execution for true branch and for false branch .
for example in figure a node n2has a tuple indicating that in method pinstruction with offset if x y takes the choice of false branch.
a symbolic execution path can be succinctly represented by the sequence of choices taken during its execution and can be recovered from the memoization tree by traversing the tree from the root to a leaf.
we thus can use the leaf nodes to represent their corresponding paths.
for example in figure a node n4implies an execution path that takes the true branch at the first conditional statement and the false branch in the second conditional statement in method p. we note that we need to keep track of all the conditions in the method not just the ones being executed symbolically.
the reason is that during replay some of the conditions that were symbolic during tree generation may become concrete due to concrete inputs from the calling context we can not distinguish that from a condition that was concrete to begin with in the tree.
we therefore chose to record allthe conditions in the summary tree and used the tree to guide the execution of all the conditions see lines in analyzemethod .algorithm procedure analyzemethod for building and composing memoization trees input method mcaller set memoizationtree s t output memoizationtree tcaller for method mcallee boolean tocompose false memoizationtree tcaller new memoizationtree memoizationtree t null instruction insntoexe getnextinstruction while insntoexe !
null do if!tocompose then turnonconstraintsolver iftype insntoexe conditionalinstruction then node n createnode insntoexe tcaller .add n iftype insntoexe invokeinstruction then ifinvokedmethod insntoexe stthen tocompose true t st.getsummary insntoexe mapping mapping createmapping context context getsymeexcontext for each path path t.getpaths do summarypc spc path.getsummarypc boolean isconsistent false for each pcpair pcp spc do ifcheck pcp context mapping then isconsistent true break if!isconsistent then marknodes path else turnoffconstraintsolver iftype insntoexe returninstruction then ifbacktocaller insntoexe then tocompose false tcaller .compressnode iftype insntoexe conditionalinstruction then node n t.getnextnode ifn summarynode then t.decompressnode n n t.getnextnode ifn markednodes then prunepath else tcaller .add n insntoexe getnextinstruction return tcaller summary nodes.
only a subset of the paths in method mcallee s memoization tree i.e.
the feasible paths in the particular calling context from method mcaller can be executed and should be contained in the memoization tree for method mcaller .
to compactly represent these paths in method mcaller s memoization tree we introduce summary nodes s .
these are nodes that point to a path in method mcallee where prepresents a pointer to one of the leaf nodes in method mcallee s memoization tree.
summary nodes serve as pointers to the paths in method mcallee that are feasible in the method mcaller s context thus the method mcaller s memoization tree does not need to duplicate the paths of repeated normal nodes from existing trees.
procedure compressnode line compacts a sequence of normal nodes into a summary node which can be reverted to the original sequences of normal nodes when the memoization tree is reused for analyzing other methods.
for instance in figure b nodes n4and n5are summary nodes indicating p s feasible paths in its calling context.
635they point to the path represented by node n4in method p s memoization tree.
path conditions.
each leaf node in the tree has an associated set of path conditions characterizing the inputs that follow the path from the root to the leaf.
note that we do not have a one to one correspondence between paths in the memoization tree and the symbolic execution tree the reason being that the memoization tree is more compact and can represent multiple symbolic executions.
each tree leaf has one or more pairs of numeric path condition pc and heap path condition heappc .
numeric path conditions depict the constraints over numeric inputs for choosing one path see figure while heap path conditions encode heap constraints introduced when analyzing methods with parameters of reference types.
we discuss the heap constraints in more detail below.
heap path conditions.
a heap path condition is a conjunction of constraints over the heap allocated objects in the input data structures.
they are generated by lazy initialization during the symbolic execution of a heap manipulating method.
more precisely these constraints are generated during the symbolic execution of instructions that perform a first access to an un initialized field i.e.
bytecodes aload getfield and getstatic .
the constraints can have the following form ref null.
reference refpoints to null.
ref1 ref2.
reference ref1points to the same object in heap as reference ref2 i.e.
ref1and ref2are aliased.
ref negationslash null.
object reference ref points to a symbolic object that is neither null nor any existing objects in heap with all its fields initialized as symbolic values.
these constraints are sufficient to express all the possible aliasing scenarios in the input data structure .
note that since our memoization tree only encodes the conditional branches in a method different heap constraints can drive the program along the same path.
for example if the condition in the code checks for the input to be not null paths characterized by non null constraints whether they are aliased or not will pass that check.
thus each path in a summary tree can have one or more pairs of pc and heappc.
we show later in this section an example of compositional analysis for heap manipulating programs.
b. composition of memoization trees our approach uses existing memoization trees to efficiently replay the symbolic execution of the corresponding methods with respect to their calling contexts.
in particular the memoization tree of the callee method is utilized to guide part of the symbolic execution of the caller method.
our approach first performs regular symbolic execution of method mcaller and creates normal nodes for conditional instructions executed in method mcaller lines .
when the execution encounters an invocation of method mcallee w e suspend regular symbolic execution controlled by variable tocompose and check which paths of mcallee are feasible in the calling context line .
if a path s pc heappc pair is consistent with the current path conditions in the callingsite this path is considered feasible otherwise the path is infeasible and it is marked in mcallee s memoization tree as not to be executed lines .
only feasible paths are considered during symbolic execution.
furthermore constraint solving which is typically the most expensive part of symbolic execution is turned off during the guided execution of method mcallee line and is resumed when the execution returns from method mcallee back to method mcaller line .
search bound.
the symbolic execution bound is fixed for a summary tree once it is built.
summary trees can be iteratively deepened as described in our previous work .
to reuse a tree with a search bound if the caller method s bound is set to be greater than the callee method s summary bound our approach will turn on the constraint solver and continue as traditional symbolic execution to extend the tree for the caller method.
therefore the set of paths explored in our compositional analysis is the same as in traditional noncompositional symbolic execution.
checking path condition consistency.
the composition of method summaries involves checking the consistency of path conditions to determine whether paths in the memoization tree of a called method are feasible in the current calling context.
in particular we check the consistency of the path condition in the tree with the path condition at the calling site.
algorithm checks path condition consistency.
the input mapping records the mapping between parameters of the summarized callee methods and actual inputs of the method in call site.
with this mapping we convert the path conditions in the memoization trees to path conditions that refer to variables in the calling context by replacing the formal parameters of mcallee with the actual arguments from mcaller .
lines 7check the consistency of numeric pcs.
each constraint in a path condition in the memoization tree is checked against the path condition from the calling context we also perform some simplifications that we omit here for clarity .
the conjunction of the summary pc and the context pc is checked for satisfiability using constraint solving.
checking heap path conditions.
lines 18check the consistency of heap path conditions heappc .
note that the heap in the calling context may be either concrete or symbolic.
if it is concrete then the heappcs can be checked directly.
however if the current heap is symbolic we perform an approximate consistency check for heappcs.
the objects in method mcallee s heap path conditions can be mapped to a concrete object in method mcaller s calling context or null or a symbolic object whose fields are all symbolic values.
for each constraint in the summary heap path condition both sides of the constraint map to lhr left side heap reference and rhr right side heap reference respectively.
if both of them arenull this constraint conforms with the context heap path condition or if both of lhrandrhr are concrete objects and they reference the same object in the calling context heap the constraint apparently also conforms to the context heap path condition.
if they are both symbolic objects we consider it consistent as well since they are both uninitialized and would be explored by lazy initialization line .
thus we take a 636algorithm procedure check for checking pcand heappc consistency input pcpair pcp context context mapping m output true for satisfiable case or false for unsatisfiable case pc npc mapnpc pcp m pc contextnpc context.getnpc for each constraint c npc do contextnpc contextnpc.addconstraint c boolean pcsatisfied contextnpc.solve if!pcsatisfied then return false heappc hpc maphpc pcp m context for each constraint hc hpc do comparator comp hc.getcomparator ifcomp !
then continue reference lhr hc.getleftsideref reference rhr hc.getrightsideref if lhr symref rhr symref lhr object rhr object lhr null rhr null then continue else return false return true conservative approach to checking heap consistency meaning that for the constraints that we can not decide in the current context we assume they are feasible and we leave the lazy initialization of mcallee to resolve it during replay.
if the conservative approach is needed we turn on the constraint solver for checking the numeric path constraints.
c. example involving heap constraints consider the swap node example in figure where class node implements a singly linked list.
a node has two fields elem and next representing an integer element and a reference to the next node in the list.
method swapnode destructively updates a node s next field.
method callswapnode creates a new concrete node n1 sets n1 s next as the input parameter and invokes method swapnode onn1.
we use lazy initialization to analyze method swapnode and generate a memoization tree shown in figure .
lazy initialization checks seven method executions that represent an isomorphism partition of the input space.
however based on conditional statements in the code the method contains only three paths as shown in figure i.e.
n1 n2 n1 n3 n4 and n1 n3 n5.
therefore we encode these seven different input data structures as seven pairs of numerical path condition and heap path condition which spread across the three paths.
for example node n2 has a numeric path condition pc true and a heap path condition heappc this.next null.p c true indicates that no constraint on the input data structure s integer variables is associated with this path.
heappc implies that if input this s field next points to null this path will be executed.
when method swapnode s memoization tree is reused during compositional symbolic execution the paths in method swapnode s memoization tree are checked for feasibility in this particular calling context.
figure illustrates the process of checking consistency of path conditions.
first in statement lazy initialization non deterministically initializes n1.next1class node int elem node next node swapnode if n e x t !
null if elem next .
elem node t next next t .
next 9t .
n e x t this return t return null static node callswapnode node n node n1 new node n1.
next n return n1 .
swapnode fig.
.
swap node example tonull o r n1 or a new node with all its fields uninitialized.
then the actual parameters from the calling site are mapped to the formal parameters in the memoization tree.
in this example concrete object n1is mapped to thisin summary.
for each pair of pc and heappc in summary tree we check if it is satisfiable with its current input data structure from the calling site.
for example in figure one of the calling context is that thisreferences a concrete node object with its elem and its next field pointing to another node object with all uninitialized fields.
we select two pairs of pc and heappc from two paths inswapnode to show how to check consistency in presence of heap operations.
one is pc true heappc this.next null and the other one is pc this.elem this.next.elem heappc this.next!
this .
the first one is not consistent with the calling context since this.next is not null while the second one is consistent because this.next!
this conforms to the input data structure and this.next.elem is symbolic uninitialized so it can be greater than or equal to this.elem whose concrete value is .
if all pairs of pc and heappc associated with a path in a memoization tree are checked to be inconsistent with respect to its calling context we consider that path infeasible in the calling context.
again the infeasible paths are marked to be pruned in symbolic execution during composition.
in this example all three paths of swapnode are feasible when invoked by method callswapnode since every path has one or more pairs of pc and heappc that are consistent with the calling context.
d. discussion correctness.
consider a method mcallee that does not invoke any other methods.
then normal symbolic execution explores the same behaviors as the replay of symbolic execution of the summary tree for mcallee .
this follows from the way we construct the memoization tree as a succinct representation of the symbolic execution tree for that method.
note also that the path conditions from the tree leaves characterize by construction the inputs that follow those paths.
consider now method mcaller that invokes method mcallee for which we computed the summary tree.
whenever mcallee is invoked inside mcaller we check to see which path in mcallee s summary tree can be used in the current context 637n1 swapnode root n2 swapnode 0n3 swapnode n5 swapnode 1n4 swapnode 0pc true heappc this.next null pc this.elem this.next.elem heappc this.next!
nullpc true heappc this.next thispc this.elem this.next.elem heappc this.next.next this.next this.next!
null pc this.elem this.next.elem heappc this.next.next this this.next !
nullpc this.elem this.next.elem heappc this.next.next null this.next !
nullpc this.elem this.next.elem heappc this.next.next!
null this.next!
null fig.
.
tree built for method swapnode nullnext nullnext0 next enextinitialize n1.next in stmt 16n1 n1 n1 n1 ?next enext ?next next nullnext this this thisreplace parameters before method invocation pc this.elem this.next.elem heappc this.next!
thispc true heappc this.next null.........check pc and heappc for each path not feasiblefeasible fig.
.
the process for checking path conditions when reusing summary tree by checking the satisfiability of the path conditions stored in the tree s leaves.
it may be the case that multiple paths from mcallee can be used in the current calling context.
they are all used systematically.
since all the cases that apply are used formcallee we conclude that there is no loss of information from the composition procedure up to the given bound .
note that due to the conservative treatment of consistency heap checking some of the infeasible paths need to be reexecuted during composition.
constraint solving is turned on for those paths so that only feasible paths are added to mcaller s summary but it may result in un necessary work for the analysis.
this is the price we pay in exchange for a simple consistency checking procedure.
identifying the inputs to a method.
so far in our presentation we assumed for simplicity that the inputs to a method are the method s parameters.
however the inputs to the method should also include all the global variables fields that are accessed without first being initialized inside the method.
identifying all these fields can be a daunting task due to the complex features of java inheritance interfaces etc .
we have developed a simple solution to the problem.
our approach assigns fresh symbolic values to all the global variables in the containing class of method mcallee before it is invoked.
the fields initialization happens right after the callee object is created.
the algorithm also assigns fresh symbolic values to all fields of the classes that are created at the time of the callee s object creation.
for static fields we also consider them as symbolic at the beginning of the analysis for mcallee .
in this way all the global variables that mcallee can access are initialized with fresh symbolic values.
the composition procedure becomes more involved because we need to perform a traversal of the heap at the calling siteto identify the values of mcallee s inputs to be mapped to the corresponding symbolic values.
in practice some of the global variables should be kept concrete as they may represent constants instances of library classes etc.
that do not need to be analyzed symbolically.
this would also make the symbolic state space more manageable.
automatically identifying which fields to keep concrete is left for future work.
in our current work we assume that the developer goes into the code and annotates which fields to be kept concrete.
e. target oriented compositional symbolic execution we have developed two heuristics that are specifically targeted towards covering a designated state in the program this may be an error or a statement deep inside the program that we aim to discover quickly .
heuristic .
to quickly steer symbolic execution towards a specific target our approach explicitly marks memoization tree nodes along paths that lead to the target e.g.
an assertion violation.
in the first heuristic our approach uses shortcircuiting if a path condition of a path that leads to an error in a summary is satisfiable in its calling context the path does not need to be re executed and the error can immediately be reported and also recorded in the calling method s summary.
moreover the error markings enable a directed search for errors where the replay of a memoized tree is prioritized to paths that may lead to errors if a memoization tree checked from a top level method has a path that terminates in an error state the corresponding path condition can be checked for feasibility in the calling context before the other path conditions thus if the feasibility check succeeds the search can report an error thereby pruning the other memoized paths.
heuristic .
the second heuristic performs aggressive pruning of the memoized trees by keeping only the paths that lead to the error and discarding the rest .
while incomplete this approach turns out to be quite effective in practice as demonstrated by the experiments in the next section.
v. i mplementation and ev aluation implementation.
we implemented our compositional symbolic execution in symbolic pathfinder spf as two listeners.
one builds the summary tree and the other one uses the summaries to guide symbolic execution.
whenever a conditional statement is executed whose condition is either concrete or symbolic we introduce a special type of choice called branchchoice of size in the spf execution.
this is a mechanism that allows us to precisely encode the conditional 638table i ev aluation for compositional symbolic execution subject method depth solver calls time m s mem mb composespfcomposespf compose spfsub method ctree tree init comp total init comp total invocations nodes bankaccountdeposit withdraw main rationalabs gcd simplify simp gcdrec rational simplify recursion gcdrec simplify wbsupdate main1 main2 launch aswmain1 main2 main0 main tcasmibc mobt moat mncbd mncbc altseptest starttcas apollomain4 main5 main6 main1 mainsymbolic swapnodeswapnode calltwice call3times heapopq r linkedlistadd repok call3times call5times add repok call3times call5times instruction s location and the choice it takes and to break the transitions that spf lumps together to introduce new points to which the tool can backtrack.
when building the summary tree the listener monitors whenever a new branchchoice is created and adds a normal node to the tree as a child to the current node.
when spf backtracks from the current branchchoice to the previous one in the search the current node in the tree is backtracked to its parent node too to keep the program states and tree nodes in sync.
evaluation for compositional symbolic execution.
we evaluated our approach on the following java artifacts bankaccount rational rationalrecursion wbs asw tcas apollo swapnode heapop and linkedlist .
all of these artifacts were used before for evaluating symbolic execution .
these subjects contain rich programming constructs such as complex non linear constraints recursion heap manipulating methods etc.
that are difficult to handle with symbolic execution.
the largest of these artifacts is apollo with .6kloc in 54classes .
the program contains complex non linear floating point constraints and it is quite challenging to analyze.
to symbolically execute aconfiguration with two iterations traditional spf takes more than hours to finish.
we are interested in evaluating our compositional approach on such complex examples to see whether it could improve the analysis time significantly.
we have conducted experiments on the subject programs using traditional non compositional symbolic execution spf and our compositional approach denoted here as compose .
for all subjects except rationalrecursion and linkedlist no pre specified search depth was needed.
the search depth for rationalrecursion and linkedlist is listed in table i. table i shows the results of our experiments using spf and compose.
we report the number of constraint solver calls the execution time the maximum memory mem used the number of invocations of sub methods that have already been analyzed and the number of nodes in compressed memoized tree using summary nodes ctree versus the number of nodes in non compressed tree tree .
for compose we show results for two steps init builds memoized summary trees for callee methods and comp reuses the summaries that are already built to composition639 639ally execute the target method.
total is the entire cost of compose to analyze a method.
the methods without init in table i are the methods that we analyzed first.
for these methods the number of constraint solver calls is the same for both spf and compose.
this is because building a tree without any existing tree to re use has similar cost to traditional symbolic execution besides the cost for building and maintaining the extra tree data structure.
we can see that for methods update inwbs main4 inapollo and add inlinkedlist building the summary took slightly longer than traditional spf due to this extra work.
we can see however that for the methods that re use the trees marked as comp the analysis incurs fewer constraint solver calls and significantly less time than traditional spf on most of the methods.
in some cases the saving can be very significant highlighted in bold in table i from simplify inrationalrecursion to mainsymbolic inapollo fewer solver calls and .1x main1 inwbs to .1x launch inwbs faster.
for apollo spf took about hours and minutes to finish while compose took less than minutes.
this result indicates that the benefits of compose become more pronounced for larger programs.
compose took slightly more number of solver calls than spf in a few methods when the number of solver calls saved in composition was less than the number of solver calls in building summaries such as method gcdinrational gcdrec inrationalrecursion and a few methods in tcas .
from the results on rationalrecursion and linkedlist it follows that as the state space to be analyzed becomes larger i.e.
by increasing the analysis depth the savings achieved by compose become more pronounced.
also naturally the more times sub methods are invoked the more repeated work is required so compositional approach gain more benefits.
this can be verified by comparison with the numbers of sub method invocations and the savings in table i. furthermore table i shows that for most methods execution compose uses either the same or less memory than traditional spf.
we note however that the maximum memory reported by spf may vary a lot due to the underlying garbage collection and thus this comparison is less illustrative.
evaluation for target oriented heuristics.
we use six subjects in table ii to evaluate the effectiveness of our proposed approach with respect to the two heuristics that are targetoriented.
for each subject we selected a subset of methods to seed an assertion error in different locations.
these locations are at the end of the first path last path and a random path that is neither first nor last in the method.
for each run there is only one assertion error in one method.
this experiment mimics scenarios where we are interested in a target located at different places in the program state space with various degrees of difficulty in locating it.
table ii shows the comparison for spf and the two heuristics h1 h2 .
the reported numbers include the cost for building summaries of callee methods.
the cases in which h1 and h2 outperform spf are highlighted.
in most cases if the error is not in the first path of a method our proposedtable ii ev aluation for target oriented heuristics subject methodtarget time s solver calls location spf h1 h2 spf h1 h2 bankaccountwithdraw1st .
.
.
rand .
.
.
last .
.
.
rationalgcd1st .
.
.
rand .
.
.
last .
.
.
simplify1st .
.
.
rand .
.
.
last .
.
.
wbs update1st .
.
.
rand .
.
.
last .
.
.
aswmain11st .
.
.
rand .
.
.
last .
.
.
main21st .
.
.
rand .
.
.
last .
.
.
tcasmncbc1st .
.
.
rand .
.
.
last .
.
.
mncbd1st .
.
.
rand .
.
.
last .
.
.
altsep test1st .
.
.
rand .
.
.
last .
.
.
apollomain41st .
.
.
rand .
.
.
last .
main51st .
.
.
rand .
.
.
last .
.
.
approaches are better than spf from .1x to .4x faster.
note that for bankaccount h2 is much faster than spf 100x .
this is due to the special structure of the program.
for few other cases where methods are small e.g.
first two methods intcas the overhead of building method summaries slows down our heuristics.
conversely if an assertion error is in the first path of a method spf took less time than h1 and h2.
this is expected since spf stops immediately after it explores the first path of a method while our proposed heuristics have the overhead of building method summary trees for various methods in the call graph.
furthermore we observe that h2 always took less or same time to find the error than h1.
this is because h2 is more aggressive in that it ignores more feasible error free paths than h1.
threats to validity.
the primary threats to external validity in this study involve the use of spf for our prototype implementation the selection of artifacts and the use of seeded assertion errors as targets.
we attempted to mitigate these threats by analyzing multiple artifacts most of which have been used in previous studies of symbolic execution based techniques and by seeding assertion errors at various locations in the program.
these threats can be further addressed by additional evaluation using a broader range of programs and targets.
the primary threat to internal validity is possible faults in the implementations of our algorithms and in spf.
we controlled for this threat by testing the implementations of the algorithms and spf on examples that could be manually verified.
where threats to construct validity are concerned the metrics we 640selected to evaluate our approach are commonly used to measure the cost of symbolic execution based techniques.
discussion.
our preliminary experiments indicate that compose has little or no benefit for small programs but the savings of compose become more pronounced when the analyzed state space is larger and for large programs such as apollo the savings achieved can be very significant.
furthermore the two target oriented heuristics are mostly effective when the target is not easy to find i.e.
it is not on the first path .
more experimentation is planned to further validate these conclusions in practice.
vi.
r elated work compositional symbolic execution has been addressed in .
the work in is the first to propose compositional techniques to improve a particular form of dynamic symbolic execution i.e.
symbolic execution performed along concrete paths .
this was extended in with a demand driven top down approach that uses execution trees similar to ours but it is not based on replay.
instead each method summary is represented as a first order logic formula with uninterpreted functions and the composition is performed entirely using smt solving.
a further extension employs both may and must summaries expressed with logical formulae.
none of these works address composition in the presence of heap operations for object oriented programming.
while in principle logical summaries could be computed for heap manipulating methods the difficulty comes when reusing the summaries one would need to reconstruct the heap according to the post condition to continue execution.
composition in the presence of heap operations is addressed in where summaries include both logical formulae and an explicit representation of input and output heaps.
the effects of the computation are stored so there is no need to replay symbolic execution.
however such advantage comes at a high price the summaries are large and the composition operation is complicated as it not only checks compatibility at the invocation point but also it synthesizes the new state with the new heap to continue with after the composition of each summary.
this work is based on constraint logic programming clp similar synthesis of the new heap would be very expensive in a general purpose tool such as spf.
we instead construct the new heap by re executing the code.
in a previous workshop paper we described a preliminary investigation of compositional symbolic execution for java bytecodes.
we used partial evaluation a well established technique that aims at automatically specializing a program with respect to some of its input to build method summaries consisting of several path specialized versions of the method code.
the obtained savings were not very impressive due to the expensive storing of multiple versions of the code.
we use a lighter weight approach here since the method summaries only encode the choices taken along each path.
this is sufficient for method replay.
compositional interprocedural analysis has been extensively studied with recent techniques focusing on handling heapoperations .
the compositional shape analysis from uses separation logic and assigns a collection of hoare triples to each procedure that is analyzed separately in bottom up fashion.
the triples provide an over approximation of data structure usage.
we provide an under approximation as is typical in symbolic execution and we do not use a logical encoding for our summaries.
the work in presents a bottom up summary based heap analysis that uses abstract points to graphs extended with constraints to encode heap summaries.
the work does not address computing summaries about shapes of data structures as in but guarantees a higher level of precision.
a recent related target oriented technique is presented in although it is done in the context of bounded model checking not symbolic execution and it performs weakest preconditions calculations instead of forward computations.
furthermore it does not handle heap operations but it is targeted towards the properties to check.
other target oriented symbolic execution techniques are presented in e.g.
.
a thorough empirical comparison with these techniques is future work.
in previous work we developed memoized symbolic execution memoise for the efficient re application of symbolic execution in different scenarios such as iterative deepening and regression analysis.
similar to the approach here memoise stores on disk the key elements of symbolic execution in a tree data structure and uses that tree during re execution.
however the approach is not compositional.
the technique that we present in this paper naturally extends this previous work enabling memoization and retrieval of trees at a finer granularity resulting in more efficient analysis.
vii.
c onclusion we presented a new approach for compositional symbolic execution.
the approach summarizes each analyzed method as a memoization tree that captures the crucial elements of symbolic execution and leverages these trees to efficiently replay the symbolic execution of the corresponding methods in different calling contexts.
our approach offers a natural way to compose in the presence of heap operations which cannot be dealt with by previous work that uses logical formulas as summaries for compositional symbolic execution.
we also presented two heuristics for the efficient treatment of error traces.
preliminary experimental evaluation based on implementation in symbolic pathfinder shows promising results.
we believe compositional analysis holds a key to scalable symbolic execution.
in future work we plan to evaluate our approach on larger programs as well as to further optimize our algorithms.
we also plan to incorporate loop invariants for the succinct summarization of looping methods.