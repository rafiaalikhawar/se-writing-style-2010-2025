synthesising interprocedural bit precise termination proofs hong yi chen cristina david daniel kroening peter schrammel and bj orn wachter department of computer science university of oxford first.lastname cs.ox.ac.uk abstract proving program termination is key to guaranteeing absence of undesirable behaviour such as hanging programs and even security vulnerabilities such as denial of service attacks.
to make termination checks scale to large systems interprocedural termination analysis seems essential which is a largely unexplored area of research in termination analysis where most effort has focussed on difficult single procedure problems.
we present a modular termination analysis for c programs using templatebased interprocedural summarisation.
our analysis combines a context sensitive over approximating forward analysis with the inference of under approximating preconditions for termination.
bit precise termination arguments are synthesised over lexicographic linear ranking function templates.
our experimental results show that our tool 2ls outperforms state of the art alternatives and demonstrate the clear advantage of interprocedural reasoning over monolithic analysis in terms of efficiency while retaining comparable precision.
i. i ntroduction termination bugs can compromise safety critical software systems by making them irresponsive e.g.
termination bugs can be exploited in denial of service attacks .
termination guarantees are therefore instrumental for software reliability.
termination provers static analysis tools that aim to construct a termination proof for a given input program have made tremendous progress.
they enable automatic proofs for complex loops that may require linear lexicographic e.g.
or non linear termination arguments e.g.
in a completely automatic way.
however there remain major practical challenges in analysing real world code.
first of all as observed by most approaches in the literature are specialised to linear arithmetic over unbounded mathematical integers.
although unbounded arithmetic may reflect the intuitively expected program behaviour the program actually executes over bounded machine integers.
the semantics of c allows unsigned integers to wrap around when they over underflow.
hence arithmetic on k bit wide unsigned integers must be performed modulo 2k.
according to the c standards over underflows of signed integers are undefined behaviour but practically also wrap around on most architectures.
thus accurate termination analysis requires a bit precise analysis of program semantics.
tools must be configurable with architectural specifications such as the width of data types and endianness.
the following examples illustrate that termination behaviour on machine integers can be completely different than on mathematical integers.
for example the following code void foo1 unsigned n ff o r unsigned x x n x gdoes terminate with mathematical integers but does notterminate with machine integers if nequals the largest unsigned integer.
on the other hand the following code void foo2 unsigned x fwhile x x g does not terminate with mathematical integers but terminates with machine integers because unsigned machine integers wrap around.
a second challenge is to make termination analysis scale to larger programs.
the yearly software verification competition sv comp includes a division in termination analysis which reflects a representative picture of the state of the art.
the sv comp termination benchmarks contain challenging termination problems on smaller programs with at most instructions average contained at most functions average and loops average .
in this paper we present a technique that we have successfully run on programs that are one magnitude larger containing up to instructions.
larger instances require different algorithmic techniques to scale e.g.
modular interprocedural analysis rather than monolithic analysis.
this poses several conceptual and practical challenges that do not arise in monolithic termination analysers.
for example when proving termination of a program a possible approach is to try to prove that all procedures in the program terminate universally i.e.
in any possible calling context.
however this criterion is too optimistic as termination of individual procedures often depends on the calling context i.e.
procedures terminate conditionally only in specific calling contexts.
hence an interprocedural analysis strategy is to verify universal program termination in a top down manner by proving termination of each procedure relative to its calling contexts and propagating upwards which calling contexts guarantee termination of the procedure.
it is too difficult to determine these contexts precisely analysers thus compute preconditions for termination.
a sufficient precondition identifies those prestates in which the procedure will definitely terminate and is thus suitable for proving termination.
by contrast a necessary precondition identifies the pre states in which the procedure may terminate.
its negation are those states in which the procedure will not terminate which is useful for proving nontermination.
in this paper we focus on the computation of sufficient preconditions.
preconditions enable information reuse and thus scalability as it is frequently possible to avoid repeated analysis of parts of the code base e.g.
libraries whose proceduresare called multiple times or did not undergo modifications between successive analysis runs.
contributions we propose an algorithm for interprocedural termination analysis .
the approach is based on a template based static analysis using sat solving.
it combines context sensitive summary based interprocedural analysis with the inference of preconditions for termination based on template abstractions.
we focus on non recursive programs which cover a large portion of software written especially in domains such as embedded systems.
we provide an implementation of the approach in 2ls a static analysis tool for c programs.
our instantiation of the algorithm uses template polyhedra and lexicographic linear ranking functions templates.
the analysis is bitprecise and purely relies on sat solving techniques.
we report the results of an experimental evaluation on procedural sv comp benchmarks with in total .
million lines of code that demonstrates the scalability and applicability of the approach to programs with thousands of lines of code.
ii.
p reliminaries in this section we introduce basic notions of interprocedural and termination analysis.
program model and notation.
we assume that programs are given in terms of acyclic1call graphs where individual procedures fare given in terms of symbolic input output transition systems.
formally the input output transition system of a procedure fis a triple initf trans f outf where trans f x x0 is the transition relation the input relation initf xin x defines the initial states of the transition system and relates them to the inputs xin the output relation outf x xout connects the transition system to the outputs xoutof the procedure.
inputs are procedure parameters global variables and memory objects that are read by f. outputs are return values and potential side effects such as global variables and memory objects written by f. internal states x are commonly the values of variables at the loop heads in f. these relations are given as first order logic formulae resulting from the logical encoding of the program semantics.
fig.
shows the encoding of the two procedures in fig.
into such formulae.2the inputsxinoffare z and the outputs xoutconsist of the return value denoted rf .
the transition relation ofhencodes the loop over the internal state variables x y .
we may need to introduce boolean variables gto model the control flow as shown in f. multiple and nested loops can be similarly encoded in trans .
note that we view these formulae as predicates e.g.
trans x x0 with given parameters x x0 and mean the substitution trans when we write trans a b .
1we consider non recursive programs with multiple procedures.
2c?a b is the conditional operator which returns aifcevaluates to true andbotherwise.1unsigned f unsigned z f unsigned w i f z w h z return w 5g1unsigned h unsigned y f unsigned x f o r x x x y return x 5g fig.
.
example.
init f z w0 z0 g0 w0 z0 z g0 trans f w z g w0 z0 g0 g h0 z w1 w0 z ?w1 w g0 out f w z g rf rf w g init h y x0 y0 x0 y0 y trans h x y x0 y0 x0 x y x y0 y out h x y rh rh x x fig.
.
encoding of example .
moreover we write xandxwith the understanding that the former is a vector whereas the latter is a scalar.
each call to a procedure hat call siteiin a procedure f is modeled by a placeholder predicate hi xpini xpouti occurring in the formula trans fforf.
the placeholder predicate ranges over intermediate variables representing its actual input and output parameters xpiniandxpouti respectively.
placeholder predicates evaluate to true which corresponds to havocking procedure calls.
in procedure fin fig.
the placeholder for the procedure call to hish0 z w1 with the actual input and output parameters zandw1 respectively.
a full description of the program encoding is given in the extended version of our paper .
basic concepts.
moving on to interprocedural analysis we introduce formal notation for the basic concepts below definition invariants summaries calling contexts .for a procedure given by init trans out we define aninvariant is a predicate invsuch that 8xin x x0 init xin x inv x inv x trans x x0 inv x0 given an invariant inv asummary is a predicate sum such that 8xin x x0 xout init xin x inv x0 out x0 xout sum xin xout given an invariant inv the calling context for a procedure call hat call site iin the given procedure is a predicate callctx hisuch that 8x x0 xpini xpouti inv x trans x x0 callctx hi xpini xpouti these concepts have the following roles invariants abstract the behaviour of loops.
summaries abstract the behaviour of called procedures they are used to strengthen the placeholder predicates.
calling contexts abstract the caller s behaviour w.r.t.
the procedure being called.
when analysing the callee the calling contexts are used to constrain its inputs and outputs.
in sec.
iii we will illustrate these notions on the program in fig.
.
since we want to reason about termination we need the notions of ranking functions and preconditions for termination.definition ranking function .aranking function for a procedure init trans out with invariant invis a function rfrom the set of program states to a well founded domain such that8x x0 inv x trans x x0 r x r x0 we denote by rr x x0 the constraints that guarantee that ris a ranking function.
the existence of a ranking function for a procedure guarantees its universal termination.
the weakest termination precondition for a procedure describes the inputs for which it terminates.
if it is true the procedure terminates universally if it is false then it does not terminate for any input.
since the weakest precondition is intractable to compute or even uncomputable we underapproximate the precondition.
a sufficient precondition for termination guarantees that the program terminates for all xin that satisfy it.
definition precondition for termination .given a procedure init trans out a sufficient precondition for termination is a predicate precond such that 9rr inv 8xin x x0 precond xin init xin x inv x inv x trans x x0 inv x0 rr x x0 note that false is always a trivial model for precond but not a very useful one.
iii.
o verview of the approach in this section we introduce the architecture of our interprocedural termination analysis.
our analysis combines in a nontrivial synergistic way the inference of invariants summaries calling contexts termination arguments and preconditions which have a concise characterisation in second order logic see definitions and .
at the lowest level our approach relies on a solver backend for second order problems which is described in sec.
v. to see how the different analysis components fit together we now go through the pseudo code of our termination analyser algorithm .
function analyze is given the entry procedurefentry of the program as argument and proceeds in two analysis phases.
phase one is an over approximate forward analysis given in subroutine analyzeforward which recursively descends into the call graph from the entry point fentry .
subroutine analyzeforward infers for each procedure call in fan overapproximating calling context callctxo using procedure summaries and other previously computed information.
before analyzing a callee the analysis checks if the callee has already been analysed and whether the stored summary can be reused i.e.
if it is compatible with the new calling context callctxo.
finally once summaries for all callees are available the analysis infers loop invariants and a summary for fitself which are stored for later re use by means of a join operator.
the second phase is an under approximate backward analysis subroutine analyzebackward which infers termination preconditions.
again we recursively descend into the call graph.
analogous to the forward analysis we infer for eachalgorithm analyze 1global sumso invso precondsu 2function analyzeforward f callctxo f foreach procedure call hinfdo callctxo h compcallctxo f callctxo f h ifneedtoreanalyzeo h callctxo h then analyzeforward h callctxo h joino sumso invso compinvsumo f callctxo f 8function analyzebackward f callctxu f termconds callctxu f foreach procedure call hinfdo callctxu h compcallctxu f callctxu f h ifneedtoreanalyzeu h callctxu h then analyzebackward h callctxu h termconds termconds precondsu 15joinu precondsu compprecondterm f invso termconds 16function analyze fentry analyzeforward fentry true analyzebackward fentry true return precondsu procedure call in fan under approximating calling context callctxu using under approximate summaries as described in sec.
iv and recurs only if necessary line .
finally we compute the under approximating precondition for termination line .
this precondition is inferred w.r.t.
the termination conditions that have been collected the backward calling context line the preconditions for termination of the callees line and the termination arguments for fitself see sec.
iv .
note that superscripts oanduin predicate symbols indicate over and underapproximation respectively.
challenges.
our algorithm uses over and underapproximation in a systematic way in order to address the challenging problem of finding meaningful preconditions by a context sensitive interprocedural termination analysis.
the precondition in definition admits the trivial solution false forprecond .
how do we find a good candidate?
to this end we bootstrap the process with a candidate precondition a single value of xin for which we compute a termination argument.
the key observation is that the resulting termination argument is typically more general i.e.
it shows termination for many further entry states.
the more general precondition is then computed by precondition inference w.r.t.
the termination argument.
a second challenge is to compute under approximations.
obviously the predicates in the definitions in sec.
ii can be over approximated by using abstract domains such as intervals.
however there are only few methods for underapproximating analysis.
in this work we use a method similar to to obtain under approximating preconditions w.r.t.
property p we infer an over approximating precondition w.r.t.
pand negate the result.
in our case pis the termination condition termconds .example .
we illustrate the algorithm on the simple example given as fig.
with the encoding in fig.
.
fcalls a procedure h. procedure hterminates if and only if its argument yis non zero i.e.
procedure fonly terminates conditionally.
the call of his guarded by the condition z which guarantees universal termination of procedure f. let us assume that unsigned integers are bits wide and we use an interval abstract domain for invariant summary and precondition inference but the abstract domain with the elementsftrue falsegfor computing calling contexts i.e.
we can prove that calls are unreachable.
we use m .
our algorithm proceeds as follows.
the first phase is analyzeforward which starts from the entry procedure f. by descending into the call graph we must compute an overapproximating calling context callctxo hfor procedure hfor which no calling context has been computed before.
this calling context is true.
hence we recursively analyse h. given thathdoes not contain any procedure calls we compute the over approximating summary sumo h y m rh m and invariant invo h x m y m .
now this information can be used in order to compute sumo f z m rf m and invariant invo f true for the entry procedure f. the backwards analysis starts again from the entry proceduref.
it computes an under approximating calling context callctxu hfor procedure h which is true before descending into the call graph.
it then computes an under approximating precondition for termination precondu h y m or more precisely an under approximating summary whose projection onto the input variables of his the precondition precondu h. by applying this summary at the call site of hinf we can now compute the precondition for termination precondu f z m off which proves universal termination of f. we illustrate the effect of the choice of the abstract domain on the analysis of the example program.
assume we replace theftrue falsegdomain by the interval domain.
in this case analyzeforward computes callctxo h z m w1 m .
the calling context is computed over the actual parameterszandw1.
it is renamed to the formal parameters y andrh the return value when callctxo his used for constraining the pre postconditions in the analysis of h. subsequently analyzebackward computes the precondition for termination ofhusing the union of all calling contexts in the program.
since hterminates unconditionally in these calling contexts we trivially obtain precondu h y m which in turn proves universal termination of f. iv.
i nterprocedural termination analysis we can view alg.
as solving a series of formulae in second order predicate logic with existentially quantified predicates for which we are seeking satisfiability witnesses.
in this section we state the constraints we solve including all the side constraints arising from the interprocedural analysis.
3to be precise we are not only looking for witness predicates but good approximations of weakest or strongest predicates.
finding such biased witnesses is a feature of our synthesis algorithms.algorithm analyze for universal termination 1global sumso invso termstatus 2function analyzeforward f callctxo f foreach procedure call hinfdo callctxo h compcallctxo f callctxo f h ifneedtoreanalyzeo h callctxo h then analyzeforward h callctxo h joino sumso invso compinvsumo f callctxo f 8function analyzebackward0 f termstatus comptermarg f foreach procedure call hinfdo ifneedtoreanalyzeu h callctxo h then analyzebackward0 h join termstatus termstatus 14function analyze fentry analyzeforward fentry true analyzebackward0 fentry return termstatus note that this is not a formalisation exercise but these are precisely the formulae solved by our synthesis backend which is described in section v. a. universal termination for didactical purposes we start with a simplification of algorithm that is able to show universal termination see algorithm .
this variant reduces the backward analysis to a call to comptermarg and propagating back the qualitative result obtained terminating potentially non terminating or non terminating .
this section states the constraints that are solved to compute the outcome of the functions underlined in algorithm and establish its soundness compcallctxo def.
compinvsumo def.
comptermarg lemma definition compcallctxo .a forward calling context callctxo hiforhiin procedure fin calling context callctxo f is a satisfiability witness of the following formula 9callctxo hi invo f 8xin x x0 xout xpini xpouti callctxo f xin xout summso f initf xin x invo f x invo f x trans f x x0 invo f x0 ghi callctxo hi xpini xpouti with summso f v callshjinfghj sumso xpinj xpoutj whereghjis the guard condition of procedure call hjin fcapturing the branch conditions from conditionals.
for example gh0of the procedure call to hinfin fig.
is z .sumso is the currently available summary for h cf.
global variables in alg.
.lemma .
callctxo hiis over approximating.
proof sketch.
callctxo fwhenfis the entry point procedure istrue also the summaries sumo hjare initially assumed to betrue i.e.
over approximating.
hence given that callctxo f andsummso fare over approximating callctxo hiis overapproximating by the soundness of the synthesis see thm.
in sec.
v .
example .
let us consider procedure fin fig.
.
fis the entry procedure hence we have callctxo f z rf true z m rf m wherem 1when using the interval abstract domain for bit integers .
then we instantiate def.
for procedure f to compute callctxo h0.
we assume that we have not yet computed a summary for h thus sumo histrue.
remember that the placeholder h0 z w1 evaluates to true.
9callctxo h0 invo f 8z w w w0 z0 g g0 rf z m rf m z true w z0 z g invo f w z g invo f w z g g h0 z w1 w0 z ?w1 w z0 z g0 invo f w0 z0 g0 z callctxo hi z w1 a solution is invo f true and callctxo h0 z w1 z m w1 m .
definition compinvsumo .a forward summary sumo fand invariants invo ffor procedure fin calling context callctxo f are satisfiability witnesses of the following formula 9sumo f invo f 8xin x x0 x00 xout callctxo f xin xout summso f initf xin x invo f x00 outf x00 xout invo f x sumo f xin xout invo f x trans f x x0 invo f x0 lemma .
sumo fandinvo fare over approximating.
proof sketch.
by lemma callctxo fis over approximating.
also the summaries sumso fare initially assumed to be true i.e.
over approximating.
hence given that callctxo fand summso fare over approximating sumo fandinvo fare overapproximating by the soundness of the synthesis thm.
.
example .
let us consider procedure hin fig.
.
we have computed callctxo h0 y rh y m rh m with actual parameters renamed to formal ones .
then we need to obtain witnesses invo h0andsumo h0to the satifiability of the instantiation of def.
for procedure h as given below.
9invo h0 sumo h0 8y x x0 y0 x00 y00 rf y m rh m true x y0 y invo h x00 y00 rh x00 x00 invo h x y0 sumo h y rh invo h x y x0 x y x y y0 invo h x0 y0 a solution is invo h0 x m y m andsumo h0 y m rh m for instance.remark .
since def.
and def.
are interdependent we can compute them iteratively until a fixed point is reached in order to improve the precision of calling contexts invariants and summaries.
however for efficiency reasons we perform only the first iteration of this greatest fixed point computation.
lemma comptermarg .a procedure fwith forward invariants invo fterminates if there is a termination argument rrf 9rrf 8x x0 invo f x trans f x x0 summso f assertions f x rrf x x0 assertions in this formula correspond to assert statements in the code.
they can be assumed to hold because assertion violating traces terminate.
over approximating forward information may lead to inclusion of spurious nonterminating traces.
for that reason we might not find a termination argument although the procedure is terminating.
as we essentially under approximate the set of terminating procedures we will not give false positives.
regarding the solving algorithm for this formula we refer to sec.
v. example .
let us consider function hin fig.
.
assume we have the invariant x m y m. thus we have to solve 9rrh x m y m x0 x y x y0 y true true rrh x y x0 y0 when using a linear ranking function template c1 x c2 y we obtain as solution for example rrh x x0 .
if there is no trace from procedure entry to exit then we can prove non termination even when using over approximations lemma line of analyze .a procedure fin forward calling context callctxo f and forward invariants invo fnever terminates if its summary sumo fisfalse .
termination information is then propagated in the acyclic call graph join in line in algorithm proposition .
a procedure fis declared non terminating if it is non terminating by lemma .
terminating if a all its procedure calls hithat are potentially reachable i.e.
with callctxo hi6 false are declared terminating and b fitself is terminating according to lemma potentially non terminating otherwise.
our implementation is more efficient than algorithm because it avoids computing a termination argument for fif one of its callees is potentially non terminating.
theorem .
if the entry procedure of a program is declared terminating then the program terminates universally.
if the entry procedure of a program is declared non terminating then the program never terminates.
proof sketch.
by induction over the acyclic call graph using prop.
.algorithm compprecondterm input procedurefwith invariant inv additional termination conditions termconds output precondition precond precond p false true 2let init xin x inv x 3while true do p precond xin solve forxin x x0 ifunsat then return precond else let inbe a model of letinv0 compinv f xin in letrr comptermarg f inv0 ifrr true thenp p xin6 in else let termconds rr letprecond0 compnecprecond f precond precond precond0 b. preconditions for termination before introducing conditional termination we have to talk about preconditions for termination.
if a procedure terminates conditionally like procedure hin fig.
comptermarg lemma will not be able to find a satisfying predicate rr.
however we would like to know under which preconditions i.e.
values of yin above example the procedure terminates.
we can state this problem as defined in def.
.
in algorithm we search for precond inv andrrin an interleaved manner.
note that false is a trivial solution for precond we thus have to aim at finding a good under approximation of the maximal solution weakest precondition for precond .
we bootstrap the process by assuming precond false and search for values of xin line .
if such a value in exists we can compute an invariant under the precondition candidatexin in line and use lemma to search for the corresponding termination argument line .
if we fail to find a termination argument rr true we block the precondition candidate line and restart the bootstrapping process.
otherwise the algorithm returns a termination argument rr that is valid for the concrete value inofxin.
now we need to find a sufficiently weak precond for whichrr guarantees termination.
to this end we compute an over approximating precondition for those inputs for which we cannot guarantee termination in line which includes additional termination conditions coming from the backward calling context and preconditions of procedure calls see sec.
iv c .
the negation of this precondition is an underapproximation of those inputs for which fterminates.
finally we add this negated precondition to our precond line before we start over the bootstrapping process to find precondition candidates outside the current precondition precond for which we might be able to guarantee termination.
example .
let us consider again function hin fig.
.
thistime we will assume we have the invariant x m with m .
we bootstrap by assuming precond false and searching for values of ysatisfying true false x x m. one possibility is y .
we then compute the invariant under the precondition y and getx .
obviously we cannot find a termination argument in this case.
hence we start over and search for values of ysatisfying y6 false x x m. this formula is for instance satisfied by y .
this time we get the invariant x and the ranking function x. thus we have to solve 9e p y e x m x0 x y x x x0 to compute an over approximating precondition over the templatep for details on templates see section v .
in this case p y e turns out to be y therefore its negation y6 is the precond that we get.
finally we have to check for further precondition candidates but y6 y6 x x mis obviously unsat.
hence we return the sufficient precondition for termination y6 .
c. conditional termination we now extend the formalisation to algorithm which additionally requires the computation of under approximating calling contexts and sufficient preconditions for termination procedure compprecondterm see alg.
.
first compprecondterm computes in line an overapproximating invariant invo fpentailed by the candidate precondition.
invo fpis computed through def.
by conjoining the candidate precondition to the antecedent.
then line computes the corresponding termination argument rrfby applying lemma using invo fpinstead of invo f. since the termination argument is under approximating we are sure that fterminates for this candidate precondition if rrf6 true.
then in line of compprecondterm we compute underapproximating sufficient preconditions for traces satisfying the termination argument rr via over approximating the traces violating rr.
now we are left to specify the formulae corresponding to the following functions compcallctxu def.
compnecprecond def.
we use the superscript uto indicate negations of underapproximating information.
we compute under approximating calling contexts as follows definition compcallctxu .the backward calling context callctxu hifor procedure call hiin procedure fin backward calling context callctxu fand forward invariants invo fis callctxu hi callctx u hi the negation of a satisfiabilitywitnesses for 9callctx u hi inv u f 8xin x x0 xpini xpouti xout callctxu f xin xout invo f x summso f summs u f assertions f x out x xout inv u f x inv u f x0 trans x x0 inv u f x ghi callctx u hi xpin xpout withsumms u f v callshjinfghj sumu xpinj xpoutj lemma .
callctxu hiis under approximating.
proof sketch.
the computation is based on the negation of the under approximating calling context of fand the negated under approximating summaries for the function calls in f. by thm.
this leads to an over approximation of the negation of the calling context for hi.
example .
let us assume that in procedure fin fig.
we have callctxu f z rf rf m i.e.fis called in a context where a return value of less than would cause non termination of the caller.
then we instantiate def.
for procedure f to compute callctxu h0.
we assume that we have already computed the over approximating summary sumo h0 z m w1 m but not yet computed an under approximating summary for h thus sumu hisfalse .
9callctx u h0 inv u f 8z w w w0 z0 g g0 rf rf true z z m w1 m z true true rf w g inv u f w z g inv u f w z g g h0 z w1 w0 z ?w1 w z0 z g0 inv u f w0 z0 g0 z callctx u hi z w1 a solution is inv u f true and callctx u h0 z m w1 i.e.
callctxu h0 z 0 11 w1 m .
definition line of compprecondterm .a precondition for termination precondu fin backward calling context callctxu fand with forward invariants invo fisprecondu f precond u f i.e.
the negation of a satisfiability witness precond u ffor 9precond u hi inv u f sum u f 8xin x x0 x00 xout callctxu f xin xout invo f x summso f summs u f assertions f x init xin x00 inv u f x00 out x xout inv u f x sum u f xin xout precond u f xin rr f x x0 preconds u f callctxu f xin xout init xin x out x0 xout inv u f x0 trans x x0 inv u f x withpreconds u f w callshjinfghj precondu xpinj xpoutj this formula is similar to def.
but w.r.t.
backward calling contexts and summaries and strengthened by the forward invariants invo f. we denote the negation of the witnesses found for the summary and the invariant by sumu f sum u fand invu f inv u f respectively.
lemma .
precondu f sumu fand invu fare underapproximating.
proof sketch.
we compute an over approximation of the negation of the precondition w.r.t.
the negation of the under approximating termination argument and the negation of further under approximating information backward calling context preconditions of procedure calls by the soundness of the synthesis see thm.
in sec.
v this over approximates the non terminating traces and hence under approximates the terminating ones.
hence the precondition is a sufficient precondition for termination.
the term rrf x x0 preconds u f callctxu f xin xout init xin x out x0 xout characterises non terminating states in the invariants of f for these either the termination argument for fis not satisfied or the precondition for termination of one of the callees does not hold or we are outside the calling context.
example .
we will instantiate def.
for procedure h in fig.
assuming that we have callctxu h y rh y 0 11 rh m as computed in the previous example.
invo h true andhdoes not have any procedure calls thus summso h true summs u h true and preconds u h false .
assume we have the termination argument candidate rrh x x0 .
the second conjunct in the consequent of the top level implication is satisfied either for y 0making rrhtrue or y 10violating the calling context third disjunct .
hence a solution is precond u h y inv u h x y and sum u h y rh .
i.e.
a sufficient precondition for termination is precondu h y m .
theorem .
a procedure fterminates for all values of xin satisfying precondu f. proof sketch.
by induction over the acyclic call graph using lemmae and .
d. context sensitive summaries the key idea of interprocedural analysis is to avoid reanalysing procedures that are called multiple times.
for that reason algorithm first checks whether it can re use already computed information.
for that purpose summaries are stored as implications callctxo sumo.
as the call graph is traversed the possible calling contexts callctxo hifor a procedurehare collected over the call sites i.needtoreanalyzeo line in alg.
checks whether the current calling contextcallctxo hiis subsumed by calling contextsw icallctxo hithat we have already encountered and if so sumso is reused otherwise it needs to be recomputed and joined conjunctively with previously inferred summaries.
the same considerations apply to invariants termination arguments and preconditions.
v. t emplate based static analysis in this section we give a brief overview of our synthesis engine which serves as a backend for our approach it solves the formulae in definitions and see sec.
iv .
our synthesis engine employs template based static analysis to compute ranking functions invariants summaries and calling contexts i.e.
implementations of functions compinvsumoandcompcallctxofrom the second order constraints defined in sec.
iv.
to be able to effectively solve second order problems we reduce them to first order by restricting the space of solutions to expressions of the form t x d where dare parameters to be instantiated with concrete values andxare the program variables.
tis a template that gives a blueprint for the shape of the formulas to be computed.
choosing a template is analogous to choosing an abstract domain in abstract interpretation.
to allow for a flexible choice we consider template polyhedra .
we state here a soundness result theorem .
any satisfiability witness dof the reduction of the second order constraint for invariants in def.
using templatet 9d 8xin x x0 init xin x t x d t x d trans x x0 t x0 d satisfies8x inv x t x d i.e.t x d is a sound over approximating invariant.
similar soundness results hold true for summaries and calling contexts.
this ultimately follows from the soundness of abstract interpretation .
similar approaches have been described for instance by .
however these methods consider programs over mathematical integers.
ranking functions require specialised synthesis techniques.
to achieve both expressiveness and efficiency we generate linear lexicographic functions .
our ranking function synthesis approach is similar to the tan tool but extends the approach from monolithic to lexicographic ranking functions.
further unlike tan our synthesis engine is much more versatile and configurable e.g.
it also produces summaries and invariants.
due to space limitations we refer to the extended version which includes a detailed description of the synthesis engine our program encoding encoding of bit precise arithmetic and tailored second order solving techniques for the different constraints that occur in our analysis.
in the following section we discuss the implementation.vi.
i mplementation we have implemented the algorithm in 2ls a static analysis tool for c programs built on the cprover framework using minisat .
.
as back end solver.
other sat and smt solvers with incremental solving support would also be applicable.
our approach enables us to use a single solver instance per procedure to solve a series of second order queries as required by alg.
.
this is essential as our synthesis algorithms make thousands of solver calls.
architectural settings e.g.
bitwidths can be provided on the command line.
discussions about technical issues w.r.t.
bit preciseness and the computation of intraprocedural termination arguments can be found in the extended version .
vii.
e xperiments we performed experiments to support the following claims interprocedural termination analysis ipta is faster than monolithic termination analysis mta .
the precision of ipta is comparable to mta.
2ls outperforms existing termination analysis tools.
2ls s analysis is bit precise.
2ls computes usable preconditions for termination.
we used the product line benchmarks of the benchmark repository.
in contrast to other categories this benchmark set contains programs with non trivial procedural structure.
this benchmark set contains programs with to lines of code on average to procedures on average and to loops .
on average .
of these benchmarks terminate universally whereas never terminate.
the experiments were run on a xeon x5667 at ghz running fedora with bit binaries.
memory and cpu time were restricted to gb and seconds per benchmark respectively using .
using 2ls with interval templates was sufficient to obtain reasonable precision.
modular termination analysis is fast we compared ipta with mta all procedures inlined .
table i shows that ipta times out on .
of the benchmarks vs. .
for mta.
the geometric mean speed up of ipta w.r.t.
mta on the benchmarks correctly solved by both approaches is .
.
in order to investigate how the m timeout affects mta we randomly selected benchmarks that timed out for m and re ran them finished in m after more than h did not finish within h. modular termination analysis is precise again we compare ipta with mta.
table i shows that ipta proves of the terminating benchmarks whereas only were proven by mta.
mta can prove all never terminating benchmarks including benchmarks where ipta times out.
mta times out on the benchmarks that cause additional potentially non terminating outcomes for ipta.
2ls outperforms existing termination analysis tools we compared 2ls with two termination tools for c programs from 4measured using cloc .
.table i tool comparison see text .2ls ipta 2ls mta tan ultimate terminating non terminating potentially non term.
timed out errors total run time h .
.
.
.
the sv comp termination competition namely tan and ultimate .
unfortunately the tools and have limitations regarding the subset of c that they can handle that make them unable to analyze any of the benchmarks out of the box.
we describe these limitations in the experiments log in .
unfortunately we did not succeed to generate the correct input files in the intermediate formats required by t2 and kittel using the recommended frontends and .
tan and kittel koat support bit precise c semantics.
ultimate uses mathematical integer reasoning but tries to ensure conformance with bit vector semantics.
also ultimate uses a semantic decomposition of the program to make its analysis efficient.
for each of the tools table i lists the number of instances solved timed out or aborted because of an internal error.
we also give the total run time which shows that analysis times are roughly halved by the modular interprocedural approaches 2ls ipta ultimate in comparison with the monolithic approaches 2ls mta tan .
ultimate spends less time on those benchmarks that it can prove terminating however these are only of the terminating benchmarks vs. for 2ls .
if ultimate could solve those benchmarks on which it fails due to unsupported features of c we would expect its performance to be comparable to 2ls.
ultimate and 2ls have different capabilities regarding nontermination.
2ls can show that a program never terminates for all inputs whereas ultimate can show that there exists a potentially non terminating execution.
to make the comparison fair we counted benchmarks flagged as potentially non terminating by ultimate but which are actually never terminating in the non terminating category in table i marked .
2ls s analysis is bit precise we compared 2ls with loopus on a collection of benchmarks abc ex01.c to abc ex15.c taken from the loopus benchmark suite .
while they are short between and loc the main characteristic of these programs is the fact that they exhibit different terminating behaviours for mathematical integers and bit vectors.
for illustration abc ex15.c terminates with mathematical integers but not with machine integers if for instance mequals int max .
next we summarise1void ex15 i n t m i n t n i n t p i n t q f f o r i n t i n i i i f o r i n t j j m j j f o r i n t k i k p k k f o r i n t l q l j l l 7g fig.
.
example abc ex15.c from the loopus benchmarks.
1void c r e a t e b a c k s t r u c t sdl surface b a c k s u r f 2f s t r u c t sdl rect pos s t r u c t sdl surface img images image f o r i n t x !
s b a c k s u r f h s img h f f o r i n t y !
y b a c k s u r f w y img w f pos .
x s i g n e d s h o r t i n t x pos .
y s i g n e d s h o r t i n t y sdl upperblit img null b a c k s u r f pos .
.
.
12g g g fig.
.
example createback from debian package abe.
the results of our experiments on these benchmarks when considering machine integers only of the programs terminate and are correctly identified by both 2ls and loopus.
for the rest of non terminating programs loopus claims they terminate whereas 2ls correctly classifies as potentially non terminating including abc ex15.c in fig.
and times out on .
2ls computes usable preconditions for termination this experiment was performed on benchmarks extracted from debian packages and the linear algebra library clapack.
the quality of preconditions i.e.
usability or ability to help the developer to spot problems in the code is difficult to quantify.
we give several examples where functions terminate conditionally.
the abe package of debian contains a function given as fig.
where increments of the iteration in a loop are not constant but dynamically depend on the dimensions of an image data structure.
here 2ls infers the precondition img!h img!w .
the example in fig.
is taken from the benchmark basename in the busybox category of svcomp which contains simplified versions of debian packages.
the termination of function full write depends on the return value of its callee function safe write .
here 2ls infers the calling context cc i.e.
the contract for the function safe write such that the termination of full write is guaranteed.
given a proof that safe write terminates and returns a strictly positive value regardless of the arguments it is called with we can conclude that full write terminates universally.
the program in fig.
is a code snippet taken from the summation procedure sasum within the c version of the popular lapack linear algebra library.
the loop in procedure fdoes not terminate if incx .
ifincx incx the termination argument is that iincreases decreases .
therefore incx6 is a termination precondition for f.1s i g n e d long i n t f u l l w r i t e s i g n e d i n t fd c o n s t void buf unsigned long i n t len unsigned long i n t cc f s i g n e d long i n t t o t a l s i g n e d long i n t f o r !
l e n u l l e n l e n unsigned long i n t cc f cc s a f e w r i t e fd buf l e n i f cc l f i f !
t o t a l l return t o t a l return cc 12g t o t a l t o t a l cc buf c o n s t void c o n s t char buf cc 15g g fig.
.
example from svcomp busybox .
1i n t f i n t sx i n t n i n t i n c x f i n t n i n c x n i n c x i n t stemp f o r i n t i incx ?
i n i n c x i n i n c x i i n c x f stemp sx 7g return stemp 9g fig.
.
non unit increment from clapack .
viii.
l imitations related works and future directions our approach makes significant progress towards analysing real world software advancing the state of the art of termination analysis of large programs.
conceptually we decompose the analysis into a sequence of well defined second order predicate logic formulae with existentially quantified predicates.
in addition to we consider context sensitive analysis underapproximate backwards analysis and make the interaction with termination analysis explicit.
notably these seemingly tedious formulae are actually solved by our generic templatebased synthesis algorithm making it an efficient alternative to predicate abstraction.
an important aspect of our analysis is that it is bit precise.
as opposed to the synthesis of termination arguments for linear programs over integers rationals this subclass of termination analyses is substantially less covered.
while present methods based on a reduction to presburger arithmetic and a template matching approach for predefined classes of ranking functions based on reduction to sat and qbf solving only compute intraprocedural termination arguments.
there are still a number of limitations to be addressed all of which connect to open challenges subject to active research.
while some are orthogonal e.g.
data structures strings refinement to our interprocedural analysis framework others recursion necessary preconditions require extensions of it.
in this section we discuss related work as well as characteristics and limitations of our analysis and future directions cost analysis and concurrency .
dynamically allocated data structures we currently ignore heap allocated data.
this limitation could be lifted byusing specific abstract domains.
for illustration let us consider the following example traversing a singly linked list.
l i s t x while x !
null fx x n e x t g deciding the termination of such a program requires knowledge about the shape of the data structure pointed by x namely the program only terminates if the list is acyclic.
thus we would require an abstract domain capable of capturing such a property and also relate the shape of the data structure to its length.
similar to we could use in order to abstract heap manipulating programs to arithmetic ones.
another option is using an abstract interpretation based on separation logic formulae which tracks the depths of pieces of heaps similarly to .
strings and arrays similar to dynamic data structures handling strings and arrays requires specific abstract domains.
string abstractions that reduce null terminated strings to integers indices length and size are usually sufficient in many practical cases scenarios where termination is dependent on the content of arrays are much harder and would require quantified invariants .
note that it is favorable to run a safety checker before the termination checker.
the latter can assume that assertions for buffer overflow checks hold which strengthens invariants and makes termination proofs easier.
recursion we currently use downward fixed point iterations for computing calling contexts and invariants that involve summaries see remark .
this is cheap but gives only imprecise results in the presence of recursion which would impair the termination analysis.
we could handle recursions by detecting cycles in the call graph and switching to an upward iteration scheme in such situations.
moreover an adaptation regarding the generation of the ranking function templates is necessary.
an alternative approach would be to make use of the theoretic framework presented in for verifying total correctness and liveness properties of while programs with recursion.
template refinement we currently use interval templates together with heuristics for selecting the variables that should be taken into consideration.
this is often sufficient in practice but it does not exploit the full power of the machinery in place.
while counterexample guided abstraction refinement cegar techniques are prevalent in predicate abstraction attempts to use them in abstract interpretation are rare .
we consider our template based abstract interpretation that automatically synthesises abstract transformers more amenable to refinement techniques than classical abstract interpretations where abstract transformers are implemented manually.
sufficient preconditions to termination conditional termination has recently attracted increased interest .
in this paper we compute sufficient preconditions i.e.
under approximating preconditions to termination via computing over approximating preconditions to potential non termination.
the same concept is used by other works .
however they consider only a single procedure and do not leverage their results to perform interproceduralanalysis on large benchmarks which adds in particular the additional challenge of propagating under approximating information up to the entry procedure e.g.
.
moreover by contrast to cook et al who use an heuristic f inite operator left unspecified for bootstrapping their preconditions our bootstrapping is systematic through constraint solving.
we could compute necessary preconditions by computing over approximating preconditions to potential termination and negating the result .
however this requires a method for proving that there exist non terminating executions which is a well explored topic.
while dynamically enumerate lasso shaped candidate paths for counterexamples and then statically prove their feasibility prove nontermination via reduction to safety proving and uses bi abduction to construct summaries of terminating and non terminating behaviors for each method.
in order to prove both termination and non termination compose several program analyses termination provers for multi path loops non termination provers for cycles and safety provers .
cost analysis a potential future application for our work is cost and resource analysis.
instances of this type of analyses are the worst case execution time wcet analysis as well as bound and amortised complexity analysis .
the control flow refinement approach instruments a program with counters and uses progress invariants to compute worst case or average case bounds.
concurrency our current analysis handles single threaded c programs.
one way of extending the analysis to multithreaded programs is using the rely guarantee technique which is proposed in and explored in several works for termination analysis.
in our setting the predicates for environment assumptions can be used in a similar way as invariants and summaries are used in the analysis of sequential programs.
ix.
c onclusions while many termination provers mainly target small hard programs the termination analysis of larger code bases has received little attention.
we present an algorithm for interprocedural termination analysis for non recursive programs.
to our knowledge this is the first paper that describes in full detail the entire machinery necessary to perform such an analysis.
our approach relies on a bit precise static analysis combining smt solving template polyhedra and lexicographic linear ranking function templates.
we provide an implementation of the approach in the static analysis tool 2ls and demonstrate the applicability of the approach to programs with thousands of lines of code.