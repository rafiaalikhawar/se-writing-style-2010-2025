when and why your code starts to smell bad michele tufano fabio palombay gabriele bavotaz rocco olivetox massimiliano di pentaz andrea de luciay denys poshyvanyk the college of william and mary williamsburg v a usa yuniversity of salerno fisciano sa italy zuniversity of sannio benevento italy xuniversity of molise pesche is italy abstract in past and recent years the issues related to managing technical debt received significant attention by researchers from both industry and academia.
there are several factors that contribute to technical debt.
one of these is represented by code bad smells i.e.
symptoms of poor design and implementation choices.
while the repercussions of smells on code quality have been empirically assessed there is still only anecdotal evidence onwhen and why bad smells are introduced.
to fill this gap we conducted a large empirical study over the change history of open source projects from different software ecosystems and investigated when bad smells are introduced by developers and the circumstances and reasons behind their introduction.
our study required the development of a strategy to identify smellintroducing commits the mining of over .5m commits and the manual analysis of of them i.e.
those identified as smellintroducing .
our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks.
in the light of our results we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.
i. i ntroduction technical debt is a metaphor introduced by cunningham to indicate not quite right code which we postpone making it right .
the metaphor explains well the trade offs between delivering the most appropriate but still immature product in the shortest time possible .
while the repercussions of technical debt on software quality have been empirically proven there is still a lack of empirical evidence related to how when and why various forms of technical debt occur in software projects .
this represents an obstacle for an effective and efficient management of technical debt.
bad code smells shortly code smells or smells i.e.
symptoms of poor design and implementation choices represent one important factor contributing to technical debt and possibly affecting the maintainability of a software system .
in the past and most notably in recent years several studies investigated the relevance that code smells have for developers the extent to which code smells tend to remain in a software system for long periods of time as well as the side effects of code smells such as increase in change and fault proneness or decrease of software understandability and maintainability .
the research community has been also actively developing approaches and tools for detecting smells and whenever possible triggering refactoring operations.
such tools rely on different types of analysis techniques such as constraint based reasoning over metric values static code analysis or analysis of software changes .
while these tools provide relatively accurate and complete identification of a wide variety of smells most of them work by taking a snapshot of the system or by looking at recent changes hence providing a snapshot based recommendation to the developer.
hence they do not consider the circumstances that could have caused the smell introduction.
in order to better support developers in planning actions to improve design and source code quality it is imperative to have a contextualized understanding of the circumstances under which particular smells occur.
however to the best of our knowledge there is no comprehensive empirical investigation into when and why code smells are introduced in software projects.
common wisdom suggests that urgent maintenance activities and pressure to deliver features while prioritizing time to market over code quality are often the causes of such smells.
generally speaking software evolution has always been considered as one of the reasons behind software aging or increasing complexity .
broadly speaking smells can also manifest themselves not only in the source code but also in software lexicons and can even affect other types of artifacts such as spreadsheets or test cases .
in this paper we fill the void in terms of our understanding of code smells reporting the results of a large scale empirical study conducted on the evolution history of open source projects belonging to three software ecosystems namely android apache and eclipse.
the study aimed at investigating i when smells are introduced in software projects and ii why they are introduced i.e.
under what circumstances smell introductions occur and who are the developers responsible for introducing smells.
to address these research questions we developed a metric based methodology for analyzing the evolution of code entities in change histories of software projects to determine when code smells start manifesting themselves and whether this happens suddenly i.e.
because of a pressure to quickly introduce a change or gradually i.e.
because of medium to long range design decisions .
we mined over .5m commits and we manually analyzed of them classified as smell introducing .
we are unaware of any published technical debt in general and code smell study in particular of comparable size.
the results achieved allowed us to report quantitative and qualitative evidence on when and why smells are introduced in software projects as well as implications of these results often contradicting common wisdom.
1table i characteristics of ecosystems under analysis ecosystem proj.
classes kloc commits issuesmean story min max length story length apache android eclipse overall ii.
s tudy design the goal of the study is to analyze change history of software projects with the purpose of investigating when code smells are introduced by developers and the circumstances and reasons behind smell appearances.
more specifically the study aims at addressing the following two research questions rq when are code smells introduced?
this research question aims at investigating to what extent the common wisdom suggesting that code smells are introduced as a consequence of continuous maintenance and evolution activities applies.
specifically we study when code smells are introduced in software systems to understand whether smells are introduced as soon as a code entity is created whether smells are suddenly introduced in the context of specific maintenance activities or whether instead smells appear gradually during software evolution.
to this aim we investigated the presence of possible trends in the history of code artifacts that characterize the introduction of specific types of smells.
rq why are code smells introduced?
the second research question aims at empirically investigating under which circumstances developers are more prone to introducing code smells.
we focus on factors that are indicated as possible causes for code smell introduction in the existing literature the commit goal e.g.
is the developer implementing a new feature or fixing a bug?
the project status e.g.
is the change performed in proximity to a major release deadline?
and the developer status e.g.
is the developer a newcomer or a senior project member?
.
a. context selection the context of the study consists of the change history of projects belonging to three software ecosystems namely android apache and eclipse.
table i reports for each of them i the number of projects analyzed ii size ranges in terms of the number of classes and kloc iii the overall number of commits and issues analyzed and iv the average minimum and maximum length of the projects story in years analyzed in each ecosystem.
all the analyzed projects are hosted in git repositories and have associated issue trackers.
the android ecosystem contains a random selection of open source apps mined from the f droid1forge.
the apache ecosystem consists of java projects randomly selected among those available2.
finally the eclipse ecosystem consists of projects randomly mined from the list of github repositories managed by the eclipse foundation3.
the choice of the ecosystems to analyze not random but rather driven by the motivation to consider projects having i different sizes e.g.
android apps are by their nature smaller than projects in apache s and eclipse s ecosystems ii different architectures e.g.
we have android mobile apps apache libraries and plug in based architectures in eclipse projects and iii different development bases e.g.
android apps are often developed by small teams whereas several apache projects are carried out by dozens of developers .
also we limited our study to projects since as it will be shown later the analysis we carried out is not only computationally expensive but also requires manual analysis of thousands of data points.
to sum up we mined commits and issues.
we focus our study on the following types of smells blob class a large class with different responsibilities that monopolizes most of the system s processing .
class data should be private a class exposing its attributes violating the information hiding principle .
complex class a class having a high cyclomatic complexity .
functional decomposition a class where inheritance and polymorphism are poorly used declaring many private fields and implementing few methods .
spaghetti code a class without structure that declares long methods without parameters .
while several other smells exist in literature we needed to limit our analysis to a subset due to computational constraints.
however we carefully kept a mix of smells related to complex large code components e.g.
blob class complex class as well as smells related to the lack of adoption of good object oriented coding practices e.g.
class data should be private functional decomposition .
thus the smells considered are representative of categories of smells investigated in previous studies see section v .
b. data extraction and analysis this subsection describes the data extraction and analysis process that we followed to answer our research questions.
when are code smells introduced?
to answer rq 1we firstly cloned the gitrepositories.
then we analyzed each repository riusing a tool that we developed named ashistoryminer with the purpose of identifying smellintroducing commits.
our tool mines the entire change history ofri checks out each commit in chronological order and runs an implementation of the decor smell detector based on the original rules defined by moha et al.
.
decor identifies smells using detection rules based on the values of internal quality metrics4.
the choice of using decor was driven by the fact that i it is a state of the art smell detector having a high accuracy in detecting smells and ii it applies simple detection rules that allow it to be very efficient.
note that we ran decor on all source code files contained in ri only for the first commit of ri.
in the subsequent commits 4an example of detection rule exploited to identify blob classes can be found at 2table ii quality metrics measured in the context of rq1 metric description lines of code loc the number of lines of code excluding white spaces and comments weighted methods per class wmc the complexity of a class as the sum of the mccabes cyclomatic complexity of its methods response for a class rfc the number of distinct methods and constructors invoked by a class coupling between object cbo the number of classes to which a class is coupled lack of cohesion of methods lcom the higher the pairs of methods in a class sharing at least a field the higher its cohesion number of attributes noa the number of attributes in a class number of methods nom the number of methods in a class decor has been executed only on code files added and modified in each specific commit to save computational time.
as an output our tool produces for each source code file fj2rithe list of commits in which fjhas been involved specifying if fjhas been added deleted or modified and if fjwas affected in that specific commit by one of the five considered smells.
starting from the data generated by the historyminer we compute for each type of smell smell k and for each source code file fj the number of commits performed on fjsince the first commit involving fjand adding the file to the repository up to the commit in which decor detects thatfjas affected by smell k. clearly such numbers are only computed for files identified as affected by the specific smell k. when analyzing the number of commits needed for a smell to affect a code component we can fall into two possible scenarios.
in the first scenario the least expected according to the software aging theory smell instances are introduced during the creation of source code artifacts i.e.
in the first commit involving a source code file.
in the second scenario smell instances are introduced after several commits and thus as result of multiple maintenance activities.
for the latter scenario besides running the decor smell detector for the project snapshot related to each commit the historyminer also computes for each snapshot and for each source code artifact a set of quality metrics see table ii .
as done for decor quality metrics are computed for all code artifacts only during the first commit and updated at each subsequent commit for added and modified files.
the purpose of this analysis is to understand whether the trend followed by such metrics differ between files affected by a specific type of smell and files not affected by such a smell.
for example we expect that classes becoming blobs will exhibit a higher growth rate than classes that are not going to become blobs.
in order to analyze the evolution of the quality metrics we needed to identify the function that best approximates the data distribution i.e.
the values of the considered metrics computed in a sequence of commits.
we found that the best model is the linear function more details are available in our technical report .
having identified the model to be used we computed for each file fj2ri the regression line of its quality metric values.
if file fjis affected by a specificsmell k we compute the regression line considering the quality metric values computed for each commit involving fjfrom the first commit i.e.
where the file was added to the versioning system to the commit where the instance of smell kwas detected in fj.
instead if fjis not affected byany smell we considered only the first nthcommits involving the filefj wherenis the average number of commits required by smell kto affect code instances.
then for each metric reported in table ii we compared the distributions of regression line slopes for cleanly and smelly files.
the comparison is performed using a two tailed mann whitney u test .
the results are intended as statistically significant at .
we also estimated the magnitude of the observed differences using the cliff s delta or d a non parametric effect size measure for ordinal data.
we followed the guidelines in to interpret the effect size values small for d positive as well as negative values medium for d 474and large for d .
overall the data extraction for rq i.e.
the smells detection and metric computation at each commit for the systems took eight weeks on a linux server having quadcore .
ghz cpu cores and gb of ram.
why are code smells introduced?
one challenge arising when answering rq 2is represented by the identification of the specific commit or also possibly a set of commits where the smell has been introduced from now on referred to as a smellintroducing commit .
such information is crucial to explain under which circumstances these commits were performed.
a trivial solution would have been to use the results of our rq and consider the commit csin which decor detects for the first time a smell instance smell kin a source code file fjas a commit introducing smell in fj.
however while this solution would work for smell instances that are introduced in the first commit involving fj there is no doubt on the commit that introduced the smell it would not work for smell instances that are the consequence of several changes performed in n different commits involving fj.
in such a circumstance on one hand we cannot simply assume that the first commit in which decor identifies the smell is the one introducing that smell because the smell appearance might be the result of several small changes performed across the ncommits.
on the other hand we cannot assume that all ncommits performed on fj are those gradually introducing the smell since just some of them might have pushed fjtoward a smelly direction.
thus to identify the smell introducing commits for a file fjaffected by an instance of a specific smell smell k we designed the following heuristic ifsmell khas been introduced in the commit c1where fjhas been added to the repository thenc1is the smellintroducing commit else givenc fc1 c2 c ngthe set of commits involvingfjand leading to the detection of smell kin 3table iii tags assigned to the smell introducing commits tag description values commit goal tags bug fixing the commit aimed at fixing a bug enhancement the commit aimed at implementing an enhancement in the system new feature the commit aimed at implementing a new feature in the system refactoring the commit aimed at performing refactoring operations project status tags working on release the commit was performed before the issuing of a major release project startup the commit was performed after the starting of the project developer status tags workload the developer had a workload when the commit has been performed ownership the developer was the owner of the file in which the commit introduced the smell newcomer the developer was a newcomer when the commit was performed c1c2c3c4c5c6c7c8loccommits fig.
.
example of smell introducing commit identification.
cnwe use the results of rq 1to select the set of quality metricsmallowing to discriminate between the groups of files that are affected and not affected in their history bysmell k. these metrics are those for which we found statistically significant difference between the slope of the regression lines for the two groups of files accompanied by at least a medium effect size.
let sbe the slope of the regression line for the metric m2mbuilt when considering all commits leading fjto become affected by a smell and sithe slope of the regression line for the metricmbuilt when considering just two subsequent commits i.e.
ci 1andcifor eachi2 .
a commit ci2cis considered as a smell introducing commit if jsij jsj i.e.
the commit cisignificantly contributes to the increment or decrement of the metric m. fig.
reports an example aimed at illustrating the smellintroducing commit identification for a file fj.
suppose that fjhas been involved in eight commits from c1toc8 and that inc8a blob instance has been identified by decor in fj.
also suppose that the results of our rq 1showed that the loc metric is the only one characterizing the blob introduction i.e.
the slope of the loc regression line for blobs is significantly different than the one of the regression line built for classes which are not affected by the blob smell.
the black line in fig.
represents the loc regression line computed among all the involved commits having a slope of .
.
the gray lines represent the regression lines between pairs of commits ci ci whereciis not classified as a smellintroducing commit their slope is lower than .
.
finally the red dashed lines represent the regression lines between pairs of commits ci ci whereciis classified as a smell introducing commit their slope is higher than .
.
thus the smellintroducing commits in the example depicted in fig.
are c3 c5 andc7.
overall we obtained smell introducing commits in the systems that we used to answer rq .
after having identified smell introducing commits with the purpose of understanding why a smell was introduced in a project we classified them by assigning to each commit one or more tags among those reported in table iii.
the first set of tags i.e.
commit goal tags aims at explaining what the developer was when introducing the smell .
to assign such tags we firstly downloaded the issues for all projects from their j ira or b ugzilla issue trackers.
then we checked whether any of the smell introducing commits were related to any of the collected issues.
to link issues to commits we used and complemented two existing approaches.
the first one is the regular expression based approach by fischer et al.
matching the issue id in the commit note.
the second one is a re implementation of the relink approach proposed by wu et al.
which considers the following constraints i matching the committer authors with issue tracking contributor name email ii the time interval between the commit and the last comment posted by the same author contributor on the issue tracker must be less than seven days and iii vector space model vsm cosine similarity between the commit note and the last comment referred above greater than .
.
r elink has been shown to accurately link issues and commits for precision and for recall .
when it was possible to identify a link between one of the smell introducing commits and an issue and the issue type was one of the goal tags in our design i.e.
bug enhancement or new feature such tag was automatically assigned to the commit and its correctness was double checked by one of the authors which verified the correctness of the issue category e.g.
that an issue classified as bug actually was a bug .
this happens in cases i.e.
for a small percentage of the commits which is not surprising and in agreement with previous findings .
in the remaining cases two of the authors manually analyzed the commits assigning one or more of the goal tags by relying on the analysis of the commit message and of the unix diff between the commit under analysis and its predecessor.
concerning the project status tags see table iii the working on release tag can assume as possible values one day one week one month ormore than one month before issuing of a major release.
the aim of such a tag is to indicate whether when introducing the smell the developer was close 4to a project s deadline .
we just consider major releases since those are the ones generally representing a real deadline for developers while minor releases are sometimes issued just due to a single bug fix.
to assign such tags one of the authors identified the dates in which the major releases were issued by exploiting the gittags often used to tag releases and the commit messages left by developers.
concerning the project startup tag it can assume as values one week one month one year ormore than one year after the project s start date.
this tag can be easily assigned by comparing the commit date with the date in which the project started i.e.
the date of the first commit .
this tag can be useful to verify whether during the project s startup when the project design might not be fully clear developers are more prone to introducing smells .
note that the project startup tag can be affected by the presence of projects migrated to gitand with a partially available history.
for this reason we checked whether the first release tagged in the versioning system were either 1or1 note that this might be an approximation since projects starting from could have a previous xhistory .
as a result we excluded from the project startup analysis projects for a total of smell introducing commits.
finally we assigned developer status tags to smellintroducing commits.
the workload tag measures how busy a developer was when introducing the bad smell.
in particular we measured the workload of each developer involved in a project using time windows of one month starting from the date in which the developer joined the project i.e.
performed the first commit .
the workload of a developer during one month is measured in terms of the number of commits she performed in that month.
we are aware that such a measure i is approximated because different commits can require different amount of work and ii a developer could also work on other projects.
when analyzing a smell introducing commit performed by a developer dduring a month m we computed the workload distribution for all developers of the project at m. then given q1andq3 the first and the third quartile of such distribution respectively we assigned lowasworkload tag if the developer performing the commit had a workload less thanq1 medium ifq1 workload q high if the workload was higher than q3.
the ownership tag is assigned if the developer performing the smell introducing commit is the owner of the file on which the smell has been detected.
as defined by bird et al.
a file owner is a developer responsible for more than of the commits performed on the file.
lastly the newcomer tag is assigned if the smell introducing commit falls among the first commits in the project for the developer performing it.
after assigning all the described tags to each of the smell introducing commits we analyzed the results by reporting descriptive statistics of the number of commits to which each tag type had been assigned.
also we discuss several qualitative examples helping to explain our findings.
blobandroid0cdsbpccfdsc255075100 blobeclipse0cdsbpccfdsc255075100 blobapache0cdsbpccfdsc255075100 bloboverall0cdsbpccfdsc255075100fig.
.
number of commits required by a smell to manifest itself.
iii.
a nalysis of the results this section reports the analysis of the results achieved aiming at answering our two research questions.
a. when are code smells introduced?
fig.
shows the distribution of the number of commits required by each type of smell to manifest itself.
the results are grouped by ecosystems also we report the overall results all ecosystems together .
as we can observe in fig.
in almost all cases the median number of commits needed by a smell to affect code components is zero except for blob on android median and complex class on eclipse median .
in other words most of the smell instances at least half of them are introduced when a code entity is added to the versioning system.
this is quite a surprising finding considering the common wisdom that smells are generally the result of continuous maintenance activities .
however the analysis of the box plots also reveals i the presence of several outliers and that ii for some smells in particular blob and complex class the distribution is quite skewed.
this means that besides smell instances introduced in the first commit there are also several smell instances that are introduced as a result of several changes performed on the file during its evolution.
in order to better understand such phenomenon we analyzed how the values of some quality metrics change during the evolution of such files.
table v presents the descriptive statistics mean and median of the slope of the regression line computed for each metric for both smelly and clean files.
also table v reports the results of the mann whitney test and cliff s deffect size large medium or small obtained when analyzing the difference between the slope of regression lines for clean and smelly files.
column cmp of table v shows a if for the metricmthere is a statistically significant difference in the m s slope between the two groups of files with the smelly ones exhibiting a higher lower slope a is shown when the difference is not statistically significant.
the analysis of the results reveals that for all the smells but functional decomposition the files affected by smells show a higher slope than clean files.
this suggests that the files that will be affected by a smell exhibit a steeper growth in terms 5table iv rq1 slope affected vsslope not affected m ann whitney test adj.p value and cliff sdelta d ecosys.
smell affectedloc lcom wmc rfc cbo nom noa mean med cmp mean med cmp mean med cmp mean med cmp mean med cmp mean med cmp mean med cmp no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01blob cliff s d .
l .
m .
l .
l .
l .
l .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cdsp cliff s d .
m .
n .
n .
n .
s .
n .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cc cliff s d .
l .
m .
l .
l .
s .
l .
m no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01fd cliff s d .
l .
l .
l .
m .
s .
l .
m no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.04android sc cliff s d .
l .
l .
l .
l .
s .
l .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01blob cliff s d .
l .
l .
l .
l .
m .
l .
s no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cdsp cliff s d .
l .
n .
n .
n .
s .
n .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.02cc cliff s d .
l .
l .
l .
l .
l .
l .
s no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01fd cliff s d .
l .
m .
l .
l .
n .
l .
m no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.02apache sc cliff s d .
l .
s .
l .
l .
m .
l .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01blob cliff s d .
l .
l .
l .
l .
s .
l .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cdsp cliff s d .
l .
n .
s .
n .
n .
s .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cc cliff s d .
l .
l .
l .
l .
s .
l .
m no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.88fd cliff s d .
l .
l .
l .
l .
s .
l .
n no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01eclipse sc cliff s d .
l .
l .
l .
m .
n .
l .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01blob cliff s d .
l .
l .
l .
l .
s .
l .
m no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cdsp cliff s d .
l .
n .
n .
n .
s .
n .
l no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01cc cliff s d .
l .
l .
l .
l .
s .
l .
m no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01fd cliff s d .
l .
l .
l .
l .
n .
l .
s no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
p value .
.
.
.
.
.
.01overall sc cliff s d .
l .
l .
l .
l .
n .
l .
l of metric values than files that are not becoming smelly.
in other words when a smell is going to appear its symptoms metric value increases occur very fast and not gradually.
for example considering the apache ecosystem we can see a clear difference between the growth of loc in blob and clean classes.
indeed this latter have a mean growth in terms of loc characterized by a slope of .
while the slope for blobs is on average .
.
to make clear the interpretation of such data let us suppose we plot both regression lines on the cartesian plane.
the regression line for blobs will have an inclination of .
indicating an abrupt growth of loc while the inclination of the regression line for clean classes will be .
indicating less steep increase of loc.
the same happens when considering the lcom cohesion metric the higher the lcom the lower the class cohesion .
for the overall dataset the slope for classes that will become blobs is .
as compared to the .
of clean classes.
thus while the cohesion of classes generally decreases over time classes destined to become blobs exhibit cohesion metric loss orders of magnitude faster than clean classes.
in general the results in table v show strong differences in the metrics slope between clean and smelly files indicating that it could be possible to create recommenders warning developers when the changes performed on a specific code component show a dangerous trend that could lead to the introduction of a bad smell.
the functional decomposition fd smell deserves a separate discussion.
as we can see in table v the slope of the regression line for files affected by such a smell is negative.
6this means that during the evolution of files affected by functional decomposition we can observe a decrement rather than an increment of the metric values.
the rationale behind such a result is intrinsic in the definition of this smell.
specifically one of the symptoms of such a smell is represented by a class with a single action such as a function.
thus the changes that could introduce a functional decomposition might be the removal of responsibilities i.e.
methods .
this clearly results in the decrease of some metrics such as nom loc and wmc.
as an example let us consider the class displaykmeans of apache mahout.
the class implemented the k means clustering algorithm in its original form.
however after three commits the only operation performed by the class was the visualization of the clusters.
indeed developers moved the actual implementation of the clustering algorithm in the class job of the package kmeans introducing a functional decomposition in displaykmeans .
overall from the analysis of table v we can conclude that i loc characterizes the introduction of all the smells ii lcom wmc rfc and nom characterize all the smells but class data should be private iii cbo does not characterize the introduction of any smell and iv the only metrics characterizing the introduction of class data should be private are loc and noa.
summary for rq .most of the smell instances are introduced when files are created.
however there are also cases especially for blob and complex class where the smells manifest themselves after several changes performed on the file.
in these cases files that will become smelly exhibit specific trends for some quality metric values that are significantly different than those of clean files.
b. why are code smells introduced?
to answer rq we analyze the percentage of smellintroducing commits classified according to the category of tags i.e.
commit goal project status and developer status .
commit goal table vii reports the percentage of smellintroducing commits assigned to each tag of the category commit goal .
among the three different ecosystems analyzed results show that smell instances are mainly introduced when developers perform enhancement operations on the system.
when considering the three ecosystems altogether for all the considered types of smells the percentage of smell introducing commits tagged as enhancement ranges between and .
note that by enhancement we mean changes applied by developers on existing features aimed at improving them.
for example a functional decomposition was introduced in the class createprojectfromarchetypemojo of apache maven when the developer performed the first pass at implementing the feature of being able to specify additional goals that can be run after the creation of a project from an archetype as reported in the commit log .
note that when considering both enhancement ornew feature the percentage of smell introducing commits exceeds on average .
this indicates as expected that the most smellprone activities are performed by developers when addingtable vii rq2 commit goal tags to smell introducing commits .
bf b ug fixing e e nhancement nf n ewfeature r r efactoring smellandroid apache eclipse overall bf e nf r bf e nf r bf e nf r bf e nf r blob cdsp cc fd sc new features or improving existing features.
however there is also a non negligible number of smell introducing commits tagged as bug fixing between and .
this means that also during corrective maintenance developers might introduce a smell especially when the bug fixing is complex and requires changes to several code entities.
for example the class securedmodel of apache jena builds the security model when a semantic web operation is requested by the user.
in order to fix a bug that did not allow the user to perform a safe authentication the developer had to update the model implementing more security controls.
this required changing several methods present in the class out of .
such changes increase the whole complexity of the class the wmc metric increased from to making securedmodel a complex class.
another interesting observation from the results reported in table vii is related to the number of smell introducing commits tagged as refactoring between and .
while refactoring is the principal treatment to remove smells we found cases in which developers introduced new smells when performing refactoring operations.
for example the classec2imageextension of apache jclouds implements theimageextension interface which provides the methods for creating an image.
during the evolution developers added methods for building a new image template as well as a method for managing image layout options e.g.
its alignment in the ec2imageextension class.
subsequently a developer performed an extract class refactoring operation aimed at reorganizing the responsibility of the class.
indeed the developer split the original class into two new classes i.e.
imagetemplateimpl andcreateimageoptions .
however the developer also introduced a functional decomposition in the class createimageoptions since such a class after the refactoring contains just one method i.e.
the one in charge of managing the image options.
this result sheds light on the dark side of refactoring besides the risk of introducing faults when performing refactoring operations there is also the risk of introducing design problems.
looking into the ecosystems the general trend discussed so far holds for apache and eclipse.
regarding android we notice something different for complex class and spaghetti code smells.
in these cases the smell introducing commits are mainly due to the introduction of new features.
such a difference could be due to the particular development model used for android apps.
specifically we manually analyzed the instances of smells identified in the android apps and we observed that in the majority of cases classes affected by a smell are those extending the android activity class i.e.
a class extended by developers to provide features to the app s users.
7table v rq1 descriptive statistics of the slope for the regression lines built for each metric for files affected notaffected by each badsmell maximinor note never use average to indicate mean because also the median is a measure of average j ecosys.
smell affectedloc lcom wmc rfc cbo nom noa mean med mean med mean med mean med mean med mean med mean med blob no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
cdsp no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
android cc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
fd no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
sc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
blob no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
cdsp no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
apache cc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
fd no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
sc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
blob no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
cdsp no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
eclipse cc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
fd no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
sc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
blob no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
cdsp no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
overall cc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
.
fd no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
sc no .
.
.
.
.
.
.
yes .
.
.
.
.
.
.
.
.
.
.
.
.
table vi rq1 slope affected vsslope not affected m ann whitney test adj.p value and cliff sdelta d ecosys.
smellloc lcom wmc rfc cbo nom noa p val.
d p val.
d p val.
d p val.
d p val.
d p val.
d p val.
d blob .
.
l .
.
l .
.
l .
.
l .
.
s .
.
l .
.
m cdsp .
.
l .
.
n .
.
n .
.
n .
.
s .
.
n .
.
l overall cc .
.
l .
.
l .
.
l .
.
l .
.
s .
.
l .
.
m fd .
.
l .
.
l .
.
l .
.
l .
.
n .
.
l .
.
s sc .
.
l .
.
l .
.
l .
.
l .
.
n .
.
l .
.
l specifically we observed that quite often developers introduce a complex class or a spaghetti code smell when adding a new feature to their apps by extending the activity class.
for example the class articleviewactivity of the aard5 app became a complex class after the addition of several new features spread across commits after its creation such as the management of page buttons and online visualization of the article.
all these changes contributed to increase the slope of the regression line for the rfc metric of a factor of .
and for wmc of a factor of .
.
project status table viii reports the percentage of smellintroducing commits assigned to each tag of the category project status .
as expected most of the smells are introduced the last month before issuing a release.
indeed the percentage of smells introduced more than one month prior to issuing 5aard is an offline wikipedia reader.table viii rq2 project status tags to smell introducing commits ecosystem smellworking on release project startup one one onemoreone one onemoreday week month week month year blob cdsp android cc fd sc blob cdsp apache cc fd sc blob cdsp eclipse cc fd sc blob cdsp overall cc fd sc a release is really low ranging between and .
this 8table ix rq2 developer status tags to smell introducing commits ecosystem smellworkload ownership newcomer high medium low true false true false blob cdsp android cc fd sc blob cdsp apache cc fd sc blob cdsp eclipse cc fd sc blob cdsp overall cc fd sc consideration holds for all the ecosystems and for all the bad smells analyzed thus confirming the common wisdom that the deadline pressure on developers can be one of the main causes for smell introduction.
considering the project startup tag the results are quite unexpected.
indeed a high number of smell instances are introduced few months after the project startup.
this is particularly true for blob class data should be private and complex class where more than half of the instances are introduced in the first year of system s lifecycle.
instead functional decomposition and especially spaghetti code seem to be the types of smells that take more time to manifest themselves with more than of spaghetti code instances introduced after the first year.
this result contradicts at least in part the common wisdom that smells are introduced after several continuous maintenance activities and thus are more pertinent to advanced phases of the development process .
developer status finally table ix reports the percentage of smell introducing commits assigned to each tag of the category developer status .
from the analysis of the results it is evident that the developers workload negatively influences the quality of the source code produced.
on the overall dataset at least in of cases the developer who introduces the smell has a high workload.
for example on theinvokermavenexecutor class in apache maven a developer introduced a blob smell while adding the command line parsing to enable users alternate the settings.
when performing such a change the developer had relatively high workload while working on nine other different classes in this case the workload was classified as high .
we can also observe that generally the developers who introduce a smell are not newcomers while often they are owners of the files.
at the first glance this could look like an unexpected result.
the owner of the file one of the most experienced developers of the file is the one that has the higher likelihood of introducing a smell.
however as also discussed by zeller in his book why programs fail more experienced developers tend to perform more complex and critical tasks .
thus it is likely that their commits are more prone to introducing design problems.summary for rq .smells are generally introduced by developers when enhancing existing features or implementing new ones.
as expected smells are generally introduced in the last month before issuing a deadline while there is a considerable number of instances introduced in the first year from the project startup.
finally developers that introduce smells are generally the owners of the file and they are more prone to introducing smells when they have higher workloads.
iv.
t hreats to validity the main threats related to the relationship between theory and observation construct validity are due to imprecisions errors in the measurements we performed.
above all we relied on decor rules to detect smells.
notice that our re implementation uses the exact rules defined by moha et al.
and has been already used in our previous work .
nevertheless we are aware that our results can be affected by the presence of false positives and false negatives.
moha et al.reported for decor a precision above and a recall of on xerces .
.
.
as for the precision other than relying on moha et al.
assessment we have manually validated a subset of the detected smell instances.
this manual validation has been performed by two authors independently and cases of disagreement were discussed.
in total smells were validated including blob instances class data should be private complex class spaghetti code and functional decomposition.
such a stratified sample is deemed to be statistically significant for a confidence level and confidence interval .
the results of the manual validation indicated a mean precision of and specifically for blob for class data should be private for complex class for spaghetti code and for functional decomposition.
in addition we replicated all the analysis performed to answer our two research questions by just considering the smell introducing commits involving smell instances that have been manually validated as true positives.
the results achieved in this analysis available in our replication package are perfectly inline with those obtained in our paper on the complete set of smell introducing commits confirming all our findings.
finally we are aware that our study can also suffer from presence of false negatives.
however i the sample of investigated smell instances is pretty large instances and ii the decor s claimed recall is very high.
as explained in section ii the heuristic for excluding projects with incomplete history from the project startup analysis may have failed to discard some projects.
also we excluded the first commit from a project s history involving java files from the analysis of smell introducing commits because such commits are likely to be imports from old versioning systems and therefore we only focused our attention in terms of first commit on the addition of new files during the observed history period.
concerning the tags used to characterize smell introducing changes the commit classification was performed by two different authors and results were compared and discussed in cases of inconsistencies.
also a second check 9was performed for those commits linked to issues only out of commits to avoid problems due to incorrect issue classification .
the analysis of developer related tags was performed using thegit author information instead of relying on committers not all authors have commit privileges in open source projects hence observing committers would give an imprecise and partial view of the reality .
however there is no guarantee that the reported authorship is always accurate and complete.
we are aware that the workload tag measures the developers activity within a single project while in principle one could be busy on other projects or different other activities.
one possibility to mitigate such a threat could have been to measure the workload of a developer within the entire ecosystem.
however in our opinion this would have introduced some bias i.e.
assigning a high workload to developers working on several projects of the same ecosystem and a low workload to those that while not working on other projects of the same ecosystem could have been busy on projects outside the ecosystem.
it is also important to point out that in terms of relationship between workload tag and smell introduction we obtained consistent results across three ecosystems which at least mitigates the presence of a possible threat.
also estimating the workload by just counting commits is an approximation.
however we do not use the commit size because there might be a small commit requiring a substantial effort as well.
as for the threats that could have influenced the results internal validity we performed the study by comparing classes affected and not by a specific type of smell.
however there can be also cases of classes affected by different types of smells at the same time.
our investigation revealed that such classes represent a minority for android for apache and for eclipse and therefore the interaction between different types of smells is not particularly interesting to investigate given also the complexity it would have added to the study design and to its presentation.
finally while in rq 2we studied tags related to different aspects of a software project lifetime characterizing commits developers and the project status itself we are aware that there could be many other factors that could have influenced the introduction of smells.
in any case it is worth noting that it is beyond the scope of this work to make any claims related to causation of the relationship between the introduction of smells and product or process factors characterizing a software project.
the main threats related to the relationship between the treatment and the outcome conclusion validity are represented by the analysis method exploited in our study.
in rq we used non parametric tests mann whitney and effect size measures cliff s delta as well as regression analysis.
results ofrq 2are instead reported in terms of descriptive statistics and analyzed from purely observational point of view.
finally regarding the generalization of our findings external validity this is to the best of our knowledge the largest study in terms of number of projects concerning the analysis of code smells and of their evolution.
however we are aware that we limited our attention to only five types ofsmells.
as explained in section ii this choice is justified by the need for limiting the computation since we wanted to analyze a large number of projects.
also we tried to diversify the types of smells including smells representing violations of oo principles and size related smells.
last but not least we made sure to include smells such as complex class blob and spaghetti code that previous studies indicated to be perceived by developers as severe problems .
nevertheless further studies aiming at replicating our work on other smells with projects developed in other programming languages are desirable.
v. r elated work this section discusses work investigating the evolution of code smells in software systems and their effect on maintenance activities and on software quality.
khomh et al.
studied the relationship between the presence of code smells and software change and fault proneness.
they found that classes affected by code smells tend to be significantly more change and fault prone than other classes.
empirical evidence demonstrating that some bad smells correlate with higher fault proneness has also been reported by li and shatnawi .
abbes et al.
conducted three controlled experiments with the aim of investigating the impact of blob and spaghetti code smells on program comprehension.
their results indicated that single occurrence of such smells does not significantly decrease developer s performance while the coexistence of multiple bad smell instances in the same class significantly reduces developers performance during maintenance tasks.
similar results were obtained by yamashita and moonen when studying the interaction of different code smells.
their results indicate that the maintenance problems are strictly related to the presence of more bad smells in the same file.
they also investigated the impact of bad smells on maintainability characteristics .
as discussed in section iv we do not focus on smell co occurrences because they happen in a very small percentage of affected classes.
the controlled experiment conducted by sj berg et al.
confirmed that smells do not always constitute a problem and that often class size impacts maintainability more than the presence of smells.
other studies investigate the impact of smells and their perception by surveying project developers.
arcoverde et al.
investigated how developers react to the presence of bad smells in their code.
the results of their survey indicate that code smells often remain in source code for a long time and the main reason for postponing their removal through refactoring activities is to avoid api modifications .
a recent paper presented an empirical study aimed at investigating the perception of types of smells by showing to the participants code snippets containing or not smells.
the results of such a study show that smells related to complex long source code are generally perceived as harmful while the other types of smells are not perceived or perceived only if the intensity of the problem is high.
yamashita and moonen conducted a survey involving professionals concerning the perceived severity of code smells and the need 10to remove them.
their results indicated that of developers do not know or know little about code smells and those who are aware about the problem pointed out that in many cases smell removal was not a priority because of time pressure or lack of adequate tool support.
in summary although with contrasting results the studies discussed above provide a general evidence that at least in specific circumstances code smells have negative effects on software quality.
despite that however developers seem reluctant to perform activities aimed at their removal.
chatzigeorgiou and manakos analyzed this phenomena and their results indicate that in most cases the design problems persist up to the latest examined version accumulating even more as the project matures.
very few bad smells are removed from the project and in the vast majority of these cases this was not due to specific refactoring activities but rather a side effect of adaptive maintenance .
they also pointed out some findings consistent with our rq i.e.
they indicated that a conspicuous percentage of smells were introduced when the affected source code entity was added in the system .
however their study does not provide quantitative data showing the magnitude of such phenomenon as we do.
it is also important to point out that we performed our analysis at commit level unlike to the related work that conducted those studies at release level which allowed us to identify when bad smells appear in the source code.
finally our results are based on analyzed systems instead of two systems analyzed by the study that we mentioned earlier.
peters and zaidman analyzed the bad smells lifespan focusing on developers behavior in the presence of such smells confirming that often even if the developers are aware of the bad smells presence they do not perform refactoring activities.
vi.
c onclusion and lessons learned this paper presented a large scale empirical study conducted over the commit history of open source projects and aimed at understanding when andwhy bad code smells are introduced.
these results provide several valuable findings for the research community lesson .most of times code artifacts are affected by bad smells since their creation .
this result contradicts the common wisdom that bad smells are generally due to a negative effect of software evolution.
also this finding highlights that the introduction of most smells can simply be avoided by performing quality checks at commit time.
in other words instead of running smell detector time to time on the entire system these tools could be used during commit activities in particular circumstances such as before issuing a release to avoid or at least limit the introduction of bad code smells.
lesson .code artifacts becoming smelly as consequence of maintenance and evolution activities are characterized by peculiar metrics trends different from those of clean artifacts .
this is in agreement with previous findings on the historical evolution of code smells .
also such results encourage the development of recommenders able of alerting software developers when changes applied to a code artifactsresult in worrisome metric trends generally characterizing artifacts that will be affected by a smell.
lesson .while implementing new features and enhancing existing ones are as expected the main activities during which developers tend to introduce smells we found almost cases in which refactoring operations introduced smells .
this result is quite surprising given that one of the goals behind refactoring is the removal of bad smells .
this finding highlights the need for techniques and tools aimed at assessing the impact of refactoring operations on source code before their actual application e.g.
see the recent work by chaparro et al.
.
lesson .newcomers are not necessary responsible for introducing bad smalls while developers with high workloads and release pressure are more prone to introducing smell instances .
this result highlights that code inspection practices should be strengthened when developers are working under these stressful conditions.
these lessons learned represent the main input for our future research agenda on the topic mainly focused on designing and developing a new generation of code quality checkers such as those described in lesson .