the road to live programming insights from the practice juraj kubelka pleiad dcc university of chile santiago chileromain robbes swse free university of bozen bolzano bozen bolzano italyalexandre bergel pleiad dcc university of chile santiago chile abstract liveprogrammingenvironmentsallowprogrammerstogetfeedback instantly while changing software.
liveness is gaining attention among industrial and open source communities several ides offer high degrees of liveness.
while several studies looked at how programmers work during software evolution tasks none of them consider live environments.we conduct such a studybased on an analysisof17programmingsessionsofpractitionersusingpharo a mature live programming environment.
the study is complemented by a survey and subsequent analysis of programming sessions in additional languages e.g.
javascript.
we document the approaches taken by developers during their work.
we find that somelivenessfeaturesareextensivelyused andhaveanimpacton the way developers navigate source code and objects in their work.
ccs concepts software and its engineering development frameworks and environments object oriented development keywords live programming software evolution exploratory study acm reference format jurajkubelka romainrobbes andalexandrebergel.
.theroadtolive programming insightsfromthepractice.in icse icse 40thinternational conference on software engineering may june gothenburg sweden.acm newyork ny usa 12pages.
introduction liveprogrammingaimstofreeprogrammersfromtheedit compilerun loop of standard programming going as far as to allow programstobechangedwhiletheyrun.recentyearshaveshownthat there is considerable interest in live programming and liveness ingeneral thenewprogramminglanguageswiftfromapplefeaturesinteractiveplaygrounds microsoftrecentlypurchaseda companydevelopingliveprogrammingtools facebook sreact supports instant feedback web browsers come with interactive consoles and inspectors .
academically a series of international conferences and workshops have been held on live programming permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
live being the most popular workshop at icse see section for background on live programming .
while some see live programming as the future of programming some of its proponents have more concrete and immediate issues.microsoftresearch sseanmcdirmid wrote thebiggest challenge instead is live programming s usefulness how can its feedback significantly improve programmer performance?
while the full vision of live programming is yet to be implementedandmadeavailableatscaletopractitioners manyelements of it are in use on a daily basis in some developer communities.
inparticular manyoftheliveprogrammingconceptshavebeen presentfordecadesinthesmalltalkandlispdevelopmentenvironments smalltalk and lisp feature high degrees of liveness.
this offers us a critical opportunity to understand howliveness is usedtoday and offers insights to practitioners researchers language designers and tool builders on how to effectively use and supportliveprogramming.inthispaper weprovideanswersto severalresearchquestionsontheuseofliveprogrammingfeaturesinpractice.wefirstprovideessentialbackgroundonliveprogramming and our main study subject the pharo ide in section .
wethenpresentourmethodology section3 weanalyzed17 development sessions of programmers totaling hours of coding with familiar and unfamiliar code.
this was followed by two confirmatory phases a survey of smalltalk developers and an analysis of online videos hours of html javascript c php haskell and c c programmers.
section4 answersour firstresearchquestion do developers use the live programming features of pharo?
in the the affirmative wefindthatliveprogrammingfeaturesandtoolswere used extensively by pharo users.
section5answersoursecondresearchquestion how do developers use live programming in pharo?
.
we describe several usages of live programming and contrast them against traditional programming approaches.
our overall finding is that simple approaches were favored and their combinations can be powerful.
we then answer our third research question do developers other than those we analyzed behave similarly?
intwoparts.
first we find that surveyed pharo users agree with most of the observationswemade section6 .subsequently weobservethat users of other languages and tools use more limited capabilities duetothelimitedextentofthetoolsupport andwiththeaimof getting feedback early and often section .
wethendiscussourfindingsinthecontextofexistingstudiesand toolsupportinsection8.inparticular wediscusshowareduced toolset centering on the concept of the object inspector supports a large range of use cases.
finally we close the paper with a discussion of the threats to validityofthisstudyinsection9andconcludewithimplications for tool builders researchers and language designers in section .
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden juraj kubelka romain robbes and alexandre bergel background and related work .
live programming environments the reader wishing to experience live programming concretely may visit the web site for a javascript example.
degrees of liveness.
live programming allows programmers to obtainnearlyinstantaneousfeedbackfromtheirprogramsthrough always accessible evaluation .
tanimoto describes four levels of liveness .
atlevel the usermust restart thewhole applicationtoobtainanykindoffeedback.atlevel2 semanticfeedback is available on demand this is the level provided by interactive interpreters read eval printloops .atlevel3 incrementalfeedback is automatically provided after each edit operation.
finally level applies changes to a running application without explic itly initiating the application under change.
each level creates a differentexperienceandcoversolutionssuchasauto testing readeval print loops repls or systems where development tools and applications share the same environment .
whileelementsofliveprogrammingdatebackdecades with some versions of it supported in lisp s read eval print loop orinsmalltalkanditsdescendants e.g.
self squeak smalltalk orlivelykernel ithasseenaresurgenceofinterestin academia and in the industry.
live programming research.
academically both the live programmingworkshop andtheinternationalconferenceonlive coding held their 3rd edition in the fall of .
many live programminglanguagesandtoolshavebeenproposed butmost ofthem areexperimental.aswe focusontheusageof livenessin practice and due to space constraints we only give a brief coverage ofa handful ofseminal work.the s sawan interest inliveprogramming for visual languages such astanimoto s viva that introduced the liveness levels.
burnett et al.implemented level4livenessinavisuallanguage .theyalsoconductedacontrolled experiment of debugging comparing live and non live tasks .theyfoundthatsubjectsperformedtwiceasmanychangesin livetasks buttheeffectintermsoftimeandaccuracywasmixed.
recent works include languages such as mcdirmid s superglue jonathanedward ssubtext andglitch .microsoft s touchdevelophasbeenmodifiedtosupportliveprogramming .
delineetal.proposedtempe aliveprogrammingenvironment for data analysis .
livenessinpractice.
severalframeworksandtoolsnowadaysadd waystointegrateimmediatefeedback particularlyontheweb.the chrome web development tools allow changes to web pages andjavascriptcodewithoutreloadingawebpage.modern popular javascript frameworks including facebook s react.js support live programming in live code editors .
mainstream languages also take steps in this direction java supports a limited replacement of application parts while it is running through the java platform debugger architecture .
apple s newlanguageswiftsupportsliveprogrammingwithinteractive playgrounds .finally microsoft svisualstudio2015supportsinteractiveprogrammingforc andf withrepls .microsoft also recently acquired the codeconnect startup which developed the alive extension for visual studio .
.
live programming in pharo whypharo?
pharo isaprogramminglanguageanddevelopmentenvironmentderivedfrom thesqueak smalltalk dialect ofsmalltalk .asthedevelopmenttoolsandtheapplications sharethesameruntimeenvironment developersnaturallyworkon running applications.
in addition developers constantly improvepharoitselfbyalteringitwhileitisrunning.sincepharocanupdate any part of an application at runtime it supports up to tanimoto s fourth level of liveness.
as a descendant of squeak pharo also features the direct manipulation morphic ui originally implemented in self .
as a descendant of smalltalk liveness is present in pharo since more than three decades.
this has two consequences thatmade pharo the case study of choice in this work.
first liveness was designed in the language and the tools since its inception the supportisbothmatureandseamless.moreimportantly liveness is also part of the culture of the development community.
pharo is usedbyanactivecommunityofdevelopers bothinindustryand academia.pharousersareintroducedtolivenesswhentheylearn the language from the very beginning and as a result practitioners use it naturally as part of their daily tasks.
this characteristic is the main driver of our choice of pharo as we wanted to know how developers familiar with liveness use it in practice.
liveness in pharo.
we now present the main liveness features of pharo contrasting it with a traditional ide eclipse assuming a default configuration .
codeevaluation.
thefirstdifferenceistheeaseofevaluatingcode inpharo.sincethecompilerisauser accessibleobject anypieceof textcanbeselected andthenbeexecuted printedout inspected debugged orprofiled eitherviamenusorkeyboardshortcuts.eclipse canonlyrunapplicationsinnormalordebugmode andexecute tests.thisdifferencehasfar reachingconsequences.forinstance inpharoitiscommontoencounterexecutableexamplesembedded inmethodcomments.tobetterunderstandamethod ausercan simply select the example execute it and observe the result.
pharo can also compile and update a single method at a time.
thiscanbedoneevenwhileapplicationsarerunning anynewcall tothechangedmethodfromthenonwillcalltheupdatedbehavior.
accessing objects.
the object inspector is a tool that displays objectstates .developerscannavigatetheobjectgraph modify instancevariables evaluatecodesnippets browseitssourcecode and invoke inspectors from virtually anywhere.
they may open multipleinspectorsatthesametimeandkeepthemforarbitrary long periods of time.
this is useful for contrasting the object behaviors and for evaluating the result of source code change on live objects.
theinspector can beembedded inother tools .
many objects have custom inspector views.
eclipse has a more limited object inspector in its debugging perspectivethatcanonlynavigatetheobject sstructure changethe values of primitive types and is dismissed as soon as the developer leaves the debugging perspective.
playground.
the playground is a tool to write code snippets and exploretheirresults whicharedisplayedinanembeddedobject inspector.
playgrounds can be used to experiment with example code snippets.
developers can open various playgrounds and keep them open indefinitely.
eclipse does notprovide a similar tool.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the road to live programming insights from the practice icse may june gothenburg sweden debugger.
the pharo debugger is composed of a stack trace at the top a source code editor in the middle and an embedded inspector in the lower part with instance and method variables.
developerscanchangethevariablevalues editsourcecode and observe the effects of these changes.
pharo developers can haveseveral debuggers open at the same time which allows for easy comparisonoftheexecutionoftwoexecutionscenarios.whena non existentmethodisinvokedonanobject thedebuggerofferstocreateit generatesastub andthennavigatesinsidethemethodstub allowing the developer to implement it with live arguments and variables at his or her disposal.
this process called programming inthedebugger canberepeatedindefinitely e.g.
anewlyadded methodcaninturncallanon existingmethod andisespecially popular among proponent of test driven development.
eclipse developers can evaluate code snippets inside of a debugger.
however eclipse does notsupport multiple opened debuggers.
changingsourcecodeatrun timeislimitedtomethodsvisiblein thecall stack any otherchangeneedsanapplication restart.
pharo developerscanchangeanysourcecodeelements includingclass definitions.thepharodebuggerisautomaticallyinvokedwhenever an error occurs while eclipse s has to be invoked manually.
halo.originatingfrommorphic thehaloenablesinteractionswithon screenwidgets.thehaloisinvokedontheuielement under the mouse via keyboard shortcuts.
buttons appear around thewidget triggeringactionssuchascopying altering deleting or inspecting it.
eclipse does notoffer a similar functionality.
.
studies of developers manyobservationalstudiesofdevelopershavebeenconducted.we very briefly list some here see section for discussions in context.
koet al.studied how developers seek information during maintenancetasks .lawrance etal.studiedhowdevelopersdebug fromaninformationforagingperspective .latoza etal.present developeractivitiesandthetoolsupportlevelforthem .roehm et al.conducted an observational study about software comprehensioninsevencompaniesandreportoncomprehensionstrategies .
latoza et al.compared novice and experts during program comprehension .
robillard et al.contrasted successful and non successful developers during maintenance tasks .
astheywork developersaskmanyquestions.severalstudies seek to catalogue them and analyze their tool support.
sillito et al.
observed27softwaremaintenancesessions andlisted questions asked during them.
latoza et al.focus on reachability questions and provide questions rated by difficulty andfrequency .
koet al.identify questions about interaction with codebases and co workers .
fritzet al.present developerquestionswithlackoftoolsupportthatinvolveinformation integrationfromvarioussources .duala ekoko etal.conducted a study on unfamiliar apis and identified questions .
some studies disallowed the use of runtime information e.g.
robillard et al.
others did allow it but did not specifically report it such as ko et al.and lawrance et al.
.
thus studies of live environments where a high amount of runtime informationisavailable complementpreviouswork.delineand fisherperformedsuchastudy butintherestrictedcontextofdata scientists not in software development.table participant information.
participant programming experience in current conducted id any language smalltalk position sessions p1 .
ph.d. student s1 p2 professor s2 p3 .
professional s3 p4 professor professional s8 s11 p5 .
master student professional s9 s12 p6 professor s10 s13 p7 ph.d. student s4 p8 bachelor student s5 s14 p9 ph.d. student s6 s15 p10 .
professional s16 p11 ph.d. student s7 s17 research method .
exploratory study participants.
we recruited eleven male participants consisting of students academic staff and professional developers from distinct small local companies.
their programming experience spanned from5to22years withamedianof6years.experienceinpharo or smalltalk ranged from .
to years with a median of years.
theparticipantsconsistedof1bachelorstudent 4ph.d.students 2professors 2professionaldevelopers and2personswithmixed positions.
details are illustrated in table .
tasks.we conducted programming sessions of which sessions s1 s10 includedan unfamiliarcodebase and7sessions s11 s17 a familiarcodebase.asessionwasclassifiedas familiar if the participant was one of the authors of the codebase.
in this case we asked the participant to choose a programming task of his or her project on which he or she can work during minutes and stressed it was not important to finish the task at the end of the session.
in unfamiliar sessions the participant had little or no knowledge of the codebase beforehand.
we provided him or her a preparedpharoimagerelatedtoaparticularbug fixingorextension task and an explanation of the task.
study setting.
participants completed the study using pharo version3.theycoulduseanyidefeatures andanydocumentation resources.
they were advised to proceed with their work as usual.
beforeeachsession wesetuptheparticipant sdeviceandexplained the procedure of the session.
we asked participants to verbalizetheir thoughts while solving their tasks.
participants did not re ceive any additional prior training for our study.
after about minutes we informed participants that they could finish whenever they wanted.
data collection and transcription.
we used three data collection techniques screen captured videos including audio hours in total user interactions and interviews.
we summarized what the participants said and described the actions they were performing on the screen we developed tools to attach timestamps to thetranscriptsandnavigatebacktothevideosasneededduringthe analysis.
these data recordings and tools are available at .
we complemented this data with ide user interactions whichwecapturedwiththedflowframework .eventsincluded opening closing andmovingofwindows clicksonuielements navigation and changes to the source code etc.
see details in .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden juraj kubelka romain robbes and alexandre bergel the interactions were not recorded in the session s14 due to the participant sincompatiblesetup weexcludes14whenwereport on dflow data in section and in figure we manually checked the presence of each tool but did not count the windows .
after each session we conducted semi structured interviews in which participants were asked to comment on the challenges experienced during the sessions and divergences with their day today work.
the interviews lasted from five to fifteen minutes.
.
on line survey since our aim was to confirm the exploratory study findings we usedanon linesurveyasitisadatacollectionapproachthatscales well .thesurveyissplitintothreeparts demographicinformation toolusagequestionswithmultiplechoices andopen ended questions.
none of the questions were mandatory.
excluding demographicsquestions the surveyconsistedof34 multiple choice questionsand2open endedquestions andansweringittookabout minutes.
the survey is available at .
we first ran a pilot survey with a limited number of people to clarify our questions.
we then advertised the survey through sevenmailinglistsrelatedtosmalltalkcommunities andtwitter.
to attract participants we included a raffle of two books.
the survey received responses.
our participants were experienced morethan10years 6to10years 3to5years and14 2yearsorless andmanywerefromindustry from industry from academia both others e.g.
hobby .
thisbalanceswithourstudyparticipants primarilyfromacademia.
respondentsusedseveralsmalltalkdialects programmeddaily.
.
on line coding session videos asconductinganexploratorystudyisatime consumingprocess even with a limited number of sessions we complement this study with an analysis of publicly available coding session videos.
we searched for programming videos on youtube using keywords such as coding session programming session and live pro gramming and environments and frameworks that were more likelytofeatureadegreeofliveness suchas javascript react c or swift .
we also considered the related videos proposed by youtube.
we selected potentially relevant videos based on their titleandskimmingtheircontents.theinitiallistincluded44videos totaling about hours.
this data is available at .
in the second step we watched and categorized each video in ordertodeterminewhetheritisaprogrammingsessionoraprearranged tutorial or talk.
we end up with coding session videos ofabout25hours.wethencarefullywatchedthesevideos looking for five events a developer observes a running application or variablevaluesafterachange adevelopermodifiessourcecode or variable values of a running application a developer uses an inspector to get runtime values a developer uses a debugger to understand a problem a developer write and run code snippets.
for each event we identified whether i we observe it at least once ii weobserveapartwhereitisusediterativelyafterasmall meaningful change or iii we do not observe it.
thevideosubjectsusethefollowingprogramminglanguages html javascript hours haskell hours php 2hours 1c 4hours and1c c 14minutes .
results usage of liveness in this section we are concerned whether participants of the exploratorystudyusetheliveprogrammingfeatures.toanswerit we divide development tools into two categories static tools if the mainpurposeistopresentsourcecode e.g.
sourcecodeandreferencesbrowsers and dynamictools ifthemainpurposeistopresent thestateofanapplication e.g.
debugger playground inspector testrunner profiler .thegoalofthisclassificationistogetusa first orderapproximationoftheuseofliveprogramming.thisis only an approximation as developers can change source code with static tools and have an immediate feedback or use dynamic tools and observe application states without performing changes.
figure dynamic and static tool usage per session.
figure shows the usage of static gray and dynamic black toolsovertimeinallthesessions.eachsessionlabelincludesthe following information session id unfamiliar or familiar task participant id and dynamic toolusage percentage.
in total ourparticipantsspent5.5hours usingdynamictoolsand7.5hours using static tools with sessions having or more of the timespentwithdynamictools.inaddition wecanseethatdevelopers routinely switched between static and dynamic tools even for short durations.
thosenumbershighlight the high overall usage of dynamic tools during the sessions and its frequency.
figure number of windows opened per session figure shows for the most frequently used tools the number of windows opened in each session.
results are aggregated for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the road to live programming insights from the practice icse may june gothenburg sweden compactness each tool is summarized by a bar divided in cells.
eachcellrepresentsthenumberofsessionsforwhichaspecified rangeofwindowswereopened graycellstotheleftindicatesparse or no usage of a tool while green cells to the right indicate prolific users.wesubdividedebuggerusageintwocategories explicituser invocation with breakpoints and automatic invocation by the ide when runtime errors occur.
figure allows us to easily rank tools by usage.
the system browser of development tool windows or used to browse and edit code unsurprisingly goes first all subjects used it extensively.thencomestheobjectinspector allbutoneparticipant usedit 139totalwindows andmanydidveryfrequently.our most prolific participant opened of them!
note that this is an underestimate as this number does not include inspectors embedded in other tools debuggers playgrounds .
debuggers caused by runtime errors follow windows .
they were present in all but3sessions andappearedforthefollowingreasons non existentmethods test case assertion failures and other runtime er rors .themethodbrowserusedforreferencenavigationcomes next windows being extensively used by half of the participants.next theplaygroundappears 46windows although this metric may be somewhat misleading all but one participant usedplaygrounds andthesewindowstendtobelong lived.finally debuggers invoked on breakpoints are next windows with 8participantsneverusingthem.othertoolssuchastestrunners windows profilers windows or version control tools windows saw little use.
summary participantsuseddynamictoolsfrequently.chiefamong them was the object inspector.
results liveness episodes inthissection wedescribethestrategiesthatprogrammerstook to make progress in their tasks.
they took a variety of approaches sometimes taking advantage of pharo s liveness accessing objects finding and modifying examples crafting code snippets modifying applications sometimesemployingmoretraditionalapproaches unit testing debugging code search and static exploration .
each type of usage or episode reusing the terminology of zieris and prechelt is illustrated by one or more examples from the transcripts.
finally we highlight how the approaches can be combined.
.
accessing and manipulating objects accessing objects with the inspector is the most common strategy participants took it was present in all but one sessions.
inspectors were used frequently due to pharo s ease of executing source code anywhere includingincodebrowsers playgrounds debuggers and inspectorsthemselves.usagesvary insophisticationfromsimple accesses checkingofclassnames variablevalues tomanipulationthroughexecutionofmethodcallsandcodesnippetsontheobjects.
basic usages.
participant p4 s8 copy pasted an example in a playgroundinordertounderstandalibrary.hehadnoideawhat a variable was its name a was far from useful.
by adding the method call a inspect at the end of the example and executing it p4 received an inspector on a where he could see the object s state including its class name.using multiple inspectors.
an important feature of the inspector isthatonecankeepanynumberofinspectedobjectsopened for as longas necessary.
in thecase of eclipse developerslose access to objects when they exit a debugging session.
pharo developers thus can change code and regularly execute methods in previously inspected objects to see the impact of their changes.
participant p9 s6 workedwith therubric frameworkthat createstexteditors.p9foundouthowthelibraryworksbyopening inspectorson objectsof interest p9obtained aninspectoron aui widget representing an editor view.
the view had a model holding information about the contained text.
within the inspector p9evaluatedandaskedfortheview smodelandopeneditinanotherinspector.thenp9wassendingmessagestobothobjects and observed how they interact and change each other.
inspectinguiobjects.
participantp11 s7 wantedtofindwherea mouse click that opened a ui window is handled.
he inspected the ui window using a halo see section .
and found the window s class.hethenputabreakpointintheclassconstructor triggered the mouse click again and found the source code in the debugger.
notethatbeingabletoinspectgraphicalwidgetsdoesnotalways result in finding relevant information.
similarly to p11 participant p5 s9 wanted to know where a particular dialog was executed.
he inspected the dialog widget but started diving in the complex structureoftheobject expectingtofindarelevantmethodname this approach is possible but is challenging .
p5 spent about minutesbeforerealizinghecoulddolikep11whosubdividedthe question in two steps identifying the widget class then using a breakpoint to find out where it is created.
using multiple inspectors with halos is possible too participant p6 s10 had to fix a bug relating to an application s text editingarea.
noticing that the bug is not present in another application he used halos to find out whether the text editing areas in the two applications were similar they were of two different ui widget classes.
p6 could then focus on one class of widgets only.
.
finding modifying and executing examples ourparticipantsfoundexamplesfromavarietyofsources indocumentation in source code in test cases and in dedicated browsers.
theywereeasytoexecuteandchange butmorecomplexexamples weremorechallengingtoreuse.evenifseldomused weobserve that having an example browser with running living examples simplifies exploration and comprehension.
basicusage.
afteridentifyingtheclassofthetextarea seeabove p6 searched for