move optimized source code tree differencing georg dotzler michael philippsen friedrich alexander university erlangen n rnberg fau germany programming systems group georg.dotzler michael.philippsen fau.de abstract when it is necessary to express changes between two source code les as a list of edit actions an edit script modern tree di erencing algorithms are superior to most text based approaches because they take code movements into account and express source code changes more accurately.
we present general optimizations that can be added to state of the art tree di erencing algorithms to shorten the resulting edit scripts.
applied to gumtree rted jsync and changedistiller they lead to shorter scripts for of the changes in the histories of open source software repositories.
these optimizations also are parts of our novel move optimized tree differencing algorithm mtdiff that has a higher accuracy in detecting moved code parts.
mtdiff which is based on the ideas of changedistiller further shortens the edit script for another of the changes in the repositories.
mtdiff and all the benchmarks are available under an open source license.
ccs concepts software and its engineering !software maintenance tools mathematics of computing !trees keywords tree di erencing optimizations source code .
introduction in many disciplines it is common to express the changes between two character sequences as a list of edit actions a so called edit script.
it often matters to nd the shortest possible edit script for instance between rna structures in biology .
when software developers examine changes in source code it is also likely that the shortest edit script is the most bene cial to grasp the nature of a change.
according to falleri et al.
the length of the edit script is a proxy to the cognitive load for a developer to understandthe essence of a commit and thus le changes .
it is also likely that code change recommendation tools can produce better results if they have access to the shortest edit scripts.
unfortunately nding them is np hard if the movement of subsequences e.g.
substrings or subtrees is a permitted edit action.
to determine source code di erences quickly di and its variants solve a simpli ed problem.
first they do not consider moved code.
the only permitted edit actions are insertions and deletions of code lines.
second they use myers algorithm to detect changes on the granularity of full text lines.
thus even if a change only a ects a part of a line e.g.
renames a variable the full line is deleted and a new line is inserted.
both simpli cations make the output of di unnecessarily verbose due to a sub optimal edit script.
tree di erencing approaches avoid the above granularity problem as a code line usually consists of a number of nodes in the abstract syntax tree ast .
the resulting edit scripts no longer mention unmodi ed parts of code lines.
but since the general problem of nding the shortest edit script on asts with moves remains np hard state of theart tree di erencing algorithms also need to simplify the problem.
rted for example does not consider moved subtrees.
other state of the art tree di erencing algorithms that consider move actions cannot be fast and nd an optimal ne grained edit script.
they use di erent heuristics to match the requirements of their speci c use cases.
changedistiller cd uses coarse grained ast nodes that represent larger structures of the code e.g.
full loop conditions or full statements.
the di erences on the resulting much smaller trees are su cient for cd s purpose to categorize and identify types of changes.
cd s edit scripts are short but the arguments of the individual edit actions are long sometimes as long as in di .
jsync is used in a clone detector framework.
thus the algorithm is aimed at changes in methods and not at changes in complete les.
hence jsync leaves out irrelevant aspects from the asts such as imports elds etc.
and does not work on full les.
gumtree gt works on ne grained asts and full code les.
for an upper bound on the runtime complexity o n2 fornast nodes gt nds a short edit script.
the goal of this paper is to achieve shorter ne grained edit scripts that use move actions more frequently even if the computation takes slightly longer than for gt or di .
we analyzed the four tree di erencing algorithms from above to better understand why their edit scripts are longer than necessary.
from this analysis we developed general optimizations.
when they are added as pre or postpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
original code modi ed code foo xy int a int b log if cond m1 d c log print !
hello m2 foo xyz t int b int a log if cond !
null m1 c d log print hello !
m2 .
.
a gt takes edit actions boxes.
foo xy int a int b log if cond m1 d c log print !
hello m2 foo xyz t int b int a log if cond !
null m1 c d log print hello !
m2 .
.
b gt with our optimizations takes edit actions.
foo xy int a int b log if cond m1 d c log print !
hello m2 foo xyz t int b int a log if cond !
null m1 c d log print hello !
m2 .
.
c mtdiff only needs edit actions.
figure code change left !right .
the boxes show the edit actions that the tree di erencing algorithms detect yellow for updates green for insertions redfor deletions blue for node movements.
processing phases to gt rted cd and jsync the optimizations shorten their edit scripts.
note that this may not be necessary for the applications for which these tree di erencing algorithms were initially developed.
fig.
holds an arti cial code change to illustrate the optimizations original code on the left modi ed code on the right .
the code is identical in all three sub gures.
the boxes indicate the edit actions.
fig.
a shows that gt produces an edit script of size .
when the general optimizations are added to gt they shorten the edit script to the actions shown in fig.
b .
the optimizations have similar e ects on the other tree di erencing algorithms but due to their di erent asts the boxes would be di erent.
additionally this work presents a novel move optimized tree differencing algorithm mtdiff that achieves even shorter edit scripts due to its higher accuracy in detecting moved code parts.
it is based on cd and uses the general optimizations.
applied to the same example mtdiff requires only edit actions see fig.
c .
sec.
brie y introduces tree di erencing.
sec.
describes the general optimizations and sec.
presents mtdiff.
these two sections also address the details of the optimizations that lead to the results in fig.
while sec.
discusses time complexities.
sec.
holds both a quantitative evaluation on changed les and a study to demonstrate that shorter edit scripts are more helpful to developers than longer ones.
sec.
discusses related work.
.
tree differencing compilers use asts to internally represent source les as rooted labeled ordered trees.
fig.
shows two examples.each node has a label lbl such as calloand simplename for xyo .
some nodes also have a value attribute v. fig.
uses their values 2oorxyo instead of their labels.
anedit script is a list of edit actions that transforms the original astointo the modi ed astm.
each edit action has a cost siand the cost of an edit script is the sum of all si.
an edit script is optimal if its cost is minimal.
for the remainder of this work all edit actions have the same cost e.g.
.
thus there is no preference of an edit action.
the optimal edit script then is the shortest one.
most tree di erencing algorithms approach the search for the shortest edit script in two phases.
phase uses heuristics to generate a mapping between the nodes of the asts.
the algorithms vary with respect to both the granularity of the ast they use and the heuristics they employ to derive the mapping.
a mapping is a list of matching pairs of nodes no nm where node nofrom astois mapped to node nm inastm.
each mapped node is part of only one pair.
it is a common restriction that only nodes with the same label can match although this misses a few corner cases e.g.
while forwith similar conditions .
our optimizations and also mtdiff share this restriction.
based on the mapping from phase phase computes the edit script in o n2 .
as the algorithms for phase are optimal a shorter edit script can only result from a di erent mapping from phase .
thus our work focuses on the heuristics in phase .
for our evaluation we use the implementation of gt for phase as it uses an optimal algorithm.
this implementation uses edit actions namely updatevalue add delete andmove .
for a pair no nm with di erent values gt adds anupdatevalue no vm action to the script.
if a node no is not in the mapping gt adds delete no .
if a node nmis not in the mapping gt adds add nm parent nm i where ispeci es the ithchild of the parent of nm.
if there is a pair no nm in the mapping where parent no parent nm is not mapped gt adds a move no parent nm i where nmis the node mapped to noandispeci es the ithchild of the parent of nm.
if both no nm and parent no parent nm are mapped gt also adds a move action if no andnmhave di erent child indices in their parents.
note that rather than moving a single node n move a ects the complete subtree rooted in n. .
general optimizations the following optimizations a eare applicable to all examined tree di erencing algorithms.
for the discussion of a ewe use the code and asts from figs.
and .
for brevity fig.
only shows the situation for gt and we only demonstrate b eon gt.
our evaluation shows that a eshorten the edit scripts for the other tree di erencing algorithms as well.
.
identical subtree optimization a identifying unchanged code is crucial to avoid large edit scripts because any pairing of nodes from unchanged parts with nodes from changed parts causes avoidable edit actions.
as example we apply cd to the ast in fig.
although it is more detailed than the cd ast .
since in this change the two assignments switch places a single move action for ois su cient.
cd does not recognize that the subtrees of oand oare left unchanged albeit in a di erent order.
thus cd creates four edit actions that modify each of the constants and identi ers a b .
the main cause 661blocko o 1o decl o bo int o o 0o decl o ao int o callo argso o 2o xyo fooo a astoof the original code.
blockm m 0m decl m am int m m 1m decl m bm int m callm argsm tm m 2m xyzm foom b astmof the modi ed code.
figure asts of the rst code lines in fig.
.
same legend as in fig.
.
is that cd pairs nodes from within the subtree oto nodes from the two di erent subtrees of mand m. hence the identical subtree optimization aadds pairs of matching nodes from identical subtrees to the mapping before phase of the tree di erencing algorithm even starts.
this reduces the number of pairs in the mapping that hold nodes from both unchanged and changed code.
ais a built in part of gt.
di ts uses a variant of it.
for each subtree agenerates a ngerprint.
identical subtrees i.e.
identical code parts have the same ngerprint i.e.
the same string representation .
then atraverses astotop down.
if a node s ngerprint also appears in the modi ed astm aadds all pairs of nodes from the two subtrees to the mapping provided that the ngerprints are unique in their respective asts.
since in most cases leaves arenotunique e.g.
into aignores them for speed.
as in fig.
the ngerprints of the subtrees of oand m match and are unique in astoand astm aadds the pairs o m decl o decl m int o int m etc.
to the mapping.
note that anot only improves the tree di erencing results it also reduces the runtime of all subsequent steps including the tree di erencing algorithm as their complexities depend on the number of nodes that are not in the mapping.
.
lcs optimization b gt uses rted to match smaller subtrees and inherits the inability to detect the move of cond in fig.
line .
it creates two instead of one edit action delete and insert .
the idea of the longest common subsequence lcs postprocessing bis to atten two subtrees that have their roots in the mapping.
if there are unmapped nodes that have the function lcsopt rooto rootm m uo unmappednodestopdown root o m um unmappednodestopdown root m m done foruo2uodo po parent uo ifpo2done then continue done done fpog pm mappednode u o m ifpm6 null then lo nodesinpostorder p o lm nodesinpostorder p m result lcs lo lm uo um m for mo mm 2result do ifmo2uo mm2umthen m m f mo mm g uo uonfmog uo umnfmmg return m figure lcs optimization b.same labels within their two attened sequences badds them as a pair to the mapping.
bin fig.
initially traverses both asts top down and collects nodes that are not yet mapped lines .
as input it uses the root nodes of both asts and the current mappingm.
in the example condo nullm !
m and condmare not in the mapping.
afterwards bselects the rst such node condo and tests whether its parent ifo has a partner in the mapping.
as ifois mapped to ifm b attens both subtrees and computes the lcs in lines .
a pair mo mm is part of the lcs result if the two labels are identical and either the pair was previously mapped or both were unmapped line .
badds the pair condo condm to the mapping.
this leads to the move action and the shorter edit script.
bdoes not add other pairs since the remaining nodes only appear in one sequence.
to avoid duplicate work bchecks each parent only once lines .
.
unmapped leaves optimization c caddresses the problem of unmapped leaves that are missing in the mapping.
for instance gt does not recognize the movement of cin fig.
line .
this again is caused by the use of rted to map small subtrees.
bdoes not heal this as either cordcan be part of the lcs.
to x this the pseudo code of cin fig.
works on all unmapped leaves that have a parent that is mapped to a partner.
in the example cois not part of the mapping but the argument list of method m1ois.
then partnerchild line nds a node xthat is a suitable partner of co. our implementation uses a cascade of conditions to select the most suitable node.
condition select a node xthat is among the children of mappedpm has both the same label and the same value asuo and is not in the mapping.
condition select a node xthat is among the children of mappedpm has both the same label and the same position asuo and is not in the mapping.
for brevity we skip the less common remaining conditions that can be found in the source code.
function unmappedleavesopt rooto rootm m uo unmappedleaves root o m foruo2uodo po parent uo mappedpm mappednode p o m ifmappedpm6 null then xm partnerchild u o mappedp m ifxm6 null then m m f uo xm g return m figure unmapped leaves optimization c. 662ascmis the most suitable node same label same value not in the mapping in the example cadds co cm to the mapping line .
this shortens the edit script because it replaces delete co and insert cm with one move .
cis invoked twice once for the unmapped leaves in astoand once for those in astm because an unmapped leaf in astmmay have a parent in the mapping lines whereas its counterpart in astohas not.
.
inner node optimization d the post processing inner node optimization dis only e ective when bor chave changed the mapping.
then it can further improve the results with the new information.
the conditions that trigger donly occur in larger code fragments.
fig.
shows an abstract example and its suboptimal mapping in which only one child of ois mapped to a child of m. for two children o2ando3 ofothere is a mapping to nodes in astmthat are children of a di erent parent n6 m. thus the edit script has two move actions.
the key idea of dis to change the partner of the parent node ofrom mton so that afterwards fewer children have tomove .
in the example after d the edit script has only onemove for o1 m1 .
fig.
holds the pseudo code of d. for an inner node ioinasto oin fig.
dsearches for an inner node in astmthat shares more mapped children with iothan the current partner in the mapping m .
if found dcounts the number of its shared children line .
if at least half of them have a mapped partner in the subtree of the matching candidate n dremoves the old pair o m and adds the new pair o n instead line .
again only pairs with the same label are considered line .
.
leaf move optimization e whereas ctargets unmapped leaves only ealso examines pairs that are already in the mapping.
gt generates twoupdate actions to modify the string constants of print in fig.
line .
edetects that a single move is su cient.
the pseudo code in fig.
rst identi es pairs of leaves in the mapping where both leaves have di erent values line .
these are candidates for the optimization.
then for each such pair e.g.
!o hellom elooks for a leaf that is a better partner because it has the same value lines .
to avoid unnecessary moves only leaves from the partner of the parent node e.g.
the string concatenation in fig.
are considered lines .
using another parent always requires amove action and cannot shorten the edit script.
if e nds such a node pm it modi es the current mapping but only if there is just a single other possible match unique .
otherwise edoes not touch the mapping as there is no o o3 o2 o1 m m1... n n2 n1... a astoof original code.
b modi ed astm.
figure asts with sub optimal mapping.
o m niare simpli cations e.g.
of argument lists.
function optimizeinnernodes rooto rootm m io mappedinnernodesinpostorder root o m forio2iodo im mappednode i o m maxm nodewithmostmappedchildren i o m ifmaxm6 imthen commonchildren commonchildren io maxm m ifjcommonchildrenj oor jchildren io j then iflbl io lbl max m then m m f io maxm g m mnf io im g return m figure inner node optimization d. fast way to decide which match prevents the edit script from growing.
there is one exception.
eupdates the mapping if there are several leaves with identical values and the position of the possible match inside its parent s subtree is the same as the position of the leaf in the original subtree for !
o .
as there is a better matching leaf in the example eremoves the old pair !o hellom in line and adds the new pair !o !m in line .
afterwards hellomlacks a partner in the mapping.
as the previous partner of m helloo has the same label eadds helloo hellom to the mapping lines .
for fig.
eis done at this point.
it has replaced the two updates with a single move .
if in other cases a pair with di erent values instead of helloo hellom is added to the mapping the pair is added to the work list for further optimization lines .
eachieves termination with a second work list line .
there may be no tting node for the leaf of the original tree.
if for the pair !o hellom there is no identi er !m then there still can be a better partner for hellom.
the second loop lines nds the partner in a way that is similar to the loop in lines .
after a rst run eruns again with parent lm instead of mappednode p o m in line .
this optimizes leaves for parents that are not in the mapping.
.
order of a e due to their design the order a phase b c d e results in the shortest edit scripts in our evaluation.
ais a pre processing step that does not require an initial mapping while the post processing steps b edo.
other function leafmoveopt rooto rootm m work mappedleaveswithvaluedi erences m work new list while work6 doouter for lo lm 2work do po parent lo mpm mappednode p o m parent l m in run pos childposition io po forc2children mp m do ifisidenticalleaf c l o then posc childposition c mp m ifunique lo children mp m pos poscthen m mnf lo lm g m m f lo c g c mappednode c m ifc null then m mnf c c g m m f c lm g work remove work c c ifvalue c value lm then work add work c l m break forc2children p o do ... work work work return m figure leaf move optimization e. 663orders or subsets of b eare valid but in general result in longer edit scripts.
donly makes sense after bor c. eis useful on its own.
.
move optimized tree diff in contrast to the other considered tree di erencing algorithms only ais already part of gt mtdiff includes and also requires all the general optimizations a e. the other major di erence is in phase i.e.
in the way mtdiff computes the mapping of nodes between asts.
due to their design gt and jsync struggle with movements of subtrees that are also altered while they are moved e.g.
the moved and altered subtree in line of fig.
.
as cd can detect such movements in its coarse grained cdast we use it as foundation of mtdiff.
both cd and mtdiff take a two step approach to create the mapping in phase .
in their rst step both algorithms create pairs of leaf nodes for the mapping.
based on the leaves in the mapping their second step creates pairs of inner nodes.
the workings of these steps are di erent in cd and mtdiff.
the latter has to address two challenges that are not an issue for cd due to its original purpose .
challenge a since the values of nodes in the cd ast contain larger pieces of the code there are fewer nodes with identical labels and values than in a ne grained ast.
for example there are two identical intnodes in fig.
whereas the cd ast represents the two non identical statements in lines and as only two nodes with non identical values.
thus mtdiff has to nd a mapping that takes care of identical leaves not relevant for cd and that also yields a short edit script.
sec.
.
presents how mtdiff nds pairs of identical leaves for the mapping.
challenge b similarly the coarse grained cd ast encodes loop conditions and other pieces of the code as values.
fine grained asts express them as separate subtrees.
thus mtdiff requires new heuristics to measure the similarity of inner nodes when it computes a mapping for them.
additionally mtdiff has to examine more inner nodes to nd suitable partners.
sec.
.
addresses the details.
although mtdiff can reuse the similarity function for leaves from cd its heuristics require their own set of similarity thresholds.
sec.
.
explains our approach to identify suitable values.
.
leaf mapping the rst step of phase creates pairs of leaf nodes and adds them to the mapping.
the pseudo code for this step is in fig.
.
leafmapping is called on the original asto and the modi ed astm.
initially it extracts lists l o lm of all leaves that are not already part of the m apping m due to a lines .
then the loops lines compute the pairwise similarities of the unmapped leaves.
mtdiff shares with cd the similarity function simlfor the leaves siml lo lm lbl lo lbl lm sim2g v lo v lm otherwise.
ast nodes with di erent labels lblnever match.
otherwise mtdiff uses bigrams sim2g to compute the string similarity of the values v in the interval .
then leafmapping sorts the list of node p airs by decreasing similarities.
nodes with the same similarities are sorted according to the post order visiting sequence rst of ast o and then of ast m line .
to keep this example simple function leafmapping rooto rootm m resolveambiguity lo unmappedleaves root o m lm unmappedleaves root m m u lo lm p forlo2lodo forlm2lmdo similarity siml lo lm ifsimilarity thresholdlthen p p f lo lm similarity g p orderbysimilarityandvisitorder p c p a ifresolveambiguity then c unambiguouspairs p a ambiguouspairs p for lo lm s 2cdo iflo2u lm2uthen m m f lo lm g u unflog u unflmg a handleambiguities a m for lo lm s 2ado iflo2u lm2uthen m m f lo lm g u unflog u unflmg return m figure creates a mapping from two trees root o rootm .
we ignore the results of the apre processing.
pthen contains the following ordered list of leaf pairs with a similarity above zero fooo foom 2o 2m int o int m int o int m ao am 0o 0m int o int m int o int m bo bm 1o 1m xyo xyzm .
.
only for the pairs without intnodes there is no ambiguity.
whereas cd does not need to handle a mbiguous nodes resolveambiguity false mtdiff separates them in list a from unambiguous ones with a c lear match list c in lines .
ambiguous nodes are nodes for which there is no single best match in p. all intnodes in fig.
fall into this category.
then mtdiff examines all entries in cand adds them to the mapping if both nodes are part of u set of unmapped nodes .
thus the for loop in lines adds all the unambiguous node pairs in the above order.
without an ambiguity treatment of the intnodes in fig.
and without a the second step mapping of inner nodes would add the barely similar pairs decl o decl m .
and decl o decl m .
to the mapping.
this would lead to an overly verbose edit script that moves the variable names aoandbo and declarations decl oanddecl o .
to prevent this handleambiguities resolves such ambiguities before mtdiff adds inner nodes to the mapping.
it reconsiders the pairs based on the similarity values of all pairs in aand takes the previously determined pairs in m into account.
based on a handleambiguities builds a matrix for each group of ambiguous leaves see fig.
a for ways to pair the intnodes.
the key idea is that the parents of the leaves often can help to resolve the ambiguity because their similarities are connected to the choices of leaf pairs.
therefore handleambiguities recursively uses leafmapping on the small subtrees that have their parents as root.
if among all combinations there are parent rooted asts that have more mapped nodes than the others mtdiff has an indication for a selection of lmamong the ambiguous leaves.
int oint o int m int m a ambiguous leaf similarity matrix s.int oint o int m2 int m b similarity matrix s after handleambiguities .
figure ambiguous leaf similarity matrix for fig .
function innernodemapping rooto rootm m io unmappedinnernodes root o m im unmappedinnernodes root m m u io im p forio2iodo forim2imdo vsim simiv io im csim simic io im similarity wi0 vsim wi1 csim ifsimilarity thresholdithen p p f io im similarity g p orderbysimilarityandvisitorder p for io im s 2pdo ifio2u im2uthen m m f io im g u unfiog u unfimg return m figure creates pairs of inner nodes.
in the example the parent of the leaf lo int oisdecl o. for the ambiguous choices for lm2fint m int mg their parents are decl manddecl m resp.
thus mtdiff calls leafmapping twice with decl o decl m m false and also with decl o decl m m false .
the adjusted similarity simabetween ambiguous leaves is then based on the results of leafmapping i.e.
the number of pairs in the mapping.
the more pairs the higher is the similarity between two leaves.
with normalization simais sima lo lm jleafmapping parent lo parent lm m false j jmax nodes parent lo nodes parent lm j. fordecl oanddecl m this yields a similarity of2 3as of the nodes in this subtree match see cell int o int m of the adjusted matrix in fig.
b .
based on the matrix the best mapping of leaves is int o int m and int o int m because this maximizes the total combined similarity .
ifleafmapping on the parents does not nd a unique best pair for each row and column mtdiff recursively applies leafmapping to the grand parents of the best rated parents.
it is still possible that even at the root nodes there are identical similarity values for several leaf pairs.
in fig.
this is the case for the logidenti ers.
they have the same parent hierarchy identical values and labels.
the only di erence is their position within the ast.
therefore handleambiguities also uses the position of the leaves.
it generates a second matrix d distance that holds the di erences in the postorder position of the node pairs.
for example the rst logo and rst logmnodes both have the same post order position and thus a di erence d ijof .
note that solely using the position matrix would lead to longer edit scripts.
for the best results handleambiguities combines matrix d with cells d ij with matrix s cells sij after the recursive application of sima.
the combination uses weights w l0 and wl12 and inverts and also normalizes the values to s ij wl0 sij w l1 dij.
sec.
.
shows how we determine the weights.
the weighted combination is done in preparation for the next and nal part of the leaf mapping that ensures a suitable choice of leaf pairs.
it is easy to see the best mapping of leaves in the matrix in fig.
b .
in the general case nding the pairs with the best combined similarity is identical to solving the assignment problem for which handleambiguities applies the hungarian method to the matrix as nal step.
.
inner node mapping next mtdiff uses the innernodemapping algorithm in fig.
.
similar to the leaf mapping step mtdiff computes the similarities between all inner nodes and adds allpairs whose similarity is above a threshold ito the list p of similar p airs in lines .
whereas cd always selects the rst pair found above a threshold to prune the search space and to reduce the runtime mtdiff exploits the fact that aalready added most inner nodes to the mapping which reduces the size of the problem.
thus mtdiff can a ord to compute all similarities above the threshold iand to select the pair with the highest similarity.
computing the similarity of two inner nodes is more difcult for mtdiff than for cd.
due to challenge b the similarity functions of cd are not applicable.
they expect that larger parts of the code e.g.
a complete loop condition are included in the values of inner nodes.
instead mtdiff uses two similarity heuristics simivand simic and combines them with two weights w i0and wi12 in line .
the rst similarity heuristics handles the values of inner nodes simiv io im lbl io lbl im v io v im discrete io sim2g v io v im otherwise.
this structure is similar to siml.
the di erence lies in the handling of inner node types for which only discrete values are allowed.
an example for such inner nodes are arithmetic expressions.
for them only the values of the operation etc.
are valid.
in these cases the similarity of di erent operations is set to .
based on preliminary experiments .
hence mtdiff can express an operator change in an arithmetic expression with a single update action.
for all other types simivuses sim2gto measure the textual similarity of the node values.
the use of sim2ghas another positive side e ect it allows mtdiff to use the cd ast in the evaluation.
without the extra treatment of arithmetic expressions sim2gwould return a similarity of leading to two edit actions delete and insert .
the second similarity heuristics simicof mtdiff takes the similarity of the children into account.
without it innernodemapping would add o m1 and decl o decl m to the mapping for our example in fig.
.
this requires additional moves for the leaves ao 0o bo 1o .
to take the children into account according to the evaluation of fluri et al it is su cient to only examine the leaves of the children s subtrees.
in contrast to cd simichas to take the importance of smaller subtrees e.g.
loop conditions into account challenge b .
cd handles this together with the values of inner nodes as such code parts appear as values and not as subtrees in the cd ast.
instead simichas to normalize the importance of the subtrees of the inner nodes ioandimto make them independent of their sizes.
to enforce that small subtrees expressing a control ow condition are as important as the subtrees of other siblings regardless of their number of leaves mtdiff uses simic io im lbl io lbl im sumc io im jch io j jch im jotherwise.
nodes with di erent ast labels never match.
otherwise the similarity of two inner nodes depends on their subtrees children ch .
for illustration of simic consider the two args nodes in fig.
.
since argsohas oas its only child andargsmhas the two children mandtm there is a division byjch io j jch im for the normalization of sumc io im p qo2ch io jcomp qo im j jleaves qo j p qm2ch im jcomp qm io j jleaves qm j.
665for each of the children qof both trees sumc computes similarity values by counting leaf pairs in the mapping as determined by the previous leaf mapping step i.e.
xyoand xyzmis counted as one pair since the similarity is above the threshold .
with comp q i mtdiff compares all the leaves of the subtrees qandi.
if one of the leaves has a mapped leaf somewhere in iit is counted.
the resulting count is normalized by the number of leaves to stress the importance of small subtrees e.g.
a control ow condition.
note that a leaf is counted even if it has been moved to a di erent subtree in i. the rationale is that program structures remain similar even if somewhere within them code is moved around.
in the example the child oofargsohas two leaves that both have a mapped node among the leaves ofargsm.
weighted by the two leaves in q this contributes 2tosumc .
likewise malso contributes2 .
as there is no mapped leaf for tminio this child adds0 to sumc .
overall the two args nodes have a normalized similarity of1 .
.
with this approach mtdiff makes the condition and the body of a loop equally important and avoids longer edit scripts due to the problem of descendant subtree matching .
.
thresholds and weights as mentioned above mtdiff uses four weights and two thresholds.
to identify suitable values for those constants we performed an extensive particle swarm optimization pso that minimizes the edit scripts for each of the changed les in the histories of di erent open source repositories checkstyle fitlibrary jgrapht junit .
the target function for the pso was the number of les for which the weights and thresholds result in shorter edit scripts compared to an initial set of scripts.
this function achieves a balance between minimizing the edit scripts for les with a few changes and les with several thousand changes the alternative to minimize the total number of all edit actions of all les favored large les .
the best values determined by the pso are w l0 .
w l1 .
w i0 .
w i1 .
threshold l .
and threshold i .
.
.
complexity analysis the evaluation shows that in practice a ebarely increase the runtime of the tree di erencing algorithms.
a can even make them faster.
we now analyze the complexity fornnodes iinner nodes lleaves .
with hash maps a has an average complexity of o a n .
bhas a worst case complexity of o b n3 .
but real world codes rarely or never have the worst case in whichn 2nodes from both trees are part of a mapping and where each lcs execution does not change this condition.
chas a complexity of o c u with uunmapped nodes.
dhas a complexity of o d i2 .
ehas a complexity of o e l2 logl as it adds at mostl mappings to the work list.
in our evaluation mtdiff is faster than other examined algorithms even though its asymptotic complexity is above ocd l2 logl2 i l .
for practical use o amust reduce the number of unmapped leaves and unmapped inner nodes for mtdiff s phase .
in more detail leafmapping without ambiguity resolution is ino l2 log l2 cl .
this is based on l2leaf comparisons with cost cland the sorting of the leaf pairs according to their similarities in o l2 logl2 .
the worst case is l l pairs of leaves with equal similarities and labels.
thenleafmapping with ambiguity resolution has to compare all i2combinations of subtrees of inner nodes to determine the best leaf matching.
each comparison requires l2executions ofleafmapping without ambiguity handling.
this causes a complexity of o l4 i2 logl2 cl .
dynamic programming reduces this to ol l2 i2 log l2 cl as subtree comparisons can be reused.
the hungarian method see sec.
.
is in oh l3 .
the position computation is in op l2 .
the innernodemapping has a complexity of oi i2 logi2 ci as there are i2comparisons of cost ci.
the cost of sorting the inner node pairs according to their similarities is in o i2 logi2 .
thus if the comparison costs are in o the complexity of phase of mtdiff is in ol oh op oi o l2 i2 log l2 cl i2 logi2 ci l3 l2 o l2 i2logl2 i2 logi2 l3 .
.
evaluation the evaluation shows a that the general optimizations shorten the edit script for all tree di erencing algorithms and b that mtdiff achieves even shorter scripts.
moreover it shows c that the optimizations and mtdiff detect more moves and d that for both the optimizations and mtdiff the performance is fast enough for practical use.
finally we show e that shorter edit scripts are more bene cial to developers.
as a common code base we use the gt framework .
this includes the unoptimized baselines of the tree di erencing algorithms gt rted and cd.
in the framework gt and rted share a ne grained ast called gt ast below .
cd uses a coarse grained cd ast.
for jsync we adopted the published source code to the gt framework with the jsync ast so that the four tree di erencing algorithms use the same edit script generator phase from the gt framework.
because of the di erent asts we never compare the results of gt rted cd and jsync with each other.
instead we show the e ects of a efor each of the algorithms on their asts separately.
since mtdiff is congurable to use any of the three asts we can compare it with the other algorithms in sec.
.
.
our dataset uses all commits in the master branches no merges before aug. taken from active open source java projects ant checkstyle cobertura drjava eclipse jdt core findbugs fitlibrary jgrapht junit .
all the projects are part of the qualitas corpus .
we excluded le revisions because they only contained changed comments and whitespace.
we also excluded le revisions with more than ast nodes because rted could not process them with the gb of ram our workstation is equipped with cpu .
ghz intel xeon .
we ignored revisions because cd or rted could not deal with them in our arti cially set time limit of minutes.
for the remaining le revisions in those commits simply called lesbelow we ran the tree di erencing algorithms on the original le before the commit and the modi ed le after the commit.
as we ran the tree di erencing algorithms in combinations without optimizations with a with b with c e with a e and also mtdiff with di erent ast types the time limits were necessary.
except for the rted versions due to the memory limitations we also executed changes in parallel.
even with the time limits and the parallel execution the measurements took about weeks on the workstation.
.
effects of the general optimizations table shows the e ects of a e in this order on the four state of the art tree di erencing algorithms.
we show the e ect of a eon the number of pairs in the mapping map.
and on the size of the resulting edit scripts.
the third column shows for how many of the les the baseline tree di erencing algorithm i.e.
gt rted cd jsync produces better results without optimizations a e .
a mapping is better if it has more pairs of nodes an edit script is better if it is shorter.
column four shows for how many les the optimized algorithm with a eleads to better results compared to its original versions.
the last column holds the rest i.e.
the number of les for which the scripts have the same size or the same number of mappings.
across all the tree di erencing algorithms the ve optimizations only have a harmful e ect both on the number of pairs in the mappings and the script sizes for a negligible .
of the les.
we discuss some reasons for this in sec.
.
.
for of the les a eshorten the edit scripts for all tree di erencing algorithms.
the mean edit script size reduction by a eis edit actions median .
for the same les the mean edit script size produced by the baseline algorithms is edit actions median .
rted is a special case in our evaluation as it already nds optimal shortest edit scripts although without moves .
no optimization can improve them.
but as the rted in the gt framework produces a mapping of nodes this mapping can be fed into an edit script generator from the gt framework that considers moves .
the generated scripts can be shorter due to the moves and can also bene t from our optimizations.
in fact for of all les rted with optimizations has shorter edit scripts.
this also means that despite its original use rted with the optimizations can act as a tree di erencing algorithm that takes moves into account.
on its own each of the ve optimizations also improves the results.
as ais already part of the baseline gt it has no e ect there.
but ahas a huge impact on the cd results with an improvement for of all les.
the reason is that for its original purpose cd did not need to handle unchanged code explicitly.
when it is added to jsync a shortens the scripts for of the les although jsync already uses a textual line di to detect unchanged code.
from all optimizations bhas the largest impact on gt and shortens the scripts for of the les without harmful impact.
it also has a strong e ect on cd shorter scripts for of all les and on jsync .
since individually c ehave little e ect we measured them together.
c e shorten the scripts for gt for of the les cd jsync .
overall all optimizations reduce the script sizes for several thousand les.
.
performance of mtdiff we now compare mtdiff with the state of the art tree di erencing algorithms on their respective asts.
for intable e ects of a eon changed les.
baseline with a esame better better size gt map.
.
.
.
gt ast size .
.
.
rted map.
.
.
.
gt ast size .
.
.
cd map.
.
.
.
cd ast size .
.
.
jsync map.
.
.
.
jsync ast size .
.
.
original code modi ed code obj1.obj2 obj3 l m n o obj4 .obj5 obj1 l t n m a gt takes edit actions.
obj1.obj2 obj3 l m n o obj4.obj5 obj1 l t n m b gta etakes edit actions.
obj1.obj2 obj3 l m n o obj4.obj5 obj1 l t n m c mtdiff takes edit actions.
figure tough code changes legend from fig.
.
stance mtdiff uses the jsync ast when compared to jsync.
for the comparison we always switch on the optimizations a eas they shorten the edit scripts or produce the same size for almost all les.
the third column of table lists all les for which the state of the art algorithms with a eactivated produce better results than mtdiff.
the fourth column shows the larger number of les for which mtdiff is better.
across all algorithms mtdiff shortens the script sizes for of all les.
compared to the baseline algorithms without a e the improvement is even larger .
the mean edit script size reduction by mtdiff compared to the algorithms with a e is edit actions median .
for the same les the mean edit script size produced by the algorithms with a eis edit actions median .
note that the comparison also shows that mtdiff is capable of producing short edit scripts for di erent types of asts.
there are several cases in which the state of the art algorithms produce shorter edit scripts i.e.
in which the optimizations a eare harmful or for which mtdiff produces longer edit scripts.
a manual inspection of the cases revealed two main patterns of tough code changes.
fig.
illustrates both.
first if nodes with the same label are moved and at least one of them is updated it is sometimes shorter to use only update actions in the edit script.
fig.
a shows that gt can express the changes in line with three updates as the underlying rted nds the optimal move free edit script.
in some cases jsync s heuristics also handle this situation well.
in contrast the optimizations a e add as many pairs of identical nodes to the mapping as possible.
under some circumstances this can lead to longer edit scripts as shown in line of fig.
b c .
the second tough pattern are nodes that are moved and replaced in their former position with a node of the same label.
consider lines and of the example in fig.
.
the identi er mismoved from line to line and a new identi er ttakes its former place.
while it is possible to express the change with the two updates m o tm and oo mm phase of mtdiff table performance of mtdiff on changed les.
alg.
with a emtdiff same better better size gta e map.
.
.
.
gt ast size .
.
.
rteda e map.
.
.
.
gt ast size .
.
.
cda e map.
.
.
.
cd ast size .
.
.
jsynca e map.
.
.
.
jsync ast size .
.
.
jsynccdrtedgt jsync astcd astgt astgt ast figure fraction of move only that are found on the respective asts black for the baseline alg.
gray with a eadded and white for mtdiff .
nevertheless adds the pair m o mm to the mapping which not only causes the move in phase but also a delete oo and an insert tm action.
this yields a longer edit script see fig.
c .
we plan to address these issues with an additional post processing step in the future.
.
move accuracy not all possible moves reduce the size of the edit scripts see fig.
.
in general it is hard to determine whether the moves in a script make it shorter.
falleri et al.
argue that a tree di erencing algorithm is more precise in detecting moves and thus more likely to nd the ideal number of moves if it identi es more scripts that solely consist of moves .
based on this way to gauge the script quality we count the les for which the tree di erencing algorithms have found move only scripts.
separately for each type of ast we identify all such les that are found by any of the algorithms with or without a e and by mtdiff.
fig.
sets this total count of move only scripts to for each of the asts.
the black areas in the gure show the fractions that the baseline versions identify the gray areas show the fractions found when the optimizations a eare activated.
with the optimizations all algorithms nd more move only scripts.
thus the optimizations improve the accuracy in detecting moves .
no single move only script was missed because of the optimizations.
there is no black area for the baseline rted as it does not generate moves .
the white areas show that mtdiff is always more accurate in detecting moves .
for both the gt ast and the jsync ast mtdiff did not miss a single move only script.
on its ast cd a eidenti es some move only scripts that mtdiff does not detect of all scripts .
the reason is that the pso see sec.
.
optimized mtdiff s weights and thresholds for a ne grained ast.
.
runtime to evaluate the runtime of the optimizations we compare the baseline algorithms with their optimized variants.
to ease comparison with related work we select the jenkins repository that is also used by falleri et al.
.
as dataset we use all le changes in the commits between the versions .
.
and .
.
.
in a total of hours our workstation executed each tree di erencing algorithm times on these changes.
we only measure the time taken by phase and by the optimizations as all the tree di erencing algorithms use the same script generator phase .
for this dataset there is no need to exclude any les due to memory or runtime limitations.
also in contrast to the previous measurements we executed no changes in parallel.the box plots in fig.
capture the results quartiles whiskers for .
times the interquartile range .
the optimizations only slightly slow down gt rted and jsync.
across all les the mean runtime increase for gt rted and jsync is .062s median .0032s .
for most applications this is an acceptable overhead.
with the optimizations switched on cd runs even faster because a reduces the problem size see the discussion in sec.
.
.
the lower three box plots in fig.
show the runtime of mtdiff on the di erent asts.
due to its higher complexity mtdiff is slower than gt.
this is the price to pay for shorter edit scripts.
even though phase of mtdiff has a higher asymptotic complexity than cd it is faster due to the e ect of a. compared to cd a e mtdiff is on par.
overall mtdiff requires less than .3s for the majority of les which we consider an acceptable runtime.
the lower three box plots also illustrate the e ect of the ast granularity on the runtime.
.
script size questionnaire the goal of a eand mtdiff is to produce shorter edit scripts.
this section reports on a survey with eight developers not the authors to determine whether this is a reasonable goal and whether shorter edit scripts are more helpful to them.
we base this study on the dataset that was used for tables and .
from the le changes we excluded large ones pairs in the mapping edit actions as they are hard to analyze for study participants.
from each of the shaded cells in the two tables we randomly selected le changes and the corresponding two edit scripts created by the two compared tree di erencing algorithms or variations .
the alternative a completely random selection of the changes would have favored the tree di erencing algorithms with a eover the baseline versions mtdiff over the algorithms with a e or same size cases over cases with di erent script sizes.
if there are less than le changes in a cell for instance there are only changes for which the baseline cd is better than cda e we randomly picked the missing le changes from the same column.
we also picked only changes with di erent edit scripts from the cells in the same size columns.
in the other cells the size di erence in the edit scripts was between and mean .
median .
.
we presented a questionnaire with all of the 3mtdiff jsync ast mtdiff cd ast mtdiff gt ast jsynca ejsynccda ecdrteda ertedgta egt execution time sec.
per changed le.
figure runtimes for jenkins.
668table questionnaire results answers .
first second unclear sum more helpful more helpful first shorter second shorter same size sum pairs of edit scripts in a graphical representation similar to fig.
to the eight study participants that all hold a master or phd degree in computer science or mathematics.
to avoid order e ects we randomized the order of the edit scripts in each pair and also showed the pairs to each of the participants in a random order.
for each of the pairs we asked the participants is the rst or the second representation more helpful in understanding the intention of the change?
.
table holds the results of the answers.
when the rst edit script was shorter the majority of the participants also found the rst script to be more helpful .
similarly when the second script was shorter more participants preferred the second script .
when the scripts had the same size there was no clear di erence and the results were more similar to a random distribution.
more formally pearson s chi squared test rejects our null hypothesis that the two nominal variables script size di erence in the pairs versus helpfulness are independent p .
this allows us to examine the strength of the e ect that the size di erence has on the helpfulness.
since the third row same size has no size di erence and thus no e ect to be measured it is left out of the remaining evaluation.
for the rst and second row cram er s association measurement is v where indicates no association and is a full association .
cohen s e ect size measure isw v prows this indicates a medium e ect of the script size di erence on the helpfulness.
however wdoes not address the issue whether a shorter or a longer script increases the helpfulness.
for that we can use the observations from table .
as there are more helpful votes for shorter scripts the shorter scripts have a medium positive e ect on the helpfulness.
.
limitations and threats to validity none of the ve optimizations a euses language dependent features.
thus they should also work for other programming languages even though the evaluation only uses java code.
this is also supported by the fact that there is no large variation in the results regardless of the type of ast we have used.
a threat to validity are possible bugs in the implementations.
as far as possible we used publicly available baseline code.
the parsers the edit script generator gt rted and cd are part of the gt tool .
we also open sourced our code changes and the adaption of cd to use the results of a to make our results reproducible.
after adopting a publicly available jsync implementation to the gt framework all four tree di erencing algorithms produce comparable mappings and edit scripts whose variations are reasonable both with and without the optimizations.
a threat to validity is the manual analysis of the script quality because the participants are members of the same university as the authors.
therefore we make the questionnaires and the raw answers available to allow re evaluation.
.
related work we divide the related work into three categories namely line di erencing tree di erencing and other approaches.
miller and myers describe the basic algorithm that is still used in the di tool.
newer line di erencing approaches also detect moved lines but are still too coarse grained for source code di erencing.
there are several optimal tree di erencing algorithms for ordered trees that do not consider move operations .
bille provides a survey.
cslicer uses a tree di erencing algorithm with heuristics that does not support moves .
rted the currently fastest optimal algorithm has a complexity of o n3 .
we discuss it throughout this paper and in our comparison.
this paper also works with and improves three publicly available tree di erencing algorithms that support moves changedistiller that was created by fluri et al.
based on an algorithm by chawathe et al.
gumtree that already includes aand relies on rted and jsync that uses a line based di to identify unchanged parts of the code but nevertheless still bene ts from a. di ts is another tree di erencing tool that supports moves .
its top down step is similar to a. we are convinced that the general optimizations b epresented in this paper are also useful for di ts.
but because the source code is not publicly available and as the papers are not detailed enough for a fair and competitive re implementation we cannot prove this.
there are also tree di erencing algorithms that are tailored to speci c languages but still can bene t from our ndings.
for example there are several for xml some of which also use ngerprints.
vdi is a tree di erencing algorithm for verilog hdl.
there are also approaches that handle graphs instead of asts e.g.
umldi jdiff dex .
with some adaptations like breaking circles at appropriate places some of our optimizations might also be useful for them.
.
conclusion this work introduces ve general optimizations for tree di erencing algorithms.
we evaluate the performance of the optimizations with four state of the art tree di erencing algorithms gt rted cd and jsync on code from open source archives.
the optimizations shorten the sizes of the edit scripts for of the analyzed les depending on the baseline tree di erencing algorithm used .
we also introduce our novel move optimized tree differencing algorithm mtdiff.
it uses a new approach to identify and map corresponding leaves between the original and modi ed ast.
additionally mtdiff uses a new metric to measure the similarity of inner nodes of the two asts.
our evaluation shows that mtdiff produces even shorter scripts for around of all les independently of the type of ast used.
for reproducibility we open source all the measurements including the questionnaire tree measurements and the source codes com fau inf2 treedi erencing .
.