qtep quality aware test case prioritization song wang jaechang nam lin tan song.wang jc.nam lintan uwaterloo.ca electrical and computer engineering university of waterloo waterloo on canada abstract test case prioritization tcp is a practical activity in software testing for exposing faults earlier.
researchers have proposed many tcp techniques to reorder test cases.
among them coverage based tcps have been widely investigated.
specifically coverage based tcp approaches leverage coverage information between source code and test cases i.e.
static code coverage and dynamic code coverage to schedule test cases.
existing coverage based tcp techniques mainly focus on maximizing coverage while often do not consider the likely distribution of faults in source code.
however software faults are not often equally distributed in source code e.g.
around faults are located in about source code.
intuitively test cases that cover the faulty source code should have higher priorities since they are more likely to find faults.
in this paper we present a quality aware test case prioritization technique qtep to address the limitation of existing coveragebased tcp algorithms.
in qtep we leverage code inspection techniques i.e.
a typical statistic defect prediction model and a typical static bug finder to detect fault prone source code and then adapt existing coverage based tcp algorithms by considering the weighted source code in terms of fault proneness.
our evaluation with variantqtep techniques on different versions of open source java projects shows that qtep could improve existing coverage based tcp techniques for both regression and new test cases.
specifically the improvement of the best variant of qtep for regression test cases could be up to .
and on average .
and for all test cases both regression and new test cases the improvement could be up to .
and on average .
.
ccs concepts software and its engineering software testing and debugging automated static analysis keywords test case prioritization defect prediction static bug finder acm reference format song wang jaechang nam lin tan.
.
qtep quality aware test case prioritization.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
of software engineering paderborn germany september esec fse pages.
introduction modern software constantly evolves as developers make source code changes such as fixing bugs adding new features refactoring existing code etc.
to ensure that the changes do not introduce new bugs regression testing is commonly conducted against existing functionalities.
however regression testing can be expensive.
especially for large projects the regression testing could consume of the overall testing budgets and require weeks to run all test suites .
intuitively test cases that could reveal bugs should be run earlier so that the developers could have more time to fix the revealed bugs and speed up the system delivery.
along this line test case prioritization tcp has been proposed and intensively studied for regression testing .
tcp techniques reorder test cases to maximize a certain objective function typically exploring faults earlier .
tcps also have been widely adopted in industry.
for instance microsoft has deployed systems that support tcp such as echelon and microsoft dynamics ax .
researchers have applied tcp techniques on projects from google and salesforce.com and have shown that tcps could significantly improve the efficiency of regression testing.
many tcp techniques have been proposed such as coveragebased tcps requirement based tcps and change based tcps etc.
coverage based tcps have been shown to outperform other tcps in terms of revealing faults .
a typical coverage based tcp technique leverages coverage information between source code and test cases i.e.
static code coverage static call graph from current version and dynamic code coverage dynamic call graph from the last execution to schedule test cases by maximizing code coverage with different coverage criteria.
coverage based tcps assign higher priorities to test cases that have higher dynamic or static code coverages.
existing tcp techniques often do not take the likely distribution of faults in source code into consideration.
in other words they assume that faults in program source code are equally distributed.
however as reported in existing work the fault distribution in source code is often unbalanced i.e.
around faults are located in about source code .
intuitively test cases that cover the more fault prone code are more likely to reveal bugs so that they should be run with a higher priority.
the goal of this study is to propose a quality aware tcp technique qtep that addresses the above limitation of existing tcps.
we evaluate the quality of source code in terms of fault proneness 523esec fse september paderborn germany song wang jaechang nam lin tan and then we further use the quality information to prioritize test cases.
to achieve the goal qtep gives more weight to fault prone source code so test cases that cover the fault prone code have a higher priority to be executed.
we identify fault prone source code in a software project by using two code inspection approaches i.e.
static bug finders and defect prediction models which are two widely studied approaches in code inspection research to help developers find bugs .
in this study we leverage these two code inspection techniques to improve existing coverage based tcps.
in addition we apply qtep to both regression and new test cases.
most existing tcp techniques only focus on prioritizing regression test cases .
however in real world testing practice the test suite for a modified software system often consists of existing test cases i.e.
regression test cases which are designed to verify whether the existing functionalities still perform correctly after changed and new test cases which are added to test the modification.
during software evolution these two types of test cases are essential for testing the modified software and detecting bugs .
thus we consider both the two types of test cases in this study.
this paper makes the following contributions we propose a novel quality aware tcp technique qtep which leverages two dominant code inspection techniques i.e.
a typical statistic defect prediction model and a typical static bug finder to weight source code in terms of faultproneness.
then qtep adapts existing coverage based tcps by considering the fault proneness of source code.
we conduct an extensive study to compare the performance of qtep with existing coverage based tcps for both regression test cases and new test cases at the class and method level granularities.
we present a rigorous empirical evaluation using versions of open source java projects and explore different variants of the proposed qtep .
results show that qtep could improve existing coverage based tcp techniques for both regression and new test cases.
specifically the improvement of the best variant of qtep for regression test cases could be up to .
and on average .
and for all test cases both regression and new test cases the improvement could be up to .
and on average .
.
the rest of this paper are organized as follows.
section describes the basic background.
section shows the design of qtep .
section shows the setup of our experiments.
section presents the results of our research questions.
section discusses our results and the threats to the validity of this work.
section surveys the related work.
finally we summarize this paper in section .
background .
test case prioritization a typical tcp technique reorders the execution sequence of test cases based on a certain objective e.g.
fault detection rate .
specifically tcp can be formally defined as follows given a test suite tand the set of its all possible permutations pt tcp techniques aim to find a permutation p ptthat p p pt p p f p f p where fis the objective function.most existing tcps leverage coverage information e.g.
dynamic code coverage dynamic call graph from the last run of test cases static code coverage static call graph from static code analysis .
the commonly used coverage criteria include statement method and branch coverages.
in this work we choose to examine statement and method coverages since previous work has shown that statement and method coverages are more effective than other coverage criteria .
for coverage based tcp techniques there are two widely used prioritization strategies i.e.
total strategy and additional strategy .
the total coverage strategy schedules the execution order of test cases based on the total number of statements or methods covered by these test cases.
whereas the additional coverage strategy reorders the execution sequence of test cases based on the number of statements or methods that are not covered by already ordered test cases but covered by the unordered test cases.
in this study we validate whether performances of the coveragebased tcp techniques could be improved by considering the results of code inspection techniques.
the reason we focus on the coveragebased tcp techniques is that they have been widely explored and outperformed most of the other tcp techniques .
in addition we evaluate the state of the art coverage based tcp techniques for both regression and new test cases.
.
code inspection techniques software static code analysis techniques and software defect prediction models are two lines of work to help detect software bugs.
static bug finders e.g.
findbugs pmd and jlint leverage welldefined bug patterns and report likely bug locations in source code.
defect prediction models build machine learning classifiers based on various metrics and predict where defects are likely to occur in the source code .
both techniques are widely used for detecting fault prone code.
rahman et al.
found that these two techniques complement each other to find different bugs.
in this work we examine whether the two code inspection techniques could help improve existing tcp techniques.
.
.
static bug finders.
static bug finders bf detect specific kinds of coding errors such as buffer overflow race conditions and memory allocation errors via programming patterns .
static bug finders mainly include informal heuristic pattern matching approaches and formal verification techniques.
in practice formal verification approaches are not scalable so most static bug finders are pattern based.
typical pattern based bug finders include findbugs pmd and jlint which have been widely used to detect real world software bugs.
previous work has shown that findbugs is more effective than pmd and jlint in terms of detection precision.
since one focus of this study is to explore the feasibility of leveraging the results of static bug finders to improve the efficiency of existing tcp techniques.
thus we only use the representative static bug finder i.e.
findbugs in our experiments.
.
.
software defect prediction.
software defect prediction techniques dp leverage various software metrics to build machine learning models to predict unknown defects in the source code .
based on the prediction results software quality assurance teams can focus on the most defective parts of their projects in advance.
524qtep quality aware test case prioritization esec fse september paderborn germany figure overview of the proposed qtep.vnandvn 1are two versions.
c1tocmare consecutive commits between these two versions that introduce changes to the source code and test cases.
typically defect prediction models could be categorized as supervised or unsupervised models.
most of existing defect prediction models are supervised .
these models leverage past defects from software historical data to build machine learning classifiers and then use the classifiers to predict future bugs.
however not all projects have enough defect data to build a defect prediction model so unsupervised models are also proposed based on the characteristics of defect prediction metrics.
to directly compare qtep to existing tcp techniques we reuse versions from open source java projects from previous tcp studies .
some of these projects do not have well maintained past defects.
this means we do not have enough defect data to build supervised models.
thus we only examine unsupervised defect prediction models in our experiments.
note that our goal of this study is not to find the best defect prediction metrics so we only build defect prediction models with widely used code metrics e.g.
lines of code code complexity metrics and object oriented metrics etc.
we use theunderstand to collect these code metrics.
the work from zhang et al.
contains the full list of these metrics which are described in their table iii.
approach figure illustrates that our approach consists of three steps leveraging code inspection techniques to detect fault prone source code section .
weighting source code based on results from different code inspection approaches section .
and adapting existing tcp techniques and evaluating the results section .
.
.
fault prone code inspection code inspection with findbugs .
given a subject project we directly perform findbugs on its source code without test code to detect potential bugs.
since findbugs only outputs detection results at line level we aggregate the results into method level and class level to meet different tcp granularities.
moreover we consider all detection results grouped by various categories.
findbugs groups detected fault prone code instances into categories such as correctness vulnerability malicious code security multi threadedalgorithm weighting source code units input inspection results at class level cbu y and at method level mbu y .
the sets of all methods mand all statements sto be weighted.
parameters wei ht base wei ht c and wei ht m. output weighted method set mw ei hted and statement set sw ei hted .
initialization set default values for examined code units.
foreach unweighted method mw ei hted iinmw ei hted do mw ei hted i wei ht base end for foreach unweighted statement sw ei hted iinsw ei hted do sw ei hted i wei ht base end for weight methods foreach unweighted method miinmdo ifmiinmbu y then mw ei hted i wei ht m end if ifcbu y contains mithen mw ei hted i wei ht c end if end for weight statements foreach unweighted statement siinsdo ifmbu y contains sithen sw ei hted i wei ht m end if ifcbu y contains sithen sw ei hted i wei ht c end if end for correctness performance bad practice and dodgy code.
the first six types are likely to be real bugs the last two types are refactoring issues.
since bad practice and dodgy code could also fail test cases in this work we use all these reported fault prone code instances as seeds to weight source code.
code inspection with defect prediction model .
similar to static bug finders defect prediction models also predict potential faults in the source code snapshot.
as we described in section .
.
we build unsupervised defect prediction models in this work.
for the unsupervised defect prediction models we use the state ofthe art technique i.e.
clami which achieves comparable performance to supervised models and has been open sourced.
to consider different test case prioritization strategies and scenarios we build clami models at both method and class levels and clami directly outputs the lists of predicted bugs at both levels.
in this study we use all the reported warnings from findbugs or clami to initialize qtep without filtering out any of them.
.
weighting source code units we leverage the detection results from the two code inspection approaches to weight the fault prone source code units.
a code unit could be a statement a branch a method or a class which depends on different test case prioritization strategies.
in this work we focus on weighting statement level and method level code units since we use statement level and method level coverage criteria to examine coverage based tcps section .
.
algorithm shows how to weight statement level and methodlevel code units by using detection results from the code inspection approaches.
note that we use the detected buggy classes and methods by the two code inspection approaches.
initially the algorithm assigns a default weight to all code units i.e.
all statements and methods .
then given a code unit if the class or the method that contains this code unit is detected as buggy the weight of this code unit will be calculated by accumulating the weights of the buggy 525esec fse september paderborn germany song wang jaechang nam lin tan class or the buggy method.
otherwise if the class or the method that contains this code unit is identified as clean its weight will not be updated.
code units that are not covered by any buggy class or method will be assigned the default weight.
parameters in the above algorithm there are three parameters i.e.
wei ht base wei ht c and wei ht mthat could affect the effectiveness of the proposed qtep .
we describe the setup tuning and impact of these three parameters in section .
.
wei ht base is the base weight for all code units i.e.
the default weight for initializing the weights of all code units.
wei ht cis the weight for detected buggy classes by code inspection techniques.
wei ht mis the weight for detected buggy methods by code inspection techniques.
for clami we use the class level prediction results as seeds to weight code units using wei ht c and use the method level prediction results as seeds to weight code units using wei ht m. findbugs outputs detection results at line level with the line level detection results one can assign the reported buggy lines a different weight and further accumulate the lines to weight the involved statements and methods.
while to make the calculation of findbugs consistent with defect prediction models in this work similar to clami we use the classes and methods that contain the detected buggy lines as seeds to weight code units using wei ht candwei ht m respectively.
.
quality aware test case prioritization after weighting all the source code units of a project we then adapt existing coverage based tcp techniques using these weighted code units.
comparing to existing coverage based tcps qtep leverages the quality aware coverage information of test cases.
in this section we show how to calculate the quality aware statement and method coverages of a test case.
a project phasmmethod level code units i.e.
mc1 mc2 ... mcm andsstatement level code units i.e.
sc1 sc2 ... scs .
its test suite t consists of ntest cases i.e.
t1 t2 ... tn .mw ei hted mw1 mw2 ... mwm and sw ei hted sw1 sw2 ... sws are the weight sets for the method level and the statement level code units respectively.
given a test case ti i n we use qmco vera e and qsco vera e to denote its quality aware method coverage and statement coverage respectively.
qmco vera e mx j 1cover ti mcj mwj qsco vera e sx j 1cover ti scj swj where cover ti mcj orcover ti scj is1 if test case ticovers code unit mcjorscj otherwise .mwjandswjare the weights for method level code unit mcjand statement level code unit scj respectively.
note that to calculate the quality aware coverages for test cases one could leverage different coverage information i.e.
dynamic coverage and static coverage information and different code inspection techniques i.e.
findbugs and clami .
with the quality aware coverages i.e.
qmco vera eandqsco vera e of each test case qtep further prioritizes test cases with different prioritization strategies i.e.
total and additional .table experimental subject programs.
vpair denotes a version pair.
rtc rtm and rf are the number of regression test classes regression test methods and regression faults respectively.
ntc ntm and nf are the number of new test classes new test methods and mutation faults for new test cases respectively.
no.
project vpair rtc rtm rf ntc ntm nf p1 time money .
.
p2 time money .
.
p3 mime4j .
.
p4 mime4j .
.
p5 jaxen .0b7 .0b9 p6 jaxen .1b6 .1b7 p7 jaxen .1b9 .1b11 p8 xml security .
.
p9 xstream .
.
p10 xstream .
.
p11 xstream .
.
p12 xstream .
.
p13 xstream .
.
p14 xstream .
.
p15 commons lang .
.
p16 commons lang .
.
p17 joda time .
.
p18 joda time .
.
p19 joda time .
.
p20 joda time .
.
experimental setup .
research questions we answer the following research questions to evaluate the performance of the proposed qtep .
rq1 .
isqtep more effective than the state of the art coveragebased tcps for regression test cases only?
rq2 .
isqtep more effective than the state of the art coveragebased tcps for all test cases both regression and new test cases ?
rq3 .
how effective are the variants of qtep combined with static bug finders versus defect prediction models in terms of improving existing tcp techniques?
rq4 .
how effective are static bug finders versus defect prediction models in identifying buggy code units defined by test cases for tcp?
inrq1andrq2 we explore the effectiveness of qtep for regression test cases and all test cases respectively.
in rq3 we aim to understand the performance of the two different types bf based anddp based of qtep variants.
in rq4 we investigate the performance of static bug finders and defect prediction models in terms of identifying buggy code units defined by test cases for tcp.
.
supporting tools in this study we focus on coverage based tcps which require both dynamic and static code coverage information of test cases.
to collect dynamic code coverage following existing work we use the asm bytecode manipulation and analysis framework under faulttracer tool to collect the dynamic code coverage information for test cases.
to collect static code coverage following existing work we use the wala framework to collect the static call graphs for the test cases and traverse the call graphs to obtain the involved methods and statements for each test method and test class.
526qtep quality aware test case prioritization esec fse september paderborn germany table the experimental scenarios for tcps in this work.
test granularities test case types method m regression test cases r class c regression new test cases rn all the test prioritization techniques have been implemented in java and all the experiments were carried out on a .0ghz i5 desktop with 6gb of memory.
.
subject systems test cases and faults to facilitate the replication and verification of our experiments we choose versions from open source java projects which are widely utilized as benchmarks to address real world test case prioritization problem .
table lists all the projects and the detailed statistical information.
the sizes of these systems vary from .7k loc time money to .1k loc joda time .
for regression test cases following existing work for each listed version pair we use the real world regression faults for regression test cases.
each version pair has at least one real world regression fault which will crash at least one regression test case on the later version.
for example there are regression faults rf in the project p11in table .
since not all benchmark projects have faults for new test cases following existing work we use mutation faults when considering the new test cases.
we generate mutation faults using a set of carefully selected mutation operators e.g.
logical arithmetic statement deletion etc.
specifically we use the major mutation tool to generate these mutation faults for new test cases.
note that not all generated mutation faults can be revealed by test cases thus we use a subset of detected faults obtained by further running major with all test cases.
for each project we randomly select mmutation faults killed by new test cases only.
we set mto be equal to the number of regression faults to simulate the real world testing scenario.
to mitigate the randomness we repeat this process times.
for instance we randomly select mutation faults and repeat this times as nf of p11in table .
thus we have fault version pairs for each of experimental subjects when considering new test cases.
.
evaluation measure we use the average percentage fault detected apfd a widely used metric for evaluating the performance of tcp techniques.
apfd measures the average percentage of faults detected over the life of a test suite and is defined by the following formula apfd pnum f i 1t fi num t num f num t where num tdenotes the total number of test cases num fdenotes the total number of detected faults and t fi i num f denotes the smallest number of test cases in sequence that need to be run in order to expose the fault i. apfd values range from to .
for any given test suite its num tandnum fare fixed.
the higher apfd value signals that the average value of t fiis lower and thus represents a higher fault detection rate.
.
experimental scenarios table shows the tcp scenario options in our experiments.
by combining these options four differenttcp scenarioscan betable the experimental independent variables of qtep.
iv1 coverage techniquesiv2 coverage criteriaiv3 prioritization strategiesiv4 code inspection techniques dynamic d method m total t bug finders bf static jupta j statement s additional a defect prediction dp defined.
we first conduct tcp at two different granularity levels i.e.
method m and class c .
in addition following existing work we also conduct tcp for regression test cases only r and all test cases regression and newly added test cases rn .
running regression test cases only or running all the test cases are two practical testing activities during software evolution .
based on the combinations of these settings the four scenarios are defined as follows regression test method m r regression test class c r all test method regression and newly added m rn and all test class regression and newly added c rn .
in section we report apfd values for these four scenarios.
table shows the four independent variables ivs used in our experiments that could affect tcp performance in terms of apfd iv1 coverage techniques .
for examining the tcp performance of qtep we use two representative coverage techniques from the existing coverage based tcp techniques.
dynamic coverage based tcp is based on the information of the dynamic call graph from the latest run of a subject project.
we use test coverage information based on the dynamic call graph to prioritize test cases.
static coverage based tcp ranks test cases based on the information from static call graph.
jupta is the state ofthe art static coverage based tcp technique .
we use jupta as a representative static coverage based tcp technique for the experiments.
iv2 coverage criteria .
since all the studied techniques rely on code coverage information we also investigate the influence of coverage criteria.
we study two widely used coverage criteria method coverage statement coverage.
iv3 prioritization strategies .
as we described in section .
thetotal strategy and additional strategy are widely used in most existing studies to schedule the execution order of test cases .
thus we also investigate the influence of these two different prioritization strategies.
iv4 code inspection techniques .
we consider two types of code inspection techniques for detecting fault prone source code and weighting source code units.
they are static bug finder i.e.
findbugs and statistical defect prediction model i.e.
clami .
we can form combinations from the first three ivs iv1 to iv3 from the existing tcp techniques as baselines.
the iv1 iv2 and iv3 in table represent technical options that we can select from the existing coverage based tcp techniques.
based on acronyms for iv options in table we can list the combinations as follows dmt i.e.
dynamic method coverage with total strategy dma dst dsa jmt jma jst and jsa.
we also use the random tcp as a baseline.
the random tcp runs all the test cases randomly therefore the performance of the random tcp might vary across different runs.
to mitigate the randomness we run the random tcp times on each subject and obtain the average performance in apfd.
following existing work we denote the random tcp technique as rt.
527esec fse september paderborn germany song wang jaechang nam lin tan 50jmt dp wcjmt dp wmjmt bf wcjmt bf wmjma dp wcjma dp wmjma bf wcjma bf wm actual values of wei htcandwei htm a 60dmt dp wcdmt dp wmdmt bf wcdmt bf wmdma dp wcdma dp wmdma bf wcdma bf wm actual values of wei htcandwei htm b figure the distribution of the best wei ht c wc and wei ht m wm for the variants of qtep that are adapted from static coverbased tcps a and dynamic coverage based tcps b .
the iv4 is a technical option in qtep for detecting buggy code and further weighting source code units.
by combining all ivs including iv4 we can define variants of qtep .
based on acronyms for iv options in table the 16variants ofqtep aredmt bf dma bf dst bf dsa bf jmt bf jma bf jst bf jsa bf dmt dp dma dp dst dp dsa dp jmt dp jma dp jst dp and jsa dp .
to investigate the tcp performance of qtep we compare the combinations from iv1 iv3 and rtto the variants in section .
.
parameter setting as presented in section .
our algorithm for weighting source code has three parameters i.e.
wei ht base default weight for all code units wei ht c weight for detected buggy classes and wei ht m weight for detected buggy methods .
different weights of these parameters could significantly affect the performance of qtep .
in this section we study the impact of the three parameters of qtep on the performance of prioritizing both regression and all test cases both regression and new test cases .
specifically for regression test cases we select the first version pair from each project listed in table as experimental subjects.
when considering both regression and new test cases we randomly selected faulty versions from the first version pair of each project as experimental subjects.
we then tune the parameters for each project using each of the variants in qtep described in .
and evaluate the specific values of the parameters by the average apfd scores at the class and the method levels with or without new test cases .
for simplifying the tuning process we set wei ht base equal to .
then we set wei ht cequal to c wei ht base andwei ht m equal to m wei ht base we experiment candmwith a range from to .
we use all the combinations of the three weightsin the tuning process which includes project variants of qtep experiments for regression test cases and project mutation fault version variants of qtep experiments for all test cases regression and new test cases .
figure a and figure b show the distribution of the best values of parameters wei ht candwei ht mfor all the variants ofqtep on the version pairs.
we could see that the best values of wei ht candwei ht mvary dramatically for different projects.
on average for variants of qtep that are adapted from static coveragebased tcps wei ht cis16.
times of wei ht base andwei ht m is13.
times of wei ht base.
for variants of qtep that are adapted from dynamic coverage based tcps wei ht cis18.
times of wei ht base andwei ht mis11.
times of wei ht base.
in this work we use the best values of wei ht candwei ht m that are obtained from the first version pair of a project as default parameters for all the left version pairs of this project.
note that since project xml security only has one available version pair from the existing benchmark dataset thus for this project we tune parameters and report the performance on the same version pair.
results .
rq1 rq2 performance of qtep for regression and all test cases figure and figure show the comparison results in the four scenarios on each of the version pairs.
specifically they show the boxplots of the apfd values for the variants of qtep the eight variants of coverage based tcps and the random baseline rtin the four scenarios.
each sub figure presents the detailed apfd results of one type of qtep i.e.
static coverage based or dynamic coveragebased variants of qtep and the corresponding baseline tcps on a specific scenario.
for example figure a shows the c r regression test class scenario of static coverage based techniques rt and static coverage based variants of qtep while figure a shows the c r scenario of dynamic coverage based techniques rt and dynamic coverage based variants of qtep .
each boxplot presents the apfd distribution median and upper lower quartiles of prioritization results of one variant of qtep on the version pairs.
we use gray white yellow blue and red boxes to represent the random static coverage based dynamic coverage based dp based qtep and bf based qtep techniques respectively.
the figures show that overall both dp based and bf based variants of qtep could outperform corresponding traditional coverage based tcps and and rt for both regression test cases and new test cases at both method level and class level tcps.
in addition static coverage based variants of qtep techniques are overall more effective than dynamic coverage based variants of qtep .
specifically for c r among all examined tcp techniques jmt bf produces the best apfd with a median value of .
which is almost higher than the best traditional coverage based technique i.e.
jmt.
for m r jmt bf outperforms all other examined tcps.
while considering new test cases jma bf andjst bf produce the best performance for c rn and m rn respectively.
we further take a closer look at each individual program.
to save space we only show the detailed comparison between the results of static coverage based variants of qtep and the results 528qtep quality aware test case prioritization esec fse september paderborn germany rt jmt jmt dp jmt bf jma jma dp jma bf jst jst dp jst bf jsa jsa dp jsa bf00.
.
.
.81apfd a c r rt jmt jmt dp jmt bf jma jma dp jma bf jst jst dp jst bf jsa jsa dp jsa bf00.
.
.
.81apfd b m r rt jmt jmt dp jmt bf jma jma dp jma bf jst jst dp jst bf jsa jsa dp jsa bf00.
.
.
.81apfd c c rn rt jmt jmt dp jmt bf jma jma dp jma bf jst jst dp jst bf jsa jsa dp jsa bf00.
.
.
.81apfd d m rn figure results of static coverage based variants of qtep and static coverage based tcps i.e.
random static coverage based tcps defect prediction based variants of qtep and bug finder based variants of qtep rt dmt dmt dp dmt bf dma dma dp dma bf dst dst dp dst bf dsa dsa dp dsa bf00.
.
.
.81apfd a c r rt dmt dmt dp dmt bf dma dma dp dma bf dst dst dp dst bf dsa dsa dp dsa bf00.
.
.
.81apfd b m r rt dmt dmt dp dmt bf dma dma dp dma bf dst dst dp dst bf dsa dsa dp dsa bf00.
.
.
.81apfd c c rn rt dmt dmt dp dmt bf dma dma dp dma bf dst dst dp dst bf dsa dsa dp dsa bf00.
.
.
.81apfd d m rn figure results of dynamic coverage based variants of qtep and dynamic coverage based tcps.
i.e.
random dynamic coverage based tcps defect prediction based variants of qtep and bug finder based variants of qtep of the corresponding coverage based tcps since they are overall more effective than dynamic coverage based variants of qtep .
the comparison between the dynamic coverage based variants of qtep and the corresponding coverage based tcps is also available online .
table shows the average apfd values of all static coveragebased variants of qtep and the corresponding coverage based tcps on each project.
numbers in brackets are the improvements of dp based and bf based variants of qtep compared to corresponding coverage based tcps.
we can see that bf based variants of qtep improve the apfd values for all the projects.
however the improvement varies on different projects.
for example on project time money jsa bf achieves the best apfd for c r i.e.
.
which is percentage points higher than the correspondingjsa i.e.
.
.
while on xstream the improvement is only percentage point.
in the worst case e.g.
jsa dp qtep does not improve traditional coverage based tcps.
the same phenomenon is also observed in dynamic coverage based variants of qtep .
the variations of improvements depending on different projects might be because the performance of fault detection varies on different projects.
to explore this we further compute the spearman correlation between the false positive rates and the improvements ofdp based and bf based qtep on all projects.
results show that the spearman correlation values for the false positive rates and the improvements of dp based and bf based qtep are .
and .
respectively.
this indicates that the performance of qtep on each project is negatively correlated with the false positive rate of the investigated code inspection technique on this project.
in addition figures i.e.
figure and figure show that all static coverage based variants of qtep generate better results than rtand the improvement ranges from to percentage points.however we also note that the performance of dynamic coveragebased variants of qtep has a dramatically decline when considering m rn and c rn compared to static coverage based variants of qtep and cannot even outperform rt.
for example the apfd of dsa dp in m rn is only .
which is percentage points lower than rt.
this is because the dynamic coverage information comes from the last execution of the test suite which does not contain the new test cases.
thus the faults that can be revealed only by the new test cases are ignored since the coverage information of new test cases is always unavailable in the dynamic coverage based tcps .
while static coverage information of both regression and new test cases could be obtained by static code analysis.
thus the performances of static coverage based variants of qtep are similar between with and without the new test cases.
for statistical tests we also conduct the wilcoxon signed rank test p .
to compare the performance of qtep and existing tcps.
specifically we compare each variant of qtep with its corresponding coverage based tcp technique on all projects for both regression and new test cases.
results show that eight of the variants of qtep could achieve significantly better performance than the corresponding coverage based tcps i.e.
jmt dp jmt bf jst bf jsa bf dmt bf dst bf dsa dp and dsa bf .
for the other eight variants their performances are slightly better or equal to the corresponding coverage based tcps.
in summary qtep is overall more effective than the corresponding coverage based tcp techniques.
while dynamiccoverage based qtep variants exhibit significantly better performance on regression test cases than on all test cases staticcoverage based qtep variants produce similarly good performance on both regression test cases and all test cases both regression and new test cases .
529esec fse september paderborn germany song wang jaechang nam lin tan table comparison between the static coverage based variants of qtep and the corresponding coverage based tcps for each project subject scenario jmt jmt dp jmt bf jma jma dp jma bf jst jst dp jst bf jsa jsa dp jsa bf time moneyc r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mime4jc r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jaxenc r .
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xml securityc r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
xstreamc r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
commons langc r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
joda timec r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
rq3 comparison between the two categories of qtep s variants in order to answer rq3 we first weight all source code units with the detection results from both defect prediction models and findbugs using algorithm .
note that in algorithm we use the tuned best values of wei ht candwei ht m details are in section .
for each project under different code inspection techniques.
we then run all variants of qtep on all version pairs p1 p20 .
as we stated in section different from most of the existing tcp related studies mainly focused on regression test cases in this work we extensively explore the performance of qtep on both regression test cases and all test cases.
thus for each versionpair we perform experiments on four different scenarios m r c r m rn and c rn details are in section .
.
table and table present the average apfds of all the variants of qtep on the four different scenarios of the versionpairs.
we conduct the wilcoxon signed rank test p .
to compare the performance of bf based and dp based variants of qtep .
between these two variants better apfd values with statistical significance are shown with an asterisk in table and table .
results show that overall bf based variants of qtep are significantly better than dp based variants.
the improvement could be up to percentage points jmt bf .
vs jmt dp .
in m r of table .
specifically jmt bf outperforms all the other variants ofqtep in terms of the average apfd at m r i.e.
.
c r i.e.
.
m rn i.e.
.
and c rn i.e.
.
.
one possible reason is bfhas a lower false positive rate than dp details are in section .
.
we further investigate whether the apfds of different variants ofqtep vary with the false positive rates of the two code inspection techniques.
specifically we compute the spearman correlation between the false positive rates and the apfd values of these twotable the average apfds of the variants of qtep that are adapted from static coverage based tcps.
scenario jmt dp jmt bf jma dp jma bf jst dp jst bf jsa dp jsa bf c r .
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
table the average apfds of the variants of qtep that are adapted from dynamic coverage based tcps.
scenario dmt dp dmt bf dma dp dma bf dst dp dst bf dsa dp dsa bf c r .
.
.
.
.
.
.
.
m r .
.
.
.
.
.
.
.
c rn .
.
.
.
.
.
.
.
m rn .
.
.
.
.
.
.
.
categories of qtep i.e.
dpandbf based variants.
the high correlation value .
indicates that the accuracy of different variants ofqtep has a negative correlation with the false positive rates of the investigated code inspection techniques.
this explains why bf based variants of qtep perform slightly better than dp based variants.
overall bf based variants of qtep are more effective than dp based variants for both regression test cases and all test cases both regression and new test cases .
.
rq4 effectiveness of findbugs and defect prediction models to answer rq4 we first collect the failure trace of each failed test case on each version pair and then we parse the failure traces to label all involved source classes and methods as buggy.
source classes and methods that are not involved are labeled as clean.
we then use defect prediction models and findbugs to identify buggy code units on the later version of each of the version pairs.
530qtep quality aware test case prioritization esec fse september paderborn germany table the performance of clami and findbugs on revealing buggy code units.
pis precision and ris recall.
granularityclami findbugs p r p r class .
.
.
.
method .
.
.
.
class level method level0.
.
.9false positive ratefindbugs clami figure false positive rates of the two code inspection techniques note that we label buggy source classes and methods using the failure traces of failed test cases instead of posted bug reports .
this might make the ratio of buggy classes and methods quite small.
for instance when labeling version pair .
.
of commonslang only out of classes and out of methods are labeled as buggy.
that is because there is only one failed test case among all regression test cases.
such a limited number of labeled buggy classes and methods could make the different performances between our study and the previous studies on defect prediction and bug finders .
to measure the performance of the two code inspection techniques we use precision andrecall which are widely used to evaluate defect prediction models and bug finders .
precision is the percentage of correctly identified buggy code units in all the code units which are identified buggy and recall is the percentage of correctly identified buggy code units in all the real buggy code units.
to show the overall performance we use the weighted average precision and recall following existing work .
table summarizes the weighted average performance of clami and findbugs on the version pairs listed in table .
specifically we could see that clami has better recall values than findbugs at both class and method levels.
however clami has smaller precision values than findbugs.
this implies clami may generate more false positives.
we further show the false positive rates in figure from which we could see that at both class level and method level clami has a .
higher false positive rate.
in summary defect prediction models identify more buggy code units while findbugs has a lower false positive rate.
.
time and memory overhead comparing with traditional coverage based tcps the extra running overhead of qtep depends on the applied code inspection techniques i.e.
defect prediction models and bug finders and our source code weight algorithm.
to understand the overhead of qtep we collect the time and space costs for all experiments and details are presented in table .
we can see that the total execution time for weighting source code running defect prediction models and findbugs varies from .
to .
seconds.
the largest project intable the average time cost of qtep on each subject.
subjecttime s defect prediction findbugs weighting code time money .
.
.
mime4j .
.
.
jaxen .
.
.
xml security .
.
.
xstream .
.
.
commons lang .
.
.
joda time .
.
.
.
.
a overlap at class level.
.
.
b overlap at method level.
figure the overlaps between findbugs and clami .
terms of the number of test cases joda time uses .5mb of memory.
as shown in the table code inspection techniques spent more time than weighting source code units.
the total time cost on each project is less than minutes.
overall the results demonstrate qtep s practical aspect.
discussion .
does the combination of bfand dpachieve better performance for tcp?
in this work we have explored the feasibility of leveraging the results of both static bug finders and statistical defect prediction models to improve testing efficiency.
as shown in section .
both bf based and dp based variants of qtep could improve coveragebased tcps.
in this section we further examine whether combining the detection results of bfand dpcould achieve better results.
specifically following the described process of qtep in section we use the combination of detection results of the two code inspection techniques to tune and weight source code units.
and then we run the new eight adapted from both dynamic and static coveragebased tcps variants of qtep on the version pairs.
note that we experiment with two combinations i.e.
union and intersection.
overall the intersection combination produces better performance than the union combination.
when comparing with bfbased and dp based variants of qtep results show that the unioncombination based qtep has a similar performance to dp based qtep we further perform one way anova analysis at the significance level of .
to investigate whether there is a significant difference between the performance of these two approaches.
the high p .
indicates that there is no significant difference between the union combination based and dp based qtep .
in addition the intersection combination based and bf based qtep perform similar also our anova test shows there is no significant difference between them.
the above results suggest that both the union combinationbased and the intersection combination based qtep cannot outperform bf based qtep.
to explore this issue we further show the overlaps between detection results of bfanddpin figure .
we could see that at the class level over detected buggy classes by findbugs are overlapped 531esec fse september paderborn germany song wang jaechang nam lin tan with the buggy classes detected by clami while the overlaps account for only of the detected buggy classes in clami.
at the method level about predicted buggy methods are overlapped with findbugs however the overlaps only account for up to of the detected buggy methods in clami.
consequently the detection result of the union set from findbugs and clami is quite similar to the result of clami.
while the detection result of the intersection set is similar to the result of findbugs.
this could help explain why the union combination based qtep anddp based qtep produce similar results and the intersection combination based qtep has similar performance to bf based qtep .
.
practical guidelines for tcp our study reveals several interesting findings that can serve as the practical guidelines for improving test efficiency.
for different scenarios.
overall both dynamic and staticcoverage based variants of qtep are applicable for improving prioritization of regression test cases.
while for prioritizing all test cases both regression and new test cases we only recommend static coverage based qtep since dynamic coverage based qtep cannot handle new test cases well.
for different projects.
as we described in section .
the performance of qtep on a project is negatively correlated with the false positive rate of the used code inspection technique on this project.
thus users could choose either dp based or bf based qtep by considering their false positive rates on the history data of this project.
while for new projects no history data are available we recommend bf based qtep since our experiment results show that dptends to have a higher false positive rate than bf.
.
threats to validity internal validity.
the proposed qtep leverages two code inspection techniques to help regression testing.
an assumption behind this combination is that the bugs detected by each of them are largely different.
our manual inspection confirms this assumption e.g.
all the bugs in the dataset cannot be detected by findbugs.
some bugs are project specific bugs that could be revealed by regression testing only.
note that our work also suggests that using each technique alone could complement each other to detect more bugs.
the success of the proposed approach may also depend on the effectiveness of the static bug finder i.e.
findbugs and the defect prediction model i.e.
clami.
with different static bug finders or different defect prediction models the performance of qtep may vary.
to evaluate the quality of prioritization we choose apfd which has been extensively used in the field of tcp.
however apfd can not reflect time and space costs or the severity of faults.
we plan to use more metrics e.g.
apfdc to reduce this threat.
external validity.
in this work all the experiment subjects are open source projects and written in java with junit test cases.
although they are popular projects and widely used in tcp research our findings may not be generalizable to commercial projects or projects in other languages.
to mitigate this threat we plan to explore the effectiveness of qtep on c c projects in the future.
related work many regression testing techniques have been proposed for improving test efficiency by test case prioritization test case selection and test case reduction .
in terms of tcp techniques rothermel et al.
first presented a family of prioritization techniques including both the total and additional test prioritization strategies using various coverage information.
a majority of existing tcps leverage code coverage information to rank test cases.
dynamic code coverage from the last execution is widely used in existing tcp techniques .
another widely used code coverage is static code coverage which is estimated from static analysis.
mei et al.
are the first to prioritize test cases with static coverage information.
some other tcp techniques leveraged similarity between test cases and source code to prioritize test cases.
specifically saha et al.
proposed an information retrieval approach for regression testing prioritization based on program changes.
noor et al.
proposed a similarity based approach for test case prioritization using historical failure data.
instead of using the coverage or similarity information between source code and test cases some approaches use other software process information as the proxy to rank test cases .
arafeen et al.
used software requirements to group and rank test cases.
engstrom et al.
selected a small set of test cases for regression testing selection based on previously fixed faults.
their work required previously revealed bugs within a given period.
for projects that do not have well maintained bugs or new projects no past bugs are available their approach cannot work.
while qtep does not have such limitation since it focuses on potentially unrevealed faults.
laali et al.
proposed to utilize the locations of revealed faults of the executed test cases to rank the remaining test cases.
different from qtep they used injected faults and the performance of their approach on real world faults is unknown.
yu et al.
proposed the fault based prioritization of test cases that is designed by using the fault based test case generation models.
different from qtep their approach assumed the fault detecting ability of each test case is available.
miranda et al.
proposed scope aided tcp for testing the reused code by using possible constraints delimiting the new input domain scope.
on the contrary qtep is not limited to testing the reused code.
conclusion in this paper to address the limitations of existing tcp algorithms we present a quality aware tcp technique named qtep .
specifically we leverage code inspection techniques i.e.
statistical defect prediction models and static bug detection techniques to detect faultprone source code and then adapt existing coverage based tcp algorithms by considering the weighted defectiveness of source code.
our evaluation shows that qtep could improve existing coveragebased tcp techniques for both regression test cases and all test cases.
as future work we plan to explore the impact of faultrevealing capability of test suites and the severities of different bugs on the performance of qtep .
we also plan to investigate the different aggregations of code inspection results in qtep .