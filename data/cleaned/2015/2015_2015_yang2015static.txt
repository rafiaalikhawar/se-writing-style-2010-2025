static control flow analysis of user driven callbacks in android applications shengqian yang dacong yan haowei wu yan wang and atanas rountev ohio state university email fyangs yan wuhaow wang10 rountev g cse.ohio state.edu abstract android software presents many challenges for static program analysis.
in this work we focus on the fundamental problem of static control flow analysis.
traditional analyses cannot be directly applied to android because the applications are framework based and event driven.
we consider user eventdriven components and the related sequences of callbacks from the android framework to the application code both for lifecycle callbacks and for event handler callbacks.
we propose a program representation that captures such callback sequences.
this representation is built using contextsensitive static analysis of callback methods.
the analysis performs graph reachability by traversing context compatible interprocedural control flow paths and identifying statements that may trigger callbacks as well as paths that avoid such statements.
we also develop a client analysis that builds a static model of the application s gui.
experimental evaluation shows that this context sensitive approach leads to substantial precision improvements while having practical cost.
i. i ntroduction in recent years the growth in the number of computing devices has been driven primarily by smartphones and tablets.
for such devices android is the dominating platform.
a recent report estimates that more than .
billion android devices will be shipped in and this number will be larger than the combined number of all shipped windows ios macos pcs notebooks tables and mobile phones .
the widespread use of android software presents numerous challenges for software engineering researchers.
one such challenge is to establish a solid foundation for software understanding checking and transformations.
static program analysis is an essential component of such a foundation.
in this work we focus on a fundamental static analysis controlflow analysis .
data flow analysis is based on some controlflow representation and our work also has direct implications for the design of data flow analyses.
traditional control flow analysis cannot be directly applied to android applications because they are framework based and event driven.
the application code and the android platform interact through callbacks calls from the platform s event processing code to the relevant callback methods defined in the application code.
a rich variety of callbacks is defined by the android framework model for events such as component creation termination user actions device state changes etc.
we focus our analysis on a key aspect of this control flow the lifecycle and interactions of user event driven application components .
the first step of our work is to formulate thiscontrol flow analysis problem in terms of the traditional concepts of interprocedural control flow analysis thus providing a foundation for reasoning about run time semantics and its static analysis approximations.
in essence the controlflow analysis problem can be reduced to modeling of the possible sequences of callbacks.
next we propose a program representation that captures such callback sequences.
this representation referred to as a callback control flow graph ccfg together with the notion ofvalid paths in this graph is the output of the control flow analysis.
we then present an algorithm for ccfg construction.
the algorithm considers user driven components such as activities dialogs and menus and analyzes the corresponding lifecycle and event handling callback methods.
the analysis of each callback method and the code transitively invoked by it determines what other callbacks may be triggered next.
this information provides the basis for ccfg construction.
the key technical insight for the design of our algorithm is that a callback method must be analyzed separately for different invocation contexts associated with it .
for example an event handler method could process user events for several different widgets and may have a different behavior for each separate widget.
our context sensitive analysis employs a form of graph reachability that traverses context compatible controlflow paths and identifies statements whose execution may trigger subsequent callbacks as well as paths that avoid such statements.
through examples and experimental studies we show the importance of this form of context sensitivity.
the proposed analysis can be a component of various other static analyses e.g.
for software checking .
we consider one such client the automated generation of static gui models which are important for program understanding and test generation.
the ccfg can be easily transformed into a certain kind of gui model used in prior work e.g.
and possible sequences of user gui events can be derived from valid paths in the model.
using applications we performed an experimental evaluation whose results can be summarized as follows.
first the analysis cost is suitable for practical use in software tools.
second the use of context sensitive analysis results in substantial precision improvements.
third in six case studies we compared the produced gui models against the perfectlyprecise manually constructed solution as well as the solution from a dynamic analysis tool .
this comparison indicates high analysis precision with three of the case studies ex hibiting perfect precision and the rest providing insights into potential precision improvements for future work.
contributions.
the contributions of this work are formulation of the control flow analysis problem for lifecycle and event handling callbacks definition of the ccfg a program representation that encodes the solution to this problem algorithm to build the ccfg through context sensitive control flow analysis of callback methods technique to build and traverse static gui models based on the ccfg evaluation on applications as well as detailed case studies using six of these applications the ccfg definition and the analysis algorithms are novel contributions to the best of our knowledge this is the first effort to perform context sensitive analysis of android callback behavior and to encode the resulting control flow information.
this is also the first work to perform fully static generation of gui models for android.
the analysis implementation is publicly available as part of the g ator analysis toolkit .
ii.
c ontrol flow analysis for android our work targets a fundamental problem static control flow analysis.
since data flow analysis must model the program s control flow in addition to the data flow domain control flow analysis is also a key component of data flow analysis.
a. background the standard program representation for such analysis is theinterprocedural control flow graph icfg .
this graph combines the control flow graphs cfgs of the program s procedures.
nodes correspond to statements and intraprocedural edges show the control flow inside a procedure.
the cfg for a procedure phas a dedicated start node spand a dedicated exit nodeep.
each call is represented by two nodes a call site nodeciand a return site node ri.
there is an interprocedural edgeci!spfrom a call site node to the start node of the called procedurep there is also a corresponding edge ep!ri.
an icfg path that starts from the entry of the main procedure is valid if its interprocedural edges are matched i.e.
each riis matched with the corresponding ci .
the goal of control flow analysis is to determine the set of all valid paths.
in an actual analysis some abstractions of such paths are typically employed.
still at its essence control flow analysis needs to find and abstract all valid paths.
for a framework based platform such as android there is no main procedure from which control flow paths start.
the interaction between an application and the platform is through callbacks the high level view of the control flow is as a sequence of calls from unknown platform code to specific application methods.
this is a key challenging aspect of android control flow analysis and the focus of our work.
thus we consider abstracted icfg paths in which only interprocedural edges to from callback methods are represented and all other edges are abstracted away.
in this case a path consists of edgesci!smandem!riwhereciis a call site node inthe platform code that invokes an application defined callback methodm andriis the return site node corresponding to ci.
the android framework defines thousands of callbacks for a variety of interactions.
we focus on an essential aspect of this control flow the lifecycle and interactions of user event driven components.
the components of interest are activities dialogs andmenus .
each such component is represented by a separate gui window.
we consider two categories of callbacks.
lifecycle callbacks manage the lifetime of application components.
the most important examples are callbacks to manage activities.
lifecycle methods such as oncreate and ondestroy are of significant interest because management of the activity lifecycle is an essential concern for developers e.g.
to avoid leaks .
lifecycle callbacks for activities dialogs and menus define major changes to the visible state and to the possible run time events and behavior.
gui event handler callbacks respond to user actions e.g.
clicking a button and define another key aspect of the control flow.
these event handlers perform various actions including transitions in the application logic e.g.
terminating an activity and returning back to the previous one .
control flow analysis of such handlers is essential for an event driven platform.
for these two categories of callbacks the execution of a callback method micompletes before any other callback methodmjis invoked.
as discussed later mimay cause the subsequent execution of mj.
thus the abstracted controlflow paths are always of the form ci!smi emi!ri cj!
smj emj!rj ck!smk emk!rk and will be represented simply as mimjmk wheremiis the callback method invoked by ci.
thus in this work we are interested in a version of control flow analysis which produces all valid sequences of method callbacks for component lifecycles and event handling.
we aim to model only a single application inter application control flow is beyond the scope of this work.
b. example from an android application figure shows a simplified example derived from openmanager an open source file manager for android.
class main defines an activity an application component responsible for displaying a gui window and interacting with the user.
method oncreate is an example of a lifecycle callback method it is invoked by the android platform when the activity is instantiated.
the structure of the new window is defined by file main.xml shown at the bottom of the figure.
in this simplified example the layout contains four gui widgets each one being a button with an image that can be clicked.
the call to setcontentview at line instantiates these widgets together with their linearlayout container and associates them with the main activity.
the loop at lines iterates over the programmatic button ids and associates the buttons with a listener object the eventhandler created at line .
the listener class defines an event handling method onclick which is invoked by the android platform when the user clicks on a button.
the button that was clicked is provided as parameter vofonclick .
the event handler may start a new activity an instance of directoryinfo when v1 public class main extends activity private eventhandler mhandler public void oncreate this.setcontentview r.layout.main mhandler new eventhandler this int img button id r.id.info button r.id.help button r.id.manage button r.id.multiselect button for int i i img button id.length i imagebutton b imagebutton findviewbyid img button id b.setonclicklistener mhandler public class eventhandler implements onclicklistener private final activity mactivity public eventhandler activity activity mactivity activity public void onclick view v switch v.getid case r.id.info button intent info new intent mactivity directoryinfo.class mactivity.startactivity info break case r.id.help button intent help new intent mactivity helpmanager.class mactivity.startactivity help break case r.id.manage button alertdialog.builder builder ... alertdialog dialog builder.create dialog.show break default ... break main.xml linearlayout imagebutton android id id info button imagebutton android id id help button imagebutton android id id manage button imagebutton android id id multiselect button linearlayout fig.
example derived from openmanager is the info button line or of helpmanager when vis the help button line .
in both cases an intent triggers the activation this is the standard android mechanism for starting a new activity.
the call to startactivity posts an event on the framework s event queue.
after onclick completes this event is processed a callback to oncreate is executed on the new activity and a new window is displayed.
when vis the manage button a new dialog window is created and displayed at line .
this window is an instance of a alertdialog and is used to show several selectable items e.g.
to manage the running process or to back up applications to the sd card .
the creation of the dialog is performed through helper object builder .
finally when v is the multi select button the displayed window remains the one associated with activity main but its visual representation changes line details of this change are omitted.
control flow analysis for this application needs to capture the ordering relationship between oncreate and onclick the event handler method may be invoked immediately after oncreate completes its execution.
similarly control flow analysis needs to capture the ordering rela tionship between onclick anddirectoryinfo.oncreate helpmanager.oncreate and alertdialog.oncreate .
in addition because it is possible that the default branch of the switch statement is taken the next callback after onclick could be another invocation of onclick .
note that the flow of control triggered by onclick is context sensitive depending on the widget parameter v different sequences of callbacks may be observed.
from prior work on control flow reference analysis of object oriented programs e.g.
it is well known that context sensitivity has significant precision benefits.
one effective way to introduce context sensitivity is to model the parameters of a method invocation including this .
based on this observation we propose a new form of context sensitive control flow analysis of callback methods.
for this example a context insensitive analysis would conclude that the execution ofonclick could be followed by execution of any one of the other four callbacks.
however a context sensitive analysis will report that for example onclick will be followed by helpmanager.oncreate only when vwas the help button.
c. problem definition consider two sets of application methods set lof lifecycle methods for activities dialogs and menus as well as set hof gui event handler methods.
sequences of callbacks to such methods are the target of our analysis.
in this work we focus on certain lifecycle methods l2l specifically creation callbacks e.g.
activity.oncreate and termination callbacks e.g.
activity.ondestroy .
in the future we plan to extend the analysis with other lifecycle callbacks based on standard ordering constraints .
in addition callbacks related to other types of components such as services broadcast receivers and non ui worker threads are of great interest to the static analysis community e.g.
for security checking and leak detection and contextsensitive analysis for such callbacks is an important target for future work.
such generalizations would require significant conceptual extensions to our current analyses.
we assume that relevant static abstractions have already been defined by an existing analysis of gui related objects .
we will refer to this analysis as g ator using the name of its public implementation .
the analysis tracks the propagation of widgets and related entities e.g.
activities dialogs listeners layout widget ids by analyzing xml layouts and relevant code e.g.
the calls to findviewbyid and setonclicklistener in figure .
its output contains a pair of sets w v .
each window w2w an activity a dialog or a menu is associated with a set of views v2v.
views are the android representation of gui widgets and are instances of subclasses of android.view.view .
a widgetv2v may be associated with event handlers h2h.
the control flow analysis output can be represented by a callback control flow graph ccfg .
there are three categories of graph nodes.
a node h v 2h v indicates that event handler hwas executed due to a gui event on widget v. a node l w 2l w shows that lifecycle method lwasoncreate main b1ondestroy main onclick imagebutton onclick imagebutton onclick imagebutton onclick imagebutton oncreate directoryinfo oncreate helpmanager oncreate alertdialog j1b2 ontextchanged textviewoncheckedchanged radiogroup ondestroy directoryinfoj2fig.
callback control flow graph executed on window w. in addition helper nodes are used to represent branch and join points as explained shortly.
the start node in the ccfg corresponds to the oncreate callback on the main activity of the application.
each path starting from this node defines a possible sequence of callbacks during the execution of the application.
an edge n1!n2shows that the callback represented by n1may trigger the subsequent execution of the callback represented by n2.
the ccfg for the running example is shown in figure .
for illustration we show a scenario where the main activity also has an ondestroy lifecycle method the details of helpmanager andalertdialog are not elaborated and are represented by the two dashed edges directoryinfo has two event handlers as well as an ondestroy method and handler oncheckedchanged may force termination ofdirectoryinfo and return control back to main .
to indicate that event handlers could be executed in any order branch nodes biand join nodes jiare introduced together with edges ji!bi.
this technique is similar to our early work on data flow analysis approximations recent work also uses a similar approach as discussed later.
both ondestroy methods are successors of the corresponding branch nodes rather than join nodes to show that the user may click the device s back button to exit an activity immediately without triggering any event handler.
note that ondestroy in directoryinfo is also a successor of oncheckedchanged to show that this handler may force exit from directoryinfo e.g.
by using a standard api call such as finish .
this model is not complete for example if main is the current window and the screen is rotated a new instanceofmain will replace the current one and oncreate would be called on it which would require additional edges in the graph.
such edges can be added for standard android events such as screen rotation interruption due to a phone call or locking unlocking the device screen for simplicity we do not consider them in this paper.
d. prior work existing work has addressed some aspects of this problem.
for example flowdroid uses a static analysis that represents the possible orderings of lifecycle event callbacks for a single activity.
the analysis encodes these orderings in an artificial main method and paths through this method correspond to sequences of callbacks.
this approach was designed for a particular form of interprocedural taint analysis and does not solve the general control flow problem described above.
the key issue is that there is no modeling of transitions and interactions involving multiple activities .
for example there is no path through the main method to show that the execution ofeventhandler.onclick may trigger the execution of directoryinfo.oncreate the same is true for the other twooncreate methods.
in addition the approach does not consider the widgets on which the event handlers operate nor does it model transitions to from dialogs and menus or transitions due to window termination.
the earlier scandroid tool which aims to model the sequence of callbacks to event handlers has similar limitations.
another area of related work is the resolution of activitylaunch calls such as the startactivity calls at lines and in figure .
activity launch apis use an intent object to specify the target activity two examples are shown at lines and in the figure.
there are several existing techniques for analysis of intent objects.
by itself intent analysis cannot determine the edges in a ccfg shown in figure .
it needs to be combined with contextsensitive analysis of event handlers and their transitive callees tracking of other window launch calls e.g.
the call to show at line and modeling of window termination calls.
one component of our control flow analysis is an intent analysis which is derived from prior work .
iii.
a nalysis algorithm a. control flow analysis of a callback method a key building block of our approach is a context sensitive analysis of a callback m2l h under a context c. recall that we use static abstractions for windows w2w activities dialogs and menus and views v2v created by g ator .
for an event handler h2h the context is a view v for a lifecycle callbackl2l the context is a window w. the analysis is outlined in algorithm .
this algorithm is then used by the main control flow analysis as described in section iii b. input and output.
the algorithm traverses valid icfg paths starting from the entry node of m s cfg.
when a trigger node is reached the traversal stops.
a trigger node is a cfg node that may trigger the subsequent execution of another callback the set triggernodes of all such nodes is provided as input toalgorithm analyzecallbackmethod m c input m callback method input c context input triggernodes set of icfg nodes output reachedtriggers set of icfg nodes output avoidstriggers boolean 1feasibleedges compute feasible edges m c 2visitednodes fentrynode m g 3nodeworklist fentrynode m g 4avoidingmethods 5while nodeworklist6 do n removeelement nodeworklist ifn2triggernodes then reachedtriggers reachedtriggers fng else if nis not a call site node and not an exit node then foreach icfg edge n!k2feasibleedges do propagate k else if nis a call site node and n!entrynode p 2feasibleedges then propagate entrynode p ifp2avoidingmethods then propagate returnsite n else if nisexitnode p andp 2avoidingmethods then avoidingmethods avoidingmethods fpg foreach c!entrynode p 2feasibleedges do ifc2visitednodes then propagate returnsite c 21avoidstriggers m2avoidingmethods 22procedure propagate k ifk 2visitednodes then visitednodes visitednodes fkg nodeworklist nodeworklist fkg the algorithm.
examples of trigger nodes are shown at lines and in figure other examples are provided in section iii b. an analysis output is the set reachedtriggers of trigger nodes encountered during the traversal.
another key consideration is to determine whether the exit node ofmis reachable from the entry node of mvia a valid trigger free icfg path.
if so the execution of mmay avoid executing any trigger.
in the example such a path exists through the default branch.
this path is necessary to determine the ccfg edge from onclick toj1for the multiselect button.
this edge shows that when this button is clicked onclick may be followed by another invocation of onclick or by app termination .
the algorithm outputs a boolean avoidstriggers indicating the existence of a trigger free path.
context sensitivity.
context sensitivity is achieved by performing a separate pre analysis represented by the call to compute feasible edges to determine the feasible icfg edges inmand methods transitively called by m. during the traversal lines in algorithm only feasible edges are followed.
the choice of the feasibility pre analysis depends on the callback method and on the context.
for example when onclick from the running example is analyzed the context is a static abstraction of the imagebutton instance provided as parameter.
using the output from g ator the id of this view is also available.
this allows c ompute feasible edges to resolve the return value of v.getid at line and to deter mine which branch is feasible.
the general form of this preanalysis is outlined in section iii c. for a lifecycle callback under the context of a window the analysis can identify virtual calls where this window is the only possible receiver and can determine more precisely the feasible interprocedural edges.
algorithm design.
the algorithm is based on the general graph traversal technique for solving interprocedural finite distributive subset ifds data flow analysis problems .
we formulated an ifds problem with a lattice containing two elements and the singleton set fentrynode m g. the data flow functions are x x identity function for non trigger nodes and x for trigger nodes .
the resulting data flow analysis was the conceptual basis for algorithm .
setavoidingmethods contains methods pthat are proven to contain a trigger free same level valid path from the entry ofpto the exit of p. in a same level valid path a call site has a matching return site and vice versa.
thus the execution of pmay avoid any trigger.
if a call site node is reachable and it invokes such a method the corresponding return site node is inferred to be reachable as well lines .
as another example whenever the exit node of pis reached for the first time line pis added to avoidingmethods and all call sites cthat invokepare considered for possible reachability of their return sites lines .
the set of avoiding methods is in essence a representation of the ifds summary edges .
b. ccfg construction ccfg construction uses the output from g ator .
in this output an activity ais associated with widgets views a v. the activity could also be associated with an options menu m2w such a menu is triggered by the device s dedicated menu button or by the action bar.
similarly a view v2v could have a context menu m triggered through a long click on the view.
each menu mrepresents a separate window with its own widget set views m which typically contains views instances of menuitem representing items in a list.
a dialogd2w is a separate window with some message to the user together with related choices e.g.
buttons for ok and cancel .
a dialog is associated with its own widget set views d .
a widgetvcould be associated with several event handlers handlers v h .
ccfg construction creates for each w2 w nodes for the relevant callbacks.
lifecycle methods for creation and termination of ware based on standard apis.
in the subsequent description we assume that wdefines both a creation callbacklc e.g.
oncreate and a termination callback lt e.g.
ondestroy but our implementation does not make this assumption.
for any h2handlers v wherev2views w there is a ccfg node h v we assume that at least one such node exists for w. a branch node bwand a join node jware also introduced.
edge creation.
algorithm defines the edges created for a windoww.
as illustrated in figure edges lc w !bw!
lt w show the invocations of lifetime callbacks these edges are created at lines in algorithm .
the second edge represents the termination of wwith the back button.algorithm createedges w input w window input lc w lt w lifecycle nodes for w input f h1 v1 h2 v2 g event handler nodes for w input bw jw branch join nodes for w output newedges set of ccfg edges for w 1newedges 2htriggers avoidsi analyze callback method lc w 3newedges newedges trigger edges triggers lc w 4ifavoids then newedges newedges f lc w !bwg 6newedges newedges fbw!
lt w g 7foreach event handler node h v do newedges newedges fbw!
h v g 9htriggers avoidsi analyze callback method h v newedges newedges trigger edges triggers h v ifavoids then newedges newedges f h v !jwg 13ifwis not a menu then newedges newedges fjw!bwg 15else newedges newedges fjw!
lt w g the termination of wcould also be triggered by event handlers.
recall that for the running example we assume that handler oncheckedchanged calls finish on activitydirectoryinfo .
this is an example of a termination trigger node and our analysis creates an edge from oncheckedchanged toondestroy at line in algorithm as elaborated below .
furthermore if the handler s execution cannot avoid this trigger the analysis would not create the edge from oncheckedchanged toj2.
for the example we assume that this termination trigger can be avoided along some icfg path thus there is an edge to j2 in figure created by line in algorithm .
for each handler hfor a viewvfromw s widget set an edge bw!
h v is added to indicate the possible user actions and the invoked handlers line in algorithm .
together with the back edgejw!bwcreated at line this structure indicates arbitrary ordering of user triggered events.
if wis a menu menu item selection immediately closes wand an edge from jwto the termination callback is created instead.
eachhis analyzed under context vusing algorithm invoked at line .
if avoidstriggers is true h v !jw is added to show that the execution of hmay retain the current window w rather than transition to a new one and user events will continue to trigger the event handlers forw.
the other outgoing edges for h v are determined by set reachedtriggers and are created by helper function trigger edges described below.
algorithm is also invoked for the creation callback lc at line to determine which trigger statements are reachable.
termination callback ltis assumed to contain no such triggers since its role is to clean up resources rather than to trigger window transitions.
edge creation for lc w shown at lines is similar to the edge creation for h v at lines .
the set of edges produced by t rigger edges is based on case by case analysis of trigger statements.
activity launchcalls such as startactivity e.g.
lines and in figure are analyzed with our flow and context insensitive intent analysis conceptually derived from a more expensive prior analysis but accounting for statement feasibility analogous to line in algorithm .
the analysis focuses on explicit intents because they are designed for use inside the same application .
in our experience it performed as well as existing alternatives .
menu launch calls such asshowcontextmenu as well as dialog launch calls e.g.
line in figure are resolved by g ator .
any such statement triggers the launch of a new window w0.
correspondingly function t rigger edges produces edges h v !
l0c w0 and l0t w0 !jwwhen invoked at line and edges lc w !
l0c w0 and l0t w0 !bwwhen invoked at line .
trigger edges also accounts for the possibility that set triggers contains a statement that terminates the current window e.g.
a call to finish on an activity or a call todismiss on a dialog.
if triggers contains a termination statement for w trigger edges produces h v !
lt w or lc w !
lt w to represent the possible flow of control.
example.
for the running example shown in figure calling a nalyze callback method at line with h onclick andv imagebutton will return triggers fs25gandavoids false .
activity launch statements25 representing line in figure is resolved to w0 directoryinfo .
as a result edges h v !
oncreate w0 and ondestroy w0 !j1are produced by t rigger edges .
if the call at line is for h oncheckedchanged triggers will contain the call to finish that closesw0 resulting in an edge to ondestroy w0 created by t rigger edges .
c. detection of feasible edges to detect which icfg edges are in feasible under a particular context we use constant propagation analyses formulated as interprocedural distributed environment ide analysis problems.
due to space limitations we outline the analyses at a high level without providing all technical details.
consider the analysis of a callback method munder context c performed by c ompute feasible edges .
the context could be a widget vor a window w both cases are handled although our experiments suggest that context sensitivity for windowswhas minor effect on precision.
first this analysis uses a form of interprocedural constant propagation to identify each local variable that definitely refers to only one object.
this analysis employs knowledge that a particular parameter ofmdefinitely refers to c and additional reference information obtained from g ator .
the analysis considers all methods transitively invoked by m virtual calls are resolved using class hierarchy information.
after this constant propagation the computed information is used to refine virtual call resolution if only one receiver object is determined to be possible the call is resolved accordingly.
next another interprocedural constant propagation analysis determines constant values of integer and boolean type.
for example for an api call such asx.getid orx.getmenuitemid ifxdefinitely refers only to one particular view the id for that view is treated as thereturn constant value of the call.
boolean expressions such asx y andx!
y are also considered both for