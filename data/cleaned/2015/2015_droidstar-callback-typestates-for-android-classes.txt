droidstar callback typestates for android classes arjun radhakrishna microsoftnicholas v. lewchenko university of colorado bouldershawn meier university of colorado boulder sergio mover university of colorado boulderkrishna chaitanya sripada university of colorado boulderdamien zufferey max planck institute for software systems bor yuh evan chang university of colorado boulderpavol ern university of colorado boulder abstract event drivenprogrammingframeworks suchasandroid arebased on components with asynchronous interfaces.
the protocols for interactingwiththesecomponentscanoftenbedescribedbyfinitestate machines we dub callback typestates.
callback typestates are akintoclassicaltypestates withthedifferencethattheiroutputs callbacks are produced asynchronously.
while useful these specifications are not commonly available because writing them is difficult and error prone.
our goal is to make the task of producing callback typestates significantlyeasier.wepresentacallbacktypestateassistanttool droidstar that requires only limited user interaction to produce acallbacktypestate.ourapproachisbasedonanactivelearning algorithm l .weimprovedthe scalability ofequivalencequeries a key componentof l thus makingactive learning tractable on the android system.
we use droidstar to learn callback typestates for android classesbothforcaseswhereoneisalreadyprovidedbythedocumentation and for cases where the documentation is unclear.
the results show that droidstar learns callback typestates accurately and efficiently.
moreover in several cases the synthesized callback typestates uncovered surprising and undocumented behaviors.
keywords typestate specification inference android active learning acm reference format arjunradhakrishna nicholasv.lewchenko shawnmeier sergiomover krishna chaitanya sripada damien zufferey bor yuh evan chang andpavol ern .
.droidstar callbacktypestatesforandroidclasses.
inicse icse 40th international conference on software engineering may27 june3 gothenburg sweden.
acm newyork ny usa pages.
thisworkwasdonewhilearjunradhakrishnawasemployedattheuniversityof pennsylvania.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
introduction event drivenprogrammingframeworksinteractwithclientcode usingcallinsandcallbacks.callinsareframeworkmethodsthatthe client invokes and callbacks are client methods that the framework invokes.theclient frameworkinteractionisoftengovernedbya protocol that can be described by a finite state machine we callcallback typestate.
callback typestates are akin to classical typestates with the key difference that their outputs callbacks are producedasynchronously.ourgoalistomakethetaskofproducing callback typestates significantly easier for developers.
asanexampleofacallbacktypestate consideratypicalinteractionbetweenaclientapplicationandtheframeworkwhenthe client wants to use a particular service.
the client asks for the servicetobestartedbyinvokingan startservice callin.afterthe framework receives the callin it asynchronously starts initializing theservice.whentheserviceisstartedandreadytobeused the framework notifies the client by invoking a onservicestarted callback.
the client can then use the service.
after the client finishesusingtheservice itinvokesa shutdownservice callinto ask the framework to stop the service.
callback typestates.
callbacktypestatesareusefulinanumber ofways buttheyarenotoriouslyhardtoproduce.first callback typestatesareaformofdocumentation.theytellclientapplication programmersinwhatordertoinvokecallinsandwhichcallback to expect.
android framework documentation for some classes already usespictures very similar tocallback typestates figure1 .
second callback typestates are useful in verification of client code.
they enable checking that a client uses the framework correctly.
third eventhoughweinferthecallbacktypestatesfromframework code they can be used for certain forms of framework verification.
forinstance onecaninfertypestatesfordifferentversionsofthe framework and check if the interface has changed.
callback typestates are very hard to produce manually.
on one hand inspectingcodetoseeinwhatsituationacallbackarrives and what callins are enabled after that is error prone.
even developers familiar with the framework often miss corner case behaviors.
on theotherhand obtainingthecallbacktypestatewithmanualtesting ishard.onewouldneedtorunallsequencesofcallins mixedinsequence with the callbacks they produce.
we systematize this testing approach using an active learning algorithm.
callback typestate assistant droidstar .we present a tool that makesproducingcallbacktypestatessignificantlyeasier.ourtargetuserisadeveloperwhowroteanandroidclassthatinteracts acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden radhakrishna et al.
asynchronouslyusingcallbackswithclientcode.droidstarisa comprehensive framework for semi automatically inferring callback typestates.
the required user interaction happens in multiple steps.inthefirststep theuserprovidescodesnippetstoperformlocal tasks such as code for class initialization and code for invoking eachcallin similarlyasinunittests .thisissufficientaslongas certainwidelyapplicableassumptionshold.first weassumethat eachsequenceofcallinsproducesasequenceofcallbacksdeterministically thisassumptionfailswhenforinstanceacallbackhasa parameter that is ignored at first by droidstar but that influences the typestate .
second we assume that the resulting typestate is finite.
if these assumptions fail in the following steps droidstar askstheuserforasolutiontotheproblem.forinstance onewayto removenon determinismistorefineonecallbackintotwoseparate logical callbacks based on the parameter values.
this design allowsdroidstartooffertheusercontroloverthefinalresultwhile requiringonlylimited local insightfromtheuser.droidstaris available for download at approach.
we present a method for inferring typestates for androidclasses.however ourmethodisequallyapplicableinother contexts.thecorealgorithmisbasedonangluin sl algorithm adaptedtomealymachines .inthisalgorithm alearnertriesto learn a finite state machine in our case a callback typestate by asking a teacher membership and equivalence queries.
intuitively a membership query asks for outputs corresponding to a sequence of input callins and the equivalence query asks if the learned typestate is correct.
we note that the teacher does not need to know the solution but only needs to know how to answer the queries.
thekeyquestionweanswerishowtoimplementoraclesforthe membership and equivalence queries.
we show how to implement membership queries on android classes using black box testing.
ourmaincontributionhereisanefficientalgorithmforimplementing the equivalence query using membership query.
the insighthere is that the number of membership queries can be bounded byafunctionofanewboundwecallthe distinguisherbound.w e empirically confirmed that for android classes the distinguisher boundissignificantlysmallerthanthestateboundusedinprevious work .
given that the number of required membership queriesdependsexponentiallyonthedistinguisherbound thenovel bound is what enables our tool to scale to android classes.
results.
weusedroidstartosynthesizecallbacktypestatesfor16 androidframeworkclassesandclassesfromandroidlibraries.the results show that droidstar learns callback typestates accurately andefficiently.thisisconfirmedbydocumentation codeinspection andmanualcomparisontosimpleandroidapplications.the running time of droidstar on these benchmarks ranged between 43secondsand72minutes withonly3benchmarkstakingmore than10minutes.theusefulnessofthedistinguisherboundwasalso confirmed.concretely usingpreviouslyknownbounds learning thecallbacktypestateforoneofourexamples mediaplayer would take more than a year whereas with the distinguisher bound this example takes around minutes.
furthermore by inspecting our typestates we uncovered corner cases with surprising behavior that areundocumented andmight even be considered asbugs in somecases.forinstance forthecommonlyusedasynctaskclass if execute iscalledafter cancel butbeforethe oncancelled figure part of mediaplayer s callback typestate from android.com reference android media mediaplayer.html callbackisreceived itwillnotthrowanexceptionbutwillnever causetheasynchronoustasktoberun.section6presentsourresults in more detail.
contributions.
thecontributionsofthispaperare a weintroduce the notion of callback typestates and develop an approach basedonthel algorithm toinferthem.
b weshowhowtoimplement efficiently membership and equivalence oracles required by the l algorithm.
c we evaluate our approach on examples from the android framework and show its accuracy and effectiveness.
workflow and illustrative example weusetheandroidframework s mediaplayer classtoexplainthe standard workflow for inferring callback typestate using droidstar.thisclassishighlystateful itsinterfaceincludesmanymethodsthatareonlymeaningfulorenabledinoneortwoparticular player states and makes extensive use of callins and callbacks to handle the delays of loading and manipulating large media files.
these properties make callback typestate a perfect fit in fact mediaplayer has one of the very few examples where we found a completecallbacktypestatespecificationintheandroidlibraries documentation.
this callback typestate is shown in figure .
infigure1 callinsarerepresentedbysinglearrowsandcallbacks by double arrows.
let us look at one part of the protocol that governsthe client frameworkinteraction.theclient firstinvokes the callin setdatasource and the protocol transitions to the initialized state.
in this state the client can invoke the callin prepareasync and the protocol transitions to the preparing state.
inthe preparing state theclient cannot invokeany callins buttheframeworkcaninvokethe onprepared callback andthen the protocol transitions to the prepared state.
at this point the client can invoke the start callin and the media startsplaying.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
droidstar callback typestates for android classes icse may june gothenburg sweden our goal is to semi automatically infer the callback typestate from the figure using the tool droidstar.
the developer interacts with droidstar in several steps which we describe now.
.
developer provided snippets to apply droidstar to the mediaplayer class the developer provides a number of code snippets detailed below that act as an interface through which the tool can examine mediaplayer instances.
test object and environment instantiation.
the main callback typestate inference algorithm of droidstar works roughly by repeatedly performing tests in the form of sequences of method calls on an object of the given class i.e.
the mediaplayer .
each test mustbeginwithanidentical isolated classobject andifnecessary a standard environment.
in the first step the developer provides a snippet to initialize such an object and environment.
in the case of mediaplayer thissnippetisassimpleasdiscardingtheprevious instance creating a new one with new mediaplayer and registeringthenecessarycallbacklisteners explainedinthe callback instrumentation paragraph below .
in some cases this snippet is morecomplex.asanexample wecannotcreatenewinstancesof thebluetoothadapter class so for that class this snippet would need to bring the existing instance back to a uniform initial state.
callindeclaration.
thenextstepistodeclarethealphabetof inputsymbols thatrepresentthecallinsintheinterfaceofourclass thefinal callbacktypestatewill be writtenusingthese symbols and map each symbol to the concrete code snippet it represents.
in most cases there is a one to one correspondence between input symbols and callin methods.
for example the code snippets associated with the input symbols prepare prepareasync and startare prepare prepareasync and start respectively.
in some cases such as when a callin takes a parameter the developer may instead map a symbol to a setof code snippets representing alternative forms of the input which are suspected to have different behavior.
in the mediaplayer class the setdatasource callin method takes a url argument.
the developer might rightly believe that depending onthe validity and reachabilityofthegivenurl thebehaviorofthecallininthetypes tatemaydiffer.inthiscase thedevelopermayprovidethetwosnippets setdatasource goodurl and setdatasource badurl for the same callin.
droidstar will consider both snippets for generatingtests andfurther itwillindicateiftheybehavedifferently with respect to the typestate.
in case a difference is detected the non determinism is handled as explained later in this section.
the complete set of input symbols which would be declared andmappedforthe mediaplayer classaresetdatasource prepare prepareasync start stop reset release and pause.
callback instrumentation.
as for the callin methods which act astheinputsymbolsinthecallbacktypestate thecallbackmethods act as the output symbols in the callback typestate.
the developer specifies the set of output callback symbols and associated snip pets to detect when callbacks occur.
in most cases this involvedadding the listeners for the callbacks in the initialization snippet asmentioned above.
inthe mediaplayer class the outputsymbols areoncompleted andonprepared.
.
automated callback typestate inference once the developer provides the input and output symbols and the associatedsnippets droidstarattemptstoautomaticallylearnthe callback typestate following the framework of the l algorithm.
l inference.
in l the learner tests sequences of inputs until she can form a consistent hypothesis automaton.
each such test or sequenceofinputs iscalledamembershipquery.onceahypothesis automaton is produced an equivalence query is performed i.e.
the hypothesis automaton is checked for equivalence with the true callbacktypestate.ifthetwoareequivalent wearedone otherwise acounter exampletestisreturnedfromwhichthetoollearns.thisprocessrepeatsuntiltheproducedhypothesisautomatoniscorrect.
formediaplayer the first set of membership queries each consist of a single different callin.
of these only the query containing setdatasource succeeds.
the learner continues with longer membership queries while building the hypothesis automaton.
for instance it learns that prepareasync and prepare do not lead to the same state it is possible to invoke the start after prepare butnotafter prepareasync .oncetheclientreceives the callback onprepared start may be called.
the learner thushypothesizesatransitionfromthe preparing tothe prepared ononprepared .oncethehypothesisiscomplete thelearnerasks the equivalencequery.
initially a counter example toequivalence isreturnedusingwhichthelearnerrefinesitshypothesis.thefinal solution is found after equivalence queries.
answering equivalence queries.
the equivalence query i.e.
checking if a learned callback typestate is in fact the true callback typestateisundecidableingeneral.however assumingaboundonthesizeofthetypestate theequivalencequerycanbeimplemented using further testing.
however equivalence queries are still expensiveandtomakethempracticalwepresentannewoptimization based on a distinguisher bound.
we can observe in figure that for anypairofstatesthereisatransitioninonestatewhichleadstoan errorintheother.thiscorrespondstoadistinguisherboundof1.
smalldistinguisherboundsarisebecausetypestatesarenotrandomautomatabutpartofanapidesignedforeaseofuseandrobustness.suchapisarecodeddefensivelyandarefail fast i.e.
errorsare not buffered but reported immediately.
each state in the typestate hasaspecificfunctionandanassociatedsetofcallinsandcallbacks.
in automata terms the alphabet is roughly the same size as the number of states and each state has only a few transitions making anytwostateseasytodistinguish.insection4.
weexplainhow tousethedistinguisherboundtoimplementequivalencequeries and discuss why distinguisher bounds are small in practice.
.
obstacles to inference and solutions the l based callback typestate inference algorithm makes several assumptionsaboutthebehavioroftheclassthatdonotalwayshold.droidstarisdesignedtodetecttheseviolationsofassumptionsand notifythedeveloper.here wediscusstwosuchassumptions the exceptionalsituationsthatarisewhentheassumptionsareviolated andtheadditionaldeveloperinterventionneededtohandlesuch cases.
non determinism.
in input output automata learning theory non determinismmakeslearningimpossible.non determinismis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden radhakrishna et al.
the possibility of the same sequence of input callins producing differentsequencesofoutputcallbacksacrosstests.non determinism maybeduetovarious controllable andnon controllable factors.controllablefactorsincludecaseswherebehaviordependsonifafile exists ifaurlisreachable etc.ontheotherhand non controllable factors include random number generators device sensors etc.
inpractice most of the non determinism was controllable.
the main technique for handling non determinism is via refinementofinputoroutputalphabets.here asinglecallinorcallbackis split into multiple logical inputs or outputs.
a controllable non determinism can be eliminated by incorporating the controlling factor into the inputs.
for example inthe sqliteopenhelper class the behavior of the constructor callinchangesdependingonifafile exists.
ho wever aftersplitting the callin into two separate callins constructor fileexists and constructor nofileexists the behavior of each of each callin becomes deterministic with respect to these callins.
b anothersourceofnon determinismiswhenthesamecallback is used to notify logically different events.
for example a classmay use a generic oncomplete callback which is passed a status parameter that can have the values success and failure .
based onthisvalue differentfurthercallinsareenabled leadingtonondeterminism.here thedevelopermaymanuallyrefinethecallbackintotwooutputsymbols onevent success andonevent failure and the behavior is deterministic with respect to these.
insummary forcontrollablenon determinism theonusisonthe developertoidentifythesourceofthedetectednon determinism andprovidearefinementoftheinputoroutputalphabetandcorre spondingcodesnippetstocontrolthesource.nogeneraltechnique exists to handle non controllable non determinism but specific cases can be handled using techniques shown in section .
non regularity.
another basic assumption that l based inference algorithm makes is that the callback typestate under consideration is regular.
this assumption is commonly violated inrequest response style behavior of classes where the number of responses outputcallbacks invokedisexactlyequaltothenumberofrequests inputcallins .oursolutiontothisproblemistorestrictthelearningtoasubsetoftheclassbehavior suchasinputswithatmostonependingrequestcallinusingalearningpurpose .these restrictions makes the behavior regular and amenable to learning.
the callback typestate learning problem we introduce formal models of interfaces define the callback typestatelearningproblem andpresentanimpossibilityresultabout learning typestates.
callback typestates have both inputs correspondingtocallins andoutputs correspondingtocallbacks .inau tomatatheory callbacktypestatescanbeseenasinterfaceautomata.
interface automata area well studied model of automatathat canproduceoutputsasynchronouslyw.r.t.inputs.weusethename callbacktypestatestoemphasizethattheyareageneralizationof typestates as used in the programming languages literature.
.
definitions and problem statement asynchronousinterfaces.
let iand obethesetofcallinsand callbacksofanasynchronousinterface.weabstractawayparameterand return values of callins and callbacks and model a behavior of theinterfaceasa trace i 0... n i o .theinterfacei isgivenby angbracketleft i o i angbracketrightwhere i i o istheprefix closed set of all feasible traces of the interface.
interface automata.
we use interface automata to represent asynchronous interfaces.
an interface automaton ais given by angbracketleftq q i o a angbracketrightwhere a qis a finite set of states b q q istheinitialstate c iand oarefinitesetsof inputandoutput symbols and d a q i o qare a set of transitions.
atrace aofais given by 0... nif q0...qn q0 q i. qi i qi a.traces a is the set of all traces of a. problem statement.
given an interface i angbracketleft i o i angbracketright thecallbacktypestatelearningproblem istolearnaninterfaceautomaton a suchthat i traces a .weallowthelearnertoaska membership oraclemoracle membershipqueries.fora membershipquery the learnerpicks mquery i0i1...in iandthemembershiporacle moracle returns either a a trace a iwhose sequence of callins is exactly mquery o r b if no such trace exists.
.
the theory and practice of learning typestates ingeneral itisimpossibletolearncallbacktypestatesusingonly membership queries no finite set of membership queries fixes a unique interface automaton.
however callback typestates canbe effectively learned given extra assumptions.
we now analyze the causes behind the impossibility and highlight the assumptions necessary to overcome it.
unbounded asynchrony.
membershipqueriesalonedonottell usiftheinterfacewillemitmoreoutputs callbacks atanypoint in time.
hence we assume assumption quiescence is observable.
thisassumptioniscommonlyusedinioco testingframeworks .
in our setting we add an input waitand an output quiet where quietis returned after a waitonly if there are no other pending callbacks.
in practice quietcan be implemented using timeouts i.e.
pending callbacks are assumed to arrive within a fixed amount of time.
if no callbacks are seen within the timeout quietis output.
example .
.
usingwaitandquiet in the mediaplayer example we have that setdatasource prepareasync onprepared wait quietis a valid trace but setdatasource prepareasync wait quietis not.
behavior unboundedness.
for any set of membership queries letkbe the length of the longest query.
it is not possible to find out if the interface exhibits different behavior for queries much longerthan k.thisisatheoreticallimitation butisnotaproblemin practice most callback typestates are rather small states .
assumption an upper bound on the size of the typestate being learned is known.
non determinism.
we need to be able to observe the systems behaviors to learn them and non determinism can prevent that.
therefore we assume assumption the interface is deterministic.
we assume that for every trace aof the interface there is at most one output o osuch that a o i. in practice the nondeterminismproblemissomewhatalleviatedduetothenatureof authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
droidstar callback typestates for android classes icse may june gothenburg sweden callback typestates see section .
see for a detailed theoretical discussion of how non determinism affects learnability.
example .
.
consider an interface with traces given by input out1 out2 .allmembershipqueriesareasequenceof input s however itispossiblethatthemembershiporaclenever returnsanytrace containing out2.inthatcase nolearnerwillbe able to learn the interface exactly.
learning callback typestates using l givenassumption andassumption we first build a synchronousclosure ofanasynchronousinterface section4.
.then we show how to learn the synchronous closure effectively given assumption section .
and .
.
.
from asynchronous to synchronous interfaces usingassumption1 and3 we build a synchronous version of an interfaceinwhichinputsandoutputsstrictlyalternatefollowing .
for synchronous interfaces we can draw learningtechniques from existing work .
define i i wait and o o quiet err .
the purposeoftheextrainputsandoutputsisdiscussedbelow.forany s i o wedefine async s a i o where ais had from sby erasing all occurrences of wait quiet anderr.
synchronousclosures.
thesynchronousclosure isofanasynchronous interface i angbracketleft i o i angbracketrightis given by angbracketleft i o s angbracketrightwhere i and oare as above and s i o is defined as the smallest set satisfying the following s s s async s i i s i s s s async s o i s wait o s s s async s i nelement i s i err s s s o o async s o nelement i s wait quiet s s s sends inerr s i err s informally in is a each input is immediately followed by a dummy output b each output is immediately preceded by a waitinput wait c anycalltoaninputdisabledin iisimmediately followedbyan err.further alloutputsafteran errareerr s. d any call towaitin a quiescent state is followed by quiet.
givenmoracle andassumption1 itiseasytoconstructthe membership moracle .notethatdueto assumption there is exactly one possible reply moracle mquery for each query mquery.further bytheconstructionofthesynchronousclosure the inputs and outputs in moracle mquery alternate.
mealy machines.
we model synchronous interfaces using the simpler formalism of mealy machines rather than interface automata.
a mealy machine mis a tuple angbracketleftq q i o out angbracketrightwhere a q q i and oare states initial state inputs and outputs respectively b q i qis atransition function and c out q i ois anoutput function.
we abuse notation and write out q i0...in o1...onand q i0...in q primeif q0 ... qn q0 q qn q prime i n qi ii qi out qi ii oi.
a sequence i0o0...inon i o is a traceofmifout q i0...in o0...on.we oftenabusenotationand write m i0...in instead of out q i0...in .
we denote by traces m the set of all traces of m. .
l learning mealy machines for the sake of completeness we describe the classical l learning algorithm by angluin as adapted to mealy machines in .
a reader familiar with the literature on inference of finite state machines may safely skip this subsection.
fixanasynchronousinterface ianditssynchronousclosure is.
in l in addition to a membership oracle moracle the learner has access to an equivalence oracle eoracle .
for an equivalence query thelearnerpassesamealymachine mtoeoracle and is inturn returned a a counterexample input cex i0...insuch thatm cex o0...onandmoracle cex nequali0o0...inon o r b correctif no such cexexists.
the full l algorithm is in algorithm .
in algorithm the learner maintains a a set sq iofstate representatives initially set to b a set e iofexperiments initially set to i and c an observationtable t sq sq i e o .theobservation table maps each prefix wiand suffix etot wi e where t wi e isthesuffixoftheoutputsequenceof moracle wi e of length e .theentriesarecomputedbythesub procedure filltable.
intuitively sqrepresentmyhill nerodeequivalenceclassesof themealymachinethelearnerisconstructing and edistinguish between the different classes.
for sqto form valid set of myhillnerodeclasses eachstaterepresentativeextendedwithaninput should be equivalent to some state representative.
hence the algorithm checks if each wi i sq iis equivalent to some w prime i sq line under e and if not adds wi itosq.
if no such wi iexists thelearnerconstructsamealymachine musingthemyhill nerode equivalenceclasses andqueriestheequivalenceoracle line5 .if the equivalence oracle returns a counterexample the learner adds asuffixofthecounterexampleto e otherwise itreturns m.forthe full description of the choice of suffix see .
theorem .
.let there exist a mealy machine mwith nstates such that traces m is the set of traces of is.
then given moracle andeoracle algorithm1returns mmakingatmost i 2n i n2mmembership and nequivalence queries where mis the maximum length of counterexamples returned by eoracle .i f eoracle returns minimal counterexamples m o n .
.
an equivalence oracle using membership queries given a black box interface in practice it is not feasible to directly implement the equivalence oracle required for the l algorithm.
here wedemonstrateamethodofimplementinganequivalence oracleusingthemembershiporacleusingtheboundednessassumption assumption .
as before fix an asynchronous interface i and its synchronous closure is.
further fix a target minimal mealy machinem such that traces m is the set of traces of is.
statebounds.
astatebound ofbstateimpliesthatthetargetmealy machinem has at most bstatestates.
given a state bound we can replaceanequivalencecheckwithanumberofmembershipqueries using the following theorem.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden radhakrishna et al.
algorithm l for mealy machines input membership oracle moracle equivalence oracle eoracle output mealy machine m sq e i t filltable sq i e t whiletruedo while wi sq i i w prime i sq t wi i t w prime i do sq sq wi i filltable sq i e t m buildmm sq i t cex eoracle m ifcex correctthen return m e e analyzecex cex m filltable sq i e t function buildmm sq i o t q wi sq q wi i i w prime i ift wi i t w prime i wi i out i oift wi i o return angbracketleftq q i o out angbracketright function analyzecex m cex for all0 i cex andwp i ws isuch that wp i ws i cex wp i 1do wp o m wp i wp prime i wp o wso last ws i ofout moracle wp prime i ws i ifwp o wso nequalout moracle cex then return ws i procedure filltable sq i e t for allwi sq sq i e edo t wi e suffix ofout moracle wi e of length e theorem .
.
letmandm primebe mealy machines having kand k primestates respectively suchthat wi i m wi nequalm prime w prime i .then thereexistsaninputword w prime ioflengthatmost k k prime 1suchthat m w prime i nequalm prime w prime i .
the proof is similar to the proof of the bound k k prime for finite automata see .
we can check equivalence of m and any given mby testing that they have equal outputsonallinputsoflengthatmost km bstate i.e.
using o i bstate k membershipqueries.
whilethissimplealgorithm is easy to implement it is inefficient and the number of required membership queries make it infeasible to implement in practice.
other algorithms based on state bounds have a similar problems withefficiency seeremarkinsection4.
.further thealgorithm doesnottakeadvantageofthestructureof m.thefollowingdiscussion and algorithm rectifies these short comings.
distinguisherbounds.
adistinguisherbound ofbdist nimplies thatforeachpairofstates q q 2inthetargetmealymachine m canbedistinguishedbyaninputword wioflengthatmost bdist i.e.
out q wi nequalout q wi .intuitively asmalldistinguisher boundimpliesthateachstateis locally different i.e.
canbedistinguished from others using small length input sequences.
the following theorem shows that a state bound implies a comparable distinguisher bound.
theorem .
.
state bound kimplies distinguisher bound k .
small distinguisher bound.
in practice distinguishers are much smaller than the bound implied by the state bound.
for the mediaplayer the number of states is but only distinguishers of length1 are required.
this pattern tends to hold in general due to the following principles of good interface design clearseparationoftheinterfacefunctions.
eachstateinthe interfacehasaspecificfunctionandaspecificsetofcallins andcallbacks.thereislittlereuseofnamesacrossstate.the typestate s alphabet is roughly the same size as the number of states.
fail fast.
incorrect usage of the interface is not silently ignored but reported as soon as possible.
this makes it easier todistinguishstatesasdisabledcallinsleaddirectlytoerrors.
nobuffering.morethanjustfail fast agoodinterfaceisinteractiveandtheeffectofcallinsmustbeimmediatelyvisible rather than hidden.
a good interface is not a combination lockthatrequiresmanyinputsthataresilentlystoredand only acknowledged at the very end.
thisobservationalsoisnotspecifictocallbackstypestatesandit has been already observed for libraries .
equivalencealgorithm.
algorithm2isanequivalenceoraclefor mealymachinesusingthemembershiporacle givenadistinguisher bound.first itcomputesstaterepresentatives r q i foreach q q q r q q line .
then for each transition in m the algorithmfirstcheckswhethertheoutputsymboliscorrect line5 .
then the algorithm checks the fidelity of the transition up to the distinguisherbound i.e.
whethertherepresentativeoftheprevious state followed by the transition input and the representative of the next state can be distinguished using a suffix of length at most bdist.ifso thealgorithmreturnsacounterexample.ifnotransition shows a different result the algorithm returns correct.
two optimizations further reduce the number of membership queries a quiescence transitions.
transitions with input waitand outputquietneed not be checked at line it is a no op at the interfacelevel.
b error transitions.
similarly transitionwiththe outputerrneednotbecheckedasanyextensionofanerrortrace can only have error outputs.
remark.
notethatifalgorithm2isbeingcalledfromalgorithm1 thestaterepresentativesfroml canbeusedinsteadofrecomputing r in line .
similarly the counterexample analysis stage can be skipped inthel algorithm andtherelevantsuffixcanbedirectlyreturned suffixin lines and and iin line .
theorem4.
.
assumingthedistinguisherboundof bdistforthe target mealy machine m either a algorithm returns correct and wi i m wi m wi or b algorithm returns a counterexample cexandm cex nequalm cex .
further it performs at most q i bdist 1membership queries.
remark relation to conformance testing algorithms .
notethattheproblembeingaddressedhere i.e.
testingtheequivalence of a given finite state machine and a system whose behavior can beobserved isequivalenttotheconformancetestingproblemfrom themodel basedtestingliterature.however severalpointsmakethe existing conformance testing algorithms unsuitable in our setting.
popularconformancetestingalgorithms likethew method and the w p method are based on state bounds and have an unavoidable o i bstate factorinthecomplexity.inourexperiments thelargesttypestatehad 10statesand 7inputs.the o i bstate factor leads to an infeasible i.e.
number of membership queries.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
droidstar callback typestates for android classes icse may june gothenburg sweden algorithm equivalence oracle with distinguisher bound input mealy machine m angbracketleftq q i o out angbracketright distinguisher boundbdist and membership oracle moracle output correctifm m o rcex is.
t.m cex nequalm cex forallq qdor q wi q wi qs.t.
wi isminimal for allq q i ido wi r q i ifout q i nequallast symbol of out moracle wi i then returnr q i q prime q i w prime i r q prime suffix check wi w prime i ifsuffix nequalcorrectthen ifm r q i suffix nequalout moracle r q i suffix then returnr q i suffix else return r q prime suffix returncorrect function check wi w prime i for allsuffix bdist ido wo out moracle wi suffix w primeo out moracle w prime i suffix ifthe last suffix symbols of woandw primeodifferthen returnsuffix returncorrect however since distinguisher bounds are often much smaller than state bounds o i bdist membership queries are feasible i.e.
.
the w and w p methods cannot directly use distinguisher bounds.
the other common algorithm the d method does not apply in our setting either.
the d method is based on building a distinguishing sequence i.e.
an input sequence which produces a different sequence ofoutputs from every single state inthe machine.
however forcallbacktypestates suchsingledistinguishingsequences do not exist in practice.
for similar reasons conformance testing algorithms such as the uio method do not apply either.
inthislight webelievethatalgorithm2isanovelconformance testing algorithm useful in specific settings where resets are inexpensive and systems are designed to have small distinguisher bounds.
.
putting it all together we now present the full callback typestate learning solution.
theorem .
.
given a deterministic interface iwith observable quiescence and the membership oracle moracle .
assume there existsaninterfaceautomaton awithnstateswithdistinguisherbound bdistmodelingthetypestateof i.interfaceautomaton acanbelearned witho i n3 n i bdist membership queries.
proof sketch.
starting with an asynchronous interface iand a membership oracle moracle usingassumption andassumption3 wecanconstructthemembershiporacle moracle for the synchronous closure isofi.
given the distinguisher bound orastateboundusing assumption2 andtheorem4.
wecan constructanequivalenceoracle eoracle usingalgorithm2.oraclesmoracle andeoracle canthenbeusedtolearnamealy machinemwiththesamesetoftracesas is.thismealymachinecan be converted into the interface automata representing the callbacktypestateof iby a deletingalltransitionswithoutput err and all self loop transitions with output quiet and b replacing all transitions with input waitwith the output of the transition.
active learning for android we implemented our method in a tool called droidstar.
in this sectionwedescribehowitworks thepracticalchallengeswefaced when working with android and our solutions to overcome them.
droidstarisimplementedasanandroidapplicationandlearns callback typestates from within a live android system.
.
designing an experiment to learn a typestate a droidstar user creates a test configuration an extensionofthe learningpurpose class providing necessary information about a java class under study.
if known the distinguisherboundcanbeprovidedheredirectly otherwise itcanbe obtainedfrom assumption bytheorem4.
.the instrumented alphabet also defined here specifies an abstract alphabet for the learningalgorithmandtranslationbetweentheabstractalphabet andconcretecallins callbacksoftheclassunderstudy.severalotheroptionsareavailableforadjustingthelearning themostimportant being the quiescence timeout which determines assumption .
.
observing asynchronous callbacks in our approach we assume bounded asynchrony assumption and therefore we can observe when the interface does not produce any new output quiescence .
we enforce this assumption onarealsystemwithtimeouts themembershipqueryalgorithm waitsforanewoutputforafixedamountoftime tmax assuming that quiescence is reached when this time is elapsed.
however android does not provide any worst case execution time for the asynchronous operations and we rely on the user to choose a largeenough tmax.
the membership query also assumes the existence of a minimum time tminbefore a callback occurs.
this ensures that we can issue a membership query with two consecutive callins so without a waitinput in between i.e.
we have the time to execute the second callin before the output of the first callin.
considerthemediaplayerexamplefromsection2.themembershipquery setdatasource url wait prepareasync wait may not return the onprepared iftmaxis violated i.e.
if the callbackdoesnotarrivebeforethetimeout andwhiletestingitis possiblethatthe prepareasync start mightnotreturnan error as expected if the lower bound tminis violated.
to avoid such issueswetrytocontroltheexecutionenvironmentandparameters to ensure that callbacks occurred between tminandtmax.
in the mediaplayer case we must pick the right media source file.
.
checking and enforcing our assumptions the simplest experiment to learn a class s callback typestate ties a single input symbol to each of its callins and a single output symbol to each of its callbacks.
however many android classes have behaviors which cause this simple experiment to fail and require more detailed experiments to succeed.
themainchallengeswhendesigninganexperimentare a nondeterministic behaviors i.e.
the state of the device and external authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden radhakrishna et al.
ctor getrdb oncreate oncreate ctor fe ctor nfegetrdb getrdboncreate oncreate figure eliminating non determinism in sqliteopenhelper eventsmayinfluenceanapplication.theseelementsareinherently non deterministic however non determinism violates assumption3.
b theparameterspace requiredtodriveconcretetestcases to witness amembership query is potentiallyinfinite.
though we have ignored callin parameters till now they are a crucial issue fortesting.
c theprotocolwearelearningmaynotbearegular language.
note that this is a violation of assumption .
non deterministic behavior.
non deterministic behavior is disallowed by our assumption3 .
however to make this assumption reasonable we must make non determinism straightforward to eliminate when it arises.
we explain two primary classes of nondeterministic behaviors and strategies to eliminate these behaviors.
the first class is related to controllable inputs and the second to uncontrollable ones such as inputs from the device sensors .
because the learning algorithm cannot learn from nondeterministic systems droidstar will terminate if such behavior is detected.
to assist in this process droidstar will report a non deterministic behavior is detected and display the disagreeing sequences to the user.
it detects this by caching all membershipqueries as input output sequence pairs.
when a new trace is explored droidstar checks that the trace prefixes are compatible with the previously seen traces.
in the first case a hidden not modeled controllable input influences the typestate.
we resolve this non determinism by manually adding the input value and create a finer alphabet that explicate the previously hidden state of the environment.
for example inthe class sqliteopenhelper the getreadabledatabase may eithertriggera oncreate callbackornot dependingontheparametervaluetoapreviouscallin constructor wasthenameof anexistingdatabasefile.hence thebehaviorofthecallinisnondeterministic dependingonthestatusofthedatabaseondisk.in thesqliteopenhelper example wesplitthe constructor callin intoconstructor fileexists andconstructor nofileexists andpasstherightparametervaluesineachcase.withthisextra modeling we can learn the interface automaton since the execu tion getreadabledatabase ends in two different states of the automaton see figure .
thesecondclassistheeffectoftheuncontrollableinputsona typestate.
such effects by definition cannot be controlled or made explicit prior to the call.
we can sometimes to remove this nondeterminism by merging different outputs considering them to be the same.
this is the dual of the previous solution.
an example is the speechrecognizer for which calling startlistening produces different callbacks depending on the environment.
as the environment cannot be reasonably controlled wemergeoutputstogotothesamestate.ifoutputsareerroneously merged the non determinism will propagate and continue to manifest.
thus there is no risk of unsound results.handling callin parameters.
while parameter less callins such asstart and stop are common in android classes many parameterizedcallinsexist.becauseinputsymbolsneedtobelisted in the experiment definition the full range of parameter values cannot be explored.
in practice we found that parameters often havelittleeffectonthetypestateautomaton.incaseswherethey do affect the automaton multiple input symbols can be defined to representthesamemethodcalledwithseveraldifferentparameters.
this solution is similar to splitting on environmental effects when dealing with non determinism.
learningfromnon regularlanguages.
anintrinsiclimitation ofl isthatitlearnsonlyregularlanguages.however someclasses expose non regular protocols.
common cases include situations wherearequestcallininvoked ntimestriggerexactly nresponsecallbacks.
in the spellcheckersession class callin getsuggestion and callback ongetsuggestions follow this pattern.
however eveninsuchcases itcanbeusefultobuildaregularapproximation of the typestate.
for example restricting the typestate to behaviors where there is at most one pending request a regular subset provides all the information a programmer would need.
hence in such cases we use the technique of learning purposes to learn a regular approximations of the infinite typestate.
empirical evaluation we evaluated our interface learning technique as implemented in droidstar by using it to generate callback typestates for classes sampledfromtheandroidframeworkandpopularthirdparty libraries.
droidstar is available at droidstar.
for these experiments droidstar was run on an lg nexus 5with android frameworkversion .
ourevaluation was designed to answer the following questions does our technique learn typestates efficiently?
whatsizedistinguisherboundsoccurinpractice?dothey support the small distinguisher bound hypothesis?
do the callback typestates we learn reveal interesting or unintended behavior in the interfaces?
methodology.
foreachexperimentalclass wemanuallyidentified areducedalphabetofrelevantcallinsandcallbacksandprovided them along with other necessary information as explained in section5 todroidstarthroughinstancesofthe learningpurpose .
relevant callins and callbacks for these experiments were those which according to the available documentation appeared to trigger or depend on typestate changes enabling or disabling of parts oftheinterface .eachinstanceconsistedof50 200linesof mostly boiler plate java or scala code.
toevaluateefficiency wemeasuredtheoveralltimetakenfor learning aswellasthenumberofmembership mq andequivalencequeries eq .thenumberofqueriesislikelyabettermeasure ofperformancethanrunningtime therunningtimedependson externalfactors.forexample inthemediaplayertherunningtime depends on play length of the media file chosen during testing.
wevalidatedtheaccuracyoflearnedcallbacktypestatesusing two approaches.
first for classes whose documentation contains a picture or a description of what effectively is an callback typestate wecomparedourresulttothedocumentation.second forallother authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
droidstar callback typestates for android classes icse may june gothenburg sweden classes we performed manual code inspection and ran test apps to evaluate correctness of the produced typestates.
we used a distinguisher bound of for our experiments further we manually examined the learned typestate and recorded the actual distinguisher bound.
for our third question i.e.
does the learnedcallbacktypestaterevealinterestingbehaviors wemanually examined the learned typestate compared it against the official android documentation and recorded discrepancies.
.
results we discuss the results in table and our three questions.
question efficiency.
the table shows that our technique is reasonably fast most typestates learned within a few minutes.
the longestonetakes71minutes stillapplicabletonightlytesting.the numbers for membership queries are reported as x y xis the number of membership queries asked by the algorithm while y is the number actually executed by the membership oracle.
this numberislowerasthesamequerymaybeaskedmultipletimes but is executed only once and the result is cached.
for each benchmark the accuracy validation showed that the produced typestate matched the actual behavior.
question distinguisherbounds.
asmentionedbefore weuseda distinguisher bound of for all experiments.
however a manual examinationofthelearnedcallbacktypestatesshowedthatabound of would be sufficient in all cases except the sqliteopenhelper andthe okhttpcall whereboundsof2arenecessary.thissupports ourconjecturethat inpractice interfacesaredesignedwitheach state having a unique functionality see section .
.
question interesting learned behavior.
of the three questions ourexperimentstoexaminethelearnedcallbacktypestateforinterestingbehaviorturnedouttobethemostfruitful uncovering several discrepancies including corner cases unintended behavior and likely bugs in the android framework.
these results reaffirm the utility of ourmain goal of automatically learningcallback typestate andsuggestthatlearningtypestatecanservevaluableroles in documentation and validation of callback interfaces.
in2cases thelearnedtypestateanddocumentedbehaviordifferedincertaincornercases.wecarefullyexaminedthedifferences by framework source examination and manually writing test applications andfoundthatthelearnedtypestatewascorrectandthe documentationwasfaulty.in5othercases webelievetheimplemented behavior isnot the intended behavior i.e.
these are likely bugsintheandroidimplementation.thesediscrepanciesmostly fall into two separate categories incorrect documentation.
in such cases it turned out that the discrepancy is minor and unlikely to produce bugs in client programs.
raceconditions.
severallikelybugswereduetoaspecificcategoryof race conditions.
these interfaces have a a callin to start an action and a corresponding callback which is invoked when the action issuccessfullycompleted b acallintocancelanalreadystarted action and a corresponding callback which is invoked if the action issuccessfullycancelled.whenthestartactionandcancelaction callins are called in sequence the expectation is that exactly one of the two callbacks are called.
however when the time between the two callins is small we were able to observe unexpected behaviors including neither or both callbacks being invoked.start cancelling running cancelling completedexecute execute cancel cancel oncancelled oncancelled cancel cancel onpostexecute figure learned typestate of the asynctask class .
selected experiments of our benchmarks we briefly explain here.
the remaining experiments are discussed in the technical report .
mediaplayer.
this is the class from the example in section .
the learned typestate differs from the existing documentation.
the learnedtypestate a hasthe pause callinenabledinthe playbackcompleted state and b showsthat onprepared isinvoked even after the synchronous callin prepare .
though undocumented these behaviors are unlikely to cause any issues.
asynctask.
the asynctask class turns arbitrary computations into callback operations with progress tracking and results are delivered via callbacks.
for our experiment the computation is a simple timer.
a constructed asynctask object performs its task when itreceivesthe execute callin andtheneitherreturnstheresults withthe onpostexecute callback orreturnsan oncancelled ifcancel is called first.
the object is single use after it has returned a callback it will accept no further execute commands.
ourexperimentrevealedanunexpectededge case if execute is after cancel but before the oncancelled callback is received it will not throw an exception but will never cause the callback task to be run.
the learned interface is in figure .
speechrecognizer.
this classprovides an exampleof uncontrollable environmental non determinism.
the particular callback that signalstheendofthespeechsession eitheran onresults oran onerror isdeterminedbytheenvironment inparticular the soundaroundthephoneduringthetest .inthiscase toreducethe systemtoadeterministiconewecanlearn wesupposedthatthe state after an onresults oronerror is the same and merged the two callbacks into a single onfinished symbol.
our results revealed two interesting corner cases for the ordering of inputs.
first if an app calls cancel between callingstartlistening and receiving the onreadyforspeech callback represented by our starting output symbol calling startlistening again will have no effect until after a certain amountoftime asshownbythe waittransitionfromstate cancelling to finished .delaysinreadinesslikethiscanbegenerally consideredbugs ifasystemwillnotbereadyimmediatelyforinputsitshouldprovideacallbacktoannouncewhenthepreparations are complete so as not to invite race conditions.
oursecondcornercaseiswheretheappcalls stoplistening astheveryfirstinputonafreshspeechrecognizer.thiswillnot throw an exception but calling startlistening at any point after will fail making the object effectively dead.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden radhakrishna et al.
class name lp loc statestime s mqeqmq per eq bdist needed asynctask bluetoothadapter countdowntimer downloadmanager fileobserver imageloader uil mediacodec mediaplayer mediarecorder mediascannerconnection okhttpcall okhttp requestqueue volley speechrecognizer spellcheckersession sqliteopenhelper velocitytracker table droidstar experimental results.
sqliteopenhelper.
thisclassprovidesamorestructuredinterface for apps to open and set up sqlite databases.
it has callbacks for different stages of database initialization allowing apps to perform setup operations only as they are needed.
when a database is openedwith getwritabledatabase acallback onconfigure is called followed by an oncreate if the database didn t exist yet or an onupgrade ifthedatabasehadalowerversionnumber thanwaspassedtothesqliteopenhelperconstructor allfollowed finallybyan onopen whenthedatabaseisreadyforreading.the database can then be closed with a close .
our experiment observed the callbacks when opening databases indifferentstates normal non existent andoutofdate andperforming the close operation at different points in the sequence.
wefoundthatoncethe getwritabledatabase methodiscalled calling close will not prevent the callbacks from being run.
velocitytracker.
thisclasswasaspecialcasewithnoasynchronous behavior it was a test of our tool s ability to infer traditional synchronous typestates.
the class has a recycle method that we expected to disable the rest of the interface but our tool found and manual tests confirmed that the other methods can still be calledafterrecycling.thedocumentation swarningthat youmust not touch the object after calling is thus not enforced.
related work workswhichautomaticallysynthesizespecificationsofthevalid sequences of method calls e.g.
typically ignore the asynchronous callbacks.
static analysis has been successfully used to infer typestates specifications importantly withoutcallbacks .thework in infersclassicaltypestatesforjavaclassesusingl .incontrast our approach is based on testing.
therefore we avoid the practical problemofabstractingtheframeworkcode.ontheotherhand the use of testing makes our l oracles sound only under assumptions.
similarly usesl toinferclassicaltypestates includingranges of input parameters that affect behavior.
however their tool is based on symbolic execution and thus would not scale to systems as large and complex as the android framework.inferring interfaces using execution traces of client programs using the framework is another common approach .
in contrast to dynamic mining we do not rely on the availabilityofclientapplicationsorasetofexecutiontraces.the l algorithm drives the testing.
theanalysisofevent drivenprogrammingframeworkshasrecentlygainedalotofattention e.g.
.however none of the existing works provide an automatic approach to synthesize interfacespecifications.analysesofandroidapplicationsmostly focus oneither statically proving programcorrectness or security properties or dynamically detecting race conditions .
these approaches manually hard code the behavior of the framework to increase the precision of the analysis.
the callback typestate specifications that we synthesize can be used here avoiding the manual specification process.
our work builds on the seminal paper of angluin and the subsequent extensions and optimizations.
in particular we build onl fori oautomata .theoptimizationsweuseinclude thecounterexamplesuffixanalysisfrom andtheoptimizations for prefix closed languages from .
the relation to conformance testingmethods hasbeendiscussedinsection4.
.
conclusion we have shown how to use active learning to infer callback typestates.weintroducethenotionofdistinguisherboundwhichtake advantageofgoodsoftwareengineeringpracticestomakeactive learning tractable on the android system.
our method is implementedinthefreelyavailabletoolcalleddroidstar.thispaper enablesseveralnewresearchdirections.weplantoinvestigatemining parameters of callins from instrumented trace from real user interactions aswellastheinferenceofstructuredtypestates for instance learning a typestate as a product of simpler typestates .