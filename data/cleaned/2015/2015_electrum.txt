lightweight specification and analysis of dynamic systems with rich configurations nuno macedo haslab inesc tec and universidade do minho nfmmacedo di.uminho.ptjulien brunel dtim uftmip onera julien.brunel onera.frdavid chemouil dtim uftmip onera david.chemouil onera.fr alcino cunha haslab inesc tec and universidade do minho alcino di.uminho.ptdenis kuperberg tu munich denis.kuperberg gmail.com abstract model checking is increasingly popular in the early phases of the software development process.
to establish the correctness of a software design one must usually verify both structural and behavioral or temporal properties.
unfortunately most speci cation languages and accompanying model checkers excel only in analyzing either one or the other kind.
this limits their ability to verify dynamic systems with rich con gurations systems whose state space is characterized by rich structural properties but whose evolution is also expected to satisfy certain temporal properties.
to address this problem we rst propose electrum an extension of the alloy speci cation language with temporal logic operators where both rich con gurations and expressive temporal properties can easily be de ned.
two alternative model checking techniques are then proposed one bounded and the other unbounded to verify systems expressed in this language namely to verify that every desirable temporal property holds for every possible con guration.
ccs concepts software and its engineering !speci cation languages model checking keywords model checking formal speci cation language work funded by the european regional development fund erdf through the operational programme for competitiveness and internationalisation compete and by national funds through the portuguese funding agency funda c ao para a ci encia e a tecnologia fct within project poci feder .
research partly funded by dga anr project c x ref.
anr astr and fondation stae ifse briefcase .
.
introduction software speci cation and veri cation is crucial at early development phases since it allows the developer to reason about the system and its properties and timely detect design errors.
although a variety of frameworks has been proposed to aid the developer in this task the most successful ones arelightweight in the sense that they provide a simple yet expressive and exible formal language allowing the user to specify di erent classes of systems and properties at different abstraction levels and are accompanied by tools that automate their analysis providing quick feedback regarding the correctness of the speci cation.
in fact such frameworks have already reached a level of maturity that enables their application in complex real world scenarios .
two classes of properties are particularly important to consider structural orstatic properties typically expressed in some variant of rst order logic that address the wellformedness of the system state and behavioral ordynamic properties typically expressed in a temporal logic that address the evolution of the system state.
although not necessarily in equal measure most interesting systems will require the speci cation and analysis of properties from both classes.
the analysis of distributed computing algorithms is a paradigmatic class whose behavioral properties are expected to be checked for arbitrary network topologies within a range speci ed by particular structural properties.
we denote such components of the system state that are initially arbitrary but remain unchanged as the system evolves as con gurations .
another relevant class is that of software product lines spls where each valid software product of a family speci ed by simple structural properties amounts to a different con guration each of which should be checked for the behavioral properties.
dynamic systems with rich con gurations are the focus of this work and concretely this class of systems exhibits the following requirements r1 a clear distinction between the speci cation of the system con guration and the system evolution r2 con gurations constrained by rich structural properties like inheritance complex relationships between entities or reachability properties r3 a declarative speci cation of the system evolution the possible actions a ecting the state possibly underdi erent idioms r4 the need to verify temporal safety and liveness properties about the speci ed system.
thus to be suitable to address this kind of problems a speci cation language should be su ciently rich and exible to support the de nition of both structural and behavioral properties while still promoting the separation of concerns.
moreover it should be accompanied by e ective tool support to allow the automatic model checking of the desired temporal properties for every valid con guration.
.
motivating examples to further clarify the class of problems we intend to address this section presents two motivating examples where all the above characteristics are manifest.
hotel room locking system.
this example regards the speci cation of a hotel room locking system that uses disposable electronic keys that relies on recodable locks that either unlock the door for the currently coded key or for its successor at which point the lock is recoded rendering the previous key obsolete.
the front desk issues new keys for the appropriate room when guests check in.
the front desk and the locking systems are stand alone no communication between them the system works properly because keys are generated using the same pseudo random generator with the initial seed of each room lock being synchronized with the front desk a priori .
to abstract away the details keys are interpreted as a totally ordered set e.g.
a set of natural numbers and each room is assigned a disjoint subset of such keys a priori given the currently coded key the next valid one is the smallest among its successors in this subset.
the available rooms keys and possible guests together with a valid assignment of keys to the rooms constitutes a con guration of this system.
these remain constant as the system evolves contrasting with the dynamic components of the system e.g.
the keys currently coded in each lock r1r1 .
moreover a valid con guration is not arbitrary but characterized by a precise set of constraints r2r2 .
the dynamic components evolve as guests check in and out or enter a room with a fresh key updating the currently coded key of that room lock.
these actions can easily be speci ed in a declarative manner for example relying on pre and post conditions r3r3 .
a safety property that is expected to hold r4r4 is that guests cannot enter rooms in which they are not currently registered.
this property does not hold in some con gurations as depicted in fig.
.
each state depicts the rooms square elements guests rounded corners and the front desk the lower faceted rectangle .
bold typeface values are part of the system con guration the others change as the system evolves with the values that are modi ed at each step underlined.
although this particular con guration leads to a counter example the problem may go unnoticed if one is required to perform the analysis for a speci c user picked con guration e.g.
wherer1 was assigned k1 andk2 and r2 the remaining keys .
distributed spanning tree algorithm.
this example concerns a simple distributed spanning tree algorithm that runs on an arbitrary but connected network topology building on the one proposed in .
here adistinguished root node possibly elected beforehand starts by assigning itself level .
nodes with assigned levels i.e.
already in the spanning tree broadcast their level to the neighbors.
when a node not yet in the spanning tree receives one such message it sets its level to one plus the level of the sender and records it as its parent node.
the details of message passing are abstracted away by allowing the system to evolve by selecting an arbitrary node to act among those not in the spanning tree but with neighbors already so and arbitrarily choosing one of the latter as parent.
here a con guration consists of a set of nodes a root node among them and a possible network topology which may take the shape of an arbitrary undirected connected graph while the dynamic aspects encompass the level and parent structures of the tree being computed r1r1 .
the speci cation of a valid topology requires a reachability constraint r2r2 .
in general the same topology may lead to several di erent spanning trees and this non determinism can be captured by declarative operations where the selection of the process to act as well as its parent is arbitrary within the stated constraints r3r3 .
both a safety and a liveness properties are expected to hold for every network topology i.e.
system con guration r4r4 the algorithm never introduces a cycle in the parent structure and a spanning tree of the whole network is eventually computed respectively.
figure 22depicts a possible execution trace of the algorithm for a speci c con guration with four nodes p1top4 root nodep2 bold circle and network topology depicted with dashed lines.
the changing elements of the speci cation namely the level and parent of each node are represented in the lower half of the respective circle and by solid arrows leaving from them respectively.
again the values updated in each step are underlined.
elevator system spl.
this example models an elevator system spl inspired by the one proposed in and extended in .
the model consists of an elevator and a set of oors at each oor there is a button that calls the elevator and inside it there is a button for each of the oors.
the base system answers button calls giving priority to the current direction it only changes direction when there are no more calls for the succeeding oors.
this behavior is however modi ed as additional features are selected.
for instance a parking feature moves the elevator to the rst oor when there are no button calls an idle feature forces the elevator to open the door when there are no button calls an executive oor feature prioritizes calls to one of the oors over the others.
multiple interfering features under some restrictions may be selected.
here each con guration represents a valid product from the spl that is a selection of features while the dynamic component models the evolution of the system taking into consideration those features r1r1 .
the selection of these features is restricted by a feature diagram that de nes simple dependencies con icts between the features which can be encoded as structural properties r2r2 .
for instance since the idle and the parking features have con icting behavior their choice could be forced to be exclusive.
the operations must be su ciently expressive to encode the behavior of the system taking into consideration the selected features r3r3 .
there are several safety and liveness properties that should be checked about this speci cation r4r4 .
for instance the most basic liveness property states that a pressed buttoncheckin g1 r1 k2 checkout g1 checkin g2 r1 k3 entry g1 r1 k2 r1 k1 k2 k3 k1r2 k4 k4g1 g2 r1 r2 r1 k1r2 k4r1 g1r2 r1 k2r2 k4r1 k1 k2 k3 k1r2 k4 k4g1 k2 g2 r1 r2 r1 k2r2 k4r1 k1 k2 k3 k1r2 k4 k4g1 k2 g2 r1 g2r2 r1 k3r2 k4r1 k1 k2 k3 k1r2 k4 k4g1 k2 g2 k3 r1 k1 k2 k3 k2r2 k4 k4r1 g2r2 r1 k3r2 k4g2 k3 g1 k2 figure execution trace for the hotel room locking system leading to a counter example.
p2 p3 p1 p4 act p2 act p1 act p4 act p3 p20p3 p1 p4 p20p3 p11p4 p20p3 p11p42p20p32p11p42 figure execution trace for the spanning tree algorithm.
will eventually be answered.
these must be checked over every possible feature combination.
while some of these are expected to always hold some fail under certain feature con gurations.
for instance the above property will fail with the executive oor feature as calls to those oors will be prioritized.
.
contributions unfortunately most formal speci cation languages and accompanying model checkers are not designed nor optimized to analyze problems such as these.
for example most standard model checkers only perform well with xed con gurations while languages more geared towards the analysis of structural properties usually without native support for some sort of temporal logic require the user to verify behavioral properties through ad hoc mechanisms.
this paper aims precisely to ll this niche and proposes a language and model checker tailored for the lightweight analysis of dynamic systems with rich con gurations.
concretely we propose a formal speci cation language inspired by alloy andtla two of the most popular speci cation languages nowadays that simpli es the speci cation of systems exhibiting all the requirements de ned above two model checking techniques one bounded and the other unbounded to verify systems expressed in such language namely to verify that every desirable temporal property holds for every possible con guration.
the remainder of the paper is organized as follows.
section22explores related languages and techniques and justi es why they fall short when analyzing this class of problems.
section 33presents the proposed language its semantics and the proposed model checking techniques.
their performance is then evaluated in section .
finally section 55draws conclusions and points directions for future work.
.
related work there are numerous approaches to the speci cation and model checking of systems.
here we focus on those whose level of expressiveness and tool support come close to that needed to handle systems with rich con gurations i.e.
that address some of the four requirements de ned in section .
alloy is a lightweight formal speci cation language with an object oriented avor which paired with its analyzer that provides support for automatic bounded veri cation has been increasingly adopted by software engineering practitioners.
the underlying formalism of alloy isrelational logic rst order logic enhanced with transitive closure operations that render the de nition of structural properties extremely simple.
thus alloy is naturally wellsuited to handle the r2r2requirement.
however alloy is inherently static thus the veri cation of behavioral properties usually relies on well known idioms that have emerged due to the language exibility.
such ad hocspeci cation is error prone and verbose and forces developers to be concerned with particularities of the idiom rather than with the properties that they actually wish to verify see for instance and as a consequence regular alloy is not well suited to address r4r4.
to overcome this limitation considerable research has been dedicated to enhance alloy with dynamic behavior .
the main drawback of these approaches is that they compromise the exibility that the alloy users are accustomed to introducing syntactic extensions that force them to adhere to speci c idioms and consequently breaking the r3r3requirement.
that is the case for instance of dynalloy an alloy variant that resorts to dynamic logic to specify behavior.
liveness properties which comprise a large class of behavioral properties are also not expressible in dynalloy and thus r4r4is not e ectively addressed.
although expressible in regular alloy via said idioms verifying such properties with the analyzer requires some insightfulness and care from the user to avoid the spurious counter examples that usually occur with naive encodings of bounded model checking techniques .
the technique from enhances alloy with imperative constructs again undermining r3r3.
in contrast the technique proposed in extends the relational logic of alloy with ctl temporal logic.
unfortunately the system actions must be speci ed with a xed idiom with an imperativeavor and thus falls short on the r3r3requirement.
moreover it disregards the rich structural properties introduced by the signature type system from regular alloy undermining its ability to address r2r2.
finally even though all these works attempt to enhance alloy with dynamic properties besides that distinguishes between static and variable elds none properly address r1r1 since they do not distinguish between the system con guration and the dynamic components that evolve over time.
in contrast temporal model checkers are developed precisely to address the r4r4requirement.
among the most successful formalisms is the temporal logic of actions tla a variant of temporal logic that introduces the notion of action to model the evolution of the system.
actions are essentially predicates that relate two consecutive states specifying the acceptable steps that allow the system to evolve.
thus the tla speci cation language built over this logic naturally handles r3r3 and has proven to be well suited to specify systems with rich temporal properties.
moreover tla is accompanied by a set of e ective tools including tlc a model checker that has proven e ective on the veri cation of complex tla systems.
however in order to be manageable by tlc some additional restrictions are imposed over the tla language namely over the action predicates reducing its compliance with the r3r3requirement.
unlike most model checkers tla does support the specication of rst order logic properties addressing r2r2to some extent.
however unlike alloy it lacks a type system with inheritance that greatly simpli es the speci cation of complex entities and their relationships.
moreover due to the nature of the model checking procedure rich structural properties may severely hinder the performance of tlc since the rst step of the procedure involves calculating every possible initial state.
while tla does provide a simple mechanism to separate the system con guration from its evolution by allowing the distinction between variable and constant parameters tlc requires constant parameters to be xed a priori by the user limiting its ability to automatically explore all possible con gurations and thus to fully address r1r1.
to circumvent this problem con gurations must be encoded in regular variable parameters and then arti cially constrained in the speci cation to remain constant throughout the system evolution.
thus although both alloy and tla exhibit powerful but simple languages associated with e ective and automated tools they excel in the veri cation of di erent classes of systems and none addresses all four requirements identi ed above11.
the number of available model checking languages and tools is too large to allow for an exhaustive comparison here but in general they are not better than alloy or tla at dealing with dynamic systems with rich con gurations.
most like spin or the various smv variants do not even support rst order logic making it very cumbersome to specify complex structural properties.
this related work 1an in depth comparison of tla and alloy using the hotel room locking system as running example can be consulted in .
the speci cation of the running examples of this paper in both those languages can also be found at .focuses on alloy and tla because we believe they are quite close to excel at handling such systems and in fact the language here proposed combines their best aspects.
an alternative perspective to the problem of model checking multiple con gurations arises from the area of spls a set of software products that share common base functionalities.
the variability between the products is de ned through the selection of features acceptable feature combinations i.e.
products are de ned through feature diagrams that impose simple dependencies and con icts between them.
model checking an spl involves checking the properties for every acceptable product.
under our perspective each of these products represents a con guration of the system restricted by the rather basic structural properties entailed by the feature diagram that are to be checked for the temporal properties.
several techniques are able to model check spls.
most however are not accompanied by high level speci cation languages that allow both the modeling of the spl and the feature diagram.
one such language with support for model checking is fsmv an extension to smv.
it follows a compositional approach in the sense that each feature is implemented through modi cations to the base system.
featurealloy an extension to alloy following a similar approach has also been proposed .
in contrast in annotative approaches the spl is represented by a single system whose behavior is de ned by guards over the selected features.
one such language is fpromela an extension to the promela language of spin.
these approaches su er from the expressiveness problems of the languages they extend that have already been exposed previously in this section.
.
the electrum framework considering the presented state of the art this work proposes an extension of the alloy speci cation language with temporal logic operators denoted electrum and associated model checking tools that address all four characteristics identi ed in section .
.
language this section describes the proposed electrum language and its formal semantics in several steps starting with an informal overview in section .
.
.
.
.
to ease the presentation of the semantics section .
.
.
.
introduces an abstract syntax for a representative subset of electrum whose semantics is expressed in terms of a translation to a rst order temporal logic.
for the sake of readability this logic is described in section .
.
.
.
before the translation itself in section .
.
.
.
.
.
.
overview this section introduces electrum whose concrete syntax is presented in fig.
.
the language is inspired both by alloy for its structural concepts and by tla for its ability to freely de ne actions as predicates with primed variables.
the speci cation of the examples in electrum as well as their alloy and tla versions can be found here .
likewise alloy structure in electrum is introduced through the declaration of signatures which specify sets of uninterpreted atoms.
hierarchical signatures can be introduced byextension in which case the sub signatures must be disjoint or through inclusion in which case sub signatures may overlap with each other.
abstract signatures are comprised only of the atoms of their sub signatures.
finally signatures may be attached with multiplicities that restrict the num ber of atoms that they may contain.
signature declarations may also introduce elds with arbitrary nite arity that represent relations between the various signatures.
these constructs are essentially those provided by the standard alloy language.
contrary to alloy however both signatures and elds may be additionally tagged as variable meaning that their valuation may evolve in time.
in contrast non variable signatures and elds are assumed to be static meaning that their valuation remains xed throughout the evolution of the system.
thus electrum provides a clear distinction between the con guration of the system static constructs and its evolution variable constructs r1r1 .
additional restrictions are introduced through the de nition of paragraphs facts axioms impose restrictions on the speci cations and assertions denote properties that are to be checked over the speci cation.
predicates and functions are essentially reusable formulas and expressions respectively.
signatures may also be annotated with local facts that apply to every atom of the signature in every instant of time.
all these paragraphs are comprised of logical formulas that borrow their expressiveness from alloy supporting universal and existential quanti cations as well as transitive closure operations and from tla supporting classical temporal operators22as well as primed expressions and thus allow both the speci cation of rich structural properties r2r2 the de nition of actions in a exible manner r3r3 .
veri cation commands to be model checked are integrated in the speci cation le again inspired by alloy allowing the veri cation of rich temporal properties r4r4 .
check commands are passed an assertion and scopes for the static and variable signatures and instruct the modelchecker to try to prove the assertion while runcommands instruct the model checker to yield an example instance of the speci cation if there is one this way it also shows whether the speci cation is indeed consistent .
the scopes bound the maximum number of elements that a top level signature will at least contain and are described in more detail in section3.
.
.
.
.
remark that the model checking techniques are expected to explore every valid valuation of signatures and elds up to the given bound33.
it should be noticed that for a variable signature the scope bounds the total number of its instances over the complete life of the modeled system44.
figure 44presents the hotel room locking system speci ed in electrum.
rooms guests and keys are introduced by static signatures meaning that their valuation remains xed along the system evolution.
there is also a singleton signature fd representing the front desk.
there is only one static eld keys that represents the set of keys assigned to each room this distribution is constrained to be a partition by fact disjointkeys .
every other eld denoting the key currently coded for a room and the registry of occupants and assigned keys at the front desk is variable.
actions are declared as regular predicates that refer to the post state by priming 2the keyword after was chosen to stand for the x read next temporal operator because in alloy next is a predicate from a commonly used standard library for ordering and we wanted to preserve upward compatibility with alloy.
3this contrasts with tlc con guration les which assign concrete valuations to the constant parameters.
4as time may be unbounded this is a way to retain decidability while remaining faithful to the successful bounded veri cation practice of alloy.spec module qualname import paragraph import open qualname paragraph sigdecljfactdecljfundecljpreddecl jassertdecljcheckcmd sigdecl sig name vardecl sigext extends qualnamejinqualname mult lonejsomejone decl name expr vardecl decl factdecl fact block assertdecl assert block fundecl fun name expr expr preddecl pred name block expr constjqualnamej namejthisjunop expr jexpr binop expr jexpr arrowop expr jexpr jexpr compareop expr jexpr jimplies expr else expr jquant decl blockorbarj expr jblock j decl blockorbar jexpr const nonejunivjiden unop !jnotjnojmultjsetj j j jeventuallyjalwaysjafter binop jorj jandj jiffj jimplies j j j j j j j.juntiljrelease arrowop !
compareop inj letdecl name expr block expr blockorbar blockj expr quant alljnojmult checkcmd check qualname scope for number jfor typescope typescope number qualname qualname name name figure concrete syntax of the electrum language additions w.r.t.
the alloy syntax are underlined .
variable expressions.
finally the fact traces restricts the acceptable states of the system a state is either the initial one or obtained from the application of the actions.
over this speci cation the assertion nobadentry veri es whether there are unwanted room entries.
this assertion is referred by the check command immediately below that instructs the model checker to test the assertion for a scope of at most elements per signature it also de nes the scope for time instants if the analysis is performed by the bounded model checker as will be described in section .
.
.
the exibility of the language allows the adoption of varied speci cation idioms that could be cumbersome in more rigid speci cation languages.
for instance in the event idiom actions are embodied by model elements rather than by predicates.
this allows the developer to de ne a hierarchy of actions allowing the sharing of parameters e.g.
in the room locking system every action has a guest parameter and of constraints e.g.
in the front desk actions the frame condition on the room coded keys is shared resulting in simpler and more manageable speci cations.
figure 55depicts an excerpt of the hotel room locking system speci ed with the event idiom in electrum where each action is embodied by a variable signature the presence of an event atom in an instant denotes the occurrence of that action.
this excerpt is an alternative to the check in action predicate speci ed in fig.
.
when de ning these event signatures one must be aware of the bounded nature of the universe in order to not restrict the application of actions.
here the multiplicity oneof the abstract event signature from which the concrete events inherit forces the existenceopen util ordering asko sig key sig room keys set key var currentkey one keys fact disjointkeysets keys inroom lone!key one sig fd var lastkey room!lone key var occupant room!guest sig guest var gkeys key fun nextkey set key min pred checkin g.gkeys g.gkeys k nofd.occupant fd.occupant fd.occupant r !g fd.lastkey fd.lastkey r !k k nextkey r.keys all gg guest g gg.gkeys gg.gkeys all r room r.currentkey r.currentkey pred init noguest.gkeys nofd.occupant all r room fd.lastkey r.currentkey fact traces init always some g guest r room k key entry orcheckin orcheckout assert nobadentry always all r room g guest k key entry and some fd.occupant ginfd.occupant check nobadentry for but time time scope only for bounded verification figure hotel room locking system under electrum.
of exactly one event at each instant although the concrete event signature to which it belongs may vary in time this also simpli es the fact traces that will only be required to enforce the init constraint .
parameters of the actions are embodied by the event signature elds since all the actions in the hotel room locking system have a guest parameter this eld is de ned at the top level event signature.
another abstract signature fdevent represents every action that occurs at the front desk enforcing the frame condition on the door locks coded keys.
the concrete event signatures then de ne the speci c constraints that restrict their occurrence at each instant.
note how in the check in action presented in fig.
the constraint is identical to the one de ned in the predicate idiom in fig.
modulo the frame condition and thus no additional burden was imposed on the developer.
the remaining operations would be de ned in a similar manner.
figure 66depicts an excerpt of a possible speci cation of the elevator spl in electrum to illustrate its potential to handle systems with variability the actions are omitted .
here features are simply declared as static signatures a product being simply a subset of those features.
con icts between features are enforced through constraints over products.
theone var abstract sig event g guest var abstract sig fdevent extends event currentkey currentkey var sig checkin extends fdevent r room k key g.gkeys g.gkeys k nofd.occupant fd.occupant fd.occupant r !g fd.lastkey fd.lastkey r !k k nextkey r.keys all gg guest g gg.gkeys gg.gkeys figure excerpt of the hotel room locking system under electrum in the event idiom.
abstract sig feature one sig fidle fexecutive fpark extends feature sig product infeature fidle fpark not in this sig floor one b landingbutton b.floor this one b liftbutton b.floor this abstract sig button floor one floor sig landingbutton liftbutton extends button var one sig current infloor var lone sig open up var sig pressed inbutton pred prop always all f floor floor.f liftbutton inpressed eventually current f some open check fidle product prop for 6but time figure excerpt of the of the elevator spl under electrum.
oors and the respective buttons one landing and one elevator button per oor are also static and de ned by structural constraints.
the remaining signatures depict the variable components of the model.
at each instant one oor marks the current position of the elevator lone variable signatures act as temporal boolean variables that denote whether the elevator is open and moving in the upward direction nally a set of buttons is selected as pressed at each moment.
properties can then be checked for arbitrary or particular products e.g.
the check command in the excerpt checks whether calls from elevator buttons are eventually answered for products that only implement the idle feature.
.
.
electrum kernel following the approach of we simplify the presentation of the semantics of our framework by considering a stripped down language dubbed electrum kernel focusing only on formulas and relational terms.
the abstract syntax of electrum kernel is shown in fig.
.
for constraints and relational expressions the translation from electrum is relatively straightforward and follows that of alloy kernel speci cally in formulas the dual logical operators and connectives may be de ned in the obvious way .
in electrum kernel the main concept is that of relation.
we assume the existence of a set rofvariable relations whichformula not formulajafter formula jalways formulajeventually formula jformula until formulajformula and formula jterm intermjall decl formula term x2v arjr2r j termj term jterm termjterm termjterm .term jterm j decl formula decl x term figure electrum kernel abstract syntax.
are declared with their arity.
signatures and elds declared in electrum are translated into electrum kernel relations unary relations in the case of signatures .
we also assume the existence of a set varof rst order variables.
additional information expressed in signature and eld declarations in electrum multiplicities the fact that some signatures and elds are static signature hierarchy and local facts must be speci ed by formulas in electrum kernel in our prototypes more e cient encodings are implemented .
in order to illustrate the translation from electrum to electrum kernel let us consider the following example abstract sig a r some a var sig b c extends a in the corresponding electrum kernel speci cation three unary relations and one binary relation are declared.
relations a b c r the fact that ais not a variable signature is expressed by the formula always a a .
the fact that band cextend a which is abstract can be expressed by the formula always a b c and no b c .
now the typing and the multiplicity constraint related to the eld rare expressed as follows always rina!a always all a a some a.r local facts are surrounded by an always operator after translation forcing them to hold in every instant of time.
.
.
foltl the semantics of electrum kernel is expressed viaa translation into first order linear temporal logic foltl .
here we brie y describe its syntax and semantics.
de nition .
given mutually disjoint sets vandpof resp.
variables and predicates with their arity the syntax of foltl formulas is given as follows55 p x1 x k jx1 x2 j j j8x jx jg jf j u withxi2vandp2p of course p x1 xk is a formula only if the arity of pisk .
derived constructs can be de ned in the obvious way.
x read next means that is true in the next instant g read always means that willalways be true f read eventually means that will eventually be true and u read until means that is true and remains true until becomes true.
the release operator can be derived from u in the usual way.
5the symbol stands for equality in foltl in order to avoid notation clashes.foltl is provided with both unbounded and bounded semantics.
for the unbounded semantics time is interpreted over the set nof non negative integers.
each rst order variable is interpreted over the domain d. de nition .
amodel for foltl is a pair m d where the set dis the domain of rst order variables and maps each predicate p2pat each instant i2n to a relation p i dk wherekis the arity of p. the satisfaction of a formula by a model is then de ned as follows.
de nition .
given a modelm a formula an instant i2n and an environment mapping each free variable xto an element in the domain d the satisfaction relation m ij is de ned inductively as follows.
m ij x yif x y m ij p x1 x n if x1 xn p i m ij ifm i6j m ij ifm ij orm ij m ij 8x if for alla2d m ij m ij x ifm i 1j m ij g if for eachj i m jj m ij f if there isj is.t.m jj m ij u if there exists j is.t.m jj and for alli k j m kj a formula without free variables is satis able if and only if there exists a model msuch thatm 0j which is simply denoted by mj .
the bounded semantics of foltl can be derived from the unbounded one following the standard technique described in .
in bounded models of size k denoting traces with k states is partial function with domain f0 k 1g.
if such trace has a loop to time l k i.e.
the value of s k is equal to the value of s l for alls then the semantics is the same as in the unbounded case after unrolling the model to be de ned over n. if the trace has no loop then the semantics has to be slightly adjusted as such traces cannot be considered valid models of invariant formulas of type g as there could be a state after k 1that violates and only of formulas of type f as discussed in gandfare no longer duals in a bounded semantics hence the inclusion of both in the language kernel .
note that we do not follow the temporal semantics from tla which makes formulas invariant under stuttering for compositionality purposes but use instead the classic semantics of temporal logic which allows to specify behaviors that may not be invariant under stuttering.
.
.
from electrum kernel to foltl the essence of the interpretation of electrum kernel into foltl boils down to removing relational terms so that we end up with formulas only.
this is a standard approach when embedding the relational logic of alloy into fol .
thus the main operation consists in removing all membership and inclusion statements present in electrum kernel formulas and replacing them with corresponding foltl subformulas.
hence the semantic map denoted j k relies on a function which given a pair of a tuple of variables and a term yields a formula stating that the former is a member of the latter.
for the sake of readability tuples are writtenjnotfk jfk jafterfk xjfk jalwaysfk gjfk jeventually fk fjfk jf1untilf2k jf1kujf2k jf1andf2k jf1k jf2k jt1int2k x where xarefresh variables jallx t fk 8x jfk x y r x there are y1 y nsuch that y1 x1 yn x2 i n with x y z 9u where x y z anduis afresh variable x 16i6j xj jff y xgk whereff y xgis the usual substitution.
figure from electrum kernel to foltl cf.. def.
.
as vectors their concatenation is denoted by juxtaposition andj jstands for their length.
de nition .
the formal semantics of electrum kernel formulas into foltl formulas is de ned by structural induction according to fig.
.
.
verification while electrum supports the de nition of both rich specications and properties to be checked over them it is only useful if accompanied by e ective model checking techniques.
fitting the dual nature of the problem at hand two distinct approaches to the model checking of electrum speci cations were explored one bounded and another unbounded.
before detailing these we rst describe the commands provided by electrum for formal analysis.
.
.
commands and scopes as presented in section .
.
.
.
an electrum speci cation integrates execution commands for the model checker.
the di erence between both veri cation approaches lies in the way time is handled.
in the bounded approach time is internally handled as a signature and is thus bounded the same way as others and in the other time is left unbounded.
the maximum number of time instants considered by the bounded approach is also de ned in the scope of the commands which is simply ignored by the unbounded approach .then given an electrum model and a scope every signature or eld is instantiated depending on the bound of signatures.
the model and the run or check command give rise to a formula mand a formula r or c respectively.
finally if the command is a run the formula m ris checked for satis ability otherwise we check whether m cisvalid.
in the following we detail how these veri cation problems translate in practice.
.
.
bounded model checking the bounded semantics of foltl described in section .
.
.
.
can be directly encoded into alloy itself as described in by explicitly introducing a time signature with a total order imposed over it to represent the trace potential loops are represented by a relation from the last time atom to a previous one.
our bounded model checker is implemented using this alternative encoding and deployed as a new version of the alloy analyzer to minimize the adoption time by alloy practitioners.
this analyzer not only generates a single counter example depicted visually but allows the user to iterate over all possible counter examples within the speci ed bounds that broke the speci ed properties thus providing the user with a wider perception of what may be the problems of the speci cation.
note that this bounded model checking procedure is iterative checking the properties for increasing trace sizes up to the speci ed scope on time stopping along the way if a counter example is found.
.
.
unbounded model checking this technique is implemented in a prototype called the electrum analyzer.
it relies on a direct embedding into the nuxmv tool66which implements various algorithms performing unbounded model checking we currently rely on the so called k liveness algorithm .
its free software predecessor nusmv can also be used but it is far less e cient on the examples we have studied so far.
the principle of the translation proceeds as described before chaining a translation from electrum to electrum kernel then to foltl and nally to ltl.
compared to the semantics presented in this paper several simple optimizations are also implemented smarter optimizations are left for future work .
now nuxmv expects a description of a transition system and a formula to check on the latter whereas an electrum model is essentially a formula specifying a set of transition systems that satisfy it .
hence the generated smv model does not contain an explicit transition system i signatures and elds give rise to frozen or plain variables depending on their status static or variable ii various formulas related to the typing and inclusion of signatures and elds are combined to form an invariant section in the le.
this is important as it allows to constrain and reduce the size of the state space.
a possible improvement would be to infer a non deterministic transition system and add a corresponding smv assign section restricting the state space further.
then a so called smv ltl speci cation is produced that represents the formula to be veri ed77.
finally it should be remarked that the present approach allows to perform veri cation on an unbounded time horizon but it does not allow to perform scenario exploration namely 6available at .
7this formula is in practice dualized w.r.t.
the description in section .
.
.
.
as nuxmv expects speci cations expressed as validity problems rather than as satis ability ones.iterate over counter examples the same way the bounded approach does.
therefore regardless of practical performance results both approaches are complementary.
.
ev aluation this section presents the empirical evaluation of our language and the proposed model checking techniques.
concretely we aim to assess how the performance of the proposed bounded and unbounded checking techniques compare with each other and with other existing similar approaches.
to answer these questions a detailed evaluation of the proposed techniques under the examples from section .
.
is presented as well as a summary of the results for an additional speci cation with rich con gurations.
regarding the hotel room locking system two versions are considered hotel checks the desired safety property and thus leads to counter examples and hotel checks the same property but with an additional constraint that prohibits any other action to occur between a guest checking in and entering a room and as a result is correct.
recall nonetheless that the counter example in hotel does not occur with every con guration.
in these examples the size of the model ndenotes the number of keys rooms and guests available in the universe.
for the spanning tree algorithm we consider the following veri cation goals span checks the liveness property without enforcing fairness thus producing counter examples span checks for the liveness property but with fairness enforced and thus is correct and span checks for the safety property and does not generate counter examples.
here model size ndenotes the number of processes and tree levels in the universe.
for the spl example we consider two check commands elevator tests the liveness property for products implementing only the idle feature which holds elevator tests the property for arbitrary products which does not hold.
here ndenotes the exact number of oors.
additionally we explore another distributed algorithm over arbitrary topologies that is packaged with the alloy analyzer whose speci cation was quite simpli ed with electrum.
concretely we consider a distributed algorithm for the election of a leader in a network with ring topology inspired by the speci cation presented in .
this speci cation is checked for two temporal properties that at least one leader is eventually elected a liveness property and that at most one leader is elected a safety property .
di erent versions of the speci cation were considered ring checks the speci cation for liveness without fairness enforced ring checks for liveness with fairness and ring checks for safety which holds.
as has already been stated in section the two existing techniques that we believe are best suited to model check speci cations with rich con gurations are alloy and tla .
since our bounded technique actually relies on alloy we will focus on comparing the performance of our two techniques with that of tla tlc.
all tests were run multiple times using alloy .
with the minisat solver and nuxmv .
.
on a ghz intel core i5 with gb memory running os x .
.
tlc .
was used for the tla tests.
note that for the unbounded approach we pre process electrum les to replace every command by all possible combinations of the said command with exact scopes .
then we generate as many corresponding smv les and run nuxmv in parallel on all cpu cores using gnuparallel starting with the smallest scopes and stopping immediately if a property is refuted.
.
results figures 9a9aand10a10apresent the performance for the hotel room locking system and the spanning tree algorithm for a xed sizen 4and increasing trace length tfor the bounded scenario.
labels hnand snstand for the hotel n and span n scenarios respectively and bndandubdstand for the bounded and unbounded techniques.
in the unbounded technique the properties are checked for arbitrary trace lengths and thus their performance is depicted by a constant function in these graphs.
note also that in the bounded scenario each trace length aggregates the time spent verifying the smaller traces i.e.
the time spent to assess that a property holds for t 4includes checking the property for lengths and .
in the scenarios where there are counter examples to be found the performance of the bounded technique stabilizes at the tvalue where that counter example nally occurs e.g.
for hotel .
this is due to the iterative nature of the technique once a counterexample is found the procedure is stopped and not run for largertvalues.
in contrast when no counter examples occur the technique must be run for every trace length value and keeps increasing with t. the performance of the unbounded approach is also better when there are counter examples to be found due to the parallelization of the procedure that stops as soon as a counter example is found.
for the scenarios without counter examples the procedure must check the properties for every launched process.
the bounded technique outperforms the unbounded one for smaller trace lengths but their performance starts to converge as the t value increases.
this reinforces the common policy of relying on bounded techniques to quickly discard trivial counterexamples and move on to unbounded techniques only when the con dence level is high enough.
in contrast figs.
9b9band10b10bpresent the performance of the model checking techniques for increasing model size n and xed trace length t for the bounded technique .
again for the bounded scenario the results aggregate the time spent for trace lengths up to .
at suchtvalue the performance of the two model checkers is almost similar for the considered examples although the bounded technique still outperforms the unbounded one.
for hotel and span the performance of the bounded technique improves atn 3andn respectively because these are the sizes where counter examples rst appear and for smaller sizes the properties must be checked for every trace length.
table 11summarizes the evaluation for the explored examples and reinforces the conclusions discussed above.
it also presents the number of valid con gurations for each of the scenarios.
note how the hotel room locking system already has valid con gurations for n .
the alloy analyzer has a powerful symmetry breaking algorithm that infers an equivalence class within the search space highly reducing the number of explored models.
for example in the same example the number of non symmetric con gurations is only .
by performing the bounded model checking of electrum via an embedding into alloy we take advantage of this mechanism hence the quite positive results for this technique.
this also points for interesting possible optimizations of the unbounded model checking technique namely its parallelization based on unique non symmetric con gurations.
a fixed n and increasing t. b fixed t and increasing n. figure performance tests for hotel andhotel .
a fixed n and increasing t. b fixed t and increasing n. figure performance tests for span span andspan .
spec.
n cfg sym type holds bnd s ubd s hotel s .
.
hotel s x .
.
span l .
.
span l x .
.
span s x .
.
ring l .
.
ring l x .
.
ring s x .
.
elevator l .
.
elevator l x .
.
table summary of the performed tests for t for the bounded scenarios s is for safety l is for liveness .
for the comparison with tlc we encoded the considered examples in tla .
in general our model checkers outperform tlc when there are counter examples to be found.
for instance for hotel withn tlc takes .
seconds to generate a counter example.
in contrast tlc outperforms our unbounded technique when there are no counter examples.
for instance for hotel tlc takes .
seconds to check that the speci cation is correct.
note that our unbounded technique unlike tlc which imposes constraints on how actions can be speci ed can handle actions speci ed in a very liberal declarative style.
nonetheless our experiments show that tlc is heavily a ected by the number of valid con gurations worsened by the fact that it is not able to explore symmetry since these a ect the number of initial states that must be explored.
in fact in the hotel scenarios for sizes higher than n tlc runs out of memory when calculating the initial states.
our unbounded model checker is still able to terminate in such scenarios.
.
conclusion this work proposed a language electrum mixing the best aspects of both alloy and tla currently two of the most popular formal speci cation languages and that we believe hits the sweet spot for the speci cation of dynamic systems requiring rich declarative speci cations both of structural aspects namely con gurations and dynamics .
two modelchecking tools for this language were also developed one bounded and the other unbounded that our preliminary evaluation already showed to be competitive performance wise with existing model checkers in particular tlc.
the bounded model checker is useful at early analysis stages namely excelling at founding and iterating over counterexamples while the unbounded one naturally slower should be used afterwards for further con rmation of the results.
in the future we intend to improve the electrum framework in two key aspects rst building on previous work on scenario exploration we intend to improve the counter example generation and iteration features by allowing the user to parameterize the tool to prioritize certain aspects for example showing rst counter examples similar to those found in previous versions of the speci cation second we intend to improve the e ciency of the unbounded model checking technique in order to take advantage of symmetry breaking namely explore a hybrid veri cation approach where a bounded analyzer would compute in advance bundles of non symmetric static con gurations to be used to optimize the ltl speci cations passed to each parallel unbounded checking process.
.