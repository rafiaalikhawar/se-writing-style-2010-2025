efficiently manifesting asynchronous programming errors in android apps lingling fan east china normal university chinating su east china normal university china nanyang technological university singaporesen chen east china normal university china guozhu meng chinese academy of sciences china nanyang technological university singaporeyang liu nanyang technological university singaporelihua xu new york university shanghai china geguang pu east china normal university china abstract android the mobile app framework enforces the single guithreadmodel in which a single ui thread manages gui rendering andeventdispatching.duetothismodel itisvitaltoavoidblocking theuithreadforresponsiveness.onecommonpracticeistooffloadlong runningtasksintoasyncthreads.toachievethis androidprovidesvariousasyncprogrammingconstructs andleavesdevelopers themselvestoobeytherulesimpliedbythemodel.however asourstudyreveals morethan25 appsviolatetheserulesandintroduce hard to detect fail stoperrors whichwetermasaysncprogramming errors apes .
to this end this paper introduces apechecker a technique to automatically and efficiently manifest apes.
the key idea is to characterize apes as specific fault patterns and synergistically combinestatic analysisand dynamic uiexploration to detect and verify such errors.
among the real world android apps apechecker unveilsandprocesses61apes ofwhich51are confirmed .
hitrate .specifically apechecker detects3xmore apesthanthestate of arttestingtools monkey sapienzandstoat and reduces testing time from half an hour to a few minutes.
on a specifictypeofapes apechecker confirms5xmoreerrorsthanthe data race detection tool eventracer with very few false alarms.
ccs concepts software and its engineering software testing and debugging ting su is the corresponding author of this paper.
emails ecnujanefan gmail.com tsuletgo gmail.com ecnuchensen gmail.com gzmeng ntu.edu.sg yangliu ntu.edu.sg lihua.xu nyu.edu ggpu sei.ecnu.edu.cn permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
asynchronous programming error testing static analysis android acm reference format lingling fan ting su sen chen guozhu meng yang liu lihua xu geguang pu.
.
efficiently manifesting asynchronous programming errors in android apps.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 12pages.https introduction most modern gui frameworks such as swing swt android qt wxerlang andmacos cocoa enforce the single gui thread model in which one single ui thread instantiates gui components and dispatches events.
specifically ui thread fetches system or user events off an event queue and dispatches them either to a responsible app component s handler or to a ui widget s event handler.
these handlers run on the ui thread and exclusively update guis if necessary.
due to this single gui thread model it is vital to avoid blocking the ui thread.
therefore most gui frameworks recommendto offload intensive tasks e.g.
network access database queries to async threads i.e.
background threads .
take android developmentframework adf asanexample itprovidesmanyasync programming constructs e.g.
aysnctask thread asynctaskloader intentservice to achieve this goal.
like other frameworks adf leaves developers themselves to properly handle the interactions between these async threads and the ui thread obey the rules implied by the single ui threadmodel.
however our investigation on apps that use asyncconstructs shows more than apps violate these rules andintroduce fail stopbugs.
forexample ifa workerthreaddirectly updates the text displayed on the ui thread the app will crash.
another example is when an async thread finishes its background task and tries to send a ui update event to a gui component.
before the update takes effect if the user rotates the screen the ui threadwilldestroyandrecreatethatguicomponent.bydefault the update event is routed to the destroyed gui rather than the newlycreatedone whichmaycrashtheapp.inthispaper weterm authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france l. fan t. su s. chen g. meng y. liu l. xu and g. pu such fatal programming errors that violate the rules implied by the single ui thread model as async programming errors apes .
such bugs in android are not easy to detect manually due to they usually reside in the code of handling interactions between ui threadandasync threads which canbe rathercomplicated for manualanalysis theycanonlybetriggeredattherightstatesof gui components e.g.
activity fragment with complicated lifecycle theyhavetobetriggeredatrightthreadscheduling while the execution time of async threads is affected by the task and its running environment e.g.
network stability system load .
evenworse existingbugdetectiontechniquesareineffectivefor such bugs.
first most gui testing techniques e.g.
random testing search based testing and model based testing are designed for functional testing in general.
theyaimatenumeratingallpossibleeventsequences gui level events in particular to manifest bugs which is unscalable and time consuming.
additionally they mainly aim at improving code coverage which may not be sufficient for exhibiting apes requirespecificeventsequenceswithappropriatelifecyclestatesand threadscheduling.second staticanalysistools e.g.
lint findbugs and pmd although scalable only enforce simple rules syntaxortrivialcontrol data flowanalysis tolocatesuspiciousbugs.forexample lintdeclaresitcanfind wrongthread er rors onetypeofapes .however asourevaluationinsection demonstrates lint incursanumberof falsenegatives failing to detectthosesophisticated wrongthread errorsaswellasother typesofapes.third otherfaultdetectiontechniques e.g.
dataracedetection haveonlytackledpartsofapes.tosystematicallytackleapes weconductedaformativestudyon2097 android apps to understand them.
first we find the async constructs areindeed widely usedin .
apps and aysnctask s and threads account for the majority.
second we identified async programming rules see section .
implied by the single gui thread model by analyzing android docs technical posts and previousfault studies on async programming.
third from apps that use async constructs we found that developers do violate these rules and introduce apes.
we collected real apes involving exceptiontypes thrownfromapps e.g.
calledfromwrongthread illegalstateexception badtokenexception etc.
informedbytheaboveresults wedevelopanapproach apechecker .
itfirstcharacterizes3faultpatternsfrom375issuesbasedonthe 3rules andsynergisticallycombinesstaticanalysisanddynamic ui exploration to efficiently manifest apes.
specifically it encodes the fault patterns into a static analyzer locates suspicious apesin the app code generates a set of program paths that can reach the faulty code maps program traces to real event sequences with appropriateenvironment andfinallyverifytheseerrorsontheapp.
we evaluate apechecker on a set of real world android apps andcompareitwiththreestate of the artguitestingtools monkey sapienz andstoat andtwofaultdetectiontools lint and eventracer .
the results show apechecker unveils and successfully processes apes of which can be reproduced .
hitrate withrealtests apechecker detects 3xmoreapesthanthetestingtools andreducesdetectiontimefrom half an hour to a few minutes and within comparable analysistime apechecker detects5xmoreapesthaneventracer with very few false positives.async thread 1ui thread loopermessage queue dialogactivityfragmentactivity async thread 2async thread 3r1ui eventssystem eventsbroadcast receiverservice ui events update createaccess r3 r2 figure single gui thread model of android and its three basic rules.
to summarize this paper makes the following contributions weconductaformativestudyon2097androidappstoinvestigate apes and identify three async programming rules implied by the single gui thread model.
we develop apechecker a technique that synergistically combines static analysis and dynamic ui exploration to efficiently detect and verify apes.
weevaluate apechecker on40real worldapps andclearlydemonstrate its effectiveness over the state of the art testing and other fault detection techniques on apes.
async programming errors .
async programming in android fig.1depictsthesingle gui threadmodelofandroid.theuithread maintainsa messagequeue andits handlerenqueuessystemorui eventsintothisqueue.theseeventscomefromappcomponents e.g.
broadcastreceiver s services orguis e.g.
activityanditsassociated visible components like dialogso rfragments .
the ui thread s looperdequeueseventsinasequentialorderanddispatchesthemto thehandlerforprocessing.theuithreadinvokesthecorresponding event handler w.r.t.an event and updates guis if necessary.
adfprovidesvariousasyncprogrammingconstructs .there arefourtypicalconstructs i.e.
aysnctask thread asynctaskloader andintentservice .
among them asynctask allows one to perform short background operations and publish results on the ui thread threadisinheritedfromjava andexecutestasksinthebackground asynctaskloader utilizesaysnctask to perform async data loading and has similar callbacks as asynctask but it is lifecyle aware adf binds unbinds the worker thread according to gui s lifecyle.
intentservice handles async requests in an async thread and sends the results to the ui thread vis a broadcast receiver .
fig.2illustrates the use of aysnctask si nadsdroid it starts two async threads i.e.
searchbypartname lines and downloaddatasheet lines tosearchelectroniccomponents datasheet anddownload fromaremoteserverifrequested.theactivity searchpanel lines searches for the result with user input in the showing a progress dialog in onpreexecute before searching and dismissesitvia onpostexecute .theresultsareshownina listview oftheactivity partlist lines25 inwhichuserscanclickany matched item lines for downloading.
however therearetwoapes lines17and46 neitherofwhich hasbeencoveredbydevelopers.therootcausesforthesetwoapes aresimilar.
whenusers rotatethe screenright afterthe startof the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficiently manifesting asynchronous programming errors in android apps ase september montpellier france the acitivty that shows the search panel public class searchpanel extends activity progressdialog msearchdialog public void searchbypartname view view msearchdialog new progressdialog this new searchbypartname searchmode partname .
exe cute asynctask to search parts private class searchbypartname extends asynctask ... protected arraylist part void .
.
.
.
.
.
other stuffs return search .
searchbypartname partname mode protected void onpostexecute arraylist part result super .
onpostexecute result msearchdialog is shown in onpreexecute msearchdialog .
d ismiss if result !
null intent i ntent new intent searchpanel .
this partlist .
class intent .
putextra partlist .
parts r e sult startactivity i ntent ... the activity that shows the list of matched parts public class partlist extends listactivity progressdialog mdownloaddialog the event handler for clicking l i s t item protected void onlistitemclick ... part selectedpart new p a r t ... mdownloaddialog new progressdialog this new downloaddatasheet .
e xecute se lectedpart asynctask to download the data sheet private class downloaddatasheet extends asynctask ... protected string part .
.
.
parts part selectedpart parts string f ilename filenameforpart sel ectedpart urlconnection pdfconnection sel ectedpart .
getpdfconnection pdfconnection .
connect .
.
.
fetch data from net work and update progress return filename protected void onpostexecute string result super .
onpostexecute result mdownloaddialog i s shown in onpreexecute mdownloaddialog .
dismiss if result !
null openpdf r esult g msearchdialog .
d ismiss l!
g mdownloaddialog .
dismiss figure motivating example aysnc tasks searchbypartname anddownloaddatasheet but before they finish i.e.
before the execution of onpostexecute s the app will crash when msearchdialog line and mdownloaddialog line are dismissed.
because the rotation will destroy the current activity and create a new one but the dialogs were attached to the original one which does not exist anymore.
this leads to a fatal badtokenexception .
we can see the right timing and lifecycle states arecrucialtomanifesttheseapes.thispaperaimsattacklingsuch hard to detect errors.
.
formative study tounderstandapes weconductedaformativestudytoinvestigate the following questions.
this enables our problem definition in section2.3and fault pattern analysis in section .
.
q1 areasyncconstructswidely usedbyandroiddevelopersto followthesingle gui threadmodel?
toanswerthis wefocuson thefourtypicalconstructsintroducedinsection .
andinvestigate open source android apps from f droid to observe the useof these constructs since f droid is one of largest android apprepositories which covers diverse application categories and allapps are open source and maintained on github google code etc.
weusesoot astaticanalysistool toidentifyaysncconstructs.
answer async constructs are widely used by android developers.
we found out of apps use async constructs account for .
.
among apps asynctask s 1248threads 286intentservice s and asynctaskloader s are used.
asynctask andthread accountforthemajority whichalsoconformstopriorwork .
q2 arethereanybasicrulesimpliedbythesingle gui threadmodelthatandroiddevelopersshouldobeyinasyncprogram ming?
are they common to other gui frameworks?
to answer this we conducted a thorough and careful inspection on an droid docs and apis including the principle of single guithread model various async programming constructs guicomponents etc and technical posts filtered from stack overflow the largest developer q a community by the keywords android plus the names of asyncconstructs tutorialsonasyncprogramming and fault studies on android .
answer weidentified3asyncprogrammingrules fig.
1annotated these rules as r1 r2andr3 which are also common to other modern gui frameworks.
rule1 asyncthreadsshouldnotupdateguiobjects since android ui toolkit is not thread safe the single gui thread model requires that async threads should not directly manipulate gui objects.
gui objects include visible components e.g.
update a dialog s message and data models e.g.
change the content of arrayadapter thatfitsinbetweena listviewandanarraylist .instead theyshould designate the ui thread to handle gui objects via ui safe methods likeactivity runonuithread .
this rule is also enforced by many gui frameworks e.g.
swing swt qt andcocoa.
rule async threads should not create gui components in the background the ui thread by default is created with a handlerandalooper.thehandlerenqueuesevents e.g.
messages or runnable objects into a message queue.
these events come fromdifferentappcomponentsandguis.the looperdequeuesand dispatches the events to the handlerfor processing.
however an asyncthread except handlerthread bydefaultisnotassociatedwith ahandler therebyitshouldnotdirectlycreateguicomponents e.g.
toast show dialog create inthebackground.instead theyshould postguicreationsviauithread s handlerintolooperforprocessing.
qt seventloop andwxerlang smailboxqueue enforcethissimilarrule.
rule async threads should avoid accessing guis or performing transactions inside async callbacks async callbacks suchasonpostexecute runontheuithread buttheyhavenoknowledge of the current states of guis.
because they are called when theasyncthreadreturns.asaresult accessingguisorperforming transactionsfor fragmentsinasynccallbacks e.g.
aysnctask onpostexecute loadercallbacks onloadfinished has the risks of sending gui updates to destroyed guis and losing app state .
cocoa touch gui framework of ios also enforces this similar rule .
q3 dodevelopersviolatetheserules?arethereanychallenges tosolvesuchapes?
toanswerthis weutilizegithubandgoogle code apis to scrawl the issue reports of apps that uses async constructs in q1.
to identify apes we only collect issues that are reportedwithexceptiontraces whichcontainthecallbacksofasyncconstructs theninspecttheirissuedescriptions comments patches if available to confirm valid issues that do violate the three rules.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france l. fan t. su s. chen g. meng y. liu l. xu and g. pu program trace generationpatterns event sequence generationissue reports static detectionenvironment generationfault pattern analysis crash reports faults x apktool error verification uiautomator figure workflow of apechecker answer we finally got valid ape issues.
the number of valid issues is not large since many issues are reported without exception traces.
it is reported only github issues have exception traces .but ourevaluation section revealsapes affectmore than apps.
these issues violate the rules in different forms involving9differenttypesoffatalexceptions e.g.
calledfromwrongthread illegalstateexception andbadtokenexception .theviolationsof rule1and3accountforthemajorityinthese375issues .
.by investigating the fixing process of these apes on github we note developers face three main challenges due to lack of adequate understanding they usually use simple try catches to fix apes manyapes resideinthe releasessince developersfailto discover them during development due to the lack of reproducing tests several developers complain about the difficulties of debugging.
.
problem definition we name the errorsthat violate the threebasic rules as aysnc programming errors and formulate our problem as follows.ui thread.
auithread uisthemainthreadthatiscreatedwhen an app starts and manages gui components.
async thread.
an async thread wis a worker thread that is instantiatedfrom anasyncconstruct e.g.
thread started bytheui thread e.g.
thread run and executes a task.
ui accessingandui safemethods.
aui accessingmethod i.e.
muiaccess may create a gui component e.g.
toast show change a gui component s state e.g.
dialog dismiss or commit fragment transactions.
a ui safe method muisafepermits safe gui access e.g.
activity runonuithread handler post or gui state check e.g.
activity isfinishing .
program trace and its event sequence.
a program trace tis a sequence of method calls m1 ... mi ... mn on the call graph of an app.
the event sequence sw.r.t.tis a set of user events e1 ... ei ... ek k susuallyholds thatcanexecuteout tunder thegivenenvironment e e.g.
threadscheduling networkstatus app permissions sensor inputs and platform versions .problemdefinition.
ourproblemistocheckwhetherthereexists anytrace tonwhich ucreatesanasyncthread w andwinvokes any ui accessing method that is not control dependent on a ui safe method.
if texists we find an event sequence lthat follows tto exhibit the error under given environment e. .
prior work prior work has only tackled parts of this problem.
one close work isfromzhang et al.
whichfindsinvalidthreadaccesserrors in java gui applications swing swt android and gives warnings intheformofmethodcallchains.however thisworkhasseveral significantdifferencesfromours first theyonlyhandleasubset of errors w.r.t.rule i.e.
an async thread directly accesses gui components.second theyusestaticanalysistocheckwhetherathreadspawningcanreachaguiobjectaccessingmethod whichisdetermined by the viewroot checkthread method in adf.
this is ad hoc and may miss many errors.
third they do not confirm errors whichmaybringmanyfalsepositives.incontrast weconductasystematicstudytounderstandapes andcombinestaticanddynamic analysis to confirm errors with real tests.
lin et al.
investigate the uses of asynctask and observe the invalid thread access errors.
buttheyaimtosolveanotherdifferentproblemofautomatically refactoring long running tasks in ui thread into aysnctask s. another area of relatedwork is detecting and reproducing concurrency bugs data race in particular .
theytreatsomeapes w.r.t.rule3asdataraces.forexample the twoapesinfig.
2canbeinterpretedasdataracessincethe mpanels variableinsidetheframeworkclass phonewindow canbeaccessed simultaneously by the ui and async thread in which one access isawriteoperation.existingdataracedetectiontools exploit dynamically explored event traces to build a happen before graph andthenquerythegraphtofindpotentialdataraces.but they have several limitations in practice to detect apes first their effectiveness heavily relies on the traces for building the graph.
if the traces have not fully covered app code the detection abilityis limited.
second they usually generate a large number of false positivesduetoconservativeanalysis .existingdataracereproducing tools arealso impractical sincethey either require user providedtracesordependontheresultsofdataracedetection tools whenconfirming bugs.section 5compares apechecker with existing data race detection tools to confirm these observations.
our approach apechecker this section details our approach apechecker .
figure3shows its workflow which is composed of five key steps apechecker summarizesasetoffaultpatternsfromthecollectedapeissues encodesthesefaultpatternsintoastaticanalyzertolocatefaulty code generatesasetofprogramtracesthatcanreachthefaultycodefromtheappentry mapstheprogramtracesintorealevent sequences tests with appropriate environment and verifies apes with the tests and dumps crash reports for fixing.
.
fault pattern analysis we categorize ape issues into three groups w.r.t.the rules summarized in the formative study.
by analyzing these issues we characterize these apes as three fault patterns.
fault pattern if an async thread wis started and wcalls a ui access method muiaccess which is not control dependent on aui safemethod muisafe.thispatternviolates rule whichis represented as start w muisafe muiaccess.
fig.4shows suchanerrorof pedometer anappthatstorestheuser sstep countperhour thesymbol denotesthecorrespondingpatch authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficiently manifesting asynchronous programming errors in android apps ase september montpellier france !
!
.
.... .. figure example of fault pattern !
.
!
.
.
!
.
!
figure example of fault pattern to fix this error .
in fragment monthlyreportfragment it starts an aysncthreadtogeneratethemonthlyreportandrefreshthegui by invoking notifydatasetchanged which crashes the app.
fault pattern if an async thread wis started and wcalls a gui creation method muicreate which is not posted on the ui thread by mpostlooper to execute.
this pattern violates rule which is represented as start w mpostlooper muicreate.
fig.5shows such an error of gisapp which is a user interface controls library for android geo applications the symbols and denote the corresponding patch to fix this error .
gisappuses an async thread exporttask to export the data by retrieving the database and use toast maketext to show a message if no data is available.however exporttask hasnotreferredtotheuithread s handlerto post messages which crashes the app.
faultpattern3 ifanasyncthread wisstarted andbefore wreturns thetargetactivityorfragment aisdestroyedorstopped and afterwreturns itsasynccallbackcallsaui accessmethod muiacess which is not control dependent on a ui safe method muisafe.
this pattern violates rule which is represented as start w destroy a orstop a return w muisafe muiaccess.infig.
there are two such errors.
when users rotate the screen right after thestartofthe asynctask ssearchbypartname anddownloaddatasheet butbeforetheyfinish thedismissof msearchdialog line17 and mdownloaddialog line can crash the app.
.
static fault detection algorithm 1detailsstaticfaultdetection.ittakesasinputanapp the lists of ui accessing and ui safe methods summarized from android docs and outputs the ape locations including the startingpointsofasyncthreads .algorithm 1worksonthestaticcall graphofanapp whereeachnodedenotesamethod andeachedge angbracketleftf angbracketrightdenotes the call from the method fto .
we first identify all method nodes that start async threads line and check whether the use of corresponding asyncconstructs violate the rules linesalgorithm static fault detection input apk an android app uiaccessapis list of ui access methods uisafeapis list of ui safe methods output apes list methodstartthread stmtstartthread methodaccessui stmtaccessui 1apes 2c buildcallgraph apk 3asyncstartnodes getreachableasyncstarts c 4foreachnodenode asyncstartnodes do 5async getaasyncclass node 6o getoverriddenmethods async 7nodelist getcalledmethodnodes o c 8whilenodelist nequal do node nodelist .dequeue ifisvisited node then continue ifnode uiaccessapis then if controldepdent node uisafeapis then m getcallingmethod async n getcallingmethod node apes angbracketleftbigm async n node angbracketrightbig nodelist .enqueue getcalledmethodnodes node c 18returnapes .
for each aysnc construct we get the overridden methods accordingtoitsclasstype lines5 .take asynctask asanexample weconsider its callbackmethods onpreexecute andonpostexecute etc.byqueryingthecallgraph wegetsallthe nodescalledbythesemethods line7 .ifaui accessingmethod node is not control dependent on any ui safe methods e.g.
activity runonuithread thisnodewillbetaggedassuspiciousape lines12 .notethatweconductbothintra andinter procedural control dependentanalysistoreducefalsealarms.algorithm 1also checks the successor methods that are called by this node line to avoid false negatives.example .
in fig.
apechecker identifies that searchbypartname startsan asynctask searchbypartname .intheonpostexecute callback it locates a ui accessing method progressdialog dismiss line which is not control dependent on any ui safe methods e.g.
activity isfinishing tosafelycheckactivitystate.so apechecker reports a suspicious ape.
.
program trace generation algorithm 2detailstheprogramtracegeneration theideaissimilar to backward symbolic execution .
it takes as input a target methodandstatement i.e.
methodaccessui andstmtaccessui from algorithm and returns the traces i.e.
method call sequences thatcanreachtheape.itstartswithanemptytrace t andbacktrackstoreachtheentryactivity lines5 .specifically themaximumnumberofgeneratedtraces maxtracecnt line17 andthe maximum trace length maxtracelen line is configurable.
during the analysis each trace tmay have one of the three states i.e.
pending tis under propagation terminated treaches the entry activity failed the propagation fails due to dead code or limitations of static analysis tools .
if no traces are pending the analysis stops lines .
otherwise the analysis continues untilthemaximumtracelengthisreached.ateachiteration the algorithm uses two important variables i.e.
ptrmethod andptrstmt pointingtothecurrentbacktrackpointof t.whentispending the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france l. fan t. su s. chen g. meng y. liu l. xu and g. pu algorithm queries the callers of tviagetacycliccallers we details this function later .
if there areno callers twill be set as faileddue to the propagation cannot proceed lines .
otherwise we updateptrmethod andptrstmtoft lines16 .specifically if t s ptrmethod has multiple callers the algorithm will fork out a new tracet primefromt copying all previous backtrack information from t tot prime and add t primeinto the list of traces lines .
here updatetrace line and performs three operations check whether t sptrmethod has reached the entry activity and updatet s state accordingly.
in particular if ptrmethod is a callback method e.g.
user event handler of the entry activity twill be set asterminated .
update the method call chain of tby adding ptrmethod .
the method call chain will be later used to generate eventsequences.
recordtheconditionsinthebodyof ptrmethod thatptrstmtare control dependent on.
these conditions will be analyzed later to create necessary environment to improve the hit rate.
section .4will discuss the details of and .
the function getacycliccallers queries and returns the immediate callers of t sptrmethod .
it removes the visited callers to ensure the traces are acyclic.
when backtrack we differentiate three types of call relations that widely exist in android.
explicit calls .
the function fimmediately calls function i.e.
there exists an edge angbracketleftf angbracketrighton the call graph.
for example searchbypartname is explicitly calledby searchbypartname viaasynctask execute see fig.
.
implicitcalls .androidsystemshavemanyimplicitcallsthrough itsframework.animplicitcallfromfunction fto indicates fcalls asynchronously.forexample thecallback onpostexecute ofsearchbypartname isimplicitlycalledwhenthecallback returns see fig.
.
inter component transition calls .
android system uses intents to start activities or services.
for example in searchbypartname the activity partlistis called by the callback onpostexecute viastartactivity see fig.
.
example.
weexplainalgorithm 2onadsdroid .algorithm reportstwosuspicious faults oneofwhichisin the onpostexecute callback which dismisses mdownloaddialog without any ui safe methods line .
algorithm 2first initializes a pending trace whoseptrmethod issetas onpostexecute andptrstmtasthedismiss statement.
itthen finds is animplicit caller of onpostexecute see5 circlecopyrt .
next it finds onlistitemclick explicitly calls viaexecute see4 circlecopyrt .next itfindstheactivity partlist is called by searchbypartname onpostexecute see3 circlecopyrt and update ptrmethod asonpostexecute andptrstmtas thestartactivity statement line .
similarly it finally finds the method searchbypartname starts the searchbypartname see1 circlecopyrt .
the final trace is searchbypartname onlistitemclick only user event handlers are shown .
.
event sequence and environment generation this step converts the program traces from section .3into actionable event sequences with appropriate environment.
eventsequencegeneration .apechecker considerstwomaintypes of callbacks when converting a program trace.
usereventhandlercallbacks.
apechecker mapseacheventhandler on the trace to a corresponding action w.r.t.a ui widget oralgorithm program trace generation input method the target method stmt the target statement output traces the list of candidate traces 1lettbe an initially empty trace 2lettracelen be the current trace length initialized as 3t.ptrmethod method t.ptrstmt stmt 4traces t 5whiletracelen maxtracelen do 6if haspendingtrace traces then returntraces 8new traces 9foreachtracet tracesdo ifispending t then tis a pending trace t.callers getacycliccallers t.ptrmethod ift.callers then sett s state as failed updatetrace t continue letcbe the first caller of t.callers foreachcallerc prime t.callers c do ifcount traces maxtracecnt then t prime fork t t prime.ptrmethod getmethod c prime t prime.ptrstmt getcallsite c prime updatetrace t prime new traces new traces t prime t.ptrmethod getmethod c t.ptrstmt getcallsite c updatetrace t new traces new traces t else tis a terminated or failed trace new traces new traces t 29traces new traces 30tracelen tracelen view.
for example in fig.
the event handler onlistitemclick ... is mapped to a clickaction on a listviewitem searchbypartname declared in the xml layout file is mapped to a clickaction on the search button.
to achieve this apechecker maintains a viewhandler mapping table which supports event handler callbacks registered in both app code and xml layouts .
activity fragment lifecycle callbacks.
foranactivityorfragment lifecycle callbacks e.g.
onrestart onresume ondestroy o n thetrace apechecker automaticallysubstitutesthecallbackwith special events that can force app to execute it.
for example for onrestart apechecker generates along press home action show the list of recently opened apps followed by a touch action on this app switchbacktothepreviousappagain triggeringthelifecycletransition onstop onrestart forondestroy apechecker generatesa device rotation event triggering the transition onstop ondestroy onstart.currently apechecker considers activity fragment and other lifecycle aware components e.g.
loader .
environment generation .apechecker automatically constructs appropriate environment for event sequences.
during the trace generation apechecker recordsthecontrol dependentconditions ofanape andanalyzesthemtoderivetheenvironment.
apechecker currently focuses on three types of environment which we find they can cover most of cases.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficiently manifesting asynchronous programming errors in android apps ase september montpellier france specific user inputs.
apechecker tracks the constraints on user inputsthatcanaffecterrorverification.itcurrentlysupportstwo lightweight strategies infer the required input formats e.g.
email address phone number fromthe property android inputtype in the ui layout files and track the intra procedural data flows ofinputsandinfertherequiredcontentsbyanalyzingsimplestring apis e.g.
equal to a constant string contain a specific character .
explicitsystemsettingsorpermissions.
apechecker analyzesspecific apis in the recorded conditions to infer necessary system settings orpermissions.forexample if wifimanager iswifienabled isthe condition apechecker will disable wifi before replaying the test if camera open is thecondition apechecker will grantthe camera access permission at runtime when required.
specific exception handling.
some apes reside in exception handlingcode andtheycannotbemanifestedwithouttriggeringthe corresponding exception.
for example if the ape can be only reached by an ioexception when the app fails to access a remote server via network apechecker will disconnect the network before replayingthe testtosimulatethe exception.
apechecker onlyhandles specific cases of ioexception e.g.
cannot access network or files butitcanbeextendedtosupportotherexceptionsifrequired.
currently apechecker supportslimitedenvironment e.g.
specific user inputs network connection camera access file access in our evaluated subjects and does not consider external events e.g.
sensor inputs and intents .
the environment can be extended in the future by using more sophisticated techniques like symbolic analysis and exception handling .
.
error verification toconfirmanape wereplaythegeneratedeventsequencewith appropriate environment on the target app and monitor the intended9exceptiontypesviaandroiddebuggingbridge adblogcat .
for those apes whose manifestations require specific activity fragment state and thread scheduling fault pattern in particular we instrument the original app atoa primeby adding semaphore operationsp waiting and v release at appropriate program locations.
forasuspiciousfaultystatement iinthecallbackofasyncthread w we insert a poperation in the background callback before ito wait for a signal at the right activity or fragment lifecycle callback ontheuithread u weinserta voperationtosendthesignal.asa result we are able to control the thread scheduling and make sure the scheduling happen at the right lifecycle state.
note that if an appcorrectlyfollowsthe3asyncprogrammingrules thecontrol of thread scheduling will not introduce apes or force the app to crash.theinstrumentationmethodonlyamplifiesthepossibility of the long execution time to simulate real possible scenarios e.g.
delay of network access wait of data download and thus will not introducenewbehaviorsorchangeoriginalbehaviors.additionally theinstrumentationlocationsdependonthefaulttypes.for example to manifest activity state loss the voperation will be added in onstopsince state loss always happens after onstop.
example.
theapein searchbypartname onpostexecute infig2violatesrule .
to manifest this error apechecker instruments a p operation in the end of and instruments a voperation at the beginning of searchpanel ondestroy .
by this apechecker can easily manifest this error by a two event sequence i.e.
click the search button and rotate the screen.
implementation apechecker is implemented in java 5k loc and python 1k loc and built on several existing tools to automatically manifest apes.
itusessoot tobuildcallgraph staticallydetectsapesbasedon the three fault patterns and generatesprogram traces.
when generating program traces it extends ic3 to handle inner classes fragments and other public classes to reduce false negatives.
it currentlyconsidersacyclictraces andsetsthemaximumnumber oftracesto10andmaximumtracelengthto20.itutilizesgator theguihierarchyprinterclient clientinparticular tosetupthemappingrelationsbetweenusereventhandlersanduielements and convertsthehandlers inthegeneratedtrace toaneventsequence e.g.
click a button choose an item in the list .
the mapped ui elements usually have unique ids or texts which enables apechecker to interact with them.
it now supports back rotate home send the apptobackground long press home and back screen screenon off to tweak lifecycle.
apktool instruments semaphore p v operations into the ui thread and async threads to control thread scheduling.
uiautomator is used to execute tests and android debugging bridge adb monitors whether the app throws the intended exception types.
evaluation we applied apechecker on real world android apps and compared it with three state of the art gui testing tools monkey sapienz andstoat thegoogleofficialstaticanalysistoollint and thestate of the artdataracedetectiontool eventracer tomeasure its effectiveness.
we aim to answer these research questions.
rq1 howeffectiveis apechecker fordetectingapesinandroid apps?
can lint detect them?
rq2 howeffectiveis apechecker againstexistingguitesting techniques monkey sapienz and stoat for apes?
rq3 howeffectiveis apechecker againstexistingdatarace detection techniques for detecting specific types of apes?
.
evaluation setup subjects.wechoosesubjectsfrom f droid thelargestrepository for open source apps and google play store the official app store from google.
we crawled all unique apps from f droid and3107popularappsfromgoogleplaywithover10kinstallations.
sootsuccessfullyprocessed1654f droidappsand2719googleplay apps.
among them f droid apps and google play apps useasyncconstructs.next apechecker identifies866apesin234 f droid apps .
and apes in google play apps .
that contain suspicious apes respectively.environment .apechecker runs on a bit ubuntu .
machine with12cores .50ghzintelcpu and32gbram.weverifyapes on both an android emulator sdk .
.
and an lg nexus 5x mobile phone sdk .
.
.studies .weconductedthreecasestudies.in study weanswer rq1.
weneed to manuallyanalyze eachreported ape anddetermine the true positives and false positives which requires a lot ofhumanefforts.therefore werandomlyselectedaround10 fdroidandgoogleplayapps respectively theappsrequiringuser credentialsareexcluded 25f droidappsfrom234suspicious faultyapps with30374executablelinesofcode loc in jimple classes methods and activities on average and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france l. fan t. su s. chen g. meng y. liu l. xu and g. pu table subjects used in the experiment and evaluation results of apechecker and lint.
app name eloc classes methods activities time min apes detected apes processed repro.
fpfault type apes by lint open manager .
adsdroid .
deskcon .
tucanmobile .
radiodroid .
filmchecker .
quranformyandroid .
motac .
maximaonandroid .
debiandroid .
nextgis mobile .
a2dp volume .
andor .
mitzuli .
commons .
adaway .
servestream .
navit .
jku app .
homemanager .
transports bordeaux .
mtg familiar .
cowsay .
aeondroid .
addi .
average .
.
malayalamnewspaper .
drum solo .
smart poker .
lojas renner .
messaging .
recarga vivo .
instacartoonphoto .
fingerprint lock .
salmos .
santander .
biblia sagrada .
trade accounting .
premiumwallpaper .
tebak lagu .
worldnews live24 .
average .
.
googleplayappswith51722loc 267classes 1232methodsand activities on average shown in table .
we measured the static analysistime thetimeofreplaytestsisomitted sinceitonlytakes a few seconds the number of detected apes the number of apes thatcanbeprocessed limitedbytheabilitiesofsoot ic3 gator the number of apes that can be reproduced repro.
false positives fp the types of faults and the number of apes that can be detected by lint.
instudy2 weanswer rq2bycomparing apechecker withmonkey sapienz and stoat which have proven effectiveness on bug detection .
apps are randomly selected from fdroid apps that contain apes.
each tool is allocated with one hour with default settings.
the number of confirmed i.e.
successfully triggered apes theanalysistimeandthelengthoftests i.e.
event sequences are recorded.
from the perspective of their approach workflow all tools are given the original rather than the instrumented apps cf.section3.
as input to achieve fair comparison monkey sapienzandstoatdonotrequiretheinstrumentation for bug detection as their algorithms do not need instrumentation otherwise they may be adversely affected e.g.
stuck by the thread scheduling and alsodonot haveideaof wheretoinstrument.
to alleviatetherandomness weruneachtool10timestoaveragedata.instudy3 weanswer rq3bycomparing apechecker witheventracer .wedidnotchooseotherdataracetools e.g.
cafa notavailable anddroidracer lesseffecitveandprecise than eventracer .
in detail we randomly selected fdroidapps sincethesourcecodeisrequiredtoconfirmtheapes reported by eventracer listed in table with at least one ape offault pattern treated as data races by eventracer only considertheracesreportedbetweenuithreadandasyncthreads and allocated events for eventracer by default only events to generate event sequences which on average costs 15minutesperapp comparabletotherunningtimeof apechecker .
eventracer generates a lot of false positives but to our knowledge noreproducingtoolscanfacilitateouranalysis asyncdroid requiresuser providedeventtraces racerdroid adoptsmanually analysis and erva is not available.
therefore we manually analyzed the races and resorted to developers for confirmation.
.
study effectiveness of detecting apes table1showstheresultsof apechecker onthe40apps.itidentified 107apesintotalwith67and40fromf droidandgoogleplayapps respectively.amongthem duetothelimitationsofunderlyingtools apescan be processed ofwhich aresuccessfully confirmed withrealtests achieving83.
hitrate.onaverage ittakes authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efficiently manifesting asynchronous programming errors in android apps ase september montpellier france .
minutes for one app with .
minutes for one f droid app and .
minutes for one google play app.
in contrast lint only detects one ape which is ineffective.
we detail the results below.
effectiveness.
apechecker successfullyreproducesallapesof fault pattern1.
homemanager managesandswitchesbetweenhomeapplications.
once started it scans the installed apps on the devicein an async thread which modifies the data list of app info asychronously with a listview .
when the scan is finished it notifies the ui thread to refresh the listviewwith the new list.
however if thelistischangedagain anotherasyncthreadiscreated during the refresh the app can be crashed by an illegalstateexception .
infault pattern mtg familiar is an offline database app for magic cards.
it takes the photos of cards to identify the magic card.
aftertakingaphoto itstartsloadingthephotowitha progressdialog andcalls toast maketext inanasyncthread.however itfailstopost toastcreation onto the ui thread which causes a runtimeexception .
apechecker successfully reproducesmost apes of fault pattern .
for example mitzuli a translator app starts an async thread tocheckversionupdate andshowsadialogtonotifytheresults.
however ifusersrotatethedevicebeforethethreadreturns afatal badtokenexception occurs.
hit rate.
apechecker achieves an .
hit rate.
we analyzed the failed cases and found most of them require special constraints.
we summarize the main scenarios below.
externalenvironment.transportsbordeaux atransportationapp searchesforpathsfromthestartstodestinations.
apechecker can generateaprogramtracebutcannotgenerateaneventsequence to trigger the error since the app registers a broadcast receiver for receiving specific intents.
apechecker cannot infer this now.
quranformyandroid isatranslatorfor thequran .if back button ispressedafteredittingthetext itstartsathreadtosavethetext into storage and shows a message via toast maketext only when no data storage is available.
apechecker cannot reproduce such errors.
complicated exceptions.
apechecker currently cannot infer complicated exceptions such as file not found and database corruption.
one ape in a2dp volume is that it tries to show a message via toast maketext intheexceptionhandling s catchstatementwhich however isonlyreachablewhenthedatabasetobeloadediscorrupted in trystatement.
falsepositives.
apechecker onlyreports6falsepositives .
.
themainreasonisthatsomemethodsorclassesareactuallyunreachable.forexample in radiodroid apechecker identifies3potential apes of which are false positive since they reside in adeadactivity activityradiostationdetail thatcannotbestartedby any other activities.
in summary on the evaluated apps apechecker can efficiently manifest apes in a few minutes with .
hit rate and .
false alarms.
.
study comparison with testing tools fig.6compares apechecker andthethreetestingtoolsinthenumber ofconfirmedapes theanalysistime inminutes andthelengthof eventsequence inlogarithmicscale thattriggerstheerrors.the resultsarepresentedinthreebarplotswitherrorbars shownas black lines where each bar s height indicates the average value and the error bar represents the standard deviation of uncertainty.
apechecker confirms many more apes than the testing tools.
in the10runs apechecker totallyconfirms32uniqueapesfromthesefigure6 comparisonbetween apechecker andtestingtools.
10apps whilemonkey sapienzandstoat respectively confirm7 and9.moreover noneofthetestingtoolsuncoverapesinsubjects 9and10whileapechecker finds and ones respectively.
the error bars of testing tools show obvious data variance i.e.
testing tools are very likely to miss apes.
forthetestingtools theanalysistimeofanerrorisitsfirstoccurrencetimesinceoneerrorcanbetriggeredmultipletimesduring one run.
we can see apechecker takes much less time than the testingtoolsexceptforthesubjects 4and7.onaverage apechecker takes2.9minutes whilemonkey sapienz andstoatrequire32.
.3and37.1minutes respectively.sapienzcaneasilyhitoneofthe errors in the subject 4but take more time for the other twos.
stoat takes less time on the subject but only hits that ape once during the runs.
additionally in terms of the event sequence length apechecker provides shorter more usable tests than the testing tools.theaverageeventsequencelengthofmonkey sapienz stoat andapechecker is respectively.
insummary ontheevaluatedapps apechecker detects3xmoreapes thantesting tools reducesdetectiontime fromhalfan hourtoafew minutes and provides more usable reproducing tests.
.
study comparison with eventracer table2compares apechecker andeventraceron10f droidappsin the number of detected apes.
for eventracer we give the number of reported data races and true positives under two configurations 1k eventand10k event .toconfirmtruepositives wefollowed the approach of evra and remove duplicated races if data racesarereportedondifferentvariablesinadfbutrefertothesame locationofappcode wetreatthemasonetruepositive.because the races actually indicate the same error in the app.
fromtable wecansee apechecker ismoreeffectivethaneventracerforthespecificapesof faultpattern3.
apechecker detects and reproduces out of apes while eventracer 10k event only finds ones.
by comparing the results between 1k event and 10k event we can note the effectiveness of eventracer heavily depends on the number of given events.
although eventracer can detect more apes with 10k event it reports 14x more false positives whichoverwhelmsusers.thisisalsoobservedbyevra thatonly3 dataracesreportedbyeventracerareharmful.wealso observethatthereportedracesarehighlyrandom whichfurther undermines its effectiveness for detecting these specfic apes.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france l. fan t. su s. chen g. meng y. liu l. xu and g. pu table comparison between apechecker and eventracer app name apes patt.
apech.
repro.eventracer 1k eventracer 10k reported tp reported tp a2dpvolume tucanmobile openmanager andor maxima filmchecker deskcon radiodroid adsdroid anymemo total insummary ontheevaluatedapps apechecker detects5xmoreapes than eventracer on a specific ape type with very few false alarms.
.
limitations and threats to validity limitations.
apechecker builds on several popular research tools i.e.
soot ic3 andgator whichrepresentthestate of the art.however theystillhaveseverallimitationsinpractice whichdirectly failapechecker on programtrace generation.for example even if sootsuccessfullyprocessesanapp thecallgraphcanstillbeincomplete .
cases in our evaluation .
moreover ic3 cannot handle iccs in inner classes or fragments and gator cannot handle thirdpartyuicontrols.tocounterthis wehavealreadyextendedic3 and gator in these aspects section .
butapechecker still cannot generate valid program traces for apes detected in the evaluatedapps e.g.
debiandroid duetothelimitationsofunderlying tools.webelievemoreengineeringeffortsonthesetoolscansignificantly improve apechecker .
additionally apechecker now only infers simple environment which lowers the hit rate.
future work will integrate more sophisticated analysis techniques to overcome this.aditionally applying apechecker todetectapesforothergui frameworks like qtrequires proper extensions .
threatstovalidity.
apechecker isonlyevaluatedon40apps and thusourconclusionmaynotbegeneraltoallapps.thesummarized async programming rules and fault patterns may be incomplete and thus apechecker may suffer from false negatives.
but we have thoroughly inspected all relevant resources and the fault patterns havecoveredall375realapesfrom1091apps.toeasetheverifica tion of apes apechecker simulates specific execution environment bycontrollingthreadscheduling e.g.
increasethewaittimeofnetworkaccess .sosometriggeredapesmaynotbeeasilymanifested by users although they are real faults under specific conditions.
related work automated gui testing many gui testing techniques e.g.
random testing search based testing symbolic execution model based testing and other approaches have been proposed for android apps.
as we discussed in section 1and demonstrated in the evaluation these techniques are ineffective for apes due to lack of prior knowledge faultpatterns .incontrast apechecker leveragesthis knowledge to efficiently manifest apes.
apechecker tackles specific bugs that violate the rules of singlegui thread model.
quantum uses model based testing to tackle app agnostic bugs.
for example when rotation happens thescreenshouldshowthesamecontentandsupporttheactions asbefore.thor amplifiesexistingtestsbyrandomlyinjecting neutraleventsequences e.g.
doublerotation pause and resume that should not affect the outputs of original tests.
amalfitano et al.
proposeasimilarideabyexhaustivelyinjectingorientation changes to expose gui failures.
however these techniques may notbe effectiveforapes.
first their effectivenessdependson the quality of an existing gui model or test suite which are usually notavailable .second thesetechniquesarerandom anddonot explicitlyconsidertheinteractionsbetweenuiandaysncthreads.
graziussi encodes some specific patterns into lint to detect lifecycle bugs.
krefinder finds restart and resume errors that cause app data loss.
apechecker tackles apes which have not been systematically investigated before.concurreny bugs asdiscussedinsection .
someapescanbe treatedasconcurrencybugs.totacklethem anumberofdatarace detection tools and data race reproducing tools are developed.
however as our evaluation shows data race detection tools are ineffective for these apes.
asyncdroid and racerdroid are impractical since they either require userprovided traces or depend on the results of data race detection tools.erva utilizesdependencygraphandeventflippingto reproduce races and uses state comparison techniques to identify harmful ones.
aatt manifests concurrency bugs whose race points at the app code level.
however it can only manifest races whose conflicting events are in the same page or race points in the user code.
other bug reproducing tools like reran and crashscope require user interactions.
in contrast apechecker automatically generates event sequences to verify apes.guided test generation our work uses static analysis to locate suspiciousapes andthenguidesguiinteractionstoverifythem.
thisideaisalsoadoptedinotherapplicationdomainsofandroid.
smartdroid guides tests to reach certain apis to manifest the maliciousbehaviors.however itexploreseveryuielementoneach pagetofindtherightviewtoclick.brahmastra drivesappsto reach third party components to test security issues mamba guidesteststorevealpotentialaccessestoprivacy sensitivedata fuzzdroid utilizes a search based algorithm combined with static and dynamic analysis to manifest malicious behaviors.
however none of these tools can be directly compared with apechecker fordetectingapes.othertargetedtestingtoolsincludecollider condroid a3e .however they areeithernot availableor requiring human intervention.
conclusion this paper introduces apechecker a technique to efficiently manifest apes.
first we conduct a formative study to understand the aysnc programming rules implied by the single gui thread model and collect a set of real ape issues.
second informed by these results wedistillthreefaultpatterns andlocatesuspiciousapes viastaticfaultpatternanalysis andthenverifythemwithrealtests.
the evaluation shows apechecker is useful and effective.