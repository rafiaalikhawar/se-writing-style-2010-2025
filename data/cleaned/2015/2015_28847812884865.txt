crowdsourcing program preconditions via a classification game daniel fava university of california santa cruz dfava soe.ucsc.edudan shapiro university of california santa cruz dgs ucsc.edu joseph osborn university of california santa cruz jcosborn soe.ucsc.edumartin sch ef sri international martin.schaef sri.come.
james whitehead jr. university of california santa cruz ejw soe.ucsc.edu abstract invariant discovery is one of the central problems in software veri cation.
this paper reports on an approach that addresses this problem in a novel way it crowdsources logical expressions for likely invariants by turning invariant discovery into a computer game.
the game called binary fission employs a classi cation model.
in it players compose preconditions by separating program states that preserve or violate program assertions.
the players have no special expertise in formal methods or programming and are not specifically aware they are solving veri cation tasks.
we show that binary fission players discover concise general novel and human readable program preconditions.
our proof of concept suggests that crowdsourcing o ers a feasible and promising path towards the practical application of veri cation technology.
.
introduction a key problem in software veri cation is to nd abstractions that are su ciently precise to enable the proof a desired program property but su ciently general to allow an automated tool to reason about the program.
various techniques such as predicate abstraction interpolation logical abduction and lately machine learning have been proposed to automatically nd such abstractions by identifying suitable program invariants.
each of these techniques provides its own approach for inventing suitable predicates but unfortunately the space of possibilities is essentially in nite and it is not currently feasible to reliably nd such predicates via automated methods.
the human process for nding invariants relies on highly skilled people schooled in formal methods to reason from the purpose of programs towards possible predicates.
however this approach has an issue of scale millions of propermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.grams could bene t from formal veri cation while there are only a few thousand such experts world wide.
automated methods rely on search and expectations to constrain the predicate invention process.
white box techniques leverage knowledge about program content to propose candidate invariants while black box methods search a space of templates often boolean functions of linear inequalities using comparatively little knowledge of program structure.
recent work on classi cation techniques employ data to constrain predicate invention.
here the objective is to induce a boolean expression over a base set of predicates that admits good program states inputs that satisfy desired properties encoded as assertions while excluding all bad states input that violates such assertions on execution .
machine learning methods are well suited to this task .
these techniques output likely invariants that can be tested by static or dynamic analysis methods to determine if they are invariant conditions of the underlying program.
the key issue in this approach is generalization useful invariants are broad statements while classi cation methods tend to over t the data.
moreover the data on good and bad program states necessary to achieve robust generalization is in short supply as program sampling is itself a hard task.
this paper reports on a classi cation based system that addresses predicate invention in a novel way it crowdsources logical expressions for likely invariants by turning invariant generation into a computer game.
this approach has several potential bene ts it can take advantage of the human ability to extract general predicates from small amounts of data it makes predicate invention accessible to a much larger pool of individuals it allows the crowd to compose unexpected likely invariants that fully automated methods might miss.
in more detail the game called binary fission addresses the subtask of precondition mining it assumes a set of annotations that encode desired properties and seeks predicates that imply the annotations hold under program execution.
players function as classi cation engines.
they collectively compose likely invariants by applying lters to separate quarks in a graphical display without any speci c awareness that they are performing program veri cation.
ieee acm 38th ieee international conference on software engineering binary fission is an instance of a growing number of games with a purpose which share the premise that many di cult and important tasks can be advanced by crowdsourcing .
as such binary fission is an existence proof for crowdsourcing precondition mining.
this paper also demonstrate that it is e ective.
we claim that the crowd can employ binary fission to compose likely invariants for non trivial programs.
binary fission in uences the crowd to produce likely invariants that are also program invariants.
binary fission in uences the crowd to produce program invariants that are non trivial reasonably general and human readable.
in addition we show that the invariants produced via binary fission are novel relative to the output of dtinv a related fully automated classi cation system .
the following sections describe our approach and results.
we begin by framing this e ort against related work and introducing binary fission.
section discusses our methodology for assembling crowdsourced likely invariants from player contributions extracting program invariants from that set assessing the quality of crowdsourced results.
section introduces the domain program we examine for preconditions and section presents results obtained with binary fission.
section discusses the source of power behind these results while section examines threats to validity.
we end with concluding remarks.
.
related work the problem of nding suitable program invariants is a central part of formal veri cation research.
striking the balance between an abstraction that is su ciently precise to prove a property and su ciently abstract to reason about is what makes program analysis scalable.
in static analysis a variety of techniques exist to infer program invariants such as cegar craig interpolation or logical abduction .
however these approaches have the inherent limitation that they rely on information generated from the source code of the analyzed program.
if the needed invariant is a relation between variables that cannot be inferred from the source code these techniques must fall back on heuristics or fail to compute an invariant.
as an alternative to static invariant discovery we have seen an increasing activity in research on data driven approaches.
a pioneer in this eld is daikon which takes a set of good program states as input and applies machine learning to nd an invariant that describes all states in this set.
more recently several approaches have extended this idea of inferring invariants from traces some of these techniques also consider sets of bad states that should be excluded by a likely invariant .
the benet of machine learning or data driven approaches over static invariant discovery is that these approaches can search for invariants in a larger space and discover invariants even if they are based on relations that are not easily inferred from the program text.
this paper explicitly compares results obtained by binary fission with results obtained through dtinv which provides a classi cation model that is very close in spirit to our work.since binary fission is a crowdsourcing game it can viewed as a game with a purpose gwap .
since binary fission involves people performing work that computers cannot it can also be viewed as a form of human computation see for design issues concerning motivation and evaluation in this context and for a survey of crowdsourcing in software engineering .
since binary fission uses a game reward system to motivate players it is a form of gami cation .
we view binary fission as a deeper application of game design principles than typical in gami cation e orts as it simultaneously makes a hard science problem playable and disguises the core activity more than typical human computation tasks.
overall the idea of building crowdsourced games for hard scienti c tasks has shown enough promise to motivate a large investment in this area.
binary fission was developed as part of the crowd sourced formal veri cation csfv program funded by darpa in the united states.
this program has resulted in the creation of ten games focused on the intersection with formal software veri cation a summary of the games developed in this program can be found in and many of the games can be played at verigames.com .
.
binary fission binary fission is a game for crowdsourcing program invariants.
it is one of several recent e orts designed to exploit the wisdom of the crowd by transforming hard scienti c problems into games .
binary fission is intended for players with no expertise in formal veri cation methods and the players are at most peripherally aware that they are solving veri cation problems through game play.
the design for binary fission was inspired by the need for a broadly accessible mechanism for nding invariants.
the game employs a classi cation metaphor.
at the technical level it inputs a program annotated with postconditions a set of predicates relating program variables and two sets of initial program states each state is a vector of variable values where good states satisfy the assertions and bad states violate those assertions on program execution.
each binary fission player employs the available predicates to nd a classi cation tree that separates good data from bad.
this tree de nes a logical formula representing a likely invariant.
at the game level binary fission hides the nature of the program data and predicates from the player.
instead the game s graphical interface presents problems to players in abstract form.
as shown in figure it depicts program states as spheres called quarks colored blue or gold depending upon whether the state is good orbad.
the quarks are initially mixed together inside the nucleus of an atom.
the player s goal is to separate the gold from the blue quarks using a set of lters corresponding internally to predicates which are capable of splitting the atom s nucleus.1the wheel around the quarks represents these predicates as pentagons.
each lter evaluates to true or false when it is bound to a given program state.
mousing over the wheel of pentagons displays the results of applying the associated lter to the program state quarks bunch up on the left if the lter evaluates them to true and they move to the right if the l1we use the terms predicate and lter interchangeably throughout the paper.
1087ter evaluates them to false.
di erent lters create di erent splits and the player s job is to decide which lters to apply and in what order.
figure binary fission representation of a nucleus with blue and gold quarks surrounded by lters by mousing over pentagons the player quickly sees the e ect of many lters on the di erent quarks.
the player clicks on a lter once she nds one that she would like to apply.
that action splits the atom into two child nodes.
the left child contains all states from the root that satisfy the predicate and the right child contains states that falsify the predicate.
the recursive application of this process on the left and the right child creates a decision tree as shown in figure .
figure sample decision tree built by a binary fission player binary fission imposes a ve level depth limit on player generated classi cation trees.
this bounds the complexity of the resulting classi ers and limits the screen real estate required for display a necessary concern in game design .
binary fission also provides a scoring function shown in equation that in uences players to create leaf nodes com posed purely of good or bad program states where the pure good nodes have special utility for de ning likely invariants .
n x i2leaf nodes puritya i sizeb i here purity is the maximum over the percentage of good states and the percentage of bad states in the node and size is a count of the quarks states in the node.
aandbare arbitrary constants.
nincreases with the count of pure nodes in the solution and decreases with the maximum depth of the classi cation tree n .
it in uences players to produce as many pure nodes as possible as early as possible which is a force towards producing useful and general descriptors.
each classi cation tree produced through binary fission is typically partial some leaf nodes only contain good states some only contain bad states while others contain a mixture.
in addition the solutions are idiosyncratic as the players generally employ di erent subsets of lters during game play.
as a result the game software combines descriptions of pure good nodes and pure bad nodes across solutions to obtain a consensus view of the likely invariant.
we discuss this process below.
.
methodology our methodology for crowdsourcing precondition discovery repeats the following steps .
express an invariant generation task as a data classication problem.
.
present the problem to binary fission players.
.
assemble a likely invariant across player solutions.
.
extract clauses from the likely invariant that satisfy program assertions.
.
assess utility of the program preconditions found.
.
assess novelty of the program preconditions found.
following these steps we assess the value added by crowdsourcing invariants by comparing the results with the solutions produced via an automated classi cation technique called dtinv .
the following sections clarify these tasks.
.
expressing invariant generation tasks the goal of binary fission is to aid the discovery of function preconditions in a program under analysis.
this is done by searching for combinations of predicates that when placed at function entry points will prevent states that lead to abnormal termination.
these predicates should not on the other hand prevent states that lead to normal program termination from executing.
we express these problems as classi cation tasks by specifying fgood states bad states predicatesgtuples.
we obtain the state data by running a large set of test cases on the underlying program and monitoring its execution with a debugger.
we collect the program state at the entry point of each function and monitor the program s exit status.
if the input state satis es end assertions and exits normally we add that vector of program variables to the good states.
if it violates assertions or causes the program to crash we add it to the set of bad 1088states.
we augment these states by randomly sampling the variable ranges observed in the program test cases after validating with gcov that the new values exercise the same code paths.
we retain these states in a hold out set for testing the generality of any preconditions found and do not present them to players.
the objective is to nd a combination of predicates that segregate good and bad states.
binary fission can utilize logical predicates of any kind obtained from any source with the caveat that they need to be relevant to the classi cation task at hand in order to be useful.
we generate a base set of predicates by employing the daikon system which is able to explain regularities in program states by searching a library of structural forms.
in particular we supply daikon with a small subset of good program states and separately a small set of bad states and collect the candidate invariants it produces.
individually the predicates produced with daikon on these subsets of program states are not good discriminators.
the job of the binary fission player is to nd combinations of predicates that together are able to distinguish between good and bad program states.
we present each of the fgood states bad states predicates g tuples generated in this way to multiple binary fission players who create compound logical statements.
binary fission has many game levels each associated with one function of the program under analysis.
a binary fission level is composed of a subset of the good and bad states derived for a given function and of predicates whose free variables bind to this program state.
as a concrete example take the algorithm in figure that computes the quotient and remainder of dividing the numerator nby the denominator d. to produce a binary fission level for divide we collect all n d pairs observed at function entry during multiple program executions.
the tuples that lead to normal program termination are labeled as good.
however the program states that cause a runtime exception the ones in which the denominator dequals zero will be labeled as bad.
predicates over the program states can be any logical expression involving nand d. 1def divide n d if d q r divide n d return q r if n q r divide n d if r return q else return q d r return divhelper d n def divhelper d q r if r d return q r return divhelper d q r d figure integer division algorithm we are interested in nding predicates that will when placed at function entry prevent runtime exceptions and post condition violations.
for example the predicate n d evaluates to true on some good program states like n d as well as on some bad program states like n d .
for this reason n dis not very helpful at segregating good program states from bad.
on the other hand the disjunction d 0 d is a useful discriminator because it evaluates to true on all valid inputs to the function and to false when d .
.
presenting the problem to players the game starts with good andbadquarks program states mixed together in an atom s nucleus.
the application of lters predicates on the nucleus splits it into a left and a child node.
through the recursive application of lters players build a decision tree.
figure depicts this process.
in this tree a player applied predicate pat the root note then predicate qon the left child from the root and predicate ron the right thus forming a four leafed tree.
two of the leaves contain only good program states represented by the plus signs one leaf node contains only badprogram states represented by the minus signs and one leaf remained impure that is it contains both good and badprogram states.
.
assembling a likely invariant each classi cation tree generated by a binary fission player separates program states into a collection of pure good pure bad and impure nodes where a pure node only contains program states of one kind .
as shown in figure a conjunction of predicates that links the root to a pure good node describes a set of states that satisfy program assertions and expresses a likely invariant.
a single player solution can contain several such paths.
by extension we de ne the disjunction of paths to pure good nodes across all player solutions as the consensus likely invariant.
this results in an expression in disjunctive normal form puregoodconjunct 1 puregoodconjunct n note that the individual conjuncts might be drawn from the same or di erent classi cation trees.
as a result the conjuncts might not employ the same variables or be mutually exclusive either as logical statements or in terms of the data they explain.
it is tempting to employ the negation of predicates describing pure bad nodes across players instead since an invariant that excludes pure bad states is potentially weaker and more desirable than an invariant that explicitly admits only good states.
however given a partial classi er the logical expression purebadconj 1 purebadconj m includes impure nodes and accepts bad states that cannot be admitted by any invariant.
.
extracting program invariants given a likely invariant expressed in dnf we use the cbmc bounded model checker to identify any component conjuncts that qualify as program preconditions.
that is if c1 c2 cnis a predicate derived from data points from function myfunc we consider each clause cifor i2f1 ngin turn.
we place a check of its negation at the entry of the function as shown on line of figure .
we then run cbmc on this modi ed program.
when cbmc encounters the if statement it splits the analysis between the two paths.
the path in which ciis falsi ed dies when it encounters exit .
on the other hand when ciis satised the analysis continues and the model checker attempts to nd function arguments args that will later cause postcondition violations line of figure .
if cbmc cannot nd inputs that satisfy ciand violate the postconditions then ciis a precondition of the function.
the full binary 1089figure example of a decision tree produced by binary fission.
tracing from the root node to the two pure positive nodes we have p qand p r which form the candidate invariant p q p r .
1def myfunc args if c i false exit remainder of the function... 5myfunc args 6assert postcondition figure pseudocode showing program transformation for discovering function preconditions.
fission invariant is the disjunct of all clauses that satisfy this test.
.
assessing invariant utility assuming binary fission players discover likely invariants and program preconditions we would like to understand the usefulness of those expressions.
we address this question by measuring the coverage of these invariants against data.
the more data explained the weaker the likely invariant or program precondition and the more utility it o ers for further formal analysis.
binary fission relies on a classi cation technique to separate good states from bad.
however classi cation methods are prone to over tting they must guard against the tendency to explain exactly and only the training data without providing insight into the general case represented by the data notseen.
common defenses include penalizing overly complex expressions considered during classi cation and testing against held back data to ensure the generality of the induced function.
we utilize both techniques here.
in particular we rely on the binary fission scoring function and depth limit to prevent over tting and we distinguish training data from test sets.
in more detail we measure expression generality against a set composed of good program states.
to increase the amount of data available we interpolate between good states supplied with the program under analysis and ensure that new states exercise the same code paths as the original states.
we measure coverage of likely invariants against the training set and coverage of preconditions against this new data which comprises the test set.
.
assessing invariant novelty in addition to assessing the utility of any invariants found we examine the conjecture that crowdsourced invariants are novel relative to the results obtained through other methods.
if they are novel it is an indication that crowdsourcing brings some special leverage to the task and we can analyze the source of that power.
we attempt to place binary fission in context by comparing it to other machine learning methods for invariant discovery.
many invariant learners now exist but dtinv is possibly the closest in spirit to our work.
dtinv is a fully automated classi er that has been shown to outperform at least six other machine learning methods for invariant discovery .
like binary fission dtinv builds a decision tree from good and bad program states that preserve or violate end assertions plus a set of primitive predicates that relate program variables.
the key di erences are that dtinv builds its own predicates from a basis set vs importing an arbitrary predicate set and it constructs decision trees of arbitrary depth that perfectly classify the data into pure good and pure bad sets vs the partial classi ers of bounded depth produced by binary fission .
we apply dtinv to the same data used in creating game levels presented to to binary fission players and we compare the resulting likely invariants for legibility generality in terms of data coverage and veracity as program preconditions.
to make the comparisons fair we pre process the code of the program under analysis to represent arrays which dtinv cannot currently consume as separate variables.
in addition rather than test the dtinv solution as a whole for its status as a program precondition we transform it into disjunctive normal form and test individual disjuncts as candidate preconditions via the cbmc model checker.
this approach is symmetric with our examination of disjuncts describing pure good nodes in the partial classi ers output by binary fission.
we compare the generality of the likely invariants and preconditions found by measuring their coverage of program states as before.
.
experimental setup in order to assess our methodology for nding preconditions we need to employ some program as the subject of analysis.
while binary fission can be applied to any program and accept its inputs from any source the application to invariant generation imposes constraints.
the underlying program must be compatible with automated analysis tools that can generate quantities of good and bad data and candidate predicates for input to binary fission.
we selected tcas an aircraft collision avoidance application originally created at siemens corporate research in .
tcas has been a common subject of veri cation methods and test case generation systems since it was incorporated into the software artifact infrastructure repository .
at the code level tcas performs algebraic manipulations of integer variables and a constant four element array.
it contains nested conditionals and logical operators there are no loops dynamic memory allocations or pointer manipulation.
as a result tcas admits analysis via model checking we use the cbmc model checker to test whether potential preconditions found through gameplay indeed exclude states that cause postcondition violations.
in addition tcas comes with a large set of test data we use to generate good and bad program states.
finally the program s alge1090braic structure is amenable to analysis by daikon which we employ to generate candidate predicates.
tcas consists of lines of c code split into nine functions.
as shown by the call graph in figure the main function calls an initialization routine before transferring control to alt sep test which tests the altitude separation between an aircraft and intruder that has entered its protected zone.
tcas then generates warnings called tra c advisories tas and recommendations called resolution advisories ras to the pilot.
the tas alert the pilot of potential threats while the ras are proposed a maneuver meant to safely increase the separation between planes.
figure tcas call graph.
a theory for avoiding aircraft collisions determines when certain maneuvers are safe these conditions identify safety properties that the tcas implementation should ideally guarantee.
table illustrates some of these safety properties reproduced from .
for example the last two entries specify that a maneuver that reduces the separation between two planes must never be issued when the planes have intruded into each others protected space.
these safety properties can be encoded as postconditions of the tcas program via assertion statements at its end.
the problem of proving the tcas program safe translates into the task of verifying that the implementation cannot violate these assertions.
.
game levels from tcas we tackle a subtask of the veri cation process which is to nd suitable preconditions for tcas functions.
function preconditions are conditional statements about program variables if they hold on input to the function program execution is guaranteed to produce the postconditions that encode desired properties.
we de ne seven precondition nding tasks from the tcas code.
they are to discover preconditions for each of the functions alim alt sep test non crossing biased climb non crossing biased descend own below threat inhibit biased climb and own above threat as shown in figure where those preconditions ensure the conjunction of program postconditions illustrated in table .
we monitor tcas execution and collect program state with a python script driving gdb.
we then feed subsets ofthe program state to daikon in order to create simple predicates.
for tcas the set of predicates consists of several hundred boolean combinations of equalities and inequalities among linear functions of variables including max and min operators numeric thresholds and explicit set membership tests.
three sample predicates are shown below.
alt layer value size positive ra alt thresh climb inhibit positive ra alt thresh figure sample predicates inferred by running daikon on a subset of program states.
from subsets of the fgood states bad states predicates g tuples we create levels in binary fission.
the game is available on line at and we invite readers to try it.
to date close to one thousand players have generated about three thousand solutions for tcas problems.
.
binary fission results following the methodology described in the previous section we collected crowdsourced solutions for the seven tcas problems identi ed in section .
.
for purposes of illustration we discuss the solution for the tcas function non crossing biased descend in detail and then summarize across the remaining six examples.
we discuss the structure and coverage of the likely invariants found we identify the valid program preconditions and we evaluate the generality of these results.
we assess novelty through comparison of the binary fission and dtinv solutions for the same problem.
.
likely invariants for tcas problems the consensus solution for non crossing biased descend has disjunctive clauses that represent the pure good nodes found across binary fission players.
each clause is a likely crowdsourced invariant.
figure illustrates the top three measured by their coverage over program states.
their content is syntactically similar each clause is a conjunct of primitive predicates shown as top level ands where the primitives express numeric equalities and inequalities over multiple tcas variables.
these are non trivial statements about domain variables and they appear reasonably general they clearly do not pick out speci c data values.
following the methodology described in section .
we measure the generality of these expressions by their coverage of the training data they each explain circa of the good program states.
the three likely invariants also appear to be describing a similar truth as they utilize many of the same variables and terms.
as a result they can describe many of the same states.
the solutions for all seven tcas problems have a similar structure.
table shows that they contain between and clauses.
these solutions are simple collections and have not been simpli ed they can overlap both logically and in terms of the data covered and their number strictly grows with the quantity of game play.
.
crowdsourced solution progress figure illustrates the crowd s progress towards nding a consensus likely invariant.
it plots cumulative data explained by the crowdsourced solution as accumulated in de1091postcondition explanation if up separation positive ra alt thresh a downward ra is never issued if a downward down separation positive ra alt thresh maneuver does not produce adequate separation assert result6 need downward ra if up separation positive ra alt tresh an upward ra is never issued if an upward down separation positive ra alt tresh maneuver does not produce adequate separation assert result6 need upward ra if own tracked alt other tracked alt a crossing ra is never issued assert result6 need downward ra if own tracked alt other tracked alt a crossing ra is never issued assert result6 need upward ra if down separation up separation the ra that produces less separation is never issued assert result6 need downward ra if down separation up separation the ra that produces less separation is never issued assert result6 need upward ra table tcas postconditions.
not other capability two of three reports valid and not down separation !
positive ra alt thresh not down separation !
positive ra alt thresh and alt layer value size positive ra alt thresh not alt layer value up separation and not down separation !
positive ra alt thresh and cur vertical sep !
positive ra alt thresh figure the best three likely invariants measured by good state coverage.
creasing order of predicate quality i.e.
the number of good program states recognized by the conjunctive predicate associated with each pure good node .
this gure supports several interesting observations.
first the top of the solutions explain of the data and this pattern repeats across all tcas problems.
this suggests a statistical regularity in crowd performance and an uneven distribution of expertise across players.
second the consensus solution is partial meaning it fails to explain all the data even after incorporating every player s contribution.
this is an expected result as binary fission limits the depth of player classication trees some truths are simply hard to express in bounded space.
in order to investigate this point further we employed a greedy search algorithm to construct a classi er for the same problem over the same primitive predicates.
the method used average impurity for scoring splits.
when invoked with a depth limit of the resulting partial classi er explained good program states.
this splitting metric clearly provided insu cient motivation to distinguish pure good nodes early in the classi cation process that have utility for invariant generation.
in contrast the reward metric employed by binary fission clearly in uenced players to isolate pure good nodes at shallower depths with the associated bene t for explaining good program states.
this pattern repeated across tcas problems.
we also tested the expressive power of the primitive binary fission predicates by invoking the greedy classi cation algorithm without a depth limit.
the result here and in all tcas problems was that the predicates had the power to correctly separate all good program and bad program states.
as a result our statistics on binary fission solutions concern the performance of the crowd not the expressivity of figure crowd progress in classifying data points from non crossing biased descend the predicates at their disposal.
.
program preconditions found we tested the likely invariants generated for non crossing biased descend using the cbmc model checker as discussed in section .
.
of the clauses supplied by players quali ed as program preconditions.
that is if any of these preconditions hold on function entry the postconditions described in table hold at program exit.
figure lists the three most general preconditions found ordered by their coverage over the test set of good program states.
these are the rst instances of program invariants found by not other tracked alt own tracked alt and up separation positive ra alt thresh other tracked alt positive ra alt thresh and down separation up separation and not up separation positive ra alt thresh and other tracked alt own tracked alt not other capability and not down separation or down separation or down separation and down separation !
positive ra alt thresh and not other tracked alt own tracked alt and up separation positive ra alt thresh figure the three best crowdsourced preconditions found.
clauses preconfunction from bf ditions alim altseptest inhibit biased climb non crossing biased climb non crossing biased descend own above threat own below threat table quantity of crowdsourced preconditions and likely invariants a fraction of the likely invariants qualify as program preconditions.
crowdsourced methods.
as with the likely invariants these preconditions are non trivial statements about domain variables here relating the positions and capabilities of aircraft in the sky.
for example the rst best precondition in figure states that advising a pilot to descend the function ofnon crossing biased descend will satisfy safety assertions when a the other plane s altitude is higher but b advising the pilot to climb will result in a vertical separation up separation that is less than the required tolerance.
binary fission players collectively found program preconditions for of the tcas tasks.
none were trivial.
table identi es the quantity of preconditions found for each task and the numbers are substantial.
.
invariant generality following the methodology described in section .
we assess the generality of the crowdsourced preconditions found by measuring their coverage over good program states in the test set.
table counts the number of program states explained by for the seven tcas problems.
the best case scenario is for the precondition to accept all good states.
in the case of non crossing biased descend the aggregate precondition composed of the clauses reported in table explains .
of the good program states withheld during the classi cation task.
this corresponds to .
of the good states per precondition clause on average although the distribution was uneven.
figure shows the best three preconditions for this problem.
the rst explained of the data while the second and third best preconditions captured and of the program states in the test set respectively.
the net result is that the crowd discovers multiple program preconditions with noteworthy coverage generality.good total function states states alim .
altseptest .
inhibit biased climb .
non crossing biased climb .
non crossing biased descend .
own above threat own below threat table testing preconditions generality by comparing the number of good states accepted versus the total number of good states in the held out test set.
.
novelty relative to the dtinv solution as discussed in section .
we compare the binary fission and dtinv solutions for each tcas problem in order to examine the conjecture that the crowd provides novel insight in the search for program invariants.
we compare the legibility and coverage of the likely invariants they produce as well as their ability to discover program preconditions.
in its raw form the dtinv solution for non crossing biased descend is a depth decision tree containing primitive predicates that completely segments the good and bad program states.
the corresponding logical expression is not human readable nor was it intended to be .
we converted this form to dnf to extract less monolithic likely invariants and show the top three clauses as measured by the number of good states covered in figure .
it is immediately obvious that these expressions rely heavily on numeric thresholds.
this is by design as dtinv s primitive predicates represent planar cuts in the octagon domain.
although it is an aesthetic judgment this design appears to make the dtinv statements harder to interpret than the binary fission output in figure .
of the three dtinv expressions in figure the second overlaps the rst and the third is a specialization of the second.
they cover and of the good program states respectively.
it is worth noticing that the single best likely invariant found by crowdsourcing figure and the dtinv classi er have essentially identical capture and that the top three employ the same variable set though in notably di erent formulas.
this is an indication that both systems are after similar insights.
we tested the dtinv solution for non crossing biased descend using the cbmc model checker to determine if not positive ra alt thresh down separation and up separation alt layer value and alt layer value down separation and alt layer value two of three reports valid not positive ra alt thresh down separation and not up separation alt layer value and not up separation down separation and not own tracked alt other tracked alt and not own tracked alt rate up separation and alt layer value other capability not positive ra alt thresh down separation and not up separation alt layer value and not up separation down separation and not own tracked alt other tracked alt and not own tracked alt rate up separation and not alt layer value other capability and other tracked alt down separation and not two of three reports valid positive ra alt thresh and not cur vertical sep other tracked alt figure the top three dtinv likely invariants.
it contained valid program preconditions.
the surprising conclusion is that it did not either as a whole or when we tested individual dnf clauses.
this pattern repeated across all seven tcas problems none of the dtinv solutions contained valid preconditions.
in contrast the crowd acting through binary fission produced preconditions for of the tcas problems.
as a result the crowdsourced solutions are clearly novel relative to the dtinv output.
the cause for the lack of dtinv based preconditions appears to be over tting numeric thresholds induced from data are highly likely to break in the presence of a holdback set and the lengthy expressions dtinv discovers to explain all the training data have limited opportunity to generalize.
in contrast the more abstract predicate base and conjunct limit imposed by binary fission essentially forces players to paint with a broader brush.
players can only produce shorter more powerful statements some of which generalize as shown above.
.
discussion this paper has addressed the problem of crowdsourcing program preconditions under the model that crowdsourcing o ers an alternate and viable method for addressing a di cult task.
we have provided an existence proof in the form of the binary fission game and we have shown that crowdsourcing is e ective by employing the game to discover program preconditions for tcas problems.
the preconditions are non trivial reasonably general as measured by data coverage on a test set and human readable.
they are also novel with respect to the output of dtinv which nds likely invariants but none that qualify as program preconditions on tcas problems.
there are three sources of power behind binary fission it employs an expressive representation it relies on the crowd to conduct a thorough search and the game imposes restrictions on that search that select for general solutions.
in more detail the representational power comes from daikon as binary fission inputs the highly structured predicates it produces.
the game exploits crowd search by collecting and testing the large number of piecewise solutions that players contribute.
the game in uences the shape of the solution bylimiting classi er depth and by rewarding discovery of partial classi ers that isolate positive data which has special utility for invariant construction.
while binary fission employs a classi cation model improving classi cation technology is not our goal.
our main point is to introduce crowdsourcing as a promising approach to invariant discovery.
from this perspective the key conjecture behind crowdsourcing is that many non expert individuals have the desire and ability to provide insight into highly technical problems when they are presented in a suitable form.
this conjecture holds for binary fission.
if it generalizes related games will provide leverage on additional veri cation tasks and crowdsourcing will o er an avenue for expanding the reach of veri cation technology.
more broadly binary fission suggests that other highly technical tasks will be amenable to crowd sourced science games.
from our experience the enabling factor is the use of a very clean mechanic for game play here classi cation tree learning .
.
threats to validity this paper reports rst results from a crowdsourced approach to precondition discovery.
as mentioned above the key points are that crowdsourcing is feasible e ective and promising as a practical avenue for expanding the reach of veri cation methods.
that said there are several threats to the validity of these claims as well as our more detailed results.
first while crowdsourcing nds preconditions on tcas the approach may not generalize to more complex programs.
in particular tcas is a short straight line arithmetic program that lacks pointers loops complex data structures and a range of other language features that complicate the veri cation task.
the counterpoint is that binary fission is agnostic to the structure of the underlying program because it formulates precondition discovery as classi cation.
the limits on its use come from the need for inputs common to classi ers a base of relevant primitive predicates and labeled data distinguishing bad program states from good.
it is true that these inputs are hard to provide for more complex programs especially the predicate base and assertion 1094violating program states as they are the product of deep analyses of program structure.
however binary fission is also agnostic as to the source of these data which greatly increases its avenues for application.
second our results on the novelty of the binary fission solution could be the product of our choice of dtinv as the comparator.
this is quite plausible the likely invariants produced by other machine learning methods might qualify as preconditions.
however our experience with binary fission has illuminated constraints that should be applied to the use of classi ers for this task they should penalize solution size which is common wisdom employ a powerful predicate base to support human legibility of the end result and reward identi cation of pure good nodes rather than focus on an entropic measure as the splitting criterion.
a third concern is that our use of crowdsourced classi cation could be replaced by a suitable automated method.
this issue reduces to the underlying question what does the crowd bring to classi cation that is di cult to automate?
.
here the core property is novelty we have shown that the crowd discovers program invariants that dtinv is unable to nd and that it does so by employing non greedy search and by imposing constraints on the form of the solution.
with su cient implementation e ort that strategy might be automated it might require a mixture of random forest techniques to approximate crowd search and a highly non linear scoring function like binary fission s which is di cult to optimize.
the required mechanism is non trivial.
more broadly the purpose of a crowdsourced science game like binary fission is to unleash human insight to solve a hard technical problem.
that value can be present even in tasks that are well characterized as search.
for example foldit lets players employ their spatial intuition to determine the shape of complex proteins.
the game has obtained results never achieved in years of research based on search over molecular conformations in combination with energy minimization methods.
precondition discovery is equally hard and the task has a natural framing as classi cation search.
in this context the crowd may intuit which predicates to employ en route to a more general solution where predicate invention is a major component of precondition discovery as conducted by human experts .
binary fission currently hides a bit too much information to support this type of player intuition a design choice made in service of broadening the game s appeal but advanced versions will provide more context about the underlying task and more leverage for predicate selection.
a nal and related argument is that binary fission addresses the wrong crowdsourcing problem.
rather than ask the crowd to combine primitive predicates we should unleash them on the task of inventing the predicates themselves.
this step seems natural as predicate invention including predicate abstraction from data is a critical but elusive process currently performed by people.
we have in fact developed a game for this task called xylem and it is available on line at xylem.verigames.com .
.
conclusion we have employed binary fission a crowdsourced game for invariant discovery to analyze the implementation of an on board aircraft collision detection and avoidance system.
we have shown that the crowd can employ binary fission to prove program properties.
they nd function precondi tions statements about program variables associated with function inputs that guarantee important safety properties hold on program exit where those properties are encoded as postconditions.
binary fission players discover concise general and human readable preconditions which are also novel relative to the complicated logical expressions often produced by other classi cations systems.
the players have no special expertise in formal methods or programming and are not speci cally aware they are solving veri cation tasks.
binary fission demonstrates the feasibility of crowdsourced invariant discovery and it illustrates the promise of crowdsourcing for other veri cation tasks.
this suggests a pathway for expanding the reach and practical application of veri cation technology.
.