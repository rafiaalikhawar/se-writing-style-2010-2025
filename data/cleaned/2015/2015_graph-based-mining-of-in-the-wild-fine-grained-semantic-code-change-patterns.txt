graph based mining of in the wild fine grained semantic code change patterns hoan anh nguyen tien n. nguyen danny dig son nguyen hieu tran and michael hilton computer science department iowa state university usa email hoan iastate.edu computer science dept.
the univ.
of texas at dallas usa email tien.n.nguyen sonnguyen trunghieu.tran utdallas.edu computer science department oregon state university usa email digd eecs.oregonstate.edu school of computer science carnegie mellon university usa email mhilton cmu.edu abstract prior research exploited the repetitiveness of code changes to enable several tasks such as code completion bug fix recommendation library adaption etc.
these and other novel applications require accurate detection of semantic changes but the state of the art methods are limited to algorithms that detect specific kinds of changes at the syntactic level.
existing algorithms relying on syntactic similarity have lower accuracy and cannot effectively detect semantic change patterns.
we introduce a novel graph based mining approach cp atminer to detect previously unknown repetitive changes in the wild by mining fine grained semantic code change patterns from a large number of repositories.
to overcome unique challenges such as detecting meaningful change patterns and scaling to large repositories we rely on fine grained change graphs to capture program dependencies.
we evaluate cp atminer by mining change patterns in a diverse corpus of open source projects from github across a population of developers.
we use three complementary methods.
first we sent the mined patterns to open source developers.
we found that of respondents recognized those patterns as their meaningful frequent changes.
moreover of respondents even named the patterns and wanted future ides to automate such repetitive changes.
we found that the mined change patterns belong to various development activities adaptive perfective corrective and preventive including refactorings .
second we compared our tool with the state of the art ast based technique and reported that it detects .1x more meaningful patterns.
third we use cp atminer to search for patterns in a corpus of github projects with longer histories consisting of 164m slocs.
it constructed 322k fine grained change graphs containing 3m nodes and detected 17k instances of change patterns from which we provide unique insights on the practice of change patterns among individuals and teams.
we found that a large percentage of the change patterns from individual developers are commonly shared with others and this holds true for teams.
moreover we found that the patterns are not intermittent but spread widely over time.
thus we call for a community based change pattern database to provide important resources in novel applications.
keywords semantic change pattern mining graph mining i. i ntroduction prior studies have confirmed that software changes are repetitive .
several researchers have exploited the repetitiveness of code changes to detect change patterns and leverage them to support several tasks such as adapting client code to the changes in a library language migration recommending bug fixes and code examples code completion andusage patterns .
previous approaches focused on mining the patterns of specific types of changes e.g.
refactorings bug fixes api migration at the syntactic level .
thus the mining s reliance on syntax alone lowers its accuracy.
this limits the potential exploitation of repeated code changes.
in software development engineers make changes with a certain high level programming task in mind.
thus mining the high level change patterns will be meaningful and beneficial to developers as well as for tool builders.
however semantic change patterns with relations among program elements might not be well captured by fine grained syntactic changes .f o r example adding a null check for an argument of a method call consists of multiple atomic syntactic changes.
only if the variable used in null checking is directly passed as an argument of a method call those syntactic changes can form that semantic change.
moreover to identify a higher level semantic change pattern one might have to also include unchanged statements in order to completely make up a meaningful pattern.
for example the method call in the above example could be unchanged but needs to be included in that pattern.
however this adds more noise in the mining process.
in other cases the atomic changes of a semantic change pattern might not be in contiguous source code due to irrelevant changed statements as we show in section ii .
this further increases the amount of noise.
to advance the field and enable novel applications in this work we detect previously unknown semantic change patterns in source code.
specifically we introduce a novel graph based mining approach to detect in the wild high level semantic code change patterns from an ultra large number of atomic code changes in several open source projects.
to catalyze fundamental advances that exploit repeated changes one has to overcome unique challenges.
first how can we find changes that are meaningful to developers and encode a semantic change pattern ?
previous work has recorded key strokes as the programmer types in an ide and then grouped fine grained atomic changes that make up a change pattern.
however in a version control repository the order of such atomic changes is not recorded leading to two challenges i a pattern detection algorithm operating on sequences of changes e.g.
the frequent subsequence mining algorithm does not work as the order of code elements might not be the order of changes and ii the actual ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic dependencies among changed code elements are lost if a mining algorithm e.g.
frequent itemset or association rule mining treats the changes as belonging to an un ordered set of independent items.
in our formative experiment the frequent itembag mining algorithm picked up trivial patterns that represent unrelated though common changes.
for example adding a simple name a variable and adding a nullliteral are two of the most common atomic changes.
in many cases they were detected as a pattern of two frequent items even though those two atomic changes did not actually go together to compose any meaningful pattern such as adding a null check .
as a consequence meaningful patterns were ranked lower than trivial meaningless ones.
removal of common atomic changes does not help because they are key components of true patterns.
moreover how can we detect changes that are common and representative across the developer community?
our algorithm must handle a large number of fine grained changes .
to address those challenges our graph based approach connects program elements involved in the change when they have data or control dependencies.
the use of graph is a departure point from ast based approaches enabling the detection of semantic change patterns.
a fine grained change graph achange graph for short has two sub graphs representing the code before and after changes.
the nodes in each sub graph represent program elements similarly to the nodes in a program dependence graph but at the expression level .
the edges among the nodes in a sub graph represent the relations among the program elements e.g.
the data and control dependencies.
the edges across two sub graphs represent the correspondences between the nodes in the old and new code.
we implemented our algorithm in a tool cp atminer and used it on a corpus of repositories to analyze 297m slocs with real world code changes encapsulated in .1m fine grained change graphs with 11m nodes.
for evaluation we employ complementary methods that assess its performance and usefulness from different angles.
first to assess if cp atminer finds patterns that are meaningful to real developers we survey open source developers.
we sent requests about the mined change instances and patterns to their respective authors.
we received responses and of them confirmed that change patterns discovered by cp atminer are correct as part of their frequent code changes.
of them provided the names for the patterns and indicated that they like to have tools to automate such fine grained change patterns in the future ides.
to study the diversity of instances of change patterns using our survey responses we manually investigated and classified all mined patterns into the development activities adaptive perfective corrective and preventive .
among the preventive changes are refactoring .
second we conducted a comparative study to evaluate our tool against the syntax based technique used in the existing approaches .
our result shows that our tool detects .1x more meaningful patterns than the baseline.
third to evaluate the effectiveness of cp atminer and gain a thorough understanding about the practice of change patterns we use cp atminer to mine for patterns in a corpus of 88github repositories with longer version histories consisting of 164m slocs from 13k developers.
cp atminer detected 17k change patterns.
we further studied the characteristics of change patterns in both space and time dimensions.
for space we studied the commonality and uniqueness of the change patterns among individual developers in the same different teams and among individual teams.
for time we studied the temporal distribution of the instances of change patterns over a period of time.
we found that of the developers have more than of their patterns repeated by others.
of the change patterns have been repeated for more than a month period.
based on these results we launch a community call to action related to fine grained change patterns.
we offer several actionable implications for researchers tool builders and developers.
first for researchers we confirm that repetitive code changes exist in a much larger varied dataset of thousands of projects and across tens of thousands of developers.
we now have the evidence that previous tools that exploited the repetitiveness of code changes are empirically justified .
researchers can replace their own database of change patterns with our significantly larger change patterns and varied contributors database thus making existing applications more powerful.
researchers can also use our tool dataset to build novel applications e.g.
tutoring systems for teaching a novice programmer how to learn programming or teaching an expert programmer how to use advanced language features .
language and api designers can use our tool dataset to learn how programmers commonly change their code to use new features harnessing feedbacks from crowdsourcing.
tool builders could find the inspiration from common change patterns to automate several repetitive tasks in ides.
this paper makes the following contributions a. representation a graph based fine grained change representation to mine semantic change patterns by capturing both the changes to code elements and their interdependencies.
b. evaluation results meaningful patterns.
a high percentage of respondents in our survey confirmed that the detected patterns are meaningful and indicated preferences to have automated tools.
commonality.
the majority of change patterns of a developer or in a team is commonly shared with others.
temporal distribution.
same developer or team repeats the same changes over time even over a month or a year.
c. implications we present practical actionable implications of our findings for researchers language and api designers tool builders and developers.
d. community based change database to significantly improve existing applications and to catalyze novel applications of change patterns we offer our dataset of 17k change patterns as an invaluable resource for our community available anonymously at ii.
m otiv ating examples we first illustrate the challenges of mining semantic finegrained change patterns and then explain the motivation for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
before change file f new file output.txt fileoutputstream s new fileoutputstream f i str .indexof pattern start after change if start return file outfile new file output.txt fileoutputstream outstream new fileoutputstream outfile i str .indexof pattern start fig.
adding a negative check on an argument of a method call before change i str .indexof pattern start sub str .substring i after change i str .indexof pattern start if i return sub str .substring i fig.
adding a negative check on the return value from a method call before change i str .indexof pattern start after change if mode return i str .indexof pattern start fig.
a change contains unrelated atomic changes our solution.
fig.
displays a change pattern in which a developer adds a negative check on the second argument of a call to string.indexof in java before calling the method lines after change .
notice that the statements on lines changed as well though those changes are irrelevant to this change pattern and only add noise.
on the other hand despite that the statement i str.indexof... did not change it is actually part of this change pattern.
thus a semantic change pattern could include syntactically unchanged statements.
observation o1 syntactically un changed program statements could carry important semantic change elements for a semantic change pattern .
a mining approach that captures only the changes to syntactic units e.g.
using tree editing operations between the asts before and after the change would miss the method call at line after change .
moreover notice that the changes at lines are nearby yet irrelevant in the change pattern.
observation o2 the atomic changes of the same pattern might not be on the contiguous lines of source code.
thus we need a change representation that relates syntactically un changed program elements with the changed elements.
fig.
displays another change pattern adding a negative check on the return value from a call to string.indexof .a n approach that represents an atomic change via the tree editing operations will encode this change as the following set adding if adding an identifier id adding an operator op adding literal and adding return .
this set exactly matches the set of tree editing operations representing the change in fig.
.
thus that approach will mis classify the change in fig.
and the change in fig.
as the instances of the same change pattern.
observation o3 an approach using only syntactic changes for change representation will misclassify the instances of different change patterns .therefore we cannot treat the atomic changes as individual elements in a set and we need a representation able to semantically connect the atomic changes to form a meaningful pattern .
fig.
shows another example in which the unrelated atomic changes could be mistakenly grouped into a pattern if they are represented as a set of atomic tree editing operations as in existing work .
in this example the set of editing operations that occurred on lines after change matches the sets of operations for the previous two examples figs and .
note that in this example the editing operations such as adding if adding id adding the op adding literal and adding return are popular atomic changes yet non data dependent and should not be grouped to form the same change pattern as before.
observation o4 an approach that relies only on syntactic changes would incorrectly classify frequent but un related atomic changes into an incorrect pattern.
from o1 o4 we propose a graph representation that encodes data and control dependencies to connect relevant atomic changes.
in fig.
after change the dependencies help connect the addition of the id startat line with the method call string.indexof at line despite that they are far apart in the source code and that the statement at line does not change.
in fact with the integration of dependencies the assignment at line after change in fig.
is considered as semantically changed with regard to program dependencies flows because after change that assignment is only executed in the false branch of the ifstatement at line .
dependencies flows help differentiate also the instances in fig.
and fig.
because the first change relates to the argument of the method call indexof while the second one relates to the return value of the call.
finally for the change in fig.
the algorithm does not group the changes at lines with the statement at line since they do not have data dependency.
next we present our mining tool cp atminer .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
before change for iterator element it o.getelements .iterator it .hasnext myelements.add it.next after change for final element element1 o.getelements myelements.add element1 fig.
a change pattern iterator replaced with foreach lwhudwru jhw ohphqwv kdv1h w whudwru ru qh w dgg jhw ohphqwv dgg qkdqfhg ru ohphqw uhfy ghi uhfy frqg sdudfrqwurofrqwuropds pdsuhfyfrqgghi sdudsdud frqwurofrqg ohphqw qkdqfhg ru gghg gghg rqwuro2shudwlrq dwd hohwhg hjhqg hiruh iwhu fig.
graph representation fgpdg for change in fig.
iii.
s emantic fine grained change representation a. fine grained code representation graph based representation from our observations we choose a graph representation that captures program dependencies.
we create a graph based program representation that captures the control data dependencies as in program dependence graphs pdgs and uses the api elements as in object usage graphs groums .
our representation called fine grained program dependence graph fgpdg is augmented with richer types of nodes and edges to capture fine grained program elements at the expression level and the dependencies including usages with exception handling.
let us detail fgpdg.
fine grained pdg a fgpdg is a directed graph that represents the data control dependencies among fine grained program elements at the expression granularity.
it also contains the nodes representing api elements.
a node represents a method call a variable declaration an operation or a control statement e.g.
iteration or condition .
an edge coming into a node represents the data on which the node depends or the control flow on which the execution of the node depends.
there are three types of nodes data operation and control nodes and two types of edges control and data edges.
fig.
shows the fgpdg for the code in fig.
before and after the changes.
data nodes represent variables field accesses and constants.
in fig.
element in the subgraph after the change is a data node.
operation nodes represent operations on data e.g.
arithmetic relational logical bit wise type comparison cast operations array accesses and method calls.
their labels are the operations types e.g.
!
except for a call whose label is its declaring type and name e.g.
iterator.hasnext in fig.
type not shown .
control nodes represent control statements which include if for branching for enhancedfor see fig.
while and dofor loops and tr yand catch for exception handling.
in our representation we transform a switch statement into nested ifstatements.
control edges represent control relation between the statements operations and the control nodes on which their executions depend.
in fig.
before change there are control edges from the fornode to the method call nodes next and add .
data edges represent the data flow between fgpdg nodes.
each edge has a label specifying the type of the data flow.
a defedge connects a data node or an operation node to another data node as its definition in an assignment.
this definition node in turn could be connected to its