minimizing gui event traces lazaro clapp lazaro stanford.eduosbert bastani obastani cs.stanford.edu saswat anand saswat cs.stanford.edualex aiken aiken cs.stanford.edu stanford university stanford ca usa abstract gui input generation tools for android apps such as android s monkey are useful for automatically producing test inputs but these tests are generally orders of magnitudelargerthannecessary makingthemdifficultforhumans to understand.
we present a technique for minimizing the output of such tools.
our technique accounts for the nondeterministicbehaviorofmobileapps producingsmallevent traces that reach a desired activity with high probability.
we propose a variant of delta debugging augmented to handle non determinism to solve the problem of trace minimization.
we evaluate our algorithm on two sets of commercial and open source android applications showing that we can minimize large event traces reaching a particular application activity producing traces that are on average less than the size of the original traces.
ccs concepts software and its engineering software testing and debugging keywords testing trace minimization delta debugging android .
introduction test cases are time consuming to write especially for applications dealing with rich graphical user interfaces guis .
many properties can only be reliably tested once the program has reached a particular state such as a specific screen or view in its gui.
part of the challenge of gui testing is in creating a sequence of user interactions that cause the program to reliably reach a target gui state under which the test one cares about can be performed.
automatically generating a sequence of gui events to reach a particular point in the program is a difficult problem to solve in general.
in many cases it is possible to reach the desired point in an application by randomly generating gui events until permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c circlecopyrt2016 acm.
isbn .
right view is displayed or by capturing and replaying the gui events generated by a user or a human tester interacting with the application.
however these randomly generated or tester captured event traces generally contain more interactions than necessary to reach the desired state.
furthermore traces generated by capture and replay of concrete user interactions might not be robust in the face of application non determinism and thus might break if the programchangesbehavior evenslightly betweenexecutions.
in modern mobile and web apps which often include internal a btestinglogicandpersonalization guinon determinism is a common obstacle for simple capture and replay systems.
in this paper we present an algorithm basedondelta debugging tominimizeatraceofguievents.
ouralgorithmisrobust to application non determinism.
when the application is deterministic the output trace is minimal meaning no element of the trace can be removed without changing the behavior we care about .
minimization proceeds by checking whether subtraces of a trace still reach the desired state.
this problem is highly parallelizable but it is not obvious how to take maximal advantage of the information gained from each subtrace trial see section .
we define the subtrace selection problem and provide an efficient heuristic as well as an optimal solution based on the problem s characterization as a markov decision process mdp .
we show the effectiveness of the above techniques in minimizing randomly generated traces for two representative datasets one set of popular android apps taken from the google play store and a set of opensource apps from the f droid application repository.
section provides a brief overview of the problem of gui traceminimizationinthefaceofapplicationnon determinism the relevant characteristics of the android platform and a motivating example for our technique.
section describes our trace minimization algorithm while section explores the problem of subtrace selection embedded in the algorithm sinnerloop includingthecharacterizationasamarkov decision process .
.
section presents our results contrasting the performance of different solutions to the subtrace selection problem.
finally section briefly describes related work and section presents our conclusions.
.
problem overview the gui of an android application also called an app consists of a set of activities .
each activity corresponds to a top level view e.g.
a page of the user interface.
additionally each app has one main activity which is the first one invoked when the app is launched.
in the course of interacting with an application s gui the user commonly transitions between different activities as actions in one ac tivity trigger another activity.
a guievent trace is a sequence of user interface events such as screen taps physical keyboard key presses and complete multi touch gestures.
one way to obtain such a trace is to record the actions of a user.
another option uses a random or programmatic input generation tool to generate the trace without human involvement.
in our experiments we took the second approach using monkey a standard first party random input generation tool for android.
monkeytracescanbegeneratedbasedonlyonthenumber and types of desired events then replayed for a particular app.
by generating multiple large random traces for each app under test we are able to reach various activities within the app.
these traces could conceivably serve as system tests for the app especially if augmented by state checks or log monitoring.
however using automatically generated traces as tests can be problematic for the following reasons .
because traces are randomly generated the majority of the events do not trigger any interesting app behavior e.g.
they are taps on inactive gui elements or trigger behavior unrelated to the functionality we care about for a given test.
large random event traces are hard for humans to interpret particularly if most of the trace is irrelevant for the desired behavior.
the traces produced by monkey typically consist mostly of irrelevant events.
.
replaying a large trace is a time consuming process as a delay must be introduced before sending each event to the app to ensure previous events have been fully processed.
in our experiments we set this delay to seconds which we found necessary to allow for events that trigger network requests or other expensive operations to be fully handled by the app before the next event is triggered.
in summary given a large event trace we would like to find a minimal subtrace that triggers the same app behavior.
in particular we focus on subtraces that reach the same activity.
if we assume that the app is deterministic in the sense that the same event trace always visits the same activities in the same order then the algorithm from section extracts from a given event trace that reaches a particular activity a minimal subtrace that reaches that activity.
note that we use activity reachability as a proxy for uncovering user triggered behavior in the app.
all the techniques and checks in this paper apply just as well if the behavior we seek to trigger involves reaching the execution point of a particular gui widget callback or the point at which a particular web request is sent.
we only require that we have a small finite set of behaviors that shall be triggered in the app so that every system test is built on top of a minimal trace triggering that behavior.
.
trace minimization example one of the apps we use for our experiments see section is yelp s eat24 com.eat24.app.apk a popular commercial food delivery app.
to generate minimized traces that reach this app s activities we run the app on an android emulator and use monkey to generate multiple gui event traces.
each trace consists of single touch events at random coordinates within the app s portion of the screen.
to capture non determinism in the app we replay each trace multiple times we use repetitions clearing any local data or app state in the device between replays.
for a particular trace twe generated the activity loginactivity is always reached by replaying ton this app.
loginactivity is a relatively easy to reach activity for this particular app as there are at least two ways to launch this activity immediately from the app s main activity either by clicking on an item in the application s menu or on the lower portion of the app s home screen which displays recommendations if the user is already logged in .
the second method requires only a single gui event the click on the bottom of the screen.
however approximately of the timewhentheappislaunchedfromacleaninstall itshowsa dialog asking for the user s address and zip code.
this dialog blocks interaction with the main activity and in our set up automatically brings up android s software keyboard.
dismissing the dialog is as simple as clicking anywhere in the screen outside the dialog and the virtual keyboard.
however this does not dismiss the keyboard itself so the state of the screen is different than if the dialog had never appeared.
after dismissing the dialog it is still possible to navigate to the loginactivity with one more click but the area of the screen that must be clicked is different than if the dialog had never appeared at all.
suppose now we wanted to manually select out of the events t a minimal subtrace t such that replaying the events of t in order reaches the loginactivity activity regardless of whether the app shows the location dialog or not.
this subtrace must exist since the original trace always reaches loginactivity among other activities in both cases.
however we cannot simply select the single click subtrace that would launch loginactivity if the dialog is not present since it won t work when the dialog does appear.
we have the same problem if we focus on picking the two clicks when the dialog appears as such a trace does not necessarily work when the dialog is absent.
for example most clicks that would simply dismiss the dialog might also trigger different behavior if the dialog is missing by clicking on active gui widgets underneath the dialog.
this sort of behavior is not exclusive to the eat24 app.
in fact many android apps behave non deterministically either because of internal a b testing logic or just because of the non determinism of the app s external environment.
we could always manually write gui testing scripts that are aware of the app s specific non determinism and generate different gui events when faced with different app states.
however as we will show it is possible to automatically generate small subtraces that are robust against application non determinism while still treating the app itself as a blac k box.
we require only a way to run subtraces on top of the appfromaninitialstatemultipletimesandlisttheactivitie s being reached.
figure shows the execution of a event trace the minimal subtrace obtained by the technique in this paperfigure reaching loginactivity oncom.eat24.app.apk that accomplishes our goal without checking at any point the state of the application s gui.
if there is no location dialog the first event in the trace triggers the direct transition to loginactivity by clicking on the bottom of the screen.
the second and third events click inactive areas of theloginactivity gui layout having no effect in this case.
if the dialog appears the first click hits a portion of the virtual keyboard layout typing a whitespace character into the location dialog.
the second click immediately dismisses the dialog without using the whitespace character.
finally the third click happens in the new location of the panel that launches loginactivity without dismissing the keyboard1.
thus whether or not the dialog appears the script will reach loginactivity and stop there.
it is worth noting that at no point is our technique aware of the dialog it only knows that this script reaches loginactivity with high probability over multiple runs of the app.
.
minimization algorithm in this section we present our trace minimization algorithm and discuss its basic properties.
our algorithm is based on zeller s delta debugging algorithm see reformulated for our problem and augmented to deal with application non determinism.
intuitively delta debugging starts with a large input sequence that passes a particular test oracle and attempts to remove part of the sequence at every step such that the remaining subtrace still passes the oracle.
this is repeated until we have a minimal subtrace that is accepted by the oracle.
a minimal subtrace with property psatisfies p but removing any single element does not satisfy p. our version of delta debugging takes as input an android app a a trace t which is an ordered sequence t e0 e1 ... of gui events and a target activity awithin a. a subtrace t oftis a subsequence of t. the algorithm has access to a test oracle o a t a which consists of starting a new android emulator installing a running tracetonaand verifying that awas launched during that execution.
the oracle returns either the target activity awas not reached or activity awas reached .
because of application non determinism our test oracle may accept 1transitioning between activities does dismiss the keyboard so we don t need to do so explicitly.globals o n nr st 1defnd3min a t a return minr a t a n 3defminr a t a k size len t k foriinrange k ti t ti t ti tsub get passing a i k .ti a iftsub atio slash none return minr a tsub a n tcompl get passing a i k .ti a iftcompl atio slash none return minr a tcompl a max k ifk len t return minr a t a min 2k len t returnt 16defget passing a s a if tc s.passes a tc a returntc return none 20defpasses a t a s foriinrange nr s s o a t a returns st figure nd3min non deterministic delta debugging minimization.
a trace with some probability p and reject it with probability p. fixing aanda we define the probability pt pr which is the trace s underlying probability of reaching awhen run on app a. figure shows the pseudo code for the general form of our trace minimization algorithm nd3min .
besides a t anda the algorithm uses global parameters the oracle o a starting number nof subtrace candidates to test a number of times to run each candidate nr and the success threshold required to accept it st .
for the algorithm to select a particular subtrace t at the endofanyminimizationstep calling o a t a nrtimesresults in the oracle returning at least sttimes.
this requirement is enforced by function passes in line .
we say that a trace is successful if it passes the check in passes .
function get passing in line takes a set sof subtraces and selects a subtrace tc ssuch that passes a tc a returns true.
it returns none iff no such subtrace exists insets.
note that get passing specifies no order in which traces are passed to passes .
we assume oracle calls are expensive but we have the ability to make multiple oracle callsinparallel.
insection4 weusetheflexibilityinthedefinition of get passing to minimize the number of rounds of parallel calls to orequired by our algorithm.
nd3min calls the recursive function minr which uses the two helper functions described above to implement our version of delta debugging.
minr follows the classic structure of delta debugging.
first lines it partitions trace tinksubtraces tiof contiguous events of roughly equal size starting with k non the first recursive call .
it also generates the complement of each subtrace ti defined as ti t ti.
it then proceeds in four cases case if any candidate subtrace tiis successful the algorithm selects that tias its new current trace t and calls itself recursively with k n lines .
case otherwise if any complement subtrace tiis successful the algorithm selects that tito be the next t. ifk k k before the next recursive call otherwise it is set to lines .
reducing kby ensures that the candidate subtraces tigenerated in the next call will be a subset of those in this call so the algorithm will keep reducing to complement subtraces untilk or no tiis successful.
note that when k both the set of candidate subtraces and that of complements are identical t0 t1andt1 t0 .
case ifkis smaller than the number of events left int we double the number of partitions up to k len t lines .
note that when we reach k len t this implies that on the next recursive call every subtrace consists of a single event.
case otherwise return tas our minimized subtrace ideally we would like to show that given a probability lower bound pb ifpt pbandtmin nd3min a t a then with high probability tminis a minimal subtrace of tsuch that ptmin pb.
unfortunately this is not possible.
toseewhy imagine t subsetnoteqltmin pt pb .
as the number of checks required to distinguish t from a subtrace which fulfills pt pbgrows without bound.
if t can be obtained from tminby removing a single event then testingtminfor minimality must take unbounded time.
we consider instead the following property definition .a tracetisapproximately1 minimal with respect to the bound pband distance ifpt pb and any subtrace t which can be obtained by removing a single event from tis such that pt pb.
we would like to bound the probability that nd3minreturns an approximately minimal trace with bound pb st nrand distance .
we would first like to show that if pt pbandtmin nd3min a t a then with high probability ptmin pb for a small .
given a single independent subtrace t if the check x passes a t a returns true then the probability that pt px for a given px is p pr integraldisplay1 0pr fpt x p dp integraldisplay1 pxfpt x p dp wherefpt x p is the probability density of pt givenx.
note that pr is if p px and otherwise.
by bayes theorem p integraltext1 pxpr fpt p dp pr integraltext1 pxpr fpt p dp integraltext1 0pr fpt p dp by definition of x passes a t a pr nr summationdisplay i st parenleftbigg nr i parenrightbigg pi p nr i note that if we assume a discrete probability distribution we can replace the integrals above by sums over p and the density functions fpt p by probabilities pr .
using this approximation and plugging the parameters nr andst as well as the discrete prior probability distribution pr obtained experimentally see section we have pr .
.
so selecting pb .
and .
would at first seem like an option to prove a bound on the probability of ptmin pb .
unfortunately most executions of our algorithm perform a largenumberofcallsto passes andtheerroraccumulates rapidly.
after just calls the naive bound on pr ptmin .
in our example would become .
.
.
bounding the error in our algorithm more tightly is non trivial.
instead when running our experiments we perform a final independent check calling passes a tmin a one last time on the final output of our algorithm.
in section we observe that this final check passes often.
for the minimized traceswherethisfinalchecksucceeds wecanindeedsaythat ptmin .
with probability .
as per the example above which uses our experimental parameters.
we can now get a bound on the probability of the second requirement in the definition of approximate minimality lemma .iftmin nd3min a t a then the probability hatwidepthat there exists no subtrace t obtained by removing a single event from tmin such that pt pbis hatwidep integraldisplay1 pb parenleft igg nr summationdisplay i st parenleft ignr i parenright ig pi p nr i parenright igg fpt p dp integraldisplay1 parenleft igg nr summationdisplay i st parenleft ignr i parenright ig pi p nr i parenright igg fpt p dp l wherelis the number of events in tmin.
proof.
consider only the last call to the recursive procedureminr which returns tmin.
note that minr returnstminonly in case which executes only when cases to are not satisfied.
thus for the last execution ofminr case must have been skipped which meansk len tmin .
since k len tmin the set i k .ti contains every subtrace which can be obtained by removing a single event from tmin.
because case was also not satisfied we know that calling get passing on this set at line returns none.
by definition this is equivalent to callingpasses on eachtiand having it return false.
takingyi passes a ti a we have pr nr summationdisplay i st parenleftbigg nr i parenrightbigg pi p nr i and using steps analogous to equations to above hatwidepi pr integraltext1 pbpr fpti p dp integraltext1 0pr fpti p dp which is the probability pr for each tigiven the behavior of passes the algorithm must have observed.
finally the probability that no tiis such that pti pb is given by hatwidep producttext ti hatwidepi which expands to the formula for hatwidepgiven in the lemma s statement since the formula for hatwidepiis the same for every ti and there are l k len tmin such subtraces.
.
trace selection recall that the method get passing takes a set sof subtraces of t and must return a subtrace tc ssuch that calling the oracle o a tc a nrtimes would succeed sttimes.
if no such tc sexists get passing must be able to determine that and return none.
calls to oracle o are time consuming so we wish to minimize the number of such calls that execute non concurrently.
we assume that we have a maximum of minstances of owhich can be run in parallel.
in our implementation these represent individual instances of the android emulator.
for each call to get passing we have a set of ntraces s t0 ... tn .
we define a schedule as an array sch suchthat summationtextn j 0vj m. astepfor get passing consists on generating a new schedule sch running vjoracle callso a tj a for each j and capturing the results.
since the total number of calls to ois at most m the calls corresponding to a single step of get passing can be executed in parallel.
we accumulate the results of all steps before the current one as pairs sj fj where sjis the number of successes seen so far for tj i.e.
was returned by o a tj a andfjthe number of failures was returned .
we can see that given the definition of get passing we never gain anything from running a single tjmore than nr times soweforbidthis andthus j.sj fj nr.
weseekto minimize the number of steps in each call to get passing before we can either identify a tjwhich satisfies passes i.e.
j.sj st or we have concluded that no such tjcan exist.
we note that given the previous constraints if ever fj nr st tjcannot be a trace that satisfies passes .
we give strategies for minimizing the number of steps ofget passing .
section compares them empirically.
.
naive scheduling there are two obvious ways to generate the schedule sch at every step of get passing which depend very little onthe observed pairs sj fj .
the first method is to schedule all nrexecutions for each trace one after the other so at every step vj min nr sj fj m summationtextk j k 0vk .
this strategy goes from j ton and greedily tries to add another execution of tjtoschuntil so would either mean that more than nrexecutions of tjhave been scheduled over all steps of get passing or would push the schedule beyond the limit of mcalls too.
a common sense optimization is at every step to return immediately if a tjwithsj sthas been found and ignore anytjwithfj nr stfor scheduling.
the worst case for this strategy happens when no trace in ssatisfiespasses .
the following is a particular example of this greedy strategy in action with nr st n and m .
we represent each step as a transition between two lists of pairs sj fj j representing the accumulated results before and after the step.
each step is also annotated with the corresponding schedule sch another naive strategy is to schedule traces in a round robin fashion.
each step scans j ton multiple times adding an additional invocation of tjifsj fj vj nr andfj nr st. it stops when the schedule is full mcalls scheduled and proceeds to run sch.
again we stop as soon as there is nothing else to run or we have found a tjwith sj st. the worst case for this strategy happens when all traces succeed with high probability.
we repeat the example above with the round robin strategy both of these naive strategies are similar in that they are likely to do plenty of unnecessary work in the average case.
we chose the round robin variant as our baseline for comparison since it performs better in the case in which is common for many of the traces in sto fail the oracle often and stis close to nr this matches our scenario .
.
heuristic exploration followed by greedy the naive algorithms don t exploit all of the information contained in the pairs sj fj in deciding what to do next.
clearly if we have a trace tj1for which sj1 fj1 andatrace tj2forwhich sj2 fj2 thentj1issignificantly more promising than tj2 and we should try checking it first.
conversely it should be possible to discard tj2by scheduling it for execution only a few more times adding copies of tj2to the next schedule while allowed would likely be a waste.
we use these observations to propose a heuristic that at every step a tries to confirm traces that seem likely to be successful and b tries to discard traces that seem likely to be unsuccessful in that order of priority.
before scheduling the first step we have j. sj fj .
since we have no information we simply schedule the traces in sin a round robin fashion.
this gives us at least some information about every tj.
in every round after that we follow the algorithm outlined in figure .globals c 1defschedule s j.vj j.pj sj sj fj sortsbypj sjdesc sc sd sf while summationtext jvj m ifsc atio slash tk remove first sc xk min nr sk fk st sk pk ifxk m summationtext jvj vk xk elifxk m sd sd else vk m summationtext jvj elifsd atio slash schedule from sdby round robin.
elifsf atio slash tk remove first sf yk min nr sk fk nr st fk pk vk min yk m summationtextvj else schedule from original sby round robin.
figure trace selection heuristic.
we first compute pj sj sj fj for each j the empirical success probability of tjso far.
we sort sin descending order first by pjand then by sj.
then we partition the sorted array sinto two sections sccontains the traces such thatpj cfor a certain constant c c .
in our implementation and sfthe rest.
we assume that traces in sc are likely to succeed after nrcalls too while traces in sf are likely to fail and we predict accordingly.
while there are traces in sc and our schedule is not full we remove tk fromscin order.
we compute xkin line which is the expected number of runs of tkneeded to get to the point wheresk st. if we can schedule that many runs we do so line .
if we can t schedule xkruns oftkin this step but we can do it in the next step we move tktosd a list of deferred traces from sc.
we do this so that if we can pack the expected number of runs for multiple traces in sc we do so even if those aren t the traces with the highest pj.
ifxkis too large to schedule in any single step then we just schedule as many copies of tkas we can.
only when scis empty we revisit the traces in sdand schedule them in round robin fashion.
if there are no traces insdthen we begin removing tkfromsfin order.
we compute ykin line for these traces which is the expectednumberofrunsof tkneededtogettothepointwhere fk nr st at which time we can declare that trace as failingpasses .
we could run the traces in sdin order of increasing empirical success probability which would allow us to discard some of them more quickly but this doesn t reduce the expected number of steps for get passing since we need to discard all traces before we can return none.
we run them in order of the decreasing probability instead as this will allow us to more quickly correct course in the rare case in which we have misclassified a passing trace as being insd after running a few more copies of the trace instead of discarding it we would observe its empirical probability increasing and we reclassify it into scon the next step.
if there is space left in the schedule after scheduling sc sdandsfas described we add additional runs of the traces insin a round robin fashion that is copies beyond the expected number of executions required to prove or disprove eachtj but without running any tjmore than nrtimes.
we show the execution of our heuristic on our same example from the previous two techniques .
solving trace selection as an mdp wecanformulatetheproblemoftraceselectionasamarkov decision process mdp which allows us to solve for the optimal strategy for given values of the parameters n m nr st. amarkovdecisionprocessisatuple s a p r where sis a set of states ais a set of actions and p s a pr isamapfromeverystateandactionpairtoaprobability distribution over possible state transitions.
r s r is the reward function which associates a value with reachingeachstate.
finally iscalledthediscountfactor.
to execute an mdp we start from some initial state 0 s then choose an action a0 a. the mdp then transitions to a state 1chosen at random over the probability distributionp 0 a0 .
the process is then repeated selecting a newaifor each iand choosing i 1from the distribution p i ai .
the value of the execution of the mdp is then summationtext i ir i which is the reward of each state visited multiplied by i. the discount factor is used to decrease the reward of reaching good states in proportion to how late in the execution these states are reached.
given a policy s a which is simply a mapping from states to actions we calculate the value of the policy as the expected value v 0 e summationtext i ir i where 0is the initial state and for every i ai and i is chosen from p i ai .
solving an mdp is equivalent to finding a policy that maximizes v 0 .
we encode trace selection as an mdp as follows s is the set of possible combinations of observed values of sj fj for each tj s. the initial state is 0 a summationtextn j 0vj m is the set of possible schedules sch.
p i a where i a and j with k. sjk fjk sik fik vk is n productdisplay k summationdisplay p parenleftbigg vk s parenrightbigg ps p vk s pr withs sjk sik.p i a is if k. sjk fjk sik fik atio slash vk.
r is for every state and we make the reward negative and the discount factor since we wish to find only a policy that minimizes the number of reached states which is equivalent to minimizing the number of steps in get passing .
any state containing sj fj withsj stfor anyj as well as any state where fj nr stfor every j is a terminal state of the mdp once such a state is reached the execution of the mdp ends.note too that the precise definition of p i a requires knowledge of pr for each subtrace tk.
but we have no way of precisely knowing this distribution.
in practice if we have a prior discrete probability distribution pr pt p over the set of all possible subtraces we can approximate pr summationdisplay p parenleftbigg parenleftbigg sk fk sk parenrightbigg psk p fk parenrightbigg pr insection5 weapproximatethepriorbyrunning nd3min with naive round robin trace selection on a few app trace activity tuples.
weusethatexperimentallydiscoveredprior to approximate p i a .
therearemethodsforsolvinganmdpinthegeneralcase but they require iterating multiple times over the set sand calculating the expected value v of each state based on the value of other states until a fix point is reached.
in our formulation the number of states enumerated naively is s parenleftbiggk nr summationdisplay k k parenrightbiggn parenleftbigg nr nr parenrightbiggn since we can construct k pairs sj fj withsj fj k. forn nr this gives us over 1011states.
we can significantly optimize our solution for this particular mdp in two ways however by getting rid of the fix point iteration requirement changing it to a single pass overs and by reducing the size of sitself.
first we observe that in our mdp we can never visit the same state twice.
in fact our mdp is a dag where each statemusttransitiontooneinwhichthesumoftheelements of the tuples sj fj has a higher value.
this type of mdp is called a finite horizon mdp .
we now restrict all candidate policies to include only schedules for which summationtextn j 0vj mexactly except in the case in which so would violate the constraint j.sj fj nr.
in the latter case every always chooses to schedule as many runs of each tjas needed to reach nr.
we note that this last action must always lead to a final state.
every state reachable from the initial state following any with the above restrictions is either a final state or is such that summationtextn j sj fj modm .
we then define i the state s iteration such thati parenleftbig summationtextn j sj fj parenrightbig mfor every non final state.
i is always an integer.
we assign all final states to iterationi nr n m .
we note that for every i s as above and j p i we have i i .
given the partition of sinto subsets si s i i induced by i we can solve the mdp by visiting each si once in reverse order of iand computing the optimal andv for each si.
we do not need to iterate to reach a fix point since v r maxa a summationdisplay parenleftbig p parenrightbig v depends only on the values v of states reachable from by actions in .
since all such states satisfy i i their value has already been calculated when visiting a previous sj i. the time to solve the mdp by this method iso a s .
note that within a single si the problem of computing v forthestatesin siishighlyparallelizable.we can further reduce s by merging states which are isomorphic in our model.
first we can coalesce all final states into two a success state swhenever sj stfor anyj and a failure state fwhenfj nr stfor every j. furthermore if state hasfj nr stfor anyj this is equivalent for the purposes of get passing to the same state after replacing sj fj with x y withy nr st. we pick a single state in this equivalence set as representative takingcare tochooseone whichpreservesthe invariant summationtextn j 0sj fjmodm and falls into the latest possible iteration.
we can also reorder the tuples sj fj in every state since the order of the subtraces in sdoes not affect the result of get passing and the generated policy will be identical up to a reordering of a .
after applying all optimizations for n m nr and st our algorithm must examine s states in order to compute the optimal strategy .
after pre computing for a particular set of parameters n m nr st we can use it to generate a schedule schat each step of the trace selection process.
section compares the number of steps required by get passing when using this strategy versus our heuristic from section .
.
.
results this section presents our empirical evaluation and results.
section .
describes our experimental setup and presents the data discussed in the rest of the section.
section .
explores the size of the minimized subtraces and the number of calls toget passing performed by the algorithm.
section .
contrasts the performance of the different trace selection methods of section .
finally section .
explores the prevalence of application non determinism in our dataset.
our tests were performed in an amazon ec2 cloud environment in which we ran m android emulator instances each on its own virtual machine as our test oracles.
as mentioned before the rest of the parameters used for nd3min aren nr and st .
.
datasets we evaluate our event trace minimization approach on two different datasets one composed of applications from the google play store selected among the top most popular apps in their category across different app categories gplay and another of redistributable open source applications from the f droid open source application repository fdroid .
for each application we generated random monkey traces of events each restricting ourselves to tap events exclusively.
although our approach can potentially be used to minimize traces with any type of events reaching activities requiring events other than taps such as structured keyboard input or complex touch gestures often produces an unfeasibly large original trace when performing random testing alone.
we ran these traces on the corresponding application and recorded the activities reached during their execution.
for the google play apps we arbitrarily selected an average of such activities per app with the minimum being activities.
for the f droid dataset we selected an average of .
activities per app with a minimum of .
for each app a and activity a we took a trace tin our generated traces which reached awithpt .
observed over trace replays .
in the cases where many traces reached awith equal probability we picked one at random.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.0proportion of traces with probability p in prior proportion of traces with probability p in final experimental runs figure prior probability distribution of subtraces.
we first ran nd3min on nine activities from two apps com.eat24.app andcom.duolingo of thegplayset using the naive round robin trace selection strategy of section .
.
this produced calls to our test oracle owith distinct subtraces in total.
we used the oracle responses obtained from this preliminary experiment to generate a probability prior pr given an unknown t and a probabilityp.
we restricted ourselves to only two apps and nine activities for generating this prior for two reasons.
first minimizing traces under the naive strategy is a time consuming process compared with either the heuristic or mdp methods.
second we want to show that the prior computed for a few apps generalizes over unrelated android applications meaning that computing this prior is a one time cost leading to a solution for the mdp model that can be applied without changes to minimizing traces for unknown apps.
figure shows this prior probability distribution.
as observed in section .
we can use this prior to approximate the transition probabilities used in the mdp for computing the optimal policy for trace selection.
to check the quality of this prior we also plot the probability distribution as estimated by examining all queries to the test oracle performed by the rest of the experiments in this section from a total of subtraces .
this distribution shows more traces as always failing pt and fewer traces as having low but non zero probability.
otherwise the distribution looks very similar to our prior which increases our confidence in using said prior as our estimate of pr .
foreachdataset gplayandfdroid wethenran nd3min on each tuple a t a in the set under two different configurations for trace selection see section one using the heuristic in section .
exclusively for every invocation of method get passing .
one using the pre computed optimal policy section .
when get passing receives a set swith to subtraces the values of nfor which we are able to compute the optimal policy in reasonable time2 .
in this configuration get passing defaults to using the same heuristic of the previous configuration whenever get passing is passed n subtraces.
on average of the steps executed in the mdp based trace selection case are steps in which get passing was invoked with fewer than subtraces and thus uses the optimal policy based on solving the mdp.
the remaining fall back to using the same heuristic of section .
.
2solving the mdp using vcpu ec2 vms takes min forn min for n and hours for n .for the applications in the google play dataset table shows the size of the minimal subtrace obtained by our minimizationalgorithmforeachtargetactivity togetherwiththe number of steps and wall clock time that our algorithm took to extract it in each configuration.
table shows the analogous information for the f droid open source apps.
the performance of the naive method on the apps of the gplay set used to compute the pt priors is listed in table .
.
size of minimized traces steps and check the column labeled eventsin our tables specifies the number of events in the minimized trace tminas generated by our algorithm.
recall that our input traces are events long in each experiment.
the average length of the minimized traces is .
for the gplaydataset using the heuristic trace selection .
using the mdp based version.
for the fdroiddataset these numbers are .
and .
respectively.
the fact that only a few events are needed in each case to reach the desired activity shows the value of minimization.
our minimized traces are smaller than the original monkey traces by an average factor of roughly 100x.
the column labeled stepscounts the number of times the methodget passing generated a schedule and called our test oracles in parallel.
equivalently stepsis the maximum number of sequential calls to each of the test oracles required during our minimization algorithm.
to make sure the trace is suitable for minimization our implementation first runs the original trace t20 times and aborts running if the oracle doesn t accept tin at least of those calls.
we include the two steps required for this check in our count.
the column labeled checkcontains a triplet of the form c p1 p2 .
after our minimization algorithm has finished we run the resulting trace additional times and record as c the number of times it succeeds.
we use this number to calculatep1 pr andp2 the probability that ifptmin .
then tminis approximately minimal as defined by lemma .
for p1 we use a formula analogous to that of section but taking into account the exact number of successful oracle queries p1 summationtext p .
parenleftbignr c parenrightbig pc p nr cpr summationtext p parenleftbignr c parenrightbig pc p nr cpr for the probability prior required for these calculations we use the same prior from figure used by the mdp trace selection method.
all probabilities in the tables are truncated not rounded as we wish to obtain a lower bound.
as observed in section since the error of passes accumulates through multiple trace reductions in our algorithm our finalptmincan fall below pb so it is not always true that c .
the vast majority of our minimized traces fullfil ptmin .
and all but one succeed over of the time.
note that for the same app trace activity tuple our algorithm sometimes produces minimized traces of different sizeswhenusingdifferenttraceselectionstrategies.
thiscan happen for one of two reasons.
first different trace selection strategies cause delta debugging to pick different subtraces during recursive invocations of the minr method which can guide the algorithm towards discovering different minimal solutions.
a minimal solution does not imply the returned trace is of minimum length among all possible successful subtraces and an input trace can contain multiple distinct minimal subtraces that reach the desired activitytable results for the google play apps heuristic opt mdp application key activity events steps time check events steps time check com.eat24.app splashactivity .
.
.
.
homeactivity .
.
.
.
loginactivity .
.
.
.
createaccountactivity .
.
.
.
com.duolingo loginactivity .
.
.
.
homeactivity .
.
.
.
welcomeflowactivity .
.
.
.
skillactivity .
.
.
.
lessonactivity .
.
.
.
facebookactivity .
.
.
.
com.etsy.android homescreentabsactivity .
.
.
.
coreactivity .
.
.
.
detailedimageactivity .
.
.
.
com.ted.android splashscreenactivity .
.
.
.
mainactivity .
.
.
.
talkdetailactivity .
.
.
.
videoactivity .
.
.
.
bucketlistinfoactivity .
.
.
.
com.zhiliaoapp.musically signinactivity .
.
.
.
oauthactivity .
.
.
.
termofusactivity .
.
.
.
com.pandora.android signupactivity .
.
.
.
signinactivity .
.
.
.
forgotpasswordactivity .
.
.
.
com.google.android licenseactivity .
.
.
.
.apps.photos licensemenuactivity .
.
.
.
settingsactivity .
.
.
.
photosaboutsettingsactivity .
.
.
.
average .
.
.
.
median .
.
.
.
table results for the f droid apps heuristic opt mdp application key activity events steps time check events steps time check com.evancharlton mileage .
.
.
.
.mileage vehiclestatisticsactivity .
.
.
.
totalcostchart .
.
.
.
fillupinfoactivity .
.
.
.
fillupactivity .
.
.
.
filluplistactivity .
.
.
.
minimumdistancechart .
.
.
.
averagefueleconomychart .
.
.
.
de.delusions.measure measuretabs .
.
.
.
measureactivity .
.
.
.
bmitableactivity .
.
.
.
bmicalcactivity .
.
.
.
org.liberty.android anymemo .
.
.
.
.fantastischmemo optionscreen .
.
.
.
algorithmcustomizationscreen .
.
.
.
studyactivity .
.
.
.
cardeditor .
.
.
.
spreadsheetlistscreen .
.
.
.
org.totschnig calculatorinput .
.
.
.
.myexpenses myexpenses .
.
.
.
expenseedit .
.
.
.
average .
.
.
.
median and have different lengths.
because of the probabilistic nature of our algorithm it is also possible that the trace returned by nd3min is not truly minimal especially if it contains a subtrace which reaches the activity with a probability very close to .
which our algorithm might have trouble classifying either way.
we can observe this situation when contrasting the minimized traces discovered by the naive and heuristic trace selectionmethodsfor createaccountactivity incom.eat24.app .
the heuristic method produces a event minimized trace that passes out of oracle calls in its final check while the naive method returns a event subtrace which is actually a subtrace of the one returned by the heuristic case but which only passes checks.
we re ran both traces times which suggests the underlaying probability of the event trace is .
and that of the event trace is .
.
.
performance comparison figure plots the number of steps and wall clock time for each experiment comparing the naive heuristic and mdpbased trace selection methods.
we normalize in each experiment to the value obtained in the heuristic case since we only have the performance of the naive method for the limited set of app trace activity tuples in table .
thus the red line at represents the performance of our heuristic and the bars represent the performance of the naive and mdpmethods relative to that of the heuristic.
the dashed vertical line separates the experiments for which we have data on the naive method from those for which we don t. we note that the configuration using the mdp policies doesn t always outperform our heuristic.
this is not unreasonable since a the mdp method only guarantees to minimize the number of steps in get passing but it might pick different subtraces than other methods thus failing to minimize the number of steps over the whole algorithm b even within a call to get passing we are approximating the prior of pt based on previous experiments which could lead to non optimal results if the distribution of underlying trace probabilities is very different in the particular app under test versus the set used to compute the prior and c since the oracle is non deterministic the number of stepsouralgorithmmustperform evenwhenusingthesame trace selection method varies across runs.
our results do indicate however that using the heuristic method for trace selection is a reasonable option which performs similarly to solving the mdp formulation and avoids the expensive pre computation for every value of n. two outliers in our plots bear explaining.
in experiment both our heuristic and the mdp based method seem to under perform the naive method on the number of steps.
however this is also a case in which the naive method produces a larger trace events than either the heuristic 25table performance for naive trace selection naive application key activity events steps exec.
time check com.eat24.app splashactivity .
.
homeactivity .
.
loginactivity .
.
createaccountactivity .
.
com.duolingo loginactivity .
.
homeactivity .
.
welcomeflowactivity .
.
skillactivity .
.
lessonactivity .
.
average .
.
median a proportion of mdp and naive steps versus heuristic b times of mdp and naive versus heuristic figure trace selection performance comparison events or the mdp based method events so this outcome can be explained as the result ofthe naive method having stopped the minimization process earlier than the other two.
in experiment the mdp based method performs much worse than our heuristic while producing a trace of identical size.
in this case the heuristic found a trace consisting of consecutive events of the original trace while the mdp based method found a trace of non consecutive events.
the structure of delta debugging is such that it generally makes faster progress towards a contiguous subsequence than towards a non contiguous one.
the average running time of our minimization algorithm using the heuristic approach is hours for the activities in thegplayset median hours and hours for thefdroidset median hours .
using the mdp based method we have an average of 49h and median of 54h for thegplayset and an average of 22h and median of 58h for fdroidapps.
thus our approach fits comfortably in the time frame of software processes that can be run on a daily i.e.
overnight or weekly basis.
we tested the sequence of time measurements for all apps gplayandfdroid under the wilcoxon signed rank test and found a mean rank difference between the heuristic and mdp based methods with p .
which is not quite enough to be considered statistically significant.
we do not have enough samples under the naive method to compare it against the other two under a similar test but it can be seen from figure that this method often significantly underperforms compared to the other two.
.
effects of application non determinism one final question regarding the trace minimization problemisonwhetherornothandlingapplicationnon determinis m is truly a significant problem.
as we discussed in section some android applications present non deterministic behavior under the same sequence of gui events motivating the need for running each event trace multiple times during minimization and estimating trace probabilities.
how ever if this is a problem that occurs only rarely it might be that the techniques presented in this paper are not often required.
we argue that application non determinism is in reality a common problem as can already be somewhat discerned from the fact that the check columns of tables and often show traces as succeeding in reaching the target activity less than times in runs.
to explore the impact of application non determinism for trace minimization we took the output minimized traces of our mdp condition for the gplaydataset and attempted to further minimize them by using traditional non probabilistic delta debugging i.e.
by following the algorithm in or equivalently by running nd3min withnr st .
in out of cases this produced a further reduced trace.
we then ran each of these resulting traces an additional times.
table contrasts the size and reliability of the traces minimized under the original mdp based non determinism aware condition with that of the result of further applying traditional delta debugging to these traces.
as we can see these resulting traces succeed in reaching the target activity much less frequently than the originally minimized traces.
thus it is clear that for traces that succeed non deterministically it is important to take into account their corresponding success probabilities during minimization.
this likely becomes more significant the more steps delta debugging takes as we can see by looking at the cases of the table above in which the minimal trace obtained by the mdp strategy is larger than events.
.
related work many tools exist for generating gui event traces to drive android apps.
these tools sometimes collectively called monkeys are commonly used to automatically generate coverage of an app s behavior or to drive app execution as part of a dynamic analysis system.
dynodroid improves on the standard android monkey by automatically detecting when the application regis table effect on application non determinism in our datase t application key activity non deterministic mdp deterministic dd events check events check com.eat24.app loginactivity createaccountactivity com.duolingo skillactivity lessonactivity com.etsy.android coreactivity com.ted.android videoactivity com.google.android licensemenuactivity .apps.photos photosaboutsettingsactivity average .
.
.
.
ters for system events and triggering those events as well as standard gui events.
it also provides multiple event generation strategies which take the app context into account and it allows the user to manually provide inputs when exploration is stalled e.g.
at a login screen .
tools such as guiripper mobiguitar appsplayground orbit swifthand and a3e dynamically crawl each app while building a model which records observed states allowed events in each state and state transitions.
the generated model is used to systematically explore the app.
puma provides a general framework over which different model based gui exploration strategies can be implemented.
acteve is a concolic testing framework for android which symbolically tracks events from the point in the framework where they are generated up to the point at which the app handles them.
evodroid generates android input events using evolutionary algorithms with a fitness function designed to maximize coverage.
brahmastra is another tool for driving the execution of android apps which uses static analysis and app rewriting to reach specific components deep within the app.
a recent survey paper by choudhary et al.
compares many of the tools above and seems to suggest that the standard android monkey is competitive in coverage achieved in a limited time.
one explanation is that monkey compensates for what it lacks in sophistication by maintaining a higher rate of event generation.
of course this unexpected result could also be the effect of comparing research prototypes against an industry standard tool which performs morerobustlyevenwhileusinglesssophisticatedtechniques.
in either case the effectiveness of the standard monkey to achievehighcoverage alongwiththerelativenoisinessofth e traces produced justifies our focus on trace minimization.
in addition to general test input generation tools for android manydynamicanalysistoolsincludecomponentsthat drive exploration of the app being analyzed e.g.
.
input fuzzers can also generate application inputs albeit restricted to testing for particular scenarios such as inter app communication errors or invalid data handling rather than aiming at gui exploration.
besidesminimizingtracesgeneratedbymonkey styletools our approach is also applicable to minimizing recorded userinteraction traces.
tools such as reran mosaic and valera could be used to record the actions of a human tester as an input event trace for our method.
in addition to automated input generation tools guiaware tests for android applications tend to be encoded as testing scripts in frameworks such as selendroid robotium calabash or espresso .
these frameworks allow scripting specific interaction scenarios with an android app and adding checks to generate an effective application test suite.
a promising line of future work is to automatically transform automatically generated and mini mized execution traces into test scripts expressed in any of these frameworks as a way to provide a starting point for test suite writers.
regardingourspecifictechnique thecoreofouralgorithm is based on delta debugging.
delta debugging is a family of algorithmsforsequenceminimizationandfaultisolation de scribed originally by zeller et al.
.
this technique has been extended to many scenarios .
in particular the work by scott et al.
extends delta debugging to minimize execution traces which trigger bugs within non deterministic distributed systems.
they run standard delta debugging over the traces of external user triggerable events.
then tocheckeachsubtraceofexternalevents they instrument the system under test and explore the space of possible interleavings of internal events.
by contrast we treat non deterministic android applications in a blackbox manner and rely on modeling the probability of success of tracesofexternalevents independentlyoftheinternalworkings of the system being tested.
for the specific case of minimizingguieventtracesinandroidapplications animportant source of non determinism turns out to be responses fromnetworkservicesoutsideourcontrol justifyingtheneed for a blackbox approach.
in other scenarios the tradeoff between both approaches likely depends on the complexity of the internals of the system being tested and the success probability of the original trace to be minimized.
amarkovdecisionprocessisastandard modelwithinthe reinforcement learning literature see e.g.
.
mdps are used to solve a variety of problems across multiple domains including optimizing resource consumption in mobile phones .
to the best of our knowledge we are the first to apply them to the problem of trace minimization in testing.
.
conclusions we have presented the problem of minimizing large gui event traces as a first step towards producing scripted test cases from the output of random input testing tools such as android s monkey.
we have shown a delta debugging extension that handles non determinism which we have shown is a pervasive issue in app behavior.
we have also presented two strategies for efficient trace selection.
evaluation of our trace minimization method shows that the resulting traces are times smaller while still reaching the same activity with high probability.
.