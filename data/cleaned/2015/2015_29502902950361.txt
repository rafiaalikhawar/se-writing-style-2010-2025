an extensive study of static regression test selection in modern software evolution owolabi legunsen1 farah hariri1 august shi1 y afeng lu2 lingming zhang2 and darko marinov1 1department of computer science university of illinois at urbana champaign legunse2 hariri2 awshi2 marinov illinois.edu 2department of computer science the university of texas at dallas yxl131230 lingming.zhang utdallas.edu abstract regression test selection rts aims to reduce regression testing time by only re running the tests affected by code changes.
prior research on rts can be broadly split into dynamicandstatictechniques.
a recently developed dynamic rts technique called ekstazi is gaining some adoption in practice and its evaluation shows that selecting tests at a coarser class level granularity provides better results than selecting tests at a finer method level granularity.
as dynamicrts is gaining adoption it is timely to also evaluate staticrts techniques some of which were proposed over three decades ago but not extensively evaluated on modern software projects.
this paper presents the first extensive study that evaluates the performance benefits of static rts techniques and their safety a technique is safeif it selects to run all tests that may be affected by code changes.
we implemented two static rts techniques one class level and one methodlevel and compare several variants of these techniques.
we also compare these static rts techniques against ekstazi a state of the art class level dynamic rts techniq ue.
the experimental results on revisions of open source projects show that the class level static rts technique is comparable to ekstazi with similar performance benefits but at the risk of being unsafe sometimes.
in contrast the method level static rts technique performs rather poorly.
ccs concepts software and its engineering software evolution automated static analysis software defect analysis software testing and debugging keywords regression test selection static analysis class firewall permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c circlecopyrt2016 acm.
isbn .
.
.
.
introduction modern software projects evolve rapidly as developers add new features fix bugs or perform refactorings.
to ensure that project evolution does not break existing functionality developers commonly perform regression testing.
however frequent re running of full regression test suites can be extremely time consuming.
some test suites require weeks to run but waiting even a few minutes for test results can be detrimental to developers workflow.
in addition to reducing developers productivity slow regression testing can consume a lot of computing resources.
for example engineers at google have observed a quadratic increase in their total test running times showing that regression testing is challenging even for a company with a lot of computing resources.
as a result a large body of research has been dedicated to reducing the costs of regression testing using approaches such as regression test selection regression test su ite reduction regression test case prioritization and test parallelization .
yoo and harman provide a thorough survey of regression testing approaches .
regression test selection rts is the most widely used approach to speeding up regression testing .
rts aims to reduce regression testing efforts by only re running the tests affected by code changes.
an rts technique is safeif it selects all tests whose behavior may be affected by code changes notrunninganyofthosetestsmaycausedevelopers to miss regressions.
prior research on rts can be broadly split into dynamic andstatictechniques.
a typical dynamic rts technique requires two types of information changes between two code revisions and test dependencies dynamically computed while running the tests on the old code revision.
given these inputs the technique analyzes how the code changes interact with the dependencies to determine a subset of tests that may reach and thus get affected by the code changes.
dynamic and safe rts has been drawing attention in the literature since at least with some newer techniques such as dejavoo faulttracer and ekstazi .
different dynamic rts techniques differ in precision1and analysis overhead.
techniques that collect finer granularity dependencies may be more precise selecting fewer tests to be 1safe techniques always select all tests affected by code changes but could also select some non affected tests.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
run but can incur higher analysis overhead in contrast techniques that collect coarser granularity test dependencie s may be less precise but can have lower analysis overhead.
the state of the art dynamic rts technique ekstazi tracks changes and dependencies at the granularity level of files for java code these files include bytecode classes.
ekstazi computes classes which changed between revisions and classes that each test class required while running on the old code revision.
ekstazi selects to run on the new code revision only tests that depend on at least one of the changed classes.
prior experiments with ekstazi showed that using coarse granularity test dependencies at the class level can substantially save the end to end test ing time that includes time to analyze changes run selected tests and update dependencies .
due to this several open source projects e.g.
apache camel apache commons math and apache cxf have already incorporated ekstazi into their build systems .
despite the recent advances in dynamic rts its reliance on dependencies collected dynamically could limit its appl ication in practice making it important and timely to reconsider static rts.
first when performing rts dynamic test dependencies for the old revision may not always be available e.g.
on the first application of rts to the project the project may have earlier revisions .
second dynamic test dependencies for large projects may be time consuming to collect.
third for real time systems dynamic rts may not be applicable because code instrumentation for obtaining dependencies may cause timeouts or interrupt normal test run.
finally for programs with non determinism e.g.
due to randomness or concurrency dependencies collected dynamically may not cover all possible traces leading to dynamic rts being unsafe.
in contrast to dynamic rts which collects test dependencies dynamically static rts uses static program analysis to infer ideally an over approximation of the test dependencies to enable safe test selection.
however although static rts techniques for object oriented languages have been proposed over three decades ago to our knowledge these techniques have not been studied extensively on modern real world projects.
in particular it is not clear a priori which granularity level would be better forstaticrts although i the most recent work on dynamic rts shows that class level provides better results than method level and ii due to the growing and relatively larger scale of modern software systems other recent state of the art dynamic rts techniques use coarser granularity e.g.
classes and methods rather than finer granularity e.g.
statements or cfg edges which are more expensive to collect.
to investigate the safety precision and overhead of static rts we implemented one class level static rts technique and one method level static rts technique.
the class level static rts technique classsrts is our implementation of the previously proposed class firewall technique it finds class level dependencies by reasoning about inheritance and reference relationships in a class dependency graph.
classsrts selects to re run any test class that transitively depends on any changed class in the dependency graph.
the method levelstaticrtstechnique methsrts utilizescallgraph analysis it constructs a call graph with all testmethods as entry points and selects to re run test classesthatcantransitivelyreachanychangedclassthroughatraversalofthecallgraph.
ourclasssrtsandmethsrts implementations are based on the asm bytecode manipulation and analysis framework and the t.j. watson libraries for analysis wala respectively.
we evaluated these two static rts techniques on revisions of open source java projects.
we considered two variants of classsrts and eight variants of methsrts and we compared them against ekstazi.
the results show thatclasssrtshascomparableperformanceasekstazi but classsrts is occasionally unsafe.
in contrast methsrts performs rather poorly it does not provide performance benefits and is more frequently unsafe.
the latter result was somewhat surprising as one may expect finer grain analysis at the method level to be safer and more precise but potentially slower than the coarser grain analysis at the class level.
in conclusion we recommend that researchers continue improving static rts techniques at the coarser granularity which already shows promising results at least at the level of classes if not modules or projects .
.
background we introduce the two static rts techniques based on program analysis at different granularity levels classsrts performs class level analysis section .
and methsrts performs method level analysis section .
.
although they perform analyses at different levels we implemented both techniques to report selected test classesto aid comparison.
in the rest of the paper when we refer to atest we mean a test class.
recent surveys on regression testing and change impact analysis provide more details about static and dynamic rts.
.
class level static rts classsrts leung et al.
first introduced the notion of firewall to assist testers in focusing on code modules that may be affected by program changes.
kung et al.
further introduced class firewall to account for the characteristics of object oriented languages e.g.
inheritance.
given a set of changed classes a class firewall computes the set of classes that may be affected by the changes conceptually building a firewall around the changed classes.
the original class firewalltechniquewasproposedfortheobject relationgraph in c and orso et al.
generalized it to the intertype relation graph irg to additionally consider interfaces in java.
subsequently we use typesto denote classes and interfaces.
to the best of our knowledge using the irg and the class firewall is the only proposed technique to perform class level static rts in java.
an irg represents the use and inheritance relations between types in a program as defined by orso et al.
definition .
intertype relation graph .
an intertype relation graph irg of a given program is a triple a gbracketleftn ei eu a gbracketrightwhere nis the set of nodes representing all types in the program ei n nis the set of inheritance edges there exists an edge a gbracketleftn1 n2 a gbracketright eiif typen1inherits from n2 and a class implementing an interface is in the inheritance relation eu n nis the set of use edges there exists an edge a gbracketleftn1 n2 a gbracketright euif typen1directly