guicat gui testing as a service lin cheng jialiang chang zijiang y ang department of computer science western michigan university kalamazoo mi usachao wang department of computer science university of southern california los angeles ca usa abstract guis are event driven applications where the flow of the program is determined by user actions such as mouse clicks and key presses.
gui testing is a challenging task not only because of the combinatorial explosion in the number of event sequences but also because of the difficulty to cover the large number of data values.
we propose guicat the first cloudbased gui testing framework that simultaneously generates event sequences and data values.
it is a white box gui testing tool that augments traditional sequence generation techniques with concolic execution.
we also propose a cloudbased parallel algorithm for mitigating both event sequence explosion and data value explosion by distributing the concolic execution tasks over public clouds such as amazon ec2.
we have evaluated the tool on standard gui testing benchmarks and showed that guicat significantly outperforms state of the art gui testing tools.
the video demo url is ccs concepts software and its engineering software verification and validation software testing and debugging keywords symbolic execution test generation gui testing cloud .
introduction graphical user interfaces guis provide a convenient way for the user to interact with the computer.
they are eventdriven applications where the flow of the program is determined by user actions such as mouse clicks and key presses.
in contrast to console applications whose only point of interaction is at the beginning guis have a potentially large number of interaction points each of which may be associated with a different state.
these features often make traditional software testing techniques ineffective.
specifically corresponding author email zijiang.yang wmich.edu gui testing has two significant challenges.
first covering all possible event sequences of a gui application is difficult due to the combinatorial explosion i.e.
the number of possible ways of clicking kbuttons can be as large as k!.
second gui behaviors depend not only on the event sequence but also on the data values of widgets such as text boxes edit boxes and combo boxes thus leading to an extremely large input space.
for example covering all possible values of a k character input string requires 26ktest cases.
although existing gui testing tools have addressed the challenge of generating high quality event sequences they have not addressed the challenge of simultaneously generating high quality data values.
as such data dependent gui behaviors are often inadequately tested.
we propose guicat a cloud based gui testing framework that generates both high quality event sequences and highquality data values by augmenting state of the art event sequence generation techniques with concolic execution.
the result is a white box gui testing tool that uniformly explores the event flow as well as the data flow.
we also propose a parallel concolic execution algorithm for mitigating the data value explosion by distributing the computation tasks over workers on private clusters as well as public clouds such as amazon ec2 .
it provides an illusion of running guicat on a powerful super computer and thus allows it to handle significantly larger applications than previously possible.
we have implemented guicat based on a number of opensource tools including guitar for generating the initial event sequences asm for java bytecode instrumentation catg for concolic execution and jacoco for computing code coverage.
unlike prior techniques guicat is fully automated in modeling gui widgets.
that is it does not require developers to manually model these widgets.
this is important because manual modeling is not only labor intensive and error prone but also hard to sustain in the long run due to frequent widget updates.
we have evaluated guicat on amazon ec2 for a set of gui testing benchmarks.
guicat achieves scalability through the distribution of symbolic execution tasks the remainder of the paper is organized as follows.
we illustrate the main idea behind guicat using motivating examples in section .
we present our algorithm in section which is followed by our experimental results in section .
we discuss the related work in section .
finally we give our conclusions in section .
.
motiv ating examples figure shows a gui example for computing ticket fare based on user inputs including name age level distance and coupons.
once the buy button is clicked the applica permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c circlecopyrt2016 acm.
... .
name jtextfield gettext string superman distance jtextfield gettext int age level jcombobox getselectedindex int jcombobox isselected int jcombobox isselected int jcombobox isselected int figure a gui example and guicat s configuration file.
onclickcomputeprice intcoupon string age string agecombobox.getselecteditem string sdistance distancetextfield.gettext intdistance integer.parseint sdistance if d100checkbox.isselected coupon if d200checkbox.isselected coupon if d400checkbox.isselected coupon if age.equals child coeffienct else coeffienct if distance price else if distance price distance coeffienct coupon else if distance price distance coeffienct coupon else if distance price distance coeffienct coupon else price distance coeffienct coupon assert price infofield.settext price figure code snippet for computing the ticket price.
tion computes and then displays ticket price using a coefficient associated with the chosen age level.
to allow guicat to generate test cases the user must provide a configuration file that specifies the name and type of the symbolic variables as shown in figure right .
each entry line of the configuration file consists of the widget name widget type method for obtaining user input e.g.
gettext type of user input and the default value e.g.
superman .
here 1means the default value is of enum type with two values 0and .
figure shows the code for computing the ticket price.
it has a bug that can lead to negative ticket prices.
for example if a user has three coupons then purchasing a child ticket for a distance of miles would result in the price being dollars.
however since a negative price requires a specific combination of widget values such bug is difficult to detect using state of the art gui testing tools such as guitar .
this is because guitar focuses primarily on generating event sequences as opposed to generating a diverse set of widget values.
our new tool guicat in contrast can quickly generate a combination of event sequences and widget values to expose this assertion failure.
guicat generates the test cases as follows.
first it uses guitar to generate the initial set of event sequences up to a bounded length.
then for each event sequence it creates an instrumented gui where some variables are marked as symbolic based on the configuration file.
next it conducts symbolic execution of the instrumented gui over the cloud.finally it uses jacoco to generate the coverage report.
now we explain each step in more detail.
step .
we use guitar to generate event sequences of a bounded length.
assume the bound is and events e1 .
.
.
e7 denote nametextfield distancetextfield agecombobox 100dollarcheckbox 200dollarcheckbox 400dollarcheckbox and buybutton .
after running guitar we have the following seven length event sequences e1 e7 e2 e7 e3 e7 e4 e7 e5 e7 e6 e7 and e7 e7 .
in this example all the bounded sequences end in e7because otherwise no action can be taken at the end of the user interaction.
consider e2 e7 as an example.
it means the user specifies a distance e2 before clicking the buybutton e7 .
although logically meaningless this particular event sequence is feasible.
step .
for each event sequence produced by guitar we generate more sequences by enumerate the values of widgets with enum types.
for example in e3 e7 we know jcombobox is associated with e3and it has an enum type.
therefore we enumerate all possible values of jcombobox to produce the new sequences e0 e7 and e1 e7 where ei 3means the value iis chosen for event e3.
we also enumerate the values of other widgets with enum types including agecombobox 100dollarcheckbox 200dollarcheckbox 400dollarcheckbox.
since these selectable widgets have a limited number of data values enumerating them is often more efficient than generating the values using concolic execution.
step .
for each event sequence generated in step we instrument the gui application by marking certain variables as symbolic.
consider the guicat conf file in figure right where the last four widgets are of enum types but the first two are not.
thus we mark the first two widgets as symbolic.
that is we use catg.readstring superman to create a symbolic string and use catg.readstring to create a symbolic integer.
here superman and 100are the default concrete values for the symbolic variables.
step .
we use catg to execute each instrumented gui application symbolically following the specific event sequence.
consider e1 e7 again where e7is associated with branches of an ifstatement.
symbolic execution will lead to the creation of new values for name and distance e.g.
name superman and distance .
mapping the values back to the event sequence will result in esuperman e50 e1 e7 where the first two events are added to set the values of the widgets.
step .
after generating all the event sequences and data values using concolic execution we use jacoco to compute the coverage report.
jacoco is an open source code coverage library for java whose output is formulated as an html page to show the coverage statistics.
.
architecture figure shows the architecture of guicat.
given a gui program pas input guicat first invokes guitar to generate event sequences.
then it instruments the program based on each sequence and the symbolic variables specified in guicat conf .
next it invokes the distributed algorithm to conduct symbolic execution of the instrumented program on a cloud node.
finally the test cases generated by all instrumented programs are collected and then used by jacoco to compute the coverage report.
in the distributed symbolic execution algorithm n0is the load balancer and n1.
.
.nkare the kworkers on the cloud.
n0distributes the set eof instrumented gui programs one per event sequence over the kworkers.
the workers then conduct symbolic execution on their share of tasks.
initially each worker receives roughly the same number of tasks.
how859guicat confbytecode instrumentationevent sequencesevent seq.
gen. guitar program p instrumented gui distributed sym.
exec.
catg test cases coverage gen. jacoco coverage report figure the architecture of our guicat tool.
algorithm symbolic execution on a worker.
e t while true do ifreceiving task set e then e e e send n0 e else if requesting tasks on behalf of nithen send ni e send n0 e else if collecting test cases then send n0 t terminate end if for all e edo pe instrument p e c f g te catg .execute pe send n0 e t t te end for end while ever since the cost of symbolic execution varies for each event sequence some workers may finish their symbolic execution tasks sooner than others.
n0detects such imbalance and requests a worker with the largest workload to share its tasks with the idle worker.
after all workers complete their tasks the load balancer n0collects the test cases.
algorithm shows the symbolic execution procedure for each individual worker.
initially the set eof tasks and test cases tare both empty.
then the worker keeps checking messages from n0and conducting local symbolic execution.
if it receives a set e of tasks from n0or another worker the new tasks are added to the local set.
since the number of tasks is changed it updates n0with its current number of tasks.
this also occurs at lines and .
with such updates n0knows the number of tasks to be processed at the workers.
if the worker receives a message from n0that requests more tasks on behalf of another worker ni it sends half of its tasks toni line .
a signal of termination is received if n0asks for its test cases and in such case the current worker sends the locally generated test cases and then terminates.
symbolic execution is conducted for each individual event sequence e e. essentially it allows us to execute the eventdriven application as if it is a sequential java program.
we leverage the catg concolic execution tool which maintains two execution stacks one for concrete execution and the other for symbolic execution.
when catg executes an unknown method for example integer.parseint the symbolic execution stack would not be updated we have modified catg to handle unknown methods.load balancer worker 1worker 2worker worker worker figure architecture of guicat s distributed algorithm.
forworker in workers do scp r autdir .tar.gz worker gui guicat log done ... forworker in workers do scp worker gui guicat autdir report.tar.gz .
autdir worker .tar.gz done figure communication from load balancer to workers.
the distributed algorithm in guicat has been implemented on amazon ec2 as a cloud service.
we divide ec2 instances into the load balancer and the workers.
the load balancer is a multi processor ec2 instance that generates event sequences distributes tasks to the workers and collects the test cases generated by the workers.
each worker is a single processor ec2 instance that symbolically executes an event sequence to generate test cases.
guicat allows the user to customize the cloud service such as the number of workers and their computation capabilities based on customer requirements such as whether a budget first testing is preferred over a speedfirst testing or whether branch coverage is preferred over instruction coverage.
to allow easy customization we implement guicat by following the star topology shown in figure where the load balancer generates and distributes event sequences to the workers and the workers conduct concolic execution with respect to the event sequence in isolation before sending test cases back to the load balancer.
figure illustrates how event sequences are distributed to the workers and how test cases are collected from the workers.
for now distributed file system libraries are used to implement the transfer of event sequences and test cases between the load balancer and workers.
the main advantage of this architecture is efficiency since there is no communication between the workers.
.
experimental ev aluation we have implemented guicat using a number of opensource tools including guitar for generating the initial event sequences asm for instrumenting the java bytecode catg for implementing the distributed parallel concolic execution and jacoco for computing the code coverage report.
we have evaluated guicat on several gui testing benchmarks.
in all experiments we have used the amazon ec2 cloud computing infrastructure where the load balancer is deployed as a multi processor ec2 instance and each worker is deployed as a single processor ec2 instance.
in the remainder of this section we report the results of two case studies a ticket seller and a workout generator.
in each case study our experiment consists of the following steps.
first we create a configuration file for the application under test.
then we generate the event sequences using 860figure ticket seller guitar .
next we distribute the event sequences from the load balancer to workers on amazon ec2.
the initial distribution is static and divides the tasks evenly to the ec2 instances.
after receiving the event sequences each worker conducts concolic execution using catg as a result test cases are generated for these event sequences.
when all workers finished the load balancer collects their test cases and then uses jacoco to compute the coverage report.
.
the ticket seller figure shows the user interface of a more sophisticated ticket seller than the one shown in figure .
it allows the user to provide passenger information such as the name id start distance from end distance to age level class level and the coupon .
when the user clicks the buy ticket button the application stores the passenger information to an object named ticketmodel checks for consistency using the method checkmodel and computes the price using the method computeprice .
there are five different types of gui widgets in figure four of jtextfield type one of jcombobox type one of jradiobutton type one of jcheckbox type and two of jbutton type.
the first two jtextfield widgets collect the values of name andidby invoking jtextfield.gettext the combination of which may lead to buggy behaviors.
we mark both fields as symbolic.
that is when loading the related java class we use the bytecode rewriting tool asm to instrument the program on the fly to replace invocations of gettext with invocations ofsgettext a method that we develop to return a symbolic value.
the symbolic values for name andidare used during the subsequent symbolic execution step.
the next two jtextfield widgets collect the values of from and toby first invoking jtextfield.gettext and then invoking integer.parseint to cast the strings into integers.
since the symbolic execution engine catg does not support such casting we have modified catg to convert these strings into integers before using them in the subsequent logic.
as for the selectable widgets jcombobox and jcheckbox we enumerate all possible values of the enum types.
we choose enumeration over symbolic execution for these selectable widgets due to efficiency and ease of implementation.
first selectable widgets do not have many different values.
second the existing symbolic execution engine often has trouble handling them.
for example jcombobox has two methods getselectedindex and getselectitem that return values of a customized object type which cannot be easily cast to strings or integers inside catg .
to summarize we used guitar to generate the initial event sequences together with the initial parameters states.
then we add the enumerated values for selectable widgets before conducting symbolic execution to generate the values for widgets of other types.
if the initial event sequence istable results on the ticket seller length node .
tool button branches coverage instructions coverage guitar checkmodel .
.
computeprice .
.
guicat checkmodel computeprice table results on ticket seller the test cases generated in addition to guitar and the unique paths covered.
tool length test case tc enum tc concolic tc paths covered guitar guicat too short to contain all widgets of jtextfield type needed we remove the stateless jtextfield event and then append more stateful jtextfield event to the beginning of the event sequence thus increasing the length of the sequence.
we analyzed the ticket seller with several configurations.
table shows the results of generating the length test cases.
columns show the tool name and the name of the button clicked.
columns show the total number of branches and the percentage of branches covered.
columns show the total number of instructions and the percentage of instructions covered.
the results show that guicat can achieve full branch and instruction coverage even with length test cases whereas guitar can only achieve .
branch coverage and .
instruction coverage for checkmodel .
branch coverage and .
instruction coverage for computeprice .
table compares guicat and guitar in terms of the number of paths covered.
column shows the tool name.
column shows the length of the test sequences.
column shows the total number of test cases generated by guitar .
column shows the number of additional test cases generated by guicat after enumerating the values of selectable widgets.
column shows the number of test cases generated by guicat after concolic execution.
column shows the path coverage.
to accurately compute the number of paths covered we manually added code into the program.
specifically we used a vector named path where each element was mapped to an if statement.
for example the agecombo box corresponds to an if statement where we set path in the then branch and path in the elsebranch.
each time the program terminates we will obtain a unique vector path that acts as the path identifier.
these vectors are stored and then used to compute the path coverage after guicat terminates.
our result shows that overall guicat achieved significantly higher path coverage than guitar .
for length test sequences in particular guicat had times higher path coverage whereas for length test sequences guicat had times higher path coverage.
guicat also successfully detected two bugs in ticket seller.
one bug is a nullpointerexception caused by the race condition between clicking of the save button and clicking of the buybutton as shown in figures and .
the other bug is the failure of an assertion due to the computed price being less than zero.
.
the workout generator figure shows the user interface of the workout generator which is taken from barad .
it generates a workout plan based on the user input including the gender metabolism 861buybutton.addactionlistener new actionlistener publicvoidactionperformed actionevent e ticketmodel.name nameinput.gettext if ticketmodel.checkmodel ticketmodel.computeprice assert ticketmodel.price bug price !
savebutton.addactionlistener new actionlistener publicvoidactionperformed actionevent e ... ticketmodel null figure the buggy code snippet in ticket seller.
error uncaught exception java.lang.nullpointerexception at examples.ticket.baradticket .actionperformed baradticket.java ... error uncaught exception java.lang.assertionerror bug price !
at examples.ticket.baradticket .actionperformed baradticket.java figure the ticket seller bug detected by guicat.
figure workout generator experience age height and weight .
the computation starts when the user clicks the generate button.
depending on the user information the computation goes through different execution paths that use different cardio coefficients.
there are three jtextfield widgets and three jcombobox widgets.
the jtextfield widgets return string values of age height and weight using the method jtextfield.gettext before casting them to integers using integer.parseint .
based on the configuration file provided by the user guicat creates three symbolic variables for these three widgets and replaces gettext with sgettext object so it can return symbolic values.
the jcombobox widgets return values of gender metabolism and experience .
since they are selectable widgets we use enumeration to create the value combinations.
table shows the results of applying guicat to workout generator with the length of test sequences set to and .
columns show the tool name and the length of the test sequences.
columns show the number of branches covered and the percentage of branches covered.
columns show the number of instructions covered and the percentage of instructions covered.
again guicat significantly outperformed guitar in terms of both path coverage and instruction coverage.
neither tool was able to reach full path and instruction coverage with length test sequences because there are three selectable widgets which requires the length of test sequences being to be larger than .
with length test sequences guicat was able to achieve instruction coverage and .
branch coverage.
in contrast guitar did not show significant improvement intable results on workout generator node .
tool length branches coverage instructions coverage guitar .
.
.
.
guicat .
.
.
table results on workout generator the test cases generated in addition to guitar and the unique paths covered.
tool length test case tc enum tc concolic tc paths covered guitar guicat branch instruction coverage.
the reason is that guitar only used the default values of the widgets and thus cannot explore alternative paths even with a longer event sequence.
in contrast guicat used both enumeration and symbolic execution to diversify the values of the widgets.
table compares guicat and guitar in terms of the number of paths covered.
column shows the tool name.
column shows the length of the test sequences used in the experiments.
column shows the number of test cases generated by guitar .
column shows the number of additional test cases generated by guicat after enumerating the values of selectable widgets.
column shows the number of test cases generated by guicat after concolic execution.
column shows the number of paths covered.
our result demonstrates that overall guicat can achieve significantly higher path coverage than guitar .
for length test sequences in particular guicat reached times higher path coverage whereas for length test sequences guicat reached times higher path coverage.
we also observed that guicat generated many more test cases than the paths covered.
for example with the length set to guicat generated test cases to cover unique paths which means some of these test cases have led to the same paths.
if we could for example identify and eliminate these redundant test cases the performance of guicat would be further improved.
however we leave the pruning of these redundant test cases for future work.
.
effect of cloud computing figure shows the effectiveness of distributing the testing of the ticket seller a and the workout generator b over amazon ec2.
the x axis denote the number of workers ranging from to and the y axis denote the time usage in second.
the solid dashed and dotted lines represent the bounded length of and respectively.
due to the inherent parallelism in symbolic execution of different event sequences the speedup is almost linear.
.
related work guitar is the first framework capable of performing the whole process of test generation execution and result assessment for guis.
since its first publication there have been multiple improvements e.g.
.
this framework generates tests as event sequences up to a given bound.
for emulating user input a specification based approach is adopted i.e.
using values from a prefilled database.
since guitar does not provide a mechanism for reasoning about input values for data widgets guicat offers complementary and more comprehensive testing.
a ticket seller b workout generator figure time reduction achieved by cloud computing.
the work closest to ours is barad that also exploits symbolic execution to compute input values for data widgets.
it manually creates symbolic mirror of java gui library so its released source code contains a large symbolic java gui library.
manual modeling is error prone and hard to sustain.
in fact we downloaded the tool but failed to make it work on our benchmarks.
we employ a different test generation algorithm and symbolic analysis method for obtaining inputs.
another line of work is to apply model checking techniques.
for example jfp awt is an extension of the java pathfinder for gui applications.
performance enhancement of gui testing has traditionally focused on minimizing event sequences .
barad generates test cases as chains of event listener method invocations and maps these chains to event sequences that force the execution of these invocations.
such approach prunes the event input space because it does not need to consider events where there are no event listeners.
more recent work starts to apply event dependency analysis program slicing or partial order reduction to improve the performance.
our performance improvement is obtained by exploiting massive hardware resource available on cloud.
therefore our approach is orthogonal to the existing algorithmic approaches.
.
conclusion we have present guicat the first cloud based gui testing tool for simultaneously generating high quality event sequences as well as high quality data values.
internally guicat leverages guitar to generate the initial set of event sequences and then uses a combination of value enumeration and symbolic execution to generate data values of the widgets.
guicat also leverages the cloud computation infrastructure to speed up the test generation by distributing independent concolic execution tasks to ec2 nodes.
we have implemented guicat and evaluated it on a set of gui testing benchmarks.
our experiments show that guicat can significantly outperformguitar on standard gui testing benchmarks in terms of both branch coverage and instruction coverage.
.