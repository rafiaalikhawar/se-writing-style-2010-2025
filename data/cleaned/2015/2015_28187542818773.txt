helping developers help themselves automatic decomposition of code review changesets mike barnett microsoft research redmond wa usa mbarnett microsoft.comchristian bird microsoft research redmond wa usa cbird microsoft.comjo ao brunet federal university of campina grande campina grande para ba brazil joao.arthur computacao.ufcg.edu.brshuvendu k. lahiri microsoft research redmond wa usa shuvendu microsoft.com abstract code reviews an important and popular mechanism for quality assurance are often performed on a changeset a set of modified files that are meant to be committed to asource repository as an atomic action.
understanding a codereview is more difficult when the changeset consists of multiple independent code differences.
we introduce cluster changes an automatic technique for decomposing changesets and evaluateits effectiveness through both a quantitative analysis and aqualitative user study.
i. i ntroduction code review is an important mechanism for quality assurance in software development it provides feedback and avoids introducing bugs.
however code review is effective only to the degree that reviewers are able to understand the changes being made.
prior work has shown that the easier it is fora reviewer to understand a change the more likely they are to provide feedback that improves quality .
we and others have observed that when changes are small and or cohesive reviewers are most able to understand them .
unfortunately developers often make changes that incorporate multiple bug fixes feature additions refactorings etc.
.
these result in changes that are both large and only loosely related if at all leading to difficulty in understanding.
developers have indicated that they are able to understand these changes better if authors annotate them with comments in the review tool but this is a cumbersome task and occurs less than of the time in practice.
developers have also provided feedback that decomposing such composite changes would help them to understand changes during review but to date no such tools exist or are being used .
to address this we developed c luster changes a lightweight static analysis technique for decomposing changesets.
the insight underlying c luster changes is that we can relate separate regions of change within a changeset by using static analysis to uncover relationships such as definitions and their uses present in these regions.
for example if a method definition is changed in one region and its callsites are changedin two other regions these three regions are likely to be related and should be reviewed together.
connected subgraphs of related code entities form partitions that can be explored and understood independently a formal description of our algorithm is presented in section iii.in an effort to validate the results of c luster changes understand differences between different types of partitions and gauge its potential usefulness we built a prototype graphical tool and used it to investigate changesets submitted for review inbing and office at microsoft.
our quantitative evaluation showsthat over of changes submitted for review at microsoft canbe potentially decomposed into multiple partitions indicating ahigh potential for use.
we also characterized and quantified thenature of suggested partitions across changesets and have performed a careful manual investigation of over reviews with an eye towards i spurious relationships for changesets with fewer than non trivial partitions section iii b and ii missing relationships for changesets with or more trivial partitions.
we then conducted a qualitative user study with twenty developers where we found that most developers agree with our automatic partitioning and believe the decomposition is useful for reviewers to understand their changes better someeven asked for the prototype to use on their own reviews going forward .
finally we discuss limitations of our algorithm and our implementation and describe how c luster changes can be integrated into the code review process.
ii.
t heproblem developers submit code to be reviewed on a daily basis.
although good development practices prescribe that developers perform small and cohesive commits they often containlarge and independent changes.
code review is dependent on understanding the change being made.
while large commits make review difficult there is more to read and try tounderstand the presence of multiple independent changes make matters worse.
developers are forced to read and make sense of more code than they would need to if the independentchanges were examined separately.
in this section we triangulate different sources of information to show the existence of thisproblem and to motivate our work.
a concrete example here is an arbitrarily chosen commit made to the roslyn project on august .
it contains edits to eight files and the addition of one file.
the commit message says fix by adding inmethod binders in betweenproperties and indexers.
also refactors expression2015 ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee icse florence italy fig.
.
example change from a real changeset.
the white lines are unchanged lines.
the green lines are added lines.
there are no deleted lines those would be shown highlighted in red.
bodied member semantic model tests into their own file and adds some extra tests.
refers to a bug report that had been made a few weeks prior.
part of the relevant change is shown in figure .
of particular interest for our work is that line adds a call to a method which is introduced in another file included in the changeset whereas the method call added on line is to the method introduced on line and so is easily found and understood.
c luster changes does indeed decompose the commit into two independent partitions one of which contains the two relevant files for the bug fix.
b literature prior literature has found that large changes are problematic to examine .
for instance rigby et al.
found that in order to facilitate review activity changes should be small and independent.
for example changes that combine refactorings with bug fixes can be difficult to review together especially if the reviewer doesn t know that there are multiple things going on in the change.
rigby et al.
raised the needto enable a divide and conquer review style that keeps each change logically and functionally independent.
in a later study rigby et al.
analyzed change size number of added and deleted lines and number of changed files and its relationship to several complexity metrics for changes submitted for peer review in open source projects.
they found that the more files changed and differences produced in a submitted change the more likely the change actually consisted of multiple relatively independent changes that might affect diverse sections of a system.
as a consequence developers experience more difficulty when trying to understand large code changes.
herzig and zeller found that a non trivial proportion of changes in five open source projects are tangled meaning that they contain more than one bug fix feature refactoring etc.
while their study was on the impact of such changes on research in mining software repositories they provide evidence that changes do exist which can in some way be decomposed.
theypoint out and we agree that there may be a completely valid reason that a developer commits multiple changes that appear unrelated as one change.
one of our study participants indicatedthat the overhead to run regression tests after each commit often leads to a developer combining multiple changes in a commit.
files changed methods changed diff regionsboxplots of change sizes fig.
.
boxplots showing distributions of the size of changes in terms of the number of files and methods changed as well as the number of diff regions.
our goal is not to force developers to commit independent changes separately but rather to identify independent parts of changes to facilitate understanding.
tao et al.
conducted a large scale study of how developers examine and understand code changes with one of their main goals being to determine how to improve the effectiveness andefficiency of the practice in understanding code changes.
they observed that engineers sometimes mix multiple bug fixing changes or changes with other purposes in a single checkin.
understanding composite changes requires non trivial efforts.
one of their main conclusions is that participants call for a tool that can automatically decompose a composite change into separate sub changes.
and point out that however currently such decomposition lacks tool support.
as one ofthe developers in their study indicated it would be useful to be able to analyze groups of functional changes instead of having to go file by file and context switch between changes.
i want to be able to see all the changes that related to one bug or possibly one variable within the changelist .
c discussions with developers we were also motivated by data gathered from our previous empirical study on code review and follow on observations and discussions with developers.
one common theme that developers mentioned when discussing code review is how large a review is.
as one developer indicated if i get a code bomb to review with like thirty files i can either look at it now and skim it in five to tenminutes or i can save it for later and i may or may not get to it.
both aren t good.
a windows development manager indicated that one of the bottlenecks in their process was reviewingchanges made to resolve conflicts after merges from branchto another.
it is not uncommon for such changes to include upwards of files and contain many unrelated changes.
d code change size at microsoft to quantitatively investigate the change size at microsoft we conducted apreliminary analysis on code changes submitted to bereviewed within microsoft office during the office 2013development cycle.
figure shows quantitative data on the change sizes.
files changed shows a boxplot of the number of icse florence italyfiles that are added modified or deleted in changes submitted for code review.
methods changed is a count of the number of individual methods that are added modified or deleted.
we define a diff region as a contiguous sequence of added deleted or modified lines.
for example figure shows two diff regions.
the median number of changed methods and diff regions are 12and24 while over of reviews modify methods and comprise diff regions.
these numbers suggest that many changes submitted for review may be large and or difficult to understand.
some developers that we talked to during this and earlier studies indicated that it is difficult to review a change that has many regions of change scattered across the files even if there are a small number of modified files.
iii.
c luster changes a. starting point the predominant code review tool used at microsoft is codeflow .
codeflow provides access only to individual changesets these are standalone packages containing the set ofpairs of changed files.
each pair has a before file and an afterfile for added or deleted files one element of the pair may be empty .
it is important to note that analyzing changesets is quite different than analyzing the history of a source repository.in particular changesets do not provide full information we do not have the full set of project files nor the compiler options used to actually compile the code.
we use a standard textdifferencing tool on each pair of files to get a set of pairs ofdiff regions.
because our analysis applies only to c files we split diff regions that cross type and method boundaries so that no diff region crosses more than one type or method.
this corresponds to the predominant organizing units of objectoriented code.
we restricted ourselves to c because it is one of the primary programming languages used within microsoft.
it is amodern object oriented language with types primarily classes but also structs composed of members such as fields events properties and nested types.
another reason for picking c is our ability to use roslyn the new microsoft compiler with its open api.
we use roslyn to create a synthetic project comprising the after files from a changeset and the basic .netassembly