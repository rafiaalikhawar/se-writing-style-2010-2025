an empirical study on mutation statement and branch coverage fault revelation that avoids the unreliable clean program assumption thierry titcheu chekam mike papadakis yves le traon and mark harman interdisciplinary centre for security reliability and trust university of luxembourg luxembourg university college london and facebook london uk email thierry.titcheu chekam uni.lu michail.papadakis uni.lu yves.letraon uni.lu and mark.harman ucl.ac.uk abstract many studies suggest using coverage concepts such as branch coverage as the starting point of testing while others as the most prominent test quality indicator.
y et the relationship between coverage and fault revelation remains unknown yielding uncertainty and controversy.
most previous studies rely on the clean program assumption that a test suite will obtain similar coverage for both faulty and fixed clean program versions.
this assumption may appear intuitive especially for bugs that denote small semantic deviations.
however we present evidence that the clean program assumption does not always hold thereby raising a critical threat to the validity of previous results.
we then conducted a study using a robust experimental methodology that avoids this threat to validity from which our primary finding is that strong mutation testing has the highest fault revelation of four widely used criteria.
our findings also revealed that fault revelation starts to increase significantly only once relatively high levels of coverage are attained.
index t erms mutation testing test effectiveness code coverage real faults test adequacy i. i ntroduction the question of which coverage criterion best guides software testing towards fault revelation remains controversial and open .
previous research has investigated the correlation between various forms of structural coverage and fault revelation using both real and simulated faults seeded into the program under test as mutants .
determining the answer to the test coverage question is important because many software testing approaches are guided by coverage and the industry standards used by practising software engineers mandate the achievement of coverage .
nevertheless the findings of the studies hitherto reported in the literature have been inconclusive with the overall result that this important question remains unanswered.
most previous studies make an important assumption the veracity of which has not been previously investigated.
we call this assumption the clean program assumption .
the assumption is that test suites are assessed based on the coverage they achieve on clean programs which do not contain any known faults.
this practice might be problematic when using faulty versions in order to check the fault revealing potential of the test suites since test suites are assessed on each of the faulty versions and not the clean program from which and for which the coverage was measured.of course it is comparatively inexpensive and therefore attractive to experimenters to use a single test suite for the clean program rather than using separate test suites for each of the faulty versions.
however a test suite that is adequate for the clean program may be inadequate for some of the faulty versions while test suites that have been rejected as inadequate for the clean program may turn out to be adequate for some of the faulty versions.
furthermore the coverage achieved by inadequate test suites may differ between the clean version of the program and each of its faulty versions.
these differences have not previously been investigated and reported upon if they prove to be significant then that would raise a potential threat to the scientific validity of previous findings that assume the clean program assumption.
we investigated this assumption and found strong empirical evidence that it does not always hold there are statistically significant differences between the coverage measurements for clean and faulty versions of the programs we studied.
given that we found that we cannot rely on the clean program assumption we then implemented a robust methodology in which the test suite for each test adequacy criteria is recomputed for each of the faulty versions of the program under test.
we studied statement branch strong and weak mutation criteria using a set of real world faults recently made available located in lines of c code spread over four different real world systems.
we used systems with mature test suites which are augmented both by using the popular test data generation tool klee and by hand to ensure the availability of a high quality pool of test data from which to draw test suites.
unfortunately such a high quality test pool cannot yet be guaranteed using automated test data generation tools alone partly because of the inherent undecidability of the problem and partly because of the limitations of current tools .
nevertheless it is important for us to have such a high quality test pool in order to allow us to sample multiple test suites related to the faults studied and to achieve different experimentally determined levels of coverage when controlling for test suite size.
using randomised sampling from the augmented test pool we were able to generate test suites that achieve many different coverage levels thereby placing coverage level under experimental control.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
perhaps the most surprising result from our study is that we find evidence for a strong connection only between coverage attainment and fault revelation for one of the four coverage criteria strong mutation testing.
for statement branch and weak mutation testing we found that increased coverage has little or no effect on fault revelation.
this is a potentially important finding notwithstanding the threats to v alidity of generalisation discussed at the end of this paper especially given the emphasis placed on branch coverage by software tools and industrial standards.
while some previous studies have made similar claims for branch and block coverage these conclusions were subsequently contradicted .
one of the other interesting and perhaps surprising findings of our study is that the relationship between strong mutation and fault revelation exhibits a form of threshold behaviour .
that is above a certain threshold we observed a strong connection between increased coverage and increased fault revelation.
however below this threshold level the coverage achieved by a test suite is simply irrelevant to its fault revealing potential.
this threshold observation and the apparent lack of connection between fault revelation and statement branch weak mutation coverage may go some way to explaining some of the dissimilar findings from previous studies and may partially reduce the apparent controversy .
according to our results any attempt to compare inadequate test suites that fail to reach threshold coverage may be vulnerable to noise effects two studies with belowthreshold coverage may yield different findings even when the experimenters follow identical experimental procedures.
more research is needed in this important area to fully understand this fundamental aspect of software testing and we certainly do not claim to have completely answered all questions in this paper.
we do however believe our findings significantly improve our understanding of coverage criteria their relationship to each other and to fault revelation.
our primary contributions are to expose and refute the clean program assumption and to present the results of a largerscale empirical study that does not rest on this assumption.
the most important finding from this more robust empirical study is the evidence for the apparent superiority of strong mutation testing and the observation of threshold behaviour below which improved coverage has little effect on fault revelation.
ii.
t est adequacy criteria test adequacy criteria define the requirements of the testing process .
goodenough and gerhart define test criteria as predicates stating that a criteria captures what properties of a program must be exercised to constitute a thorough test i.e.
one whose successful execution implies no errors in a tested program .
as a result they guide testers in three distinct ways by pointing out the elements that should be exercised when designing tests by providing criteria for terminating testing when coverage is attained and by quantifying test suite thoroughness.although there is a large body of work that crucially relies upon test criteria there remain comparatively few studies in the literature that address questions related to actual fault revelation using real faults to reliably confirm the coverage based assessment of test thoroughness.
we therefore empirically examine the ability of criteria guided testing in uncovering faults.
we investigate four popular test criteria the main two structural criteria namely statement and branch testing and the main two fault based criteria namely weak and strong mutation testing .
a. statement and branch adequacy criteria statement testing aka statement coverage relies on the idea that we cannot be confident in our testing if we do not at least exercise execute every reachable program statement at least once.
this practice is intuitive and is widely regarded as a very minimal requirement for testing.
however programs contain many different types of elements such as predicates so faults may be exposed only under specific conditions that leave them undetected by statement adequate test suites.
therefore stronger forms of coverage have been defined .
one such widely used criteria commonly mandated in industrial testing standards is branch coverage or branch testing .
branch testing asks for a test suite that exercises every reachable branch of the control flow graph of the program.
branch testing is stronger to statement testing which only asks for a test suite that exercises every node of the graph.
b. mutation based adequacy criteria mutation testing deliberately introduces artificiallygenerated defects which are called mutants .
a test case that distinguishes the behaviour of the original program and its mutant is said to kill the mutant.
a mutant is said to be weakly killed if the state of computation immediately after the execution of the mutant differs from the corresponding state in the original program.
a mutant is strongly killed if the original program and the mutant exhibit some observable difference in their output behaviour.
strong mutation does not subsume weak mutation because of potential failed error propagation which may cause state differences to be over written by subsequent computation.
for a given set of mutants m mutation coverage entails finding a test suite that kills all mutants in m. the proportion of mutants in mkilled by a test suite tis called the mutation score of t. it denotes the degree of achievement of mutation coverage by t in the same way that the proportion of branches or statements covered by tdenotes its degree of branch or statement adequacy respectively.
previous research has demonstrated that mutation testing results in strong test suites which have been empirically observed to subsume other test adequacy criteria .
there is also empirical evidence that mutation score correlates with actual failure rates indicating that if suitable experimental care is taken then these artificially seeded faults can be used to assess the fault revealing potential of test suites.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i summary of previous studies on the rela tionship of test criteria and faults .
author s y earlargest subjectlanguage test criterion fault types summary of primary scientific findings frankl weiss pascal branch all uses real faults all uses relates with test effectiveness while branch does not.
offutt et al.
fortran c all uses mutation seeded faults both all uses and mutation are effective but mutation reveals more faults.
frankl et al.
78fortran pascalall uses mutation real faultstest effectiveness for both all uses and mutation is increasing at higher coverage levels.
mutation performs better.
frankl iakounenko c all uses branch real faultstest effectiveness increases rapidly at higher levels of coverage for both all uses and branch .
both criteria have similar test effectiveness.
briand pfahl cblock c uses p uses branchsimulationthere is no relation independent of test suite size between any of the four criteria and effectiveness andrews et al.
cblock c uses p uses branchreal faultsblock c uses p uses and branch coverage criteria correlate with test effectiveness.
namin andrews cblock c uses p uses branchseeded faultsboth test suite size and coverage influence independently the test effectiveness liet al.
javaprime path branch all uses mutationseeded faults mutation testing finds more faults than prime path branch and all uses.
papadakis malevris cmutant sampling 1st 2ndorder mutationseeded faults1storder mutation is more effective than 2ndorder and mutant sampling.
there are significantly less equivalent 2nd order mutants than 1storder ones.
ciupa et al.
eiffel random testing real faults random testing is effective and has predictable performance.
wei et al.
eiffel branch real faults branch coverage has a weak correlates with test effectiveness.
hassan andrews 800c c javamulti point stride data flow branchmutantsdef uses is strongly correlated with test effectiveness and has almost the same prediction power as branch coverage.
multi point stride provides better prediction of effectiveness than branch coverage.
gligoric et al.
java caimp dbb branch imp pcc statementmutantsthere is a correlation between coverage and test effectiveness.
branch coverage is the best measure for predicting the quality of test suites.
inozemtseva holmes javastatement branch modified conditionmutantsthere is a correlation between coverage and test effectiveness when ignoring the influence of test suite size.
this is low when test size is controlled.
just et al.
java statement mutation real faultsboth mutation and statement coverage correlate with fault detection with mutants having higher correlation.
gopinath et al.
javastatement branch block pathmutantsthere is a correlation between coverage and test effectiveness.
statement coverage predicts best the quality of test suites.
this paper cstatement branch weak strong mutationreal faultsthere is a strong connection between coverage attainment and fault revelation for strong mutation but weak for statement branch and weak mutation.
fault revelation improves significantly at higher coverage levels.
c. previous empirical studies table i summarises the characteristics and primary scientific findings of previous studies on the relationship between test criteria and fault detection.
as can be seen there are three types of studies those that use real faults seeded faults and mutants.
mutants refer to machine generated faults typically introduced using syntactic transformations while seeded faults refer to faults placed by humans.
one important concern regards the clean program assumption when using either seeded or mutant faults or both.
in principle most of the previous studies that used seeded or mutant faults assume the clean program assumption as their experiments were performed on the original clean version and not on the faulty versions.
this is based on the intuitive assumption that as artificial faults denote small syntactic changes they introduce small semantic deviations.
our work shows that this assumption does not hold in the case of real faults and thus leaves the case of artificial faults open for future research.
though previous research has shown that higher order complex mutants are generally weaker than first order simple ones and that they exhibit distinct behaviours which implies that the assumption plays an important role in the case of artificial faults.only the studies of frankl and weiss frankl et al.
frankl and iakounenko ciupa et al.
and wei et al.
do not assume the clean program assumption.
unfortunately all these studies have limited size and scope of their empirical analysis and only the work of frankl et al.
investigates mutation.
generally only three studies offutt et al.
frankl et al.
and li et al.
investigate the fault revelation question for mutation but all of them use relatively small programs and only the work of frankl et al.
uses real faults leaving open the questions about the generalisability of their findings.
the studies of andrews et al.
and just et al.
used real faults to investigate whether mutants or other criteria can form substitutes for faults when conducting test experiments.
this question differs from the fault revelation question because it does not provide any answers concerning test criteria fault revelation.
also both these studies make the clean program assumption and do not control for test suite size.
overall although the literature contains results covering a considerable number of test adequacy criteria including the most popular branch statement and mutation based criteria our current understanding of these relationships is limited and rests critically upon the clean program assumption.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iii.
r esearch questions our fist aim is to investigate the validity of the clean program assumption since much of our understanding of the relationships between test adequacy criteria rests upon the validity of this assumption.
therefore a natural first question to ask is the extent to which experiments with faults when performed on the clean fixed program versions provide results that are representative of those that would have been observed if the experiments had been performed on the faulty program versions.
hence we ask rq1 does the clean program assumption hold?
given that we did indeed find evidence to reject the clean program assumption we go on to investigate the relationship between achievement of coverage and fault revelation using a more robust experimental methodology that does not rely upon this assumption.
therefore we investigate rq2 how does the level of fault revelation vary as the degree of the coverage attained increases?
finally having rejected the clean program assumption and investigated the relationship between fault revelation for adequate and partially adequate coverage criteria we are in a position to compare the different coverage criteria to each other.
therefore we conclude by asking rq3 how do the four coverage criteria compare to each other in terms of fault revelation at varying levels of coverage?
the answers to these questions will place our overall understanding of the fault revealing potential of these four widely used coverage criteria on a firmer scientific footing because they use real world faults and do not rely on the clean program assumption.
iv .
r esearch protocol our study involves experiments on mature real world projects with complex real faults developer machinegenerated and manually written tests.
all these tests yields a pool from which we sample to experimentally select different coverage levels while controlling for test suite size number of test cases .
our experimental procedure follows the following five steps we used corebench a set of real faults that have been manually identified and isolated using version control and bug tracking systems in the previous work by b ohme and roychoudhury .
b ohme and roychoudhury with the introduction of corebench have created a publicly available set of real world bugs on which others like ourselves can experiment.
we extracted the developer tests for each of the faults in corebench.
we generated test cases covering at least partially all the faults using the state of the art dynamic symbolic execution test generation tool klee .
we manually augmented the developer and automatically generated test suites that were obtained in the previous steps.
to do so we used the bug reports of thetable ii the subject programs used in the experiments .for each of them the number of test cases tc their size in lines of code and number of considered faults are presented .
program size developer tc klee tc manual tc faults coreutils findutils grep make faults and generated additional test cases to ensure that each fault can potentially be revealed by multiple test cases from the test pool.
the combined effect of steps and is to yield an overall test pool that achieves both high quality and diversity thereby facilitating the subsequent selection step.
we perform statement branch weak and strong mutation testing using multiple subsets selected from the test pool constructed in the steps and using sampling with uniform probability.
test suites for varying degrees of coverage according to each one of the four criteria were constructed for all faulty programs one per fault in corebench in order to avoid the clean program assumption.
a. programs used to conduct our experiments it is important to use real world programs that are accompanied by relatively good and mature test suites.
thus we selected the programs composing the corebench benchmark make grep findutils and coreutils .
their standardized program interfaces were helpful in our augmentation of the developers initial test suites using automated test data generation.
furthermore the available bug reports for these programs were helpful to us in the laborious manual task of generating additional test cases.
table ii records details regarding our test subjects.
the size of these programs range from kloc to 83kloc and all are accompanied by developer test suites composed of numerous test cases ranging from to test cases .
all of the subjects are gnu programs included in gnu operating systems and typically invoked from the command line through piped commands .
grep is a tool that processes regular expressions which are used for text matching and searching.
the make program automates the source code building process.
findutils and coreutils are each collections of utilities for respectively searching file directories and manipulating files and text for the unix shell.
b. corebench realistic complex faults to conduct this study we need a benchmark with real world complex faults that can be reliably used to evaluate and compare the four coverage criteria we wish to study.
unfortunately benchmarks with real errors are scarce.
corebench is a collection of systematically isolated faults carefully extracted from the source code repositories and bug reports of the projects we study.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the most commonly used benchmarks are the siemens suite and the software infrastructure repository sir but sadly neither can help us to answer our particular chosen research questions.
while the siemens suite has been widely used in previous studies the degree to which generalisation is possible remains limited because the programs are small and cannot truly be said to be representative of realworld systems.
the sir repository overcomes this limitation because it contains real world programs and is a very valuable resource.
nevertheless many of the faults collected for the sir programs are artificially seeded faults.
this repository is thus less relevant to our study because we seek to study the relationship between such artificially seeded faults and real faults as part of our set of research questions.
the corebench benchmark we chose to use was built by analysing commits which led to the isolation and validation through test cases of faults .
every fault was identified by exercising the project commits with validating test cases that reveal the faults.
thus the test cases pass on the versions before the bug introducing commit and fail after the commit.
also the test cases pass again after the fixing commit.
further details regarding the benchmark can be found in the corebench paper by b ohme and roychoudhury and also on its accompanying website1.
when conducting our analyses we also verified the faulty and fixed versions using both the developer and additionally generated either manually or automatically test cases details regarding the test suites we used can be found in section iv c .
as the faulty and fixed program versions were mined from project repositories by analysing commits they could have differences that are irrelevant to the faults we study.
thus they could potentially bias our results because they might arbitrarily elevate the number of program elements to be covered due to altered code unrelated to the fault .
to avoid this we checked and removed irrelevant code from the few cases we found using the test suites as behaviour preserving indicators we used delta debugging to minimise the differences between the faulty and fixed versions .
finally we excluded nine faults from our analysis due to technical problems.
faults with corebench identifiers and for the make program failed to compile in our environment.
also we had technical problems forming the annotations for make faults with identifiers and and thus klee could not create additional test suites for these faults.
fault of grep and of the findutils and of make took us so much execution time that we were forced to terminate their execution after days.
c. test suites used the developer test suites for all the projects we studied were composed of approximately tests in total.
as these were not always able to find the faults because in this case bugs would have been noticed before being reported the authors of corebench designed test cases that reveal them typically release corebench only one test to expose each bug .
however we not only need to expose the bugs but also to expose them multiple times in multiple different ways in order to allow our uniform test suite selection phase to benefit from a larger and more diverse pool from which to select.
therefore to further strengthen the test suites used in our study we augment them in a two phase procedure.
in the first phase we used klee with a relatively robust timeout limit of seconds per test case to perform a form of differential testing called shadow symbolic execution which generates test cases.
shadow symbolic execution generates tests that exercise the behavioural differences between two different versions of a program in our case the faulty and the fixed program versions.
we guided shadow symbolic execution by manual annotations to the subject programs that have no side effects.
unfortunately the current publicly available version of the tool klee does not yet handle calls to system directories i.e.
test cases involving system directories rendering it inapplicable to many cases of the findutils and make programs.
also due to the inherent difficulty and challenge of the test data generation problem we could not expect and did not find that klee was able to expose differences between every one of the pairs of original and faulty programs.
therefore in a second phase we manually augment the test suites using the bug reports following the process of b ohme and roychoudhury designing additional test cases that reveal and that fail to reveal the bugs.
we manually generate tests in all situations where there are either fewer than five test cases that reveal a given fault or fewer than five that cover the fault but fail to reveal it thereby ensuring that all faults have at least five revealing and five non revealing test cases.
our experiments were performed at the system level and involved mutants branches and statements.
every test exercises the entire program as invoked through the command line rather than unit testing which is less demanding but vulnerable to false positives .
as a result both automated and manual test generation were expensive.
for example the machine time that was spent on symbolic execution took approximately day on average for each studied bug.
all the test execution needed for our experiment took approximately days of computation time to complete of single threaded analysis .
following the recommendations of xuan et al.
we refactored2the test cases we used to improve the accuracy of our analysis.
this practice also helps to elevate the performance of symbolic execution .
finally each test case is essentially a test input that needs a test oracle in order to determine its corresponding output.
fortunately in our case we have a reliable and complete test oracle the output differences between the fixed and the faulty versions.
overall the coverage scores levels achieved by the whole test pool are presented in figure .
2many test cases form a composition of independent valid test cases.
we split these tests and formed multiple smaller and independent ones which preserve their semantics.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d. tools for mutation testing and coverage measurement to conduct our experiment we used several tools in additional to the shadow symbolic execution feature implemented3on top of klee .
to measure statement and branch coverage we used the gnu gcov utility.
to perform mutation we built a new tool on top of the frama c framework as existing tools are not robust and scalable enough to be applied on our subjects.
this tool supports both weak and strong mutation by encoding all the mutants as additional program branches for weak mutation testing and uses program wrappers similar to those used by shadow symbolic execution that automatically and precisely record the program outputs for strong mutation testing .
our mutation tool reduces the execution cost of strong mutation by checking for strong death only those mutants that were already weakly killed since any mutant that is not weakly killed by a test case cannot be strongly killed by definition.
we also used the recently published tce trivial compiler equivalence method to identify and remove strongly equivalent and duplicated mutants detected by tce.
we use a timeout in order to avoid the infinite loop problem a mutant may lead to an infinite loop which evidently cannot be detectable in general due to the undecidability of the halting problem.
in this way we are treating sufficient difference of execution time as an observable output for the purpose of strong mutation testing.
thus a mutant is deemed to be distinct from the original program if its execution differs by more than two times the execution of the original program.
the mutation tool includes the large and varied set of mutant operators used in previous research .
specifically we used mutants related to arithmetic relational conditional logical bitwise shift pointers and unary operators.
we also used statement deletion variable and constant replacement.
e. analyses performed on the test suites to answer our research questions we performed the following analysis procedure.
we constructed a coverage mutation matrix that records the statements and branches covered and mutants killed by each test case of the test pool.
g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 g8 g9 g10 g11 g12 g13 g14 g15 g9 g16 g9 g17 g11 g12 g18 g19 g16 g20 g14 g15 g9 g16 g9 g17 g11 g12 g21 g10 g16 g12 g22 g23 g8 g9 g16 g9 g19 g24 g19 g12 g9 g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 fig.
.
the test pool with overall coverage score values.for rq1 we select arbitrary test sets execute them in both the fixed clean and faulty versions and measure their coverage and mutation scores.
we used the wilcoxon test to compare these values.
in order to facilitate inferential statistical testing we repeat the sampling process times so that for each fault and for each coverage criterion we perform testing experiments each with a different sampled test suite.
the wilcoxon test is a non parametric test and thus it is suitable for samples having unknown distribution .
the statistical test allows us to determine whether or not the null hypothesis that there is no difference between the test coverage achieved for the clean and faulty versions of the program can be rejected.
if the null hypothesis is rejected then this provides evidence that the clean program assumption does not hold.
however statistical significance does not imply practical significance even when the assumption does not hold if the effect of assuming it is found to be always small then the pernicious effects on previous and potential future experiments may also be small.
therefore we also measured the v argha delaney effect size a12 which quantifies the size of the differences statistical effect size .
the a12effect size is simple and intuitive.
it measures the probability that values drawn from one set of data will have a different value to those drawn from another.
a12 .5suggests that the data of the two samples tend to be the same.
v alues of a12higher than .
indicate that the first dataset tends to have higher values while values of a12lower than .
indicate that the second data set tends to have higher values.
to study further the differences between the faulty and the fixed program versions we use the notion of coupling .
a fault is coupled with a mutant statement or branch if every test that kills the mutant respectively covers the statement or branch also reveals the fault.
thus if for example a statement is coupled with a fault then every test set that covers this statement will also reveal this fault.
unfortunately computing the exact coupling relations is infeasible since this would require exhaustive testing to consider every possible test set .
however should we find that a fault fremains uncoupled with all mutants statements or branches then this provides evidence that the adequacy criterion is not particularly good at uncovering f. based on the coupled faults we can provide further evidence related to the clean program assumption.
if we observe many cases were faults are coupled in one version either faulty or fixed while not in the other then we have evidence against the assumption.
to answer rq2 and rq3 we examined the relation between coverage score and fault revelation by selecting test sets of equal size number of tests .
we thus select suites of sizes .
.
.
and of the test pool composed of all developer machine and manually generated test cases .
then for every score ci in the range maximum recorded score we estimate the average fault revelation rate for all the tests that have coverage values at least ci.
this rate estimates the probability that an arbitrary ci adequate test suite detects a fault.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 g8 g9 g10 g11 g12 g13 g14 g15 g9 g16 g9 g17 g11 g12 g18 g19 g16 g20 g14 g15 g9 g16 g9 g17 g11 g12 g21 g10 g16 g12 g22 g23 g8 g9 g16 g9 g19 g24 g19 g12 g9 g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 a p values for all scores g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 g8 g9 g10 g11 g12 g13 g14 g15 g9 g16 g9 g17 g11 g12 g18 g19 g16 g20 g14 g15 g9 g16 g9 g17 g11 g12 g21 g10 g16 g12 g22 g23 g8 g9 g16 g9 g19 g24 g19 g12 g9 g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 b a12 values for all scores fig.
.
rq1 comparing the faulty with the clean fixed programs.
our results show that there is statistically significant difference between the coverage values attained in the faulty and clean programs subfigure a with effect sizes that can be significant subfigure b .
we then compare these fault revelation probabilities for different levels of minimal coverage attainment.
ideally we would like to control both test size and coverage across the whole spectrum of theoretically possible coverage levels .
however since coverage and size are dependent it proved impossible to do this i.e.
large test sizes achieve high coverage but not lower while smaller sizes achieve lower coverage but not higher.
therefore to perform our comparisons we record the highest achieved scores per fault we study.
for rq2 we compared the fault revelation of scores for arbitrary selected test suites with those of the highest and coverage attainment of same size .
for rq3 we compared the fault revelation of the criteria when reaching each level of coverage in turn.
to perform the comparisons we used three metrics a wilcoxon test to compare whether the observed differences are statistically significant the v argha delaney a12for the statistical effect size of the difference and the average fault revelation differences.
finally to further investigate rq3 we also compare the number of faults that are coupled with the studied criteria according to our test pool.
v. r esults a. rq1 clean program assumption the clean program assumption relies on the belief that the influence of faults on the program behaviour is small.
however white box adequacy criteria depend on the elements to be tested .
thus faulty and clean programs have many different test elements simply because their code differs.
unfortunately applying experiments to the clean version does not tell us what would happen on the program execution of the same test of the faulty program versions.
therefore we seek to investigate the differences in the coverage scores of test suites when applied to the clean and the faulty programs.
the results of our statistical comparison p values between the coverage scores obtained from the faulty and clean programs are depicted in figure a .
these data show that all measures differ when applied on the clean rather than the faulty program versions.these differences are significant at the .
significance level for all four criteria and for and of the cases for strong mutation weak mutation branch and statement coverage respectively.
strong mutation differences are more prevalent than those of the other criteria indicating that the clean program assumption is particularly unreliable for this coverage criterion.
the results related to the effect sizes are depicted in figure b revealing that large effect sizes occur on all four criteria.
strong mutation has larger effect sizes than the other criteria with some extreme cases having very high or low a12values.
one interesting observation from the above results is that the faults do not always have the same effect.
sometimes they decrease and sometimes they increase the coverage scores.
it is noted that the effect sizes with a12values higher than .
denote an increase of the coverage while below .
denote a decrease.
therefore the effect of the bias is not consistent and thus not necessarily predictable.
to further investigate the nature of the differences we measure the couplings between statements branches and mutants with the faults.
figure presents a v enn diagram with the number of coupled faults in the faulty and the clean versions.
we observe that and couplings represent and of the considered faults are impacted by the version differences when performing statement branch weak mutation and strong mutation testing.
we also observe that for statement branch weak and strong mutation and faults are coupled only to test criteria elements on the faulty versions while and faults only coupled on the clean versions.
interestingly in the clean versions branch coverage performs better than weak mutation couples with faults while weak mutation with while in the faulty version it performs worst couples with while weak mutation with .
these data provide further evidence that results drawn from the two programs can differ in important ways casting significant doubts on the reliability of the clean program assumption.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii the influence of coverage thresholds on fault revela tion for test suite size .
of the test pool .table entries on the left part record fault revela tion a t highest x coverage levels and on the right part the results of a comparison of the form rand randomly selected test suites v s highest x test suites achieving the highest x of coverage e.g.
for branch and highest the a12suggests tha t branch provides a higher fault revela tion in its last coverage levels in of the cases with a verage fault revela tion difference of .
.
test criterionav fault revelation rand vs. highest rand vs. highest rand vs. highest highest highest highest p value a12 av diff p value a12 av diff p value a12 av diff statement .
.
.
.21e .
.
.25e .
.
.97e .
.
branch .
.
.
.94e .
.
.24e .
.
.73e .
.
weak mutation .
.
.
.04e .
.
.25e .
.
.74e .
.
strong mutation .
.
.
.39e .
.
.20e .
.
.60e .
.
b. rq2 fault revelation at higher levels of coverage the objective of rq2 is to investigate whether test suites that reach higher levels of coverage for the same test suite size also exhibit higher levels of fault revelation.
to answer this question we selected arbitrary test suites per fault considered using uniform sampling so that they all have the same test size.
we then compare their fault revelation with that of the tests suites that achieve the highest levels of coverage.
thus we compare with test suites that lie in the top and of coverage to investigate different levels of maximal coverage attainment.
table iii records the results for the controlled test size equal to .
of the test pool which are representative of those we attained with the other sizes i.e.
.
.
and .
overall our data demonstrate that all criteria exhibit minor improvement in their fault revelation when considering the threshold of the highest all a12values are above the .
.
the results are even worse for lower coverage thresholds i.e.
when considering the highest etc.
in practical terms the fact that the fault revelation differences are small indicates that test sets having coverage values lying within the highest are those that reveal significantly more faults than arbitrary test sets of the same size.
the surprising finding is that fault revelation improves slightly when test suites achieve the top of the levels of coverage for a given test suite size for all the four criteria.
however for strong mutation we do observe more important differences when the top and the top of coverage are attained.
furthermore for strong mutation the average fault revelation rate was higher than the arbitrary test sets for the highest .
this increases to approximately and when considering the test suites that had the highest and coverage attainment.
as can also be seen from the results confining our attention to only the top and even the top levels of coverage attainable for a given test suite size produce only minor improvements in fault revelation for the other three criteria.
that is test suites with the higher and higher of coverage attainment for statement branch and weak mutation in table iii do not exhibit practical improvements on the fault revelation compared to arbitrary test suites of the same size the lowest a12is .
.
clean faulty a statement10 clean faulty b branch clean faulty c weak mutation2 clean faulty d strong mutation fig.
.
fault coupling in the faulty and clean versions.
by contrast test suites that lie within the highest and for strong mutation do achieve significantly higher fault revelation than arbitrary test suites of the same size.
for both the and thresholds the differences exhibit relatively strong effect sizes the v argha delaney effect size measures of .
and .
respectively which are noticeably lower than .
.
furthermore at the highest the p value is lowest and the effect size largest.
taken together these results provide evidence that test suites that achieve strong mutation coverage have significantly higher fault revelation potential than those that do not while the improvements for statement branch and weak mutation are small.
this result suggest that coverage should be used only as the starting point of testing and not as a test quality indicator.
finally we notice that relatively high levels of strong mutation are required top for this effect to be observed below this threshold level differences between arbitrary and partially strong mutation adequate test suites are less important.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv comparing fault revela tion for the highest coverage threshold and test suite size of .
of the test pool .
criteria comparison p val a12 av fault revelation diff strong mut vs statement .61e .
.
strong mut vs weak mut .23e .
.
strong mut vs branch .16e .
.
weak mut vs statement .65e .
.
weak mut vs branch .23e .
.
branch vs statement .37e .
.
c. rq3 fault revelation of statement branch weak and strong mutation rq2 compared arbitrary test suites with higher adequacy test suites of the same size for each coverage criterion.
this answered the within criteria question for each criterion of whether increasing coverage according to the criterion is beneficial.
however it cannot tell us anything about the differences in the faults a tester would observe between criteria a question to which we now turn.
table iv reports the differences in pairwise comparisons between the four criteria for test suites containing .
of the overall pool of test cases available the same size test suites we used to answer rq2.
results for other sizes of test suites are similar but space does not permit us to present them all here.
all the differences are statistically significant the p values are lower that the .
level except from the differences of weak mutation statement and weak mutation branch .
the results from this analysis suggest that in terms of fault revelation there are differences between statement branch and the weak mutation when compared to one another.
however these are small as measured by the pand a12values .
the results also indicate that strong mutation significantly outperforms all other criteria i.e.
weak mutation branch and statement coverage with fault revelation scores that are on average at least higher.
figure visualises these results fault revelation of the four criteria and randomly selected test suites and demonstrate the superiority of strong mutation over the other criteria.
g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 g8 g9 g10 g11 g12 g13 g14 g15 g9 g16 g9 g17 g11 g12 g18 g19 g16 g20 g14 g15 g9 g16 g9 g17 g11 g12 g21 g10 g16 g12 g22 g23 g8 g9 g16 g9 g19 g24 g19 g12 g9 g25 g16 g12 g26 g11 g24 g1 g2 g1 g1 g1 g1 g2 g3 g1 g1 g1 g2 g4 g1 g1 g1 g2 g5 g1 g1 g1 g2 g6 g1 g1 g7 g2 g1 g1 g1 fig.
.
fault revelation of the studied criteria for the highest coverage threshold and test suite size of .
of the test pool.
statement branchweak mutation strong mutation fig.
.
fault coupling between the studied criteria.
finally figure shows the faults coupled uniquely and jointly to each of the four adequacy criteria.
this provides another view of the likely behaviour of test suites that target each of these coverage criteria with respect to the realworld faults considered.
each region of the v enn diagram corresponds to an intersection of different coverage criteria and the number recorded for each region indicates the number of faults coupled by the corresponding intersection of criteria.
this allows us to investigate the faults that are uniquely coupled by each criterion and those coupled jointly by pairs triples and quadruples of criteria.
in the fault dataset we study there are faults are not coupled to any of the criteria and are coupled to all four criteria the quadruple of criteria region depicted in the centre of the v enn diagram .
it is interesting that all faults coupled by weak mutation are also coupled by strong mutation since strong mutation does not theoretically subsume weak mutation.
branch coverage theoretically subsumes statement coverage but only when of the feasible branches and of the reachable statements are covered there is no theoretical relationship between partial branch coverage and partial statement coverage.
therefore it is interesting that for our partially adequate test suites all faults are coupled with statement coverage are also coupled with branch coverage.
by contrast faults coupled to branch coverage are not to weak mutation one of which is coupled to strong mutation while weak mutation has faults coupled that are uncoupled with branch coverage.
however differences between statement branch and weak mutation are relatively small by comparison with the differences we observe between strong mutation and the other three criteria.
indeed figure provides further compelling evidence for the superiority of strong mutation testing over the other coverage criteria.
as can be seen faults are uniquely coupled to strong mutation.
that is faults are coupled to strong mutation that are not coupled to any of the other criteria showing that strong mutation uniquely couples to of faults that are coupled to any of the four criteria .
by contrast each of the other three criteria has nofaults uniquely coupled and even considering all three together only have two faults that are not coupled to strong mutation.
these faults are only coupled to branch and statement coverage.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vi.
t hrea ts to validity as in every empirical study of programs generalisation remains an open question requiring replication studies.
we used c utility programs.
programs written in other languages and with different characteristics may behave differently.
all four programs we used are well specified well tested wellmaintained and widely used open source programs with standardized program interfaces with bug reports that are publicly accessible.
our results may generalise to other wellspecified well tested well maintained and widely used open source c programs but we have little evidence to generalise beyond this.
additional work is required to replicate and extend our results but clearly any future work should either avoid the clean program assumption or first investigate its veracity for the selected pool of subjects.
another potential threat to the validity of our findings derives from the representativeness of our fault data.
we used real faults isolated by b ohme and roychoudhury and used by other researchers .
since these faults were found on well tested widely used programs we believe that they are representative of faults that are hard to find but further research is required to test this belief.
the use of automatically generated and manually augmented test suites also poses a threat to generalisability.
while we cannot guarantee the representativeness of this practice it is desirable in order to perform experiments involving multiple comparisons that use a good mix of tests that reveal and fail to reveal the faults studied.
we control for test suite size and different levels of achievement of test adequacy and perform multiple samples of test suites to cater for diversity and variability.
nevertheless we cannot claim that the test suites we used are necessarily representative of all possible test suites.
we restricted our analysis to the system level testing since the developers tests suites were also system level tests and we used a wide set of mutation operators included in most of the existing mutation testing tools as suggested by previous research .
we view this as an advantage because according to gross et al.
applying testing at the system level makes robust experimentation that reduces many false alarms raised when applying testing on the unit level while focusing on a narrower set of mutation operators would tend to increase threats to validity.
however this decision means that our results do not necessarily extend to unit level testing nor to other sets of mutation operators.
all statements branches and mutants that cannot be covered or killed by any test in our test pool are treated as infeasible or as equivalent mutants .
this is a common practice in this kind of experiment because of the inherent underlying decidability problem.
however it is also a potential limitation of our study like others.
furthermore since we observe a threshold behaviour for strong mutation it could be that similar thresholds apply to statement branch and weak mutation criteria but these thresholds lie above our ability to generate adequate test suites.there may be other threats related to the implementation of the tools our data extraction and the measurements we chose to apply that we have not considered here.
to enable exploration of these potential threats and to facilitate replication and extension of our work we make available4our tools and data.
vii.
c onclusion we present evidence that the clean program assumption does not always hold there are often statistically significant differences between coverage achieved by a test suite applied to the clean fixed program and to each of its faulty versions and the effect sizes of such differences can be large.
these differences are important as they may change the conclusions of experimental studies.
according to our data more faults are coupled with weak mutation than branch testing in the faulty programs but less in the clean ones.
this finding means that future empirical studies should either avoid the clean program assumption or at least treat it as a potential threat to the validity of their findings.
the unreliability of the clean program assumption motivated us to reconsider the relationship between four popular test adequacy criteria and their fault revelation.
we thus reported empirical results based on an experimental methodology that benefits from enhanced robustness by avoiding the clean program assumption .
in this study we provide evidence to support the claim that strong mutation testing yields high fault revelation while statement branch and weak mutation testing enjoy no such fault revealing ability.
our findings also revealed that only the highest levels of strong mutation coverage attainment have strong fault revealing potential.
an important consequence of this observation is that testers will need to have first achieved a threshold level of coverage before they can expect to receive the benefit of increasing fault revelation with further increases in coverage.
future work includes studies and experiments aiming at increasing the understanding of these fundamental aspects of software testing.
an emerging question regards the optimal use of mutants when comparing testing methods i.e.
whether methods should be applied on the original clean or on the mutant versions of the programs.
similarly the relation of specific kinds of mutants such as the subsuming and hard to kill ones with real faults and their actual contribution within the testing process form other important aspects that we plan to investigate.
acknowledgment we would like to thank marcel b ohme and abhik roychoudhury for providing us the corebench installer.
we also thank tomasz kuchta and cristian cadar for providing the implementation of the shadow symbolic execution and their support on using klee.
thierry titcheu chekam is supported by the afr phd grant of the national research fund luxembourg.
mark harmans work was part funded by the epsrc programme grant daase ep j017515 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.