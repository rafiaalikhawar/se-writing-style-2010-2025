automated transplantation and differential testing for clones tianyi zhang miryung kim university of california los angeles tianyi.zhang miryung cs.ucla.edu abstract code clones are common in software.
when applying similar edits to clones developers often find it difficult to examine the runtime behavior of clones.
the problem is exacerbated when some clones are tested while their counterparts are not.
to reuse tests for similar but not identical clones grafter transplants one clone to its counterpart by identifying variations in identifier names types and method call targets resolving compilation errors caused by such variations through code transformation and inserting stub code to transfer input data and intermediate output values for examination.
to help developers examine behavioral differences between clones grafter supports fine grained differential testing at both the test outcome level and the intermediate program state level.
in our evaluation on three open source projects grafter successfully reuses tests in of clone pairs without inducing build errors demonstrating its automated code transplantation capability.
to examine the robustness of grafter we systematically inject faults using a mutation testing tool major and detect behavioral differences induced by seeded faults.
compared with a static cloning bug finder grafter detects more mutants using the test level comparison and almost 2x more using the state level comparison.
this result indicates that grafter should effectively complement static cloning bug finders.
i. i ntroduction code reuse via copying and pasting is a common practice in software development .
prior studies show that up to of code in modern software contains code clones code similar to other code fragments elsewhere .
manually adapting clones is error prone.
chou et al.
show that a large portion of operating system bugs is introduced by manual porting mistakes between clones .
juegens et al.
find that nearly every second unintentionally inconsistent change to a clone leads to a fault .
therefore developers may want to examine and contrast runtime behavior of clones.
fischer finds that developers want to see how reused code works in terms of runtime behavior .
holmes et al.
find that developers want to leverage existing tests to validate reused code .
we also find that industrial developers rely on regression testing to check for inconsistent or missing edits on clones .
however the situation is exacerbated due to a lack of tests where some clones are tested while their counterparts are not.
in fact our study shows that in of studied clone pairs only one clone is tested by existing tests but not its counterpart to be detailed in section iv .
no existing techniques can help programmers reason about runtime behavior differences of clones especially when clones are not identical and when clones are not tested.
in the absence of test cases develop ers can only resort to static analysis techniques to examine clones but these techniques are limited to finding only pre defined types of cloning bugs such as renaming mistakes or control flow and data flow inconsistencies.
this paper presents a test reuse and differential testing framework for clones called grafter .
given a pair of clones and an existing test suite grafter helps programmers crosscheck runtime behavior by exercising the clones using the same test.
test reuse for clones is challenging because clones may appear in the middle of a method without a well defined interface i.e.
explicit input arguments and return type which also makes it hard to directly adapt test for reuse.
such intramethod clones are often found by widely used clone detectors such as deckard or ccfinder .
grafter identifies input and output parameters of a clone to expose its de facto interface and then grafts one clone in place of its counterpart to exercise the grafted clone using the same test.
similar to how organ transplantation may bring incompatibility issues between a donor and its recipient a grafted clone may not fit the context of the target program due to variations in clone content.
for example if a clone uses variables or calls methods that are not defined in the context of its counterpart simply copying a clone in place of another will lead to compilation errors.
to ensure type safety during grafting grafter performs inter procedural analysis to identify variations in referenced variables and methods.
it then adapts the grafted clone using five transplantation rules to handle the variations in referenced variables types and method calls.
finally it synthesizes stub code to propagate input data to the grafted clone and then transfers intermediate outputs back to the recipient.
grafter supports differential testing at two levels test outcomes i.e.
test level comparison and intermediate program states i.e.
state level comparison .
during differential testing grafter does not assume that all clones should behave similarly nor considers that all behavioral differences indicate bugs.
in fact a prior study on clone genealogies indicates that many syntactically similar clones are used in different contexts and have intended behavioral differences.
the purpose of differential testing ingrafter is rather to illuminate and expose behavioral differences at a fine grained level automatically and concretely by pinpointing which variables states differ in which test.
we evaluate grafter on pairs of nonidentical clones from three open source projects apache ant java apns and apache xml security.
grafter successfully grafts and ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1public class copy extends task 2private includepatternset includes 4public void setincludes string patterns ... if patterns !
null patterns.length stringtokenizer tok new stringtokenizer patterns while tok.hasmoretokens includes.addpattern tok.next string tokens stringutils.split patterns for string tok tokens includes.addpattern tok ... 20public class includepatternset 21public set string set 22public void addpattern string s set.add s ... a correctly edited clone in the copy class1public class delete extends task 2private excludepatternset excludes 4public void setexcludes string patterns ... if patterns !
null patterns.length stringtokenizer tok new stringtokenizer patterns while tok.hasmoretokens excludes.addpattern tok.next string tokens stringutils.split patterns .
for string tok tokens excludes.addpattern tok ... 20public class excludepatternset 21public set string set 22public void addpattern string s set.add s ... b inconsistenly edited clone in the delete class fig.
similar edits to update the use of stringtokenizer api to stringutils.split incopy anddelete .
test 2public void testcopy 3task copytask fileutils.createtask fileutils.copy ... 5copytask.setincludes src .java test .java 6jobhandler.fireevent copytask 7asserttrue checkfilecopied fig.
a test case for the copy class.
reuses tests in out of pairs of clones without inducing compilation errors.
successfully reusing tests in of the cases is significant because currently no techniques enable test reuse for nonidentical clones appearing in the middle of a method.
grafter inserts up to lines of stub code on average to ensure type safety during grafting indicating that code transplantation and data propagation in grafter are not trivial.
to assess its fault detection capability we systematically seed mutants as artificial faults using the major mutation framework .
we use jiang et al.
s static cloning bug finder as a baseline for comparison.
by noticing runtime behavioral discrepancies grafter is more robust at detecting injected mutants than jiang et al.
more using the test level comparison and almost 2x more using the state level comparison.
grafter s state level comparison also narrows down the number of variables to inspect to three variables on average.
therefore grafter should complement static cloning bug finders by enabling runtime behavior comparison.
our grafting technology may also have potential to assist code reuse and repair .
the rest of the paper is organized as follows.
section ii illustrates a motivating example.
section iii describes how grafter reuses tests from its counterpart clone by grafting a clone.
section iv describes the evaluation of grafter and comparison to jiang et al.
section v discusses threats to validity and section vi describes related work.ii.
m otiv a ting example this section motivates grafter using an example based on apache ant.
the change scenario is constructed by us to illustrate the difficulty of catching cloning bugs.
figure shows the pair of inconsistently edited clones one from the setincludes method in the copy class lines in figure 1a and the other from the setexcludes method in the delete class lines in figure 1b .
these clones are syntactically similar but not identical the left program uses a field includes of type includepatternset while the right program uses a field excludes of type excludepatternset .
the copy class implements the task of copying files matching the specified file pattern s .
on the other hand delete removes files that do not match the pattern s .
methods setincludes andsetexcludes both split the input string by a comma and add each pattern to a pattern set includes andexcludes respectively.
figure shows a test case testcopy which creates a copy object specifies two copied file patterns as a string src .java test .java and then checks if all java files in the src folder and the test folder are copied to a target directory.
however the delete class is not tested by any existing test.
stringtokenizer is a legacy class and its usage is now discouraged in new code.
therefore alice updates the use ofstringtokenizer api to stringutils.split in both copy anddelete in figure .
however she accidentally changes the separator from to .
indelete line in figure 1b .
such mistake is difficult to notice during manual inspection as these programs are similar but not identical.
an existing cloning bug finder by jiang et al.
would fail to find the mistake as it checks for only three pre defined cloning bug types via static analysis renaming mistakes control construct inconsistency and conditional predicate inconsistency.
accidentally replacing the separator does not belong to any of the pre defined cloning bug types.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1public class copy extends task private includepatternset includes private excludepatternset excludes public void setincludes string patterns ... this is stub code inserted for data transfer excludepatternset excludes save excludes excludes new excludepatternset excludes.set includes.set the original code is replaced with the grafted code from setexcludes if patterns !
null patterns.length string tokens stringutils.split patterns for string tok tokens includes.addpattern tok if patterns !
null patterns.length string tokens stringutils.split patterns .
for string tok tokens excludes.addpattern tok this is stub code inserted for data transfer includes.set excludes.set excludes excludes save g51 g86 g77 g75 g77 g82 g69 g80 g39 g80 g83 g82 g73 g40 g73 g80 g73 g88 g73 g72 g43 g86 g69 g74 g88 g73 g72 g39 g80 g83 g82 g73 g45 g82 g87 g73 g86 g88 g73 g72 fig.
grafter grafts the clone in delete lines in place of the original clone in copy lines for test reuse.
grafter inserts stub code highlighted in yellow .
to reuse the same test testcopy fordelete grafter grafts the clone from delete in place of the original clone incopy as shown in figure .
as the grafted code uses an undefined variable excludes grafter also ports its declaration to copy.java .grafter ensures that the grafted clone receives the same input data by populating excludes with the value of includes lines and transfers the value ofexcludes back to includes lines .
therefore the value of excludes can flow into the same assertion check of the original test.
additional stub code generated by grafter is highlighted in yellow in figure .
after grafting grafter then runs testcopy on both clones and finds that the test now fails on delete because the string is not split properly.
to help alice further diagnose failure symptoms grafter shows that tokens has a list src .java test .java incopy but src java test java indelete due to a wrong split.
grafter also shows that this difference has propagated to corresponding variables includes andexcludes .
iii.
c lone grafting and testing grafter takes a clone pair and an existing test suite as input and grafts a clone from the donor to the recipient to make the test s of the recipient executable for the donor.
adonor program is the source of grafting and a recipient program is the target of grafting.
grafter does not require input clones to be identical.
clones could be the output of an existing clone detector or be supplied by ahuman.
for example lines in setincludes and lines in setexcludes are clones found by deckard in figure .
delete.java is the donor program and copy.java is the recipient program as alice wants to reuse the test of copy.java fordelete.java .
grafter works in four phases.
grafter first analyzes variations in local variables fields and method call targets referenced by clones and their subroutines phase i .
it also matches corresponding variables at the entry and exit s of clones which is used for generating stub code and performing differential testing in later phases.
grafter ports the donor clone to replace its counterpart clone and declares undefined identifiers phase ii .
to feed the same test input into the grafted clone grafter populates the input data to newly ported variables and transfers the intermediate output of the grafted clone back to the test for examination phase iii .
finally it runs the same test on both clones and compares test outcomes and the intermediate states of corresponding variables at the exit s of clones.
we use figure as a running example throughout this section.
a. v ariation identification the goal of phase i is to identify mappings between method call targets local variables and fields at the entry and exit s of each clone.
grafter leverages inter procedural analysis to find identifiers referenced by each clone and its subroutines.
it then determines which referenced identifiers are defined in the donor but not in the recipient.
there are three goals with respect to finding variable mappings at the entry and exit s of each clone.
first we need to identify variables used by the donor clone but not defined in the recipient clone so grafter can port their declarations in phase ii to ensure type safety and avoid compilation errors.
second we need to decide the data flowing in and out of the clone at the entry and exit s so we can insert stub code to populate values between corresponding variables in phase iii.
third we compare the states of corresponding variables at clone exit s for fine grained differential testing in phase iv .
these goals are achieved by capturing the consumed variables at the entry of the clone region and the affected variables at the exit s of the clone region in the control flow graph.
a variable is consumed by a clone if it is used but not defined within the clone.
a variable is affected by a clone if its value could be potentially updated by the clone.
the consumed variables are associated with the data flowing into the clone and the affected variables are associated with the updated data flowing out of the clone.
grafter performs a combination of def use analysis and scope analysis to identify consumed and affected variables.
given a clone fand its container method mand class c consumed variables at the clone s entry can be approximated consumed f m c def c def m def f use f similarly given a clone f affected variables at an exit point pcan be approximated as following authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm heuristics for transfering variable values input let v1andv2be a pair of mapped variables.
in this algorithm each variable symbol is an abstraction containing the name type and field information which guides the generation of stub code.
output let code be the stub code to tranfer the value of v1tov2.
it starts with an empty string and ends with a sequence of statements generated using a few heuristics.
algorithm transfer v1 v2 code ifv1.name v2.name then return ifv1.type v2.type or v1.type is castable to v2.type then return v2.name v1.name ifv1.type structurally equivalent to v2.type then code v2.name new v2.type match stablematching v1.fields v2.fields foreach fi fjinmatch do code transfer fi fj return code procedure stablematching s1 s2 match unmatch s2 while unmatch is not empty do f2 next field in unmatch foreach f1ins1do iff1.type f2.type or f .type is castable to f .type or f .type is structurally equivalent to f .type then iff1 match.keys then f prime match.get f d1 levenshteindistance f1.name f .name d2 levenshteindistance f1.name f prime .name ifd1 d2then match.put f f2 unmatch.add f prime else match.put f f2 return match excludepatternset object in line in figure .
expression type variation.
the data type of an expression can be different based on the variables operators and method targets used in the expression.
such variation can cause type incompatibility in the returned object if it appears in thereturn statement.
grafter first decomposes the return statement return x into two statements one storing the expression value to a temporary variable type temp x and the other returning the temporary value return temp .
grafter applies the v ariable type v ariation rule above on temp to convert its type to a compatible type in the recipient.
recursion.
if both container methods in the donor and recipient have recursive calls in the clone region grafter updates the recursive call targets in the grafted clone.
c. data propagation in medicine surgeons reattach blood vessels to ensure the blood in the recipient flows correctly to the vessels of the transplanted organ.
similarly grafter adds stub code to ensure that newly declared variables consume the same input data as their counterparts in the recipient and the updated values flow back to the same test oracle.
given each mapped variable pair v1andv2in phase ii grafter generates stub code to propagate the value of v2 tov1at the entry of the clone and to transfer the updated value of v1back to v2at the exit.
in algorithm the main function transfer takes two variables v1andv2as input and produces a sequence of program statements for datapropagation.
the symbols v1andv2in algorithm abstract their variable name type and field information.
heuristic a. given two variables v1andv2with the same name and type there is no need to propagate the value from v1tov2.
in figure both clones use the method parameter patterns and the