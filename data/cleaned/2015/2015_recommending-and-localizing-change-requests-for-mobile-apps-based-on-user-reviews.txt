recommending and localizing change requests for mobile apps based on user reviews fabio palomba1 pasquale salza2 adelina ciurumelea3 sebastiano panichella3 harald gall3 filomena ferrucci2 andrea de lucia2 1delft university of technology the netherlands 2university of salerno italy 3university of zurich switzerland abstract researchers have proposed several approaches to extract information from user reviews useful for maintaining and evolving mobile apps.
however most of them just perform automatic classification of user reviews according to specific keywords e.g.
bugs features .
moreover they do not provide any support for linking user feedback to the source code components to be changed thus requiring a manual time consuming and error prone task.
in this paper we introduce c hange advisor a novel approach that analyzes the structure semantics and sentiments of sentences contained in user reviews to extract useful user feedback from maintenance perspectives and recommend to developers changes to software artifacts.
it relies on natural language processing and clustering algorithms to group user reviews around similar user needs and suggestions for change.
then it involves textual based heuristics to determine the code artifacts that need to be maintained according to the recommended software changes.
the quantitative and qualitative studies carried out on user reviews of open source mobile apps and their original developers showed a high accuracy of c hange advisor in i clustering similar user change requests and ii identifying the code components impacted by the suggested changes.
moreover the obtained results show that change advisor is more accurate than a baseline approach for linking user feedback clusters to the source code in terms of both precision and recall .
index t erms mobile apps mining user reviews natural language processing impact analysis i. i ntroduction nowadays the development and the release planning activities moved from a traditional paradigm in which software systems are released following a clearly defined road map towards a paradigm in which continuous releases become available for an upgrade every week .
it is particularly true in the case of mobile apps where developers manage updates i.e.
new features enhancements or bug fixes through online app stores such as google play store apple store and windows phone app store .
this kind of distribution is accompanied by mechanisms which allow end users to evaluate releases by using scores usually expressed as five stars values and user reviews.
these reviews are free text that may informally contain relevant information for the development team such as bugs or issues that need to be fixed summaries of the user experience with certain features requests for enhancements ideas for new features and comparison with other apps.
thus not only do user reviews represent the simplest and fastest way end users have to express their opinions or report their suggestions but also a powerful crowd feedbackmechanisms that can be used by developers as a backlog for the development process aiming to improve the success distribution of their apps .
the main problem for developers is that existing app distribution platforms provide limited support to systematically filter classify and aggregate user feedback to derive requirements .
moreover manually reading each user review to gather the useful ones is not feasible considering that popular apps e.g.
facebook receive hundreds of reviews every day .
to address the problem and reducing the manual effort in the recent past the research community has proposed approaches to select the useful feedback from user reviews essentially consisting of performing only an automatic classification of the review content according to specific keywords without considering sentence structures and semantics.
moreover the information that can be gathered is restricted to user reviews and there not exists any systematic way for linking user feedback to the related source code components to change a task that requires an enormous manual effort and is highly error prone.
to better illustrate the problem statement let us consider the following scenario.
john is a mobile developer of the frostwire app an open source bittorrent client for android a quite popular app on google play store.
john frequently checks the numerous user reviews the app receives on a daily basis.
not only do they contain compliments but also some informative feedback such as bug reports or feature requests.
he needs to read reviews carefully and carry out a timeconsuming activity of analysis and synthesis in order to identify and collect possible suggestions for improvement.
once john detects an informative feedback he has to locate the source code components related to the requested changes.
this is not always easy even if he is the main developer of the application.
indeed user reviews are usually informal text written by nontechnical users therefore poorly understandable and or not containing enough information to match the corresponding source code components correctly.
for instance john finds a user review verbatim reporting i can t download most off the songs.
.
besides the spelling mistakes john realizes that the user is complaining about download problems but he is not sure that this is an actual bug or maybe the user is not able to use his app correctly.
thus he skips the review and continues to read the other ones.
afterward he finds other negative user reviews mentioning and detailing the same problem as the one above.
as an example a user claims that he is not able ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ive known frostwire to be a great app now its super slow at donwloading songs pls fix this problem i can t download most off the songs.
pls someone fix the app it won t download or show any results anymore worked amazing in the beginninglibraryutils transfersfragment searchprogressviewmagnetdownloader figure c hange advisor motivating example.
to download songs through magnet links.
at this point john understands that this is a real bug by reading the collection of these user reviews and identifies a possible solution.
as an alternative john might have used existing tools.
for instance he might have exploited surf to summarize reviews or urr and clap to prioritize groups of reviews.
nevertheless he would not be able to i extract only the useful information hidden behind different user reviews ii group together fine grained information iii understand the actual impact of each change request.
to overcome these limitations in this paper we introduce change advisor a novel approach that facilitates the analysis of the enormous amount of user reviews developers receive on a daily basis by automatically i extracting user feedback relevant from a maintenance perspective ii clustering them based on similar user needs and iii identifying the set of source code components that need to be changed to accommodate the user requests.
by using our approach the work done by john in the previous scenario would have been drastically reduced.
indeed john can download the list of user reviews from the developer console of google play store and give them as input to change advisor together with the source code of his app.
following the steps described in section iii our approach extracts only user feedback useful from a maintenance perspective and groups entries together into clusters representing similar user needs.
then c hange advisor locates the specific source code components that would likely have to be changed.
figure depicts the way c hange advisor supports the specific task of john .
in particular the user feedback is extracted and clustered in a group of sentences which describe a i slow download performance and ii the inability in showing the transfer results.
then c hange advisor links the grouped user feedback into four classes i.e.
transfersfragment searchprogressview magnetdownloader and libraryutils .
the transfersfragment class is responsible for the visualization of the downloads that are being transferred and a progress bar implemented by the searchprogressview class shows the status of the searches initialized by the user using a magnet link.
john discovers a connection delay bug in the libraryutilsclass which is used by the magnetdownloader class responsible for the download of torrents related to magnet links.
given the output of c hange advisor john is now able to solve the issue because he immediately identifies the problem experienced by users and receives suggestions about which source code components need to be modified.
in this paper we empirically evaluated the performances of c hange advisor by using user reviews and the source code of open source mobile apps.
as a preliminary analysis we quantified the c hange advisor ability to cluster user feedback toward similar change requests finding that our approach is able to identify cohesive user feedback clusters.
then we evaluated c hange advisor capabilities in identifying the code components impacted by the suggested changes comparing our technique with a baseline implementation of the tool proposed by saha et al.
in the context of bug localization.
we observed that our approach is able to achieve ofprecision and70 ofrecall being more precise and38 more complete than the baseline technique.
finally we qualitatively evaluated c hange advisor by surveying the10 original developers of the apps in our dataset who confirmed the actual usefulness of the approach in practice.
the prototypical implementation of c hange advisor as well as the material and working data sets used in our study are publicly available .
structure of the paper.
section ii discusses the related literature while section iii presents the proposed approach.
in section iv we describe the case study conducted to evaluate the proposed approach.
the qualitative case study involving the original developers is reported in section v whereas section vi concludes the paper.
ii.
r ela ted work in the following we summarize the main relevant research in the context of mining user reviews of mobile apps and linking informal textual information to the source code.
the interested reader can find a comprehensive literature review in the work by martin et al.
.
a. mining user reviews harman et al.
introduced the concept of app store mining by identifying correlations between the customer ratings and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the download rank of a mobile app.
iacob and harrison empirically assessed the extent to which users of mobile apps rely on reviews to describe change requests discovering that a noticeable percentage of user reviews describe feature requests.
moreover pagano and malej found that of the user reviews are related to requirements and user experience and that developers use the feedback provided by the users to gather requirements.
these papers motivated our work since they clearly indicate that users actually exploit the review mechanism in order to suggest improvements to apply to the current version of an app.
chen et al.
devised ar m iner an approach to filtering and ranking informative reviews using a semi supervised learning based approach.
they demonstrated that on average of reviews contain informative content.
khalid et al.
reported a study with user reviews aimed at qualitatively classifying them into types of complaints.
the results suggest that more than of the complaints are related to problems that developers can solve.
such results highlight the importance to have tools supporting developers in evolutionary tasks in the same way as the one proposed in this paper.
guzman et al.
proposed an automatic approach to assigning a score to reviews indicating the user sentiment.
di sorbo et al.
devised surf a tool to summarize user reviews to gather new requirements.
panichella et al.
proposed ar doc an approach that combines natural language processing sentiment analysis and text analysis techniques through a machine learning ml algorithm to detect sentences in user reviews.
c hange advisor relies on ar doc to classify user reviews as change requests e.g.
fix a bug or add a new feature .
villarroel et al.
devised clap an approach to classifying clustering and then prioritizing user reviews on the basis of the information they contain i.e.
suggestions for new features or bug reporting .
unlike our work this approach takes into account entire user reviews rather than the more fine grained information given by user feedback and has as a final goal of prioritizing user reviews rather than locate change requests.
finally gu and kim defined an approach able to summarize sentiments and opinions and classify them in aspect evaluation bug reports feature requests praise and others.
the approaches mentioned above perform an automatic classification of user reviews according to predefined topics e.g.
bugs features .
moreover they do not provide any support for linking user feedback to the source code components to be changed.
b. linking informal t extual documentation to the source code traceability between textual artifacts e.g.
requirements and the source code was widely studied in the past see e.g.
.
similarly several approaches to locating features in the source code and tracing informal textual documentation such as e mails forum discussions and bug reports to the source code have been proposed.
in this context three works are closer to the one we proposed in this paper.
firstly saha et al.
proposed the use of structured information retrieval based on code constructs i.e.class and method names to improve bug localization.
their approach named blu ir exploits the v ector space model to link bug reports to the source code.
in section iv we report the detailed comparison between blu ir and our approach.
secondly asuncion et al.
devised trase an approach that uses lda based topic modeling to enhance the information provided by prospective traceability.
since there is no way to know a priori the number of latent topics the authors configured the parameter of the lda algorithm i.e.
the number of topics using different settings namely and .
however as previously demonstrated by panichella et al.
the configuration used to set the clustering algorithm is an important component of topic modeling techniques and an optimal choice of the parameters generally results in better performance.
this is especially true in cases where there are no hints about the right number of clusters to create as for user reviews .
moreover the technique exploited by trase to retrieve links toward the source code requires additional information by developers about the part of the project that needs to be modified which is not required by our approach.
finally palomba et al.
proposed crist al a tool for tracing informative crowdsourced reviews to the source code commits and for monitoring the extent to which developers accommodate user requests and follow up user reactions as reflected in their ratings.
unlike crist al the intent of change advisor is to recommend the location of code changes on the current version of an app rather than monitor the changes already applied during the history of a project.
iii.
t he change advisor approach the goal of the proposed approach is to extract from user reviews feedback relevant from a maintenance perspective and suggest the location of such changes in the source code.
to this aim it applies the following steps user feedback identification and classification i.e.
bug fixing tasks features enhancement and new features requests source code and user feedback preprocessing user feedback clustering representing similar user needs i.e.
code change requests determining the code artifacts related to the suggested software changes.
a. user feedback classification during the first step c hange advisor extracts and classifies the informative sentences i.e.
the feedback contained in the user reviews.
to achieve this goal it employs ar doc areview classifier previously defined by panichella et al.
which is able to automatically mine feedback in user reviews.
specifically ar doc combines natural language processing nlp sentiment analysis sa and text analysis t a techniques through a machine learning ml algorithm to detect the user feedback that belongs to one of the following categories information giving information seeking feature request and problem discovery .
we relied on the original authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
implementation of the tool publicly available as a java library .
we used this tool to classify and filter feedback in user reviews categorized as i request to fix bugs sentences of the ar doc category problem discovery and ii feature enhancements or feature requests feature request category .
note that we filtered out feedback in user reviews categorized asinformation giving and information seeking since they are not strictly related to change requests in the source code of an app.
as an example a review reporting it s an awesome app!
is classified as information giving and does not provide any useful information from a maintenance perspective.
b. input preprocessing in this step c hange advisor preprocesses both the user feedback extracted from the original reviews and the source code components in order to remove noise contained in the data that may hinder the accuracy of the nlp techniques exploited in further steps.
source code preprocessing the source code is first parsed to extract the code components it contains such as fields classes and methods.
the extracted code components are then normalized using a typical information retrieval ir normalization process .
in particular the terms contained in the source code are transformed by applying the following steps i separating composed identifiers using the camel case splitting which separates words on underscores capital letters and numerical digits base ii reducing letters of extracted words to lower case iii removing special characters programming keywords and common english stop words iv stemming words to their original roots via porter s stemmer .
finally the normalized words are weighted using the term frequency inverse document frequency tf idf schema which reduces the relevance of too generic words that are contained in several source code components.
this step outputs a set of bag of words one for each class of the analyzed app.
user feedback preprocessing the challenge of this step is finding a methodology that is able to parse correctly all the words contained in a user feedback because the language used by the end users of an application is generally informal very noisy and substantially different from the sectorial language used in software artifacts .
for this reason we defined a specialized ir process to transform the end user language into input suitable for textual analysis using the python libraries nltk and t ext blob two collections of tools for natural language processing nlp and the spell check p yenchant library .
the involved nlp steps are spelling correction the words of user feedback are replaced if misspelled according to the english vocabulary of p yenchant library.
contractions expansion it substitutes any possible english contractions with the related extended form e.g.
don t becomes do not .
nouns and verbs filtering the process is performed by first applying a part of speech pos tagging classification which identifies the logic role of words in user feedback sentences.then only the nouns and verbs are selected for the following steps because they are the most representative parts of the meaning of an artifact .
tokenization user feedback is transformed into lists of words i.e.
tokens which will be the atomic part of the next steps excluding numbers and punctuation that usually do not contain information.
singularization the singularization function of the t ext blob library is exploited to normalize every word to its related singular form.
stopword removal the tokens are intersected with the wordnet english stopword list which is a list of common words that are frequent in written english e.g.
the a and an and only introduce noise to nlp activities.
stemming the inflected words are reduced to their stem form e.g.
pushing is replaced with push .
this step reduces the number of tokens and thus the complexity of the nlp work.
repetitions removal for each document only one occurrence per word is preserved.
we perform this step since in this context it is unlikely to have more occurrences of a word.
therefore the contribution provided by having repetitions of the same word is not useful for the nlp activities.
short tokens removal this step excludes tokens with less than 3characters such threshold is a standard applied in nlp because tokens having a low number of characters are usually conjunctions or generic terms used in informal context and irrelevant for our purposes .
short documents removal documents with less than 3tokens are also excluded from the output because short documents i.e.
user feedback do not have enough terms to explain a change request clearly.
as the final result the process outputs a bag of words for each user feedback that will be the input of the subsequent clustering phase.
c. user feedback clustering the goal of this step is to group together automatically user feedback expressing similar user needs consisting of similar code change requests e.g.
a problem in the gui and or performance and energy consumption problems .
it is worth noting that this step is required since linking single user reviews to source code components does not provide high precision values as highlighted by the preliminary analysis reported in our online appendix .
moreover this phase allows grouping together common user change requests making them more comprehensible for the developer.
many effective clustering algorithms accept text objects as input.
we experimented three different clustering techniques such as the latent dirichlet allocation lda exploited by asuncion et al.
the application of genetic algorithms to lda lda ga devised by panichella et al.
and the hierarchical dirichlet process hdp algorithm proposed by teh et al.
.
the first technique is the classical implementation of the lda algorithm which requires the specification of the parameter beforehand namely the number of clusters topics to create starting from the set of sentences to group together in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
our case the user feedback extracted from the user review .
the lda ga technique is an evolution of the lda algorithm able to find an optimal configuration of the parameter during their execution by relying on genetic algorithms.
finally hdp is an extension of the lda algorithm where the number of topics is not known a priori.
in hdp and lda models each document in the corpus collection is considered as a mixture of latent topics with each topic being a multinomial distribution over a known vocabulary of words.
to cluster related feedback hdp implements a nonparametric bayesian approach which iteratively groups elements based on a probability distribution i.e.
the dirichlet process .
we benchmarked the three techniques concerning the quality of solutions and execution time.
we decided to integrate hdp in c hange advisor because it provides a good trade off between quality and execution time.
a detailed analysis of the comparison between the techniques is reported in our online appendix .
d. recommending source code changes once the user feedback clusters are formed grouping together similar change requests they are subjected to a process of linking to source code components to suggest what is the set of classes to update in order to meet these requests.
we linked the user feedback clusters to source code classes by measuring the asymmetric dice similarity coefficient defined as follows sim cluster j class i vextendsingle vextendsinglewcluster j wclass i vextendsingle vextendsingle min parenleftbig vextendsingle vextendsinglewcluster j vextendsingle vextendsingle wclass i parenrightbig where wcluster jis the set of words contained in the cluster j wclass iis the set of words contained in class iand the min function normalizes the similarity score with respect to the number of words contained in the shortest document i.e.
the one containing fewer words between the cluster and the class under analysis.
the asymmetric dice similarity ranges between .
we used the asymmetric dice coefficient instead of other similarity measures e.g.
the jaccard coefficient because often the user feedback clusters are notably shorter than the source code files and therefore considering the minimum cardinality of the sets of words at the denominator of the formula allows to weight the similarity between documents better.
the output is represented by a ranked list where the links having the highest similarity values are reported at the top.
pairs of cluster component having a dice similarity coefficient higher than a threshold are considered by c hange advisor to be a link .
we experimented different values for this threshold and the best results were achieved when considering the third quartile of the distribution of the dice similarity coefficients obtained for a given application detailed results of the calibration are in our online appendix .
however the developers may want to order the list based on other criteria such as the popularity of a change request expressed by the cluster size.
in future we plan to integrate into change advisor a prioritization approach that takes intotable i characteristics of the apps in the dataset.
app kloc classes reviews feedback acdisplay cool reader fb reader focal frostw ire k mail shortyz crosswords sms backup solitaire wordpress overall account both change requests popularity and the similarity values with the source code.
iv .
s tudy i t he accuracy of change advisor the goal of the study is to evaluate the effectiveness of change advisor in retrieving links between user feedback clusters and source code.
thus the quality focus is on the accuracy of the proposed approach in suggesting source code changes based on user feedback.
the context of the study consists of android open source apps whose source code is hosted on the f droid open source repository and also published on the google play store .
for each app considered in our dataset table i shows i the application name ii the size of the app in terms of kloc and number of classes iii the number of user reviews and iv the number of user feedback entries extracted for the considered user reviews.
the selected apps belong to different categories have different sizes and reviews written by users with different requirements and expectations.
a. empirical study definition and design the study aims at answering the following research questions rq1 does change advisor identify cohesive user feedback clusters representing related change requests?
rq2 does change advisor correctly link change requests represented by user feedback clusters to code artifacts that need to be modified and how well it works compared to a state of the art technique relating informal textual documentation to source code?
to address our research questions we firstly ran c hange advisor against the apps in our dataset.
in a normal scenario of using c hange advisor the developer owns both the user reviews by downloading them as csv file from the app distribution platform and the source code needed as input.
in our case we first had to retrieve the reviews related to the chosen apps.
to this aim we developed a web scraper that extracts the user reviews directly from the google play store where they are publicly available.
for the source code we downloaded the last version of the considered apps from the corresponding repositories e.g.
github and we used a java parser to extract single components see section iii b .
before focusing on the performance of the proposed approach in suggesting source code changes addressed by authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rq2 with rq1we wanted to ensure that the clusters created by c hange advisor using hdp are cohesive and thus meaningful.
to this aim we involved as inspectors external mobile developers having 5years of experience.
the participants were asked to evaluate the cohesiveness of the clusters generated by c hange advisor for each app in our study.
to avoid bias the inspectors were not aware of the experimental goals and of the specific algorithm used by the approach to cluster user feedback.
to express their opinion the participants used a likert scale intensity from very low tovery high values i.e.
giving a value between 1and5 where 1means very low while 5very high .
this process required approximately 3weeks of work.
inrq2our goal was to evaluate c hange advisor accuracy in linking user feedback clusters to the source code.
however as pointed out in section ii several approaches able to link informal textual documentation to the source code have been proposed in the literature to solve other software engineering tasks e.g.
bug localization .
therefore rather than simply evaluating the performance of c hange advisor w ea r e also interested in understanding whether the definition of our approach is actually needed or similar performance can be achieved by using existing state of the art techniques when used to link user feedback to the source code.
to this aim we used a baseline approach inspired to blu ir the technique proposed by saha et al.
for linking bug reports to the source code using an information retrieval infrastructure.
note that bug reports may be affected by the same noise e.g.
errors different language compared to the source code programming language of user reviews.
we chose this approach as the baseline because it tries to solve a similar problem as c hange advisor .a s discussed in section iii c linking single user reviews to source code components does not provide good results.
hence to conduct a fair comparison blu ir links each of the user feedback cluster produced using hdp to the source code by computing the cosine similarity between the vectors of terms built through the application of the v ector space model .
the baseline reports a link if the similarity between a cluster and a class is .
.
to compare the two approaches we needed a set reporting the actual links between user feedback contained in the clusters and the source code.
due to the absence of this data set we had to build our own oracle manually.
we asked the mobile developers previously involved in the evaluation of the cohesiveness of user feedback clusters to analyze the change requests contained in the clusters of reviews and determine the software artifacts that need to be maintained for performing such changes.
in this case as well the participants were not aware of the details of the study.
we provided the participants with both the source code of the considered apps and the clusters generated by hdp .
the task consisted of analyzing each user feedback cluster in order to find the set of classes that need to be modified according to the requests reported in the cluster.
each inspector performed the task independently.
once completed the task the two different sets of links were compared and the inspectors discussed the differences theytable ii evaluation provided by the inspectors about the cohesiveness of the clusters generated by c hange advisor .
app clusterscohesiveness min median max acdisplay cool reader .
fb reader focal frostw ire k mail .
shortyz crosswords sms backup .
solitaire wordpress overall found e.g.
links marked as correct by one inspector but not by the other in order to resolve the disagreement and reach a common decision.
finally we considered as golden set all the links declared as correct by both the two inspectors after the discussion.
to measure the level of agreement between the inspectors we computed the jaccard similarity coefficient i.e.
the number of traceability links identified by both the inspectors over the union of all the links identified by them.
the overall agreement between the inspectors was of .
a spreadsheet reporting the data about the agreement computation is available in our replication package .
this process required approximately 5weeks of work.
once defined the oracle we answered rq2by reporting precision and recall achieved by c hange advisor and by the baseline.
replication package.
change advisor is publicly available in the online appendix together with the dataset used in the study.
the prototype is a runnable d ocker container which allows not only the replication of the experiment but also the application of the approach to any given app data i.e.
reviews and source code .
b. analysis of the results in the following we discuss the results of the study.
evaluating the cohesiveness of user feedback clusters table ii reports the minimum median and maximum of the scores assigned by the inspector during the evaluation of the clusters generated by c hange advisor .
as we can see our approach identified a minimum of and a maximum of user feedback clusters for a total of clusters on the apps.
all the data related to clusters and their validation are available in our online appendix .
from a qualitative perspective the cohesiveness of clusters produced was generally evaluated by the inspectors as high orvery high i.e.
4and5values of the likert scale respectively .
indeed the median of the distribution is while the values are mainly placed between 4and5.
this result highlights the ability of change advisor to group together correctly similar changes.
nevertheless there is one specific case for the sms backup app where the clustering phase did not provide the expected results.
this app offers the possibility to backup sms mms and calls log entries by providing space in the cloud.
users authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii comparison between c hange advisor and the baseline approach in linking change request feedback.
appchange advisor baseline precision recall precision recall acdisplay cool reader fb reader focal frostw ire k mail shortyz crosswords sms backup solitaire wordpress overall often complain of energy consumption problems or the lack of compatibility with previous versions of the android operating system i.e.
android kitkat .
.
manually analyzing the clusters created by c hange advisor for this application we discovered that the cluster which obtained the lowest score included user requests related to both these problems.
thus the presence of co occurrence of terms in the two different change requests generated some noise that did not allow the correct clustering of the corresponding user feedback.
in summary.
change advisor correctly clusters user feedback expressing similar change requests.
an exception occurred because of the co occurrence of terms expressing different change requests reported in the same user feedback.
evaluating the linking accuracy table iii reports the precision and the recall achieved by c hange advisor and by the baseline approach for each of the considered apps when retrieving links between user feedback clusters and source code elements.
the last row i.e.
overall shows the results achieved when considering all the links suggested by the two approaches as a single dataset.
as we can see the results achieved by c hange advisor are quite positive since it is able to discover correctly overall of the links between user feedback clusters and classes i.e.
traceability links out of the total .
at the same time the suggestions provided by c hange advisor are quite close to the actual classes that need to be modified to implement a change request.
indeed the recall ranges between and overall is .
the lowest precision of c hange advisor is achieved on the sms backup app where the proposed approach outputs 5false positive links.
a possible cause behind this result can be related to an incorrect cluster of user requests for this app as observed before.
besides the mentioned clustering issue by manually investigating the links suggested by c hange advisor we discovered two other reasons for this result i poor cohesion of the classes composing the application and ii the poor vocabulary of the identifiers.
in particular we found several cases in which a single class of the project is responsible for multiple functionalities leading to the co occurrence of different topics in the same class.
as an example the class com.zegoggles.smssync.service.state.state is responsible for both the management of error messages andadditional services e.g.
user notifications and the information about the state of the execution of the app .
moreover the same attributes are used in different methods of the class for instance the variable resource that is used to update the user interface layout and images contained in the project is referenced in all the methods.
as a consequence of these observations the similarity between user feedback clusters and the source code is blurred by the presence of different topics.
thus the main limitation of c hange advisor is that it is not always possible to generate reliable links from the user feedback when the vocabulary of the source code is poor or the source code elements implement functionalities related to multiple topics.
this result is expected since our approach relies on topic analysis techniques which are themselves affected by the same problem.
on the other hand it is interesting to observe that c hange advisor results are highly accurate when the source code is well modularized and has a good vocabulary.
for instance let us consider one of the correct links found on thefrostwire project.
this app is an open source bittorrent client and the main problem experienced by users is related to the storage of the downloaded contents.
in this example one of the user feedback cluster identified by c hange advisor contains two reviews both of them reporting the inability of users in finding songs they have previously downloaded.
c hange advisor suggests modifying the class albumsongfragment contained in the package com.andrew.apollo.ui.fragments.profile and the classes guiutils andguimediator of the package com.limegroup.gnutella.gui in order to deal with the problems reported in the user feedback.
by analyzing the source code of the suggested classes we found that our approach correctly suggests the set of classes to change to address the user feedback.
indeed the class albumsongfragment implements the methods oncreateloader andonloadfinished that are responsible for loading the multimedia content stored on the mobile phone whereas the classes guiutils andguimediator manage the user interface related to the music library.
in this case the only class missed by c hange advisor ismusicutils of com.andrew.apollo.utils which contains utility methods used by the class albumsongfragment to perform the loading of the multimedia contents.
this example practically shows the potential usefulness of c hange advisor from the developers perspective.
as for the baseline approach it always has low precision in retrieving links i.e.
overall .
the poor performances are also highlighted by the value of recall which reaches only overall.
we manually investigated some of the links provided by the baseline approach to understanding the reasons behind these results.
the major issue is related to the fact that a linking done using the v ector space model does not provide optimal performances when relating user feedback clusters and source code.
user feedback clusters are almost shorter than the set of words belonging to the source code and most of the times authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the words used in the two sets of terms are similar because the users tend to explain problems using the same vocabulary present in the user interface of the app .
for this reason the use of the asymmetric dice coefficient instead of the cosine similarity results in a winning choice for c hange advisor because it is able to match directly the strings belonging to the two sets of terms rather than computing their similarity using vectors.
we also perform an additional analysis aimed at verifying the overlap between the approaches i.e.
the number of links correctly retrieved by one approach and missed by the other as well as the number of links correctly found by both the techniques.
a complete report is available in our online appendix .
this analysis confirmed the findings discussed above since we observed that of correct links between user feedback clusters and the source code are retrieved by change advisor only while both the approaches found of the correct links.
therefore only a small percentage of the links are retrieved by blu ir and missed by our approach highlighting the small contribution given by the alternative approach in finding links between clusters and source code.
this result is significant because it shows how existing tools locating informal textual documentation to the source code are not particularly suitable in the context of reviews of mobile applications.
we repeated the experiment by distinguishing the different types of user feedback considered by the approaches i.e.
problem discovery and feature request and did not find any meaningful differences.
for the sake of space limitation we report these results in the online appendix .
in summary.
despite few cases discussed above c hange advisor exhibits high precision and recall in linking user feedback clusters to source code components.
when compared to the baseline our approach results are more precise and more complete.
c. threats to v alidity threats to construct validity concern the relationship between the theory and the observation.
for the evaluation of the experimented approaches we relied on error prone human judgment because of the subjectivity in deciding if a cluster of user feedbacks is cohesive or not and whether a link suggested by an approach is correct or not.
to alleviate this issue we built a golden set based on the judgment of more professional inspectors.
moreover the two inspectors firstly performed the task separately and then all disagreements were discussed and resolved.
the proposed approach itself could have been influenced from intrinsic imprecision of other approaches on which it relies e.g.
ar doc hdp .
in future we plan to investigate better the relationship between the outcome of change advisor and the use of the techniques discussed above with the goal of increasing the already high performance of our approach.
on the one hand if the clusters have been qualitatively evaluated by two professional developers in terms of cohesive ness we cannot speculate about their completeness.
indeed we cannot ensure that all the user feedback of the apps in our dataset have been taken into account and correctly clustered.
however as future work we plan to build an oracle reporting the actual clustering of user feedback of the apps in the dataset and compare such an oracle with the results provided by change advisor .
finally another threat in this category is related to our implementation of the baseline approach which was needed to compare our approach with the state of the art.
however we applied the same algorithms and the same steps than the blu ir approach described by saha et al.
.
threats to internal validity concern any confounding factors that could influence our results.
a first threat is related to the choice of the versions of the apps we considered in our study.
specifically the analyzed source code refers to the latest version of an app while the reviews can be related to previous versions.
even though in a normal context a developer is always able to retrieve the reviews for specific versions of his or her app through the google developer console we were not able to distinguish them during the user reviews scraping phase.
nevertheless this is not an issue of this study since the goal was to quantify the accuracy of the proposed approach in linking user feedback to the source code independently from the version of the app to which the feedback refers.
at the same time user feedback provided by users could have already been implemented by developers.
although there may be additional opportunities for increasing the practical applicability of c hange advisor by combining it with a monitoring system such as crist al this is outside the scope of this paper.
hence we leave this exploration for future work.
another threat that could affect the validity of the results of rq2is the presence of potential missing links.
while the inspectors followed a clearly defined evaluation procedure we cannot ensure that the set of correct links identified in this phase actually reflect the total set of correct links present in a given application.
finally the threshold adopted for the dice similarity coefficients may have influenced our results.
however we chose its value by performing a tuning process detailed in the online appendix .
threats to external validity concern the generalizability of our findings.
in this study we selected 10different apps belonging to different app categories having different sizes and user reviews written by different audiences.
to confirm the generality of our findings as future work we would have to replicate the study exploiting the data from more apps belonging to different app stores.
v. s tudy ii o pinions of the original developers even though our technique achieved good results in the previous study software engineering techniques have to address the real needs of developers.
for this reason the goal of this second study is to investigate the opinions of original app developers about c hange advisor with the purpose of analyzing its usefulness from a developer s perspective.
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
context of the study consists of the apps already used in the first study.
a. empirical study definition and design in this study we address the following research question rq3 are the suggestions provided by change advisor actually useful for developers?
to answer our research question we sent a direct invitation to the developers of the apps taken into account.
to identify them we retrieved the e mail addresses of the developers from the source code repositories of the considered apps filtering the developers that have contributed with at least one commit on the main branch.
we chose to involve original developers rather than relying on external developers because we wanted to collect the opinions of the developers that actually worked on the systems under analysis and therefore have a sound knowledge about the structure of the app.
we contacted developers in total receiving responses one for each app involved in the study.
note that even though the number of respondents appears to be low .
response rate our results are close to the suggested minimum response rate for the survey studies which is defined around .
the idea behind the study design was to show to each developer a subset of the links found by c hange advisor for the app he she developed.
for this reason we selected the top10 links identified by our approach on each app of the study those with the higher dice coefficient resulting from the first study see section iv .
this was done to avoid having a long questionnaire that might have discouraged developers to take part in our study.
for each link composed of a user feedback cluster and the related classes the participants had to answer the following questions could you please summarize what the users wanted to say in the shown user reviews?
how well the user reviews are grouped together according to the number of source code components that need to be modified?
please rate your opinion from very poorly to very well.
how well the proposed set of classes matches the actual set of classes that need to be changed in order to satisfy the user requests?
please rate your opinion from very poorly to very well.
evaluate the completeness of the set of classes suggested above compared to the actual set of classes that need to be modified in order to satisfy the user requests.
please rate your opinion from unacceptable to excellent.
besides the questions reported above the developers also filled in a pre questionnaire that allowed us to assess their background.
they also answered a brief post questionnaire where we asked to estimate how much time they would save using an approach like the one proposed in this paper instead of manually analyzing user reviews to identify change requests.
the survey was designed to be completed within approximately minutes.
to automatically collect the answers the survey was hosted using a web based survey software i.e.
google f orms .
developers were given days to respond to the survey.
at the end of the response period we collected the answers of the complete questionnaires in a spreadsheet to perform data analysis.
to answer rq3 we computed the distribution of values assigned by developers when evaluating the cohesiveness of user feedback clusters question of the survey the distribution of values assigned by developers when assessing the precision of c hange advisor question of the survey the distribution of values assigned by developers when evaluating the completeness of the suggestions provided by c hange advisor question of the survey .
moreover when answering to question we collected the descriptions provided by the developers as free opinions about the clusters produced by c hange advisor .
b. analysis of the results the respondents declared a mobile development experience ranging from 3to5years with 2to3applications each and a google play store score of 4stars.
the developers also claimed they look at user reviews most of the time to gather requirements for new releases of their apps spending about hours per week.
figure shows the boxplots of the distributions of the responses divided by app provided by the developers involved in the study.
we reported the likert scale values of the aspects analyzed in rq3 i.e.
cluster cohesiveness linking precision and linking completeness .
as we can see the level of cohesiveness assigned by the developers is always high likert value except for thewordpress app where on average the cohesiveness is equal to .
.
however by further analyzing his answers we observed that he was always able to summarize the requests contained in the feedback clusters indicating specific problems in the app therefore explaining well focused issues e.g.
options in the dashboard were deactivate for a while and users are just reporting such issues .
this observation makes us conclude that the lowest values assigned by the developer do not indicate problems in the clustering phase of change advisor but rather the judgment of the developer has been just more conservative than that of other developers.
the results obtained by this analysis confirmed again the ability of c hange advisor in grouping together similar user needs.
the precision and completeness of the approach were instead evaluated in general as well and very well respectively.
while the values assigned by developers to assess the precision of c hange advisor somehow reflect the quantitative analysis conducted in section iv precision the most interesting thing is related to the completeness .
indeed the developers perceived the links provided by our approach closer to the actual set of code components to modify with respect to what we estimated in our quantitative evaluation recall .
this highlights the potential of the proposed approach as a tool useful for developers in a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
acdisplay cool reader fb reader focal frostwire k mail shortyz crosswords sms backup solitaire wordpress .
.
.
.
.0value variable cluster cohesiveness link precision link completeness figure survey results.
real world environment.
the claim is also supported by some of the answers provided by the developers when they filled in the post questionnaire.
in particular we asked to estimate how much time they would save using c hange advisor instead of only manually analyzing user reviews.
in general they claimedthat a tool like c hange advisor would be very useful and that they would be able to save almost all the necessary time compared to the manual task .
one of the developers pointed out that trivially i will not need to read each single review to know what requirements i should implement.
this represents exactly the first goal of c hange advisor i.e.
trying to reduce a huge number of user reviews to a smaller set of useful contents through the clustering process.
on the other hand c hange advisor links user feedback directly to source code components.
although a developer usually is aware of the source code components responsibilities the linking process would reveal itself to be very useful as pointed out by two developers i know what changes i have to make in my appwhen implementing a change.
however a tool like this may help in quantifying the number of classes to be modified.
it would be useful for letting me immediately know to what extent a change is complicated to apply.
thus the original developers of the apps in our dataset highlighted that c hange advisor not only provides a toolkit able to support them during the daily activities of user reviews reading and understanding but also a tool to estimate the possible cost of some change.
in summary.
the developers confirm the usefulness of change advisor in practice.
in particular not only do the developers think that our approach would be useful in grouping together reviews with the same meaning and linking to source components but also in quantifying the extent of changes.
c. threats to v alidity threats to construct validity are mainly related to how we measured developers estimation of cluster cohesiveness linking precision and completeness.
we used a likert scale that allows comparing responses from multiple respondents.
however we are aware that questionnaires may only reflect a subjective perception of the problem.
threats to internal validity are related to the selection of the top links based on the higher dice coefficient valuesresulting from the first study.
we made it to avoid having a long questionnaire that might have discouraged developers to take part in our study.
moreover a factor that may have affected the results of the survey study is the response rate of .
although it covers each app in the dataset.
as for the threats to external validity they are related to how we generalized the results.
a replication of the study is part of our future agenda.
vi.
c onclusions and future work in this paper we introduced c hange advisor a novel approach developed with the goal of supporting developers in accommodating user change requests of mobile apps and planning a new release of an application.
we believe that c hange advisor represents a significant step forward to the current state of art of app reviews mining since to the best of our knowledge it is the first approach able to i extract user feedback relevant from a maintenance perspective ii cluster it according to similar user needs and iii determine the code artifacts that need to be maintained to accommodate the change requests.
the first evaluation of c hange advisor demonstrated that the approach is able to i identify cohesive user feedback clusters representing similar change requests rq1 ii identify the source code components impacted by the suggested changes with ofprecision and70 ofrecall rq2 and iii it is more accurate than a state of the art technique developed inthe context of bug localization .
the study conducted with the original developers of the apps in our dataset confirmed the usefulness of our approach in practice rq3 .
our future research agenda includes i the extension of the empirical study to include a larger number and variety of appsfrom different stores ii the comparison of c hange advisor with other baseline techniques in the context of software traceability e.g.
the technique proposed by bachelli et al.
and iii the integration of a mechanism for prioritizing the suggested changes.
specifically the prioritization mechanism will take into account both user requests popularity and the interdependencies between the impacted code components to help developers focus on requests important for users and avoid working on conflicting software changes.