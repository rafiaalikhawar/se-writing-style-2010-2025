automated model repair for alloy kaiyuanwang university oftexas at austin usa kaiyuanw utexas.eduallison sullivan university oftexas at austin usa allisonksullivan utexas.edusarfrazkhurshid university oftexas at austin usa khurshid utexas.edu abstract automated program repair is an active research area.
however existing research focuses mostly on imperative code e.g.
in java.
in this paper we study the problem of repairing declarative mod els in alloy a first order relational logic with transitive closure.
weintroducearepair thefirsttechniqueforrepairingalloymodels.
arepair follows the spirit of traditional automated programrepair techniques.
specifically arepair takes as input a faulty alloy modeland atest suitethat contains somefailing test and outputsarepairedmodelthatiscorrectwithrespecttothegiventests.
arepair integrates ideas from mutation testing and program synthesis to provide an effective solution for repairing alloy models.
the experimental results show that arepair can fix out of real world faultymodelswe collected.
ccs concepts softwareand itsengineering error handlingand recovery keywords modelrepair first orderlogic arepair acm reference format kaiyuan wang allison sullivan and sarfraz khurshid.
.
automated model repair for alloy.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm new york ny usa 12pages.
introduction automatic program repair techniques significantly reduce the humaneffortrequiredtodiagnose debug andrepairfaultyprograms .thestandard generateand validate approach startswi th afaultyprogramandatestsuitethatrevealsthedefect.itexplores candidate programs in the search space and validates each candidate program against the given test suite until a program that passes all tests is found.
some repair techniques infer specs of theprogramandtranslatetherepairproblemintoconstraints andthen use sat smt solvers to synthesize patches that conform to thespecs .
nowat north carolinaa t state university.
permission to make digital or hard copies of all or part of this work for personal or classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributedfor profit or commercialadvantage and that copies bear this notice and the full citation on thefirstpage.
copyrightsfor components of thiswork owned byothers than acmmustbehonored.abstractingwithcreditispermitted.
tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermission and or afee.
requestpermissionsfrompermissions acm.org.
ase september montpellier france associationfor computing machinery.
acm isbn978 ... .
languages like java.
our focus in this paper is declarative models w r i t t e ni na l l o y a first order relational logic with transitive closure.
the alloy language and its back end analyzer have been explored within the software engineering community.
alloy is used in various domains including uml analysis security networking and feature modeling .
additionally thealloy analyzer has been extended to provide betterscenario finding experiences .
alloy users write models that describe the properties of the system of interest.
the alloy analyzer translates alloy models into kodkod f o r m u las and invokes off the shelf sat solvers to search for solutions.
the analyzer performs scope bounded analysis which checks the properties within a given scope i .
e .b o u n do nt h eu n i v e r s eo fd i s course.aunit definesthenotionoftestinginalloyfollowing thespirit of traditional testing frameworks e.g.
junit.
developers writetestpredicatesandinvoke commandstoasserttheexistence ornon existence of solutions.
inthispaper wepresentarepair anovelgenerate and validate program repair technique for alloy which is able to handle al loy models with multiple faults.
arepair has three main components a mutation based fault localization technique alloyfl that locates faults at the ast node granularity a generator that systematically generates alloy expressions withequivalencepruningrulesforrelationalalgebra and asynthesizerthatexplores the search space untilamodelwithallpassing tests is found.
arepair starts by invoking alloyfl to locate faults.
each time alloyfl is invoked arepair checks if the mostsuspiciousnodecanbefixedbymutationandappliesthechangeif thatisthecase.otherwise foreachsuspiciousastnodereturned arepair creates holes fordescendant nodes in the suspiciousast andenumeratescandidatefragme nts generatedbytheexpression generator of corresponding holes until some failing test passesandtheresultsofpassingtestsarepreserved.arepairimplements two strategies to explore the search space all combinations and base choice .
the all combinations strategy explores all combinations of candidate fragments for all holes until some failing testpasses and no passing testfails.
the base choice strategy enumeratescandidatefragments foroneholeatatime whilekeeping the candidate fragments of the other holes constant.
after enumerating all the fragments for one hole the base choice strategy fills t h eh o l ew i t ht h ef r a g m e n tt h a tm a kes the most failing tests pass and no passing test fails.
both strategies are inspired by textbook input space criteria for test coverage .
arepair avoids running aunit test predicates with expensive sat solver calls by building formula dependency graphs and leveraging alloy s built in evaluator to evaluate a minimal number of affected formulas that de termine a test s satisfiability.
a hierarchical cache further reduces thesizesofinputstotheevaluator.arepairrepeatedlyfixesfaults untilalltestspassoritexhausts theboundedsearch space.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france kaiyuan wang allison sullivan and sarfraz khurshid we evaluate arepair using modelscollectedfrom thestandard alloy4.
distributionand amalgam .wealso collectalloyassignment solutions from graduate students.
with the default setting arepair is able to repair out of real faulty models .w e make the following contributions alloy model repair.
arepair is the first repair technique for alloy which uses both mutations and synthesis to repair faulty models.
the experimental results show that the combined approach works well and many faulty models require both muta tionsandsynthesis foracompletefix.arepairdoesnotrequire isolated faults.
it can fix models with multiple faults or faults involving multiplelocations.
optimizationsforpracticalmodelrepair.
arepairdoesnot search forfaultpatternsand applyrepair templatestofixfaults.instead it tries to repair a faulty ast in a bottom up fashion so it is more likely to repair faults with unseen patterns.
the absence of repair templates results in an immense search space andweimplementthefollowingoptimizationstomakethetech nique tractable and reduce end to end time.
the expression generator prunes equivalent expressions based on equivalence pruningrules and modulotestinputs .
the enumeration based approach explores the search space without expen sive constraint solving .
the construction of dependency graphsforconstraintformulase nables asmallnumberofevaluatorcallsduringtheenumeration basedapproach.
thebase choicesearch strategyreducest heexplorationspace.
thehierarchical caching reduces sizes of the inputstoevaluator calls.
evaluation.
weevaluatearepaironrealfaultsandshowthatit isabletofix28outof38faultymodels.wequalitativelycompare patches generated by arepair and human written patches and show thatthequalityofthegenerated patchesisgood.
open source.
we release real world alloy models with annotated fault locations and human written patches and opensource arepair so researchers can use them in the future.
therepois available at example thissectionpresentsareal worldfaultyalloymodeltointroduce thebasicsofalloyandaunit.then wedescribehowalloyfl and arepair fixthe model.
figure1ashows the farmer river crossing puzzlewhere the goalistoallowafarmertotransportafox chickenandgrainfromone river bank to the other.
the farmer uses a boat and can only carryoneitematatime.ifleftunattended thefoxeatsthechicken and the chicken eats the grain.
the model contains a fault whichprevents the eating from happening while the farmer is away.
instead the faulty model enforces the eating to happen when thefarmer comesback.
lines 4declarethebasic typesintheproblem anotionofobject line sigdenotesa set andintroducesa type fourconcrete objects line3 andasetofstates line4 thatmodeltheobjectsinboththe nearandfarbanks afterevery farmer s rivercrossing action line .
the abstract keyword enforces that an object is one of its concrete subtypes farmer fox chickenandgrain.t h eone keyword constrains each concrete object type to contain a single distinctobjectatom.the eatsfielddeclaresthateachobjectcaneatasetofobjectsandthefactonline5restrictsthatthefoxcaneatthe chicken and the chicken can eat the grain.
the initialstate fact onlines6 7constrainsthatinitiallyeverything isonthenearbank and nothing is on the far bank.
the crossriver predicate on lines 13definestherivercrossingaction.ittakesfourparameters thesetofobjectsonthebankwherethefarmerstartsat pre state from andpost state from andthesetofobjectsonthebankthefarmer willcrossto pre state toandpost state to .thepredicatestates that either the farmer takes nothing or the farmer takes one itemtotheothersideoftheriver.the statetransition factonlines1419 states that for every two consecutive states if the farmer is on thenearbankinthepre state thenhewouldcrosstherivertothefar bankin thepost state and vice versa.
the solvepuzzle online restricts that everything should be on the far bank of the riverinthelaststate.
thefaultis in the crossriver predicate highlighted in orange .
thepredicateenforceseatingtohappenonlyafterthefarmercomes back and not immediately after the farmer leaves the bank.
thismeans if the farmer takes the grain from the near bank to the far bank thefoxwillnoteatthechicken.
butwhen thefarmercomes backtothenearbank thefoxeatsthechicken.thismodelingerror was in alloy release .1and wasfixedin release .
.
an aunit test that reveals the fault is shown in figure 1b.
predicate test1encodesthevaluationsofeach signature typeand fieldrelationinthefaultyfarmermodel.theinvocationof crossriver predicateonline18statesthateverythingisononebankandnoth ingisontheotherbankinthepre state.inthepost state afterthefarmer crosses the river with the fox only the chicken is left onthe one bank because the chicken eats the grain and both the farmerandthefox areontheotherbank.
thecommandin line19 runsthetestwithatmost4atomsforeachsigtypeandexpectstheexistenceofasolution.however thetestpredicateisunsatisfiable becauseofthemodelingerror resulting inatestfailure.
arepair invokes alloyfl tolocatefaultsat the ast nodegranularity.
the most suspicious node alloyfl returns is shown in figure2.arepaircreates holes toreplace eachlevel ofast nodes inabottom upfashion.forexample itfirstcreatesholesfor toand eats highlighted in red .
then arepair generates a set of candidateexpressions foreachholeusing allsignatures fields variables inscope e.g.
farmer fromanditem etc.next arepairenumerates thecandidate expressions for each holeand runs all affected tests to see if any test result changes from failing to passing.
arepair keeps the candidate values that make some failing tests pass andpreservestheresultsofpassingtests.inthiscase arepairreplaces towithnoneand now one failing test passes and no passing test fails .next arepairrerunsalloyfl and findsthatthemostsuspi ciousnodeisstillthesame.inthisiteration arepaircreatesholes for toand the relational join operator highlighted in yellow .
arepair keeps synthesizing expressions formulas under each suspicious node to make failing tests pass.
if arepair cannot makeany failing test pass for the suspicious node then it repeats the same process for the next suspicious node.
note that alloyfl is a mutation based technique and it can also repair the model with mutations.eachtimealloyflisinvoked wecheckifthereisamutation over the most suspicious node alloyfl reports that makes some failing tests pass and no passing test fails.
if such mutation authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated model repair for alloy ase september montpellier france .openutil ordering asord .abstract sig object eats setobject .one sig farmer fox chicken grain extends object .sigstate near far setobject .facteating eats fox chicken chicken grain .factinitialstate .
lets0 ord first s0.near object nos0.far .predcrossriver .
from from farmer .
to to to.eats farmer .
some item from farmer .
from from farmer item .
to to to.eats farmer item .
factstatetransition .
alls state s ord next .
farmer ins.near .
crossriver .
elsecrossriver .
.
predsolvepuzzle ord last.far object a faultyfarmerriver crossing model.
.predtest1 .
some disj f0 farmer some disj x0 fox .
some disj c0 chicken some disj g0 grain .
some disj f0 x0 c0 g0 object .
some disj s0 s1 s2 s3 state .
farmer f0 .
fox x08.
chicken c09.
grain g0 .
object f0 x0 c0 g0 .
eats x0 c0 c0 g0 .
state s0 s1 s2 s313.
near s0 f0 s0 x0 s0 c0 s0 g014.
s1 x0 s2 f0 s2 x0 s3 x0 .
far s1 f0 s1 g0 s2 g0 s3 f0 s3 g0 .
ord first s0 .
ord next s0 s1 s1 s2 s2 s318.
crossriver .
runtest1 for 4expect .
more tests ... b afailing test of the farmer river crossing model .
figure1 faultyfarmerexampleandtests.
from to item item from farmer farmer to to eats level7level6level1 figure firstsuspiciousnodefor faultyfarmerexample.
a ahuman written patch.
.
predcrossriver .
from from farmer .
from from farmer from .eats .
to to to.eats farmer .
to to farmer .
some item from farmer .
from from farmer item .
from from farmer item from .eats .
to to to.eats farmer item .
to to farmer item b a patch generated byarepair.
.
predcrossriver .
from from farmer .
to to to.eats farmer .
some item from farmer .
some item from farmer .
from from farmer item .
from from farmer from .eats item .
to to to.eats farmer item .
to to farmer item figure3 patchesfor thefaultyfarmermodel.
exists then we mutate the model and start the next iteration.
finally if arepair can fix thefaulty model i.e.
alltests pass then itpost processes the fixed model to remove redundant code e.g.
replace to none.eats w i t h to and returnsthemodeltotheuser.
figure3showsthehumanwrittenpatch a and thefirstpatch generatedbyarepair b .wecanseethatthehumanwrittenpatchfixes the eating action both when the farmer crosses the riverwith lines7 orwithout lines2 anitem.thepatcharepair generates deletes the formula that models the farmer s crossingriverwithoutanitem lines2 andfixesthe eating actionwhen the farmer crosses the river with an item lines .
the interesting part is that the patch also changes the domain of a variable declaration lines4 whicha ctuallymergesbothcaseswhenthe farmer crosses the river with without an item.
the new domain line allowsthe itemto bethe farmer himself and it modelsthe correctsemantics correspondingtothedeletedformulaonlines23.in thiscase we validatethe equivalenceofgenerated patchand thehuman written patchwitha scope bounded analysis using the alloy analyzer and find that the generated patch is semantically equivalenttothehumanwrittenpatch.
background fault localization in this section we describe alloyfl which is the fault localizationtechnique usedby arepair.
alloyfl follows the traditional mutation based fault localizationtechniques and implements avariety of mutationoperators as shown in figure .mormutates signature multiplicity e.g.
lone sig t o one sig .qormutates quantifiers e.g.
all t o some .uor borandlordefine operatorreplacement for unary binary and formulalist operators respectively.
for example uor mutates a. b t o a. b bormutates a b t o a b andlor mutates a b t o a b .uoiinserts an unary operatorbefore expressions e.g.
a.b t o a. b .uoddeletes an unary operator e.g.
a. b to a. b .loddeletesanoperandofalogicaloperator e.g.
a b to b .pbddeletes the bodyof analloyparagraph.
boeexchanges operands fora binary operator e.g.
a b t o b a .ieoe exchangestheoperandsof imply else operation e.g.
a be l s e c t o a c else b .
these operators are well defined such that alloyflisabletoaccuratelylocatefaultsandevenfixthefaultsin some cases.
for example to fix the faulty farmer example in figure1a alloyfl fixespartsofthefaultsbyapplying bor figure3 b lines4 and lod figure3 b lines .
the input of alloyfl is a faulty alloy model and a set of alloy commandswiththe expectkeyword.thesecommandscaninvoke alloypredicates functionorassertions.
expect meansthatthe correspondingcommandisexpectedtobesatisfiablewhile expect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france kaiyuan wang allison sullivan and sarfraz khurshid mutationdescription operator mor multiplicity operator replacement qor quantifier operator replacement uor unary operator replacement bor binary operator replacement lor formula listoperator replacement uoi unary operator insertion uod unary operator deletion lod logical operanddeletion pbd paragraph body deletion boe binary operand exchange ieoe imply else operandexchange figure4 mutationoperators means thatthecommand isexpectedtobeunsatisfiable.
inthis paper eachcommandinvokes anaunit testpredicateandwe sayanaunittestfailsifthecorrespondingcommandissatisfiable butisexpectedtobeunsatisfiable orviceversa.
theoutputofalloyflisalistofastnodesindescendingorderoftheirsuspicious ness given a formula.in thispaper we use theochiai f o r m u l a failed e totalfailed failed e passed e w h e r efailed e andpassed e are the number of tests that failed and passed with respect tothe original faulty model that kill the mutant e a n dtotalfailed is the total number of failed tests for the faulty model.
alloyfl systematically mutates the faulty alloy model using mutation operators in figure 4and runs the test suite against each mutant.
a suspiciousness score computed from th e ochiai formula is assigned to eachmutatedastnode.incasemorethanonemutationoperatoris applicable to an ast node the maximum suspiciousness score computed for the node is used.
finally alloyfl ranks all nodesin the descending order of suspiciousness and returns the ranked list.
we modify alloyfl to also return the mutation operator corresponding to themost suspiciousast nodeso later arepair candetermine if that mutationshouldbeappliedas a potentialfix.
technique in this section we first describe how we create holes section .
andhowwegenerateexpressionstofillinholes section .
.next we describe the search strategies section .
.
then we describe how we run tests withoutinvoking a sat solver section .
a n d thehierarchicalcachingweusetoimproveperformance section .
.
finally we describe the enumeration based repair approach as a whole section .
.
.
createholes foreachsuspiciousastnodereturnedbyalloyfl wecreateholesateachlevelofthecorrespondingastinabottom upfashion.for example themostsuspiciousnodeinthefaultyfarmermodel figure2 has levels.
we first create holes at level shown in red and synthesize new expressions at that level without modifying nodesofotherlevels.werepeatthisprocessfromlevel7tolevel1 root level until some failing test passes and no passing test fails.
theintuitionisthatalloyflisdesigned tomutateupper leveloperator nodes and if the fault cannot be fixed by alloyfl then theissueislikelyatthelowerlevelsoftheast.thisapproachalsoprioritizes patches with smaller perturbations to the original model whichisconsistentwiththeinsight patchesthatintroducesmaller perturbations to the original program are more likely to be cor rect .
creating a single hole for each node in a given level may not result in valid models.
for example replacing the node with a holeatlevel1infigure 2doesnotmakethenewprogramcompile.
consequently the schema to create holes for different ast nodes may vary.
arepair introduces different types of holes i.e.
quantifier holes denoted by qh logical operatorholes denoted by loh comparisonoperatorholes denotedby coh implicationholes denoted by ih cardinality holes denoted by ch boolean holes denoted by bh and expression holes denoted by eh .
the value of qhcanbeoneof all no some lone or one .
the value of loh can be either o r .
the value of cohcan be one of in !
o r !in .
the value of ihcan be either o r .
the value ofchcanbeoneof no lone one or some .
the value of bhcan beeither empty or !
.
the value of ehcan be any expression.
figure5showsthemeaningofdifferenttypesofastnodesand thecorrespondingschemastocreateholes.eachschemaisdenoted by h x h where h x meanstheholescreatedfromastnode typexandhshows the way to compute holes.
for example the most suspicious node returned by alloyfl is a conjunction node a ss h o w ni nf i g u r e .
to create holes for the root node we can apply the schema for the conjunction node which states thattheholesweshouldcreateincludealogicaloperatorhole loh holes createdfromtheleftchildandholescreatedfromtherightchild.inthis case boththe left and right children of the conjunction node aresetequalitynodes sowerecursivelyapplyschemasinfigure5until no more holes are created.
in the end we wouldcreate 4expressionholes 2comparisonoperatorholesandalogicaloperatorhole.
this step guarantees that if we fill holes with candidate operators expressions then the resulting expression formula willalways compile.
.
generatingexpressions thespaceofcandidatefragmentsforoperatorholes e.g.quantifier holes and cardinality holes are fixed but the space of candidate fragmentsforexpression holesdependsontheexpression generator.togeneratevalidcandidatefragmentsforexpressionholes we need to find all atomic expressions in the model that can be used.
arepair has a static analyzer which finds all atomic expressions i.e.
sigs fields predicate function parameters quantifier variablesand let variables in scope of each expression hole.
the holes thatshare the same set of atomic expressions in scope have the same set of generated candidate fragments.
arepairimplementsanexpressiongeneratorthatgenerates expressionsfollowingthegrammarsinfigure .thegeneratorimplements two pruning strategies.
first the generator prunes semanticallyequivalent expressions using equivalence pruning rulesforrelationalalgebradescribedinrexgen .second thegenerator implements a modulo test checker that prunes equivalent expres sionswithrespecttothegiventests.theequivalencepruningrulesandthemodulotestcheckersignificantlyreducethenumberofexpressions toconsider and maketherepair problem tractable.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated model repair for alloy ase september montpellier france meaning schema meaning schema cartesianproduct h e h relational join h triangleleft e h union h e h intersection h e h set difference h e h overridingunion h eh domainrestriction h e h range restriction h e h transitiveclosure h e h reflexivetransitiveclosure h eh inverserelational join h eh relational transpose h e h cardinality h e h set comprehension h t t e h identity relation binary h iden eh universe unary h univ eh conjunction h h l o h h disjunction h h l o h h implication h h i h h bi implication h h i h h if then else h ?
h h h negation h b h h relational equality h h co h h relationalcontainment h i n h co h h universalquantification h t t qh h h t existentialquantification h t t qh h h t h one ch h h lone ch h h some ch h h no ch h figure hole creation schemas for alloy surface syntax.
h x computes the holes for syntax x. and denote formulas which evaluatetotrueor false.
and denoteexpressions whichevaluateto relations.
t denotetuplemembership t .
expression e uope ebo pe atom e const unary op uop binaryop bop atomic expr atom e si e field e param e vare constant const none iden univ int figure6 expression generationsyntax.
next we describe the modulo test pruning technique with an example.
consider the modelshown below signode link lonenode predp some n node no??
predt1 some disj n0 node node n0 link n0 n0 predt2 some disj n0 n1 node node n0 n1 link n0 n1 n1 n0 p the modelhas asignature node ab i n a ryfi e l d linkand a quantifiervariable n.i mpli ci tly n i softy pe nodeandhas acardinality of .
the model contains two aunit tests t1andt2.s u p p o s ew e wanttogenerate expressions oftype nodeinthebody denotedby ?
?
oftheexistential quantification andwe can use n link a n d node astheatomicexpressions.thefollowingtableshowsthevaluationsoffoursyntacticallydifferentexpressions i.e.
n n.link link.
node n a n d link.node n with respect to t1andt2.
test n n n.link link.
node n link.node n t1 n0 n0 n0 n0 t2n0 n0 n1 n0 n0 n1 n1 n0 n1 n1 for test t1 ncan only be n0andlinkisn0 n0.i ti se a s yt o see that n n.link a n d link.node n evaluate to the same set n0 and thus are equivalent with respect to t1.f o rt e s t t2 ncan ben0orn1 a n dlinkis n0 n1 n1 n0 .
n link.
node n a n d link.node n are equivalent with respect to t2bothwhen n n0 andn n1.s o n a n d link.node n are equivalent with respect to the test suite and the modulo test checker can prune either n or link.node n .
in practice we keep expressions with smaller sizes so link.node n willbepruned.iftheexpressiondoesnot contain any free variable its valuation does not change based on the valuations of free variables.
if the expression contains more thanonefreevariable thenweneedtoenumerateallcombinations ofpossiblevaluations ofthefree variables toget thevaluations ofthe expression.
if the free variable s cardinality is greater than then its valuation can be any subset ofits declaring type.
two expressionsareequivalentwithrespecttoatestiftheirvaluationsare thesameacrossallcombinationsofpossiblevaluationsoffreevariables in the scope.
the expression generator prunes expressions that are equivalent to any existing expression with respect to the entire testsuite.
inthispaper thesizeofanexpressionisdefinedasthenumber of descendant nodes in the ast representation of the expression.
theexpressiongeneratorisabletogenerateexpressionsofagiven typeand size.
.
search strategies given a level of nodes in a suspicious node and the correspond ing holes created arepair implements two search strategies all combinations andbase choice .
all combinations .
under this search strategy arepair tries all combinations of candidate fragments for all holes until it finds some failing test passed and no passing test failed.
this strategyis typically impractical as the number of holes and the number of candidate fragments for each hole grow.
for example with holes and 100candidate fragments foreach hole the search spaceis .
in our implementation we limit the maximum number of combinations to explore per level of holes for this search strategy.
typically the limit we set is still large so we stop exploring more combinations the first time a combination of candidate fragmentsmakessomefailingtestpassandnopassingtestfails.ifsuch a combination is found we fill the holes with the corresponding fragmentsand savethechanges beforestartingthenext iteration.
intuitively we want to first explore combinations of candidate fragments of expression holes with smaller expression sizes be cause we assume small sized expressions are more natural to developers e.g.
n vs node link.n .
figure7showshowweprioritizeexploringcombinationsofcandidateexpressionswithsmaller sizes.
suppose we have nholes hole1toholen a n dholeihassi number of candidate fragments.
then we can partition the candi datefragments of hole iintokiparts pi 1topi ki ofequalsize.next we create size ntuplesu x1 x2 ... xn n logicalandtext i 1xi and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france kaiyuan wang allison sullivan and sarfraz khurshid hole1p1 1p1 ...p1 k1s1 hole2p2 1p2 ...p2 k2s2 ... hole npn 1pn ...pn knsn figure7 all combinations partitions.
sort the tuples first byn summationtext i 1xiand then by max i xi min i xi togetsarankedlistoftuples l.forexample if n k1 k2 thentherankedtuplelist l .
finally weiterateeachtuple x1 ... xn inlandexploreallcombinations of candidate fragments c f1 ... fn n logicalandtext i 1fi pixi .
since expressions are generated in a bottom up fashion expressions with smaller sizes are generated first which means expression sizes in px iare smaller than expression sizes in px jifi j. therefore the exploration strategy guarantees that combinations of smallerexpressions areexplored first.base choice .under thissearchstrategy arepairholdscandidate fragments of all holes constant except one hole base choice .
itenumerates candidate fragments of hole iwith the candidate fragments of the rest holes unchanged.
for each holei a r e p a i re x plores all candidate fragments and picks the one fi t h a tm a k e s themaximumnumberoffailingtestspassandnopassingtestfails.
then arepairenumeratescandidatefragmentsof holei 1withthe fragment of holeiset tofi.
arepair uses this exploration strategy fromhole1toholenandsavesthefinalchanges asthepotentialfix.
for example with holes and candidate fragments for each hole thesearch spaceis400.in practice thenumber ofgenerated candidatefragmentsforanexpressionholecanbelarge soweset alimit onthenumber ofcandidatefragments toexploreperhole.
.
running tests arepairinvokestestsintheexpressiongenerationphase toprune expressions the fault localization phase to locate faults and the repairphase tovalidatecandidatepatches .sincethesearchspaceis large and each repair problemcontains many tests invoking all tests at the repair phase takes a majority of the time.
moreover invoking eachtestpredicatewithasatsolverisexpensive.
wein troduceatechniquethatdeterminestestsatisfiabilityusingalloy s built in evaluator without sat solving and builds a dependency graphfor eachtesttoreducethenumber ofevaluator calls.
for a given faulty alloy model arepair normalizes the signaturemultiplicityconstraints thefield multiplicityconstraintsandthesignaturefacts andcreatesaformulaforeachconstraint.inthefaultyfarmerexample figure 1a the objectsignature isdeclared tobeanarbitrarysetofatoms soitdoesnotneedtobenormalizedand we create an empty formula denoted by object mult w h i c h evaluates to true bydefault.
similarly the field eatsis declared to relate an object to a set of objects so we simply create an emptyformula denoted by eats mult .
one sig farmer i sd e c l a r e dt otest1object mult farmer mult foxmult chicken mult grain multstate multeats multnear mult farmulteating initialstatestatetransition crossriver figure8 dependencygraph for test1in figure 1b.
be a singleton set so we normalize it as sig farmer r e m o v es i g nature multiplicity constraint and create a formula one farmer denotedby farmer mult .thus arepaircreatesaformulaforeach signature and field.since the farmer modeldoesnot have any sig nature facts we do not need to create any formula for signature facts.foreachfactparagraph arepaircreatesaformula denoted bythe factname thatis identical tothe factbody.
foreachaunittest wecreatea dependencygraphthatencodes the formulas the test depends on.
for example figure 8shows the dependency graph for test1in figure 1b.test1depends on all signature field multiplicity constraints and all fact constraints becausethoseconstraintsareenforcedbythealloyanalyzerwhen we invoke the test.
since both test1andstatetransition directly invoke the crossriver predicate they both depend on crossriver .
once we build the dependency graph for each aunit test it is easy to compute a test s satisfiability from the formulas the testdepends on.
initially arepair evaluates each formula the test de pends on and stores the satisfiability of each formula.
when arepair enumerates candidate fragments for holes it only evaluates the affected formulas to determine the satisfiability of the test.
inthe faulty farmer example when a repair enumerates candidate fragmentsforholesunderthemostsuspiciousastnode figure theonlyaffectedpredicateis crossriver andtheaffectedformulas arestatetransition andtest1.
to determine the satisfiability of test1 w eo n l yn e e dt oe v a l u a t et h eb o d yo f statetransition and thebodyof test1.moreover ifanyunaffectedformulaisunsatisfiable thenweknowthetestisunsatisfiableeven withoutinvoking theevaluator.inpractice thetechniqueimprovestheperformance ofarepairbecauseitdoesnotinvolve any expensive satsolvingandisabletodetermine thetestsatisfiabilitywithaminimalnumberofevaluatorcalls.
.
hierarchical caching the evaluator based approach to determine the test satisfiability can be further improved by our hierarchical caching algorithm.
the idea is that we can reuse the previously evaluated result i.e.
valuation of a formula if its subformulasevaluate tothe same set ofvaluesassomesubformulasweevaluatedbefore.weexplainhierarchical caching through thefarmer example.supposewe want to determine the satisfiability of test1 figure1b b ye v a l u a t i n g the fact formula statetransition and the created holes that correspond to nodes at level of the most suspicious ast node i.e.
to a n d eats i nf i g u r e 2highlighted in red.
also assume that hole h to is first replaced by fragment none a n dh o l e h eats is unchanged.
we create a hierarchical cache for test1as follows.
first weinvoke theevaluator forthefragments ofbothholesandfind that none e v a l u a t e st o and eats e v a l u a t e st o x c0 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated model repair for alloy ase september montpellier france algorithm arepair algorithm.
input faultyalloymodel m t e s ts u i t e t. output fullyfixed model or partially fixed model.
1canfix true 2whilecanfixdo 3res runtests m 4ifalltestspassed res then return m full fix.
5l locatefaults m res 6ifisempty l then return m partial fix.
7canfix false 8ifisfixed m l then m applychange m l canfix true 11else foreachn ldo patch synthesize m n ifisfixed m patch then m applychange m patch canfix true break 18returnm partial fix.
c0 g0 .sowecreatemappings none for h to and eats for h eats .sincethejoinoperator inlevel 6isthelowestcommonancestorofbothholesinlevel7 amapping .
x0 c0 c0 g0 iscreatedforthejoinoperator.note that the key of the join operator is its string representation with alldescendantholesreplacedbytheirvaluationsunder test1.the value of the mapping is obtained by evaluating the string representationofthejoinoperator i.e.
none.eats which is .w ethen create a mapping for the body of the declaring crossriver predicate.
but because the body has parameters from from to to weneedtoassignpossiblevaluestoallparametersandcreateamappingforthebody a1a2...an where aimeans the string representation of the body with the join operator replaced with its actual valuation given ith possible assignment of parameters and biis the corresponding boolean result of the body formula in this case.
we finally maps the cached valueof crossriver i.e.
tothesatisfiabilityofthe statetransition fact.
if the next fragment ofhole h to is item object w h i c he v a l u ates to h eats is unchanged then weimmediately know that statetransition evaluates to the same result as when hole h to is none .
because the new keys we computedfor other nodes e.g.
thejoinoperatorinlevel6 arealreadyinthecache.therefore weonly invoke the evaluator once to evaluate item object i n s t e a d ofevaluatingthebig statetransition bodytodetermineitssatisfiability.
in general the hierarchical cache reduces the input size ofevaluator calls butincrease the number of evaluator calls.
in practice we observe speed ups for a majority of repairing problemsand few repair problems suffer from aslow down.
.
repair algorithm algorithm 1showsthe algorithmofarepair.the algorithmtakes asinputafaultyalloymodel mand a testsuite tthatreveals thefault.
the output is either a fully fixed model if all tests pass or a partially fixed model otherwise.
in the worst scenario arepair is not able to fix any fault in which case the partially fixed modelis the original faultymodel.
initially we set canfixtotrue line and enter the loop line .
for each iteration in the loop we firstrunalltests against m line .
if all tests pass mis returned line .
otherwise we run alloyfl to return a ranked list l o fs u s p i cious ast nodes line .
if lis empty then the algorithm cannot fixthefaultymodelanditreturnsthelateststateof m line6 .otherwise we set canfixtofalse line and tryto fix the faults.the algorithm checks if the mostsuspicious ast node l h a sapotential fix line .
the isfixedcheck determines if we want to use the mutation or the synthesizer to fix the model.
in general the isfixedmethod returns true if the mutation makes xfailing tests pass and ypassing tests fail where x 0a n dy .
in practice xandycan be arbitrary numbers as long as x yholds becausewewanttomakesurethealgorithmterminates.
sinceinitially we have a finite number of failing tests and x ymakes sure that fewer tests are failing at each iteration.
the total number of iterations is bounded by the number of initial failing tests.
ifisfixed line returns true then we apply the mutation to m line and set canfixtotrue line .
otherwise we iterate over the ranked suspicious nodes line and try to fix the model us ing the synthesizer.
for each suspicious node in l w ei n v o k et h e synthesizer tocreate holes gener ate candidatefragments explore thesearch spaces andfind apotential patch line .then theal gorithm checks if the patch is a potential fix line .
the isfixed methodinline14issimilartothemethodinline8.ifthepatchisafix then we apply the patch tothe model line with canfixset totrueand exit the inner loop line .
otherwise we invoke thesynthesizeronthenextsuspiciousnodein l.ifthesynthesizer cannotfindafixafterexploringallsuspiciousnodes thealgorithm exitstheouterloop line2 and returnsthelateststateof m. i f the resulting model passes all tests arepair simplifies the model to make it look more natural to the developer.
for exam ple arepairreplaces to none.eats with to because none.eats alwaysevaluatestoan emptyset.
evaluation weevaluatearepairon38realfaultscollectedfromalloyrelease .
amalgam and alloy homework solutions from graduate students.
these faulty models contain various types of faults i.e.
overconstraints underconstraintsandamixtureofboth.wedefine the number of faults as the number of incorrectly modeled alloy paragraphs e.g.
signatures predicates functions and facts.
w ea ddr e s sth ef ollo wi n gr e s e a r c hque s ti on si nth i ss ec ti on rq1.what is the repair efficacy ofarepair?
rq2.how does the quality of arepair generated patches compared tohuman written patches?
rq3.why is arepair unabletofixsomemodels?
.
experiment setting unlikeexistingdatasetsthatisolatefaultsfortherepairtechniques e.g.
defects4j we use the exact human written faulty alloy models as an input to arepair.
we use the ochiai f o r m u l a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france kaiyuan wang allison sullivan and sarfraz khurshid all combinationssearchstrategy base choice search strategy model ast test flt fix status types ss es fl s eg s ee s fix status types ss es fl s eg s ee s addr1 m .
.
.
m .
.
.
arr1 .7e5 .3e5 .
.
.
s 4e4 .
.
.
arr2 m s .4e7 5e6 .
.
.4e3 m s .4e7 .
.
.
bst1 m .
.
.
m .
.
.
bst2 2e17 .6e5 .
.
.8e3 bst3 m s 2e8 4e3 .
.5e3 bempl1 .
.
.
.
.
.
cd1 m 1e4 .
.
.
m s .9e5 .
.
.
cd2 s .
.
.
s .4e5 .
.
.
ctree1 m .
.
.
m .
.
.
dll1 s .9e4 .
.
.
s .7e4 .
.
.
dll2 m s .9e4 .
.
.
m s .6e4 .
.
.
dll3 .7e9 .1e4 .
.
.
dll4 m s .9e4 .
.
.
m s .6e4 .
.
.
farmer1 m s .6e13 .
.6e4 .5e4 fsm1 m .
.
.
m .
.
.
fsm2 m .
.
.
m .
.
.
grade1 s .5e9 1e3 .
.
.
other1 s .
.
.
.7e4 .
.
.
stu1 s .3e4 .
.
.
s .7e6 .
.
.
stu2 s .6e12 .
.
.
stu3 .7e15 .5e4 .
.
.8e3 stu4 s .3e4 .
.
.
s .7e6 .
.
.
stu5 s .3e4 .
.
.
s .7e6 .
.
.
stu6 m s .8e8 4e3 .
.
.
stu7 m s .4e5 1e4 .
.
.
s .3e10 .5e4 .
.
.7e3 stu8 s .4e4 1e4 .
.
.
s .4e4 .
.
.
stu9 m .
.
.
m .
.
.
stu10 s .3e4 .
.
.
s .7e6 .
.
.
stu11 s .4e7 .
.
.
s .4e7 .
.
.
stu12 m s .3e4 .
.
.
m s .7e6 .
.
.
stu13 m .
.
.
m .
.
.
stu14 m s .8e8 4e3 .
.
.
stu15 s .3e4 .
.
.
s .7e6 .
.
.
stu16 .9e5 .
.
.
stu17 s .5e8 .
.
.
stu18 m s .9e9 .7e5 .
.
.1e3 m s .9e9 .
.
.
stu19 s 1e13 .
9e3 figure9 arepair results.timesarein seconds.
denotesnot applicable.
to rank suspicious ast nodes in alloyfl because existing studies show that ochiai is effective.
the expression generator generates different sizes of expressions based on the level ofthe holes in the suspicious ast.
we set the expression size to 3for the deepest level of holes in each suspicious ast.
the expression size increases by 1forholes atdepth d i 1comparedtoholes at depthdiwheredi di up to a maximum expression size of .
for the all combinations search strategy we partitionthe candidate fragments for each hole into parts i.e.
k i in figure and we set the maximum number of combinations of candidatefragmentstoexploreto10000 perlevelofholes .forthebase choice search strategy we set the maximum number of candidatefragmentstoexploreforeachholeto1000.theaunittests we use to validate the patches are automatically generated using mualloy sothattheyareabletodetectallnon equivalentmutant models .
additionally the authors manually inspect the generated tests and add some new tests to cover different cornercases.themanuallywrittentestsaccountfor ofthetotaltests.
wevalidatethecorrectnessofageneratedpatchbybothinspectingthemmanuallyandusingthealloyanalyzertoperformascopeboundedequivalence check.
the human written patches are written with the intention of introducing small perturbationsthat are sufficient to fix the faults.
we terminate arepair once it finds apatch thatpasses all tests.allexperimentsareperformedonubuntu16.04ltswith2.4ghz intel xeoncpu and 16gb memory.
to save space we denotethe all combinationssearchstrategyas acandthebase choicesearch strategy as bcin thefollowing sections.
.
repair efficacy figure9shows the detailed results for arepair.
model ast test and fltshowthename thenumberofastnodes thenumberof testsandthenumberoffaults respectively foreachsubjectmodel.farmer1 is from alloy release .
.
addr1 bempl1 grade1and other1arefromamalgam .therestmodelsarefromgraduate student solutions.
student solutions for the same question share thesametestsuite .
fixshowsthenumberoffaultsasearch strategy is abletofix.
statusshows therepair status.
means the generatedpatchissyntacticallyidentical tothehuman writtenpatch.
means the generated patch is synt actically different but semanticallyequivalenttothehuman writtenpath.
meansthepatchis plausible incorrect but passes all tests .
means arepair fails to generate a patch that pass all tests.
means the repair times out after15hours.
typesshowswhetherthefixrequiresmutations m orsynthesis s .
ssshowsthesearchspacesize whichisdefinedas thesumofthenumberofcombinationsofcandidatefragments including applied mutations for fixes to consider in each iteration.
esis the actual number of combinations or mutations arepair authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated model repair for alloy ase september montpellier france tried.flisthefaultlocalizationtime.
egistheexpressiongenerationtime.
eeis the end to end time.
alltimes are in seconds.
theentireexperimentscontain38faultymodelsand62individualfaults.acisabletofix24modelsand31faults.bcisabletofix modelsand 42faults.additionally actimes out 15h for modelswhilebcfinishesallmodelsin15h.acisabletofix2modelsthatbcisnotabletofix e .g.
other1andstu7.bcisabletofix modelsthatacisnot abletofix including 1plausiblepatchforcd1 e.g.arr1 bst3 cd1 farmer1 andgrade1.
many models requirebothmutationsandsynthesisforacompletefix e.g.
arr2and dll2.
ac s search space ranges from to .9e9 and the maximum size of the explored space is 5e6.
bc s search space ranges from 1to 2e17 and the maximum size of the explored space is .6e5.
we can see that bc explores less of its search space than ac though bc typically has a much larger search space.
in general bc runs faster than ac withthe exceptions of cd1 cd2andstu7.f ora c thefaultlocalizationtimeranges from .3sec to188.9sec and themaximum expression generation time is .
sec excluding timeoutcases.forbc thefaultlocalizationtimerangesfrom1.8secto .6secandthemaximumexpressiongenerationtimeis1.6e4sec.
typically ac times out for models whose expression generation time is large 1000s under bc.
a large expression generation timeisareflectionofarepairproducingalargenumberofexpressions resultinginlargesearchspaces.thismeansthatwhenthereare somany combinations ofcandidate fragments toconsider ac typicallytimesout.incomparison despitethelargenumberofexpressionsproduced bcexploresmuchlessspaceandthusisfaster.however bc can run into its local optimum.
for example the ex plored space for other1is less than for both bc and ac but bc cannot fix the model.
overall ac and bc are complementaryand bc is superior in the sense that it takes less time to run andfixes morefaults.
.
patchquality to answer rq2 wefindthatbcgenerates26patchesthatpassall tests all patches are correct and patches exactly match humanwritten patches .
ac generates patches that pass all tests patchesarecorrect 7patchesexactlymatchhuman writtenpatches and patchisplausiblebutincorrect .
we comparethegeneratedpatchesthataresyntacticallydifferentbutsemanticallyequivalent to human written patches.
in addition to patches for the faulty farmer model figure figure 10compares arepair generated patchesandhuman writtenpatchesfor bst1 aandb cd2 cand d andstu8 eandf .the sortedpredicatein bst1modelsthatthe valueofthecurrentnodeshouldbegreaterthanvaluesofitsleftdescendants and less than valuesofits rightdescendants.
thedeveloperincorrectlyuse n. left torepresentthedomainof n sleftdescendants.
the correct domain should be n.left.
left right as shown in the human written patch.
the generated patch re stricts the domain to be n. left.
right w h i c hm e a n sa l ln o d e s thatcanbereachablefrom nbyfirstfollowingoneormore leftrelationandthenzeroormore rightrelation.the acyclicpredicate incd2models that a class does not transitively extend itself.
the faultymodeldoesnotconsiderthetransitivityrequirement which is fixedinthehuman writtenpatchbyreplacing c c.ext w i th c in c. ext .
the generated patch uses c c c. ext w h i c h a human written patchfor bst1.
.
predsorted alln node .
alln2 n. left n2.elem n.elem .
alln2 n.left.
left right n2.elem n.elem .
alln2 n. right n2.elem n.elem .
alln2 n.right.
left right n2.elem n.elem b arepair generatedpatchfor bst1.
.
predsorted alln node .
alln2 n. left n2.elem n.elem .
alln2 n. left.
right n2.elem n.elem .
alln2 n. right n2.elem n.elem .
alln2 n. right.
left n2.elem n.elem c human written patchfor cd2.
.
predacyclic .
noc class c c.ext .
noc class c inc. ext d arepair generatedpatchfor cd2.
.
predacyclic .
noc class c c.ext .
noc class c c c. ext e human written patchforstu8.
.
predsorted this list .
alln node n.elem n.link.elem .
alln node somen.link n.elem n.link.elem f arepairgenerated patchforstu8.
.
predsorted this list .
alln node n.elem n.link.elem .
alln link.node n.elem n.link.elem figure comparison of arepair generated patches and human writtenpatches.
states that no class is equal to the intersection of the class and all its subclasses transitively.
the sortedpredicate in stu8models a linkedlistsortedindescendingorderofthenodevalues.thefaultymodel does not allow the existence of any list with a single node withoutany link .thehuman writtenpatchallowssuchcasesby stating that if a node nhas a subsequent node following the link then its value should be less than or equal to the value of its sub sequentnode.thegeneratedpatchinsteadmodifiesthedomainto restrictthelessthanorequalrelationonlyapplying tonodesthat have asubsequent node.
the authors check correct patches that are syntactically different from human written patches and find that these patches areeasy to understand in general.
there are rare cases that arepairgenerates some complex expressions that can be further simplified throughsemantic reasoning.
additionally arepair generates a patch which fixes a fact instead of the predicate the developer would fix for ctree1.
.
limitation to answer rq3 we manually inspect all faulty models that arepairisunabletofix.thereasons arecategorizedasfollow the repair requires synthesizing predicate and function calls.
for example one ofthepropertyto fixin bst2requires invoking predicates and functions.
therepair requires moving afielddeclarationfromone signaturetoanother e.g.
bempl1.
the repair requires creation of new syntactic structures.
for example dll3m od e l sap r o pe r t yu s i n gas i n g l eq u a n t i fi e r b u t the model needs two.
stu2has a formula with the structure but the correct fix requires else w h e r e and areformulas.
stu6isoverconstrainedandthefixrequires authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france kaiyuan wang allison sullivan and sarfraz khurshid creatingadisjunctionofanewformulaandanexistingformula.
dll3andstu16have empty predicates and require arepair to synthesize formulasfrom scratch.
bothacandbcsearchstrategiesaregreedyandmayruninto a local optimum.
for example a correct patch of other1requires changing two formulas at the same time and bc runs into a local optimum that leads to a repair failure.
similarly ac runsinto alocaloptimumfor arr1.
we find that the majority of the faults arepair is unable to fix fall under category followed by category .
to handle faults incategory3 wecanaddrepairtemplatesthatintroducenewsyntactic structures if the current version of arepair is not able to find a correct patch.
new search strategies can be designed to addressfaults under category .
from our experiment arepair is able to handle a majority of the faulty models out of and we plan tohandle the limitationsin futureworks.
threats to validity there exists several threats to the validity of our results.
many of the parameters in the implementation and experimental setup were chosen by heuristics.
they may not represent the optimum setofparametervalues.moreover theseparametervaluesmaynot generalize to other unseen faulty models.
arepair s ability to fix faulty models depends on the fault localizationtechnique and the aunittestsuite.ourexperimentresultsmayvaryifweuseadifferentfaultlocalizationtechnique e.g.tarantula .ifthetestsuite is tooweak to capturethe desired modelproperties arepair may givetoomanyplausiblebutincorrectpatches.therealfaultymodels we use in the experiment are limited in the sense that most ofthem are written by graduate students.
so the experiment results maynotgeneralizetofaultymodelswrittenbyexperienceddevelopers.
however we collected our set of subject faulty models tothe best ofourability.
the aunit tests e.g.
the test in figure 1b when written manually canrequiresomeeffort.inthispaper amajorityofthetests are generated by mualloy in which case the manual effortissubstantiallyreduced.ingeneral themanualeffortcanbereduced by writing partialtests that provide valuations for a subset ofthe relations declared in the model.for example thetest in figure1bcanomittheconstraintsonvariousrelations e.g.
state near a n dfar becausetheseconstraintsare irrelevant totheproperty the test is intended to check.
related work arepairisa generate and validate repairtechniquefordeclarative models written in alloy.
the technique is able to fix models withmultiple faults or faults that require fixes at multiple locations.
arepairdoesnothaveanyrepairtemplates insteaditcreatesholes in suspicious ast nodes level by level and can fix different kindsof bugs.
theidea ofcombining mutations from mbfl and a synthesizer to repair faulty programs is new.
the base choice searchstrategyreducestheexplorationspaceandisdifferentfromsearch strategies of existing repair techniques.
the hierarchical caching reduces the input sizes of evaluator calls and is different from ex isting memoization techniques.
next we highlight the main areas ofworkrelated toarepair.generate and validate repair .thegenerate and validate repair techniques apply a set of code transformations to generate program candidates and validate eac h candidate under the given test suite.
these techniques implement different search strategies e.g.
genetic algorithms semantic search random search and adaptive search to explore the immense search space of repair candidates.
researchers also proposed other repair tech niques that remove program functionalities create program variants leverage dynamic program state or focuson improving performance by removing bottlenecks in con current programs .astor is a repair library that implements existing techniques to fix java code.
techniques that prioritize patches are built based on human written code historical data document analysis antipatterns and test generation .
constraint solving repair .t h econstraint solving repair techniques use the semantics of the faulty program and translate therepair problem into a constraint solving problem.
then the con straint solving problem is solved by an off the shelf solver to find a repair that satisfies all inferred specifications.
the constraints canbeinferred fromtestexecutions orsemanticanalysis .
other techniques use formal specifications o ri n f e ri n v a r i a n t s tofixpr og rams.
declarative debugging .
the fundamental idea of declarative debugging is that the programmer or some oracle has an intended interpretation of the program and debuggers can query the programmer to obtain this information.
the debugger compares theintended interpretation of a buggy program with its incorrect actualbehavioron somecomputation.thecause ofthedifference is isolated to a small section of code which must contain a bug.
declarativedebuggingwasfirstintroducedinprolog andthen extendedforfunctionalandlogicprograms .researchers alsodeveloped programrepair techniquefor sql .
alloy.
over the past years many extensions have been built for alloy .
aluminum generates minimal instancestomakeiteasyforuserstoinspect.amalgam allows userstoaskwhyandwhynotarelationexistinanalloyinstance.
asketch provides a sketching framework foralloy.
conclusion thispaperintroducesa generate and validate repairtechnique arepair tofixfaultyalloymodels.arepairleveragesamutation basedfault localization technique an expression generator and a syn thesizer to repair various kinds of faults.
arepair is enumerationbasedanditenbodiestwosearchstrategies i.e.theall combination strategy and the base choice str ategy.
arepair implements variousoptimizations including the useofmodulotest input pruningtoremove equivalentexpressions theconstructionofdependency graphtoreduceevaluatorcalls andtheemploymentofahierarchical cache to reduce evaluator input size.
the experimental resultsshow thatarepair workswell in fixing real faultymodels.