easy modelling and v erification of unpredictable and preemptive interrupt driven systems minxue pan shouyu chen y up e i tian zhang and xuandong li state key laboratory for novel software technology nanjing university china software institute nanjing university china department of computer science and technology nanjing university china department of computing the hong kong polytechnic university hong kong china mxp nju.edu.cn remainxy gmail.com csypei comp.polyu.edu.hk ztluck lxd nju.edu.cn abstract the widespread real time and embedded systems are mostly interrupt driven because their heavy interaction with the environment is often initiated by interrupts.
with theinterrupt arrival being unpredictable and the interrupt handlingbeing preemptive a large number of possible system behavioursare generated which makes the correctness assurance of suchsystems difficult and costly.
model checking is considered to beone of the effective methods for exhausting behavioural statespace for correctness.
however existing modelling approaches forinterrupt driven systems are based on either calculus or automatatheory and have a steep learning curve.
to address this problem we propose a new modelling language called interrupt sequence diagram isd .
by extending the popular uml sequence diagram notations the isd supports the modelling of interrupts essentialfeatures visually and concisely.
we also propose an automata based semantics for isd based on which isd can be transformedto a subset of hybrid automata so as to leverage the abundantoff the shelf checkers.
experiments on examples from both real world and existing literature were conducted and the resultsdemonstrate our approach s usability and effectiveness.
index t erms interrupt driven systems sequence diagrams system modelling model checking.
i. i ntroduction interrupt driven systems where processing is initiated by interrupt requests are gaining popularity since interrupts are a key design primitive for software systems that actively makeinteractions among system components and closely interactwith the environment.
they are commonplace in all stylesof computing platforms including safety critical embeddedplatforms low power mobile platforms and high end infor mation systems .
particularly most cyber physical systemsare interrupt driven since interrupts are an extremely commonform of concurrency that the control software uses to obtainsensor data from its physical environment and enabletimely response to outside stimuli in a power efficient way .
however interrupts can cause problems for many ofthem can happen at an arbitrary time and preempt the runningtasks which adds non determinism and concurrency to thesystems.
this poses challenges to the development of reliableinterrupt driven systems as designers have to explicitly handleunpredictable system behaviour caused by interrupts.
as aconsequence interrupt driven systems are error prone and need extensive efforts for quality assurance.
corresponding author.testing is one of the primary ways to assure the quality of systems.
however existing testing techniques for sequentialprograms or even concurrent programs have notaddressed the problems caused by interrupts adequately.
theyoften cannot identify or capture the concurrency brought aboutby interrupts precisely.
to address this limitation researchershave tried interrupt scheduling algorithms that fire interruptsat proper points of time or suitable test adequacy criteriato guide and evaluate the testing process .
nonetheless testing of interrupt driven systems can still be insufficient.
thegeneration of interrupt requests is usually random and non deterministic and the interrupt handling is often preemptiveand nested which results in that the number of possible systembehaviours grows exponentially in the number of occurredinterrupts while defects related to specific behaviour aredifficult to detect by testing approach .
model checking on the other hand can rigorously verify a system s behaviour by exhaustively exploring the state space ofa software system.
recent studies have noticed the significanceand uniqueness of interrupt driven systems and new modellinglanguages are proposed.
for example interrupt time automata ita are proposed to model multi task systemswith interrupts.
they form a subclass of stopwatch automata where the real valued variables with a rate of 0or are organised along priority levels.
ita are powerful inexpressiveness however we argue that industrial designersmay find them difficult to use.
when modelling with ita designers have to consider all possible interleavings of states as well as the clocks that specify the timing requirements.
onthe other hand uml sequence diagrams offer an intuitiveand visual way of describing interactions among system com ponents and the environment.
they are widely used in industry.according to a survey conducted in sequence diagramswere recognised as one of the most frequently used diagrams and system analysts and programmers admitted that theyrely most on sequence diagrams along with class diagramsto capture requirements and exchange information.
however sequence diagrams are still inadequate to model interrupt driven systems.
interrupts arrival can be unpredictable andtheir handling is preemptive and prioritised.
time could bea complex concept too since the execution time of tasksand interrupt service routines isrs can be interrupted and ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
resumed.
these interrupt specific features are not supported by sequence diagrams.
to overcome these limitations we propose the interrupt sequence diagram isd which extends the sequence diagram with interrupt modelling mechanisms.
the extension adopts the uml standard notation for easy comprehension.
we propose to introduce a new combinedfragment int to specifically model interrupts.
a combinedfragment int can model an interrupt s unpredictable arrival and its handler s prioritised preemptive execution.
as for time tasks isrs in interrupt driven systems can often be preempted during execution which means the actual execution time does not equal to the time duration from the beginning to the completion of the tasks isrs.
considering that the uml sequence diagram only supports the latter form of timing constraints which is not sufficient for interrupt driven systems we propose a new kind of timing constraints called task constraints to model the actual execution time of tasks isrs.
to facilitate formal verification we also provide an automata based semantics for isd.
we use integration automata ia a subset of hybrid automata to interpret the semantics of isd which also enables the employment of the abundant off the shelf hybrid automata checkers for verification.
we conducted multiple case studies with the state of the art tool spaceex and the experiment results consistently showed that our approach can effectively find defects.
particularly we believe that the best trait of isd is that it is easy to learn and use and therefore we conducted an experiment to compare the usability of isd and ita.
the results confirmed isd s good usability.
the main contributions of this paper are we propose a novel modelling language isd to specify the interrupt driven systems.
to our best knowledge isd is the first sequence diagram based language which supports the specification of interrupt s unpredictable arrival prioritised preemptive handling and the time suspension and resumption we propose an automata based semantics for isd based on which isd can be transformed to hybrid automata for correctness checking we developed a tool named isdchecker which is to our knowledge the first available tool that checks graphical models for interrupt driven systems.
evaluation on previous studied and real world cases shows isdchecker s effectiveness and usability.
the rest of the paper is organised as follows.
in the next section we introduce the uml sequence diagram and a modelling example.
section proposes the isd s notation and section presents its automata based semantics.
section conducts a series of experiments to evaluate our approach s usability effectiveness and efficiency.
section discusses the related work and section draws the conclusion.
ii.
s equence diagram and motiv a ting example uml sequence diagrams form a class of important uml interaction models.
each of them describes a set of interactive scenarios as fig.
shows an example.
there are twosd satellite spin gu tt cu cc e0e1 e2e3 e5e4 e7e6 e8e9 loop e10e11 e12e13m1 m2 m3 m4 m5 m6 m7 fig.
.
a sequence diagram example dimensions in a sequence diagram.
the vertical dimension represents time and the horizontal dimension consists of different lifelines representing participating entities.
information exchange between lifelines is carried out by messages represented by arrows.
in the simplest form a sequence diagram depicts the desired exchange of messages and corresponds to a single execution of the system.
to specify complex scenarios conveniently sequence diagram supports operations such as choice and iteration through combinedfragments or fragments for short .
a fragment is defined by an interaction operator and one or more interaction operands.
the notation for a fragment is a solid outline rectangle and the operator is shown in a pentagon in the upper left corner of the rectangle.
each operand is composed of a subset of messages in the diagram.
in this paper we consider three most frequently used interaction operators which are loop altand opt.
the operator loop designates that the fragment represents a loop so its operand will be repeated a number of times.
a guard that may include a lower and an upper number of iterations of the loop can be associated with the fragment.
fig.
shows an example of the loop fragment where the iteration times is restricted from to times.
the operator alt designates that the fragment represents a choice of behaviour.
at most one of the operands will be chosen and the chosen operand must have a guard expression that evaluates to true at this point in the interaction.
the operator opt has a similar meaning as the operator alt except that it has only one operand.
the fragment opt specifies the behaviour where either the operand happens or nothing happens.
in this paper we enforce strict sequencing on the fragments.
consequently a fragment will cover all lifelines so that when the execution control of flow enters a fragment all lifelines enter the fragment.
sequence diagrams are popular in industry because they help designers focus on the most frequent or critical scenarios.
however they are insufficient to model interrupt driven systems.
to support this claim we present a real world case of designing the spin action in a satellite controlling system.
the original sequence diagram provided by the designers was an informal sketch which we revised to conform to the uml standard and to exclude sensitive information.
as shown in fig.
the spin action involving four participating authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
entities consists of three operations.
in the first operation the command centre cc sends an inquiry to the satellite s computing unit cu about the status of the satellite message m1andm2 .
then in the second operation cu informs cc that it is going to produce the instructions for the satellite to spin an angle to better absorb sunlight and in the meantime will not response to cc commands message m3 .
then cu sends the instructions to the thruster tt to be executed message m4 and tt acknowledges cu when the spin action is completed message m5 .
in the third operation the satellite communicates with the ground unit gu periodically to exchange information message m6andm7 .
the communication cannot be interrupted by other operations or the communication link would be lost.
should the interpretation of the diagram in fig.
strictly follow the uml specification the system should be running without problems because in a uml sequence diagram events corresponding to message sending and receiving are subject to predefined partial orders deduced from the visual order of the diagram see for more details about the partial orders among events .
thus in fig.
e4would be considered to happen after e2 and e10after e9 which means the three operations happen in sequential order.
however this sequence does not cover all the actual system behaviours.
in reality the operation of cc querying cu and the operation of cu communicating with gu are both interrupts so their arrivals are unpredictable.
even worse the former has a higher priority than the latter which means that the inquiry from cc to cu is not obliged to happen before cu and gu s communication but can interrupt the communication process and cause a problematic behaviour.
the engineers had not noticed the problem and implemented the system as designed which resulted in a costly failure during the system integration test.
to prevent this kind of disaster it is expected that the problematic behaviour be captured by the designs and found by some sort of checking methods.
unfortunately because of the partial orders enforced on the events it is impossible for a uml sequence diagram to specify unpredictable interrupts.
in the following section we propose a smooth extension to the uml sequence diagrams to allow the specification of unpredictable and preemptive interrupt driven system behaviours.
iii.
i nterrupt sequence diagram the interrupt sequence diagram isd is an extension of the uml sequence diagram to model interrupt driven systems.
we notice that the occurrences of interrupts are often spontaneous and unpredictable and therefore propose a new fragment called int consisting of one operator and one operand to model interrupts.
the operator int declares that the fragment represents an interrupt behaviour whose syntax is int angbracketleftpriority exp angbracketright .
priority exp models the interrupt s priority occur bound specifies the times the interrupt can occur and the separation in time between two consecutive interrupt arrivals and mask cond models the interrupt mask condition.
in the following we give detailed explanations about different parts of the int fragment.isd satellite spin gu tt cu cc e0int p query e1 e2e3 e5e4 comp flag e7 comp flag e6 e8e9 int p comm e10e11 e12e13 .
e2 e1 .
e8 e7 .
e3 e0 .
e6 e4 .
e11 e10 e13 e10 .
e9 e8 .4m1 m2 m3 m4 m5 m6 m7 fig.
.
an interrupt sequence diagram example a. order of events the events in the operand of the int fragment specify the execution process of the interrupt arrival and handling.
as an event will not belong to two interrupts no overlapping of two int fragments is allowed.
to depict interrupt s unpredictability it is required that there should be no partial orders deduced from the visual orderings of messages between the events from inside and outside an int fragment respectively.
for example in fig.
e2ande4are two events inside and outside an int fragment respectively and thus there is no ordering requiring thate2occur before e4.
to specify the prioritised preemption of interrupts a priority expression is proposed defined as angbracketleftpriority exp angbracketright p angbracketleftpriority angbracketright where angbracketleftpriority angbracketright non negative natural .
the priority of the int fragment comes from the priority of the interrupt and applies to all the events in the fragment.
to be consistent we assign a default priority to the entire diagram which applies to events not in any int fragment.
in fact excluding the int fragments the entire diagram with its enclosed loop alt andopt fragments can also be viewed as a fragment except its priority is the lowest.
from now on we use the term interaction fragment indiscriminately to represent theint fragment or the diagram excluding all int fragments.
the priority of the interaction fragments introduces a new kind of orderings among events when the execution control of flow is in an interaction fragment of priority p1 it can move to another interaction fragment of priority p2ifp2 p but not vice versa.
formal semantics of the int fragment is presented in sec.
iv b4.
let us revisit the example of the satellite spin and re model it with isd as shown in fig.
.
there are two int fragments query and comm.
query has a priority of and comm has a priority of .
so events in int comm can occur after the occurrence of e10and before the occurrence of e12 causing the communication between cu and gu to fail.
with the help ofint fragments a defect of the design can be revealed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. interrupt mask designers often use interrupt masks to prevent some less important interrupts from interfering with more crucial tasks.
the isd supports modelling the interrupt masks by using mask variable updates and tests.
each interrupt mask is modelled by a mask variable with a value from .
the enablement or disablement of the interrupt mask is achieved by setting the variable s value to 1or0 respectively.
in uml sequence diagrams the values of variables are updated via actions associated with messages whereas in isd we need a more accurate mechanism to model mask variables since the enablement disablement of interrupts always happens at the beginning or the end of uninterruptible operations.
thus the isd supports variable updating actions to be associated with events since it is the events that represent the beginning and the ending of message processing.
anint fragment can have mask conditions which are defined as angbracketleftmask cond angbracketright angbracketleftmask variable angbracketright where angbracketleftmask variable angbracketright letter tokens .
the events in the int fragment can happen when all mask conditions are evaluated as1 or no mask condition is provided.
for example the int fragment comm in fig.
has one mask condition comp flag .
therefore the events in this fragment can happen when variable comp flag is set to .
c. modelling of time the other mechanism to reduce the unpredictability imposed by interrupts is the timing specification.
timing specification can specify the timing properties of the system.
designers can designate the time point or interval in which an interrupt could happen or the duration of the interrupt handler to restrict interrupts behaviour and reduce their uncertainty.
for example suppose that a system consists of one uninterruptible task and one interrupt.
if some timing constraints specify that the interrupt would not occur during the execution of the task no interrupt mask would need to be disabled which could save the computing resource and time.
in uml sequence diagrams the timing mechanisms are all about the time duration between two events which specifies how much time has passed from the occurrence of one event till the other.
by using event names to represent the occurrence time of events the timing constraint can be defined as a e e prime b a b are real numbers bmay be which requires that the time duration from the occurrence of e primetill the occurrence of ebe within the range .
although this kind of timing constraints is sufficient for most systems they cannot meet the need to specify interrupt driven systems.
the designers of interruptdriven systems often need to specify the actual execution time of a task however it is not the time duration between the task s start and completion events for its execution can be interrupted by unpredictable interrupt occurrences.
for example in the satellite spin example in fig.
although one may know that executing the interrupt comm from the occurrence of e10to that of e13 requires 2to5time units it is incorrect to model this time information using e13 e10 because the execution of comm can besuspended by query .
we provide a new mechanism called task constraint .
a task constraint denoted as a e e prime b is about two events eande primesatisfying that both events are from the same interaction fragment f. the value of e e prime is computed as the time duration from the occurrence of e primetill the occurrence of e subtracting the time when the diagram s execution control of flow is not in f. for example the task constraint e13 e10 5in fig.
specifies the time that the execution control of flow stays in the fragment comm is between to time units.
formal semantics of timing and task constraints are given in section iv b5.
furthermore it is possible to specify the minimum and maximum times an interrupt can occur and for interrupt that can occur multiple times the minimum separation in time between two consecutive interrupt arrivals.
we use the expression occur bound to specify these timing requirements which is defined as angbracketleftoccur bound angbracketright angbracketleftmin angbracketright angbracketleftmax angbracketright where angbracketleftmin angbracketright positive natural angbracketleftmax angbracketright positive natural greater than or equal to angbracketleftmin angbracketright angbracketleftseparation angbracketright positive real .
without an explicit occur bound the interrupt is supposed to occur exactly once by default and without the separation field provided arbitrary separation time positive real is allowed.
for example the occur bound of the int fragment comm specifies that it can occur to times and the minimum separation time can be arbitrary.
d. isd syntax now we can formally define the syntax of isd as follows.
definition an interrupt sequence diagram isd is a tuple d l e m r v u f c where lis a finite set of lifelines eis a finite set of prioritised events whose elements are pairs e p where eis the event and pis its priority.
mis a finite set of messages.
for each m m m e e prime where e e prime ecorrespond to the sending and the receiving of m respectively r e lis a labelling function which maps each event e eto a its sending receiving lifeline r e l vis a finite set of message orderings whose elements are a pair m m prime m m prime m such that mvisually precedes m prime uis a finite set of mask variable updates whose element is a tuple var val e where var is a variable val is the updated value and e eis the event associated with the variable update f floop falt fopt fint is a finite set of fragments.
each element f fis a tuple o g m f where o loop alt opt int is the operator gis the guard expression of f and mf 2mis a subset of m cis a finite set of timing constraints and task constraints.
iv .
ia b ased semantics we define an automata based semantics for isd to facilitate formal verification.
the semantics of isd is interpreted by integration automata ia which are a special case of hybrid authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automata.
in this section we will first visit the concept of ia followed by the presentation of the semantics definition.
a. integration automata hybrid automata are finite automata extended with a finite set of real typed variables whose values change continuously at each location.
the change rates of the variables are designated by the flow conditions associated with locations.
there are also invariants in each location indicating that the conditions need to be satisfied when the location is active.
transitions between locations are guarded by jump conditions on the variables and their executions may reset some of the variables by the reset actions .
if the invariants jump conditions and reset actions are all linear expressions over the variables and the flow conditions specifying the allowed values of the first derivatives of the variables are either 0or1 then the hybrid automata are called integration automata.
we can see that the restriction on flow conditions of integration automata makes it suitable to model time suspension and resumption.
formal definitions of the integration automata can be found in .
b. isd semantics we follow the generally agreed semantics of the basic fragment and the alt opt andloop fragments.
furthermore we define the semantics for the int fragment task constraints and mask variables designed for modelling interrupts.
a common approach to interpreting sequence based diagrams using automata is to use one automaton for every object and their parallel composition for the whole diagram .
the composition requires the synchronisation between different object automata which is achieved by using synchronisation labels corresponding to the message names.
since transitions with the same synchronised label must happen simultaneously it is impossible to distinguish the message sending and receiving events over time.
in interrupt driven systems the time duration between events plays a vital role in correct system functions.
thus in contrast to this approach we propose to use fragment as a basic unit for semantics interpretation similar to .
algorithm algorithm of constructing an automaton for a basic fragment 1construct the initial location q0 2for each non final location qthat has no outgoing edges do acquire the set lof events in the path from q0toq for any event e e l do ifany event e primesatisfying e prime e ois in lthen construct a location q primeand a transition q e q prime for any location q prime prime q prime prime negationslash q prime do l prime set of events in the path from q0toq prime l prime prime set of events in the path from q0toq prime prime ifl prime l prime primethen q prime prime merge q primeandq prime prime change q e q prime to q e q prime prime end end ifqhas no outgoing edges then mark qas final 17endobjaisd basic m1objb objc e1 e2 m2e4 e3 q0 q1q2 q3q4e1e2 e3e3 e2 q6e4 e4q5e2 fig.
.
a basic fragment and its corresponding automaton the basic fragment the simplest form of isd is a basic fragment that does not have any nested fragments.
the behaviour of a basic fragment is a set of event sequences which are permutations of events satisfying a partial order relation of events deduced from the visual orderings.
so to interpret the behaviour of a basic fragment we can use an automaton of which the set of event sequences along all paths is equivalent to the set of event sequences of the fragment.
given a basic fragment let ebe its event set and obe the set of event orderings where e e primeindicates that emust occur before e prime.
algorithm takes eandoas its input and outputs an automaton to interpret the fragment.
it focuses only on the event sequences while the timing and task constraints are handled in sec.
iv b5.
we use an example to explain the algorithm.
fig.
shows the example of a basic fragment and its corresponding automaton.
the fragment has a set of events e e1 e2 e3 e4 and a set of event orderings o e1 e2 e1 e3 e3 e4 .
suppose we follow algorithm and has constructed a part of the automaton which is drawn in thin lines.
now for location q3 we acquire the set l e1 e3 which comprises events in the path from q0toq3 line .
following line we pick event e2because it is in e l. since e1is already in l the condition in line is satisfied and a location q primeand a transition q3 e2 q prime is constructed line .
location q primeis not shown in fig.
because when executing line we find that the set of events in the path from q0toq primeis the same as from q0toq4.
since q4is an existing location we merge q primeintoq4 line and change q3 e2 q prime to q3 e2 q4 line .
then we loop back to line pick event e4 and construct new locations and transitions in the same manner.
when q6is picked since there are no events left for q6to grow outgoing edges we mark it final.
obviously for the constructed automaton there is only one initial location and it is easy to prove that there is only one final location as follows.
suppose there are more than one final location.
since the events along each path to the final locations are all the same the final locations can be merged as one.
guaranteeing that there is only one initial location and one final location is useful when the automaton needs to be connected with other automata to interpret nested fragments.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
isd ioop obja objb loop e2m1e1c c c c e1q0 q1 e2c qf q ft0 t1 t2tf tb fig.
.
a loop fragment and its corresponding automaton the loop fragment we require a strict sequencing for the loop fragment which means that the events in one iteration can happen only when all the events in previous iterations have happened.
if the loop fragment contains just one basic fragment we interpret it with the automaton a constructed by algorithm with the following modifications.letq 0be the initial location and qfbe the final location ofa.
the automaton alinterpreting the loop fragment is constructed based on aas follows add a new transition tbfrom qftoq0to form loops construct a new location q prime f and add a new transition tf from q0toq prime f. make q prime fas the final location and qfas the non final location use a variable cto count the iteration times.
initialise c to on the transition to q0 and increase cb y1o nt b for the guard a b restricting the iteration times assign a constraint c b totb and a constraint c atotf.
fig.
shows an example.
for the isd in fig.
locations q0 q1andqfand transitions t0 t1andt2constitute the automaton obtained by applying algorithm .
transition tbis added to form the loop and its condition c 5ensures that the iteration times will not exceed this condition is checked before theincrease of c .
location q prime fand transition tfare added so that when exiting the loop there is a condition c 3ensuring that the iteration times will be at least .
if there are other fragments nested the interpretation can be done from inside to outside recursively.
specifically foran enclosing fragment that has nested fragments we firstinterpret the nested ones.
without the nested fragments the rest of the enclosing fragment is divided into separate parts which are later interpreted individually.
then the automatoncorresponding to the entire fragment can be obtained byconnecting one automaton s final location to the other s initiallocation following the visual orderings of the nested fragmentsand the parts they separated in the enclosing fragment.
theonly exception is that the nested fragment is an int fragment which will be discussed in sec.
iv b4.
the alt andopt fragments in the alt fragment each operand has a guard condition.
the events in an operand canhappen only if the guard of this operand is true when the control of flow reaches the fragment similar to the if else structure in programming languages.
to interpret an alt fragment we first use two automata a1anda2for the twoisd alt obja objb alt e2m1e1 e1q0 q1 e2 q2t1 t2 e4m2e3 e3q3 q4 e4 q5t3 t4qi qfx x ti1 ti2 tf1 tf2 fig.
.
an alt fragment and its corresponding automaton operands o1ando2 respectively and then compose them into a single one as follows construct a location qiand add transitions ti1andti2from qito the initial locations of a1anda2 respectively construct a location qfand add transitions tf1andtf2 from the final locations of a1anda2toqf respectively add the guard condition of o1to transition ti1 and that ofo2to transition ti2 make qithe initial location and qfthe final location of the composed automaton.
an example is shown in fig.
.
the parts in dotted boxes are the two automata interpreting the two operands of the alt fragment.
the reason we use two new location qiandqfis to ensure that every automaton corresponding to one fragmenthas only one initial location and one final location to simplifythe interpretation of nested fragments.
the opt fragment can be viewed as a special case of the alt fragment with only one operand.
its interpretation is more straightforward the operand is interpreted first and the guardcondition is added to the initial transition to the initial location.
the int fragment since the occurrence of interrupts is unpredictable it is required that the events in the int fragment have no partial orders with events outside the fragment.
inother words the events in the int fragment and the enclosing fragment form two independent event sets and therefore the int fragment and its enclosing fragment can be interpreted separately.
in interrupt driven systems when an interrupt request occurs it is accepted when its priority is higher than the currenttask and the interrupt mask if there is any is enabled.
whenthe preemptive interrupt completes it returns the control ofexecution to the preempted task if there is no interrupt requestof higher priority.
we refer to this interrupt handling mech anism to interpret the relationship between the two automata corresponding to an int fragment and its enclosing fragment.
letai qi0and qifare the initial and final locations respectively be the ia interpreting an int fragment and ae qe0andqefare the initial and final locations respectively be the ia interpreting its enclosing fragment.
it is assumed that all events in aehave lower priorities than those in ai which can be guaranteed by composing the automata corresponding int fragments in ascending order of priorities.
then the ia authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
isd int obja objb int p e2m1e1 e1qe0 qe1e2ae e4m2e3x n e3 e4x n 2x n n 1n n 3qef qi0 qi1 qifai fig.
.
an int fragment and its corresponding automaton e1 e2 1 e3 e4 2 1 1 2 1 1 2 1 2 0 1 2 0 1 2 0c1 c2 0c1 c2 5qe0 qe1 qef qi0 qi1 qif fig.
.
interpretation of task and timing constraints ahaving the equivalent behaviour as the isd consisting of both the int and its enclosing fragments can be obtained by composing aiandaeas follows for any location qiofae add a transition from qitoqi0 ofaiand associate it with a variable assignment n i and the interrupt mask condition of the int fragment if there is any for any location qiofae add a transition from qifto qiand associate it with a guard condition n i make qe0andqefas the initial and final locations of a respectively.
in the example shown in fig.
the two parts in dotted boxes labelled with aiandaeare the automata corresponding to theint fragment and its enclosing fragment respectively.
in a location of ae e.g.
qe1 the control of flow can transfer toai provided that the interrupt mask xequals to .
the assignment n on the transition from qe1toqi0ensures that when exiting from ai the control of flow would return toqe1by taking the transition with guard condition n .
the timing and task constraints besides the common timing constraints the isd offers the new notion of task constraints.
whereas timing constraints can be easily interpreted by clock constraints in timed automata the task constraints are beyond the expressiveness of the classic clock constraints.
suppose that we have a task constraint a e e prime b. when the control of flow is not in the fragment to which eande primebelong the clock needs to freeze which means a change in the clock flow rate.
fortunately the ia supports this change of rate for variables.
for each timing constraint a e e prime b we use one variable cto represent a clock.
we make the initialisation c 0at the transition with label e prime and set a flow condition c in every location.
at the transition with label e the value of c equals to the time duration e e prime so we add the jump conditiona c bto the transition.
fig.
shows the same automaton as the one in fig.
with the addition of the interpretation of the timing and task constraints assignments and conditions irrelevant to time are omitted .
suppose for the isd in fig.
there is a timing constraint e2 e1 10specifying that the deadline for the completion of transferring message m1should within time units and a task constraint e2 e1 specifying that the actual time for transferring m1takes to time units.
then for the timing constraint e2 e1 w e generate a variable c1 initialise c1on the edge labelled with e1 and add a constraint c1 10on the edge labelled with e2.
the flow condition of c1is set to c1 in all locations.
for each task constraint we also generate a variable c primeand initialise it to 0at the transition labelled e prime.
different than the timing constraints the variable c primedoes not increase in all the locations but only in those corresponding to the interaction fragment to which eand e primebelong recall that the term interaction fragment can represent either the int fragment or the diagram excluding all int fragments .
therefore locations corresponding to the interaction fragment to which eande prime belong are equipped with a flow condition c prime while other locations are equipped with a flow condition c prime .
in this way when reaching the transition with label e the value of the variable c primewould represent the actual execution time that the control of flow stays in the same interaction fragment between the occurrences of eande prime so the jump condition a c prime bcan be added to that transition.
for example for the task constraint e2 e1 a variable c2is used and initialised on the edge labelled with e1 and a constraint c2 5is associated with the edge labelled with e2.
the flow conditions in locations qi0 qi1andqifcorresponding to the int fragment are set to c2 and in locations qe0 qe1andqefcorresponding to the enclosing fragment are set to c2 .
c. specification and v erification of properties whereas the isd models how the system behaves the properties to be checked are captured by property specification.
for isd the property needs to specify both temporal orderings and time durations between events.
motivated by our goal of easy modelling and verification we propose a simple specification language defined as angbracketleftspec clause angbracketright angbracketlefte1 angbracketright angbracketlefte2 angbracketright angbracketleftmin angbracketright angbracketlefte2 angbracketright angbracketlefte1 angbracketright angbracketleftmax angbracketright where angbracketlefte1 angbracketright event name angbracketlefte2 angbracketright event name e2 negationslash e1 angbracketleftmin angbracketright non negative real angbracketleftmax angbracketright non negative real greater than or equal to angbracketleftmin angbracketright .
a specification is composed of one or more spec clauses.
e1 e2specifies that e1occurs before e2in temporal order andmin e2 e1 max specifies that the time duration from the occurrence of e1to that of e2is between time units.
the specification language is sufficiently expressive in specifying various properties in interrupt driven systems.
for example for the property of timeout freeness one can use0 e2 e1 bound to specify that for a task starting by event e1and completing by event e2 it shall not exceed the given time bound.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the verification is to check whether there is a behaviour in the ia that can reach the final location and satisfies the negation of the properties and if so the properties are not satisfied and a counterexample represented by the behaviour is reported.
for a property of the form e1 e2 its negation is e2 e1 and we first find all paths in which e2occurs before e1and then check if any behaviour of such paths can reach the final location.
for a property of the form min e2 e1 max its negation is e2 e1 m i n ande2 e1 m a x if max negationslash .
we translate the negation to clock constraints add them to the ia and check if there is a behaviour that reaches the final location.
the checking of the existence of behaviours reaching the final location is essentially a reachability analysis problem and can be solved by exploiting the existing hybrid automata checkers.
v. e xperimental ev alua tion we implemented our approach as a prototype called isdchecker which supports the modelling and verification of isd.
the graphical modelling interface is based on umlet which is a free open source uml tool.
the verification is conducted by transforming the isd to an ia based on the isd semantics and feeding the ia to spaceex which is a state of the art tool for verifying safety properties of hybrid systems.
note that there is no restriction of the choice of hybrid automata checkers so long as the verification of ia is supported.
our approach of modelling and verifying interrupt driven systems with isds aims to guarantee the correctness of the systems.
ideally it should be effective in finding counterexamples and at the same time easy to use.
therefore our evaluation addresses the two following research questions rq1 can our approach effectively detect problems in interrupt driven system models?
rq2 is isd easy to use compared with existing modelling languages for interrupt driven systems?
a. rq1 approach efficacy to conduct the experiments we searched papers published after year using keywords interrupt driven interrupt program interrupt software interrupt system embedded system or real time system combined with keywords verification testing analysis or model checking and collected closely related to interrupt driven system papers from whose