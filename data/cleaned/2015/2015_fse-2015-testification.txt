witness validation and stepwise testification across software verifiers dirk beyer1 matthias dangl1 daniel dietsch2 matthias heizmann2 andreas stahlbauer1 1university of passau germany2university of freiburg germany abstract it is commonly understood that a verification tool should provide a counterexample to witness a specification violation .
until recently software verifiers dumped error witnesses in proprietary formats which are often neither human nor machine readable and an exchange of witnesses between different verifiers was impossible.
to close this gap in softwareverification technology we have defined an exchange format for error witnesses that is easy to write and read by verification tools for further processing e.g.
witness validation a nd that is easy to convert into visualizations that conveniently let developers inspect an error path.
to eliminate manual inspection of false alarms we develop the notion of stepwise testification in a first step a verifier finds a problematic program path and in addition to the verification result false constructs a witness for this path in the next step another verifier re verifies that the witness indeed violates the specification.
this process can have more than two steps each reducing the state space around the error path making it easier to validate the witness in a later step.
an obvious application for testification is the setting where we have two verifiers one that is efficient but imprecise and another one that is precise but expensive.
we have implemented the technique of error witness driven program analysis in two state of the art verification tools cpachecker andultimate automizer and show by experimental evaluation that the approach is applicable to a large set of verification tasks.
categories and subject descriptors d. .
software engineering software program verification general terms theory verification keywords error witness counterexample validation software verification program analysis model checking .
introduction software verification becomes more and more important in practice several breakthroughs in verification research were achieved during the last decade and several successful verification tools were developed.
the tacas international com petition on software verification sv comp serves as a showcase of the state of the art.
users can choose from a wide range of verifiers and the sv comp categories give an approximate guidance on which verifier is good for which kind of programs.
one important and unsolved problem of applying verification technology in practice is that verification tools sometimes produce false alarms and it still requires an enormous manual effort to find out if a reported bug indeed represents a genuine specification violation.
our solution comprises two components we developed anexchange format for error witnesses and evaluated its effectiveness by a thorough experimental evaluation and we develop the notion of stepwise testification as the technique of witness validation immediately leads to the notion of witness refinement enabling a chain of verifiers or testifiers to continuously refine the erroneous state space until a test vector for the error is found.
testification is the process of giving evidence for a claim that a given program satisfies or violates its specification.
the evidence of the absence or presence of a specification violation is given by one or more witnesses.
a verification tool is a testifier if it provides evidence to support its claim i.e.
if it produces a witness for correctness or for a violation of the specification.
stepwise testification is the process of applying testification in several steps on ever refined witnesses possibly using different verification tools combining different strengths.
figure illustrates the process of stepwise testification.
in this paper we focus on stepwise testification of specification violations by producing error witnesses left part while conditional model checking focuses on stepwise testification of correctness.
we accompany the bug report of verifier v1with an error witness which represents information that can effectively guide another verifier v2to efficiently re explore the state space that verifier v1reported to contain a bug.
our experimental study confirms the following insights our exchange format makes it possible to communicate error witnesses across verifiers verifier v2needs on average considerably less resources to validate the witness than verifierv1needed to find the error even if v2uses a more expensive verification technology e.g.
v1using linear and v2 using bit precise arithmetic stepwise testification ca n be more efficient than verification i.e.
the cpu time for v1 verification v2 witness validation can be less than the cpu time for v2 verification alone the state space to be analyzed by v2is effectively reduced.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
721our technique was already used in the most recent edition of the competition on software verification.
the sv comp community manifested in the competition rules that each answer falsemust be accompanied by an error witness.
previously only the existence of an error witness was checked but not its meaning .
the last edition of the competition rules required the organizer to reasonably validate each witness in order to get more confidence that the error witness indeed represents a valid bug before assigning a success score.
on the syntactic level we use xml more specifically graphml as a language to represent error witnesses.
on the semantic level we use the standard concept of nondeterministic finite automata to represent an error witness.
a witness automaton observes the paths that the verifier explores and directs the exploration engine along the paths that the witness describes i.e.
towards the violation of the specification.
witnesses can be read by humans perhaps using a visualization or inspection tool or a witness valid ator.
witness automata allow different levels of abstraction.
a most abstract error witness automaton allows all paths through the program i.e.
it does not restrict the statespace exploration.
a most concrete error witness automaton represents one concrete error path which is annotated with value assignments for all variables i.e.
a concrete test vect or is represented .
many interesting witnesses occur in between the two extremes there is a continuous spectrum of refined witness automata reducing the number of possible choices through a program until the most concrete level the test vector is reached.
sometimes it is efficient to represent several or even infinitely many error paths in one witness.
contributions.
we make the following novel contributions we develop a syntactical exchange format based on xml for exchanging and archiving witnesses across software verifiers and instantiate the format for c programs.
we introduce witness automata as a semantical basis from which a program analysis can be constructed as an extension for existing verifiers two examples given .
our approach validates witnesses against the given program and specification independently from the computing resource and verifier used to produce the witness i.e.
neither this resource nor this verifier need to be trusted.
we develop the notion of stepwise testification which continuously refines witnesses using different verifiers or different approaches on perhaps different platforms.
we provide an extensive experimental evaluation that shows the potential and feasibility of using error witnesses and stepwise testification.
advantages and applications.
our solution has various application scenarios in research and industry for example witness validation can be used to automatically eliminate false alarms in program analysis e.g.
as used in .
a common exchange format can boost the development of various tools for collecting correlating explaining and visualizing error witnesses from different sources.
error witnesses can accompany bug reports.
it is sound to use untrusted computing resources and verification engines if followed by witness validation on trusted computing resources and trusted witness validators.
this is especially interesting for verification in the cloud.
different verification approaches and tools have different strengths and thus it is interesting to combine different verification approaches via stepwise testification.stepwise testification error t esti fication step error t esti fication step kconditional model checking kconditional model checking false violating t est vectortrue correctness proof... ... figure stepwise testification conceptual view testificationreached error1 concrete paths iterationpstepwiset esti fication nn 1r figure testification reduces the state space left and the number of paths right that need to be re verified.
error witnesses can describe program parts that should be covered by a regression test suite.
witness validation implies a notion of witness quality a more concrete witness less resources needed for validation might be considered better than an abstract witness.
figure left illustrates how testification gives evidence of the presence of a specification violation by reducing the state space that the witness validator needs to verify i.e.
the state space to be explored gets narrower.
figure right illustrates that testification reduces the number of paths tha t the witness validator has to verify.
for example given a program that contains rerror paths an error witness might represent more paths e.g.
ppaths including some infeasible error paths but testification might further refine such an error witness until only one concrete path is represented e.g.
in iteration n .
testification might also find out that all paths of the witness are not violating the specification error witness rejected cf.
iteration n .
example.
we illustrate how error witnesses are validated and refined across verifiers we start with an overview of the process and then describe the process of producing and consuming error witnesses in more detail.
we run three verifier instances in sequence.
each of them takes the program shown in fig.
3a as input and produces an error witness.
the specification of the program is that neither label error1norerror2is reachable from the program entry.
the first verifier runs an analysis based on predicate abstraction with counterexample guided abstraction refinement cegar and produces the error witness in fig.
3b.
the second verifier takes this witness and the program as input and runs an analysis based on an interval domain and produces the error witness in fig.
3c.
in the last step we run a test case generator that takes the error witness from fig.
3c as input and produces the test vector in fig.
3d witness .
before we continue with the example we will informally introduce several basic concepts.
we model the program as a control flow automaton cfa its locations represent 7221int foo int s int t 2int d s t 3if d d return 6int x nondet int 7int a x ?
8int b a d 9if b error1 exit 12if b error2 exit 15while a a code omitted 19return b a source codeq0start q1 q2q qe1 qe2 q else o w then o w else then then o w else b witness 1q0start q1 q2 qe1q q then d d o w3 else d d o w a a o w else b b then b b c witness 2q0start q1 q2 qe11 s t o w x o w o w d witness figure example c program a and a testification sequence of three witne ss automata accepting control states are drawn as double circles sink states are labeled with the subscript non accepting control states are drawn as single circle.
program counter values we denote the location before the operation on line iasli and its edges represent program operations.
error witnesses are represented as finite automata that describe a set of program paths that should contain at least one path that violates the specification.
paths that en d in a sink control state not accepted by the witness automaton should not be explored by a verifier that consumes the witness during witness validation .
in our figures each transition of a witness automaton has a label which is divided into two parts by colon the first part is the source code guard which is used to matchthe control flow and can be given e.g.
as a line number.
the second optional part is thestate space guard given as a c expression which is used torestrictthe abstract successor state of an analysis i.e.
the set of concrete program states that it represents.
the exploration of the state space can be restricted either by transitions to sink control states that have no outgoing transitions and thus the path exploration ends or by restricting the state space using state space guards at transitions.
a state space guard needs to be checked if the corresponding source code guard matches the current control flow edge.
we only consider analyses that construct reachability graphs of abstract states.
in our example an abstract state is a tuple q l e that is composed from the current state qof the witness automaton the current location lof the cfa and a component ethat represents the information that is tracked by the chosen abstract domain for example the interval domain or the predicate abstraction domain .
the analysis that consumes a witness automaton proceeds along those cfa edges that match transitions of the witness automaton.
the first witness automaton is produced by a verifier with predicate abstraction cegar and lazy abstraction .
the analysis detects that taking thethen branch in line cannot lead to a violation of the specification and thus writes a transition to the sink stateq with source code guard then and similarly for theelsebranch in line .
the multiplication in line is overapproximated by the analysis this predicate analysisuses linear arithmetics and thus it reports paths to both error locations.
despite the infeasible error path that is included in the witness the loop of lines has already been analyzed i.e.
a successive witness validation can ig nore the loop completely.
in the next testification step the error witness in fig.
3b is validated by a verifier that runs an interval analysis.
the verifier starts with the abstract state q0 l1 i.e.
the witness automaton is in its initial state q0 and the cfa is on its initial location l1 which corresponds to the function entry .
the first analyzed operation is the declaration of the function parameters and their initialization.
in the witness automaton only the self transition on state q0labeled with o w otherwise matches self transitions such as this one match only if no other transition matches.
thus the verifier proceeds to line with the abstract state q0 l2 .
the assignment d s tis matched again by the self transition and the witness automaton stays in q0.
from abstract state q0 l3 we compute one successor state for each case of the condition in line one for the then case and one for the else case each case is matched by a corresponding edge of the witness automaton.
the then branch of the if statement in line is matched by the transition to the sink state q the analysis does not continue on that branch because q has no successor.
thus the else branch of the if statement is taken by proceeding to q1in the witness automaton.
for the assignments of lines and the witness automaton takes the self transition in q1 where the analysis has to branch due to the conditional assignment in line on one branch the value of ais on the other branch it is .
the paths immediately join again and the value of ais in the interval .
the automaton stays in q1and the analysis continues with bin after line until it reaches line with the abstract state q1 l9 .
we compute a separate abstract successor state for each case of the condition in line the successor state for the then case is qe1 l10 because the next operation label error1is reached.
since this is the accepting error state qe1 we 723have confirmed the first error path of the witness.
the analysis continues at line by computing successors for q2 l12 ok which was the result of the else case of the condition in line .
the state component ok which represents the information tracked by the interval analysis stores the intervals a maps o b maps o d maps o .
the analysis can not take the then branch from q2 reaching the accepting stateqe2 which corresponds to error2in the cfa because the interval analysis stored that the value of bis in the interval .
therefore the label error2is not reachable the previous analysis that produced this witness automaton could not detect this because the predicate analysis overapproximated the multiplication in line .
proceeding the else branch from line we enter q 2of the witness automaton and reach line .
the analysis that produced the witness was able to prove that the code from line onwards does not violate the specification.
therefore the sink control stateq 2concludes the analysis.
upon completion the interval analysis produces the witness automaton in fig.
3c.
the automaton is constructed by encoding all abstract paths that lead to the violating abstrac t state in line and adding transitions to sink control states along the paths such that a witness validator can stop the exploration of branches that are not relevant for reaching the violating abstract state.
in the last testification step the error witness from fig.
3c is used to restrict a test case generator in order to derive a specific test vector for the path to error1.
the test vector is derived by extracting a satisfying assignment of the formula that represents the program path to the error location.
the third witness automaton represents the result of the test case generation i.e.
a test vector.
related work.
there is a large body of work on combining different verification approaches starting in the s with reduced products of abstract domains .
there are many combinations of model checking with data flow analysis wit h testing and with deduction cf.
for an overview .
most existingapproachescombinedifferenttechniquesinparallel as a product or as portfolio verification.
more recently stepwise sequential combinations were conceptualized as conditiona l model checking where verification artifacts conditions are passed from one verifier to another.
our contribution focuses on stepwise testification of specification violation s based on passing error witnesses from one verifier to another.
model checking tools usually produce and provide counterexamples in some form.
however there is an increasing awareness for the need of fast and automatic validation of program error paths in order to increase the confidence in the automatic bug reports especially to reduce the number of false alarms .
a cheap data flow analysis can be combined with a high precision feasibility analysis to filt er out as many false alarms as possible within one instance of a verifier .
experiments illustrate that the validation of error witnesses is usually significantly faster than re verifying the full program .
the tool that produced an error witness can work with a different abstract domain than the tool that is used for the validation .
there was however no unified exchange format for error witnesses across verifiers.
the process of refining witnesses has been addressed for safety proofs from software verification but not yet for counterexamples.
clarke and veith mention the fact that already a full kripke structure with a violation of the specification would be a valid counterexample theydefine a set of criteria that make counterexamples more useful for tools and potential users.
we extended this idea to stepwise testification.
witness testification can be seen as the counterpart of conditional model checking .
the exchange of verification and inference results across verifiers has not been discussed in detail before.
counterexamples were exported by deriving full programs from counterexamples in order to provide them as input to another tool .
this approach is not feasible for witness validation because the witness needs to be checked against the original program.
there is a number of trace formats in the context of distributed high performance computing e.g.
the open trace format or the mpi trace format their primary intent is to keep record of events in the system for example the exchange of messages between processes.
these formats have a strong focus on time stamped events in distributed systems and are not applicable to our problem.
the certification problem format2was designed for first order term rewrite systems and termination analysis.
error witnesses have many applications and a common exchange format for verification tools will foster further research in this direction in particular on combinations of verification and debugging techniques.
.
protocol analysis preliminaries.
we adopt the same notion of programs to describe the theoretical aspects of our ideas as in previous work .
the presentation is restricted to a simple imperative programming language that contains only assume operations and assignments and all program variables are integers.3programs are represented by control flow automata cfa .
a control flow automaton c l l0 g consists of a set lof program locations modeling the program counter the initial program location l0 which models the program entry and a set g l ops lof control flow edges each of which models the operation that is executed during the flow of control from one program location to another.
all variables that occur in operations from opsare contained in the set xof program variables.
aprogram path is a sequence l0op1 ...opn lnwith li opi li gfor i nandl0is the initial program location.
a program path is called feasibleif there exists a test vector for which the program path can be executed otherwise the program path is called infeasible a feasible path with concrete test values is called concrete path .
protocol automata.
a protocol automaton a q q0 f for a cfa c l l0 g is a non deterministic finite automaton with the following components the finite setqrepresents the control states of the automaton the alphabet 2g consists of pairs of a finite set of cfa edges from gand a state condition the transition relation q qdefines the control state transitions the initial control state q0 qdefines the start of the automaton and the setfcontains the accepting control states.
we write q q if q q andq q if there exists a withq q .
protocol analysis.
aprotocol analysis for a protocol automatonais a configurable program analysis cpa o do squigglerighto mergeo stopo which tracks the control state 3our implementations are based on cpachecker and ultimate automizer both of which support c programs.
724of a protocol automaton a q q0 f and consists of the following components for a given cfa l l0 g .the abstract domain do c q consists of the setcof concrete states the semi lattice q and a concretization function .
the semi lattice q z q with z q consists of the set zof abstract data states which are pairs of a control state from q or special lattice element and a condition from a partial order the join operator and the top element q. the partial order is defined such that q q if q orq q and the join is the least upper bound of two abstract data states and the top element q true is the least upper bound of the set of all abstract data states.
the concretization function z 2cis a mapping that assigns to each abstract data state q the set of concrete states.
.the transfer relation squigglerightohas the transfer q g squigglerighto q if the protocol automaton ahas a transition q q such that d andg d. the condition of the control state transition is stored in the successor in order to enable a composite strengthening operator to strengthen the successor abstract data state of another component analysis in the composite analysis using information from condition .
.the merge operator combines elements with the same control state mergeo q q braceleftbigg q ifq q q otherwise .
.the termination check stopo q r returns true i.e.
terminates the state space exploration of the current path if the abstract data state is covered by an existing abstract data state stopo q r q r .
composition.
the protocol cpa is used as one component in a composite cpa in which other component cpas track the data and control state i.e.
information about the values of the variables and the control flow location.
let pbe a component cpa that tracks the abstract data states.
in the composite abstract transfer relation the abstract data states from the protocol cpa oand the other cpa pcan be used to strengthen the composite abstract successor in the following way the composite abstract transfer restricts the abstract data state in pto represent only those concrete states that satisfy the state condition ino.
this way each abstract data state on a program path that the composite cpa explores always implies the corresponding state condition of the protocol automaton.
simulation.
arunof a protocol automaton afor a program path l0op1 ...opn lnis a simulation sequence q0 1 ... n qnsuch that every step liopi li 1is matched by a stepqi i qi 1with i d and li opi li dand all variable assignments at program location li 1satisfy .
protocol automaton aacceptsthe run ifqn f. we say aaccepts the program path if there exists an accepting run ofafor .
the projection of an accepted run to its alphabet symbols 1... nis called accepted word .
the set of all accepted words of adefines the language l a .
specification by observer automata.
safety properties and security aspects can be modeled using finite observer automata also called monitor automata that run in parallel to the system to be verified and observe the behavior of the system without influencing it.
observer automata are an established concept for providing a formal specification .
separating specification from im plementation supports the idea of separation of concerns tools can support the user in providing and maintaining the specification.
a software specification is either weaved into the source code before verification cf.
slic and blast or checked on the fly in parallel to the program cf.
blastcpa cpachecker orion .
a set of properties can be checked simultaneously within one run of a verifier.
anobserver automaton is a protocol automaton that satisfies the following condition for every control state qofa and every control flow edge gofc the state conditions can partition but not restrict the state space of the program logicalortext q q d g q q d g d true.
anobserver analysis is a protocol cpa for an observer automaton i.e.
anobserveranalysis observes or monito rs the paths of the observed program but does not restrict the exploration of the program analysis.
the observer cpa can be used to split abstract paths to observe them separately.
.
testification the goal of our work is to represent error paths paths through the program source code that violate the specification in such a way that they are reproducible machine readable and exchangeable between various verification tools.
conceptually a witness is information that provides evidence of the verification result.
this paper focuses on error witnesses i.e.
witnesses that provide evidenc e that the given program violates a given specification.
for the representation of error witnesses we use witness automata.
witness automata.
awitness automaton is a protocol automaton and a witness analysis is a protocol cpa for a witness automaton which runs as one component cpa of a composite program analysis in parallel to other component cpas.
one of the other component cpas is an observer cpa that encodes the specification.
in contrast to observer automata witness automata not only observe but also restricthow the program analysis explores the program s state space.
while an observer automaton has abstract successor states for allconcrete successor states a witness automaton can restrict the successor states to those successor states th e lead the exploration towards the specification violation.
in other words the witness automaton guides the program analysis to explore the state space that violates the specificatio n. automata that guide the analysis towards specific program locations are also used for test case generation .
verification with witnesses testification .
we require a verifier whenever a violating program path is found to produce a witness automaton for exemplifying the violation we call such averifier also testifier because ittestifies that the bug exists and we call this process testification as illustrated in fig.
4a.
the purpose of the witness automaton is to later restrict the state space exploration of a verifier such that the error path can be confirmed with less effort than with a completely independent verification run.
in this paper we focus on errorwitnesses only.
witness validation.
witness validation is the process of determining if for a given program specification result and witness the same result can be re established independently .
in this paper specifically for error witnesses we validate if an error path can be found in the state space that the witness describes.
one way of implementing witness validation is to construct a composite program analysis that has 725program witnessspeci fication result true false verifierprogram speci fication a verification with witnesses testification witness validatorresult true false program witnessspeci fication result true false b validation of witnesses witness t estifierprogram witnessspeci fication result true false program witnessspeci fication result true false c stepwise testification with witnesses figure from verification and witness validation to stepwise testification a specification analysis and a witness analysis as component s which simultaneously observe and restrict the state space exploration the witness validation restricts the search of the composite program analysis such that only paths are explored that the witness automaton can match and the specification analysis checks if the path indeed violates th e specification.
if during the analysis of a program path the witness automaton takes a transition to a sink state the analysis stops exploring the path thus restricting the state space exploration.
the witness is confirmed by the witness validator if both the specification automaton and the witne ss automaton take a transition to their respective accepting error control state.
we call such a verifier witness validator .
a widely used instance of error witness validation is counterexample checking e.g.
for example during the refinement phase in cegar where an abstract counterexample which is an error witness is checked for feasibility the witness testifies against the program s claim to correctness .
the given error witness is either rejected which means that it describes no feasible counterexample or it is accepte d because it contains a concrete error path and cegar stops.
abstraction levels of witness automata.
a witness automaton can represent more than one error path in fact the verifier that constructs the witness automaton is not bound to a certain level of abstraction.
obviously for the purpose of witnessing a violation of a specification the witness is t he better the more the witness automaton restricts the search space in order for the validating program analysis to explore fewer paths and validate the witness faster.
stepwise testification with witnesses.
stepwise testification of witnesses is the iterative process of improving witnesses by removing unnecessary state space.
this process combines witness validation with testification it tak es as input a witness and produces as output a better witness as illustrated in fig.
4c.
here for error witnesses a testification step starting with witness wproduces a witness w that describes a subset of paths that contains an error path.
each testification step reduces the state space that the next testification step has to explore.the most concrete level of error witnesses describes one single concrete path that violates the specification cf.
fig.
right .
such a concrete error path contains value assignments for all variables and is equivalent to a test vector.
stepwise testification across verifiers.
in order to enable witness validation and stepwise testification across di fferent verifiers we propose a verifier independent exchange format which was already successfully used in sv comp .
the exchange of error witnesses across different verifiers enables a wide range of applications some of which were outlined in the introduction.
the following section gives more detail on the proposed exchange format.
.
exchange format using a common exchange format for error witnesses tools that support stepwise testification may be chained arbitrarily.
we instantiate these concepts for programs written in c and an exchange format based on xml.
.
witness exchange format our format for exchanging error witnesses is based on graphml an xml based format for storing and exchanging graph structures.
a number of libraries support reading and writing graphml or at least xml and thus make the adoption of the format convenient.
the graph nodes and graph edges represent the control states and the transitions of the witness automaton respectively.
we make use of the extensible nature of graphml to extend it with custom data for storing error witness information.
both the node and edge elements in graphml can take additional data within a datatag that has an attribute key.
the meaning of a data tag is determined by its keyattribute.
more details on the error witness format can be found on our supplementary web page.
automata states and transitions.
the control states q and the corresponding transitions q qof the witness automaton are the central information to be encoded in the format.
the format also encodes the different roles that a control state can take the initial state q0of the automaton a sink state q an error state qe or a normal state.
depending on the role we add a data tag with the key attribute entry sink or violation with the value true the default is falsefor all three declaring the control state as normal .
the behavior of transitions between control states is defined by a set of guards.
the conditions at the transitions represent source code guards and state space guards.
a sourcecode guard is used by the validator to check if a control flow edge of the cfa matches a control state transition based on the source code.
line numbers are an example of such guards.
state space guards are used to strengthen the abstract successor states that are computed by the transfer relation of an analysis after the source code guard matches the transition to the next control state of the witness automaton.
assumptions like x y are examples of such guards.
a summary of the guards that we use for our experiments is given in sect.
.
.
.
format implementation this section provides guidance towards robust implementations for writing and reading error witnesses describes some dbeyer verification witnesses 726best practices and presents how common real world issues with exchanging error witnesses across different verifiers can be addressed.
writing a witness automaton from an arg.
a verification tool can produce witnesses by transforming the desired parts of the abstract reachability graph arg which is often available from an analysis into a witness automaton.
the nodes along an error path in the arg become control states in the witness automaton.
the initial control state q0 of the witness automaton corresponds to the root node of the arg.
for every arg node that violates the specification we add a corresponding accepting error control state.
the edges of the arg become transitions in the witness automaton.
edges that leave the error path in the arg become transitions to a sink state i.e.
a state with no outgoing transitions.
based on the desired level of abstraction we add source code guards to the transitions.
those can be based for example on the line number character offset and branching control case information of the arg edge.
constraints on variable values at the target state of an arg edge may be encoded as state space guards.
after producing the witness automaton from the arg we perform several minimizations for example we remove transitions without any guard and reduce sequences of similar transitions i.e.
given a sequence of transitions with the same set of guards we often leave only one of those transitions in the automaton.
reading a witness automaton for validation.
an error witness validator reconstructs the witness automaton that is stored in our exchange format.
for every node in the witness file there is a state in the witness automaton.
for every edge in the witness file there is a transition in the witness automaton guarded by for example information about line numbers branchings and assumptions from the data tags.
we add an unguarded self transition to each accepting error state in order to express that given a program path t for any prefix t oftthat causes the automaton to switch to an error state tis also an accepted error path.
to states that are neither sink nor accepting error state we also add a self transition that is guarded by the negation of the disjunction of the source code guards of all other outgoing transitions of this control state such that it matches if no other outgoing transition matches.
we label these transitions with o w .
this is done in order to address differences in program representations between verifiers which we will discuss in more detail below.
after the witness validator has reconstructed the witness automaton it is able to apply the concepts described in sect.
to validate the witness.
addressing differences in program representations between verifiers by stuttering.
the ansi c standard specifies that it is not required to evaluate all parts of an expression if some parts are sufficient to determine its outcome.
this has to be considered during witness validation.
therefore in addition to the transitions that are explicitly defined in the error witness control states that are neither sink control state nor accepting control state have the transition o w to itself.
this self transition is required in all cases where the verifier that produced the witness skipped parts of the code either due to simplifications or optimizations in the front end of the verifier or simply due to a higher level of abstraction than applied by the witness validator.
for instance the witness automaton might not contain any information about a block of c code that is unreachable.
we consider imposing rules about what to include in witnessesand what can safely be omitted to be too restrictive and a barrier to applying front end optimizations.
therefore the witness automaton is allowed to stutter until the actual analysis catches up in its exploration.
on the other hand this implies that a witness validator must use an internal representation of the program that is at least as fine grained and complete as the witnesses.
another effect of this solutio n is that the end of a path must be explicitly marked as a sink control state by the witness writer if the state space guards are not strong enough to contradict the abstract state of the witness validator otherwise the state space reduction may not be as effective because the witness validator has to consider all remaining branches as well.
handling ambiguity.
in some cases the source code matching information at a transition might be ambiguous.
one line might contain several statements 1int c 2int x x x 3if c error exit a witness automaton might have the assumption x 3after a match of line because it is valid after the third statement in line .
an analysis that would require the truth of x after the first statement first match of line could terminate the analysis since the path formula x x is unsatisfiable.
these cases can be identified by considering the direct successor edges in the cfa lookahead .
for a given witness transition with source code guards an additional transition from the source control state back to itself is introduced.
this transition is guarded by the same source code guard and additionally by the condition that two successive cfa edges hence the lookahead match these guards.
if this case is encountered during the analysis the transitions provide a non deterministic choice between proceeding to the next control state or staying in the current control state.
the downside of this approach is that the non determinism inflates the state space.
however a smart witness validator may detect cases where there is no semantic difference between the choices.
the witness validator then makes a choice thus avoiding the state space inflation.
for exampl e if the one line sequence int x n nondet is encountered it does not matter which of the two declarations an assumption about variable xis applied to because the initialization of ndoes not change the value of x. in the given example the ambiguity can also be resolved by the witness writer by providing an exact offset value.
imprecise witnesses.
a verifier that runs an analysis with a coarse precision might not be able to choose a specific path to the error location that is feasible in the concrete program.
instead of choosing an arbitrary path we produce an automaton that describes several paths assuming that one of these paths is feasible in the concrete program.
a witness validator can therefore produce a refined version of the error witness that describes a smaller number of paths.
best practices.
different verifiers use different internal representations of programs.
an exchange of error witnesses across verifiers is only possible if the witness automata especially their transitions refer to program fragments that can be identified by all verifiers in the testification chain.
therefore we recommend brevity for witness production instead of creating several transitions about the same program operation the verifier should try to merge them into a single transition.
conversely a witness validator must not prune parts of the source code that might be referenced by a 727witness.
due to these requirements for witness validators it is arguably more difficult to implement a witness validator than a verifier that only writes witnesses but we consider this to be an acceptable trade off for the flexibility that is gained by enabling a verifier to refine and improve upon the results of other tools.
open problems.
there are several open problems that we do not yet address in the current error witness exchange format.
our format does not define a means to specify context switches so it is currently not possible to express witnesses to specification violations that depend on concurrency.
a counterexample to termination or more general a counterexample to a liveness property is not a finite execution.
yet we can use witness automata to narrow down a program to a set of infinite paths that contains an infinite execution.
however the current syntax does not allow to distinguish loops that may be executed infinitely often and loops that may be executed for an arbitrary but finite number of times.
.
experimental ev aluation to demonstrate the effectiveness and efficiency of errorwitness validation we performed a large number of different experiments.
the experimental work flow consists of instructing the verifier to produce an error witness and to validate an error witness.
experiment goals.
we perform a feasibility study to support the following claims claim we developed an error witness format that is machine readable and can be used to exchange witnesses for bugs in c programs between different verifiers.
claim witness validation can take considerably less effort than verification i.e.
the witness successfully guides the verifier through a considerably smaller state space.
claim a high precision witness validator may improve the overall effectiveness if an efficient but low precision verifier produces witnesses and the validator rejects a substantial number of incorrect witnesses.
the witness validator is only applied to a verification task a program and its specification if the previous verification step produced a witness.
an error witness may describe only a subset of the possibly infinite paths that violate th e specification rejecting an error witness does therefore not imply that the verification task satisfies the specification b ut only that the given error witness does not encode a violating path.
therefore in our experiments that are restricted to errorwitnesses the result of witness validation is to be interpreted as follows falsemeanswitness confirmed true meanswitness rejected i.e.
the part of the program that the witness describes does not violate the specification.
benchmark set.
our benchmark is composed of the verification tasks from all categories of sv comp except arrays bitvectors concurrency floats memorysafety termination andrecursive which are not supported by one or both of the evaluated verifiers.
a total of of these tasks contain known specification violation s. experimental setup.
all experiments were conducted on machines with two .6ghz core cpus intel xeon e52650 v2 with 135gb of ram.
the operating system was ubuntu .
bit using linux .
and openjdk .
.
each verification task was limited to two cpu cores a cpu runtimeof15minandamemoryusageof15gb.
cpachecker was used in revision from the trunk with mathsat5as smt solver.
cpachecker was configured to perform a predicate analysis using the theory of linear arithmetic over integers and uninterpreted functions.
ultimate automizer was used in revision from the trunk and used its svcomp configuration with z3as smt solver.
the benchmarks were executed using benchexec in version .
.
presentation and availability.
the results tools and verification tasks that we used in our evaluation are available on our supplementary web page.4all reported times cpu time are rounded to two significant digits.
for verification runs where the verifier claims to have found a bug we distinguish between expected alarms which are alarms for programs with a known specification violation and unexpected alarms which are alarms for programs without known specification violations.
unexpected alarms may occur if due to a lack of precision a verifier reports an infeasible error path.
an expected alarm can still be a false alarm if the witness is incorrect i.e.
it does not describe a feasible error path.
our knowledge about existing violations is based on the verdicts of the sv comp community.
claim witness validation across verifiers.
our first experiment represents a feasibility study showing that we were able to implement a witness exchange format for bugs in c programs for two different verifiers cpachecker andultimate automizer which both can take the roles of a verifier producing witnesses and a witness validator.
results.
we produced error witnesses with cpachecker and automizer and then used them as input for both verifiers so that each verifier had to validate its own witnesses and the witnesses of the other verifier.
in total cpachecker produced witnesses of which are considered to be unexpected alarms and automizer produced witnesses of which are considered to be unexpected alarms.
validation times.
figure 5a displays the results for validating witnesses produced by cpachecker withcpachecker itself and shows that validating the witnesses is at least as fast and often much faster than producing the witnesses.
this confirms our expectations and matches the results of earlier work where an internal non exchangeable witness format was used.
the same trend is observable in fig.
5b which displays the results for cross validating witnesses produced by automizer withcpachecker and in fig.
5c which displays the results for validating witnesses produced by automizerwithautomizer itself.
we also note that automizer has a slightly higher start up time about seconds than cpachecker about3seconds beforeanyresultsarereturned.
figure 5d displays the results for cross validating witnesses produced by cpachecker withautomizer .
due to the different start up times observed above there are some verification tasks where validating the witnesses with cpachecker was quicker than validating them with automizer but the trend of witness validation often being faster than verification is observable here too.
acceptance and rejection rates.
inordertoshowthattheverifiers actually use and check the witnesses provided to them a closer inspection of the witness acceptance and rejection rates is required.
table shows the total amounts of accepted and rejected witnesses for each of the four combinations.
runs where the witness validation timed out are counted as rejections.
the high rate of accepted expected alarms across verifiers and respectively confirms the earlier a cpachecker cpachecker b automizer cpachecker c automizer automizer d cpachecker automizer figure scatter plots for pairwise composition for witness validation cpu seconds for producing a witness on the x axis cpu seconds for witness validation on the y axis.
a caption p c abbreviates witnesses produced by pthat are accepted by c table accepted and rejected witnesses validator cpachecker automizer producer cpachecker automizer cpachecker automizer accepted rejected expected alarms only accepted rejected accept.
rate unexpected alarms only accepted rejected reject.
rate observation that the tools understand each other s witnesses.
the high rejection rates of and for the unexpected alarms across the tools on the other hand confirm that our approach is suitable for increasing the confidence in counterexamples.
it is also important to notice that not all expected alarms are in fact accompanied by correct witnesses.
a verifier may produce an incorrect witness that does not describe a feasible error path while missing the actual bug.
for example cpachecker produces a witness for the verification task elevator spec3 product31 false unreachcall.cil.c butautomizer rejects this witness.
manual inspection reveals that the witness contains a sequence where the value is assumed for a variable cil tmp4 in line of the verification task followed by assuming the value for the result of the expression cil tmp4 in line of the verification task an error caused by a technical limitation of the chosen smt configuration.
the rejection of the described path is therefore justified and desirable.
for validating their own witnesses both the high rate of accepte d expected alarms and and the low rate of rejected unexpected alarms and is to be expected because both the verification run and the witness validation are equally im precise and thus verifiers will repeat the same mistakes they made when producing the witnesses.
claim state space reduction.
in order to support the claim that the guidance provided by witnesses is able to significantly reduce the state space that has to be explored by the validator we compare the code coverage between producing witnesses and validating those witnesses as an approximate indicator of the explored state space.
the term code coverage in this section refers to the code that is visited .
.
.
.
.
.
.
.
a line coverage .
.
.
.
.
.
.
.
b condition coverage figure scatter plots that illustrate a reduction of the code coverage with values for the verification runs on the x axes and values for the witness validation runs on the y axes by the verifier in order to determine the verification result.
another indicator that could be used would be the amount of states in the abstract reachability graphs however this measure would not be comparable across different abstract domains and even though we used the same abstract domain forbothconfigurationsinourcomparison wewantourresults to be comparable to future experiments.
for this experiment we chose the predicate analysis of cpachecker .
we applied two code coverage measures line coverage which counts each visited line once and condition coverage which counts each visited case of each boolean sub expression once.
results.
figure 6a illustrates that the line coverage of the witness validation run never exceeds and is often significant ly lower than during the initial verification run.
figure 6b shows the same trend for condition coverage but with an even more extreme reduction of coverage during witness validation in comparison to the initial verification run.
condition coverage is a better indicator for the reduction of the number of explored program paths.
claim witnesses improve effectiveness and efficiency.
one of our claims is that for many verification tasks it is faster to use a quick low precision verification followed by a high precision witness validation thereby obtaining high precision confidence in the counterexamples than to use the slow high precision verification exclusively .
to support this claim we selected the devicedrivers benchmark set of sv comp which contains verification tasks of which contain a known specification violation.
we used two different predicate analysis configurations of cpachecker one using linear arithmetic la and one using bit precise arithmetic bp .
we used both configurations to validate the witnesses produced by la.
1200cpu time s bp la followed by bp witness validation and a bp rerun figure quantile plot showing that lafollowed by a bp witness validation and rerunning bpon rejections is more efficient and effective than just running bp results.
we made the following observations .bpproduces expected proofs while laproduces expected proofs.
the difference of results is because the bit precise configuration bptimes out on tasks for which lais quick enough to provide a proof.
.bpproduces expected alarms for programs with known specification violations and unexpected alarms for programs without a known violation whereas laproduces expected alarms and unexpected alarms in total .
the confidence in the alarms reported by lais initially restricted to the limitations of linear arithmetics.
.
of the witnesses produced by lawere confirmed by a bpvalidation.
the confidence in these remaining witnesses is thus strengthened by the bit precise analysis.
among the rejected witnesses were of the unexpected alarms.
witnesses for tasks where both configurations produced unexpected alarms were confirmed by bp.
.the sum of cpu time required to verify the tasks with confirmed witnesses with laand confirming those witnesses with bpamounts to .74h while verifying the same verification tasks with bptakes .1h.
.if we sum the cpu time of all tasks with la verification andbp validation and add the sum of cpu time used bybpto verify those tasks from scratch for which the la witness was rejected by bp which is .2h we obtain a total cpu time of 53h.
this is 9h less than the total cpu time for verifying all tasks with bp 62h even though we now have expected proofs as well as witnesses in which we have bit precise confidence only of which are unexpected alarms from lawhich were confirmed by bpand from consecutively running bpon the tasks for which the witness was rejected .
this effect is visualized in the quantile plot in fig.
.
we know that the bprerun could also solve another tasks however the sum of the cpu time for running la validating the witnesses and rerunning bpwould exceed the time limit in these cases.
in summary we observe that for this set of verification tasks using plain bit precise predicate analysis for verification is slower than verifying the tasks with predicate analysis with linear arithmetics la followed by witness validation with a bit precise predicate analysis bp while both provide the same bit precise confidence in the counterexamples.
at the same time the efficiency of the predicate analysis with linear arithmetics allows to produce more proofs before the timeout than the bit precise predicate analysis.
therefore we propose a workflow where the tasks are first verified by la the witnesses of laare validated by bp and tasks for which the witnesses were rejected are verified by bp.
as a sanity check we also validated the witnesses produced bylawithla.
as expected almost all of the witnesses areconfirmed so we are confident that the increased precision of thebpwitness validation is really the cause of the observed witness rejections and that the witnesses confirmed by bp are valid even with bit precise semantics even though they were produced by an analysis restricted to linear arithmetics.
validity.
we chose the devicedrivers benchmark set for this experiment because it contains real world c code and contrary to some of the other sv comp benchmark subsets it contains many programs that are large in terms of lines of code and use a wide variety of the programming language features such as structs pointers pointer arithmetics and arrays.
for verification tasks from other sets that are not as complex we observed that the bit precise analysis often performs as well as the predicate analysis using linear arithmetics.
in our experiment the goal was to show that witnesses can be used to improve the results for cases where the more precise analysis is too slow so it would be invalid to include tasks where this premise does not hold.
.
conclusion if the goal is as ambitious as verifying large software systems it is required to combine the strengths of different verification techniques and as a precondition unify their results and make them exchangeable.
the objective of our work was to close the gap of a missing exchange format for error witnesses and to establish witness validation as part of the verification and validation process.
it is important to have such a format in the verification community in order to eliminate false alarms by witness validation and in order to leverage the potential of combining different verification tools once a verifier outputs its error witness in the exchangeable format no extra implementation work is necessary for witness validation the witness can be given directly as input to an off the shelf external witness validator we provide two open source implementations .
our experience shows that it is feasible to support such a format despite the differences in the internal representation of the control flow of programs.
stepwise testification goes one step beyond witness validation thanks to exchangeable error witnesses it is easy to design verification and validation processes where various tools can interact complementing and enriching each other.
our experiments reveal that it is worthwhile to chain testifiers that produce increasingly more restricted witnesses.
we performed an extensive experimental evaluation to show that the proposed error witness exchange format is flexible enough to enable the combination of two very different verification tools witnesses effectively reduce the state space that a validator needs to explore and witness validation is on average significantly faster than verification without the guidance of a witness and witness validation ca n confirm and accept witnesses with reasonably good acceptance and rejection rates.
considering that this is the initial study on witness validation the results look very promising to continue in this direction.
evidence of the success of witness validation was also given by its application in the last edition of the competition sv comp .