precise concolic unit testing of c programs using extended units and symbolic alarm filtering yunho kim school of computing kaist daejeon south korea yunho.kim03 gmail.comyunja choi school of computer science and engineering kyungpook natl.
univ.
daegu south korea yuchoi76 knu.ac.krmoonzoo kim school of computing kaist daejeon south korea moonzoo cs.kaist.ac.kr abstract automated unit testing reduces manual effort to write unit test drivers stubsandgenerateunittest inputs.ho wever automatically generated unit test drivers stubs raise false alarms because they often over approximate real contexts of a target function fand allow infeasible executions of f. to solve this problem we have developed a concolic unit testing technique conbrio.
to provide realisticcontextto f itconstructsan extendedunit offthatconsists offandclosely relevant functions to f. also conbrio filters out a false alarm by checking feasibility of a corresponding sym bolic execution path with regard to f ssymbolic calling contexts obtained by combining symbolic execution paths of f s closely related predecessor functions.
intheexperimentsonthecrashbugsof15real worldcprograms conbrioshowsbothhighbugdetectionability i.e.
.
ofthe targetbugsdetected andhighprecision i.e.atruetofalsealarm ratio is .
.
also conbrio detects new bugs in target c programs studied in papers on crash bug detection techniques.
ccs concepts software and its engineering software testing and debugging acm reference format yunho kim yunja choi and moonzoo kim.
.
precise concolic unit testing of c programs using extended units and symbolic alarm filtering .
inicse icse 40th internationalconference onsoftware engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction althoughunittestingiseffectivetodetectswbugs fieldengineers have burden of manually generating test drivers stubs and test inputsforeachtargetunit.toreducemanualefforttogeneratetest inputs automatedtestgenerationhasbeenapplied e.g.
concolic testing have been appliedto detect bugs in open source programs and industrial projects a t permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
also to reduce manual effort to generate unit test drivers stubs automated unit testing has been applied to open source programs and large industrial sw .
amaindrawbackoftheautomatedunittestingisalargenumber offalse alarms raised by infeasible unit executions i.e.
unit executionsthatareinfeasibleatsystem level .infeasibleunitexecutions occur generated due to inaccurate unit test drivers stubs that overapproximate real contexts of a target unit sect.
.
.
this false alarmproblemisaseriousobstacletoapplyautomatedunittesting in practice since field engineers would not like to spend time to manually filter out many false alarms.
toovercomethislimitation wehavedevelopedanautomated unit testing framework conbrio concolic unit testing with sym bolic alarmfiltering using symbolic calling c ontexts which operates in the following two stages .to provide realistic context to a target function f conbrio constructs an extended unit offthat consists of fandclosely relevantfunctions to fwhich can filter out infeasible unit executions caused by symbolic stubs.
the relevance of a function to fismeasuredbythedegreeofdependencyof fon sect.
.
.
then conbrio performs concolic execution of an extended unit off.
.tofilteroutfalsealarmsbycheckingfeasibilityofacorrespondingsymbolicunitexecutionof f conbriogenerates symbolic callingcontext offbycombining symbolic pathsof closelyrelevantpredecessor functions of fin a static call graph.
asaresult conbriodetectsbugseffectivelyandpreciselybecause itenforcesvariousandrealisticexecutionsof fthroughconcolic executionof fwithf srealisticcontexts i.e.
withthefunctions closelyrelevantto f andaccuratelyfiltersoutfalsealarmsusing f s symbolic calling contexts.
note that it is important to construct an extended unit and symboliccallingcontextof ftocontain onlyfunctions closelyrelevant to fsinceincludingmorefunctionswillenlargesymbolicsearchspace anddegrade unittesting effectivenessandefficiency.
forexample at one extreme end an extended unit may contain all successorfunctions of fand fail to detect bugs due to too large symbolic search space to explore.
also symbolic calling context of fmay contain symbolic execution paths of all predecessor functions of f up to mainand fail to detect bugs.
we have applied conbrio to real world c programs in sir andspec2006 benchmarksandconbrioshowsboth 1generatedsymboliccallingcontextmay notrepresentallfeasiblecallingcontextof f due to the limitation of symbolic execution.
thus a symbolic calling context becomes more difficult to satisfy by adding symbolic execution paths of more predecessor functions of f i.e.
via logical .
see sect.
.
.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yunho kim yunja choi and moonzoo kim high bug detection ability i.e.
.
of all target bugs detected and high precision i.e.
a true to false alarm ratio is .
which is more precise than the latest concolic unit testing techniques for cprograms e.g.
.7byuc klee .also conbriodetects 14newbugs in the latest versions of the nine target c programs studied in other papers on crash bug detection techniques.
the contributions of this paper are as follows conbrio achieves both high bug detection ability .
of the targetbugsdetected andhighprecision falsealarmratiois1 .
based on the two core ideas building and utilizing contexts of a target function explicitly based on relevance of functions measured by a function dependency metric a new alarm filtering strategy that constructs symbolic calling contexts compositio nally and utilizes them to check feasibility of a violating unit execution.
the extensive empirical evaluation on both bug detection ability andprecisionofconbrioandtheotherconcolicunittestingtechniques on the real world c programs supports researchers and practitioners to learn the pros and cons of the related techniques sect.
.
byapplyingconbrio wehavedetectedandreported14new crash bugs in the latest versions of the target programs that were studied in other papers on crash bug detection techniques sect.
.
.
wehavemadethereal worldcrashbugdataofthecbenchmarkprogramspubliclyavailable whichwerecollectedandorganized after examining the bug reports of the last years http swtv.kaist.ac.kr tools conbrio sothatresearcherscanusethem for various testing research purposes sect.
.
.
.
the remainder of the paper is as follows.
section explains the background of automated concolic unit testing.
section describes the detail of conbrio.
section explains the experiment setupto evaluate conbrio compared to other techniques.
section 5reports the experiment results.
section discusses related work and section concludes the paper with future work.
background .
preliminary unit testing uses driversandstubs or mock objects to test a target function in isolation i.e.
without the rest of a target program .
suppose that a target function under test ftakesnarguments a1 ...anandaccesses mglobalvariables v1 ...vm anddirectlycalls lotherfunctions 1 ... l.toenforcediversetestexecutionsof f a tester develops various unit test drivers drvf is each of which generatesargumentvalues ai ...ain globalvariablevalues vi ...vim and finally invokes fwith these input values.
also a tester builds stubfunctions si 1...si ltoreplace 1 ... l.also testdrivers stubs should satisfy constraints on the interface between fand the rest of a target program to avoid infeasible unit test executions of f. .
concolic unit test driver stub generation foreachtargetfunction f aconcolicunittestingtechniqueautomaticallygenerates symbolic stubsanda symbolic unittestdriver.
symbolicstubssimplyreturnsymbolicvalues withoutupdatingglobalvariablesandoutputparametersforsimplicity andasymbolic driver invokes fafter assigning symbolic values to the input variables of faccording to their types as follows primitive types primitive variables are directly assigned with primitive symbolic values of the corresponding types.
arraytypes eacharrayelementisassignedwithasymbolicvariable according to the type of the array element for a large array onlythefirst nelementsareassignedwithsymbolicvalues wherenis given by a user .
pointertypes forapointervariable ptrpointingtoavariableofa type t a driver allocates memory whose size is equal to the size oftand assigns the address of the allocated memory to ptr i.e.
ptr malloc sizeof t .
then a driver assigns ptrwith a symbolic valueof type t. if asize of tis not known e.g.
file in standard c library null is assigned to ptr.
if there exists a pointer variable ptr2pointing to a symbolic variable of the same type t a driver assigns ptr2toptr.
structure types a unit test driver specifies all fields of struct variable sas symbolic variables recursively i.e.
if scontains structvariable t a unit test driver specifies the fields of tas symbolic too .
a limitation of this approach is that the drivers and stubs often over approximatetherealenvironmentof fandallow infeasible unitexecutions i.e.
executionsof fwhichare notfeasibleatsystemlevel that may raise false alarms.
.
insertion of assertions targeting crash bugs concolic unit testing techniques aim to detect crashes run time failures such as null pointer dereference npd array index out ofbounds oob and divide by zero dbz as well as violations of user given assertions.
they often focus on crashes because usergiven assertions are usually not available in real world programs.
concolic unit testing techniques insert assert exp intof whereexpspecifiesaconditiontoavoidcrashes e.g.
denominator nequal 0toavoiddbz .becauseof assert exp inf concolictestingtries togenerateatestinputwithwhich fmakesexpfalseandincreases a chance to detect crash bugs.
.
example of false alarm figure shows a target program with a target function funder test lines .
maincalls a1if the first parameter xofmainis greaterthan0orcalls a2 otherwise line3 .
a1anda2callbatline5 and line respectively and bcalls fat line .
ftakes an integer parameter xand calls g x line a sanity check function for accessing arraythroughanindex x and h x line15 .aconcolic unit testing technique generates a unit test driver driver f and symbolic stubs stub gand stub hforf.
also it modifies fto callstub gandstub hinstead of gandhrespectively see the commentsatline12andline15 andinsertsanoobassertionat line .
figure2showsaunittestdriverandstubsfor f.driver f invokesfwith a symbolic argument arg1 lines where int arg1 sym int setsarg1asasymbolicintegervalue line2 .
stub g 2this subsection is excerpted from .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise concolic unit testing of c programs using extended units and symbolic alarm filteringicse may june gothenburg sweden x and y are inputs of a target program int main int x int y return x ?
a1 x y a2 y int a1 int x int y if y return b x else return int a2 int x if x return b x int b int x if x return f x else return target function under test int f int x int array result if g x !
if stub g x !
assert x x result array else result h x else result stub h x return result int g int x return x ?
int h int x returnx figure target program with a target function f int driver f int arg1 sym int f arg1 int stub g int x int ret sym int return ret int stub h int x int ret sym int return ret figure generated unit test driver and stubs for f andstub hreturnsymbolicintegervaluesas gandhreturninteger values lines5 7andlines9 11respectively .concolicexecution ofdriver f violates the oob assertion at line of fif a unit test execution satisfies the following two conditions asymbolicargument arg1tof line3of driver f islargerthan or equal to the size of array e.g.
arg1is stub greturns a non zero value e.g.
however an alarm raised in such unit test execution is a false alarmbecause such unit test execution of fisinfeasible with the real target program where gis invoked greturns if arg1 line of figure unlike stub g .
in other words a concolic unit testing technique can raise a false alarm if it generates unit test drivers stubs different from real environment of fwhich consist of main a1 a2 b g and h. conbrio technique figure shows the overall process of conbrio as follows .conbrioreceivessourcecodeofatargetprogram alistoftarget functions to test and system test cases of the target program as inputs.
conbrio obtains function call profiles from the system test executions section .
.
.itchecksfunctionrelevancebycalculating dependency ofatargetfunction fonotherfunction usingconditionalprobability p f based on the observed function call profiles section .
.
with a given dependency threshold we consider fhas ahigh dependency on ifp f .
.
based on the calculated dependency of fon other functions itconstructsan extendedunit offthatcontains f f ssuccessor functionsinastaticfunctioncallgraphonwhich fhashigh dependency and symbolic stubs.
it identifies calling contexts offeach of which is a maximal call path a1 a2 ... fin a static function call graph suchthat fhashighdependencyonall ais.weuse ctx f k to indicate kth calling context of f. section .
describes more detail.
.conbrioappliesconcolictestingtoanextendedunitof ftoexplorediverseandrealistictargetunittestexecutions.duringconcolicexecution itbuildsasymbolicpathformula fvithatrepresents executions violating a given assertion viinf section .
.
.itfiltersoutanalarmraisedat vibycheckingthefeasibilityof fviwith regard to f scalling contexts see step .
for this purpose conbrio constructs f ssymbolic calling context formulas ctx f k and uses a smt solver to check satisfiability of fvi see step conjuncted with ctx f k section .
.
if the result is unsat for all calling contexts i.e.
there existsnofeasible execution in any calling context of fto make fvi feasible a target alarm is considered as false and ignored.
otherwise i.e.
the result is sat with at least one calling context a corresponding alarm is reported as a violation of viinf.
.
obtaining function call profile from system test executions conbrio executes a target program with given system test cases and obtains function call profiles.
for example suppose that a target program in fig.
has three system test cases to main x y and .then thefunctioncallprofilesareobtained as follows main a2 a2 b b f f g with main a1 a1 b b f f g with and main a1 a1 b b f f g f h with .
.
computing dependency of a target function on other functions suppose that a program has a target function fand other function and it has nfsystem test executions that invokes f. based on functioncallprofiles wecompute dependency offon asp f .
given a static call graph g v e see def.
and system test executions we compute p f as follows case for which is a predecessor offing v e p f is calculated asn1 nfwheren1is a number of system executions where callsfdirectly or transitively.
case for which is a successor offing v e p f is calculated asn2 nfwheren2is a number of system executions where f calls directly or transitively.
case for which is a successor andpredecessor offing v e i.e.
thereexistsarecursivecallcyclebetween fand p f authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yunho kim yunja choi and moonzoo kim k lj lj f lj int main x y ... a1 ... a2 int a1 ...b ... int a2 ...b ... int b ...f ... int f ... g ... h ... int g ... int h ... lj d f d f a stub b lj lj f p main f p a1 f p a2 f p b f p g f p h f f f stub hgdriver f d main b f ga1main a1 f ghbmain f gb main b f ga1main a1 f ghb y y d f f stub hgdriver f 3 d dd 3 d he d y dy lj lj lj f lj d 3 d z lj d driver f d f a2main f gba2 y figure overall process of conbrio iscalculatedasn3 nfwheren3isanumberofsystemexecutions wherefcalls or callsfdirectly or transitively.
forexample step1offig.3showsthreetestcases and and their corresponding function call profiles for the program infig.
.basedontheprofiles wecalculateddependencyof fon other functions as follows p main f .
n1 nf p a1 f .
n1 nf p a2 f .
n1 nf p b f .
n1 nf p g f .
n2 nf p h f .
n2 nf .
constructing extended unit and calling contexts given a static call graph g v e of a target program def.
a targetfunction f sdependencyonotherfunctions i.e.
p f and adependencythreshold conbrioconstructsan extendedunitoffthat consists of fandf s closely relevant successor functions andcalling contexts off.
definition .
a static call graph g v e is a directed graph wherevis a set of nodes representing functions in a program and eisarelation v v.eachedge a b eindicatesthat adirectly callsb.w ecallanode pasapredecessor offifthereexistsapath fromptof.w ec a l lan o d e sas asuccessor offif there exists a path from ftos.
forexample step3offig.3showshowconbrioconstructsan extendedunitof fandacallingcontextof fforaprograminfig.
.
givenastaticcallgraphwhosenodesarelabelledwithdependency off conbrioconstructsanextendedunitof fthatcontains fand gsince fhashighdependencyon g butnot h i.e.
p g f but p h f where .
.finally driver f invokesanextended unit of fwith symbolic inputs.
note that conbrio does notraise afalsealarminthisexampleunlikeconcolicunittestinginsect.
.
because an extended unit provides realistic environment to fby using gwhich is closely relevant to f. also conbrio builds a calling context of fasb fsince fhas high dependency on b but nota1nora2 i.e.
p b f butp a1 f p a2 f .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise concolic unit testing of c programs using extended units and symbolic alarm filteringicse may june gothenburg sweden .
.
constructing extended unit.
for each target function f conbrio constructs an extended unit that contains fandf s successor functions such that fhas high dependency on all function nodes in a call path from fto in a static function call graph i.e.
for all nodes nibetween fand p ni f .
a unit testdriversetsallargumentsandallglobalvariablesaccessedby the extended unit of fas symbolic inputs as described in sect.
and invokes f. for example fig.
shows a static call graph whose nodes are labeledwithdependencyofatargetfunction f.fig.4showsthatan extendedunitof f markedwithblackdashedlineatthebottom consists of f n12 n13 andn14 functions on which fhas high dependency i.e.
p n12 f p n13 f p n14 f .
.
in addition as a false alarm reduction heuristic conbrio adds sym assume expr 3at thebeginning of f s extendedunit where exprrepresentspossiblevaluerangesofsymbolicinputvariables which are obtained by applying a static value range analyzer to an entire target program code .
if an input value is not in the estimatedrange acurrenttestexecutionimmediatelyterminates without raising any alarms and conbrio continues to a next test execution.
as another heuristic conbrio constructs an extended unit to keep consistency between a pointer input variable to dynamicallyallocatedmemoryanditssizevariablebyfiguringoutsuch relation between input variables based on the variable names.
.
.
constructing calling contexts.
inastaticcallgraph g v e labelled with dependency of f we define a calling context offas a maximal call path from a predecessor node of ftofas follows.
definition .
an ithcalling context off v sayingctx f i is a maximal call path a1 a2 ... fin a static call graph g v e satisfying the following conditions a1is a predecessor of f for allajinctx f i p aj f thereexistsnoothercallingcontextof fthatcontains ctx f i as its sub path i.e.
ctx f i is maximal .
conbrio generates a calling context by traversing a static call graph from fin a reverse direction until it reaches a node labelled withlowdependencyof f.forexample fig.4showstwocalling contexts of f ctx f andctx f .ctx f is a call path from n5t of see the blue dotted line in the left part where p n5 f p n8 f .
.
andp n1 f .
p n2 f .
.
thus ctx f n5 n8 f.similarly ctx f n3 n6 n9 f. .
concolic testing to generate violating symbolic path formulas conbrioappliesconcolictestingtoanextendedunittoexplore diverse and realistic executions of f. during concolic execution it obtainsa setofsymbolicexecutionpath formulas sef.and records asymbolicpathformula f vi j thatviolatesanassertion viinf j is an index to a symbolic path formula violating visince there can bemultiplesuchsymbolicpathformulas .weuse fvitodenote logicalortext.
j f vi j .
3sym assume expr is a macro of if !expr exit .
q q q q q q q q q q q q d d h q q q d d pdlq figure4 staticcallgraphshowinganextendedunitandtwo calling contexts of f ctx f andctx f with .
tofocuson f conbriomodifiesdfssearchstrategiesbyusing a priority queue for branch conditions of fand a normal queue for those of the other functions in an extended unit of f e.g.
gin fig.
.
conbrio explores various behaviors of ffirst by negating branch conditions in a priority queue first branch conditions in anormal queue are negated when the priority queue is empty .
.
alarm filtering by checking satisfiability off sviolatingsymbolicpathformula fvi withf s symbolic calling context formula to filter out false alarms raised at viinf conbrio checks the feasibilityof fviwithregardto f scallingcontexts seesect.
.
.
.
for this purpose conbrio constructs ctx f k which is a kth symbolic calling context offand checks satisfiability of fvi ctx f k using a smt solver.
ctx f k is constructed as follows see fig.
for each function ajin a calling context of f i.e.ctx f k conbrio obtains seajwhich is a set of symbolic execution path formulas of aj.
note that this task is the same task in step sect.
.
.
if ajwas already tested as a target function and seajwas generated in step this alarm filtering step step reuses seaj.
conbrio obtains a slice of seajwith regard to aj saying slice seaj aj as follows slice seaj aj def prime primeis a prefix of seajsuch that containsinvocationof aj 1and primedoesnotcontain a suffix of after the invocation .
forexample for ctx f infig.
fig.5showsthat slice sen5 n8 hastwosymbolicpathformulasthatcall n8 n5 n8 and n5 n8 shown as thick blue arrows where x y z iszth symbolic path formulaofafunction xthatterminatesimmediatelyaftercalling a function y.slice sen8 f also has two symbolic path formulas that callf n8 f and n8 f .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yunho kim yunja choi and moonzoo kim y s lj d lj d lj d figure5 violatingsymbolicpathformula fviandasymbolic calling context of f i.e.
ctx f withctx f in fig.
conbrio obtains symbolic calling context formula offwith ctx f k i.e.
ctx f k bycombiningsetsofslicedsymbolicexecutionpathformulasof a1 i.e.
slice sea1 a2 a2 i.e.slice sea2 a3 ... ofctx f k until reaching fusing logical conjunction.
thus ctx f k withctx f k a1 a2 ... fis defined as follows ctx f k def logicalandtext.
aj ctx f k f logicalortext.
l slice seaj aj l forexample fig.5shows ctx f withctx f n5 n8 finfig.4asfollows seethickbluearrowsrepresenting n5 n8 n5 n8 n8 f and n8 f ctx f n5 n8 f n5 n8 n5 n8 n8 f n8 f finally conbrioapplies a smtsolver to fvi ctx f k for every symbolic calling context of f. if a result is unsat for all callingcontexts i.e.
thereexists nofeasibleexecutioninanycalling contextsof ftomake fvifeasible atargetalarmisconsideredas false and ignored.
otherwise i.e.
a result is sat with at least one callingcontext acorrespondingalarmisreportedasaviolationof viinf.
.
implementation we have implemented conbrio in lines of c code using clang llvm .
.
conbrio uses crown for concolic testing and llvm based static variable range analyzer t o computethepossiblerangesofvariables.crown concolictesting for real world software analysis is a lightweight easy tocustomizeconcolictestingtoolforreal worldcprograms available at features such as bitwise operators floating point arithmetic bitfields and so on.
crown has been successfully applied to various industrial projects.table target programs and bugs for rq1 to rq4 target lines of of sys.
branch func o f programs func.
test cov.
cov.
target and versions cases bugs bash .
.
.
flex .
.
.
.
grep .
.
.
gzip .
.
.
.
make .
.
.
sed .
.
.
vim .
.
.
perl .
.
.
.
bzip2 .
.
.
.
gcc .
.
.
gobmk .
.
.
.
hmmer .
.
.
.
sjeng .
.
.
libquantum .
.
.
.
h264ref .
.
.
sum n a n a average .
.
.
.
.
.
experiment setup wehavedesignedfiveresearchquestionstoevaluatebugdetection ability and precision of conbrio and compare conbrio with otherconcolicunittestingtechniqueson15real worldcprograms.
notethatitisimportanttoevaluatebugdetectionabilityandpreci sion together because of a trade offbetweenthem i.e.
a technique mayimprovebugdetectionabilityatthecostofprecisionorvice versa .
also we applied conbrio to the latest versions of the nine c programs studied in other papers on crash bug detection techniques.
.
research questions rq1.
bug detection ability how many crash bugs among the target crash bugs does conbrio detect compared to the other concolic unit testing techniques?
rq2.
bug detection precision how much is a false alarm ratio of conbrio compared to the other techniques?
rq3.effectivenessofthesymbolicalarmfiltering howmuch does the alarm filtering strategy using symbolic calling contexts affect a number of target bugs detected and a false alarm ratio?
rq4.
effect of the function selection strategy on bug detection ability and precision howmuchdoesthefunctionselection strategy based on the function relevance metric affect a numberoftargetbugsdetectedandafalsealarmratio compared to a strategy based on static call graph distance?
rq5.
effectiveness of detecting newcrash bugs how many new crash bugs does conbrio detect?
.
target bugs and programs we target crash bugs described in section .
by inserting correspondingcrashassertionsintargetprogramsbecausecrashbugs are serious problems and conbrio can automatically insert such authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise concolic unit testing of c programs using extended units and symbolic alarm filteringicse may june gothenburg sweden table target programs for rq5 target programs lines of of sys.
branch func.
and versions func.
test cases cov.
cov.
abcm2ps .
.
.
.
autotrace .
.
.
.
bib2xml .
.
.
catdvi .
.
.
eog .
.
.
.
gif2png .
.
.
.
jpegtran .
.
.
.
mp3gain .
.
.
.
xpdf .
.
.
sum n a n a average .
.
.
.
.
assertions without user given test oracles which are rarely availableintargetprograms.weusetwobenchmarks knowncrashbug benchmark for rq1 to rq4 and unknown crash bug benchmark for rq5 available at .
.
known crash bug benchmark.
the known crash bug benchmark consists of all c programs in sir except siemens programs and spacewhich do not have available bug fix histories andspec2006integerbenchmarks except mcf .2whichhasonly onesystemtestcase .wetargetthecrashbugsofthebenchmark programs that satisfy the following conditions crash bugs that exist in a target program version and have been confirmed by original developers through bug fix commits since thereleaseofatargetprogramversion e.g.
dec1996for bash .
until april crash bugs that canbe detected by unit testing i.e.
both buggy statement s reported in a bug fix commit and violated assertion s are located in a same target function table describes target programs including their sizes in locincludingcommentsandemptylines anumberoffunctions to test a number of system test cases used branch coverage and function coverage achieved by the system test cases and a number ofthetargetcrashbugs.foralltargetprograms weusedallsystem test cases provided in the benchmarks.
each target program has twoto15targetcrashbugs .5onaverage .notethatnosystem test case detects a target bug.
for example we have reviewed bug fix commits reported sincethereleaseof vim .0onfeb1998untilapril2017.11among themreportcrashbugsexistingin vim .
.amongthe11crash bugs unit testing can detect six of them which we target for vim .
see the eighth row of the table .
.
.
unknown crash bug benchmark.
theunknowncrashbug benchmark programs were selected from the literature on crash bugdetectiontechniques.thisisbecausesirandspecbenchmark programsdonotsatisfythefollowingcriteria weselectedtarget programs whose sizes are to loc and which have morethanthreecrashbugfixesinthelastthreeyears i.e.between april to april .
we excluded very large programs due to huge manual effort required to check validity of alarms.
we alsoexcluded programs with three or less crash bug fixes in the last three years because such programs may not have a crash bug.
to obtain new crash bug benchmark programs we surveyed papers on crash bug detection techniques published in major se icse fse ase issta pl pldi popl splash andsecurity conferences ieee s p acm ccs usenix security in the last threeyearsandobtainedtheninerelevantpapers .then weappliedtheabovecriteriatothelatestversions of the target programs studied in these papers and obtained the nine target programs in table .
again for all target programs we used all system test cases provided in the target program versions and no system test case violated the crash assertions.
.
concolic unit testing techniques to compare we have compared conbrio with the following concolic unit testing techniques symbolic unit testing sut it generates a symbolic unit testing driver with symbolic arguments to a target function fand symbolicglobalvariableswithoutanyconstraintsonthesymbolic values asdescribedinsect.
.
.also sutusessymbolicstubs to replace all functions called by f. static call graph distance techniques it constructs an extended unittoincludeallsuccessorfunctionsof fwithinacertaindistanceboundfrom finastaticfunctioncallgraph.also acalling context of fcontains predecessor functions of fwithin a certaindistanceboundfrom f.weusedistancebounds3 6and9.
sut corresponds to a static call graph distance technique with a distance bound .
sut uses dfs as a concolic search strategy.
call graph distance techniques and conbrio use the modified dfs sect.
.
.4these unit testing techniques have been implemented in lines of c code using crown .
.
measurement we consider that a target bug is detected if a unit test execution thatviolatesanassertioncoversoneofthebuggystatementsina target unit.
to identify the buggy statements we have manually analyzed all crash bug fix commits of all subsequent releases of the target program versions in sir and spec2006 benchmarks.
we considerthatastatement sofatargetprogramisabuggystatement ifscorresponds to the changed fixed statements in a crash bug fix commit.
weanalyzealarmsreportedbythealarmfilteringstrategy sect.
.
.
fortruealarms wecountanumberofviolatedassertstatements which satisfy the following conditions there exists a unit test execution fvthat covers a buggy statement and violates an assert statement in a target function f. we can confirm that fvis feasible at system level by manually creating a system level test that includes fvand violates the assert statement we compared execution traces of fvand a corresponding system test using gdb .
4wereporttheexperimentusingonlydfsandmodifieddfssincetheexperiments using other searchstrategies such as randomnegation and cfg heuristic showonly negligible difference.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yunho kim yunja choi and moonzoo kim we consider all other alarms as false ones.
.
testbed setting for sut call graph distance techniques and conbrio we set the timeout of concolic testing step in fig.
as seconds per a targetfunction.5aftertestgenerationterminates call graphdistancetechniquesandconbrio performs thefalsealarmfiltering task step in fig.
.
we set a function dependency threshold as .
.
sincetheexperimentscaleislarge i.e.
targeting15 915functions for the known crash bugs and functions for the unknown crashbugs theexperimentswereperformedon100machineseach ofwhichisequippedwithintelquad corei54670kand8gbram runningubuntu14.
.264bitversion.werunfourconcolicunit test runs on a machine in parallel.
.
threats to validity a threat to external validity is the representativeness of our target programs.
but we expect that this threat is limited since the target programs are widely used real world ones and tested by many otherresearchers.anotherthreattoexternalvalidityisthepossible bias of the system tests we used to obtain dependency between functions.wetriedtoreducethisthreatbyutilizingallavailable system test cases in the benchmarks.
a threat to internal validity is possible faults in the implementation of the concolic unit testing techniques we studied.
to address thisthreat weextensivelytestedourimplementation.athreatto construct validity is the use of the crash bugs that were fixed by thebug fixcommitsreportedsofar i.e.
thetargetprogramsmay have unknown unreported crash bugs which we do not count .
we target crash bugs confirmed by the developers through the bugfix commits because it would require too much effort to manually validate numerous alarms without confirmed reports in this large scale experiment.
however this threat seems limited because all targetprogramsarewell maintainedsothattheseprogramsmay not have many new bugs.
experiment result forallcomparisonintheexperimentsinthissection weapplied wilcoxn test with a significance level .
to show the statistical significance.
allcomparison resultsin this sectionare statistically significantunlessmentionedotherwise.theexperimentdataare available at .
experiment data .
.
data on extended units and calling contexts.
forthe15 known crash bug benchmark programs each extended unit constructedbyconbriocontains6.2functionsonaverage.conbriogenerated3.0callingcontextspertargetfunctionwhereeachcalling context has .
functions on average.
call graph distance techniqueswithbound3 and9generateanextendedunitthatcontains .
.
and .
functions on average respectively.
also they 5we selected timeout as seconds because exploratory study with timeout and seconds suggested that timeout beyond seconds had negligible effect on the overall experiment results of conbrio and the other techniques.table3 numbersofthetargetbugsdetectedbytheconcolic unit testing techniques target o fbound of static call program target graph distance tech.
conbrio bugs0 sut bash .
flex .
.
grep .
gzip .
.
make .
sed .
vim .
perl .
.
bzip2 .
.
gcc .
gobmk .
.
hmmer .
.
sjeng .
libquantum .
.
h264ref .
sum generate5.
.
and24.3calling contextspertargetfunction on average respectively.
.
.
data on unit tests generated and alarm filtering.
for the known crash bug benchmark programs conbrio spent .
hours to generate unit tests for target functionsand .
hours for the symbolic alarm filtering using z3 on 100quad core machines.
z3 reports that a symbolic calling contextformula with a violating symbolic unit execution consists of .5million clauses on .
million boolean variables on average and its maximum memory usage is around .
gb.
call graph distance techniques with a distance bound and spent the almost same .8hours for unit testgeneration i.e.
most targetfunctions reach the timeout and .
.
and .
hours for the symbolic alarm filtering respectively.
conbrio covered .
to .
of the branches of a target program .
onaverage withtheunittestsandthegivensystem testcases i.e.
theunittestsincreasethebranchcoverage25.
p moreonaverage .
.
where57.
istheaveragebranch coverage achieved by the system test cases see the last row of table .
.
rq1 bug detection ability table3describesanumberofthetargetbugsdetectedbytheconcolic unit testing techniques and shows that conbrio has high bug detectionability.conbrioandstaticcall graphdistancetechnique withboundzero i.e.
sut achievethehighestbugdetectionability i.e.
.
butsutachievesthisatthecostofmanyfalse alarms seesect.
.
.notethatthegivensystemtestsdonotdetect anyofthetargetbugs.inaddition weappliedconcolictestingat system level using distributed concolic testing tool score withthesameamountoftotaltimeon100machinesbutfoundthat no target bug was detected.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise concolic unit testing of c programs using extended units and symbolic alarm filteringicse may june gothenburg sweden table numbers of false alarms and ratios of false alarms per true alarm of the concolic unit testing techniques static call graph distance techniques target sut conbrio programs of f t of f t of f t of f t of f t false alarm false alarm false alarm false alarm false alarm alarms ratio alarms ratio alarms ratio alarms ratio alarms ratio bash .
.
.
.
.
.
flex .
.
.
.
.
.
.
grep .
.
.
.
.
.
gzip .
.
.
.
.
.
.
make .
.
.
.
.
.
sed .
.
.
.
.
.
vim .
.
.
.
.
.
perl .
.
.
.
.
.
.
bzip2 .
.
.
.
.
.
.
gcc .
.
.
.
.
.
gobmk .
.
.
.
.
.
.
hmmer .
.
.
.
.
.
.
sjeng .
.
.
.
.
.
libquantum .
.
.
.
.
.
.
h264ref .
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
as a distance bound of the call graph distance techniques increases to and the number of detected bugs severely decreases to and respectively because larger symbolic search space should be explored within the timeout.
amongtheundetectedsixtargetbugs threetargetbugs inbash grep and gccwere missed because concolic execution did not cover corresponding buggy statements within the timeout twobugsin flexandh264refweremissedbecauseofthealarm filtering strategy and one in vimwas missed because a unit executioncoveredthecorrespondingbuggystatementandanassert statement but did not violate the assert statement.
.
rq2 bug detection precision table4describesanumberoffalsealarmsandaratiooffalsealarms pertruealarmofthetechniquesandshowsthatconbrioachieves high bug detection precision.
among the techniques conbrio raises the lowest number of false alarms i.e.
.
false alarms per target program on average and the lowest false alarms per true alarms ratio i.e.
.
false alarms per true alarm on average .
thestaticcall graphdistancetechniquewithdistance0 i.e.sut suffersthelargestnumberoffalsealarms .0falsealarmspertarget program on average .
conbrio raises only .
.
.
.
and46.
and61.
ofthefalsealarmsraisedbythestatic call graphdistancetechniqueswithdistancebounds0 and9 on average respectively see the last row of the table .
.
rq3.
effectiveness of the symbolic alarm filtering the comparison of the experiment results of conbrio and conbrio without the alarm filtering strategy using symbolic calling contextformulas sect.
.
demonstratesthatthealarmfilteringstrategy improves bug detection precision significantly.
in other words conbrio withoutthe alarmfilteringstrategy detectstwo 6the static alarm reduction heuristics of conbrio decrease the number of false alarms .
to .
on average and the number of false alarms per true alarm .
to .5onaverage withoutdecreasingthebugdetectionability i.e.conbriowithout the static alarm reduction heuristics detects the same bugs and raises .
false alarms per target program on average .more target bugs i.e.
bugs in all target programs but with five times higher false alarm ratio i.e.
.
false alarms per true alarm onaverage .althoughthesymbolicalarmfilteringspentmoretime .
hours than the unit test generation .
hours this strategy is worthwhiletoapplytoimprovebugdetectionprecision.detailed experiment data is available at .
rq4.
effect of the function selection strategy on bug detection ability and precision the comparison on the experiment results of conbrio and the call graphdistancetechniquesconfirmsthattheideaofincluding onlyclosely relevant functions to a target function based on the proposeddependencymetricinextendedunitsandcallingcontexts is effective.
forexample conbrioandthecall graphdistancetechnique with bound generate an extended unit of a similar size i.e.
.
vs. .8functionsonaverage andtheamountofgeneratedcalling contextsarealsocomparable .0callingcontextseachofwhichhas .6functionsvs.
.9callingcontextseachofwhichhas2.8functions on average see sect.
.
.
.
the time taken to generate unit test executions is almost same .
hours and the time taken to apply the alarm filtering strategy is also similar .
vs .
hours .
however conbrio achieves much higher bug detection ability andprecisionthanthecall graphdistancetechniquewithbound i.e.
.
vs76.
forbugdetectionabilityand4.5vs.
.9falsealarms pertruealarmon average .withlargerdistance bounds6 and9 a numberofthe detected bugsdropsto 41and39 and the false alarm ratio decreases to .
and .
respectively which is still three to two times less precise than conbrio.
.
rq5.
effectiveness of detecting new crash bugs conbrio detects new crash bugs in the seven target programs.
conbrio detects five new crash bugs in autotrace two bugs in each of abcm2ps gif2png and mp3gain one bug in each of bib2xml eog and jpegtran and no bug in catdviandxpdf.
note that we confirmed the new crash bugs by manually creating system level test cases that crash a target program due to thebugsdetectedbyconbrio.conbrioraises71falsealarms over the all target programs and its true to false alarm ratio foreach program ranges from .
to .
.
on average except catdviandxpdf .
we have reported these new crash bugs to the original developers and been waiting the responses from them detailedexampleand explanationofthenewlydetectedbugs are available at related work .
concolic unit testing techniques there exist concolic unit testing techniques e.g.
whichrequireausertobuildsymbolicunittestdriversandstubs.
7conbriogenerated3.3callingcontextspertargetfunctioneachofwhichhas4.
functions on average.
it spent .
minutes to generate unit tests for targetfunctionsand20.7minutestoapplythesymbolicalarmfilteringon100machines and covered .
of the branches on average.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yunho kim yunja choi and moonzoo kim dart generatessymbolicunittestdrivers butnotsymbolic stubs like sut sect.
.
and test inputs for c programs.
conbol generates symbolic unit test drivers stubs and test inputs targeting large scale embedded c programs.
dart and conbol generatesymbolicunittestdriverswithoututilizingcontextsofa target function fand may suffer many false alarms.
chakrabartiandgodefroid developedaunittestingtechnique which statically partitions a static call graph using topological information and tests each partition as a unit through symbolic execution.thistechniquemaysuffermanyfalsealarmsbecausethe obtained partitions may not represent groups of relevant functions due to insufficient information to generate partitions i.e.
using onlytopologicalinformationofastaticcallgraphwithoutsemantic or dynamicinformation .
their toolis notpublicly available and the paper does not report bug detection ability nor precision .
t o m b .e ta l reported that interprocedural program analysis with deeper call depth bound raise fewer false alarms.
however they did not report how to set a proper call depth bound.
recently uc klee directly starts symbolic execution from atargetfunctionusinglazyinitialization .throughthemanual analysis of the thousands of alarms the authors of uc klee detected 67new bugsin bind openssl linuxkernel andits true to falsealarmratiois1 .7onaverage.wecouldnotdirectlycompare conbrio with uc klee because uc klee is not publicly availableand bind openssl andlinuxkernel millionlinesofcode are too large to manually analyze alarms.
.
random method sequences generation techniques for object oriented programs randoop invokes a random sequence of public methods including constructors of a target method s class.
mseqgen mines codebasestoextractrelevantmethodsequencesofatargetclass under test and extends such method sequences with symbolic executionforhighcoverage.evosuite testsjavamethodsusing search based strategies with symbolic execution.
testful combines genetic algorithm and a local sear ch to improv e the speed ofjavaunittestgeneration.gargetal.
improvesrandoopby generatinginputtestcasesofthegeneratedmethodsequenceusingconcolictestingforc programs.thesetechniquesmayalsosufferfalse alarms due to infeasible test inputs method sequences genera ted.forexample grossetal.
reportedthatrandoopraised181 alarms withoutdetecting anybug i.e.
allalarms werefalse ones onfivejavaprogramsalthoughtheauthorsofrandoopreported that randoop s true to false alarm ratio is .
on java libraries and .net libraries on average .
fraser et al.
reported that the statistically estimated true to false alarm ratios range from .6to1 .2intheirexperimentsonrandomlyselected100projects hosted on sourceforge.net.
garg et al.
does not report detected bugsor falsealarm ratiosbut branchcoverage obtainedusingthe proposedtechniqueoneightprograms except gnuchess onwhich theauthorsreportedninenewbugsandthatatruetofalsealarm ratio was .
.
in spite of the lack of explicit context information e.g.
class object information in c programs conbrio detects bugspreciselyincprograms i.e.
atruetofalsealarmratiois1 .
8dart bypassesthefalsealarmissuebytargetingpublicapifunctionsoflibraries which should work with all possible inputs.on average while keeping high bug detection ability i.e.
.
of the target bug detected on average .
the aforementioned papers report only bug detection precision rq2 notbugdetectionability rq1 whichmakesfaircomparison between these techniques and conbrio difficult.
this is because thesetechniquesmayimproveatruetofalsealarmratioatthecost ofmissingbugs.becauseofsuchtrade offbetweenprecisionand recallofbugdetection westudiedandreportedbothbugdetection ability and precision.
.
automated unit testing techniques based on system tests elbaum et al.
proposed a technique to generate unit tests from systemtests thetechniquecapturesprogramstatesbeforeandafter an invocation of a target function fto generate unit test inputs andoraclesfor f.ocat capturesobjectinstancesduringsystemexecutionsandgeneratesunittestsusingrandoopwiththe capturedobjectandthemutatedobjectinstancesasseedobjects.
genutest automatically generates unit tests and mock objects using captured method sequences during system testing.
a limitationofthesetechniquesisthattheexecutionsofthegenerated unit tests just replay the same behaviors or similar behaviors ofatargetunitinalreadyperformedsystemtesting i.e.
they are applicable to only regression testing of evolving software nottoasingleversionofsoftware .also theaforementioned papers do not report bug detection ability nor precision.
conclusion and future work wehavepresentedanautomatedconcolicunittestingtechnique conbriowhichgeneratesextendedunitstocloselymimicthereal contexts of a target function fand filters out false alarms using symbolic calling context formulas of fusing relevant functions to f. through the experiments conbrio demonstrates both high bug detection ability .
of all target bugs detected and high bugdetectionprecision atruetofalsealarmratiois1 .
.further more conbriodetects14newcrashbugsinthelatestversionsof the nine target c programs studied in other papers on crash bug detection techniques.
as future work to improve the precision of automated unit testingfurther weplantorefinethefunctiondependencymetricby analyzing more semantic characteristic of target program executions.also wewillimprovebugdetectionabilityfurtherbyapplying an invasive software testing technique which increases test coveragebyutilizingdiverseexecutionsofmutatedversionsofa target program.
in addition we will utilize generated test cases to improve precision of mutation based fault localization .
acknowledgement thisworkissupportedbynext generationinformationcomputing developmentprogram throughthe nationalresearch foundation ofkorea nrf fundedbytheministryofscienceandict msit no.nrf 2017m3c4a7068175andno.nrf 2017m3c4a7068177 and basic science research program through nrf funded by msit nrf 2016r1a2b4008113 andbasicscienceresearchprogram through nrf funded by the ministry of education nrf2017r1d1a1b03035851 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise concolic unit testing of c programs using extended units and symbolic alarm filtering icse may june gothenburg sweden