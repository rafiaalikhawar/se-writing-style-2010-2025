nullaway practical type based null safety for java subarno banerjee university of michigan ann arbor mi usa subarno umich.edulazaro clapp uber technologies inc. san francisco ca usa lazaro uber.commanu sridharan university of california riverside riverside ca usa manu cs.ucr.edu abstract nullpointerexception s npes are a key source of crashes in modern java programs.
previous work has shown how such errors can be prevented at compile time via code annotations and pluggable type checking.
however such systems have been difficult to deploy on large scale software projects due to significant build time overhead and or a high annotation burden.
this paper presents nullaway a new type based null safety checker for java that overcomes these issues.
nullaway has been carefully engineered for low overhead so it can run as part of every build.
further nullaway reduces annotation burden through targeted unsound assumptions aiming forno false negatives in practice on checked code.
our evaluation shows that nullaway has significantly lower build time overhead .
than comparable tools .
.
.
further on a corpus of production crash data for widely used android apps built with nullaway remaining npes were due to unchecked third party libraries deliberate error suppressions or reflection and other forms of post checking code modification never due to nullaway s unsound assumptions for checked code.
ccs concepts software and its engineering extensible languages compilers formal software verification .
keywords type systems pluggable type systems null safety static analysis acm reference format subarno banerjee lazaro clapp and manu sridharan.
.
nullaway practical type based null safety for java.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
introduction nullpointerexception s npes caused by a dereference of null are a frequent cause of crashes in modern java applications.
such crashes are nearly always troublesome but they are particularly problematic in mobile applications.
unlike server side code where a bug fix can be deployed to all users quickly getting a fixed mobile permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
to users devices can take days to weeks depending on the app store release process and how often users install updates.
due to the severity of null dereference errors recent mainstream languages like swift and kotlin enforce null safety as part of type checking during compilation.
previous work has added type based null safety to java via code annotations and additional type checking .
with this approach developers use nullable and nonnull code annotations to indicate whether entities like fields parameters and return values may or may not be null.
given these annotations a tool checks that the code is null safe by ensuring e.g.
that nullable expressions are never de referenced and that null is never assigned to a nonnull variable.
previous work has shown this approach to be an effective way to prevent npes .
despite their effectiveness previous type based null safety tools for java suffered from two key drawbacks.
first the build time overhead of such tools is quite high.
our experimental evaluation showed the two best known tools to have average overheads of .
and .
respectively see compared to regular compilation.
for a seamless development experience a null safety tool should run every time the code is compiled but previous tool overheads are too high to achieve this workflow without excessive impact on developer productivity.
second some previous tools prioritize soundness i.e.
providing a strong guarantee that any type safe program will be free of npes.
while this guarantee is appealing in principle it can lead to significant additional annotation burden for developers limiting tool adoption.
to address these drawbacks we have developed nullaway a new tool for type based null safety for java.
nullaway runs as a plugin to the error prone framework which provides a simple api for extending the java compiler with additional checks.
the core ofnullaway includes features of previous type based null safety tools including defaults that reduce the annotation burden and flowsensitive type inference and refinement .nullaway includes additional features to reduce false positives such as support for basic pre post conditions and for stream based apis .
nullaway is carefully engineered and regularly profiled to ensure low build time overhead.
we built nullaway at uber technologies inc. uber and have run it as part of all our android builds both on continuous integration servers and developer laptops for over two years.
at uber nullaway replaced another tool which due to performance limitations ran only at code review time.
running nullaway on all builds enabled much faster feedback to developers.
regarding soundness nullaway aims to have no false negatives in practice for code that it checks while reducing the annotation burden wherever possible.
nullaway s checks to ensure nonnull fields are properly initialized are unsound but also require far fewer annotations than a previous sound checker .
similarly arxiv .02127v1 jul 2019esec fse august tallinn estonia subarno banerjee lazaro clapp and manu sridharan nullaway unsoundly assumes that methods are pure i.e.
sideeffect free and deterministic .
in both cases we have validated that neither source of unsoundness seems to lead to real world npes for uber s android apps based on crash data from the field.
for usability nullaway uses an optimistic handling of calls into unchecked code though such handling can lead to uncaught issues.
modern java projects often depend on numerous third party libraries many of which do not yet contain nullability annotations on their public apis.
maximum safety requires a pessimistic modeling of such libraries with worst case assumptions about their nullness related behavior.
pessimistic assumptions lead to a large number of false positive warnings in our experience making the tool unusable on a large code base.
instead nullaway treats calls into unchecked code optimistically it assumes that such methods can always handle null parameters and will never return null.
additionally nullaway includes mechanisms for custom library modeling and leveraging nullability annotations when they are present.
overall nullaway s handling of unchecked code is practical for large code bases while providing mechanisms for additional safety where needed.
we performed an extensive experimental evaluation of nullaway on 18open source projects totaling 164klines of code and on .3mlines of production code from widely used android apps developed at uber.
we observed that nullaway introduced an average of overhead to build times on the former on the later significantly lower than previous tools.
further a study of one month of crash data from uber showed that npes were uncommon and that nearly all remaining npes were due to interactions with unchecked code suppression of nullaway warnings or post checking code modification.
none of the npes were due to nullaway s unsound assumptions for checked code.
finally the evaluation confirmed that removing these unsound assumptions leads to significantly more warnings for developers.
nullaway is freely available and open source.
it has more than stars on github and has been adopted by a number of other companies and open source projects further validating its usefulness.
we believe that nullaway s design and tradeoffs provide a useful template for future type systems aiming to prevent crashes in large scale code bases.
contributions this paper makes the following contributions we describe the design of nullaway s type system tuned over many months to achieve no false negatives in practice for checked code with a reasonable annotation burden.
nullaway includes a novel carefully designed initialization checking algorithm an optimistic treatment of method purity and a highly configurable system for determining how to treat unchecked code .
our evaluation showed that a checker without these unsound assumptions emitted many false positive warnings .
.
we present experiments showing that nullaway s buildtime overhead is dramatically lower than alternative systems enabling npe checking on every build .
.
we analyze production crash data for a large code base built with nullaway and show that on this data set nullaway 1optimistic handling is also used for overriding methods from unchecked packages see .achieved its goal of no false negatives for checked code as remaining npes were primarily caused by third party libraries and warning suppressions .
.
overview in this section we give a brief overview of type based nullability checking as implemented in nullaway .
the core ideas of preventing npes via pluggable types are well known see elsewhere for further background.
with type based null checking a type s nullability is expressed via additional qualifiers written as annotations in java.
the nonnull qualifier describes a type that excludes null whereas nullable indicates the type includes null.
given these additional type qualifiers type checking ensures the following two key properties no expression of nullable type is ever assigned to a location of nonnull type.
no expression of nullable type is ever dereferenced.
together these properties ensure a program is free of npes assuming objects have been properly initialized.
we defer discussion of initialization checking to .
consider the following simple example 1void log nonnull object x system.out.println x.tostring 4void foo log null here the parameter of logis nonnull so the call log null will yield a type error as it violates property .2the developer could address this issue by changing the annotations on log s parameter xto be nullable .
but xis dereferenced at the call x.tostring which would yield another type error due to violating property .
one way the developer can make the code type check is to change the body of the logmethod as follows 5void log nullable object x if x !
null system.out.println x.tostring the type checker proves this code safe via flow sensitive type refinement to be discussed further at the end of this section the checker interprets the null check and refines x s nullness type to be nonnull within the if body making the tostring call legal.
types qualified with nullability annotations form a subtyping relationship where nonnull c is a subtype of nullable c for any class c .
hence property simply ensures assignment compatibility according to subtyping.
override checking nullaway also ensures that method overrides respect subtyping enforcing the standard function subtyping rules of covariant return types and contravariant parameter types .
consider the following example 8class super nonnull object getobj return new object class sub extends super nullable object getobj return null 2for type checking assignments include parameter passing and returns at method calls.nullaway practical type based null safety for java esec fse august tallinn estonia class main void caller super x new sub x.getobj .tostring nullpointerexception!
since xhas declared type super the declared target of x.getobj on line is super.getobj .
this method has a nonnull return type making the tostring call legal.
however this example crashes with an npe since overriding method sub.getobj has nullable return type.
to close this loophole the checker must ensure covariance in return types so a method with nonnull return type cannot be overridden by one with nullable return type.
similarly it must check for contravariant parameter types so a method s nullable parameter cannot be made nonnull in an overriding method.
defaults annotating every field parameter and return value in a large code base would require a huge effort.
nullaway uses the non null except locals nnel default from the checker framework to reduce the annotation burden.
any unannotated parameter field or return value is treated as nonnull whereas the types of local variables are inferred see below .
beyond reducing annotation effort this default makes code more readable by reducing annotation clutter and nudges the developer away from using null values making the code safer.
flow sensitive type inference refinement as in previous work nullaway automatically infers types for local variables in a flow sensitive manner.
beyond inspecting assignments null checks in conditionals are interpreted to compute refined path sensitive types where the condition holds.
e.g.
at line of the previous log example the type of xis refined to nonnull inside the if body based on the null check.
nullaway uses an access path based abstract domain to also track nullability of sequences of field accesses and method calls.
describes how nullaway s assumptions around method purity interact with type inference.
other tools throughout this paper we discuss two other typebased null checking tools for java the nullness checker from the checker framework which we refer to as cfnullness for brevity and eradicate available with facebook infer .
subsequent sections will detail how the checks performed by nullaway and its overheads compare with cfnullness and eradicate.
initialization checking beyond the checks shown in to fully prevent npes a nullness type checker must ensure that objects are properly initialized.
sound type systems for checking object initialization have been a subject of much previous research .
in this section we present nullaway s approach to initialization checking.
though unsound our technique has a low annotation burden and has caught nearly all initialization errors in our experience at uber.
figure gives a code example we will use to illustrate our initialization checking.
we first describe how nullaway checks that nonnull fields are initialized .
then discuss checking for uses before initialization .
and then compare with cfnullness and eradicate .
.
class initexample nonnull object f g h k initexample this .f new object this .g.tostring use before init helper private void helper this .g new object this .h.tostring use before init initializer public void init this .h this .f if cond this .k new object figure an example with errors to illustrate initialization checking.
.
field initialization initialization phase any nonnull instance field must be assigned a non null value by the end of the object s initialization phase.3we consider an object s initialization phase to encompass execution of a constructor possibly followed by initializer methods .
initializer methods or simply initializers are methods invoked at the beginning of an object s lifecycle but after its constructor e.g.
overrides ofoncreate in android activity subclasses .
field initialization may occur directly in constructors and initializers or in invoked helper methods.
in figure the initexample class has four nonnull fields declared on line .
nullaway treats the init method lines as an initializer due to the initializer annotation.
for a method annotated initializer nullaway assumes without checking that client code will always invoke the method before other noninitializer methods in the class.
note that the initexample constructor invokes helper at line to perform some initialization.
checks given a class cwith constructors initializers and initializer blocks for each nonnull field fofc nullaway treats fas properly initialized if any one of four conditions holds fis initialized directly at its declaration or fis initialized in an initializer block or chas at least one constructor and allconstructors initialize f or some initializer in cinitializes f. for a method constructor or initializer block mto initialize a field f fmust always be assigned a non null value by the end of m. this property can be determined using the same analysis used for flow sensitive type inference see by checking if the inferred type of this .fis nonnull at the end of m.nullaway also allows for initialization to occur in a method that is always invoked bym.
nullaway determines if malways invokes a method nwith two simple checks the call to nmust be a top level statement in m 3for space we elide discussion of nullaway s handling of static field initialization the techniques are roughly analogous to those for instance fields.esec fse august tallinn estonia subarno banerjee lazaro clapp and manu sridharan not nested within a conditional or other block 4and nmust be private orfinal to prevent overriding in subclasses.
for figure nullaway reasons about initialization as follows fis properly initialized due to the assignment at line .
gis properly initialized since the constructor always invokes helper line which assigns g line .
his properly initialized since initializer method init assigns h line .
line only initializes kconditionally.
so nullaway reports an error that kis not properly initialized.
.
use before initialization within the initialization phase a further check is required to ensure that nonnull fields are not used before they are initialized.
two such bad uses exist in figure the read of this .gat line and this .hat line .
nullaway performs a partial check for these bad uses.
within constructors and initializers nullaway checks at any field use that the field is definitely initialized before the use.
this check again leverages the same analysis used for flow sensitive type inference.
nullaway must also account for fields that have been initialized before the analyzed method.
for example the read ofthis .fat line of figure is safe since fis initialized in the constructor which runs earlier.
similarly nullaway accounts for fields initialized in always invoked methods before a read.
nullaway s check is partial since it does not check field reads in methods invoked by constructors or initializers or guard against other leaking of the this reference during initialization.
so while nullaway reports a use before init error at line of figure it does not report an error for the uninitialized read at line .
while handling certain cases like reads in always invoked methods would be straightforward detecting all possible uninitialized reads would be non trivial and add significant complexity to nullaway .
uninitialized reads beyond those detected by nullaway seem to be rare so we have not yet added further checking.
.
discussion in contrast to nullaway cfnullness aims for sound initialization checking.
the cfnullness initialization checking system .
an extension of the summers and m ller type system prohibits invoking any method on a partially initialized object without additional developer annotations.
e.g.
cfnullness prohibits the call at line since helper is not annotated as being able to operate during initialization.
it also lacks support for a direct analogue of the initializer annotation.
as we shall show in this strict checking leads to a number of additional false warnings.
nullaway s checking is unsound but it seems to catch most initialization errors in practice with a much lower annotation burden.
nullaway s initialization checking was inspired by the checking performed in eradicate which also supports the initializer annotation.
compared with eradicate there are two main differences in how nullaway checks for initialization.
first nullaway only considers initialization from callees that are always invoked 4nullaway currently unsoundly treats nas always invoked even if mmay return before invoking n. 5nullaway does not attempt to identify methods that are always invoked from a constructor or initializer through a chain of invocations more than one level deep this has not led to false positive warnings in practice.
class fooholder nullable object foo public nullable object getfoo return this .foo public void setfoo nullable object foo this .foo foo public nullable object getfooornull return randint ?
null this .foo figure an example to illustrate nullaway s purity handling.
see .
.
in contrast eradicate considers initialization performed in all private or final constructor callees even those invoked conditionally which is less sound.
e.g.
if line were written as if cond helper eradicate would still treat fields assigned in helper as initialized.
second eradicate does not have any checking for use before initialization .
.
note that usage of initializer can be dangerous as nullaway does not check that such methods are invoked before others.
in the uber code base most usage of initializer is via overriding of well known framework methods like activity.oncreate .
when developers introduce new usage of initializer our code review system automatically adds a comment to warn about the risks.
purity assumptions nullaway reduces warnings unsoundly by assuming all methods arepure i.e.
both side effect free and deterministic.
figure gives a simple example of a class fooholder that has a foofield with a getter and setter.
nullaway s flow sensitive type inference assumes method calls are side effect free so it will erroneously not report a warning on this code fooholder f ... if f.foo !
null f.setfoo null f.foo.tostring npe!
nullaway ignores the effect of the setfoo call and assumes f.foo remains non null at line based on the null check at line .
additionally nullaway assumes all methods are deterministic in order to refine nullability of getter return values during type inference.
the following code may throw an npe fooholder f ... if f.getfooornull !
null f.getfooornull .tostring the issue is that getfooornull defined at line in figure is non deterministic given the same parameters it may return null in some calls but not others.
nullaway ignores this possibility and refines the nullability of getfooornull s return to be nonnull under the condition and hence emits no warning.nullaway practical type based null safety for java esec fse august tallinn estonia discussion in practice we have not observed any npes in the field due to method side effects.
in the uber code base most data holding classes are immutable precluding such errors.
also usually a null check is quickly followed by a dereference with no intervening code a safe pattern even with mutable types.
we have also not observed non determinism to cause soundness issues for nullaway in practice.
by default cfnullness soundly assumes that methods may be impure.
while this catches more bugs on the uber code base this would lead to a large number of false warnings.
cfnullness has an option to assume methods are side effect free but no option as of yet to assume determinism.
previous work has studied automatic verification of method purity for java it would be interesting future work extend nullaway to verify these properties efficiently.
handling unannotated code this section details how nullaway handles interactions with unannotated unchecked code typically written by a third party.
since modern java programs often use many third party libraries without nullability annotations these interactions arise frequently in real world code.
by default nullaway uses an unsound optimistic handling of interactions with unannotated code sacrificing some safety to enhance tool usability.
assume that code in a program has been partitioned into checked code which has proper nullability annotations checked by nullaway and unannotated code which is lacking annotations and has not been checked.
we shall detail how this partition is computed shortly.
by default nullaway treats interactions between the checked and unannotated code optimistically i.e.
it assumes that no errors will arise from the interaction.
in particular this means when checking a call to an unannotated method m nullaway assumes that m s parameters are nullable and that m s return is nonnull .
when checking an override of an unannotated method m see discussion of override checking in nullaway assumes that m s parameters are nonnull and that m s return is nullable .
these assumptions are maximally permissive and ensure that no errors will be reported for interactions with unannotated code a clearly unsound treatment.
alternatives to optimistic handling of unannotated code yield too many false positives to be usable.
no handling of third party code can prevent all npes as there may be bugs within the thirdparty code independent of what values are passed to api methods.
a maximally safe handling of interactions with third party code would be pessimistic making the exact opposite assumptions from optimistic checking e.g.
all return values would be treated as nullable .
but these conservative assumptions lead to a huge number of false warnings.
by default cfnullness handles thirdparty libraries the same way as first party code any parameter or return missing an annotation is assumed to be nonnull .
these assumptions also lead to a large number of false warnings see .
granullar inserts runtime checks at the unannotated code boundary to guarantee soundness of checked code annotations.
wea.b.c.foo ?object o a.b in xepopt ... annotatedpackages regex?
a.b in xepopt ... unannotatedsubpackages regex?
a.b.c in xepopt ... unannotatedclasses ?
is class cannotated generated and xepopt ... treatgeneratedasunannotated set?
does a.b.c.foo have a library model for its first parameter?
acknowledgerestrictiveannotations set and bytecode has nonnull jarinferenabled set and bytecode analyzed as requiring nonnull from model nonnull nullableyesno noyes noyes yes no noyes noyes no yes figure flowchart for nullaway s treatment of unannotated code.
did not investigate this approach due to potential runtime overhead and the riskiness of shipping modified code.
nullaway has a highly configurable system for specifying which code is unannotated and how optimistically it is handled.
at the highest level annotated and unannotated code is partitioned based on its java package notwhether the code is first party or thirdparty.
this system provides a high degree of flexibility when adoptingnullaway source packages can be treated as unannotated for gradual adoption while third party packages can be treated as annotated if they have proper annotations present.
figure presents a flow chart showing how nullaway determines the nullability of the first parameter to a hypothetical method a.b.c.foo object o represented by the missing annotation placeholder ?
.
the first four steps seek to determine whether the code is annotated or unannotated.
the method is treated as annotated if the package name matches the annotatedpackages regex it does not match the unannotatedsubpackages regex the class name is not blacklisted in unannotatedclasses and the class is not annotated as generated with the option treatgeneratedasunannotated set.
in this case the nullability of ois assumed to be nonnull .
otherwise the code is unannotated.
nullaway then checks if there is a manually written library model giving an annotation for the method parameter if so that annotation is used.
nullaway ships with such models one per method and parameter position pair.
these mostly cover common methods from the jdk and android sdk.
nullaway can load additional custom library models but none of the open source apps in our evaluation required it.
if the acknowledgerestrictiveannotations option is set nullaway looks for explicit annotations within unannotated code usingesec fse august tallinn estonia subarno banerjee lazaro clapp and manu sridharan them if they are more restrictive than its default assumptions.
this allows nullaway to opportunistically take advantage of explicitlyannotated third party code without forcing its default assumptions for checked code onto unannotated methods.
here if foo s parameter had an explicit nonnull annotation it would be used.
finally nullaway can leverage models automatically generated by jarinfer a separate analysis we built for basic type inference on bytecode.
for example if a method unconditionally dereferences its parameter jarinfer infers that the parameter should be nonnull .
while jarinfer still only performs intra procedural analysis on library entrypoints we have found it useful at uber for catching additional issues in interactions with libraries.
a full description of jarinfer is outside the scope of this paper we plan to extend it with greater functionality and present it in future work.
none of the open source apps in our evaluation use jarinfer.
other features in this section we detail nullaway s handling of other java features relevant to nullability and describe some additional nullaway features that reduce false warnings.
polymorphism nullaway does not yet support polymorphic nullability for generic types.
consider the following pair type class pair t u public t first public u second cfnullness allows for different uses of pair to vary in nullability via type use annotations on generic type parameters .
e.g.
one can write pair nullable string string forpairs where the first element may be null.
in contrast nullaway treats generic types like any other for pair it assumes both fields have the nonnull default.
to allow null as a value the fields themselves would need to be annotated nullable .
type use annotations on the generic type parameters are ignored.
this treatment is sound but could lead to undesirable code duplication e.g.
one may need to write a nearly identical firstnullablepair secondnullablepair etc.
we have found this lack of support for type polymorphism to be only a minor annoyance thus far.
a big mitigating factor is that most generic type usages in the uber codebase are of collection data structures and it is a best practice to simply avoid storing null in such types .
however we do see a need to eventually support type polymorphism for cases like the above pair type and also functional interface types like those in the java.util.function package.
we plan to add support in future work but so without compromising on build time overhead may require care.
arrays nullaway unsoundly assumes that arrays do not contain null values.
in contrast cfnullness uses type use annotations to reason about nullability of array contents e.g.
the type of an array of possibly null string s is written nullable string .
note thatcfnullness does not soundly check array initialization by default .
in the uber code base arrays of