lazy cseq a context bounded model checking tool for multi threaded c programs omar inverso truc l. nguyen bernd fischery salvatore la torrezand gennaro parlato electronics and computer science university of southampton uk foi2c11 tnl2g10 gennaro g ecs.soton.ac.uk ydivision of computer science stellenbosch university south africa bfischer cs.sun.ac.za zdipartimento di informatica universit a degli studi di salerno italy slatorre unisa.it abstract lazy cseq is a context bounded verification tool for sequentially consistent c programs using posix threads.
it first translates a multi threaded c program into a bounded nondeterministic sequential c program that preserves bounded reachability for all round robin schedules up to a given number of rounds.
it then reuses existing high performance bounded model checkers as sequential verification backends.
lazy cseq handles the full c language and the main parts of the posix thread api such as dynamic thread creation and deletion and synchronization via thread join locks and condition variables.
it supports assertion checking and deadlock detection and returns counterexamples in case of errors.
lazy cseq outperforms other concurrency verification tools and has won the concurrency category of the last two sv comp verification competitions.
i. i ntroduction bounded model checking bmc tools have successfully been used to analyze sequential software and to discover subtle errors in applications .
however attempts to apply them naively to multi threaded programs e.g.
face problems as the number of possible interleavings grows exponentially with the number of threads and statements and a large number of specialized approaches based on partial order or contextbounded analysis cba methods have been developed.
cba methods limit the number of context switches they explore which is empirically justified by work that has shown that errors manifest themselves within few context switches and so fit well into the general bmc framework.
lazy cseq is a context bounded model checking tool for the verification of concurrent c programs.
it is based on the technique of sequentialization which translates a concurrent program into a non deterministic sequential program that under certain assumptions behaves equivalently so that the different concurrent schedules do not need to be explicitly handled during verification.
the obtained sequential program can then be verified using different off the shelf sequential verification tools.
lazy cseq is implemented as a source to source translation in the cseq framework .
in contrast to the original cseq tool that is based on a lal reps style sequentialization lazy cseq uses a different lazy sequentialization which aggressively exploits the structure of bounded programs and works well with bmc based backends.
lazy cseq s early prototypes already performed very well in particular they have won the concurrency category of the last two tacas software verification competitions sv comp .
here we now describe how we have extended lazycseq into a full fledged verification tool for sequentially consis tent c programs using posix threads.
lazy cseq handles the full c language and the main parts of the posix thread api such as dynamic thread creation and deletion and synchronization via thread join locks and condition variables and checks both builtin and user defined assertions.
we have extended lazy cseq so that it can now also detect deadlocks and return counterexamples in case of any errors.
we have further implemented a mechanism that allows users to control the schedule exploration which can lead to better performance and can be used to implement different context bounded analysis strategies including bounding the number of context switches and rounds .
with lazy cseq we impact two different user groups within the broader software engineering community.
first for software developers i.e.
end users we provide a robust and well performing verification tool for a notoriously difficult verification problem.
second for verification tool developers we provide a front end processor for concurrency handling that can easily be combined with different sequential verification tools.
the remainder of the paper is organized as follows.
in the following two sections we summarize the underlying sequentialization described in more detail in and give a highlevel overview of the cseq framework and the lazy cseq tool.
in section iv we evaluate lazy cseq on the sv comp benchmarks before we discuss related work in section v and finally conclude in section vi.
ii.
l azy sequentialization of concurrent programs sequentialization is based on a translation of the input program to a corresponding sequential program which is then analysed by an off the shelf backend verification tool for sequential programs.
the key idea of such translations is to replace the control nondeterminism of the original program by data nondeterminism and to capture thread invocations by function calls.
lazy sequentialization methods in addition preserve the sequential ordering of the interleaved thread executions preserving local invariants of the original program and use much less data nondeterminism than other sequentializations which can result in better performances of the backend tools.
a. lazy sequentialization schema we assume that a concurrent program pconsists of n functionsf0 f n wheref0denotes the main function and creates at most nthreads respectively with start functions f1 f n respectively.
note that these assumptions can easily be enforced by bounding the programs in bmc fashion and cloningbool the f1 0g int cs ct pc size f5 2g define j a b if pc a a cs goto b pthread mutex t m0 m1 int x void t0 void arg f static int l 0 j pthread mutex lock m0 1 j pthread mutex lock m1 2 j l x 3 j x l 4 j pthread mutex unlock m0 5 j pthread mutex unlock m1 6 g void t1 void arg f 7 j pthread mutex lock m1 8 j pthread mutex lock m0 9 j x 10 j pthread mutex unlock m1 11 j pthread mutex unlock m0 12 g int main thread f static pthread t t0 t1 13 j pthread mutex init m0 14 j pthread mutex init m1 15 j pthread create t0 null t0 16 j pthread create t1 null t1 17 g int main f for r r k r f ct if active f only active threads cs pc nondet uint next context switch assume cs size appropriate value?
main thread thread simulation pc cs store context switch g ct if active f gg g fig.
.
example program with injected control code.
the start functions if necessary.
since each start function is thus associated with at most one thread we can identify threads and start functions.
for round robin executions we fix an arbitrary schedule by permuting f0 f n in each round we execute an arbitrary number of statements from each function f0 f n. for any fixed our translation then guarantees that pfails an assertion in krounds if and only if the sequentialized program pseq kfails the same assertion.
note that the translation thus preserves not only bounded reachability but allows us to perform on the concurrent program all analyses supported by the sequential backend tool.
pseq kis composed of a new function main and a thread simulation function fseq ifor each thread fiinp.
fig.
shows in black a simple example program and in gray the extra code fragments injected by lazy cseq.
the program consists of two threads t0andt1that acquire two mutexes m0andm1in reverse order and can thus deadlock.
note that the sequential verification ofpseq krelies on stubs provided by lazy cseq.
pseq kthus uses a slightly modified version of the pthreads api.
for example the pthread create stub takes an additional argument for the statically known id of the calling thread see for details.
the new main ofpseq kis a driver that calls in the order given by the functions fseq iforkcomplete rounds.
for each thread it maintains the label at which the context switch was simulated in the previous round and where the computation must thus resume in the current round.
moreover before each call tofseq i the label at which the control will context switch out is nondeterministically guessed.
eachfseq iis essentially fiwith few lines of injected control code and with labels to denote the relevant context switch points in the original code.
when executed each fseq ijumps in multiple hops to the saved position in the code and then restarts its execution until the label of the next context switch is reached.
this is achieved by the j macro.
context switching at branching statements requires some extra care see for details.
we also make the local variables persistent i.e.
static such that we do not need to re compute them when resuming suspended executions.
we make use of some additional data structures and variables to control the context switching in and out of threads as described above.
the data structures are parameterized over t nwhich denotes the maximal number of threads activated in pexecutions.
we keep track of the active threads the arguments passed in each thread creation the largest label used in each fseq i the current label of each fseq i and the index of and the context switch point guessed for the currently executed thread.
note that the control code we inject in the translation is designed such that each fseq ireads but does not write any of the additional data structures.
this data is updated only in the main driver and in the portions of code simulating the api functions concerning thread creation and termination.
this has the advantage of introducing fewer dependencies between the injected code and the original code which typically leads to a better performance of the backend tool e.g.
for bmc backends this results in smaller formulas .
b. deadlock check compared to the prototype described in the lazy cseq tool now uses an improved modeling and coverage of the pthreads library especially for mutexes.
for example it can now detect whether a mutex is used again after being destroyed.
however the main improvement in this respect is that lazy cseq can now also check for deadlocks in the original concurrent program.
adeadlock is characterized by a subset of the threads i that are all blocked after trying to acquire a mutex that is held by another thread and where ii the dependency chain between the waiting threads is cyclic.
for example for the program in fig.
such a cycle and thus a deadlock occurs if t0acquires m0 then the context switches and t1successfully acquires m1but gets subsequently blocked when it tries to acquire m0 and the context switches back to t0 which gets blocked when it tries to acquire m1.
thus there is a cyclic chain of length 2where t0 is the first thread and holds mutex m0 and is waiting for mutex m1 and t1is the second thread and holds mutex m1 and is waiting for mutex m0 .
note that there may be other threads that are blocked by trying to acquire any of the mutexes held by any of the the threads in the chain but are not required for the deadlock and thus do not need to be recorded in the chain.
lazy cseq thus searches for deadlock conditions by nondeterministically guessing the chain on the fly while simulating the threads.
this chain is modelled by an array of thread identifiers together with a single mutex identifier.
the first position in the array contains the id of the thread that starts the cycle.
each subsequent position i 1in the array contains the id of a thread that waits on a mutex held by the thread whose id is stored in the previous position i. the additional single mutex identifier denotesthe mutex on which the second thread in the array is blocked this is stored when the second thread is entered into the chain.
when a thread successfully acquires a mutex and the chain is still empty we non deterministically decide to store its id in the first element of the array thereby starting to search for a cycle and continue with its simulation.
when the mutex is already held by another thread the simulation of the requesting thread is blocked moreover if the mutex is held by the thread stored at the end of the array we non deterministically insert the id of the requesting thread at the current position in the array.
we then test for a cycle over the waiting threads by checking whether the id of the last inserted thread is the same as the one stored in the first position of the array.
when we release any mutex we also check that the first thread in the array does not release the mutex on which the second thread in the array is blocked and on which the deadlock eventually hinges.
this ensures that the waiting threads cannot make progress before the simulation detects the cycle and thus correctness of the simulation.
iii.
a rchitecture implementation and availability a. the cseq framework lazy cseq is developed within the cseq framework .
the framework builds on ideas from the original cseq tool but has been improved and fully re engineered.
it now provides support for quickly developing new sequentialization based verification tools.
to date it has also been used to implement the mu cseq and ul cseq tools.
the framework comprises several modules that are either translators that implement source to source transformations of c programs or wrappers that work on generic strings and are used for general purpose tasks that do not produce source code.
each tool within cseq is identified by a configuration that corresponds to a sequence of translators followed by a sequence of wrappers.
fig.
sketches the configuration for lazy cseq.
a verification tool takes as input the file containing the source code of the concurrent c program to analyze and the list of verification parameters.
for lazy cseq the verification parameters are the number of rounds the unwinding depth and the acronym of the backend tool.
the input parameters are passed to the appropriate modules additionally the first module takes as input also the input source file and then the output of each module is fetched as input to the following module.
the output of the last module in the sequence is the analysis outcome.
the first translator is always a merger the input source code is merged with external sources pulled in by the include directives.
the last translator is typically an instrumenter which instruments the output according to the backend tool as explained below .
the purpose of the wrappers is to interact with the backend tool and interpret its answer at the end of the analysis in particular we have a cex module that is responsible for tracking back the counter example generated by the backend tool on the input source code and thus output the counter example.
translators run in two steps the input code is parsed in order to build the abstract syntax tree ast the symbol table and other data structures the ast is recursively traversed and un parsed back into a string that corresponds to the output c code.
this mechanism is built on top of pycparser a parser for c99 that uses ply an implementation of lex yacc and it is implemented by conveniently overriding pycparser s ast based pretty printer so that the output code is transformedwhile visiting the ast.
in particular the transformation is made on the fly by directly changing the output generated by ast subtree visits rather than altering the structure of the ast itself.
other source to source translation tools use instead rewrite rules.
string based source transformations are in contrast more intuitive and require a less steep learning curve and combined with python s flexibility it is relatively easy to implement complex code transformations quickly.
string based rewriting is also used in the rose framework .
the cseq framework also provides a line mapping functionality that is independent from the specific translation performed and is a useful support for the counterexample generation.
the idea is to keep track of the location in the source code where each line of the output was translated from.
during the generation of the output translators automatically create maps from output to input in a similar way to how the c preprocessor cpp uses line control information when merging multiple source files to keep track of which lines comes from which source file.
however rather than inserting explicit line directives in the source code like cpp does the information is stored as a table which maps output lines back to input lines note that each input line may generate several output lines for instance after unfolding a loop .
at the end of the last translation it is possible to track line numbers back to the output of the first module.
for the first module merger since there might be multiple input files due to the include directives we map output line numbers to pairs of the form linenumber filename .
instrumenting the code for a specific backend is in itself a quite simple standalone transformation undertaken by the instrumentation module.
it consists in replacing the primitives for handling non determinism that are backend independent and potentially injected at any point by any module with backendspecific statements.
this involves three kinds of statements variable assignment statements to nondeterministic values using nondet int nondet long etc.
restrictions of nondeterminism using assume explicit condition checks using assert .
this requires a simple renaming of the function calls or inserting ad hoc functions definition depending on whether or not the desired verification backend natively models all of the above.
the size of a backend integration is therefore usually less than lines however the cbmc default backend exploits cbmc s bitvectors to optimize the representation of the program counters and is thus more complicated.
b. the lazy cseq tool the lazy cseq tool is a cseq configuration of eighteen modules that can be conceptually grouped into the following categories see fig.
the source merging module eight simple transformation modules to rewrite the input program in steps with a progressively simplified syntax so to simplify the complex transformations occurring later in the sequence four translators for program flattening to produce a bounded program see two modules implementing the sequentialization algorithm that produces a backend independent sequentialized file see standard program instrumentation to instrument the sequentialized file for a specific backend fig.
.
configuration sequence of lazy cseq.
double framed boxes denote modules composed of multiple submodules.
two wrappers for backend invocation and user report generation or counterexample translation.
compared to the features of the prototype described in lazy cseq s new features are deadlock checking see section counter example generation and scheduling selection .
we briefly describe the latter two here.
the counterexample generation feature of lazy cseq tackles one of the main usability limitations of sequentialization based tools namely that when an error is found the error trace is too hard to follow as the counterexample produced by the backend actually refers to the sequentialized file.
lazy cseq instead generates counterexamples that refer to the actual input code.
the main task here consists in translating the backend s counterexample by tracing back line numbers to their corresponding input coordinates and then showing the amended states in the same order.
for this we use the line mapping feature provided by cseq framework.
we also insert additional concurrency specific details to show schedules thread creations lock operations and the like.
counterexample generation in lazy cseq is currently supported only for the default backend.
however we stress that the line mapping facility provided by the framework cseq is general backend independent and translation independent and thus can be used for any backend.
for ann thread program our prototype from fixes a schedule of the threads this corresponds to the order in which the threads get created and explores all computations up to a number of rounds rspecified as input parameter where in each round threads are scheduled according to .
in the lazycseq tool we now allow to specify some schedule restrictions for each round.
namely we can choose for each round if all threads can be scheduled denoted with or only a thread from a set of threads can be scheduled we list the threads with numbers separated by commas .
to separate rounds we use .
for example for two rounds denotes the scheduling from for only the first and second thread in order of creation can be scheduled at the first round filtering out any other possible choice note that the main thread is always in first set indicates an explicit schedule.
note that even when the schedule is fixed context switch points can still happen at any time.
scheduling selection can be useful to guide the analysis when some specific facts on scheduling are known or on complex problems where even analyzing a single round would require too many resources.
in fact the translation is tailored to the specific sub set of possible schedules and the trimmed down main driver results in smaller verification conditions.c.
usage.
lazy cseq can be invoked with the command cseq.py i input.c to analyze the input file input.c and check for reachable error states determined by an error label an assertion failure or incorrect use of locks using the default analysis parameters and the default backend.
deadlock checking is off by default and can be enabled with deadlock .
the analysis parameters are the loop unwinding depth and the number of rounds.
their default value is 1for both and can be changed with unwind k and rounds k respectively.
the default backend is cbmc and it can be changed using backend bwhere bis one of the following bounded model checkers blitz cbmc esbmc llbmc abstraction based tools cpachecker satabs symbolic testing tools klee support for bounded model checking is mature while abstractionbased and testing backends are only supported experimentally at this stage.
the option rounds uses standard round robin schedules as in .
this can be replaced with restricted schedules using schedule r1 .
.
.
rn which gives schedule restrictions for nrounds as described above.
counterexample generation is disabled by default but can be enabled when using the default backend with cex .
alternatively linemap will show a table of the line maps across all source transformation steps one row for each output line one column for each transformation.
d. availability and installation.
lazy cseq is available as open source software under bsd license.
our tool can be downloaded from uk gp4 cseq files lazy cseq .
.tar.gz.
more information is available in the readme file in the installation package at the url above.
the project s homepage is cseq .
a demo video of the tool is available at soton.ac.uk gp4 cseq files lazy cseq .
demo.mov.
iv.
e xperimental results we have compared lazy cseq .
using cbmc v5.
as a backend against cbmc v5.
itself and cseq .
.
cbmc uses partial orders to symbolically model concurrency while cseq is based on an eager sequentialization implementing a variant of lr and uses cbmc v5.
as sequential backend.
we have used the set of benchmarks from the concurrency category of the software verification competition sv comp held at tacas .
these are widespread benchmarks and many state of the art analysis tools have been trained on them1 lazy cseq .0cbmc .
pthread pthread atomic pthread ext pthread lit pthread wmm fig.
.
lazy cseq .
versus cbmc .
.
i.e.
cbmc in addition they offer a good coverage of the core features of the c programming language as well as of the basic concurrency mechanisms.
since we use a bmc tool as a backend and bmc can in general not prove correctness but can only certify that an error is not reachable within the given bounds we thus conducted the experiments only on the unsafe files of the files in the whole benchmark set with a total of approx.
240k lines of code.
we have performed the experiments on an otherwise idle machine with a xeon w3520 .6ghz processor and 12gb of memory running a linux operating system with bit kernel .
.
.
we set a 10gb memory limit and a 750s timeout for the analysis of each subject.
for each tool and file we set the parameters to the minimum value needed to expose the error.
the experiments for cbmc and cseq .
are summarized by the scatter plots with logarithmic axes shown in figure and figure respectively.
all tools report the correct answers.
both cbmc and cseq time out on files.
furthermore cseq rejects files and returns unknown on files due to translation errors and bugs in the tool .
the experiments clearly show that lazycseq outperforms both cbmc and cseq except on a handful of small files in which cbmc is faster.
overall lazy cseq is about 6x and 20x faster than cseq and cbmc respectively.
v. r elated work in addition to the already cited work there is further related research that we briefly discuss here.
sequentialization was originally developed for two threads and two context switches by qadeer and wu but was subsequently generalized by lal and reps to a fixed number of threads and a parameterized number of round robin scheduling .
later latorre madhusadan parlato extended this work to track only reachable configurations .
further extensions allowed modelling of unbounded dynamic thread creation and dynamically linked data structures allocated on the heap .
poirot also verifies concurrent c programs via sequentialization but it first translates them into boogie and then implements the sequentialization transformation at the boogie level and can thus not be used as a generic concurrency preprocessor.
moreover poirot uses a1 lazy cseq .0cseq .
pthread pthread atomic pthread ext pthread wmm fig.
.
lazy cseq .
versus cseq .
.
different windows based concurrency library not immediately comparable to the posix thread api.
rek implements sequentialization for c via code to code transformation but it is targeted at real time systems and hard codes a specific scheduling policy.
vi.
c onclusions sequentialization is becoming a prominent approach to find bugs in concurrent programs.
it ensures fast prototyping of analysis tools by reusing existing sequential program tools.
our lazy cseq tool is quite robust and competitive with state of theart tools as shown by the experiments.
it also allows for analysis with different specifications reachability deadlock check and different technologies depending on the choice of the backend .
when used with cbmc as backend our tool also generates counterexamples for the input program we are not aware of other tools based on sequentializations that support this.
another interesting feature is the possibility of refining the scheduling of threads by entering a scheduling expression as a parameter that can be useful to guide the analysis when some specific facts on scheduling are known or just to restrict the search.
as future directions we plan to extend the cseq framework with more sequentialization algorithms support for other classes of concurrent programs embedded programs distributed programs and counterexample generation modules for other backends.