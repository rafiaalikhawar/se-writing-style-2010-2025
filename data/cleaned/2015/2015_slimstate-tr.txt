array shadow state compression for precise dynamic race detection williams college technical report cstr may james wilcox university of washingtonparker finch cogniuscormac flanagan university of california santa cruzstephen n. freund williams college abstract precise dynamic race detectors incur significant time and space overheads particularly for array intensive programs due to the need to store and manipulate analysis or shadow state for every element of every array.
this paper presents s limstate a precise dynamic race detector that uses an adaptive online algorithm to optimize array shadow state representations.
s limstate is based on the insight that common array access patterns lead to analogous patterns in array shadow state enabling optimized space efficient representations of array shadow state with no loss in precision.
we have implemented s limstate for java.
experiments on a variety of benchmarks show that array shadow compression reduces the space and time overhead of race detection by and respectively.
it is particularly effective for array intensive programs reducing space and time overheads by and respectively on these programs.
i. i ntroduction the widespread adoption of multi core processors necessitates a software infrastructure that can reliably exploit multiple threads of control.
developing reliable multithreaded software is extremely difficult however due to problems caused by unexpected thread interference which are notoriously difficult to detect reproduce and eliminate.
perhaps the most fundamental interference problem is a race condition which occurs when two threads concurrently access the same location where at least one access is a write.
race conditions typically reflect synchronization errors and they cause highly unintuitive behavior under relaxed memory models .
moreover reasoning about richer concurrency properties such as atomicity serializability determinism cooperability functional correctness etc.
often requires first identifying or limiting where races may occur.
much prior work has explored analyses for race detection.
static analyses e.g.
can offer strong guarantees but due to computability limitations either miss races or report false alarms and they may have trouble scaling to large systems.
a complementary approach is to use dynamic analyses which can be precise for the observed trace meaning that they report errors if and only if there is a race condition in the observed trace of the target program.
a variety of implementation techniques have been developed for precise dynamic race detection including vector clocks epochs accordion clocks and others .
however the spaceand time overhead of precise dynamic race detectors is still prohibitive for many applications.
for example f asttrack s epoch based representation of the happens before relation exhibits slowdowns of roughly an order of magnitude and even greater increases in memory usage particularly for array intensive programs.
thus while precise dynamic analyses are critical for detecting data races and other interference problems in multithreaded systems their current performance limitations preclude their widespread use.
for many programs much of this space overhead is due to race detection for arrays.
we focus on reducing that overhead.
to detect races on an array a a dynamic race detector must record sufficient information about the access history of each array element a to determine if a subsequent access to a is in a race with any previous access to it.
access information is typically stored in an array shadow s where s represents the access history for a .
for example in the common case for the f asttrack race detector s contains the epoch the thread identifier and clock of the last access to a .
programs often access arrays by readily identifiable patterns and those patterns lead to analogous patterns in their shadow arrays.
we present a new race detection algorithm slimstate that dynamically identifies these patterns and uses them to compress shadow arrays.
for example suppose a synchronization free region sfr of one thread traverses all odd elements in a newly allocated array aof size nwhile a concurrent sfr traverses all even elements.
once both sfrs have completed all odd elements in swill be identical as will all even elements.
in this case rather than requiring n shadow elements s limstate represents sas a two element array t where the shadow state for a is now t thus reducing the number of shadow locations from n which could be very large to .
this compressed representation enables a corresponding reduction in the number of race checks.
as the first sfr above traverses all odd elements of a rather than performing a separate race check on each access s limstate builds a footprint ... of accesses to aby that thread without yet verifying those accesses are race free.
s limstate commits that footprint to the shadow state and verifies race freedom at the thread s next synchronization operation.
since all indices in this footprint map to t slimstate only needs to check and update that single shadow location in contrast to the n checks and updates necessary with a traditional shadow array representation.if a later sfr accesses a different footprint of the array s limstate appropriately refines the compressed shadow representation tto avoid any missed races or false alarms.
in contrast prior techniques for compressing shadow state e.g.
are prone to false alarms as discussed in section vii below.
as expected our analysis is most effective on programs that use arrays heavily.
for a collection of array intensive java benchmarks those for which at least of their data belongs to arrays s limstate reduces the heap footprint by35 and improves speed by .
slimstate is most effective on array intensive programs that closely adhere to the access patterns currently recognized.
for others our analysis currently finds less opportunity for compression.
thus s limstate demonstrates the potential of using access patterns to compress shadow state and also opens the door to further exploration of more sophisticated pattern matching adaptive mechanisms to target compression where it is most likely to pay off and static analyses for computing footprints and patterns ahead of time to reduce the need to dynamically infer them.
s limstate may also be adaptable to shadow compression for objects but the relatively small size of objects when compared to arrays will necessitate different strategies than those we have found effective for arrays.
the benefits of compressed shadow arrays are not limited to race detection.
many dynamic analyses for a variety of correctness properties including atomicity determinism and cooperability also maintain a shadow array for each array in the target program.
we expect that shadow array compression may yield comparable benefits for these analyses.
contributions.
the primary contributions of this paper are we demonstrate that array shadow states contain redundancy due to patterned accesses.
we present the s limstate precise dynamic race detection algorithm which partitions arrays into groups of indices with identical shadow states.
s limstate infers those partitions with a dynamic analysis that tracks the footprint of array accesses within each synchronizationfree region.
section iii and section iv .
we explore the design space for representing partitions and footprints using techniques such as ranges strided ranges and bit sets.
section v a .
we develop an implementation of s limstate for java and we report its performance on a variety of benchmark suites.
section v b. for array intensive programs s limstate reduces the minimum heap size by when compared to f asttrack .
section vi.
slimstate also reduces the running time by for array intensive programs.
furthermore s limstate scales to larger numbers of threads significantly better than f asttrack for some benchmarks.
ii.
r eview of dynamic racedetection a race condition occurs when two threads concurrently access a memory location where at least one of those accessesthread athread b x rel m acq m x 1x 2a 1a 4a race!a 4b 8a 5checkcheckcacbs checklm fig.
.
race detection using vector clocks and epochs.
is a write.
accesses are considered concurrent if there is no synchronization dependence between them such as the dependence between a lock release by one thread and a subsequent acquire by a different thread.
these synchronization dependencies form a partial order over the instructions in a trace called the happens before relation .
precise race detectors typically use vector clocks vcs to represent the happens before relation.
given a system in which each thread has a unique identifier t2tid a vector clock v tid!nat records a clock for each thread in the system.
vector clocks are partially ordered v in a point wise manner with an associated join operation t v1vv2iff8t.v1 t v2 t v1tv2 t.max v1 t v2 t a dynamic analysis based on vcs maintains a vector clock ctfor each thread t. the clock entry ct t records thread t s current time.
for any other thread u the clock entry ct u records the clock for the last operation of thread uthat happens before the current operation of thread t. figure illustrates the shadow state caandcbfor a trace of operations performed by threads aandb.
the additional shadow state component lmrecords the vector clock of the last release of lock m. thus when thread aperforms rel m lmis updated to ca h4 0i and cais incremented to h5 0ito reflect that later steps of ahappen after that release.
when thread bperforms acq m cbis joined via twith lm reflecting that later steps ofbhappen after the release by a. following the f asttrack algorithm the shadow state component sxcontains the epoch t cto indicate that the last access to xwas by thread twhen t s clock was c. an epoch t chappens before a vector clock v t c v if and only if the clock of the epoch is less than or equal to the corresponding clock in the vector.
t c v iff c v t a later access to xby thread uis race free provided sx cu.
for example at the second access to xin figure sx a andcb h4 8i.
since cb a this access is race free.
at the third access to x sx b 8andca h5 0i.
since ca b a race condition exists.
1due to space limitations this discussion does not distinguish reads from writes and assumes all accesses to a variable conflict.
our implementation handles concurrent reads by tracking reads and writes in separate epochs and by using f asttrack s adaptive epoch vc representation to record concurrent reads when they are observed .
these extensions are straightforward and pose no technical challenges.
see section v. 2thread athread b acq m a a a a rel m acq m a 0a 1a 2a 3rel m acq m a 0a 1rel m b 2b 2b 2b 2b 2b 2b 2b 2a 5b 2b 2b a 5a 5b 2b 2a 5a 5a 5b 2a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5b 8a 5a 5a 5b 8b 8a 5a 5b 8b 8b 8a 5b 8b 8b 8b 8b 8b 8b 8b 8b 2b 2b 2b 2b 2b 2a 5a 5a 5a 5a 5a 5b 8checkcheckcheckcheckcheckcheckcheckcheckcheck check cacbs t fafblm b 8b 8b 8b 8a 6b 8b 8b 8a 6a 6b 8b 8checka 6a 6b 8b 8b 8b 8b 8a 6b 8refine checkcheckfig.
.
full and compressed shadow state for patterned accesses to an array.
iii.
s hadow compression c heck coalescing as discussed above dynamic race detectors typically maintain shadow state for each memory location which incurs significant overhead.
f asttrack s epochs are perhaps the most lightweight representation for precise race detection but can still lead to an order of magnitude or more increase in memory footprint particularly for array intensive programs.
for example a f asttrack implementation for java that supports concurrent reads maintains two epochs encoded as integers and a possibly null reference to a vc for each element in an array even if those elements are one byte each.
slimstate significantly reduces array shadow state overhead by eliminating redundancy via state compression.
figure provides a simple example of how array access patterns in the target program induce corresponding patterns in the shadow array.
two threads aandbiterate over elements in an array aprotected by the lock m. we show the f asttrack shadow state ca cb lm and sfor each step in the execution where s records the epoch of the last access to a .
note two key aspects of this trace at each synchronization operation above the dashed line all elements in the shadow array sareidentical and within each of those critical sections the checker performs four identical checks namely the check b h5 3ifor thread a s writes and the check a h5 8ifor thread b s writes.
slimstate dynamically identifies such patterns and uses them to compress the array shadow sinto a smaller representation t. since s ...s are identical at synchronization operations s limstate uses a single shadow location t to represent all of s ...s .
to do this s limstate does not immediately perform a separate race check on each access to a instead for each thread t slimstate builds a footprint ft ofa indices that thread thas accessed since its last synchronization operation.
when each thread texits its first criticalsection the footprint ft contains all indices corresponding to shadow state t .
in this case s limstate performs one race check t ct which verifies all accesses toa ... a are race free s limstate then updates one shadow location t tot ct t which simultaneously records the epoch of the last access to all of a ... a .
we refer to this as committing the footprint.
of course threads may access arrays in more complex patterns as well.
for example multiple threads may concurrently access disjoint blocks of elements two threads may concurrently access alternating elements a thread may only traverse some prefix of the array and so on.
s limstate is designed to maintain full precision in all cases by dynamically refining its compressed shadow representation tto precisely represent the original shadow array sregardless of how the underlying array has been accessed.
for example at the end of the third critical section in figure footprint fa does not cover all indices corresponding to shadow location t .
thus tis refined to have two locations where t corresponds to indices and and t corresponds to indices and .
the commit for aagain requires only one check and update to t .
if a thread touched every array element within a critical section the subsequent commit would check and update t andt .
slimstate initially uses the coarse representation of only a single shadow state to represent all elements in an array and then refines that representation as necessary.
in the worst case s limstate may need a finerepresentation where each shadow location in sis maintained separately in which case t s .
however our experimental results show that slimstate is often able to find more compact yet fully precise representations.
since our algorithm defers a check until after the access a race may not be reported until the end of the current sfr.
3however this is a reasonable tradeoff for better scalability and performance in many situations since identifying the memory location and the enclosing sfr is often sufficient to understand and fix the race.
in a production environment existing mechanisms to recover from run time faults like unintended races such as checkpointing can also still be employed by for example ensuring all pending footprints are processed prior to recording checkpoints.
iv.
s limstate analysis details we now formalize the s limstate algorithm and prove that its optimizations do not compromise precision.
a. multithreaded program traces an execution trace !captures the execution of a multithreaded program by listing the sequence of operations performed by its threads.
each operation of a thread t2tid can acquire or release a lock m2lock or access index i2index ... n of a single global array !2trace operation b2operation acc t i acq t m rel t m the simplicity of our execution model is for presentation clarity only.
the actual implementation as described in section v is significantly more complex because it must handle the full java bytecode language and support arbitrarily many arrays and objects other synchronization mechanisms and non conflicting concurrent reads.
in this section we elide these nonessential details in order to clearly present the key ideas of precise dynamic array shadow compression.
b.fasttrack algorithm figure summarizes the f asttrack algorithm adapted for our idealized trace language.
each f asttrack analysis state c l s includes the current vector clock ctof each thread t the vector clock lmfor the last release of each lock m and the epoch sifor the last access to index iof the global array.
the initial analysis state is t.inct ?v m. ?v i .
?e where ?erefers to a minimal epoch ?vis the minimal vc t. and inct v u.ifu tthen v u else v u the rule foracc t i compares the epoch si with thread t s vector clock ct if this check fails the analysis get stuck reflecting a detected race condition.
otherwise this rule updates sito the epoch etof thread t where et t ct t .
we use s to denote the function that is identical to s except that it maps itoet.
the rule foracq t m simply joins lm the vector clock of the last release of lock m with the current thread s clock ct. conversely rule forrel t i updates lm with ctand increments the t component of ct. a trace !
b1...b jisrace free under fasttrack if it can be successfully analyzed by these rules without getting stuck i.e.there exist states ... jsuch that !b1 !b2 !bj j which we abbreviate !
!
j.c.slimstate algorithm the s limstate algorithm in figure represents the shadow array sin a more space efficient manner as the map t p!epoch .
here pis some partition ofindex which means pis a set of parts where each part p2pis a subset ofindex and each index i2index is in exactly one part in p. thus tcontains an epoch tpfor each part p2p.
in the ideal case as in the first two critical sections in figure the partition c oarse index contains a single part index and thus tcontains a single epoch tindex that applies to all indices in the array.
at the other extreme pis the trivial partition f ine i i2index andtcontains a separate epoch t i for each index i meaning dom t dom s index .
various other partitions are of course possible.
for example partition p ... ... divides tinto two epochs for the even and odd indices in the global array and characterizes the refined partition at the end of figure .
slimstate also maintains a footprint ft index recording all indices accessed during thread t s current sfr.
each array access extends this footprint via rule .a thread s footprint must be committed into tbefore it performs any synchronization operation as captured via antecedent ft in rules and .
slimstate s analysis state is represented as a five tuple c l f p t as shown in figure and the relation b describes how the s limstate state is updated for each observed event bof the target program.
footprint commits are handled via the relation vdefined via and .
rule changes the partition pwhile still preserving the epoch for each index.
here p i denotes the part p2pthat contains i. this rule enables the partition pto be refined so that a footprint ftis exactly the union of some parts p1 ... p jinp.
in this case we say that pissufficiently precise for the footprint ft. once the partition is sufficiently precise for a footprint ft rule can commit each part p ft. the rule checks that accesses to pare race free tp ct updates each tpfor these accesses and removes pfrom ft. if the check tp ctfails the analysis gets stuck reflecting a race.
finally the rules and enable multiple vsteps to be performed either before or after each bstep.
the s limstate algorithm is nondeterministic about when vsteps occur as described in section v our implementation determinizes this algorithm by deferring commits as long as possible to optimize representation efficiency based on the largest footprints possible.
slimstate does not check for a race on an access to an index iimmediately.
instead iis added to the accessing thread s footprint and the race is detected later when that footprint is committed.
we say that state c l f p t has a latent race oniifiis in two footprints simultaneously or if iis in a footprint that when committed will reveal a race that is if 9t u2tid.t6 u i2ft fu or 9t2tid.i2ft t p i ct. 4fasttrack analysis slimstate analysis 2ft state c l s where 2ss state c l f p t where c tid!vc l lock !vc s index !epochc tid!vc l lock !vc f tid!2index p partition of index t p!epoch !b b si ct s0 s c l s !acc t i c l s0 f0 f c l f p t acc t i c l f0 p t c0 c c l s !acq t m c0 l s f t c0 c c l f p t acq t m c0 l f p t l0 l c0 c c l s !rel t m c0 l0 s f t l0 l c0 c c l f p t rel t m c0 l0 f p t v p2p p ft f0 f tp ct t0 t c l f p t v c l f0 p t0 pandp0are partitions of index 8i2index .t p i t0 p0 i c l f p t v c l f p0 t0 !
v !
!
!
0v !
fig.
.
f asttrack and s limstate analysis states and transition rules where et t ct t .
the initial s limstate state is t.inct ?v m. ?v t .
coarse ?t where ?tmaps index to?e.
a trace !israce free under slimstate if there exists a state with no latent races such that !
.
d.slimstate precision we now prove that s limstate is a precise race detector by showing that it behaves the same as f asttrack which previous work has shown to be precise .
we begin by introducing the following functions and which map fasttrack states to s limstate states and vice versa ft state !ss state c l s c l t. fine t where t i si ss state !ft state c l f p v c l s where si et ifi2ftfor some t t p i if8t.
i62ft note that is well defined only for states with no latent races.
with these definitions we demonstrate that each f asttrack transition corresponds to a s limstate transition.
below we assume the trace !is not empty since the empty trace is trivially race free.
lemma .
if !b 0then b .
proof is by case analysis on !b .
theorem .
if a trace !is race free under fasttrack then !is race free under slimstate .
proof we have that !
!
for some .
by lemma and induction on !
!
.
moreover 0v .
this transition can be merged into the first step of !
yielding !
.
by the definition of has no latent races and thus !is race free under s limstate .
we now show the converse also holds.
each s limstate transition corresponds to a f asttrack transition provided that the s limstate states have no latent races.
lemma .
if b and and 0have no latent races then !b .
proof is by case analysis on b .
theorem .
if a trace !is race free under slimstate then !is race free under fasttrack .
proof we have that !
for some with no latent races.
hence every intermediate state in this sequence has no latent race and thus !
!
by lemma .
thus !is race free under f asttrack .
since the s limstate relation is non deterministic determining that a trace !
b1...b jis racy under s limstate in theory involves a search to show that there are no possible states ... jsuch that b1 b2... bj jwhere jhas no latent races.
however this search is not necessary the following theorem shows that any reachable state with a latent race is evidence of a racy trace.
theorem .
suppose !
where has a latent race.
then !is not race free under slimstate .
proof in the analysis sequence !
consider the first transition into a state 2with a latent race so that !
b !
where !
!
.b.!
.
by lemma !
!
and by lemma there does not exist a 0such that !b .
hence !is not race free under fasttrack and so by theorem !is not race free under slimstate .
lemma .
suppose b 0where 0has a latent race but does not.
then there is no 0such that !b .
proof is by case analysis on the type of latent race in .
v. s limstate implementation we have implemented s limstate for java and describe the most salient aspects of this implementation below.
a. representation of footprints and partitions the idealized s limstate algorithm of the previous section manipulates arbitrary partitions and footprints.
an implementation could support that full generality by for example encoding those structures with bit sets but a prototype demonstrated that this is prohibitively expensive.
instead the slimstate implementation restricts the general algorithm to footprints and partitions that have efficient representations and that reflect common array usage patterns.
footprints.
slimstate represents footprints as strided ranges of the form hb e ki with the following meaning hb e ki b ik b b ik e thus h0 iencodes h1 iencodes ... and e mpty h1 iencodes the empty set.
for all non empty strided ranges hb e ki we require that b e k and kdivides e b. strided ranges can represent many footprints observed in practice.
the following algebraic rules describe how to extend a strided range with another index which occurs in the rule .
hb e ki i hb e kiifi2hb e ki empty i hi i 1i hb b 1i b k hb b k ki hb b 1i b k hb k b ki hb e ki e k hb e k ki hb e ki b k hb k e ki if a strided range footprint cannot be extended with a new index s limstate commits the current footprint and then adds the index to the new empty footprint.
partitions.
the s limstate implementation supports the following partition modes where ndenotes the length of the corresponding program array and dandsdivide n coarse ... n fine ... n block d ... d d .
.
.
2d ... n d .
.
.
n stride s s 2s .
.
.
n s s 2s ... n s ... s 2s 3s ... n split i ... i i .
.
.
n prefix i ... i i i ... n below are several examples of how these modes divide the index space for an element array into disjoint parts labeled a b .
.
.
that each correspond to a single entry in the compressed array shadow t.p f hb e ki refine p f coarse f h0 n 1i coarse coarse f h0 e 1i split e coarse f hb n 1i split b coarse d0 g c d n b e d0 k block d0 coarse b k n e k k k nstride k coarse e n prefix e block d d0 g c d d b e d0 k block d0 split i f h0 i 1i split i split i f hi n 1i split i split i f h0 n 1i split i split i d0 g c d n i b e d0 k block d0 split i d m a x i e d n prefix d stride s s0 l c m k s s0 n s0 b k n e k stride s0 prefix i f hi n 1i prefix i prefix i e i prefix i prefix i 2e n prefix 2e any any fine table i. p artition refinement rules where f6 empty .aaacoarseaaaaaaaablock babbbabcstride ddabcaaasplit baabbabcprefix dddddaababcdababcd p index space tpartition b lock d applies when sfrs accessing the array always access one or more complete blocks of delements.
partition s tride s applies when sfrs follow a strided access pattern with steps of size s. the c oarse and f inepartitions described previously can be represented either as blocks or strides coarse block n stride ... n fine block stride n ... n partition s plit i applies when elements ... i 1are accessed together and similarly for i .
.
.
n .
partition prefix i maintains separate shadow locations for the first ielements.
this is particularly useful when a program creates a large buffer but only ever touches the first few elements.
each partition mode provides an efficient mapping from an array index i2index to a corresponding index in the shadow array t. eg for b lock d this mapping is simply idivd .
table i describes how a partition pis refined to a new partition refine p f that is sufficiently precise for the footprint f. recall pis sufficiently precise for fiffis exactly the union of some parts p1 ... p jinp.
note that refine p f is a refinement of p each part in pbecomes the union of some parts in refine p f .
the given rules are applied in the order listed and they attempt to minimize the number of parts in the resulting partition.
in particular if pis already sufficiently precise for f then p refine p f .
coarse rules.
the first three rules either preserve the coarse partition or convert it to s plit d if possible.
the fourth rule converts the partition to b lock d0 iffexactly covers one or more blocks in b lock d0 .
we require d0 to avoid converting to f ine block before exploring 6other rules.
the fifth rule converts c oarse to s tride k when given an appropriate footprint.
the last rule converts to coarse to prefix mode if the largest index in the footprint is in the first quartile of the array a threshold heuristically chosen to balance various implementation tradeoffs.
block d rules.
we refine this partition to have a smaller block size d0if we can find a d0that evenly divides both the original size dand the range end points of the footprint f.w e choose the largest block size satisfying this requirement.
split i rules.
we remain in s plit i if the footprint matches either or both parts.
we may transition to b lock d0 if we can find a d0that evenly divides the array size the index i and the endpoints of the footprint f. we may also transition to prefix mode if the original split and the endpoints of fare all within the first quartile of the array.
stride s rules.
we refine s tride s to s tride s0 ifs0a multiple of step size sandfis an appropriate strided range.
prefix i rules.
a prefix partition remains the same if the footprint fis i .
.
.
n or if fonly contains indices in the finely tracked prefix.
otherwise we at least double the size of the finely tracked prefix to appropriately amortize the cost of initializing a new larger shadow array.
if none of the above rules apply the partition becomes f ine.
b. java implementation details we built our prototype in the r oadrunner analysis framework .
r oadrunner takes as input a compiled java target program and inserts instrumentation code into the target to generate an event stream of memory and synchronization operations.
back end checking tools process these events as the target executes.
standard java library classes are not instrumented by r oadrunner and so they are not checked for races and are assumed to not perform synchronization relevant to the target program.
r oadrunner contains special handling for object andthread methods providing basic synchronization operations such as wait andnotify as well as volatile variables.
to facilitate comparisons slimstate reuses the f asttrack reference implementation wherever possible.
indeed the only substantive difference is in the treatment of arrays.
objects are tracked exactly as in fasttrack .
both tools prevent races on their shadow state via optimistic concurrency control mechanisms.
slimstate correctly handles concurrent reads by maintaining separate bit read and write epochs randw in each shadow location and imposing ordering requirements on pairs of accesses only when at least one is a write.
when reads for a location are not totally ordered the single epoch ris replaced with a vector clock as in f asttrack .
array shadows.
for each array s limstate creates an arrayshadow object encapsulating the corresponding partition pand shadow array t where tis stored as an array of adaptive epoch pairs r w described in the previous paragraph.
when pis not sufficiently precise for a footprint being committed s limstate refines that p as described in the previous section and similarly refines the shadow array tas necessary.
arrayshadow objects support concurrent refinements which typically leave punchanged and commitsvia optimistic concurrency control.
each arrayshadow also maintains separate read and write footprints as strided ranges for each thread that has touched its corresponding array.
commit buffers.
for each thread t slimstate maintains a commit buffer recording all arrayshadow s with non empty read or write footprints for t.slimstate flushes that buffer and commits the corresponding footprints whenever tperforms a synchronization operation.
as mentioned earlier if thread tperforms an array read or write that cannot be merged into the arrayshadow s read or write footprint the footprint is committed immediately and the access is recorded in the new empty footprint.
we limit the size of commit buffers to entries and flush them if they become full.
this may lead to sub optimal commits for some arrays but our experience indicates that this does not occur often and that larger buffers lead to performance degradation by preventing the shadow state for an array from being garbage collected even if the array itself has been.
fine and prefix modes.
once the partition for an array is in f ineor p refix i mode s limstate stops building footprints for that array and instead commits accesses to the shadow array as they occur.
small arrays.
the overhead of managing footprints and partitions for small arrays can be higher than tracking those arrays with f ine partitions from the start.
s limstate treats all arrays below a threshold size of as having a f inepartition.
vi.
e va l uat i o n we evaluate the effectiveness of s limstate on the benchmarks listed in figure .
each is labeled with its source the java grande benchmarks the dacapo benchmarks jbb andmtrt colt and raja .
the java grande benchmarks were configured with worker threads and their largest data sets.
r oadrunner contains special provisions to compensate for bugs in the barrier implementations in some of those programs .
we separated the dacapo programs from the dacapo harness and excluded the tradebeans benchmark to avoid limitations of roadrunner s instrumentation loading support.
the code in several specific class files in other programs was excluded from analysis for similar reasons.
these programs were configured to use the default benchmark parameters.
the jbbbenchmark was modified to terminate after a fixed number of transactions rather than after a fixed time.
all experiments were performed on an apple mac pro with a .7ghz core pentium xeon processor with hyperthreading and 64gb of memory.
we used sun s java hotspot bit server vm version .
with the default parallel garbage collection configuration.
both f asttrack and s limstate are precise and report no spurious warnings or missed races.
we manually verified that both tools report the same races modulo variations due to observed interleavings.
array shadow compression.
figure provides an overview of the shadow compression achieved by s limstate s various partition modes.
these benchmarks are ordered according to how well s limstate compresses array shadow state.
the left 7fig.
.
left fraction of shadow array locations in each partitioning mode at their end of their life times.
right how many shadow array locations are needed for each partition mode as a fraction of the original number of locations.
slim alternative bit set representations program s tate footprint partition both crypt .
.
.
.
raytracer .
.
.
.
montecarlo .
.
.
.
lusearch .
.
.
.
jbb .
.
.
.
batik .
.
.
.
colt .
.
.
.
xalan .
.
.
.
pmd .
.
.
.
tomcat .
.
.
.
moldyn .
.
.
.
series .
.
.
.
h2 .
.
.
.
jython .
.
.
.
sunflow .
.
.
.
mtrt .
.
.
.
eclipse .
.
.
avrora .
.
.
.
luindex .
.
.
.
fop .
.
.
.
lufact .
.
.
.
sor .
.
.
.
sparse .
.
.
raja .
.
.
.
average .
.
.
.
table ii.
a rray shadow fractions .side shows the aggregate array sizes for all arrays matching each partition mode relative to the aggregate size of all allocated arrays.
with no compression the shadow state and arrays will be equal in size.
an array may go through multiple refinements over its lifetime and this figure reflects only its final partition mode.
the right half of figure shows the compressed size of the shadow arrays for each partition mode.
for programs like sor andsparse the number of array shadows is identical to the number of array elements since f inepartitions provide no compression.
for crypt and raytracer on the other hand the number of shadow locations is well below of the array sizes.
table ii provides a numeric view of this data.
the second column shows for each benchmark the shadow fraction which is the number of array shadow locations as a fraction of the number of array elements.
s limstate achieves a shadow fraction of .
in comparison to for f asttrack .
slimstate also performs fewer array race checks than fasttrack for these programs.
bit set representations.
columns investigate how the shadow fraction is influenced by s limstate s representations for footprints and partitions.
column shows that using bit sets to represent arbitrary footprints reduces the average shadow fraction to .
column shows that using bit sets to represent partitions reduces it to .
our prototype ran out of memory on the entries marked .
and column shows that using bit sets to represent both footprints and partitions reduces it to .
.
these bit set implementations are prohibitively expensive for many programs but their shadow fractions 8array elems minimum heap space time with no space limits program count x106 of totalshadow fractionbase mb ft basess base ss ft base sec ft basess base ss ft array intesive programs crypt .
.
.
.
.
.
.
.
.
.
lufact .
.
.
.
.
.
.
.
.
.
series .
.
.
.
.
.
.
.
.
.
sor .
.
.
.
.
.
.
.
.
.
sparse .
.
.
.
.
.
.
.
.
.
montecarlo .
.
.
.
.
.
.
.
.
.
lusearch .
.
.
.
.
.
.
.
.
.
xalan .
.
.
.
.
.
.
.
.
.
eclipse .
.
.
.
.
.
.
.
.
.
luindex .
.
.
.
.
.
.
.
.
.
batik .
.
.
.
.
.
.
.
.
.
tomcat .
.
.
.
.
.
.
.
.
.
colt .
.
.
.
.
.
.
.
.
.
jbb .
.
.
.
.
.
.
.
.
.
avrora .
.
.
.
.
.
.
.
.
.
geo mean array intensive .
.
.
.
.
.
object intesive programs h2 .
.
.
.
.
.
.
.
.
.
fop .
.
.
.
.
.
.
.
.
.
moldyn .
.
.
.
.
.
.
.
.
.
mtrt .
.
.
.
.
.
.
.
.
.
pmd .
.
.
.
.
.
.
.
.
.
jython .
.
.
.
.
.
.
.
.
.
sunflow .
.
.
.
.
.
.
.
.
.
raytracer .
.
.
.
.
.
.
.
.
.
raja .
.
.
.
.
.
.
.
.
.
geo mean object intensive .
.
.
.
.
.
overall geo mean .
.
.
.
.
.
table iii.
a nalysis overhead for benchmark programs sorted by the percent of memory locations array elements object fields that are array elements .array intensive programs ha ve a percentage of array elements of at least .
suggest that more expressive representations particularly for partitions may further improve s limstate s space savings.
reduced race detection overhead.
table iii shows the total number of array elements allocated in each program as well as that count as a percentage of all locations array elements plus object fields tracked during race detection.
the table also shows the running time and minimum heap size for each benchmark under three configurations base no race detection f asttrack ft and s limstate ss .
since s limstate is designed to improve the performance of race detection on arrays we focus our attention on the 15array intensive programs for which at least half of the checked memory locations are array elements.
for those programs the running time under s limstate when memory is unconstrained is the running time of f asttrack with a geometric mean of .
when memory is constrained slimstate is able to successfully check those programs in heap spaces that are of the minimum heap required to check them with f asttrack with a geometric mean of .
the most significant improvements are achieved for array intensive programs whose access patterns match our compression modes.
while our focus is primarily array intensive programs we also show the object intensive programs in table iii.
theseprograms which use fewer arrays and typically exhibit large array shadow fractions offer less opportunity for compression.
two notable exceptions are raytracer andjython which use a small number of arrays heavily and in a compressible way.
when all programs are considered the running time under s limstate when memory is unconstrained is reduced to of the running time under f asttrack .
when memory is constrained s limstate is able to check those programs in heap spaces that are on average only of the minimum heap size required to check them with f asttrack .
these timing measurements are the average of runs when the jvm s maximum heap size is set to the machine s physical memory size of 64g which is roughly an order of magnitude larger than the maximum space used by any benchmark under any checker.
minimum heap space is measured by iteratively reducing the jvm s maximum permitted heap size until execution fails to terminate within five times the running time of f asttrack under no memory constraints.
increasing that time limit led to no discernible changes in the results.
some programs where all arrays ultimately have f ine partitions such as sparse still exhibit space and time savings because show arrays are still compressed for parts of their lifetimes including periods when memory pressure is greatest.
slimstate space savings drop from to about when we do not by default use f inepartitions for arrays with fewer cryptlusearch luindexsparse0x25x50x75x100x0x20x40x60x 0x5x10x15x20x25x0x10x20x30x40x0x10x20x30x0x20x40x60x80x 0x30x60x90x2x4x6xheap size normalized to base min.
heap sizerun time normalized to base run time basefasttrackobjfasttrackslimtrack cryptlusearch luindexsparse0x25x50x75x100x0x20x40x60x 0x5x10x15x20x25x0x10x20x30x40x0x10x20x30x0x20x40x60x80x 0x30x60x90x2x4x6xheap size normalized to base min.
heap sizerun time normalized to base run time basefasttrackobjfasttrackslimstatefig.
.
run times for different heap sizes.
than elements due to the additional bookkeeping.
repeating these experiments on a .4ghz core amd athlon processor yielded quite similar results for the arrayintensive programs with mean savings in time and minimum heap size of and respectively.
time vs. space graphs.
since java is a garbage collected language the vm can reduce overall running time at the cost of increased space usage for the heap and vice versa.
figure provides a more complete view of this time space tradeoff for the checkers on representative array intensive programs.
the appendix contains graphs for all programs studied.
in these graphs jvm heap size is normalized to base minimum heap size from table iii and run time is normalized to base time with no space limits.
we also include fasttrack obj a version of f asttrack that only checks for races on objects as a proxy for ideal behavior if allarray checking time and space overhead were eliminated.
the graphs for crypt and lusearch show sizable improvements in both time and space.
other programs such as sparse show modest gains in speed but a sizable drop in the minimum heap size.
for luindex limited opportunities for compression combined with additional bookkeeping lead slimstate to perform no better or slightly worse than fasttrack .
that pattern is repeated in several other programs.
the high variability under different workloads indicates that s limstate may be most effective when used in conjunction with adaptive feedback to target compression where it will be most effective.
scalability.
slimstate has the potential to scale to large numbers of threads better than f asttrack .
to measure this we examined eight array intensive programs with configurable levels of concurrency.
we ran those programs on a system with four .4ghz core amd athlon processors and 256gb of memory selectively varying the number of active cores.
figure shows the minimum heap space top row and run time bottom row versus number of cores for five representative programs.
in that figure crypt montecarlo lusearch andxalan use one worker thread per core and tomcat uses one client thread and one server thread per core.
the results are promising.
the minimum heap space for crypt does not increase very much with the number of threads because the program always uses the same fixed size data arrays.
however f asttrack s running time fails to scale.
as the number of threads increases it suffers from greater garbage collection overhead and bottlenecks on accesses to the shadow state maintained by the race detector.
s limstate scales much better because of its smaller memory footprint and because it updates shadow state for shared arrays much less frequently.
for montecarlo slimstate s compression uses significantly less memory than f asttrack .
the memory requirements for lusearch andxalan both scale better with slimstate requiring less additional memory per thread than fasttrack .
the tomcat program which did not exhibit very good compression in our earlier experiments shows little difference in scalability for the two checkers.
the lufact sor and sparse benchmarks not shown show little deviation from the relative performance under s limstate and f asttrack reported in table iii as the number of threads increases.
vii.
r elated work a common approach for shadow state compression in earlier tools is using a single shadow state for each array and object .
octet uses a similar coarse grained mechanism to enable efficient tracking of crossthread dependences inside a jvm .
to determine if a reported race is real one approach is to re run the program with a more fine grained shadow state for the offending array as in multirace .
another is to switch to a fine grained representation on the fly and hope that a second race manifests later if the first had been a real race as in racetrack .
other recent work on a f asttrack style race detector for c c uses a single shadow state for contiguous memory locations if those locations are accessed within the same critical sections.
however only the first two critical sections accessing those locations are considered and the shadow state is not refined if later accesses are not correlated resulting in potential false alarms.
in contrast s limstate s adaptive compression technique precisely tracks the happens before relation with no false alarms or missed races.
several race checkers defer the processing of accesses until later in the execution.
recplay for example records all memory locations accessed within each sfr and then uses this information to verify that concurrent regions access disjoint memory during replay.
drd and threadsanitizer similarly buffer accesses but do not infer patterns or compress the shadow state.
similar buffering is also common in transactional memory systems .
many other dynamic analyses improve space and time performance by sacrificing precision guarantees in various ways.
for example eraser s lockset algorithm reasons about lockbased synchronization augmented with specialized handling of thread local and read shared data .
other approaches extend that algorithm to be less prone to false alarms .
sampling techniques have also been explored 10cryptmontecarlolusearchxalantomcat 116324864116324864116324864116324864116324864coresmin.
heap mb basefasttrackslimscalecryptmontecarlolusearchxalantomcat 116324864116324864116324864116324864116324864corestime sec basefasttrackslimscalecryptmontecarlolusearchxalantomcat 116324864116324864116324864116324864116324864corestime sec basefasttrackslimstatefig.
.
min.
heap size and running time with no space limits for workloads scaled to the number of available cores.
with some loss of precision .
radish checks race freedom of most accesses in hardware at access time but defers some race checks into a queue processed by another core asynchronously.
the hardware waits for the queue to empty at synchronization points in the same way that s limstate empties its access buffers at those points.
slimstate targets shared memory concurrency.
other programming models may support more efficient race detection e.g.
structured parallelism in cilk or x10 partitioned global address space programs or gpus .
a number of static analyses reason about access patterns in the context of race detection.
dpj for example uses sourcelevel type annotations to enforce access patterns guaranteed to be race free .
r edcard uses a global analysis to infer whether simple access patterns for arrays and objects are followed within all synchronization free code blocks on all executions .
a dynamic analysis can partition shadow state based on that information but r edcard uses a very expensive and somewhat brittle whole program analysis.
s limstate instead infers access patterns that are only required to hold for the observed program trace enabling compression based on patterns that static analysis fails to identify or that are only violated on rare or exceptional control flow paths.
r edcard misses such opportunities.
on the benchmarks in common with that work r edcard reduces the number of shadow locations allocated for both arrays and objects by .
s limstate reduces that number by despite not addressing objects.
viii.
c onclusions and future work dynamic race detectors incur significant space overhead for recording analysis shadow state particularly for arrays.
prior work compressed shadow state by compromising precision.
we show that by recording footprints and adaptively refining the compression strategy s limstate achieves significant compression of array shadow state with no loss of precision.
dynamic analyses for richer concurrency properties such as atomicity or determinism often must first reason about raceconditions in the observed trace and the contributions of this work also serves to potentially improve those analyses as well.
slimstate builds footprints dynamically which involves some run time overhead.
a promising direction for future work is to compute these footprints statically.
adapting s limstate to access patterns and shadow compression for objects is another avenue of future work although it is likely that other techniques will be required to achieve good performance given the size of most objects.