detection of energy inefficiencies in android wear watch faces hailong zhang ohio state university columbus ohio usa zhang.
osu.eduhaowei wu ohio state university columbus ohio usa wuhaow cse.ohio state.eduatanas rountev ohio state university columbus ohio usa rountev cse.ohio state.edu abstract this work considers watch faces for android wear devices such as smartwatches.
watch faces are a popular category of apps that display current time and relevant contextual information.
our study of watch faces in an app market indicates that energy efficiency is a key concern for users and developers.
the first contribution of this work is the definition of several energy inefficiency patterns of watch face behavior focusing on two energy intensive resources sensors and displays.
based on these patterns we propose a control flow model and static analysis algorithms to identify instances of these patterns.
the algorithms use interprocedural control flow analysis of callback methods and the invocation sequences of these methods.
potential energy inefficiencies are then used for automated test generation and execution where the static analysis reports are validated via run time execution.
our experimental results and case studies demonstrate that the analysis achieves high precision and low cost and provide insights into potential pitfalls faced by developers of watch faces.
ccs concepts theory of computation program analysis software and its engineering software testing and debugging keywords android wear smartwatch energy sensor static analysis testing acm reference format hailong zhang haowei wu and atanas rountev.
.
detection of energy inefficiencies in android wear watch faces.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
https introduction wearable devices are becoming increasingly popular.
annual sales of smartwatches are expected to double by reaching over million devices .
other wearables such as head mounted displays body cameras and wrist bands exhibit similar trends.
this popularity is driven by the enhanced mobility and range of activities supported by such devices and by their ability to sense external permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
e.g.
temperature and gps location and user s physiological state e.g.
heart rate perspiration and range of movement .
the focus of our work is the android wear aw platform.
while aw shares some components with traditional android its core features are different from those in the well studied android platform.
for example an aw app running on a wearable device has a lifecycle different from the standard android lifecycle and uses entirely different platform apis.
existing techniques for analysis and testing of traditional android apps cannot be applied directly to aw apps.
some prior work has considered the analysis and testing of push notifications where an android app running on a handheld device e.g.
a smartphone displays notifications on a wearable.
however we are not aware of any work focusing on standalone aw apps in which the wearable operates independently from any handheld.
such apps presents the next generation of software for aw devices and their importance is being emphasized in the latest aw releases.
the increasing use of standalone aw apps requires new research advances and tools to improve developer productivity and software quality performance and security.
an important category of standalone aw apps are watch faces .
our studies discussed in the next section indicate that watch faces are some of the most widespread examples of standalone aw apps among the aw apps we examined around were watch faces.
a watch face uses a digital canvas to display the current time and other contextual information.
it has access to sensors gps bluetooth networks and data providers such as the user s agenda.
watch faces can be designed to be interactive reacting to user s touch and performing tasks according to user provided feedback.
with the introduction of aw .
the functionality of watch faces has become much richer than simply displaying time.
in our case studies we observed watch faces that monitor and display information related to weather light intensity humidity and air pressure as well as user specific information about steps taken heart rate exercise statistics and daily agenda.
we have performed an initial study of watch faces in google play which helped us highlight trends in this area as well as the concerns of watch face users.
based on this study we have identified energy efficiency as one of the key considerations for aw watch faces.
while building watch faces developers have to follow various guidelines to achieve energy efficiency.
our case studies of watch face code as well as our examination of user comments indicate that these guidelines are sometimes violated leading to watch faces that drain the battery.
the first contribution of our work is the definition of several energyinefficiency patterns of watch face behavior .
these patterns focus on two energy intensive resources sensors and displays.
based on these patterns we propose an approach to identify instances of energy inefficient behaviors in watch faces.
the approach is based on three contributions.
first we propose a static control flow model for watch faces in order to capture possibleesec fse november lake buena vista fl usa hailong zhang haowei wu and atanas rountev null interactiveselect ambientstandby palm invisiblepress side button swipe up swipe right swipe left flick wrist out press side button tap screen tiltdeselect press side button swipe right swipe down flick wrist in standby standby palm figure states events and transitions.
run time sequences of events and the corresponding sequences of callbacks in the app code.
while here we use this model for analysis of energy inefficiencies the model itself is more general and could also be used for other categories of static analyses.
next based on the model we define static analysis algorithms based on interprocedural control flow analysis of callback methods and the invocation sequences of these methods.
control flow sequences that statically exhibit the inefficiency patterns are then used for automated test generation and execution where the static analysis reports are validated via run time execution.
the last contribution of this work is an experimental study of applying the proposed approach to a variety of watch faces.
we demonstrate that the analysis achieves high precision and low cost.
our companion case studies explain the underlying causes of these inefficiencies and provide insights into potential pitfalls faced by developers of aw watch faces.
background and app market study several watch faces could be installed on an aw device and only one of them is active at a time.
the user selects the currently active watch face using the watch face picker aw component.
.
watch face lifecycle the lifecycle of a watch face is defined with respect to four states shown in figure .
state null indicates that the watch face is not selected by the user to be displayed that is another watch face is currently active .
in interactive state the watch face is selected to be active is visible on the screen and is responsive to user interactions.
after a certain period of inactivity seconds by default or in response to certain user actions the watch face can transition to state ambient .
in aw devices there is a special mode to save battery life ambient mode in which users are not interacting with the device and the watch face only shows limited information in a battery friendly manner e.g.
with lower resolution and fewer colors.
finally state invisible indicates that a watch face is active but is not visible on the screen and thus is inaccessible for users e.g.
because it is covered by some launched aw app because the watch face picker is invoked or because a push notification is displayed.
while the aw documentation describes these states informally it does not specify a detailed model for possible transitions between states.
as a first step toward constructing such a model we enumerated all possible user triggered events ej.
for each of the four states si we investigated the possible run time transitions from si when ejoccurs.
figure shows all possible transitions.
edges are labeled with events.
a detailed discussion of possible events will1 class breelwatchfaceservice extends canvaswatchfaceservice engine oncreateengine return new engine class engine extends canvaswatchfaceservice.engine watchfacecontroller mwatchfacecontroller void oncreate mwatchfacecontroller new watchfacecontroller void ondestroy mwatchfacecontroller.destroy void onambientmodechanged boolean inambientmode mwatchfacecontroller.setambientmode isinambientmode void onvisibilitychanged boolean visible mwatchfacecontroller.setvisibility isvisible void ondraw ... ... class watchfacecontroller boolean mambientmode boolean mvisibility orientationcontroller morientationcontroller watchfacecontroller morientationcontroller new orientationcontroller void setambientmode boolean ambientmode mambientmode ambientmode if mambientmode morientationcontroller.stop else morientationcontroller.start void setvisibility boolean visibility mvisibility visibility if mvisibility morientationcontroller.start else morientationcontroller.stop void destroy morientationcontroller.stop class orientationcontroller sensor msensor sensormanager msensorservice sensoreventlistener msensoreventlistener new sensoreventlistener ... orientationcontroller msensorservice ... msensor msensorservice.getdefaultsensor sensor.type accelerometer void start msensorservice.registerlistener msensoreventlistener msensor void stop msensorservice.unregisterlistener msensoreventlistener figure decompiled code from the hundreds watch face.
be provided shortly here we only mention a few examples.
event select refers to the selection of the watch face using the watch face picker as a result the watch face becomes active and visible.
event deselect is triggered when the user chooses another watch face using the picker since the picker is displayed on top of the current watch face the source of this transition is state invisible .
the default transition from interactive toambient due to user inactivity is denoted by an artificial standby event.
it is important to note that this model is imprecise.
while it represents all and only possible transitions from each state siupon each event ej not all paths in this model correspond to feasible run time behaviors.
we revisit this issue in the next section.
.
running example state changes trigger various callbacks from the aw platform to the watch face code.
to illustrate these callbacks we use the example in figure .
the example is extracted from the hundreds watch face which is available in the google play app store and has 50k 100k installs.
the hundreds is an apparel and media brand.
the figure shows the decompiled code non essential details are elided.
the code defines a subclass of canvaswatchfaceservice .
this superclass defined in android.support.wearable.watchface provides a canvas on which the code can draw using android painting apis.
nested class engine contains the implementation of the watch face e.g.
drawing hands on the screen setting timers fetching sensor data etc.
the watch face lifecycle start end is defined by callback methods oncreate andondestroy declared inengine .
when the watch face enters ambient mode callback method onambientmodechanged is invoked by the aw platformdetection of energy inefficiencies in android wear watch faces esec fse november lake buena vista fl usa with formal parameter inambientmode equal to true .
upon exiting ambient mode the same method is called with a false parameter value.
similarly callback onvisibilitychanged is invoked when the watch face becomes invisible with parameter visible equal to false and again when it becomes visible with true parameter .
in this example helper class watchfacecontroller maintains two fields.
field mambientmode records the parameter value for the last call to engine.onambientmodechanged .
note that the call at line uses the return value of isinambientmode instead of parameter inambientmode .
helper method isinambientmode is defined in a superclass of engine and returns a value which is the same as the last inambientmode value.
field mvisibility records the parameter of the last call to onvisibilitychanged .
the call at line does not use directly the parameter value of visible but rather an equivalent return value from isvisible .
class orientationcontroller manages the watch face s use of the accelerometer sensor.
at initialization an instance of this class obtains the sensor.
upon state changes the listener is registered and unregistered.
the unregistration line is needed for energy efficiency reasons the aw developer guidelines recommend that whenever the watch face enters ambient mode sensors are turned off to allow the device to enter low power mode.
the code aims to identify transitions to state ambient i.e.
inambientmode at line istrue and stop the sensor.
similarly transitions to state invisible i.e.
visible at line is false stop the sensor.
despite these efforts to follow the guidelines the code contains a logical error.
one possible run time behavior is a transition from interactive toinvisible and from there to ambient .
this could happen for example when the user opens a push notification which transitions from interactive toinvisible but does not do anything for seconds which automatically transitions to ambient .
the run time sequence of callbacks in this scenario is onvisibilitychanged false onambientmodechanged true onvisibilitychanged true .
the last callback occurs because in aw ambient mode is considered to be a visible low power state.
for this callback sequence the sensor is deactivated but then reactivated and remains active in ambient mode in clear violation of aw guidelines.
the underlying problem is the condition at line the correct condition is mvisibility !mambientmode .
this example illustrates some of the challenges in developing watch faces.
first possible aw behaviors are not defined by precise models and could be misunderstood by app developers.
one contribution of our work is defining a control flow model to capture possible event sequences and the corresponding callbacks.
second the management of energy consumption is an important consideration for aw devices and apps.
as our studies suggest mismanagement of energy intensive resources e.g.
sensors screen does occur in real world watch faces.
.
app market study to understand how aw watch faces fit in the larger aw ecosystem we performed an app market study.
we used two collections of aw apps android wear center awc and goko store .
each collection provides a reference to a google play aw app together with an app classification.
for our purposes this classification can be used to distinguish watch faces from other aw 14q3 14q4 15q1 15q2 15q3 15q4 16q1 16q2 16q3 16q4 17q1 17q2 17q3 17q4 18q1010002000300040005000 appswatch faces other aw appsfigure number of watch faces and other aw apps.
figure word cloud of reviews for watch faces.
apps.1for each aw app in these collections including watch faces we used google play to determine the date of the last update.
as of february the total number of aw apps in these collections was of which were watch faces.
figure shows a cumulative distribution of the number of aw apps based on the date of the last app update.
each x axis point corresponds to a quarter e.g.
q4 of .
the corresponding yaxis point is the number of apps whose last update is in this quarter or in any previous quarter.
watch faces present a sizeable fraction of all aw apps this fraction is for the last point on the x axis.
further many of the watch faces in these collections have been updated relatively recently.
from the set of watch faces some are paid and some are free.
we obtained watch faces that were free and available in an unrestricted play mirror .
those watch faces were used in our experimental evaluation described later.
we used a crawler to obtain the most helpful reviews for each watch face.
figure shows a word cloud for the reviews.
we then performed text analysis on reviews containing the top frequent words.
we saw many reviews complaining about the battery usage of watch faces for example although this watchface is very informative it uses up too much battery life it s great but drains my battery crazy fast and unnecessary battery drain for the lg g watch in ambient mode .
these observations highlight the necessity for watch faces to effectively manage energy usage.
modeling of control flow and energy inefficiencies motivated by the prevalence of watch faces among aw apps we developed a control flow model that can be used as the basis for static analysis of watch faces as well as for test generation.
to 1google play does not directly provide a way to identify watch faces and searching for relevant keywords produces a limited number of results many not related to aw.esec fse november lake buena vista fl usa hailong zhang haowei wu and atanas rountev the best of our knowledge this is the first attempt to model the possible control flow behaviors of watch faces.
based on this model we present patterns of energy inefficiencies specifically patterns related to the use of sensors and the displays in ambient mode.
the next section presents static analyses and testing techniques for finding instances of these inefficiency patterns.
.
refined control flow model the model presented earlier in figure does not capture faithfully the full complexity of watch face behavior.
as described shortly we created a tool to explore dynamically all possible sequences of events and states.
based on the observed paths we developed a refined model with a set of states state defined as interactive ambient null invisibleapplist invisiblenotification invisiblepicker .
here we represent the circumstances under which the watch face becomes invisible the user opens the list of apps to select an app to run a push notification is received and displayed to the user and the user opens the watch face picker to select a new watch face.
the resulting model is shown in figure .
the model is based on several categories of events.
the effects ofswiping depend on the direction of the swipe for example swiping from bottom to top opens the stream of push notifications.
putting a palm over the screen causes the watch face to enter the low power ambient mode.
pressing the side button has a variety of effects depending on the current state.
wrist gestures can be used for convenience e.g.
flicking the wrist in out corresponds to swiping down up and shaking the wrist acts like pressing the side button.
tapping on the screen wakes up the watch from ambient mode tilting the screen also wakes up the watch.
as discussed earlier select anddeselect are artificial events representing the activation deactivation of the watch face via the picker and standby denotes an automatic transition after a period of user inactivity.
there is considerable overlap in the behaviors of many of these events.
for simplicity we elide events that have the same behavior as other events but are difficult to trigger automatically specifically palm tilt and wrist gestures.
thus we define the set of events as event select deselect press side button tap screen standby swipe right swipe left swipe down swipe up .
each e event triggers a sequence of callbacks.
the previous section discussed lifecycle callbacks defined in subclasses of engine oncreate called during initialization ondestroy invoked when a watch face is deselected onambientmodechanged used when entering leaving ambient mode onvisibilitychanged called when the watch face becomes visible or hidden.
the last two callbacks are invoked with a boolean parameter indicating the state change.
callbacks oncreateengine oncreate andondestroy in watchfaceservice the class in which an engine is nested are also of interest since they are invoked when a watch face is created and destroyed.
we define the set callback of lifecycle callbacks to containonvisibilitychanged true onvisibilitychanged false onambientmodechanged true onambientmodechanged false oncreate ondestroy wfsoncreateengine wfsoncreate andwfsondestroy .
in the model in figure each state transition is s s e c state state event callback .
here the transition is from sto s upon event e. the transition triggers the sequence of callbacks c.to generate this model we implemented and instrumented a sample watch face to track state changes.
more specifically we created a watch face that implements all relevant apis and then instrumented every method to track state transitions.
further we developed a tool to automatically trigger events in event starting from state null.
this tool also serves as the test case execution engine which will be discussed later in the paper.
we recorded the state change if there was one and continuously triggered events in the new state.
this process was repeated until the state returned back to null or there was no state transition observed.
this systematic exploration produced a set of traces which we analyzed to create the state transition graph in figure .
.
potential inefficiencies due to sensors one of the critical issues for wearable devices is their low battery capacity.
when examining reviews for aw apps we often see users complaining about battery drain.
hardware sensors may be one of the reasons for such drain.
sensors have to be acquired before and released after use.
an app binds a listener to a sensor and unbind it when the data is no longer needed.
callbacks in the listener are invoked when new sensor data is obtained.
this is illustrated by thesensoreventlistener object created at line in figure and the related calls to registerlistener andunregisterlistener .
there are multiple categories of sensors e.g.
acceleration rotation gravity magnetic field heart rate etc.
each category is represented by an integer constant defined in class sensor as exemplified by type accelerometer at line in the example.
typically there exists only one hardware sensor for each category.
a sensor is represented by an instance of sensor in the example msensor refers to such an object.
when a listener is registered with a sensor a callback onsensorchanged in the listener is invoked when new data is available for brevity this callback is not shown in figure .
the guidelines for apps using sensors warn developers to be sure to unregister a sensor s listener when you are done using the sensor or when the sensor activity pauses since if a sensor listener is registered and its activity is paused the sensor will continue to acquire data and use battery resources unless you unregister the sensor .
in order to apply this guideline to watch faces we define two patterns of potential misuse.
in this section we define them with respect to run time behavior while the next section uses static abstractions of this behavior.
first we define a sensor resource as a pair res lis sen where lisis an instance of sensoreventlistener andsenis an instance of sensor .
we use this notion because there could be several listeners for the same sensor object or several sensors that one listener listens to.
let sensor be the set of such pairs.
an invocation of registerlistener for particular lisand senis an acquire operation for the corresponding resources we will denote it by acq res .
similarly calling unregisterlistener is a release operation rel res .
consider a sequence of invocations of callback methods s c1 .
.
.
cmwhere ci callback .
let acqicontain a set of acq res elements such that the execution of callback method ci including the effects of its callees acquires sensor resource res i.e.
it calls registerlistener forresand reaches the exit of ciwithout invoking a corresponding unregisterlistener .
similarly relicontains a set of rel res that occurred during the execution of ci.detection of energy inefficiencies in android wear watch faces esec fse november lake buena vista fl usa interactiveambient standby invisible pickerswipe left swipe right invisible applistpress side button invisible notification swipe up nullselect wfsoncreate wfsoncreateengine oncreate onvisibilitychanged true press side button tap screen press side button standby deselect swipe right press side button standby onambientmodechanged true onvisibilitychanged true swipe down press side button standby onambientmodechanged true onvisibilitychanged true figure state transition graph for watch face lifecycle.
for the running example in figure consider the sequence of states interactive invisiblenotification ambient .
as shown in figure the corresponding sequence of callback invocations is c1 onvisibilitychanged false c2 onambientmodechanged true c3 onvisibilitychanged true .
there is one sensor resource resdefined by the pair of objects obtained at lines and in figure .
the acquire release sets are acq1 rel1 rel res acq2 rel2 rel res acq3 acq res and rel3 .
similarly to traditional program analyses the effects of some ci can be expressed by a transfer function fi s s killi geni where sis a set of sensors resources killi res rel res reli andgeni res acq res acqi .
given a path pin the controlflow model from figure let fpbe the composition of functions fi for the callback sequence along the path.
following the informal general guidelines for sensor management we define two specific patterns of potential inefficiencies.
first consider a path pthat starts from state null ends at that state but does not contain it otherwise.
if fp this means that the watch face acquired some sensor resource but did not release it by the time the watch face was deselected.
the second pattern occurs when a path pstarts at state null and ends at state ambient but does not contain either one as an intermediate state.
if fp in the low power ambient mode which could exist for a long period of time there is active sensor that could drain the battery.
similar patterns have been studied in prior work for android apps but we are not aware of any similar work for aw apps and in particular watch faces which have their own lifecycle and control flow different from that of android apps for handheld devices.
it is important to note that the second pattern does not necessarily signify a problem with the app in some scenarios the app has to record sensor data even in ambient mode.
however in our studies we observed that typically this pattern does indicate unnecessary sensor usage and the programmer should have released thesensor resource before entering ambient mode.
the code in figure exemplifies this problem the programmer has indeed attempted to release the sensor but did so incorrectly.
one refinement that is needed in these definitions is the following in addition to the callbacks in the control flow model the effects of callback onsensorchanged should be accounted for.
upon listener registration the current value of the sensor is almost immediately provided to the listener specifically the aw framework invokes onsensorchanged on the listener object.
this callback could release the sensor.
thus after each callback ciwith an acqi the effects of invoking onsensorchanged should be appended by composing transfer function fiwith the transfer function of onsensorchanged .
.
potential inefficiencies due to displays displaying graphics in bright and vibrant colors consumes more energy than in plain dark colors and may damage the screen if managed incorrectly for oled displays.
dark themes may save as much as seven times the power of all white displays .
in particular for watch faces in ambient mode aw guidelines suggest that developers to keep the graphics simple draw outlines of shapes using a limited set of colors set background to completely black or grey with no image and aim to have of pixels black .
unlike regular android apps where developers typically utilize predefined screen components e.g.
button watch faces only provide a low level canvas to draw on.
developers are given an instance of canvas and the bounds in which the watch face should be drawn.
class paint is used for colors and styles of the drawing.
we are interested in colors and in particular the following apis paint.setcolor int which takes as input a color value and configures the paint to draw the corresponding color and canvas.drawcolor int which takes a color value as a parameter and fills the entire canvas with the specified color.esec fse november lake buena vista fl usa hailong zhang haowei wu and atanas rountev class radialwatchfaceservice extends canvaswatchfaceservice class engine extends canvaswatchfaceservice.engine drawablewatchface facedrawer void oncreate facedrawer new drawablewatchface void onambientmodechanged boolean inambientmode facedrawer.setambient inambientmode void ondraw canvas canvas rect bounds facedrawer.draw canvas bounds class drawablewatchface boolean mactive true paint marcpaint new paint void setambient boolean state mactive !state void void draw canvas canvas rect bounds marcpaint.setcolor 0xff03a9f4 blue if mactive canvas.drawpath secondspath marcpaint marcpaint.setcolor 0xff8bc34a green canvas.drawpath minutespath marcpaint marcpaint.setcolor 0xffe51c23 red canvas.drawpath hourspath marcpaint figure decompiled code from radial watch face.
each color is represented by an integer value such as 0xff000000 black and 0xffffffff white .
there are also apis to obtain color values from rgb and string representations.
for example color.parsecolor transforms a string to its integer representation.
to simplify the discussion we elide such cases and only discuss integer constants in the code but our implementation does handle these other cases.
the drawing on the canvas is performed by callback ondraw which is invoked frequently in state interactive and less frequently in state ambient .
figure illustrates this behavior some details have been omitted for brevity.
helper class drawablewatchface contains the code for updating the canvas when ondraw is invoked.
in interactive mode the hours minutes and seconds hands are drawn.
in ambient mode the seconds hand is not drawn because the screen updates i.e.
the calls to ondraw by default happen every seconds in order to conserve energy.
although this class records the current state interactive vs. ambient in field mactive the code logic inside draw uses the same set of colors for both cases.
we define two patterns for suspicious behavior that may indicate display inefficiencies in ambient mode.
both are defined for a path pin the control flow model of the form interactive ambient interactive .
we consider the callbacks along p with invocations ofondraw interleaved c1 onambientmodechanged true c2 ondraw c3 onambientmodechanged false c4 ondraw .
let colibe the set of colors appearing as parameters to setcolor and drawcolor during the invocation of ciand its transitive callees.
the first pattern we consider is when the set of colors does not change when the state change occurs that is col1 col2 col3 col4.
the example in figure matches this pattern because col1 col3 andcol2 col4 blue green red .
the second pattern is when the colors do change but in ambient mode there are colors that are not black or dark shades of grey.
in the example suppose hypothetically that the call at line which uses the blue color were inside the if statement at line .
in that case we would have had col2 green red andcol4 blue green red which does not exhibit the first pattern but does exhibit the second one.
both patterns indicate that display management in ambient mode may violate aw guidelines.
however we do not consider this to be enough evidence to report a problem.
after our static analysis described in the next section identifies these patterns we generate and execute a test case to trigger the corresponding behavior at runtime.
a snapshot of the watch face in ambient mode is taken and analyzed with respect to the following aw guideline at least x of pixels in ambient mode should be black .
the recommended threshold is in our experiments we use a more relaxed value of and report only watchfaces that are below this threshold.
the entire process of test generation execution and snapshot analysis is automated.
static analysis and inefficiency testing given the patterns defined so far we developed static analyses to construct the control flow model in figure analyze callbacks from the model as well as related callbacks such as onsensorchanged andondraw and identify instances of the potential inefficiencies.
these instances are then used to automatically create test cases whose run time execution is used to decide whether to report the behavior to the programmer.
the use of static analyses has several benefits compared to purely dynamic approaches.
first it provides detailed information about the specific code paths along which the inefficiencies occur which is useful for code analysis and optimizations.
static analysis results can be used to create a small number of targeted test cases to cover the suspicious behaviors which reduces the cost of subsequent testing.
further static analyses can be employed to discover potential problems early in the development process by executing then as part of the suite of static checkers used in development environments.
.
sensor related inefficiencies .
.
sensor resources.
the analysis first determines the acquire and release operations for sensor resources.
recall from section .
that a run time sensor resource res lis sen is a pair of a listener object lisand a sensor object sen. statically lisis anewexpression for a sensoreventlistener .
the sensor object is an instance of sensor and always obtained by calls to getdefaultsensor with an integer constant such as sensor.type accelerometer .
we perform propagation of integer constants to such calls.
for each sensor type the analysis creates an artificial sensor object.
those objects together with the listener objects are then propagated to calls that register and unregister listeners.
those calls correspond to acq res andrel res elements in the analysis.
the propagation is done via flow insensitive context insensitive field based value flow analysis similar in spirit to points to analysis.
.
.
acquires and releases.
for each method ci callback we need to compute its acquire set acqiand release set reli.
callback methods onambientmodechanged andonvisibilitychanged are analyzed under four different contexts for all possible combinations of invisible on off and ambient on off .
here on off refers to the return boolean values of internal apis isinambientmode and isvisible illustrated at lines and in figure .
whenever onambientmodechanged is invoked with true subsequent calls to isinambientmode return true until onambientmodechanged is called again with a false parameter.
there is a similar relationship between onvisibilitychanged andisvisible .
we consider the effects of onambientmodechanged under the four possible contexts of isinambientmode true false detection of energy inefficiencies in android wear watch faces esec fse november lake buena vista fl usa andisvisible true false .
this is needed to capture cases where these status methods are used by the code to query the watch face state e.g.
as done in the running example .
similarly we consider the effects of onvisibilitychanged under the same four contexts.
we have seen examples where both status methods are used in the internal logic of a callback method which means that both should be included in the context.
the analysis uses the context information to identify controlflow branches that are feasible under this context.
first the values of the formal parameters of onambientmodechanged line and onvisibilitychanged line are recorded based on the context.
in the running example onambientmodechanged under context true will set parameter inambientmode totrue here refers to either value for isvisible .
further parameter ambientmode at line and field mambientmode at line will be set to true as well.
as a result the ifstatement at lines will execute the call tostop which will release the sensor resource.
if the context were false the call to start at line would be executed instead and the sensor resource would be acquired.
to account for this context we first propagate the context information using a value flow analysis similar to the one used to analyze sensor types objects and listeners.
we utilize the ssa form of jimple the ir of soot for this propagation.
since we use the analysis results to resolve conditionals e.g.
lines and in the running example whenever several values flow to the same variable field we set its value to i.e.
any .
in essence this is a form of copy constant propagation.
at the end of this propagation the resulting values are used to resolve conditionals if possible.
a value means that both branches are possible.
once feasible branches of conditionals are determined the analysis traverses the control flow graphs of ciand its callees to determine acq res andrel res operations.
for each encountered acq res we perform an additional traversal to determine whether it is postdominated by any matching rel res if so it should not be included inacqi.
for each encountered acq res we perform a traversal to filter out those that are not guaranteed to be executed along all possible control flow paths.
.
.
path exploration.
the acquire and release sets for callbacks are computed on demand during path exploration of the model from figure .
the context information described above is based on the model path being explored.
starting from null we perform a depth first traversal to construct paths that represent the lifetime of a watch face for pattern ending with null or transition to ambient mode for pattern ending with ambient .
only paths whose length does not exceed a parameter kare considered value is set in our implementation .
each cithat is invoked along the path is considered and the current state is maintained to determine the current values of isinambientmode andisvisible needed to decide what context to use for ci.
the traversal maintains a set of acquired but not yet released sensors.
when ciis processed all resfrom reliare removed from the set and then the ones from acqi are added to it.
any remaining resafter the traversal is considered to be an indicator for a potential inefficiency.
we record all such paths for subsequent test generation and execution.
for each reported path we generate a test case based on the events along the path.
the test generation and execution is basedon a wrapper of monkeyrunner developed by us.
consider a path s1 .
.
.
sn.
for each transition s s e c event eis mapped to an api call of the wrapper.
during the execution we usedumpsys in android debug bridge adb to fetch information about acquired sensors.
at the start and end of the execution of a test case the test invokes adb to record all listeners package names and sensor types.
if a sensor is inactive at the start but stays active at the end we consider the static analysis report to be confirmed.
.
display related inefficiencies the first step of the analysis is to determine a set of colors for each call site of set color apis.
recall from section .
that a color is represented as an integer constant.
we perform a propagation of integers in the range of 0xff000000 to0xffffffff to calls topaint.setcolor andcanvas.drawcolor .
the propagation is similar to what was done for sensor types.
next a set of colors colis computed for onambientmodechanged .
the analysis of this callback is done under two different contexts when isinambientmode istrue and again when it is false .
as before the context is used to determine which branches of conditionals are feasible under that context.
during a control flow traversal whenever a call to setcolor ordrawcolor is encountered its set of colors is added to col. to account for the effects ofondraw an artificial call to it is added immediately before the exit of onambientmodechanged .
this allows for the effects of the context to propagate to ondraw .
for the example in figure the boolean parameter to onambientmodechanged which is the same as the context affects field mactive line which in turn is used during drawing line .
our analysis captures these kinds of dependencies.
if hypothetically the call to setcolor at line were guarded by the conditional at line our static analysis would have determined that the corresponding blue color is used only under context false .
the color sets of the callbacks are examined for the two patterns introduced in section .
.
if there is a match of either pattern a test case is generated to select the watch face and put it in ambient mode.
a screenshot is taken during execution when the watch enters ambient mode.
the automated analysis of screenshots is conducted offline.
we calculate the percentage of black pixels and report the watch face as containing a display inefficiency if the percentage is below as described at the end of section .
.
evaluation we implemented the static analysis based on the soot analysis framework .
analysis performance was evaluated on a machine with .40ghz processor 16gb ram and ubuntu .
.
test execution was conducted on an lg watch style running android wear .
.
the implementation of the approach and all benchmarks are available at .
experimental subjects there are two ways to distribute aw apps as standalone apps and embedded inside a handheld app.
recall from section .
that we obtained apks for watch faces from a play mirror .
we first perform a check on all downloaded apks for embedded aw apks.
if an apk has any internal apk we collect the embeddedesec fse november lake buena vista fl usa hailong zhang haowei wu and atanas rountev table characteristics of experimental subjects apps classes methods stmts time sec .
table summary of sensor related inefficiencies.
senpat senpat reported confirmed reported confirmed apk as a study subject.
otherwise we directly use the original apk for further analysis.
table shows the characteristics of all experimental subjects.
the total number of classes of the watch faces is shown in column classes .
this includes all classes except those from the android library and some well known thirdparty libraries such as com.google org.joda and org.mozilla .
column stmts shows the number of statements in soot s ir.
column time sec shows the running time of static analyses and test generation.
the average cost of the analysis is around .
seconds per 10k jimple statements.
.
sensor related inefficiencies table shows a summary of the result of detection for energy inefficiencies caused by mismanagement of sensors.
columns reported show the number of watch faces with potential inefficiencies reported by our static analysis for the two patterns described in section .
denoted as senpat and senpat in the table.
columns confirmed show the number of watch faces with a runtime unreleased sensor during test execution.
in our experiments a total of watch faces are reported to have sensor unreleased when they are inactive and destroyed senpat .
this means that the developer forgot to unregister sensor listeners in ondestroy wfsondestroy andonvisibilitychanged false .
for out of the reports the test cases exposed unreleased sensors.
the analysis reports instances for senpat .
usually this means that the watch face attempted to unregister the sensor listener in an incorrect way e.g.
some cases were missed for transitions to the power saving ambient mode as illustrated by the insufficient check at line in the running example.
this is likely caused by programmers misunderstanding of the watch face lifecycle.
using test execution we confirmed of the reports.
table shows all watch faces that are confirmed to have unreleased sensors during test execution.
the checkmarks in column senpat and senpat indicate in what category a watch face is reported.
the next to last entry corresponds to the running example which exhibits senpat .
an example of senpat is bokeh .
the watch face acquires a gravity sensor to guide the movement of the background image similarly to a live wallpaper in regular android.
there is only one implementation of sensoreventlistener .
registrations for the gravity sensor occur in oncreate and onambientmodechanged false .
every time the watch face enters ambient mode the gravity sensor is released by an unregistration in onambientmodechanged true .
no other places have calls to un registerlistner .
the developer intentionally did this to avoid unnecessary sensor acquisition astable confirmed sensor related inefficiencies.
package name senpat senpat com.atektura.analogglowlitewatchface com.atektura.datestampwatchface com.blis.android.wearable.bliswatchface com.codingforlove.wear.watchfaces com.deglise.sensorface com.face.watch.meo com.mogoolab.androidwear.christmascounter com.newscope.bmwwatchface.row com.newscope.bmwwatchface com.osthoro.animatedearthwatchface com.osthoro.beautifulstuddedwatchface com.pandaeyes.cryptowatch com.smartartstudio.turbo.free.interactive.watchface com.smartartstudio.ultron.interactive.watchface com.trigonesoft.paranormal com.virtualgs.snowwatch com.zanyatocorp.illusionwatchface cz.dmn.bokehwatchface eu.stettiner.diamondwatchface eu.stettiner.dietwatch eu.stettiner.manyiconswatchface info.fathom.watchfaces.coubertin net.yt1300.watchfacemodel101b net.yt1300.watchfacemodel102 pl.nwg.dev.wear.rambler ru.slobodchikov.kgbwatchface wearable.android.breel.com.thehundreds wear.trombettonj.trombt1pearlfree there is no animation in ambient mode.
however when the watch face is deselected no release operation is performed during the transition from invisiblepicker tonull andinteractive toinvisiblepicker .
thus the sensor remains active and drains the battery.
we observed false positives of the static analysis in the following three cases.
first in the ceres watch face reported as senpat a call to isinambientmode is performed inside ondraw and sensor listener unregistration is performed in ambient mode.
our analysis of sensors does not consider this callback.
however according to aw guidelines the system calls the engine.ondraw method every time it redraws your watch face so you should only include operations that are strictly required to update the watch face inside this method .
since ondraw is called much more frequently than the lifecycle callbacks a better design is to move the release of sensors outside of ondraw .
the other two examples are scuba and speeds reported as senpat .
they both maintain an internal state machine using custom enum s to represent the state of the watch face.
this state is then used to correctly acquire and release the sensors.
our analysis does not model the effects of these internal states and state transitions.
based on the results from table analysis precision is for senpat and for senpat .
we also determined analysis recall.
first we checked all watch faces and found that of them register sensors.
we extensively studied the code and the run time behavior of all watch faces and manually identified instances of senpat and instances of senpat .
thus the recall is for senpat and for senpat .
in the three false negatives the listener is the watch face service.
it should be possible to generalize our analysis to handle this case.
for the watch faces that did exhibit run time violations of senpat we performed additional studies of the decompiled code todetection of energy inefficiencies in android wear watch faces esec fse november lake buena vista fl usa table summary of display related inefficiencies.
dispat gemma black white static reported reported determine whether there was legitimate sensor use in ambient mode.
an example of such use could be gathering heart rate statistics or user motion statistics for fitness apps.
however we found only one watch face in which the sensor use may be somewhat legitimate in all other cases the sensors should have been turned off in ambient mode.
this one watch face writes the sensor information to the device log using log.d calls.
these logs could conceivably be used by other apps on the device but those apps would need a special read logs permission to be granted by the user.
it is not clear that such logs would be of any use when the watch face is deployed on users devices.
.
display related inefficiencies table shows a summary of the static analysis reports as well as a comparison with gemma for the energy inefficiencies due to displays in ambient mode.
column static shows the number of watch faces identified by our static analysis as having the two display related patterns described in section .
.
we denote these patterns as dispat and dispat .
recall that dispat means the color set does not change when a watch face goes into ambient mode.
dispat means that the set of colors changes but contains colors that are not black.
we consider colors whose rgb values are below as black.
any color with greater rgb values is considered not recommended in ambient mode.
the number of reported potential inefficiencies is shown in column reported under dispat .
as discussed earlier these static reports should be followed by test execution and analysis of the actual display observed at run time on the device in our case on the lg watch style .
in our experiment of watch faces were observed to violate the guidelines because they contained too many non black pixels in ambient mode.
note that we only consider pixels inside the inscribed circle of a screenshot since all screenshots are taken as square images while the smartwatch we use in the experiment has a round screen.
any pixel beyond the circle is ignored.
to further validate our results we implemented estimates based on the gemma approach .
higher power consumption implies higher energy use over a period of time thus we can use power as an indicator of the energy intensiveness of each watch face in ambient mode.
to obtain estimates of power consumption we analyzed the ambient mode screenshots using our implementation of a gemma based technique.
gemma calculates the theoretical power consumption of oled displays for an app and provides suggestions for power efficient color palettes.
other researchers have used similar techniques .
the power consumption for oled displays can be modeled as a linear function of the rgb values for each pixel.
gemma formulates the function as tp x x 0y y pr rx y pg gx y pb bx y table reports of display related inefficiencies.
package name dispat dispat gemma com.asus.facedesigner com.dylanp.navballwatchface com.epix.nicetimewatchface com.gashfara.surfwatchface com.goldenbrown.watches com.milesoberstadt.radialwatchface com.multidots.watchface com.nickschwab.android.wear.simplefaces com.qmzc.timagine.watchface.earth com.qmzc.timagine.watchface.flat com.qmzc.timagine.watchface.kiwi com.qmzc.timagine.watchface.maze com.raimund.bigsimple ger com.raimund.retrolcd com.rocas.classicfree com.runderbin.blackclassicwatchface com.smartmadsoft.wear.face.everyday com.stmp.counterface com.syzygy.tarvos com.watch.richface.delta com.watch.richface.guard com.watch.richface.infinity com.watch.richface.smartdrive com.watch.richface.throttle com.watchwright.christmas com.watchwright.cross com.watchwright.us com.wearclan.watchface.face com.wearclan.watchface.lightsense com.wearclan.watchface.technomachine com.wearclan.watchface.vividthanksgiving de.uschonha.tinylaser eu.foxjunior.simpleandcleanwathfacefree eu.stettiner.dietwatch fi.fluid.watcherwear org.beatonma.io16 re.hofer.watchface.binary ru.devsp.apps.customwatch watch.richface.androidwear.armada2 watch.richface.androidwear.digitalvision watch.richface.androidwear.fury watch.richface.androidwear.ntouch watch.richface.androidwear.timegate watch.richface.androidwear.valiant watchface.lbriceno.com.binarynerd wear.android.cricking.crickingandroidwear wearable.android.ns.nl.wearabletest here tpis the total power for a given screenshot.
xandyare the total number of pixels in each dimension in our case restricted to the round watch face area xandyare coordinates of a pixel and pr r pg andpb b are linear power consumption functions for rgb values in a pixel.
as observed by others blue pixels consume nearly twice the power of red and green pixels a pixel with white color consumes more power than one with any other color and a black pixel has the lowest power consumption.
recall that we report a watch face as exhibiting energy inefficiencies if the percentage of black pixels is below .
in terms of power this means a watch face is reported if its power consumption in ambient mode is greater than the power consumption of an image with black pixels.
the upper bound of the power consumed by such an image occurs when the other of pixels are all white as white is the most power intensive color.
we use this as a baseline and calculate the power consumption estimate tpbase.
any watch face whose tpestimate is larger than tpbasecan be regarded asesec fse november lake buena vista fl usa hailong zhang haowei wu and atanas rountev a violation.
column reported under gemma black white shows the total number of such watch faces.
table shows the package names of all watch faces reported by the proposed analysis and by our implementation of gemma.
columns dispat and dispat show whether the watch face is reported by our approach as an instance of the pattern.
a checkmark in column gemma indicates a report by our gemma implementation.
our analysis report covers all cases that are reported by gemma estimates.
there are reports by our analysis that theoretically consume less power than tpbaseand thus are not reported by gemma estimates.
they use colors other than black that are not very energy consuming for example red and green.
note that it is easy to use the gemma based criterion rather than the simpler number of black pixels criterion when deciding whether to report pattern instances.
in the public implementation of our approach we include both filters as possible choices for the users of our analyses.
summary.
our results can be summarized as follows static analysis of potential energy inefficiencies in watch faces can be performed with low cost and high precision.
the analysis output provides specific information about the underlying causes of inefficiencies e.g.
executions paths in the code and can be used to generate test cases to exhibit the problem at run time.
using this analysis combined with dynamic checks after test execution we were able to identify watch faces with energy related inefficiencies.
related work android wear characterization and uses.
liu and lin examine hardware and os level characteristics of aw devices to find execution inefficiencies and design flaws.
many researchers have focused on the security issues of aw devices and apps.
do et al.
present techniques to leak sensitive data from aw devices.
mujahid has conducted a study of permission and feature mismatch of aw apps.
liu et al .
present side channel attacks to infer user inputs by exploiting sensors on devices.
there also exists several approaches from the hci community focusing on application scenarios and user interface design.
shen et al .
detect handshakes on aw devices to create secret keys for secure communication.
safedrive collects and analyzes behaviors of drivers for distraction detection.
arduser et al .
use motion data collected in aw smartwatches for text recognition.
reyes et al .
introduce novel gestures based on user s thumb movement.
show captures sensor data to deduce handwriting.
energy analysis for android and wear.
there is a large body of work on energy issues for regular android apps .
several optimizations have been proposed for oled displays .
gemma generates color palettes using multi objective optimization to produce energyfriendly colors.
we use gemma based estimates in our reports and experimental evaluation.
for cases where display related inefficiencies are reported by our hybrid static dynamic approach gemma could be used to provide suggestions for improvements.
banerjee et al .
introduced a dynamic analysis for detection of energy hotspots and bugs in android apps.
their follow up work proposed techniques for debugging and fixing energy inefficiencies based on dynamically generated gui models.
dynamic analysis based on static gui models has also been used forexploring run time inefficiencies including sensor related ones.
static analysis has been employed to report missing deactivation energy defects and to generate test cases for sensor related leaks .
the missing deactivation patterns in our work have similar structure but these existing approaches are specific to regular android apps and cannot be applied directly to aw apps including watch faces which have their own distinct lifecycle and control flow.
energy related behaviors for android have also been considered in other contexts.
jabbarvand et al .
developed an approach to minimize the number of tests needed to uncover energy bugs.
follow up work on droid defines a mutation testing approach to evaluate the ability of a test suite to reveal energy inefficiencies.
cruz and abreu studied the effects of performance based guidelines and practices on android energy consumption and highlighted the need for energy aware techniques.
there are several studies of energy use in wearable devices.
min et al.
present an exploratory investigation of users expectations interactions and charging behaviors when using smartwatches.
poyraz and memik collect activities of smartwatch users in days.
they propose a power model to analyze the characteristics of user behaviors power consumption and network activities.
liu et al .
investigate the usage of push notifications apps and network traffic for a comprehensive power model.
their findings highlight the power consumption in ambient dozing mode because of its long duration.
while these studies are general aw characterizations our work focuses on the detection of specific energy inefficiencies of watch faces by static analysis and testing.
testing and analysis of android apps.
linares v squez et al .
present a summary of the current state of frameworks tools and services for automated testing for android.
choudhary et al .
li et al.
and sadeghi et al .
conduct similar studies.
fazzini et al.
propose a technique for generating platform independent test scripts for android apps.
li et al .
consider the evolution of gui test scripts for mobile apps.
zhang et al .
generate tests using a static gui model .
garcia et al .
leverage symbolic execution to generate inter component communication exploits.
sapienz uses search based testing to explore test sequences.
crashscope uses a model based approach to detect and report crashes.
other representative tools include axiz dynodroid evodroid patdroid gator puma swifthand and trimdroid .
conclusions with the increasing popularity of wearable devices various challenges have emerged for both developers and software engineering researchers.
our work focuses on android wear watch faces which are some of the most popular wear apps.
we propose a watch face control flow model define energy inefficiency patterns for sensors and displays and implement static analysis and test generation to identify them.
the evaluation shows that the proposed approach has low cost high precision and can successfully detect inefficiencies in a wide range of real world watch faces.