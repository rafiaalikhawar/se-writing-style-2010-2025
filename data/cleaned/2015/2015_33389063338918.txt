what the fork a study of inefficient and efficient forking practices in social coding shurui zhou carnegie mellon university usabogdan vasilescu carnegie mellon university usachristian k stner carnegie mellon university usa abstract forking and pull requests have been widely used in open source communities as a uniform development and contribution mechanism giving developers the flexibility to modify their own fork without affecting others before attempting to contribute back.
however not all projects use forks efficiently many experience lost and duplicate contributions and fragmented communities.
in this paper we explore how open source projects on github differ with regard to forking inefficiencies.
first we observed that different communities experience these inefficiencies to widely different degrees and interviewed practitioners to understand why.
then using multiple regression modeling we analyzed which context factors correlate with fewer inefficiencies.
we found that better modularity and centralized management are associated with more contributions and a higher fraction of accepted pull requests suggesting specific best practices that project maintainers can adopt to reduce forking related inefficiencies in their communities.
ccs concepts software and its engineering collaboration in software development open source model .
keywords fork based development collaboration modularity centralized management acm reference format shurui zhou bogdan vasilescu and christian k stner.
.
what the fork a study of inefficient and efficient forking practices in social coding.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa 12pages.
introduction collaboration is essential for software development at scale in both industrial and open source projects.
inadequate models of collaboration can stifle innovation and severely hurt common infrastructure e.g.
when code structure does not align with team structure .
although open source has achieved enormous productivity gains sustainability of the open source movement permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
stdev .
forks contributing backdensity a stdev .
pr merged ratiodensity b stdev .
duplicate prs among rejected prsdensity c stdev .
.
.
.
.
.
hard forks among all forksdensity d figure density plots of four inefficient forking practices with high variance among projects in our sample.
the arrow points towards higher efficiency.
the dashed line shows the median.
is in question without models of collaboration that incorporate volunteers and avoid undue burden on few maintainers .
in this paper we focus on a specific important aspect how to effectively and efficiently collaborate on a common code base with forks.
the notion of forking in open source has evolved traditionally forking was the practice of copying a project and splitting off new independent development forking was rare and was often intended to compete with or supersede the original project .
nowadays forks in distributed version control systems are public copies of repositories in which developers can make changes potentially but not necessarily with the intention of integrating those changes back into the original repository.
with the rise of social coding and explicit support in version control systems forking of repositories has become very popular e.g.
over github projects have more than forks and over projects have more than forks as of june with numbers rising quickly.
however developing with forks does not come without costs.
independent development means contributions are not always visible to others unless an explicit merge back attempt is made.
with a growing number of forks coordination overhead rises .
specifically we note four challenges lost contributions changes published in forks but not integrated back into the original repository are hard to find and de facto lost for the larger community rejected pull requests developers who attempt to contribute but are rejected may be frustrated and refrain from future contributions redundant development developers may independently implement similar functionality in forks without coordination and fragmented communities a lower bar for forking can encourage developers to maintain multiple product variants in parallel fragmenting the community and making it difficult for users to identify the variant of a project that best fits their needs or that is most actively developed .
overall we consider lost contributions rejected pull requests redundant development and esec fse august tallinn estonia shurui zhou bogdan vasilescu and christian k stner fragmented communities as development process inefficiencies and we study how projects can reduce such inefficiencies.
prior work that studied the fork based development model suggests high variance in how and why developers use forks.
for example st nciulescu et al .
found for marlin a heavily forked open source firmware project for 3d printers over forks on github that most forks are inactive no update after forking point and used for configuration rather than new feature development while only few are actively maintained.
similarly jiang et al .
found after surveying github developers that some created forks with the intention of contributing back while others simply used them as a backup.
we also found that github projects are quite different with respect to the discussed inefficiencies as shown in figure 1and as we will discuss in section .
in this paper we study the differences among open source communities in terms of forking practices identify and measure inefficiencies and model how characteristics and practices such as modularity and centralized management are associated with these inefficiencies.
specifically we investigate the research question what characteristics and practices of a project associate with more efficient forking practices?
understanding what influences inefficiencies can help communities to design interventions and to improve communication onboarding and sustainability.
concretely we derived potential characteristics and practices that could affect forking in efficiency by a asking open source developers about their forking practices and b exploring exiting theories on distributed collaboration.
we then tested these hypotheses at scale on github data we designed measures for four inefficiencies and potential characteristics and practices collected data from github projects with different number of forks and used multiple regression modeling.
we found that better modularity of the project structure and more centralized management practices for contributions are strong predictors of more contributions and more merged pull requests.
interestingly our models also reveal a tradeoff centralized management also associates with higher risk of community fragmentation through hard forks as does a low pull request acceptance rate.
our results suggest best practices that project maintainers can adopt if they want to make fork based development more efficient.
our operationalizations and results also lay the foundation for future tool support such as benchmarking projects and highlighting inefficient practices .
in a nutshell we make the following contributions we design measures for open source community inefficiencies and observe differences among projects along these measures.
we identify relevant context factors from literature analysis and interviews and derive corresponding hypotheses.
we fit statistical models that associate context factors with inefficient practices across github projects.
1throughout this paper we use the term inefficiency to concisely describe potential inefficiencies in collaboration.
it is important to note that not all development that is not eventually integrated should be avoided.
in fact competition can be a driver for creativity or for exploring better solutions and the drawbacks of redundancies might be outweighed by reduced coordination costs .
however we argue and find in our interviews that modern forking practices often lead to inefficiencies that many developers would like to reduce.
we aim to find ways in which project leads can influence practices and their outcomes if they chose to set such goals it does not imply a goal to avoid all redundancies or always integrate all changes.
related work history of forking before social coding forking traditionally referred to the intention of splitting an independent development line e.g.
forking jenkinsfrom hudson over governance disagreements to compete with the original repository often under a new name.
here we refer to forking in the sense of creating a public copy of a gitrepository often with the goal of contributing to the original project we refer to the traditional notion of splitting development as hard forking .
hard forks have been discussed controversially the right for hard forks codified in open source licenses was seen as essential for guaranteeing freedom and useful for fostering disruptive innovations encouraging a survival of the fittest model but hard forks themselves were often seen as antisocial and as risky to projects since they could fragment a community and lead to confusion for both developers and users .
there are not many cases where both communities survived after a hard fork with a prominent exception being the bsd variants .
past research on forking focused primarily on hard forks in open source where a popular topic was understanding motivations for forking .
for example nyman et al.
analyzed self described reasons for hard forking and found that variants targeting specific needs or user segments are the most common followed by variants for different hardware porting bug fixes and reviving abandoned projects.
researchers also argued that forking can be a suitable foundation for variant management and to overcome governance disputes .
recent work focused on collaborative development with forks on social coding platforms.
the openness of social coding creates transparency by making development activities in forks public and making pull request pr contributions visible.
prior work studiedgithub s pull request model to investigate the reasons and factors that affect the pr evaluation process .
among the findings both technical and social factors affect the chance of acceptance such as the quality of the pr and the submitters social connection to core members of the community.
prior work confirmed also that forking provides increased opportunities for community engagement e.g.
over half of the commits in the marlin project come from forks .
biazzini et al.
defined three collaboration models of open source projects on github by understanding the dispersion of commits created by forks in the community and revealed that collaboration patterns may differ significantly among projects .
more generally it has been observed that communities often adopt a shared culture of common practices but cultures can differ significantly among communities .
we study which aspects of a community s culture associates with collaboration efficiency.
overall most prior work focused on hard forks though understanding the acceptance of contributions through individual pull requests has recently come in focus.
in contrast we study forks as a collaboration mechanism at the project level and focus on factors associated with project wide inefficiencies.
inefficiencies in forking to motivate our research we explore to what degree forking inefficiencies are common and differ across open source projects.
351what the fork a study of inefficient and efficient forking practices in social coding esec fse august tallinn estonia inefficiency lost contributions.
some developers publish changes in their own forks but not also upstream in the original project.
although technically public these changes are hard to find and potentially lost for the larger community .
fung et al.
report that only of all active forks of nine popular javascript github projects integrated back any changes extrapolating this can amount to significant inefficiencies regarding development talent and lost effort across open source.
in prior work we found that developers are often interested in activities by other developers but simply are not able to follow details in that many forks proactively e.g.
they cite a developer discovering a feature in a fork as if it only exists in this fork then i want to somehow get this feature into my fork.
only very recently tools have been proposed to help developers monitor forks at scale .
we regard a community in which more developers attempt to contribute their changes upstream as more efficient.
in our sample of github projects we identified the fraction of forks that attempt to contribute any changes back among all active forks we will explain details regarding dataset and measurement in section .
in fig a we show high variance across projects in the degree to which developers attempt to contribute their changes from forks back upstream ranging from projects in which almost no forks attempt to contribute back to projects where almost all forks do.
these strong differences in observed efficiency raise the question of why these projects are so different and how project maintainers if they wish to do so can encourage more contribution attempts.
inefficiency rejected pull requests.
not all attempted contributions are accepted by project maintainers.
when developers submit a pull request pr that gets rejected they can perceive this as a waste of their effort and get discouraged from contributing further .
one common reason for rejecting a pr is misalignment with the maintainers vision of the project .
from the community s perspective a project in which most prs are accepted can be considered as more effective with regard to contributor efforts.
observing the rate of rejected prs among all closed prs in our github projects plotted in fig b details in section we see that in most projects a majority of prs are accepted but also note the high variance.
again we would like to identify whether different project characteristics or practices can explain why some projects accept most prs whereas others accept only a small percentage and how project maintainers can strive for more efficiency.
inefficiency redundant development.
globally decentralized fork based development can be especially challenging because of fewer opportunities for rich interaction and direct communication contributors can find it hard to maintain awareness of the project s trajectory or other developers which may lead to redundant development in which two or more people independently work on similar functionality in forks without awareness of each other.
redundant development is a common reason for rejecting prs in many projects in prior work we and others have developed tooling to detect such duplicates .
working on a change just to discover that other developers have previously or in parallel performed similar changes can also be demotivating.
we consider projects that reduce accidental redundancies as more efficient.plotting the fraction of prs rejected due to redundancies in fig1 c details in section we can observe that redundant development is a small but pervasive problem mean .
max .
again we observe high variance across projects worth investigating.
inefficiency fragmented communities.
even on modern social coding platforms diffusion of efforts similar to those discussed for hard forks section can be observed many secondary forks i.e.
forks of forks contribute to other forks but not to the original repository and forks slowly drift apart .
such fragmentation can threaten the sustainability of open source projects when scarce resources are additionally scattered causing redundant work.
for example marlin has several hard forks such as ultimaker which has evolved into an independently managed project with over own forks fragmentation related inefficiencies can be observed for example in a pr for marlin fixing an issue pr that was fixed already years earlier in ultimaker pr .
hard forks are rare but potentially expensive for a community.
plotting the percentage of hard forks among all the sampled forks of each project in fig d details in section we again observe high variance raising the question of what kind of projects are more susceptible to hard forks.
in summary we observe indicators of possible inefficiencies in most projects and high variance in how developers use forks.
suspecting that there are ways to actively encourage more efficient outcomes we study to what degree project characteristics and practices associate with inefficiencies.
determinants of inefficiencies we used a mixed method approach to answer our research question what characteristics and practices of a project associate with more efficient forking practices?
we started qualitatively with interviews and literature analysis to identify candidate context factors project characteristics and practices that may influence effectiveness of fork based development in a project deriving eight hypotheses.
we subsequently operationalize measures for context factors and inefficiencies collect data from github repositories and quantitatively test our hypotheses using multiple regression modeling.
.
identifying potential context factors we pursued two strategies in parallel interviews with active opensource contributors and analysis of the literature on distributed collaboration.
this way we collect perceptions of inefficiencies and their causes from practitioners and can contrast practices in different open source systems while at the same time also considering theories describing factors for efficient distributed collaboration albeit established in contexts outside of fork based development.
specifically we interviewed maintainers and fork owners of several popular open source projects including bitcoin marlin smoothieware and scikit learn the number of forks ranged from to .2k all interviewees had public email addresses on their github profiles about efficient and inefficient practices and what might influence them.
we stratified our sample of interviewees to include maintainers of projects with many forks maintainers of projects with many duplicate prs developers who contributed to many open source projects and developers who made changes in 352esec fse august tallinn estonia shurui zhou bogdan vasilescu and christian k stner forks without attempting to contribute back.
we conducted interviews over skype or email and in person at two mixed academicpractitioner conferences.
to analyze the transcripts we conducted axial coding.
this way we identified context factors that may affect the collaboration efficiencies considering also the theories we found in the literature on distributed collaboration.
modularity affects forking practices.
interviews discussions with contributors familiar with both marlin andsmoothieware revealed an interesting contrast marlin forks and smoothieware forks are both frequently forked open source 3d printer firmware projects but contributors familiar with both perceive very different practices.
learning from marlin s maintainability challenges due to crosscutting implementations smoothieware was designed modularly and emphasizes loose coupling and extension through separate modules so that developers can add functionality without having to modify smoothieware s core.
a developer who is familiar with both projects indicated that smoothieware follows more professional and industrial development practices such as submitting smaller and more cohesive changes.
one interviewee indicated not contributing their significant extensions back to marlin because of high integration effort.
on github some projects have an extremely modular structure e.g.
homebrew contains a collection of scripts or plug ins that are assembled automatically such that many contributions simply add files instead of modifying existing ones.
modularity was not entirely uncontroversial in our interviews though e.g.
one smoothieware contributor suggested that modularity helped with some extensions but made others harder so many restrictions that you can t just modify anything in the base code.
all this makes the code upgradeable clean and manageable but the development progress is much slower because some functions cannot be integrated with those restrictions.
this suggests tradeoffs regarding the rigidity that modularity imposes on developers making certain changes hard or impossible.
literature our interview observations align with theory outside of social forking contexts about the importance of modularity for distributed collaboration.
for example parnas and conway have both argued for the importance of modularity for collaboration and division of labor.
herbsleb and grinter found modularity aligning with work assignments to be essential for a geographically distributed software project.
researchers and practitioners have also emphasized the importance of modularity for open source development .
for example torvalds claims for without you cannot have people working in parallel and midha and palvia found that modularity is positively associated to technical success of open source projects.
specifically maccormack et al .
suggested that more modular projects could be more attractive to potential contributors.
it is hence plausible that modularity also has positive effects on collaboration efficiency in fork based development among looselyconnected developers on social coding platforms.
at the same time researchers have found that many aspects of a software system are difficult to implement modularity and that too rigid compatibility requirements might hinder innovation also modularity does not always align with how developers think .
hypotheses despite raised concerns we hypothesize that a modular design of the software would make it easier to contribute toa project which influences both whether developers attempt to contribute and to what degree maintainers accept contributions h1.projects with a better modular design have a larger fraction of contributing forks.
h2.projects with a better modular design have a larger fraction of merged prs.
coordination mechanisms affect forking practices.
interviews interviewees of many projects including marlin andsmoothieware indicated that their communities welcome all prs that may benefit the larger community and that they are interested in activities in various forks though they find it hard to monitor them.
in contrast an interviewee from the cryptocurrency project bitcoin forks expressed a different view bitcoin has adopted a central management style in which a relatively stable team of core developers decides the direction of the project and in which features are discussed and decided upfront in an issue tracker often political and hard fought among different camps .
the issue tracker records which forks contain the corresponding code changes for each issue other forks are of little interest to maintainers and unsolicited prs remain ignored for years.
similarly one of the maintainers of the python machine learning project scikit learn forks indicated that developers have little chance of integrating their changes upstream unless they talk to the maintainers first.
developers also perceive explicit coordination as a key mechanism to avoid redundant development.
certain open source communities perceived redundancies as a significant problem and promoted explicit coordination to combat it e.g.
django adopted a policy requiring contributors to communicate with the core team upfront to claim issues before submitting patches .
a maintainer ofscikit learn was even surprised about the existence of duplicate prs because in their project explicit coordination developers discuss with the core team before any work is the norm.
literature researchers have long studied different degrees of explicit coordination and their tradeoffs in distributed collaboration often in corporate settings e.g.
brandts and cooper found that central coordination makes it easier to manage a division s product types but more difficult to take advantage of each division s private information.
comparing linux and wikipedia to traditional organizations puranam et al .
observed that linux uses a centralized task division strategy in which the initial problem formulation is defined by the founder of a project while wikipedia s task division is decentralized which the researchers associate with problems of misinformation and duplication contributions.
regarding task allocation linux and wikipedia are both decentralized so that tasks are allocated through voluntary self selection of members into roles.
shaikh and henfridsson studied the version control history of linux and observed that linux changed its management strategies as the community evolved from centralized to decentralized the authors argued that the governance strategy is a configuration of coordination processes and governance varies across open source communities.
this matches our observation of different communities with different coordination strategies.
we expect to see similar tradeoffs among coordination strategies also in new forms of collaboration with forks in open source.
353what the fork a study of inefficient and efficient forking practices in social coding esec fse august tallinn estonia hypotheses we hypothesize that projects coordinating contributions upfront in an issue tracker reduce inefficiencies by encouraging more focused development activities that are more frequently integrated and rejecting fewer prs because fewer prs misalign with the maintainer s vision.
we also hypothesize that pre communication i.e.
developers discussing their contributions before submitting prs associates with fewer redundant prs h3.projects pursuing a centralized management strategy have a larger fraction of contributing forks.
h4.projects pursuing a centralized management strategy have a larger fraction of merged prs.
h5.projects in which external developers tend to discuss or claim an issue before submitting prs have a lower frequency of redundant development.
contribution barriers affect community fragmentation.
interviews some interviewees indicated that contribution barriers led them to create a hard fork e.g.
the owner of a video recording project explained i submitted a pr but they rejected it.
because it is incompatible to the maintainer s vision so i think fine i will keep my own fork.
later this fork started to attract its own external contributions.
also as one smoothieware interviewee said quote above the rigidity that modularity imposes on developers makes integrating certain changes hard or impossible leading in some cases to active but unmerged development bitcoin with its rigorous centralized management is one of the projects that has the most hard forks.
disagreements between maintainers and contributors can lead to hard forks and fragment communities.
literature as discussed in section reasons for hard forks have been well studied before the rise of social coding and distributed version control and conflicts between the project leader s vision and the needs of community members were a common cause .
hypotheses we hypothesize that a low rate of accepted external contributions modularity restrictions and centralized management all can trigger community fragmentation h6.projects with a lower pr merge ratio have higher likelihood of having at least one hard fork.
h7.projects with a more modular design have higher likelihood of having at least one hard fork.
h8.projects pursuing a centralized management strategy have higher likelihood of having at least one hard fork.
note that h6uses the pr merge ratio the predicted outcome in h2andh4 as a factor.
that is we expect potential tradeoffs in that factors that improve efficiency regarding merged prs could at the same time reduce efficiency regarding community fragmentation.
summary and importance.
modularity and coordination are established theories in software engineering.
after reviewing the literature and interviewing open source contributors we derived eight hypotheses about context factors informed by the two theories that are expected to associate with inefficient outcomes in a domain where the theories have not been tested before fork based development.
to test these hypotheses we operationalize our context factors in github trace data and model their effects at scale across many open source projects details in section .
.
this way we not only test the limits of the two theories and expand them in a commit history of fork and upstream b only f only exist in fork only u only exist in upstream f2u merged from fork to upstream u2f pulled from upstream to fork.
figure determining the origin of commits.
the new domain of fork based development but also provide quantitative empirical evidence on the effects of the different context factors on relevant outcomes where previously there were only beliefs.
this step of providing data driven empirical evidence to popular theories is particularly important as beliefs and evidence often misalign in software engineering practice .
.
operationalizations we iteratively developed outcome measures for inefficiencies measures for context factors and measures for control variables.
specifically we first developed an initial measure and subsequently validated construct validity by manually checking samples and outliers repeating the process with a refined measure as needed.
several measures are nontrivial and are built on top of significant prior research as we will discuss.
we share implementations for all measurements as part of our replication package .
outcome ratio of contributing forks.
to assess inefficiencies regarding lost contributions we measure the fraction of active forks in which developers have submitted prs or otherwise integrated their code changes into the upstream project higher values indicate higher efficiency .
specifically we query the github api to identify whether prs have been issued for any commits from a fork.
we also analyze the commit histories to identify whether commits have been merged without publicly visible prs.
unfortunately reliably detecting active forks and merged changes is not trivial.
forks may pull changes from upstream upstream repositories can merge changes also without prs commits are often merged across various branches and commit timestamps are not generally reliable.
hence we developed a new approach to identify from which fork a commit originates and how it has been merged across branches and forks.
to this end we analyze the joint commit graph of the fork and the upstream repository nodes are commits edges are parent relationships merge commits have multiple parents .
since commits may be merged multiple times and in different directions across branches and forks we analyze the number of merge commits and 354esec fse august tallinn estonia shurui zhou bogdan vasilescu and christian k stner assign a commit as originating in the fork from which it was merged the fewest times as follows each branch in the fork and the upstream repository corresponds to a commit node in the graph usually a node without children .
for merge commits we distinguish between the direct parent first parent and the merged parents other parents of a commit.
we assign a weight of to an edge between a merge commit and its merge parents and a weight of to all other edges.
for every commit node the shortest path from that node to a commit node mapped to a branch indicates the branch and thus the repository the commit originates from.
if there is no path from a commit to any branch of a repository it has not been merged into that repository yet.
we illustrate an example in figure a commit node has been merged from a branch into another branch and from the fork into the upstream master by counting the merge edges we can identify that it originates from the fork because more merge edges need to be traversed to reach a branch from the upstream repository similarly we can identify that commit node originates from upstream there is no path from commit node to the upstream repository indicating that the commit originates from the fork and has not been merged yet.
note a similar mechanism to recognize the origin of commits was suggested in prior work but without a description of how to perform it and without releasing an implementation.
to measure the ratio of contributing forks we determine which forks are active i.e.
have commits originating from the fork then identify successful and attempted contributions from merged commits in the commit graph and from prs originating from the fork.
outcome ratio of merged prs.
to assess inefficiencies regarding rejected prs we measure the fraction of closed prs that have been accepted higher values indicate more efficient outcomes .
the resolution status reported by github is often not reliable as many developers integrate prs through other mechanisms than github s user interface thus closing them without marking them as accepted.
we follow gousios heuristics to identify accepted contributions but refine them to account for frequent practices we observed if the pr is marked as merged on github we mark it as accepted.
.
of all merged prs .
if a commit closes the pr using certain phrase conventions advocated by github e.g.
fixes and that commit appears in the target project s branch we consider the pr as accepted.
different from gousios work we use github s issue events timeline api rather than analyzing textual comments to detect links to prs in commit messages.
.
of all merged prs .
if any of the last discussion comments of the pr refers to a commit sha we consider the pr as accepted.
specifically we follow gousios criteria the comment contains a reference to a specific commit identifier sha this commit sha appears in the project s master branch and the comment can be matched by the regular expression merg apply appl pull push integrat land cherry s pick squash ing i?ed .
we extended this by making sure that no second linked pr appears in the comment indicating a competing or superseding pr.
.
of all merged prs .
if the last comment before closing the pr matches both rules and above or matches only rule we consider the pr asaccepted unless a link to another pr appears in the comment.
.
of all merged prs .
if no heuristic identifies a pr as accepted we mark it as rejected.
outcome ratio of duplicate prs.
to assess inefficiencies regarding duplicate development we measure the fraction of closed prs rejected due to redundant work lower values indicate higher efficiency .
to identify duplicate prs we refined heuristics summarized and validated by yu et al.
based on regular expressions to identify duplicate related keywords in pr comments and links to other prs.
we also found many cases in which a pr is redundant to a commit so we extend the link detection to include commit shas.
after several rounds of refinement we arrived at six patterns for detecting prs rejected due to redundant development that can be found in the implementation .
outcome presence of hard forks.
to assess inefficiencies regarding community fragmentation we measure whether projects have at least one hard fork.
we consider a fork as a hard fork if a it has attracted its own external contributions at least two prs submitted by other contributors or b it has substantial unmerged changes at least commits as identified from our commit graph see figure and the project s name has been changed with levenshtein distance .
in our sample of the projects have at least one hard fork as per our operationalization.
predictor for modularity logic coupling index.
researchers have proposed different metrics to measure the modularity of a project taking different perspectives.
for example many approaches use program analysis to detect dependencies among program structures others measure logic coupling from cochange patterns observed in the project s revision history .
to measure modularity uniformly across projects in different programming languages we adopt a light weight previously validated measurement of logic coupling rose we define the logic coupling index of a commit as the fraction of file pairs that have been changed together in that commit out of all file pairs in the project.
we aggregate this measure at the project level by computing the median of recent commits.
to focus on modularity relevant to external contributors and avoid bias from past but now changed practices for each project we analyze the last commits whose authors are external contributors the results are robust for different operationalizations with the last or commits .
a lower logic coupling index indicates better modularity as fewer files are changed together.
predictor for modularity additive contribution index.
in addition to logic coupling we also measure the modularity of contributions in terms of whether they add or modify code.
this measure is motivated by observations discussed above that some github projects have an extreme form of modularity in that they primarily collect extensions or plug ins and are extended by contributing additional files rather than editing existing ones.
thus we define a second modularity measure the additive contribution index that measures to what degree external contributions are additive we measure the fraction of new files added out of all files touched per commits.
we compute the median over results of all commits from external contributors in a project.
a higher additive contribution index indicates that more changes were additive in nature indicating better modularity from a contributors perspective.
355what the fork a study of inefficient and efficient forking practices in social coding esec fse august tallinn estonia predictor for coordination centralized management index.
we measure the degree developers use the issue tracker to coordinate what to work on before submitting a pr we observe which new prs are linked to existing issues typically by referring to the issue number in the text of the pr by parsing the event timeline of the pr provided by the github api.
we define the centralized management index of a project as the fraction of prs that link to issues out of all closed prs from external contributors.
a higher centralized management index indicates that upfront coordination on what to work on through issues is more common in a project.
predictor for coordination pre communication index.
we additionally measure to what degree developers coordinate who will work on an issue before submitting a pr by observing whether developers claim an issue before completing the work.
specifically we look for two commonly recommended practices of precommunication before submitting a final pr developers might leave a comment on the issue to which they later respond indicating their plan to work on the issue and possibly linking to their fork.
following explicit recommendations from github developers might submit an incomplete pr clearly marked as work in progress e.g.
using labels and later update that pr once they finish their work.
both practices publicly announce that a developer is working on an issue.
we define the pre communcation index of a project as the fraction of prs for which the author has commented under the linked issue before submitting the pr or in which the pr was marked as work in progress in its history out of all closed prs by external contributors that are linked to issues.
a higher pre communcation index indicates that the practice of coordinating who will work on an issue is more common in a project.
control variables.
finally we measure a number of controls that might co vary with our efficiency outcomes.
specifically we collect form the github api the project age size in bytes and number of forks older bigger or more heavily forked projects are likely to adopt different practices.
we additionally collect projectlevel aggregate statistics about all closed prs by external noncore contributors modeled closely after factors that prior research found to correlate with the chance of accepting individual prs submitterpriorexperience a dummy encoding whether at least half of the prs in the project are submitted by people with prior experience submitting and having merged prs in the same project in the past prs from people with prior experience are more likely to be accepted .
ratioprswithtests the ratio of prs containing test cases prs containing test cases are more likely to be accepted .
we reused our measure to identify tests based on file name patterns maintained by the package search service npms.io such as matching file paths containing test orspec.
prhotness the median over prs of the number of commits on files touched by each pr during the previous three months prior to the pr creation prs touching hot files changed frequently in the recent past are more likely to be accepted .
and submittersocialconnections a dummy encoding whether at least half of the prs in the project are submitted by people who followed already at pr creation time the maintainer who closed each respective pr prs by more socially connected submitters who follow the maintainers are more likely to be accepted .table how we stratified our sample.
group num.
forks num.
projects on github num.
projects in sample a b c .
data collection we assembled a multidimensional dataset of actively developed github open source projects with at least a moderate number of forks.
starting from a list of projects with at least forks in the march ghtorrent dump we filtered projects based on the following criteria projects should be developing software applications or frameworks.
interested in understanding software development practices we remove projects using github for document storage or course project submission.
we search for keywords like homework assignments course to find online courses remove projects starting with awesome usually document collections and remove projects with no programming language specific files.
projects should have at least commits active forks and closed pull request.
we are interested in active projects with some development history and some collaboration so we set a minimum threshold of commits active forks i.e.
those with at least one own commit after forking and at least one pull request by an external contributor.
projects should have at least one closed issue.
finally we exclude projects that do not use the issue tracker because we cannot establish coordination practices for those.
to not bias our analysis by practices applied by the largest or by many small projects we stratify across projects with different numbers of forks sampling very frequently forked projects frequently forked and moderately forked as shown in table in each stratum we select a random sample.
finally we exclude all projects from which we have previously interviewed developers and duplicate projects resulting in projects for our analysis.
for each project we need to analyze forks external commits external prs and issues.
we only consider external prs and external commits by developers who are not project owners and have not closed prs of others in the project.
since computing the flow graph in fig.
2requires locally cloning all forks in a project and is computationally expensive we sample active forks per project that were forked more than days before our analysis to allow for time for developers to attempt to contribute changes back.
we use the github api to fetch the history of each issue and links among issues and prs.
in figure we show the ranges and distributions of the four operationalized measures of modularity and coordination in our dataset.
note the large variance across projects for all variables.
.
statistical analysis we use multiple regression modeling to test for each outcome whether it is significantly associated with the different hypothesized context factors while controling for known confounding variables cf.
prior work.
the multivariate nature of our analysis is especially relevant when modeling the pr merge ratio which is known to be impacted by the presence of tests and the prior experience of the pr submitters .
356esec fse august tallinn estonia shurui zhou bogdan vasilescu and christian k stner stdev .
.
.
.
.
.
modularity indexdensity a stdev .
.
.
.
.
.
additive contribution indexdensity b stdev .
.
.
.
.
.
centralized mngmt indexdensity c stdev .
.
.
.
.
.
ratio precommunicated prsdensity d figure density plots for our main predictors.
the dashed line denotes the median.
note that we perform our analysis at project level each row of data aggregates information about one project i.e.
we compare how projects with different characteristics and practices tend to differ regarding forking inefficiencies on average.
for the binary outcome variable presence of hard forks we build a standard logistic regression model.
notably we also build logistic regression models for the other three ratio outcome variables.
logistic regression is more appropriate when trying to estimate probabilities of frequencies ratios than linear regression because in the latter case the binomial probabilities would become increasingly spiked as the number of observations increases e.g.
the case with pull requests merged out of submitted gives more information than the case with merged out of submitted.
in a glm the denominator from the ratio e.g.
for the former example and for the latter can be specified explicitly as the weights parameter when using the glmfunction in r. when building the regression models we take several steps to ensure robustness and validity.
first we conservatively remove the top up to of the data for variables with exponential distributions these outliers tend to have high leverage decreasing the models robustness.
we also test for high leverage points using cook s distance measure and exclude additional projects from each model as needed below each regression model summary table in section we show the exact number of data points modeled.
second we test and correct for multicollinearity using the variance inflation factor vif .
third we evaluate the goodness of fit of our models using mcfadden s pseudo r2measure.
finally we report for each model variable its exponentiated coefficient i.e.
its odds ratio the factor by which a one unit increase in a predictor increases if greater than or decreases if less than the odds of the outcome occurring standard error significance level p value and effect size i.e.
2 the fraction of deviance explained by the model that can be attributed to that predictor as per an anova type ii analysis see columns lr chisq in the model tables for the absolute amounts of deviance explained .
.
threats to validity as usual our operationalized measures can only capture some aspect of the underlying quality.
for example logic coupling at the file level may miss some more granular dependencies that may make changes challenging and our centralized management index may miss rare practices such as coordinating in a separate channel.
as discussed we manually validated construct validity of each measure on a sample of projects to avoid systematic errors andtable contributing forks model r2 .
ratio contributing forks coeffs errors lr chisq intercept .
.
numforks .
.
.
size .
.
.
projectage .
.
.
centralizedmngmtindex .
.
.
modularityindex .
.
.
additivecontributionindex .
.
.
p .
p .
p .
n explored different operationalizations to ensure robustness.
while we cannot exclude some noise regression across over one thousand projects will likely pick up on signals despite some noise in measurements.
nonetheless our results must be interpreted in the context of our operationalization.
to this end we share an r notebook detailing our analysis .
finally one must be careful to generalize our results beyond the context of our analysis of social coding in open source projects on github.
although many companies increasingly adopt practices from open source development they likely do not share the same context of loosely coordinated distributed contributions from developers outside a core team.
results in the following we discuss results from hypothesis testing organized by forking inefficiency outcomes .
when do forks attempt to contribute back?
h h3 to test our hypotheses that modularity h1 and coordination practices h3 associate with higher rates of attempted contributions we modeled a project s ratio of contributing forks as a function of the two modularity indices and the centralized management index while controlling for the overall number of forks the project size and the project age.
in table we show a summary of the regression model.
interpreting the coefficients we first note a strong positive effect for the centralized management index explaining approximately of the deviance explained by the model projects with stronger coordination practices asevidenced byadvanced planning ofwhat work needs tobedone through issuelinking tend tohave ahigher fraction ofcontribut ingforks that submitpatches upstream.
modularity in terms of logic coupling also has a positive effect albeit weaker accounting for about of the deviance explained by the model projects with more modulararchitecture inwhich changes canbemade inrelativeisolation withouttouch ingmany files tend tohave ahigher fraction ofcontribut ingforks.
therefore we find evidence in support of both h1andh3.
when are more contributions integrated?
h h to test our hypotheses whether modularity h2 and coordination mechanisms h4 may also facilitate the integration of changes originating in forks back into the upstream project we modeled the ratio of merged prs submitted by external contributors as a function of the modularity and centralized management indices.
in the regression we control for known confounding factors as per prior work the total number of forks the project size and age the prior experience 357what the fork a study of inefficient and efficient forking practices in social coding esec fse august tallinn estonia table external pr merge ratio model r2 .
ratio merged prs coeffs errors lr chisq intercept .
.
numforks .
.
.
size .
.
.
projectage .
.
.
submitterpriorexperiencetrue .
.
.
submittersocialconnectionstrue .
.
.
prhotness .
.
.
ratioprswithtests .
.
.
centralizedmngmtindex .
.
.
modularityindex .
.
.
additivecontributionindex .
.
.
p .
p .
p .
n table duplicate pr ratio model r2 .
ratio duplicate prs coeffs errors lr chisq intercept .
.
numforks .
.
.
size .
.
.
projectage .
.
.
ratioprecommunicatedprs .
.
.
p .
p .
p .
n of the pr submitters the ratio of prs containing test cases and the median pr hotness.
in table we summarize the regression results.
as expected most of the deviance explained by the model is attributed to the control variables.
still even after controlling for confounds all three main predictors have sizeable positive effects on the average pr merge ratio.
modularity operationalized as low logical coupling and high ratio of added files to modified files has the strongest effect of the deviance explained for the two variables together the more modularthearchitecture thehigher thefraction ofmerged prs.
coordination also has a positive and comparably large effect of the deviance explained themore planned theprsare i.e.
inresponse toopen issues thehigher theaverageacceptance rate other variables held constant.
together these results provide strong support for both h2andh4.
when is duplicate work more common?
h to test whether discussing or claiming an issue before submitting a pr correlates with less redundant development h5 we modeled the average rate of duplicate prs per project as a function of the rate of precommunicated prs controlling for project age project size and number of forks older projects and bigger projects with more forks can be expected to experience more duplication on average .
the regression summary in table 4suggests that the higher the rate at which prs are pre communicated the lower the overall rate of duplication among prs.
however we model rare events both duplicates and pre communication are relatively rare in our dataset the model fit is rather poor r2 and our pre communication index explains only of the deviance explained by the model.
we conclude cautiously that there isonly weak evidence thatclaim ing prsbeforework ingonthem associates with lower riskofduplicate work.
when does the community risk fragmentation?
h h to test whether projects that reject many external contributions h6 have a more modular design h7 or have higher coordinationtable hard forks model r2 .
has hard forks t f coeffs errors lr chisq intercept .
.
numforks .
.
.
size .
.
.
centralizedmngmtindex .
.
.
modularityindex .
.
.
additivecontributionindex .
.
.
prmergeratio .
.
.
p .
p .
p .
n requirements h8 correlate with fragmented communities and hard forks we modeled the likelihood of a project having hard forks as a function of the average external pr merge ratio and the modularity and centralized management indices while controlling for project size and the overall number of forks.
our model summarized in table confirms a sizeable negative effect for the pr merge ratio of the deviance explained strongly supporting h6 thelower thepracceptance rate the higher thechance ofaproject havinghard forks on average.
the centralized management index also has a statistically significant positive effect of the deviance explained supporting h8 more coordination require ments areassociated with ahigher risk ofcommunitymem bers fragment ingintovarioushard forks.
we do not find a statistically significant effect though for the modularity associating with hard forks h .
.
discussion modularity.
modularity has been widely recognized as an important quality that facilitates software evolution and eases division of labor and collaboration .
our study confirms that better modularity is associated with higher efficiency of distributed fork based development specifically higher fraction of developers contributing their changes back h1 and higher rate of integration of external contributions h2 .
note that logic coupling was beneficial in general whereas extreme modularity where contributions are mostly additive do not seem to encourage a higher percentage of developers to contribute back but it significantly eases integration.
while there are some concerns about limiting effects of modularity for certain changes even to the extent we could hypothesize potential fragmentation of communities through hard forks we did not find in our models any direct evidence supporting these concerns h7 .
however there is a noteworthy indirect effect higher modularity is associated with higher pr acceptance ratios h2 in turn higher pr acceptance ratios are associated with higher likelihood of community fragmentation through hard forks h6 .
more research is needed to disentangle the effects of modularity more precisely from those of lower pr acceptance rates we suggest this as a promising direction for future research.
in short our results suggest a net positive impact of modularity in fork based collaborative development a new domain lacking the empirical evidence.
coordination.
our study also indicates the importance of active coordination among developers.
even though fork based development on a transparent platform allows all developers to freely fork projects make changes without coordination and suggest prs once 358esec fse august tallinn estonia shurui zhou bogdan vasilescu and christian k stner done coordination is associated with significant improvements to the efficiency of a community regarding forking outcomes specifically.
projects with a practice to coordinate work through issues upfront have a higher rate of developers who attempt to integrate their changes h and have a higher rate of accepted prs h .
however coordination is known to incur some costs and could potentially be annoying to some.
our models provide support for these concerns suggesting that higher levels of coordination might actually encourage hard forks h8 .
again note a similar tradeoff as with modularity albeit this time more clearly visible in our models coordination is directly and positively h8 associated with likelihood of hard forking but also indirectly and negatively h4 through its effect on pr acceptance rates hard forks are associated more with projects that are more selective in accepting external prs h6 .
we suspect that developers have to make deliberate tradeoff decisions about how inclusive they want to be in accepting community contributions potentially at the cost of discouraging contributors and fragmenting their community if their standards are too rigid.
redundant development.
finally our models of duplicate prs are not sufficiently well fitting to conclude there is strong evidence supporting different interventions we found some evidence but weaker compared to the other hypotheses that claiming an issue upfront is associated with a lower chance of redundant work h5 .
duplicates are rare in most projects but may still cause substantial friction especially for new developers also despite many recommendations claiming issues is not a common practice yet in most projects.
interestingly anecdotally we found cases where developers triggered duplicate work by posting an issue before addressing the issue themselves without actually claiming the issue which encouraged others to work on the same issue in parallel.
more research is needed to develop and evaluate interventions.
recently suggested awareness tools that might detect duplicate work quickly rather than expecting upfront coordination might be an interesting alternative strategy.
.
implications implications for practitioners.
our results encourage practitioners to strive for implementations that are modularly extensible and to adopt guidelines for contributors that suggest coordinating planned changes through an issue tracker.
though some opensource developers might dislike the rigidness and effort of central coordination our results show that projects that do so receive a higher fraction of prs from their active forks end up integrating more changes and likely frustrate fewer contributors in the process.
maintainers might want to point newcomers especially to work on problems which can be completed with modular changes.
all of this can improve sustainability and the perception of having a strong community for a project.
finally while hard forks are rare in practice they can be expensive for a community and have gotten much easier on social coding platforms maintainers should consider carefully to what degree they can remain open to various external contributions and how modularity can help to integrate contributions more easily or to what degree they are willing to accept some degree of fragmentation.implications for researchers and tool builders.
while we explored how project characteristics and existing practices influence efficiency outcomes there are many opportunities to design and study further interventions.
for example improved tooling to navigate and understand changes in forks or to oversee large numbers of prs can help both maintainers and contributors to explore not integrated forks and detect work in progress to detect interesting extensions and avoid redundant development.
explicit github mechanisms rather than conventions to claim issues as work in progress have been suggested as have community tooling for coordination which would be worth evaluating.
there may be research opportunities to detect redundant prs automatically to reduce the maintainers effort or even to detect redundant development early before developers finished their work .
research on mentoring might further establish good and efficient practices.
furthermore we suspect that many members of an open source community are not aware of their practices and how they relate to other projects e.g.
some interviewees where surprised that some projects largely coordinate work in the issue tracker whereas others were surprised that not all projects do that .
we suspect that making practices transparent for example through repository badges ormetric dashboards can help community members to understand their practices and how it relates to other possibly more efficient projects.
finally we argue that researchers should revisit hard forks and the cost of community fragmentation given that new ease of forking on social coding platforms may have changed dynamics from the feared hard forks of the past.
many tools to manage distributed development with forks can also be useful for industrial settings where forks are also frequently used for collaboration and for variant management and recently several researchers have explored lightweight tooling to support fork based variant management .
conclusion fork based development in social coding context has been widely adopted in open source communities as it allows developers to modify their own fork without affecting others and provides a uniform way of contribution their changes back to the original project.
we show that there are significant inefficiencies in the collaborative development process of many communities including lost contributions rejected pull requests redundant development and fragmented communities.
through large scale statistical modeling of factors operationalized in github traces we found that many of these inefficiencies associate with common project characteristics and practices especially modularity and coordination practices.