eventflowslicer a tool for generating realistic goal driven gui tests jonathan a. saddler myra b. cohen department of computer science engineering university of nebraska lincoln lincoln ne usa saddler huskers.unl.edu myra cse.unl.edu abstract most automated testing techniques for graphical user interfaces guis produce test cases that are only concerned with covering the elements widgets menus etc.
on the interface or the underlying program code with little consideration of test case semantics.
this is effective for functional testing where theaim is to find as many faults as possible.
however when one wants to mimic a real user for evaluating usability or when it is necessary to extensively test important end user tasks ofa system or to generate examples of how to use an interface this generation approach fails.
capture and replay techniques can be used however there are often multiple ways to achievea particular goal and capturing all of these is usually too time consuming and unrealistic.
prior work on human performance regression testing introduced a constraint based method to filtertest cases created by a functional test case generator however that work did not capture the specifications or directly generate only the required tests and considered only a single type of test goal.
in this paper we present eventflowslicer a tool that allows the gui tester to specify and generate all realistic test cases relevantto achieve a stated goal.
the user first captures relevant events on the interface then adds constraints to provide restrictions on the task.
an event flow graph is extracted containing onlythe widgets of interest for that goal.
next all test cases are generated for edges in the graph which respect the constraints.
the test cases can then be replayed using a modified versionof guitar.
a video demonstration of eventflowslicer can be found at index t erms software test generation graphical user interfaces goal based testing i. i ntroduction automated test generation for graphical user interfaces guis has been the subject of a large body of research .
approaches include model based techniques which have ledto tools such as guitar random techniques or search based techniques that systematically explore the applicationevent space to increase code coverage .
however all of these methods for test generation focus primarily onfunctionality with the aim of exercising as many events andevent sequences on the interface as possible.
while this iseffective for some types of testing it fails to mimic real tasksthat a user might perform.
recent work on usability testing human performance regression testing hprt proposed atechnique to automate test case generation that mimics thevarious ways an expert user can perform some task based ona stated goal .
this allows the interface designer to findproblematic paths in the interface.
in hprt a set of widgetson the interface that participate in the given task are firstenumerated and a set of constraints are added to ensure thatthe task is realistic i.e.
it doesn t open and close a windowbefore a useful action is performed .
that work however hasseveral limitations.
first the types of tasks allowed are limitedto those which can be performed on the interface in differentways but with only minor structural differences e.g.
menusversus buttons .
second the user has to specify widgets andconstraints manually in a text file with no tool support .
third the tests are not directly generated but rather are filtered fromthe set of all possible functional tests on an event flow graphwhich limits scalability.
other approaches for realistic user testing include pattern based testing however that work differs in that ituses a template for a specific goal and does not provide theflexibility of generating tests for any type of test goal.
memonet al.
used ai planning however they generate a single test case and require the user to specify the exact orders of sequences of actions in the path.
zhang et al.
use staticanalysis to extract the set of actions to perform a workflowon the interface but they do not generate replayable tests andrequire access to the source code.
there has also been some work on generation of realistic test cases for web applications however they do not generate event sequences for desktop gui applications.
in this paper we present our tool eventflowslicer efs for short that solves the stated challenges of hprt.
efs was firstdescribed in .
it allows users to specify and generatetest cases for a variety of goal types.
the first type of test goalis the most stringent and expects that the test cases differ onlyin slight structural ways such as by using a menu versus akeyboard or by switching the order of a task .
our exampletask in this paper is structural.
efs also supports goals thatare functionally different.
these types of goals have at leasttwo different ways to perform the same task that use verydifferent methods such as using entirely different menus andsteps .
an example of such a task used in our prior work is thatof search and replace in drjava.
the third type of goal that issupported is an abstract goal.
a user might specify a generalgoal that they want to change the look of some text.
thismight include making the text a different font or a differentcolor or italicizing etc.
we can define such a test goal usingeventflowslicer and generate all of the test cases constrained .
c circlecopyrt2017 ieeease urbana champaign il usa t ool demonstrations955 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
required order repeat exclude atomic requi red order repeat exclude atomic .
capture widgets .
constrain .
model setup .
generate tests .
replay tests rmi remote method invocation guitar built on guitar ic e a user input automated fig.
.
overview of eventflowslicer by a set of user defined rules.
the task used in our running example can be made into an abstract goal by removing someof our constraints.
we used an abstract version of this goalwhich generated test cases in our prior work .
in eventflowslicer the user is provided both with a capture mechanism and a graphical constraint interface that walks them through each part of the process.
they then push abutton to extract a small event flow graph relevant only to theirtask and to generate tests that satisfy their goal.
once gener ated the tests can be replayed from within eventflowslicer.eventflowslicer can also read inputs from prior steps sothat the process can be started at any point and artifactsreused.
eventflowslicer utilizes the model based approach ofthe guitar framework for its ripping process and replay .
we begin next with an overview of the tool architecture and discuss the targeted users.
we then present a running exampleof the use of each of the modules of the tool in section iii.we follow with a discussion of our validation of efs sectioniv .
then we conclude and present future work in section v. ii.
s ystem architecture figure shows an overview of eventflowslicer.
it has five primary modules labeled to .
the first module allows theuser to provide input via a capture tool that creates an initialpart of the goal specification.
this part of the process usesjava remote method invocation rmi to allow the applicationto open and close in a separate process.
once the widgets are captured the second module provides a graphical interface for the user that walks them through the process of defining thesets of constraints for the given goal.
there are five types ofconstraints described later requires order repeat exclude and atomic.
once the constraints are defined the next phase is to perform the model setup which creates an event flow graph a graph model of the events and their follows edges which aredynamically extracted from an interface .
containing onlythose widgets that are captured.
this module is built on topof the guitar ripper .
once the model has been created the next step is to generate tests.
the event flow graph isexplored in a depth first manner pruning edges that violate constraints and recording paths.
all paths that satisfy all theconstraints are output as the set of tests.
last the tests can bereplayed using a modified version of the guitar relayer.
we have retrofitted this module to use rmi.
we will discuss eachmodule in more detail in the next section.
envisioned users eventflowslicer is developed both for experienced testers who can use the command line input and directly modify the constraints files as well as for lessexperienced testers such as user interface designers who wantto explore different ways to perform the same task on theinterface.
we expect that the output of the test case replaycan be used in some existing performance prediction tools aswas done in hprt .
we also envision that efs can beused to help discover ways to perform actions on a task fora tester who iteratively interacts with the tool relaxing andadding constraints in the process.
iii.
e xample tool walkthrough we use a small task modified from based on a stack overflow question.
the user asked how to change thestylization specifically background color of text typed into ajava source file as a comment .
we have defined our task to satisfy a specific non trivial goal that can be achieved many ways.
the user wants to makethe text of the java comment in jedit to be bold and italic and to have a new background color.
as part of our goal wewill allow the user to make these changes in any order and touse both the mouse and keyboard to achieve the backgroundcolor changes.
each valid test case must have all three changesmade.
our task in called commented text bg is similarto this one however it is abstract in that it did not require thatall three changes happen but only at least one hence therewere more ways to perform the task .
more formally our goalin this demonstration will be to enumerate all possible ways the jedit style editor can be opened and used to change thecommented text so that it is italicized bold and has a graybackground color.
there are ways to achieve the goal wehave stated.
this task will be run on jedit v ersion .
.
.
in order to make this task realistic when creating test cases we follow a few principles.
the test case must not repeat any states or move to unnecessary states leading to the goal state.
the tester is always actively exploring new states of the editor when they click the ok button.
the test case must always make forward progress towards achieving the goal.
to begin we start eventflowslicer.
we show the main screen in figure .
notice that some of the text fields arefilled in already for demonstration.
at startup these are empty but can be auto filled by using command line arguments andpassing the gui flag.
eventflowslicer has five steps circled in red that are performed in order.
most of these stepscan be skipped by providing input files such as a constraintsfile which will skip step and or a set of tests which will allow one to move directly to step .
as input to start the application the tester provides an output directory andlocation of the application.
this can be a .jar file shown inthe figure or can be a class file.
optional virtual machine and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
eventflowslicer main screen application specific arguments can be provided as input files.
no other input is needed to begin step .
a. capture once the initial information is provided to efs the capture button is clicked and the application under test will open.
we show jedit open during the capture phase in figure .
thejedit style editor is not initially visible to the tester fromthe main editor window it must be revealed by clicking amenu item in the main window s menu.
the testeropens this window via the menu which is being captured byefs and upon entering this window they click on each of thewidgets that are involved in the task.
in this case they willclick on the italics bold and background color checkboxes.this can be done in any order.
they will ignore the text colorpicker since this is not needed for the task and should notbe captured.
once the background color checkbox is selected another color picker becomes accessible.
they will click onthat and they are taken to a color window where they canselect the background color either by clicking on a cell withthe mouse or by using the keyboard.
the tester will captureboth actions again in either order .
the following widgets willbe captured by eventflowslicer utilities menu quick settings submenu edit syntax style menu item italics check box bold check box background color check box and push button the light gray swatch button using mouse the light gray swatch button using the arrow keys space bar fig.
.
the jedit style editor window nothing selected pick a color ok button style editor ok button during capture the tester visually selects the widgets and the labels are printed to the console to help identify whatactions efs is capturing.
when done he or she hits the stopcapture button and the widgets are recorded to a file.
thefile containing all these widgets is automatically used in thenext phase and added to the interface in the field labeledconstraints file .
the tester can manually edit this xml fileif some incorrect widgets were selected.
b. constrain this step specifies how these widgets work together to achieve the goal.
it will add constraints related to the captured widgets.
during this phase a gui walks the tester througheach constraint in order and provides a list of the possible widgets which can participate in this rule to make the tester sjob easier.
any of the captured widgets are allowed to be addedinto constraints groups and test case generation will enforcethat the test cases adhere to these rules.
to briefly review from our previous work the five constraints the tester can work with in the currently implementedversion of eventflowslicer are shown below.
we assume thatw w w2 ... w n is the set of captured widgets.
requires given a set r w wi rappearing in each generated test case.
exclusion given the set e w wi wj e w i negationslash wj at most one of wiandwjcan appear in any generated test case.
repeat given a set p w and a minbound and maxbound wi p wimay occur up to rtimes in a generated test case where minbound r maxbound1.
order given a sequence of nsetss o o2 ..o n oi wand oi oj o i oj and i j wi oi wiappears before all wj ojin every test case.
this is a partial order on widgets.
1without specifying any constraint minbound maxbound authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
atomic a sequence s w i wj ..w n where wi w. this is an exact order of widgets.
each of these rules can be used repeatedly.
for instance we can require three separate groups of widgets by adding requires rules.
in our running example the following constraintswere employed three requires constraints one for each of the italics bold and background color checkboxes.
this willforce all three to appear in a test case for it to be valid.
note we can also add all three to a single requiresconstraint meaning that at least one must be present ina test case creating a more abstract goal.
one exclusion constraint containing both the keystroke and click option for selecting a color.
this means testcases will only use one of these methods to change thebackground color.
an atomic constraint that states that the background color checkbox is clicked before its selector button isclicked.
if we were to change this to an order constraintstating the checkbox appear only at some time prior to selecting a color we would more than double thenumber of test cases generated.
we bind these two ac tions together for the sake of an understandable workingexample.
efs supports both options.
an example constraint tool window is show in figure .
the possible widgets are on the left the current constraint in thedisplay is the requires constraint.
as each widget is selected for this rule it will be added on the right.
we require only a few requires rules to obtain a suite that is focused on just the three formatting widgets we mentioned.
in the jedit application the italics bold and background color buttons can only befound in the style editor window shown in figure and they are also among the few widgets we captured in the first step.thus having required that each test case use one of thesewidgets we force every test case to first navigate down themenu path to the style editor the one denoted by utilities quick settings and edit syntax style .
the space of test cases generated is limited to realistic expert user test cases based on global constraints see which will hold as long as constraints specified in the constraints tool don t override them.
test cases will not open a window or click to enter a tab in a tabbed selection panel and then immediately close the window or panel to performactions elsewhere.
each event will be used only once in eachtest case in absence of overriding repeat rules and all tasks will end and begin in the main window the application opened when launched.
without global constraints the test case mightcontinually check and uncheck the italic or bold option orleave the style editor without changing the state at all.
we are now done specifying our test suite to the generator.
eventflowslicer allows us to immediately transition into letting the program handle the rest of the work.
c. model setup the next step is to create the models from which to derive test cases.
the generator takes the captured output and the fig.
.
the eventflowslicer constraints tool output of the constraints selection both combined into one file and gathers necessary data from the interface using a guitarrip operation and creates an event flow graph efg a graph where nodes represent the events in the application and edgesindicate a node can follow another one.
the rip operation is explained in detail in .
the resulting efg does not provide a complete graph of the interface but instead only rips thewidgets that were captured and are contained in the constraintsfile .
we show the full efg for jedit in figure a .
thishas hundreds of nodes and thousands of edges.
by contrast the efg that is ripped using eventflowslicer is shown in figure b .
this is further reduced in the first part of test generation shown as figure c .
eventflowslicer uses a guitar filter to prune widgets that are not captured.
if a widget sits under a menu item that wasn texplicitly captured the path to it is left in the efg to ensureproper test cases can be generated.
the result of extra hidden widgets is reported by eventflowslicer at the end of the modelsetup step.
d. generation once the model is created the tester can select generate test cases.
the first step makes sure that the constraints file and efg file were generated for the same application.each main element in the constraints file is checked for aunique mapping to an event in the efg.
the second step isto reduce the efg to remove some edges based on the globalrules see for more information .
in particular thenorepeats rule implies that widgets should by default notbe repeated in test cases so the reduction removes any selfedges from the efg and other edges which traversing wouldautomatically imply illegal breaking of global rules in a testcase .
there are three such reductions we make repeatself windowopenclosecannothappen and expandtochild.
theyare described in .
we have experimented with variousorderings of these three reductions since the last reduction isimpacted by the former and have found that the different authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
e3365297604 menu utilities click e2640108148 menu utilitiesquick settings click e3469068240 menu item utilitiesquick settingsedit syntax style of token under caret click e519002124 check box italics click e3876132034 check box bold click e2524057168 check box background color click e227488950 push button background color click e2403448090 push button ok clicke3845132384 page tab list swatches select e581799926 push button ok clicke3003664316 0 mouse panel swatches click e3003664316 1 typing panel swatches selecte3365297604 menu utilities click e2640108148 menu utilitiesquick settings click e3469068240 menu item utilitiesquick settingsedit syntax style of token under caret click e519002124 check box italics click e3876132034 check box bold click e2524057168 check box background color click e227488950 push button background color click e2403448090 push button ok clicke3845132384 page tab list swatches select e3003664316 0 mouse panel swatches click e3003664316 1 typing panel swatches select e581799926 push button ok click fig.
.
phases of the efg reduction.
unconstrained ripping to obtain jedit s full efg is shown in a .
eventflowslicer will produce a reduced efg from its rip shown in b .
the test generation phase will reduce the efg furtherby removing edges for the global rules just before generation c orderings of reductions have an insignificant effect but that reductions overall are useful in reducing graphs to nearly halftheir size on average which reduces test generation time.
theresulting event flow graph after the global rules are removedin our example is shown in figure c .
once these reductions and mappings are made the generator then starts systematically traversing the efg from the widgetsthat exist on the main window.
when a test case containingallrequires widgets is found and that does not violate other constraints it is returned as a test case.
the traversal then continues avoiding branches that violate constraints as it goes.in the end all specified test cases are generated.
e. test cases our working example will result in test cases.
there are six different tests that account for each of the possible orders for italic bold and background color and for each of these there are two ways to change the background color mouse orkeyboard .
we have verified that the test cases generated from eventflowslicer for this instance achieve the desired result by manually examining each test case.
we present examples of two test cases in figure .
the left side lists the steps forboth of the test cases while the right side shows a portion ofthe actual test case xml for the first test case which is ina modified guitar format.
the guitar generator creates widget ids using a digit hash value.
as a design decision eventflowslicer test cases are relabeled with english languagedescriptions of the widgets so that the tester can readily see what the test cases are before having to replay the testcase.
this is useful for a number of reasons the tester need not run the test cases in order to under stand what it is scripts can utilize this information to mine data about thewidgets in each test case.
reasoning about the validity of each test case to achievethe desired goal is possible by looking at a visualization of the efg relabeled in the same manner and studyingpaths taken to achieve the generated test cases.
f .
replay the last phase of eventflowslicer is test case replay.
the tester can replay all tests in the test suite or select a subset bytest case one .
menu utilities click .
menu utilities quick settings click .
menu item utilities quick settings edit syntax style of token under caret click .
check box italics click .
check box bold click .
check box background color click .
push button background color click .
page tab list swatches select .
mouse panel swatches click .
push button ok click .
push button ok click test case two .
menu utilities click .
menu utilities quick settings click .
menu item utilities quick settings edit syntax style of token under caret click .
check box bold click .
check box background color click .
push button background color click .
page tab list swatches select .
typing panel swatches select .
typing panel swatches select 0 0 .
push button ok click .
check box italics click .
push button ok click example test case xml test case one fig.
.
our running example produces test cases that bold italicize and change the background color of text in any order.
the atomic constraint ensures that the background color activation checkbox is checked immediatelyprior to the color selection window being opened in every test case.
on the left we show two abstract test cases consisting of just the steps.
on the right we show the partial xml for the first test case.
number.
the output from the generation step is a set of test case files that can be executed on the application.
in this step the application is opened by efs and sent events mapping tothe descriptions given in the test case file.
some java swingapplications are intolerant to soft closing of an application swindows by test automators.
applications may block the userfrom so at certain stages where other forms of input liketext input are required or the app may hold up the system inorder to write files to the file system .
choi et al.
point thisout as a problem when testing gui s. we use remote methodinvocation rmi to avoid this problem.
since efs opens theapplication in a subprocess it has control over restarting theapplication for the next test case and prevents the underlyingsystem under test from interfering with this process.
the output from this operation is a set of snapshots that demonstrate all of eventflowslicer s actions.
borrowing fromtechniques used in efs executes an action and thentakes a visual snapshot to provide a graphical story of whathappened during the test case.
images from a variant of ourrunning example jedit commented text were used to helpverify the over test cases we got back from one of ourtasks .
iv .
v alida tion in our initial work we validated eventflowslicer on a set of tasks comprising user goals on four differentapplications.
these include both structural only goals aswell as those which have functional differences and whichare abstract.
the first twelve structural were taken fromprior work on human performance regression testing forlibreoffice.
there were four core tasks two on writer one authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for calc and one for impress .
each of these was performed on three different versions of the system one that had onlymenus one that had menus and keyboard shortcuts and onewith menus keyboard shortcuts and toolbar buttons .
usingthis study we were able to confirm that we generated theexact same test cases that the hprt generator would producewhen fed similar inputs.
furthermore we evaluated the generation of nine newer goal based test suites six that were based on stack overflow questions and three that we created for other applications .we used three applications jedit drjava and terpword.for each of these tasks we performed the full workflow ofeventflowslicer beginning with capture.
the test case count of these test suites ranged from to average of .test generation times after capture and constraints rangedfrom seconds test cases to .
seconds test cases .for this study we validated each test case against the test cases generated via the hprt technique in the instances where we mimicked their goal .
for the other test cases we manually examined the test cases.
the runtime for testgeneration of eventflowslicer showed a .
reduction overthe hprt test generation technique.
the goal used in therunning example here is a restricted version of the commentedtext bg task .
v. c onclusions and future work this paper has presented eventflowslicer a goal based tool for test specification and generation.
eventflowslicer allows the tester to capture relevant widgets for a task specifyconstraints and then automatically extract a model generate tests and replay them.
all intermediate artifacts are saved sothe tester can start at any point in the process and or edit themmanually.
we have examined the use of eventflowslicer inhelping with the task of exploring the space of all possibilities in a goal changing commented text s background color andmaking it bold and italic in jedit .
the user performs themanual steps of capture and defining constraints as input to the generator which then creates a test suite of test cases covering all intended manners of accomplishing our goal.
in future work we will make eventflowslicer available for others to use and extend.
we also plan to develop amethod to construct a graph of the outcome of a test suitereplay operation.
one use of this graph is to help interfacedesigners weed out pathologically long scenarios that userswould have trouble executing.
a second use when paired with our snapshots would be to visualize where bugs appear in aninterface and to help localize faults to certain usage scenarios.
we also intend to evaluate the usability of the tool and evaluatethe difficulty of defining constraints.
a cknowledgments this work was supported in part by national science foundation grants ccf cns and ccf .
2artifacts from our validation study can be found at edu myra artifacts eventflowslicer