the evolution of c programming practices a study of the unix operating system diomidis spinellis dds aueb.grpanos louridas louridas aueb.grmaria kechagia mkechagia aueb.gr department of management science and technology athens university of economics and business patision gr athens greece abstract tracking long term progress in engineering and applied science allows us to take stock of things we have achieved appreciate the factors that led to them and set realistic goals for where we want to go.
we formulate seven hypotheses associated with the long term evolution of c programming in the unix operating system and examine them by extracting aggregating and synthesising metrics from snapshots obtained from a synthetic software con guration management repository covering a period of four decades.
we found that over the years developers of the unix operating system appear to have evolved their coding style in tandem with advancements in hardware technology promoted modularity to tame rising complexity adopted valuable new language features allowed compilers to allocate registers on their behalf and reached broad agreement regarding code formatting.
the progress we have observed appears to be slowing or even reversing prompting the need for new sources of innovation to be discovered and followed.
ccs concepts software and its engineering !software evolution imperative languages software creation and management open source model general and reference !empirical studies measurement social and professional topics!software maintenance history of software keywords c coding style coding practices unix bsd freebsd .
introduction tracking long term progress in engineering and applied science allows us to take stock of things we have achieved appreciate the factors that led to them and set realistic goals for where we want to go.
progress can be tracked along two orthogonal axes.
we can look at the processes inputs acm acknowledges that this contribution was authored or co authored by an employee contractor or affiliate of a national government.
as such the government retains a nonexclusive royalty free right to publish or reproduce this article or to allow others to do so for government purposes only.
icse may austin tx usa c acm.
isbn .
.
.
.
at the resulting artefacts outputs .
furthermore we can examine both using either qualitative or quantitative means.
the objective of this work is to study the long term evolution of c programming in the context of the unix operating system development.
the practice of programming is a ected by tools languages ergonomics guidelines processing power conventions as well as business and societal trends and developments.
speci c factors that can drive long term progress in programming practices include the a ordances and constraints of computer architecture programming languages development frameworks compiler technology the ergonomics of interfacing devices programming guidelines processing memory and speed and social conventions.
these might allow among other things the more liberal use of memory the improved use of types the avoidance of micro optimisations the writing of more descriptive code the choice of appropriate encapsulation mechanisms and the convergence toward a common coding style.
here are a few examples.
the gradual replacement of clunky teletypewriters with addressable cursor visual display terminals in the 1970s may have promoted the use of longer more descriptive identi ers and comments.
compilers using sophisticated graph colouring algorithms for register allocation and spilling may have made it unnecessary to allocate registers in the source code by hand.
the realisation that the overuse of the goto statement can lead to spaghetti code might have discouraged its use.
similarly one might hope that the recognition of the complexity and problems associated with the mis use of the c preprocessor may have led to a reduced and more disciplined application of its facilities.
also one would expect that the introduction and standardisation of new language features would lead to their adoption by practitioners.
finally the formation of strong developer communities the maturing of the eld and improved communication facilities may lead to a convergence on code style.
in more formal terms based on a simple regression exploratory study we established the following hypotheses which we then proceeded to test with our data.
h1 programming practices re ect technology affordances if screen resolutions rise we expect developers to become more liberal with their use of screen space as they are no longer constrained to use shorter identi ers and shorter lines.
higher communication bandwidth think of the progress from a bps asr teletypewriter to a bps vt character addressable terminal to a mbethernet connected ieee acm 38th ieee international conference on software engineering ieee acm 38th ieee international conference on software engineering ieee acm 38th ieee international conference on software engineering bitmap screen workstation makes typing more responsive and the refresh of large code bodies faster.
similarly if barriers imposed to compilation unit sizes by the lack of memory or processing capacity are removed we expect developers to abandon arti cially imposed le size limits and move towards longer les packed with more functionality.
h2 modularity increases with code size as the unix source code evolves and multiplies in size and complexity we expect developers to manage this growth through mechanisms that promote modularity.
these include the use of the static keyword to limit the visibility of globally visible identi ers and the pairing of header les with c implementation into discrete modules.
h3 new language features are increasingly used to saturation point the c language has been changing over time with new features being added albeit sparingly.
we expect them to be increasingly used after being introduced up to a point certainly a language feature can only be used a certain number of times in a program.
for example when the unsigned keyword was introduced it could in theory be used at most on all integer de nitions and declarations of a program and in practice only on those where the underlying value was indeed non negative.
we call this limit the feature s saturation point.
h4 programmers trust the compiler for register allocation in the days of yore programmers had to deal themselves with the nitty gritty details of register allocation by declaring variables with the register keyword.
as compiler technology has improved compilers have become more adept at the task.
we expect that developers have been noticing this and have therefore been more and more trusting of the compilers with handling register allocation optimizations.
h5 code formatting practices converge to a common standard we expect developers working on a single project such as unix to adopt a common coding standard making the code base more homogeneous over time.
this can be aided through the increased availability and use of collaboration mechanisms such as version control systems and online communities.
h6 software complexity evolution follows self correction feedback mechanisms we expect that as software evolves it becomes more complex to a degree.
a successful project cannot grow in complexity beyond the con nes of human comprehension.
therefore we also expect that beyond a certain point self correction feedback mechanisms should kick in bringing code complexity down.
h7 code readability increases as software and its development process and community evolve growing in size and in complexity to a degree we expect its readability to increase in order to make it manageable by its evolving community of developers.
in addition a long lived project will outlive its original developer cast and accommodations must be made for new cohorts.
the preceding hypotheses can be tested by examining instances of the code over time.
by looking at the long term evolution of associated metrics we can determine whetherthey indeed change over time as well as the direction and rate of change.
the results of the study on long term evolution of programming practices can be used to allocate the investment of e ort in areas where progress has been e ciently achieved and to look for new ways to tackle problems in areas showing a lack of signi cant progress.
also given the hypothesis that the structure and internal quality attributes of a working non trivial software artefact will represent rst and foremost the engineering requirements of its construction the results can also indicate areas where developers rationally allocated improvement e ort and areas where developers did not see a reason to invest.
this paper builds on the earlier short exploratory study by explicitly stating and testing hypotheses by using a more sophisticated statistical method for the analysis by a detailed explanation of the employed methods and by presenting possible causality links between external changes the metrics and the hypotheses.
to formulate the hypotheses we took into account the general technological trends such as improved screen technologies and software techniques combined with metrics which we could measure from our data and could bear on the trends.
in the following sections we describe the methods of our study section we present and discuss the results we obtained section and outline related work section .
section summarises our conclusions and provides directions for further work.
.
methods our study is based on a synthetic software con guration management repository tracking the long term evolution of the unix operating system.
at successive time points of signi cant releases we process the c source code les with a custom developed tool to extract a variety of metrics for each le.
we then synthesise these metrics into weighted values that are related to our hypotheses and analyse the results over time using established statistical techniques.
.
data collection and primary metrics the analysis of the unix source code over the long term was made possible by the fact that important unix material of historical importance has survived and is nowadays openly available.
although unix was initially distributed with relatively restrictive licenses signi cant parts of its early development have been released by one of its rights holders caldera international under a liberal license.
additional parts were developed or released as open source software by among others the university of california berkeley and the free bsdproject.
the primary sources of the material used in this study include source code snapshots of early released versions which were obtained from the unix heritage society archive thecd rom images containing the full source archives of berkeley s computer science research group csrg the oldlinux site and the free bsdarchive.
these snapshots were merged with past and current repositories namely the csrg sccs repository the free bsd 1cvs repository and the git mirror of modern free bsddevelopment.
this material plus results of primary research regarding authorship and genealogy formed the basis for constructing a synthetic git repository which allows the e cient retrieval and processing of the unix source code covering a period of years .
749table analysed unix releases name mean file date loc research v3 research v5 research v6 bsd bell 32v research v7 bsd bsd bsd bsd .
snap bsd .1c bsd .
386bsd .
386bsd .
bsd .
bsd .
tahoe bsd .
net freebsd .
freebsd .
freebsd .
.
bsd .
net bsd .
lite1 bsd .
lite2 bsd .
bsd .
reno freebsd .
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
freebsd .
.
581due to the fact that early releases are only available as snapshots it was decided to study the code at points of signi cant software releases rather than at xed time intervals.
this was done because obtaining code snapshots at xed time intervals was only possible after when all software began to be tracked through various revision control systems.
the releases examined the mean date of the les comprising them and the size of c proper source code les are listed in table .
we did not include header les in our study to avoid skewing metrics associated with executable code such as the number of functions per le with results from les that typically do not include any such code.
interestingly over the examined period the code body grew by more than three orders of magnitude from six thousand to ten million lines.
a few earlier revisions that existed in the repository were not examined because they did not contain any c source code les.
we show and use each release s mean le date based on averaging each le s last modi cation time rather than the release date because this re ects better the age of the corresponding code base.
this also avoids the distortion that would be introduced by treating what were sometimes parallel lines of development as a linear sequence.
such parallel development took place during the berkeley unix evolution over the early years with research unix and over the late years with bsdand free bsd.
obtaining metrics from large code bodies is di cult for technical and operational reasons .
on the technical side code dependencies make it di cult to establish the full context needed in order to parse and semantically analyse the code.
this is especially true for c code where the compilation depends on system header les compilerde ned macros search paths and compile time ags passed through the build process .
the operational reasons are associated with the required throughput though due to the relatively small number of releases we examined this was not a major issue in this study.
we addressed the di culty of parsing c source code without access to the original compilation environment by extending and using our cmcalc1open source tool which e ciently calculates through static analysis a variety of c code quality metrics without requiring full access to the compilation environment s parameters.
the tool s operation is based on state machine logic described in reference and will therefore produce reasonably accurate results without requiring access to header les and the like.
extensive unit tests of the source code is devoted to them were used to verify the tool s operation in diverse corner cases.
the cmcalc tool calculates size language feature code style and commenting metrics see