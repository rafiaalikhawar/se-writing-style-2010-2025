nar miner discovering negative association rules from code for bug detection pan bian bin liang wenchang shi jianjun huang bianpan liangb wenchang hjj ruc.edu.cn school of information renmin university of china key laboratory of deke renmin university of china beijing chinayan cai ycai.mail gmail.com state key laboratory of computer science institute of software chinese academy of sciences beijing china abstract inferring programming rules from source code based on data mining techniques has been proven to be effective to detect software bugs.
existing studies focus on discovering positive rules in the form ofa b indicating that when operation aappears operation b should also be here.
unfortunately the negative rules a b indicating the mutual suppression or conflict relationships among program elements have not gotten the attention they deserve.
in fact violating such negative rules can also result in serious bugs.
in this paper we propose a novel method called nar miner to automatically extract negative association programming rules from large scale systems and detect their violations to find bugs.
however mining negative rules faces a more serious rule explosion problem than mining positive ones.
most of the obtained negative rules are uninteresting and can lead to unacceptable false alarms.
to address the issue we design a semantics constrained mining algorithm to focus rule mining on the elements with strong semantic relationships.
furthermore we introduce information entropy to rank candidate negative rules and highlight the interesting ones.
consequently we effectively mitigate the rule explosion problem.
we implement nar miner and apply it to a linux kernel v4.
rc6 .
the experiments show that the uninteresting rules are dramatically reduced and detected violations have been confirmed as real bugs and patched by kernel community.
we also apply nar miner to postgresql openssl and ffmpeg and discover six real bugs.
ccs concepts software and its engineering automated static analysis keywords bug detection code mining negative rule rule explosion acm reference format pan bian bin liang wenchang shi jianjun huang and yan cai.
.
nar miner discovering negative association rules from code for bug bin liang is the corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction static bug vulnerability detection techniques usually require some prior knowledge i.e.
detection rules or vulnerability signatures .
in recent years it has been widely proven that code mining approaches on bug vulnerability detection are very effective .
such approaches automatically extract implicit programming rules from program source code and further detect violations of these rules as bugs or vulnerabilities.
generally during code mining the program source code is first transformed into itemsets graphs or other forms.
next data mining algorithms are applied on the transformed forms to extract patterns e.g.
frequent itemsets or sub graphs and infer programming rules.
the last step is to detect violations against the inferred rules.
for example pr miner and antminer mine frequent itemsets from the linux kernel to extract association rules as detection rules and have detected dozens of unknown bugs.
the basic idea of these existing studies is to utilize statistics to find program elements with accompanying relationship from source code.
this relationship exhibits as a positive programming pattern.
that is in the target project some program elements appear together frequently up to a given threshold or there is a certain connection among them.
for example pr miner and antminer both extract the positive association rules in the form ofa b indicating that within a function when the program element aappears the element bshould also appear.
accordingly if a function implementation violates the rule i.e.
containing a without b a potential bug is expected.
similar techniques have been proposed to detect potential object misuse bugs and missing program elements following control structures and to infer the correct usage of the apis .
all these approaches target on a group of ad joint program elements that have a mutually supportive relationship i.e.
positive associations.
however we observed that in practice some implicit programming patterns appear as negative associations in the form of a b. that is when aappears bshould not appear and vice versa.
in this sense a negative rule reflects the mutually suppressing or conflicting relationship between aandb.
violating negative rules may also result in serious bugs.
it is usually impossible to manually identify all negative rules from a project especially a large scale 411esec fse november lake buena vista fl usa p. bian b. liang w. shi j. huang and y. cai one like the linux kernel.
but to the best of our knowledge no existing approaches can automatically extract negative rules from source code for bug detection.
the state of the art mining based solutions only extract positive programming rules.
compared with the positive rules that indicate frequent patterns a negative rule is typically more implicit and the corresponding bugs are more insidious.
for example the bug in figure has existed in linux kernel for more than years i.e.
presented in linux .
.
or earlier .
hence it is both challenging and urgent to develop an effective approach to automatically extracting implicit negative programming rules to detect related bugs and vulnerabilities.
in this paper we propose nar miner to address the above issue.
the overarching idea is to infer interesting negative association rules through infrequent pattern mining and to further detect the corresponding violations as potential program bugs.
essentially due to the nature of negative rules directly mining infrequent patterns to extract negative rules will produce a huge number of rules.
we call this the rule explosion problem .
most of these rules areuninteresting for bug detection i.e.
they do not embody any real application logic and violations of them do not lead to bugs or program quality issues.
hence the detection results based on these uninteresting rules will produce unacceptable false positives.
for example directly applying an existing negative rule mining algorithm to linux kernel will extract up to hundreds of thousands of rules and millions of violations.
that became impossible for manual audit under limited human resource.
to address the rule explosion problem we propose a semantics constrained negative association programming rule mining algorithm to avoid generating excessive uninteresting rules as far as possible.
moreover we utilize the information entropy to identify the general functions that are prone to result in uninteresting rules.
this step helps to further filter potentially uninteresting rules.
as a result nar miner can effectively mitigate the rule explosion problem and gain desirable interesting rules to detect potential bugs.
we implement a prototype of nar miner and first evaluate it on a linux kernel v4.
rc6 .
the experiments show that semanticsconstrained negative rule mining and information entropy based rule filtering perform well on reducing the number of uninteresting rules.
that is it reduces uninteresting rules i.e.
from to among the top ranked negative rules .
especially it achieves a true positive rate of among the top ranked negative rules.
nar miner reports violations of the top ranked rules.
we manually inspect the results and find suspicious bugs and dozens of quality problems.
we report the suspicious bugs to linux kernel maintainers.
of them have been confirmed as real bugs and the corresponding patches have been merged into the latest version e.g.
v4.
.
we further apply nar miner to postgresql v10.
openssl v1.
.
and ffmpeg v3.
.
.
from the top ranked rules and violations we manually identify six suspicious bugs all of which have been confirmed and fixed by the corresponding maintainers.
this paper makes the following main contributions to the best of our knowledge our work is the first one that focuses on extracting negative programming rules from source code to detect bugs.
it extends the capability of the miningbased bug detection technique.
we propose an approach to mitigating the rule explosion problem by introducing program semantics in rule mining and using information entropy to identify the general functions which can effectively extract desirable interesting negative programming rules for bug detection.
we implement a prototype of nar miner targeting on realworld large scale software projects.
we apply the tool to four large scale systems i.e.
the linux kernel postgresql openssl and ffmpeg and find a considerable number of bugs among which have been confirmed.
motivating example we use a simplified code snippet from linux kernel v4.
rc6 to motivate our method.
in figure the function lapbeth new device calls alloc netdev at line to allocate a chunk of memory for a network device.
then at line in inlined function netdev priv is invoked to get the starting address of the private data and store it to variable lapbeth .
as shown in figure lapbeth points to a location inside the previously allocated memory.
if the device registration fails at line the memory chunk for the device will be released.
the allocated memory pointed by variable ndev is first freed at line and then the private data is freed at line .
the critical operations in the execution sequence from memory allocation to free are highlighted in the code snippet and the corresponding memory states are depicted accordingly.
we use red horizontal lines to describe freeing memory via free netdev and blue vertical lines for kfree .
with the illustration it is easy to tell there is a double freebug in the code.
traditional static detection methods are difficult to discover this bug and other similar bugs in a large scale system e.g.
linux kernel as the required bug patterns or rules are application specific and hard to collect.
existing mining based approaches cannot report the bug either.
for example the state of the art approach antminer extracts the positive association rules and checks the violations.
from the linux kernel we discover appearances of the pair alloc netdev free netdev among invocations of alloc netdev .
.
and only one invocation of free netdev is followed by kfree among its call instances .
.
antminer treats alloc netdev free netdev as a positive rule with a minimum confidence threshold as .
however the code in figure calls both alloc netdev andfree netdev and thus is a support instead of a violation of the rule.
hence the aforementioned bug is undiscovered.
besides due to the low confidence .
antminer does not treat free netdev kfree as a valid rule i.e.
filtered out by the minimum confidence threshold .
as a result antminer cannot report kfree follows free netdev as a bug.
from the above analysis it is quite difficult or even impossible to detect the bug in figure through analyzing the ad joint relationships among elements.
in essence the two program elements i.e.
free netdev andkfree closely related to the bug are negatively correlated.
this knowledge can be discovered by a statistic analysis.
specifically we find that in most cases about .
within the linux kernel free netdev is not followed by kfree we learn that the developers are mostly aware of the case in which calling kfree after free netdev may be unnecessary or cause serious problems.
412nar miner discovering negative association rules ... esec fse november lake buena vista fl usa file linux v4.
rc6 drivers net wan lapbether.c 2static int lapbeth new device struct net device dev struct net device ndev struct lapbethdev lapbeth alloc netdev allocate memory with size sizeof net device align sizeof lapbeth ndev alloc netdev sizeof lapbeth lapb d net name unknown lapbeth setup if !ndev goto out lapbeth netdev priv ndev ... rc eio if register netdevice ndev goto fail list add rcu lapbeth node lapbeth devices rc 16out return rc 18fail dev put dev free netdev frees the memory allocated in alloc netdev including the memory for private data free netdev ndev the memory is freed again resulting in double free kfree lapbeth goto out 26static inline void netdev priv const struct net device dev return char dev align sizeof struct net device netdev align sizeof net device align sizeof lapbeth ndev ndev lapbeth ndev lapbeth ndev lapbeth figure a bug in linux kernel violating the rule free netdev kfree .
source code preparing data transaction database mining inferring rules detecting violations function entropy bugs negative rules frequent and infrequent itemsets figure a high level overview of nar miner .
inspired by that relatively small amount of paired occurrences can be considered as anomalies.
we leverage infrequent itemset mining algorithms to infer the negative association rules and apply the rules to detect their violations e.g.
the one in figure .
during the mining and detection we also take the program semantics e.g.
data flow information into consideration.
in our example kfree shares data with free netdev and their appearance together is treated as an infrequent pattern.
therefore we infer a negative rule free netdev kfree .
applying the rule to our example discovers the corresponding bug bug in table our approach .
overview we present nar miner targeting on detecting bugs where a program contains some operations e.g.
two function calls that are deemed not to appear together without requiring any prior knowledge.
the high level idea of nar miner is to employ the data miningtechnique to infer negative association rules from source code and detect their violations .
figure presents the overview of nar miner .
it first prepares data for the mining phase.
similar to most of mining based methods we only extract programming rules from each individual function i.e.
intra procedural to avoid overcomplicated analysis.
program elements as well as their semantic relationships within each function are identified and transformed into a transaction which is then stored in a database called transaction database .
next it mines frequent and infrequent itemsets which denote sets of program elements from the database.
then it infers negative association rules from the mined itemsets and leverages the confidence and the entropy of functions to rank the rules automatically.
finally it detects the violations of the inferred rules and reports the top ranked ones as potential bugs for auditing.
.
challenge previous studies have shown that only a small number of patterns that exhibit negative association relationship are interesting.
their techniques of identifying interesting rules via computing their support and confidence cannot be directly adopted to code mining.
the program elements constructing an interesting negative association rules should suppress each other in their semantics not just infrequently appearing together.
our empirical study shows that directly applying the algorithm proposed by wu et al.
on the transaction database extracted from the linux kernel generates negative association rules see .
.
while of them are uninteresting in a sampling analysis.
up to violations are reported which makes human auditing impossible.
we call this the rule explosion problem and recognize it as the main challenge of extracting negative association rules.
we attribute the following two aspects as the root cause of rule explosion.
413esec fse november lake buena vista fl usa p. bian b. liang w. shi j. huang and y. cai existing negative association rule mining approaches mainly target on market basket medical diagnosis protein sequences etc.. for such kinds of data any two elements from a mining unit e.g.
a shopping receipt do not have any particular relationship except belonging to the same unit.
in other words the elements of a mining unit are homogeneous.
however between program elements there are often various semantic relationships e.g.
data dependence.
ignoring such relationships may result in many uninteresting rules consisting of semantically independent elements which actually do not suppress each other but just infrequently appear together.
a large scale project usually contains a certain number of general purpose apis that can be used in almost all programming contexts such as printk andisalpha in linux.
they can be coincidentally paired with other operations to form association rules.
even considering strong semantic relationships e.g.
data dependence during mining these apis can still result in many negative uninteresting rules.
actually the more general an api is the less mutual suppression it has with other operations.
based on above insights we mitigate the rule explosion problem as follows.
considering the essence of program elements as discussed above we focus rule mining on the program elements that have strong semantic relationships e.g.
data dependence to reduce uninteresting rules as far as possible.
we employ the information entropy to measure the generality of apis and use it to rank mined candidate negative rules.
the uninteresting rules involving high generality apis will be excluded from the final audit.
.
preparing data nar miner transforms the program elements into transactions and store them to a database.
in this paper we focus on two kinds of program elements function calls and condition checks because many bugs result from function or condition misuses .
as discussed earlier we aim to extract negative association rules from transactions whose elements have a strong semantic relationship.
we define two elements to have a strong semantic relationship if there is a data correlation between them including data dependence and data share .
in details given two statements s1ands2 if either s2uses a value defined in s1 i.e.
data dependence or they both appear on the same execution path and use the same non constant value i.e.
data share we say they are strongly semantically related.
the semantic relationships of program elements is identified via data flow analysis .
nar miner associates the semantic relationships with program elements and stores them into the database for mining.
the preprocessor of nar miner is built on top of the gcc v4.
.
frontend which provides control flow graphs and intermediate representations in ssa form for data flow analysis.
figure a presents a piece of code and figure b shows the corresponding intermediate representation in ssa form.
nar miner can tell that is valid fooand barare data dependent on read2 at line .
as is valid andfooare within the same execution path they have a data share relationship.
because there is no path between fooand bar they are not considered to be semantically related.
to ease the mining phase the intermediate representation is then converted into a transaction database.
every function definition ismapped to a transaction.
a transaction consists of two parts a bag of program elements and a set of semantic relations among these elements.
each program element is normalized before dumped to the database.
a function call is represented with the function name without the arguments and variables in a conditional statement are renamed with ret if they keep return values of some functions or with their data types in other cases as done in many mining methods .
for example the condition expression in figure is normalized to ret .
the semantic relationship between two program elements is represented as a tuple in the transaction.
for example the tuple foo is valid says that functions foo andis valid have some semantic relation.
figure c presents the semantic relationships for the code snippet where a node denotes a program element and an edge indicates the relationship for data dependence and for data share .
we map each program element to a unique integer and thus mining is applied on the integer set to improve performance as a large number of string equivalence comparison is time consuming.
.
extracting frequent infrequent itemsets a rarely invoked program element always infrequently appears together with other program elements and will result in a large number of negative patterns.
however such patterns are meaningless in statistics .
hence we focus on mining negative patterns whose elements are frequent alone but infrequent together.
for a negative rule a b itsantecedent i.e.
a and consequent i.e.
b are frequent but the combination of them i.e.
a b is infrequent.
in this section we present our algorithm on extracting interesting frequent and infrequent itemsets and will explain how to generate negative rules in the next section.
existing algorithms extracting frequent and infrequent itemsets only rely on the occurrences of itemsets in the transaction database .
none of them considers the semantic relations among elements.
directly applying them on the database generated in .
will result in a large number of uninteresting rules.
as far as we know there is no infrequent itemset mining algorithm that can be directly applied in our work.
to address this issue we design a semantics constrained mining algorithm which focuses on extracting strong semantics related itemsets.
elements in a strong semantics related itemset are all related to each other in semantics e.g have data dependence or data share relationships.
we design our algorithm based on the well known apriori algorithm which applies a bottom up approach to generate relatively large candidate itemsets by joining smaller frequent ones together.
the principle behind the bottom up approach is the apriori property any subset of a frequent itemset is also frequent.
in our cases any subset of a strong semantics related itemset is also strong semantics related because any two elements in the subset must be related in semantics.
hence strong semantics related itemset also complies with the apriori property and can be mined in a bottom up manner.
our algorithm of mining frequent and infrequent strong semanticsrelated itemset is shown in algorithm .
besides the transaction database it requires users to specify two parameters the minimum frequency support mf s and the maximum infrequency support mis.
an itemset is considered to be frequent if its support is larger than 414nar miner discovering negative association rules ... esec fse november lake buena vista fl usa .
str read1 .
str read2 .
valid is valid str .
if valid .
foo str .
else .
bar str .
a source code.
.
str 1 read1 .
str 2 read2 .
valid is valid str 2 .
if valid .
foo str 2 .
else if .
bar str 2 .
b intermediate representation in ssa.read1 read2 is valid foo bar ret c transaction.
figure source code transformation.
algorithm extract frequent and infrequent itemsets procedure mine itemsets db mf s mis fis iis l1 f requent itemsets for k lk k do sk lk 1zlk sk prune sk for each itemset iinsk do support i count support db i if support i mf s then lk lk i else if support i mis then nk nk i end if end for fis fis lk iis iis nk end for output fisandiis end procedure procedure count support db i counter for each transaction tindb do if i t.elements relations i t.relations then counter counter end if end for return counter end procedure or equal to mf s and an itemset is infrequent if its support is less than or equal to mis.
the output of the algorithm is all frequent itemsets fis and infrequent itemsets iis of interest.
at the beginning the algorithm scans the transaction database to find all frequent itemsets line .
then it attempts to discover frequent and infrequent k itemsets from frequent k itemsets lines .
a k itemset contains kitems.
first it generates candidatek itemsets of interest by joining frequent k itemsets see line .
two k itemsets are joinable if they have k common items.
suppose that two joinable k itemsets are i1 ... ik ik and i1 ... ik ik the join result is a k itemset i1 ... ik ik ik .
second the algorithm leverages the apriori property to prune k itemsets that have infrequent sub itemsets line .
after that function count support is called to compute the support of every k itemset line .
the itemset is inserted into lk line a set ofalgorithm generate negative association rules procedure generate rules fis iis min conf for each itemset iiniis do a min support subset i b i a r a b conf idence r support i support a if conf idence r min conf then continue end if interestin ness r conf idence r entrop y i nars nars r end for sortnars by their interestingness return nars end procedure frequent k itemsets if its support is not less than mf s otherwise if its support is not larger than mis it is inserted into the set of infrequent k itemsets nk line .
it should be noted that itemsets whose supports are are naturally ignored.
lkandnkare finally merged to fisandiis line respectively.
the frequent itemset lkis then used to generate larger itemsets lk 1andnk .
the algorithm terminates when lkis empty for certain k and outputs the collected frequent infrequent itemsets line .
the function count support scans the database to compute the support of an itemset i lines .
the counter will increase by if a transaction supports i line .
a transaction supports iif and only if it contains all items in ias well as all possible relations among the included items denoted as relations i .
for example the transaction in figure supports the itemset foo is valid because it includes not only both the two items fooandis valid but also the semantic relation between them i.e.
the tuple foo is valid .
however the transaction is not a support of itemset foo bar because it does not contains the tuple foo bar .
in order to mine rules like kfree kfree we also extract itemsets like where is frequently called but two call instances of it in the same function are rarely related in semantics.
this helps nar miner find the bug in table see .
.
.
.
generating negative association rules a negative association rule a bimplies that two frequent itemsets aandbrarely appear in the same transaction.
that is a b is infrequent.
in fact the antecedent and consequent of a 415esec fse november lake buena vista fl usa p. bian b. liang w. shi j. huang and y. cai rule are actually a disjoint partition of an infrequent itemset.
one straightforward negative association rule generation method is to find all pairs like a b from an infrequent itemset i where a b ianda b .
it uses the confidence of rule a bto determine its infrequency.
the confidence is defined of as follows conf idence a b support a b support a where support a b is the number of transactions that support a b supporting abut not a b. consequently we have support a b support a support a b support a support i where i a b. hence equation can be rewritten to conf idence a b support i support a from an infrequent itemset iwith nelements n at most n negative association rules can be generated by directly applying the above method.
however violations to them are all the same i.e.
the transactions that support the itemset i. hence it is enough to keep track of only one of them in the bug detection oriented application.
note that from the perspective of programming the rule a bmeans that elements in bshould not appear in contexts that include a. its violations are always false positives if the reversed rule b ais not interesting because the existence ofbis not meant to reject a. inspired by that in almost all cases if we expect transactions that support the infrequent itemset ito be real bugs all the negative association rules derived from ishould be interesting.
hence we can select the rule with the lowest confidence to represent these rules.
taking confidence as the metric the other rules will be interesting if it is interesting.
the logic in real world programming is often very complex.
some mined rules may not be applicable in programming practice.
violations detected according to them are usually false alarms.
a general methodology is to rank the mined rules such that the interesting rules are top ranked and uninteresting rules are bottom ranked.
existing works mainly rank rules according to their confidence high confidence rules are top ranked .
however the confidence only reflects the negative positive correlations among several limited elements.
in fact the interestingness of a programming rule is also related to whether its elements are concentrated in certain contexts.
that is if the calling contexts of an element trend to be more homogeneous the rules composed by it is more likely to be an interesting one.
otherwise if the element is used in quite different contexts it is more general and is more likely to appear together with various elements.
in this paper we use the generality to indicate how different the contexts for an element are.
in general rules consist of elements with high generalities are more likely to be uninteresting ones.
we introduce the information entropy to quantitatively measure the generality of elements.
for a call instance of a program element we describe its context by both elements depends on and elements that depend on .
we extract such elements in all call instances of and put them into a bag.
the information entropy of the bag of reflects how different the call instances are and can be used to measure the generality of .
the information entropy forthe bag of denoted as h can be computed by equation h lo 10 n pi lo 2 pi where piis the frequency of the i th element in the bag nis the number of call instances of .
the entropy for an itemset is a sum of the entropy for each element.
with the generality of each program element the interestingness of a negative association rule rcan be measured as interestin ness r conf idence r h i where h i is the information entropy of element i. our method to generate negative association rules is formalized in algorithm .
the algorithm takes the frequent itemset fisand infrequent itemsets iisextracted in .
as well as a user specified threshold min conf as inputs.
it returns the set of negative association rules nars .
it first generates the representative rule for each infrequent itemset ithat has the lowest confidence lines .
from equation the smaller the support of ais the lower the confidence of a bbecomes.
hence we select the subset ofiwhose support is smallest to generate the representative rule.
then the confidence of the rule is computed line and checked against the threshold min conf line .
the information entropy is employed to measure the interestingness of a potentially interesting rule line .
finally the negative association rules are sorted in the descending order of their interestingness.
.
detecting violations the violations of a negative association rule r a bare those transactions that support itemset a b. a straightforward approach is to directly scan the database to find all transactions that contain both itemsets aandb.
however such an enumerating approach is time consuming especially for databases with hundred of thousands of transactions.
to speed up the detection process we adopt the trick used in pr miner .
when generating frequent and infrequent itemsets nar miner also collects transactions that support them.
we use supporters i to indicate all transactions that support an itemset i. then the set of violations of the negative association rule ris exactly supporters a b .
evaluation .
experiment setup we implement nar miner as a prototype system to detect bugs in large scale c programs.
we evaluate nar miner on the well known linux kernel v4.
rc6 .
the linux kernel has been widely used as the target of evaluation toe in mining based bug detection methods .
the major reason for choosing the linux kernel as our target is that we want to examine the effectiveness of our method by detecting some real bugs that were not found in previous work.
linux v4.
rc6 was the latest version at the experiment time.
it contains c files and header files including functions and lines of code loc .
to verify whether nar miner can be applied for bug detection in other systems we also select three popular large scale c systems from different domains postgresql v10.
openssl v1.
.
and 416nar miner discovering negative association rules ... esec fse november lake buena vista fl usa ffmpeg v3.
.
.
postgresql is an open source database openssl is a library for secure communications and ffmpeg is a framework for encoding decoding multimedia files.
many bug detection methods select them as the targets of evaluations .
nar miner requires to specify three parameters the minimum support threshold of frequent itemsets i.e.
mf s the maximum support threshold of infrequent itemsets i.e.
mis and the minimum confidence threshold of interesting negative rules i.e.
min conf .
generally an itemset will be more interesting if it is either a frequent itemset with a higher support or an infrequent one with a lower support.
besides a higher minimum confidence can further filter out uninteresting negative rules.
in practice different parameter settings may result in either failing to report some real bugs or producing too many false alarms.
users can tune these parameters according to the detection strategies conservatively or aggressively.
to determine reasonable parameters we perform an empirical study as done in .
specifically with a sampling analysis a parameter setting is considered acceptable when more than half of the top ranked negative rules are interesting ones.
in this study we set mf s to be misto be and min conf to be .
in our experiments the default parameter setting works well against the four different toes see .
and .
.
.
detecting bugs in the linux kernel .
.
preprocessing the source code.
nar miner took about minutes to parse the kernel source code and to transform it into a transaction database.
among all the function definitions there are functions contain some program elements i.e.
function calls or condition checks .
after the transformation each function definition is mapped to a transaction in the database.
the database includes different elements where each element corresponds to a function call or a condition check.
among them are frequent elements that appear in more than mf s transactions.
.
.
effectiveness on mining negative rules.
to evaluate the effectiveness of our method that incorporates both the semanticsconstrained rule mining and the information entropy based rule ranking we conduct three experiments nar miner narminer nar miner .
the methodology adopted in each experiment is explained below a nar miner the mining algorithm does not consider semantic relations among items and the mined rules are ranked according to their confidence b nar miner based on nar miner the semantic relations among items are used as constraints to filter out weak semanticsrelated itemsets c nar miner based on nar miner we introduce the information entropy to measure the interestingness of negative association programming rules.
this experiment evaluates the full capability of nar miner .
we show the experiments results in table with the number of frequent itemsets fis infrequent itemsets iis number of inferred negative association rules number of detected violations and the time cost for mining ranking and detection time in seconds.
comparing the results for nar miner and nar miner or nar miner we observe that adopting the semantics constrained mining reduces the total number of rules and violations in an orderof magnitude about reduction for all columns .
the rule explosion problem is mitigated to a large extent.
due to the limited time we manually examine the top ranked negative association rules in each experiment.
the rules are ranked by their confidence in nar miner and nar miner whereas by their interestingness in nar miner.
a negative association rule is marked as true if it is really interesting and violating it will result in bugs or quality problems.
for example free netdev kfree is an interesting true rule because a violation to it will result in a potential double free bug such as the one discussed in .
in nar miner only among the top rules are considered as interesting rules.
in other words of them leads to false alarms for violation detection.
the main reason for this low rate of interesting rules is that the program elements consisting of such rules are usually independent of each other in semantics.
for below example though ranked number one with a confidence of .
in nar miner the rule static key false atomic read is uninteresting because the two functions take entirely independent variables as actual arguments in the program that contains both of them and they do not really suppress each other.
1static inline void load mm cr4 struct mm struct mm if static key false rdpmc always available atomic read mm context.perf rdpmc allowed introducing semantics constrained mining reduces the false positive rate to .
in nar miner which however is still too high to be acceptable in practice.
while the inferred rules have all involved program elements semantically related some elements are very generic and can be used in various contexts where violations do not lead to bugs.
for example function iowrite32 is data dependent on readl when they appear together only one occurrence in linux kernel and a rule iowrite32 readl is inferred.
the rule is ranked top 8th with a confidence of .
in nar miner but still uninteresting because both functions are used in various manners and a combination of them will not result in any bugs.
nar miner employs the information entropy to measure generalities of functions.
it is .
and .
for iowrite32 andreadl respectively.
the interestingness of the rule iowrite32 readl is .
small enough to be lowly ranked.
in this way most uninteresting rules are assigned low interestingness values and thus ranked at bottom meanwhile potentially interesting ones are assigned with relatively high interestingness values and ranked at the top.
in nar miner out of the top negative rules are marked with true nearly times of the number in nar miner .
in particular there are true negative rules among the first ones.
the true positive rate is .
that s we can find an interesting rule within less than two manual audits which is acceptable in practical bug detection against real world large scale systems such as the linux kernel.
we also inspect the violations of the top inferred rules.
from the columns violations and bugs in table we observe more reported violations and confirmed bugs due to the application of semantics constrained mining and information entropy based ranking which eventually enhances the ability of nar miner enabling it to infer much more interesting rules columns true andtp rate .
.
.
detecting violations.
against the negative association rules extracted by nar miner violations are detected.
we manually inspect the reported negative association rules and their 417esec fse november lake buena vista fl usa p. bian b. liang w. shi j. huang and y. cai table results of the three experiments.
experiment fis iisnegative association rules violationstime all reviewed true tp rate all reviewed bugs nar miner 24s nar miner .
13s nar miner .
16s table previously unknown bugs in linux v4.
rc6 detected by nar miner .
id function violated rulerule rankingpatchid nar miner nar miner nar miner hisi sas shost alloc scsi host alloc kfree na pm8001 pci probe mvs pci init 4xfs test remount options kmem zalloc kfree mxs lradc ts probe devm ioremap is err na ccp init dm workarea dma map single ret na 7qla26xx dport diagnostics flctl dma fifo0 transfer 9kexec calculate store digests crypto alloc shash kfree na vpd sections init memremap iounmap vpd section init lapbeth new device free netdev kfree na ubi scan fastmap kmem cache alloc kfree na 14psb mmu pt unmap unlock kunmap atomic kunmap atomic na lan9303 probe reset gpio devm gpiod get optional ret na cpcap adc probe platform get irq byname ret na esrt sysfs init memremap kfree na violations according to the ranking of the rules.
to gain maximum benefit from the detection we select the top ranked rules for review as violations of them are more likely to be real bugs.
we examine the top ranked negative association rules and corresponding violations see the last row in table within one person day.
we find suspicious bugs and dozens of program quality problems such as redundant condition checks and computations.
as linux kernel maintainers often ignore the quality problems we only submit patches of the suspicious bugs to the linux kernel maintainers.
up to now of these patches have been confirmed and accepted by the kernel maintainers.
the confirmed bugs are listed in table with the functions that contain the bugs function the rules they violate violated rule and the rule ranking in the three experiments.
the last column shows the patch ids to the bugs and our patches at the patchwork site.
among these found bugs six and have presented in kernel .
and two and even have been latent for more than years.
these bugs violate negative association rules in total.
if ranked by confidence only one of them is within the top rules in column nar miner .
but ranking the rules with the information entropy makes all of them in top nar miner .
this observation illustrates that introducing information entropy into ranking is significantly useful in highlighting interesting rules.
we also observe that only of these rules are extracted in nar miner na for no hit and the other rules are all missing.
for example the rule free netdev kfree is missing because there are functions calling both free netdev andkfree .
without considering semantic relations the support of the itemset free netdev kfree is which is much higher than the predefined threshold mis .
as a result it will not be taken as an infrequent itemset and thus the negative association rule cannot be inferred.
however with semantics constrained mining and information entropy nar miner successfully infers the rule and discovers corresponding bugs figure .
therefore we claim that semantics constrained mining can help reduce not only false positives but also false negatives .
.
.
comparison with positive rule mining based methods.
in practice certain bugs violating a negative rule may also violate a corresponding positive rule.
therefore such bugs are supposed to be detected by both negative and positive rule mining based methods.
we investigate to see if such cases occur commonly.
we choose the bugs in table as a base line conduct another experiment that infers positive association rules from the frequent itemsets mined in .
.
with the same settings for mf s andmin conf with nar miner and then detects violations of the rules as done in and .
a manual inspection shows three out of the bugs are detected and in table whereas the other bugs about .
are missing.
we then augment the positive rule mining based approach with the semantics constrained mining i.e.
taking the data relations among program elements into account.
two more bugs and are discovered but there are still bugs about .
are undetected.
consequently we claim that 418nar miner discovering negative association rules ... esec fse november lake buena vista fl usa while the semantics constrained mining is able to help the positive rule mining based approaches detect more bugs the negative rule mining based approach can exclusively discover a lot of bugs that positive rule mining based approaches cannot.
.
detecting bugs in other systems nar miner is further applied to postgresql v10.
openssl v1.
.
and ffmpeg v3.
.
.
nar miner extracted and negative rules from postgresql openssl and ffmpeg respectively.
we manually inspect the top ranked negative rules no more than and their violations in each system as done in .
.
as a result we identify six violations two per target and have reported them to the corresponding communities.
up to now all of the six suspected bugs have been confirmed and fixed by the corresponding system maintainers.
the details can be found in the bug reports for postgresql from the mailing list with ids and for openssl from the issue list with ids and and for ffmpeg from the mailing list with ids and .
the experiments demonstrate that nar miner is not limited to a specific target system e.g.
linux kernel but can be used to find real bugs in various large scale c systems.
.
case study in this section we illustrate the capability of nar miner with comparison with positive association rule par mining based methods on the confirmed bug in postgresql.
in postgresql the function opentransientfile allocates a file descriptor and stores it to a globally maintained list of allocated files.
the return descriptor must be released with closetransientfile which removes the descriptor from the list before truly closing it with close.
directly using close will make the list keep the released descriptors and may result in use after free bugs.
statistically in postgresql v10.
opentransientfile is invoked within functions.
in of the functions its return value is passed to closetransientfile but in function its return value is directly passed to close resulting in a negative association rule opentransientfile close and a positive association rule opentransientfile closetransientfile with the same confidence of .
.
figure shows a but in function dsm impl mmap that incorrectly passes the file descriptor fdallocated with opentransientfile at line to close at line along a path.
it violates the above negative rule and is thus reported by nar miner .
however from the view of accompanying analysis because on certain paths fdis correctly passed to closetransientfile at lines and which complies with the requirement of the above positive rule.
hence the buggy code is indeed a support rather than a violation of the rule.
we fix the bug by replacing line with closetransientfile fd as shown in figure .
the patch has been accepted by the maintainers.
discussion and limitations negative rules vs. positive rules .
in this paper we detect bugs mainly based on negative association rules rather than positive ones.
however these two kinds of approaches have no essential conflicts.
as they concentrating on different types of programming rules they can be complementary to each other.
from the point of view of bug detection our approach is able to extract negative1 postgresql .
src backend storage ipc dsm impl.c 2static bool dsm impl mmap dsm op op dsm handle h size s void p void ma size ms int l int fd flags ... struct stat st ... omitted if fd opentransientfile name flags return false if op dsm op attach if fstat fd st !
closetransientfile fd return false else close fd if op dsm op create unlink name return false closetransientfile fd return true nar closetransientfile fd patch par figure a bug in postgresql violating the rule opentransientfile close .
programming rules and to detect bugs that cannot be revealed by approaches based on mining positive association rules and vice verse.
theoretically a combination of the two kinds of approaches may exhibit better detection performance less false negatives .
in addition compared with mining positive rules mining negative rules is often accompanied by generating more uninteresting rules leading to a large amount of false positives.
in this case the positive rules of the same program can be helpful to reduce them.
for example if a piece of code violates a negative rule but satisfies a positive one the corresponding violation of the negative rule is more unlikely to be a real bug.
we can lower its ranking to filter such a violation.
similarly bug detection based on positive rules may also face the same challenge i.e.
reporting false positives .
so a straight forward question is that in such cases whether the two approaches can be helpful to reduce the false positives each other?
we will further research on this in the future.
rule explosion .
in essence the rule explosion problem in negative association rule mining cannot be completely resolved.
in this paper we adopted a relatively straight forward approach.
specifically we utilize semantic relationships between elements to eliminate a vast majority of uninteresting rules during mining and then employed the information entropy to measure interestingness of rules such that potential interesting rules are further highlighted.
however there may exist multiple solutions.
for example we can further quantify the strength of semantic relations among program elements to refine the mining results.
besides the data dependence and data share relations other relations can also be utilized such as control flow relation.
these potential improvements can further mitigate the rule explosion problem to lower manual audit effort.
this is also one of our future works.
mining algorithms .
in this paper we adopt the itemset mining algorithm to extract negative programming rules.
in practice for some kinds of programming rules other forms of representation and mining algorithms may be more appropriate.
for example using sequences to represent order sensitive programming logics is more suitable than using itemsets.
however the sequence based algorithm has poor robustness in discovering order insensitive programming logics.
if we can effectively determine whether a programming pattern is order sensitive or not a 419esec fse november lake buena vista fl usa p. bian b. liang w. shi j. huang and y. cai targeted algorithm can be adopted to mine related rules.
this will be one of our future works.
related work program analysis has been widely and successfully used for bug finding.
for example model checking can automatically verify the correctness properties of finite state systems with the model of the target system and the specification .
due to the high cost of writing a model for the target system implementation level model checkers are then developed and find real bugs in system code .
researchers also leverage program analysis to detect the violations of specific rules.
typically a set of programming rules are provided to the tools which either statically or dynamically check whether the target system violates the given rules.
pasareanu and rungta developed spf to generate test cases for java programs by introducing symbolic execution into model checking .
engler et al.
proposed techniques to statically check system rules using system specific compiler extensions while findbugs runs as a standalone tool to inspect occurrences of bug patterns in java bytecode .
livshits and lams translated user provided specifications of vulnerabilities into static analyzers and use them to detect vulnerabilities such as sql injections and cross site scripting in web applications written in java.
in addition molnar et al.
utilized dynamic test generation to find integer bugs in binary programs by checking the violations of particular assertions .
despite their success in finding bugs these approaches largely depend on the models of the system or the patterns of the bugs e.g.
high level api semantics which we call prior knowledge.
without that kind of knowledge they are unable to find bugs.
our work by contrast discovers the knowledge automatically and then detects bugs based on the collected knowledge.
techniques that can automatically extract knowledge from the target system are also presented.
the pioneer work proposed by engler et al.
employed statistical analysis to infer temporal rules from given rule templates detecting bugs without specifying concrete rules .
kremenek et al.
used factor graphs to infer specification from programs by incorporating disparate sources of information .
these two approaches are limited to infer rules with predetermined templates and specific knowledge that must be provided by the users.
some approaches rely on certain domain knowledge within the mining rules and are specially designed to infer rules for critical apis or security sensitive functions .
they also require the users to provide the domain knowledge to facilitate the mining process.
however nar miner requires nothing from the users while extracting rules based on the association rules implicitly included in the programs.
recently researchers leverage data mining algorithms to extract more general rules from real large systems .
the overarching idea behind these mining based techniques is that in most cases programs are correct and thus any anomalies are likely to be bugs .
in general these approaches first infer frequently appeared patterns from the target system and consider such patterns as the implicit rules that developers should follow in coding.
then they detect any violations of those rules as potential bugs.
the inferred patterns can be either positive or negative.
for example pr miner and antminer extract positive association rules that enforce paired appearances of program behaviors.
chang et al.
detect missing code structures by mining frequently associated sub graphs from program control flows and inspecting occasional violations .
yun et al.
infer the correct usage of apis based on the mined positive association rules of the semantics among different apis .
different with these approaches nar miner focuses on mining negative association rules from source code and detects bugs that violate those rules.
similar rules can also be extracted from dynamic execution traces.
beschastnikh et al.
developed synoptic to generate temporal system invariants from system execution logs .
wang et al.
developed bugram that employs the n gram language model to measure the probability of token sequences and treats low probability sequences as anomalies i.e.
potential bugs .
bugram can also detect certain bugs caused by the co occurrence of mutually suppressed program elements.
however due to the limited size of the sequence window bugram is difficult to capture bugs involving long distance program elements.
mining negative association rules has been applied to data like market basket protein sequences and financial data .
for such data the relationship between two elements is much simpler than that for program elements which contribute different intensities to the relationship.
wu et al.
presented algorithms to effectively and efficiently mine negative association rules in large databases .
zhou and yau proposed a combined algorithm to mine interesting association rules reducing large number of negative rules .
these algorithms can also be adopted by nar miner as the basic mining algorithm but need to handle program semantics in order to reduce uninteresting rules.
conclusion data mining techniques have been widely used to infer programming rules and then detect software bugs based on the rules.
existing approaches have proven that positive association rules indicating that associated program elements must appear together are useful to detect bugs via checking the violations.
however the negative programming rules which disallow the co occurrences of involved program elements are mostly neglected.
we present nar miner to mine negative association rules from source code.
we introduce program semantics to guide the mining phase.
we also leverage function entropy to rank candidate rules and highlight the interesting ones.
by this means nar miner dramatically reduces the number of uninteresting rules and mitigates the rule explosion problem to a certain degree.
we evaluate the prototype on four popular large scale systems and find a considerable number of bugs some of which have been confirmed by the maintainers.