typedevil dynamic type inconsistency analysis for javascript michael pradel parker schuh koushik sen electrical engineering and computer sciences university of california at berkeley technical report no.
ucb eecs october 2014copyright by the author s .
all rights reserved.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission.
acknowledgement this research is supported in part by nsf grants ccf ccf1018729 ccf and ccf and gifts from mozilla and samsung.typedevil dynamic type inconsistency analysis for javascript michael pradel parker schuh and koushik sen eecs department university of california berkeley abstract dynamic languages such as javascript give programmers the freedom to ignore types and enable them to write concise code in short time.
despite this freedom many programs follow implicit type rules for example that a function has a particular signature or that a property has a particular type.
violations of such implicit type rules often correlate with problems in the program.
this paper presents typedevil a mostly dynamic analysis that warns developers about inconsistent types.
the key idea is to assign a set of observed types to each variable property and function to merge types based in their structure and to warn developers about variables properties and functions that have inconsistent types.
to deal with the pervasiveness of polymorphic behavior in real world javascript programs we present a set of techniques to remove spurious warnings and to merge related warnings.
applying typedevil to widely used benchmark suites and real world web applications reveals problematic type inconsistencies including correctness problems performance problems and dangerous coding practices.
i. i ntroduction dynamic languages such as javascript are becoming increasingly popular for client side and server side web applications traditional desktop applications and mobile applications.
one reason for this popularity is that dynamic languages do not require programmers to annotate their programs with type information or to follow any strict typing discipline.
this freedom allows programmers to write concise code in short time.
however the freedom offered by dynamic languages often comes at the cost of hidden bugs.
since the language does not enforce any typing discipline no compile time warnings are reported if a program uses and combines types inconsistently.
even worse many dynamic languages silently coerce values from one type into another type leading to incorrect behavior without any obvious sign of misbehavior.
figure shows three type related problems that may easily remain unnoticed.
each example is a previously unreported problem that we find in a popular javascript benchmark.
figure 1a shows code that concatenates strings into a larger string.
unfortunately concatenating the initially undefined variable dnaoutputstr with a string results in a string that starts with undefined .
figure 1b shows code that pads a given string with empty characters until it reaches a particular length.
unfortunately the function returns a string object when the given string already has the desired length and a primitive string value otherwise which is problematic because these two types behave differently.
figure 1c shows the constructor of an object and code that modifies the properties of this object.
unfortunately this modification overwritesproperties of type number with undefined which causes a crash when running the program with a configuration that slightly differs from the default configuration.
finding these problems is difficult because they do not lead to obvious signs of misbehavior when executing the programs.
how can developers detect such problems despite the permissive nature of javascript?
all three examples in figure share the property that a variable property or function has multiple inconsistent types .
in figure 1a variable dnaoutputstr holds both the undefined value and string values.
in figure 1b function leftpad sometimes returns an object and sometimes returns a primitive string value.
in figure 1c variable gbcontains objects that have different structural types.
this paper exploits the observation that inconsistent types often correlate with problems and presents typedevil a mostly dynamic analysis that detects inconsistent types in javascript programs.
the analysis associates type information with each variable property and function and records the types of values observed at runtime.
based on this runtime information the analysis merges types that are structurally equivalent.
finally the analysis reports potential problems caused by variables properties and functions that have multiple inconsistent types.
to avoid unnecessary warnings caused by source code that is intentionally polymorphic the approach aggressively filters and merges warnings for example based on programmer beliefs inferred from the source code and based on dataflow relations between variables.
our work is enabled by two observations about javascript code that occurs in practice.
first we observe that even though it is not required by the language most code follows implicit type rules.
we speculate that programmers voluntarily use consistent types because it facilitates humans to reason about code.
second we observe that inconsistent types either originate from highly polymorphic yet correct code locations or from code locations where occasional inconsistencies correlate with problems that developers should be aware of.
typedevil leverages these two observations by inferring types from runtime behavior and by reporting occasionally observed inconsistent types as likely problems.
two kinds of existing analyses reason about types in dynamic languages.
first static and dynamic type inference aims at assigning types to variables and functions to show that the program is well typed .
due to the inherent difficulties of analyzing dynamic languages and a b c program regexp dna sunspider date format xparb sunspider gb emulator octane source code 1vardnaoutputstr 2for iinseqs dnaoutputstr seqs .
source 1string.
leftpad function val size ch varresult newstring val if ch null ch while result.length size result ch result return result 1function gameboycanvas this.width this.height 5function initnewcanvas gb.canvas.width gb.canvas.clientwidth gb.canvas.height gb.canvas.clientheight inconsistent typesvariable dnaoutputstr has types string andundefinedfunction leftpad has return types object andstringvariable gbhas inconsistent object types e.g.
gb.canvas.width has types number and undefined problem incorrect string value undefinedgtagg.. return values behave differently depending on the length of the given stringcrash when changing the emulator settings fig.
.
real world problems related to inconsistent types.
due to intentionally polymorphic code this approach either requires type annotations or it leads to various type errors that include many false positives.
typedevil has a relatively low number of false positives because it uses a mostly dynamic analysis because it focuses on individual problematic code locations instead of inferring sound types for the entire program and because it uses a set of novel techniques to deal with intentionally polymorphic code.
second optimizing jit compilers leverage static and dynamic type inference to emit code specialized towards particular runtime types .
instead of improving the performance of existing programs typedevil warns developers about problematic code locations.
to evaluate typedevil we apply it to popular javascript benchmarks and to real world web applications.
in total the analysis reports type inconsistencies of which at least correspond to problematic code.
the detected inconsistencies lead to incorrect but not necessarily crashing behavior such as figure 1a expose error prone programming practices such as figure 1b and cause crashes and other unintended behavior in executions that are slightly different from the analyzed executions such as figure 1c.
the most prevalent root cause for inconsistent types is that a variable property or function is unintentionally undefined .
however simply reporting all occurrences of undefined would not only report many false positives but also miss four of the problems that typedevil detects.
in summary this work contributes the following inconsistent types as likely problems .
we present the notion of inconsistent types as a pattern of likely problems in programs written in dynamic languages.
section iii an analysis to find inconsistent types .
we present typedevil a practical mostly dynamic analysis that detects inconsistent types in javascript programs.
in contrast to traditional type inference typedevil does not aim at showing the well typedness of a program but it focuses on individual variables properties and functions that have inconsistent types.
section iv empirical evidence .
we report the results of an extensive evaluation with widely used javascript programs andwe show that typedevil reveals previously unreported problems in these programs.
section v ii.
o verview and example this section illustrates our approach with a simple javascript program.
the program in figure 2a defines a functionaddwrapped that takes two numbers each wrapped into an object and returns the sum of the two numbers.
if only one argument is given then the function returns the number wrapped by this argument.
wrapped numbers are objects with a property vthat contains the number.
to wrap a number one can either call the wrapper constructor or use an object literal such as fv g. the program calls addwrapped three times passing a single argument in line and two arguments in each of lines and .
the intended behavior of the program is that all three calls of addwrapped return .
however the call in line accidentally uses a string instead of the number .
since javascript silently coerces values from one type to another the program executes without any warning.
line coerces the number 5into a string and then concatenates it with the string .
as a result the call in line returns and not the expected number .
typedevil detects such problems by dynamically analyzing the program and by reporting variables properties and functions that have inconsistent types.
the approach has three steps which we illustrate in the following.
gathering type observations the first step is a dynamic analysis that gathers type observations for each variable property and function that the analyzed execution refers to.
typedevil instruments the program by adding code that records the type of each reference.
types in javascript are structural types and typedevil represents types as a record of typed properties.
for example the type of the object created in line is a record with a single entry vof type number .
to bound the number of types the analysis considers all objects allocated at the same code location and all functions defined at the same code location to have a single type.
a source code 1function addwrapped x y if y return x.v y.v else return x.v 8function wrapper v this.v v 11addwrapped v 12addwrapped v newwrapper 14addwrapped v newwrapper b type observations sorted by first appearance base prop.
type lines object1 v number frame addwrapped y undefined frame addwrapped x object1 function addwrapped return number object2 v number frame wrapper v number object3 v number function wrapper return object3 frame addwrapped y object3 frame addwrapped x object2 object4 v string object5 v number function wrapper return object5 frame addwrapped y object5 frame addwrapped x object4 function addwrapped return string c condensed type graph function addwrapped returnfunction wrapper returnobject1235 object4 v stringnumber undefined frame addwrapped x yv frame wrapper v d reported type inconsistencies argument xofaddwrapped has inconsistent object types x.v isnumber lines and and string line .
addwrapped has inconsistent return types number lines and and string line .
fig.
.
running example.
executing the program in figure 2a yields the type observations summarized in figure 2b.1each row of the table describes the types observed for a property of a base type.
we use the same representation of type observations for types of properties variables and functions.
for example the first row describes that the object created at line called object1 has a property vof type number .
the second row describes that the local variable yofaddwrapped is observed to have typeundefined .
the fourth row describes that the return type of function addwrapped is observed to be number .
summarizing observations into a type graph after gathering type observations at runtime typedevil merges all observations into a type graph.
nodes in the graph represent types and labeled edges represent properties.
an edge pfrom type t1to type t2means that t1has a property pof type t2.
figure 2c shows the type graph for our example.
for illustration purposes we represent the outgoing edges of a node as a record.
typedevil merges type nodes that are structurally equivalent.
for example object1 object2 object3 and object5 all have a single property vof type number and therefore are represented as a single type node object1235.
reporting problematic inconsistencies the final step of typedevil is to report type inconsistencies.
initially the analysis considers each property of a type as inconsistent where the type node has more than one outgoing edge labeled with this property.
in figure 2c these property edges are dashed.
for example the property that represents the return value of addwrapped is inconsistent because it points both to the number node and to the string node.
to avoid overwhelming developers with spurious and duplicate warnings typedevil aggressively filters and merges inconsistencies.
for the example the analysis filters the inconsistency of the argument yofaddwrapped because the program expects yto be undefined as indicated by the check in line .
as a result 1the table omits some type observations for brevity.typedevil reports two warnings figure 2d which point the developer to the incorrect argument passed to addwrapped in line and to the resulting incorrect return value.
iii.
p roblem statement in the following we define the most important terms used throughout the paper and the problem we are addressing.
definition type a type is either a primitive type boolean number string undefined or null or a record type p!
2tthat maps named properties to sets of types.
a record type represents one of the following kinds of types anobject type where properties represent object properties.
anarray type where properties represent indices.
afunction type where the this and return properties represent the receiver and the return value respectively.
aframe type where properties represent local variables of a function.
treating objects arrays functions and function call frames as a single concept simplifies the description and implementation of typedevil.
each property of a record type maps to a set of types because a property may point to multiple different types.
the record of a function type does not include the parameters of the function because parameters are treated as local variables in the function s frame type.
our representation of types ignores the prototype of an object.
two types are consistent if both types are the same if both types are structurally equivalent or if one type is a structural subtype of the other type.
definition consistent types types t1andt2are consistent t1 t2 if and only if one of the following holds botht1andt2are primitive types and t1 t2.
both t1andt2are record types and all of the following hold kind t1 kind t2 where kind t is either object array function or frame.
the sets of properties of t1andt2are equal or a subset of each other dom t1 dom t2 ordom t2 dom t1 .
all common properties of t1andt2point to types that are consistent with each other 8p2dom t1 dom t2 8t0 12t1 p 9t0 22t2 p t0 t0 2and 8t0 22t2 p 9t0 12t1 p t0 t0 we say that two types are inconsistent if they are not consistent according to the above definition.
the problem addressed in this paper is how to detect inconsistent types that are likely programming errors in javascript programs.
iv.
a pproach this section describes the typedevil approach in detail.
a. gathering type observations the first step of typedevil is to instrument and execute the program to gather information about the types of variables properties and functions.
the result of this first step is a set of type observations .
each observation is a triple base prop type where base is the name of a type prop is the name of a property of the base type and type is the name of the type that prop is observed to refer to.
to gather type observations typedevil instruments the program in two ways.
first we add instrumentation code that creates type observations and that stores them into a global set of observations.
second we add instrumentation code that attaches a shadow value to each object.
this shadow value stores the name of the type we associate with the object to easily access the object s type name whenever the object is referred to.
the dynamic analysis is implemented on top of jalangi details on the instrumentation and the implementation of shadow values are available in .
the following describes the instrumentation points where typedevil adds code.
object literals to keep track of the type of newly created objects typedevil adds instrumentation code to every object literal.
the instrumentation code creates one type observation for each property of the object literal where base is object concatenated with a unique identifier of the object literal s source code location prop is the name of the object property andtype is the type name of the object that prop refers to.
the instrumented code stores the value of base as the shadow value of the newly created object.
for example the object literal in line of figure leads to a type observation object v number .
when executing this line typedevil attaches the shadow value object to the newly created object.get property and put property to keep track of the types of object properties typedevil adds instrumentation code to every source code location that reads or writes an object s property.
the instrumented code creates a type observation where base is the type name of the base object prop is the name of the property and type is the type name of the value that is read or written.
these type observations may replicate information that is already known.
we nevertheless record a type observation at every property access because properties may be modified by uninstrumented code such as native functions.
for example line of figure reads property vof the base object x. when this line is reached for the first time via the call in line it leads to a type observation object v number .
function literals to identify function types typedevil adds instrumentation code to every function literal.
the instrumented code attaches to the new function object a shadow value which is function concatenated with a unique identifier of the function definition site.
the value will be used to identify the function s type whenever this function is referred to.
for example when executing the function declaration statement in line of figure the instrumented program attaches the type name function addwrapped to the newly created function object.
function calls to keep track of function types typedevil adds instrumentation code to every function call.
the instrumented code records the call s receiver type and return type by creating type observations where base is the name of the function type prop is this and return respectively andtype is the type of the receiver object this and the return value respectively.
if the function has no return value the program records a type observation where type is undefined .
at function call sites typedevil does not record the types of function parameters instead these observations are recorded when the callee accesses the arguments.
if the function call is a constructor call typedevil also creates type observations for the newly created object as described above for object literals.
for example when executing the call in line of figure typedevil records the following type observations function addwrapped this window and function addwrapped return number where window refers to the global object which in javascript is assigned to this in the absence of another receiver.
function enter to enable the analysis to keep track of the type of local variables typedevil instruments each function body by adding code at the function entry.
the added code associates the name of the frame type of the function with the current stack frame object.
the name of the frame type is frame concatenated with a unique identifier of the source code location of the function definition.
the analysis uses the frame type to keep track of the types of local variables of the function.
for example typedevil adds instrumentation code to the entry of the function defined in line of figure .
when entering this function the instrumented program associates the name frame addwrapped with the current stack frame.
4variable reads and writes to keep track of the type of local variables including function parameters typedevil adds instrumentation code to every variable read and write.
the instrumented program creates a type observation where base is the frame type of the stack frame that defines the variable prop is the name of the local variable and type is the type of the value that is read or written.
for example when the call in line of figure leads to a read of variable yin line the instrumented code adds a type observation that records the variable s type frame addwrapped y undefined in javascript a variable can be a local variable of the function fthat is currently on top of the call stack a variable accessible via the closure created when fwas defined or a global variable.
typedevil assigns each local variable to the frame where it is defined and it assigns global variables to a special global frame.
b. summarizing observations into a type graph executing a program that is instrumented as described in the previous section yields a set of type observations.
the next step of typedevil is to summarize these observations into a graph that allows for identifying inconsistent types.
definition type graph the type graph gof an execution of a program is a directed graph t p .
the nodestrepresent types observed during the execution.
an edge t1 t2 p 2p represents that the property poft1has been observed to point to a value of type t2.
to create an initial type graph typedevil iterates through all type observations.
for each observation base prop type the analysis checks if there are nodes in tthat represent base andtype and creates such nodes if they do not yet exist.
then typedevil checks if there exists an edge that is labeled with prop from base totype and adds such an edge to the graph if it does not yet exist.
typedevil leverages the type graph to identify inconsistent types by searching for nodes that have multiple outgoing transitions labeled with the same property name.
performing this search on the initial type graph would lead to many spurious warnings because in the initial type graph different nodes may represent structurally equivalent types.
for example in the initial type graph for figure graph not shown the node that represents function wrapper has two outgoing transitions labeled with return each pointing to an object type that has a single property vof type number .
reporting inconsistent types based in the initial type graph would lead to a warning even though all objects passed to wrapper are structurally equivalent.
to avoid the problem of reporting inconsistencies between structurally equivalent types we condense the type graph by merging equivalent types.
definition equivalent types two types t1andt2are equivalent t1 t2 if and only if one of the following holds botht1andt2are primitive types and t1 t2.algorithm condense type graph.
input type graph g t p output condensed type graph g0 t0 p0 m inittypemap g .mapt !t0 changed true while changed do changed false for all t2t do ift6 m t then if9t02t witht6 t0andt t0then m t t0 else m t t changed true t0 p0 for all t2range m do t0 t0 mergenodes ft02t withm t0 tg p0 p0 mergeedges ft02t withm t0 tg m return t0 p0 both t1andt2are record types and all of the following hold kind t1 kind t2 where kind t is either object array function or frame.
t1andt2have the same properties and each property points to types that are equivalent dom t1 dom t2 and8p2dom t1 t1 p t2 p. typedevil merges equivalent type nodes of the type graph to obtain a condensed type graph.
definition condensed type graph the condensed type graph gof an execution of a program is a type graph for which there do not exist any two nodes that are equivalent.
algorithm describes our approach for producing a condensed type graph from the initial type graph.
the basic idea is to initially assume that all types that have the same kind and the same set of property names are equivalent and to repeatedly split types that turn out to be not equivalent when following their outgoing edges.
the algorithm initializes and refines a map mthat assigns type nodes of the initial type graph to type nodes of the condensed type graph.
at first the helper function inittypemap initializes the map mby creating a condensed type node for each set of initial type nodes that have the same kind and the same set of property names.
the main part of the algorithm lines to repeatedly refines muntil each type node is equivalent to the condensed type node it maps to.
for this purpose the algorithm searches for a type node tthat is currently mapped to a non equivalent type node and assigns it to another type node instead.
if there exists another type node t0that is equivalent to taccording to definition then the algorithm maps tto this type node t0.
5otherwise the algorithm creates a new condensed type node by mapping tto itself.
the final part of the algorithm lines to creates the condensed type graph t0 p0 by merging type nodes and property edges according to the map m. the helper function mergenodes creates a single type node that combines the type names of all given type nodes.
likewise the helper function mergeedges maps the outgoing transitions of the given set of type nodes to the respective nodes in the condensed type graph.
figure 2c shows the condensed type graph for our running example.
c. reporting inconsistencies that are likely problems the final step of typedevil is to report inconsistent types that are likely problems.
the basic idea is to report a warning for each type node that has multiple outgoing transitions labeled with the same property name.
definition inconsistent type warning given a condensed type graph g t p an inconsistent type warning is a triple t p ti where t2t pis a property name ti ftij t ti p 2pg andjtij .
for example the first warning of figure 2d is frame addwrapped x fobject object 4g .
a naive implementation of this idea reports various warnings that correspond to harmless code.
the reason is that a variable property or function may refer to multiple types on purpose.
typedevil heuristically distinguishes such intended polymorphism from inconsistency problems by combining two kinds of techniques.
first we use techniques that assign warnings to equivalence classes so that warnings that have the same root cause are in the same class sections iv c1 to iv c3 .
second we use techniques that mark warnings that are likely false positives for pruning sections iv c4 to iv c7 .
typedevil computes the final set of warnings by keeping exactly one warning per equivalence class if and only if none of the warnings in this equivalence class is marked for pruning.
merging by dataflow relations if a single value is referred from multiple