powerstation automatically detecting and fixing inefficiencies of database backed web applications in ide junwen yang university of chicago uscong yan university of washington uspranav subramaniam university of chicago us shan lu university of chicago usalvin cheung university of washington us abstract modern web applications are built using a myriad of software components and each of them exposes different programming models e.g.
application logic expressed in an imperative language database queries expressed using declarative sql .
to improve programmer productivity object relational mapping orm frameworks have been developed to allow developers build web applications in an object oriented manner.
despite such frameworks prior work has found that developers still struggle in developing performant orm based web applications.
this paper presents powerstation a rubymine ide plugin for optimizing web applications developed using the ruby on rails orm.
using automated static analysis powerstation detects orm related inefficiency problems and suggests fixes to developers.
our evaluation using real world applications shows that powerstation can automatically detects performance issues across them.
a tutorial on using powerstation can be found at .
ccs concepts software and its engineering software performance keywords performance anti patterns object relational mapping frameworks database backed applications rubymine plugin acm reference format junwen yang cong yan pranav subramaniam shan lu and alvin cheung.
.
powerstation automatically detecting and fixing inefficiencies of database backed web applications in ide.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction modern web applications face stringent latency requirement and increasingly large amount of user data to process.
recent studies have found that users expect every web page to load within two seconds with one second s delay causing fewer page views a decrease in customer satisfaction and loss in conversions .
meanwhile popular web applications often encounter user accounts increasing from a few thousands to tens of millions in few years .
such latency and data scaling pressures are particularly aggravated by the pervasive use of object relational mapping orm frameworks e.g.
ruby on rails django and hibernate that while improve programmer productivity by abstracting persistent data manipulations through their object oriented interfaces make it difficult for developers to optimize the queries that are automatically generated by the frameworks.
previous studies have shown that developers often struggle at writing efficient web applications using orm frameworks .
several orm related performance anti patterns have been found to widely exist in real world database backed web applications and lead to application inefficiencies.
unfortunately many of these inefficiencies go undetected by compilers and database management systems as they focus solely on either the application code or the embedded queries while recognizing such inefficiencies require both systems to work in tandem.
this paper presents powerstation an ide plugin for ruby on rails rails applications that automatically detects orm related performance problems and suggests fixes for them.
it makes two contributions.
first we build a database aware static analysis framework for rails applications.
the current powerstation prototype can already detect common orm performance anti patterns and generate patches for of them.
these anti patterns include loop invariant query dead store query unused data retrieval unoptimized common subexpression api misuses and inefficient data rendering.
as summarized in previous work only patterns can be detected previously and we are unaware of any tool that can automatically fix any of them.
second we have integrated powerstation into a popular rails ide rubymine so that rails developers can easily benefit from powerstation to improve the efficiency of their applications.
the source code of powerstation is available on github .
performance anti patterns powerstation currently tackles six performance anti patterns.
while these patterns have been observed in previous work from real world rails applications they have not been systematically detected and fixed before three anti patterns rd cs and esec fse november lake buena vista fl usa j. yang c. yan p. subramaniam s. lu and a. cheung ran.include?val end values.reject do val rans read only u read only u .
include?val sql select from custom fields join ... join ... where user id ?
call v3 read only u call v2 values.reject call v3.include?val query node data edge control edge a ruby code b adg copy u v1 branch copy val figure loop invariant query from redmine the code checks which valinvalues list belongs to user u s read only fields sql select1fromblogswhere user id ?
limit1sql selectcount fromblogs where user id ?ruby if user.blogs.count 0ruby if user.blogs.exist?
figure api misuse from onebody the upper code is less efficient than the lower code ia below were automatically detected in three different frameworks and we are unaware of prior work that performs automatic patching.
loop invariant queries li .
a query is repeatedly issued in every iteration of a loop to load the same database contents.
in the real world example shown in figure 1a hoisting the query out of the loop can speed up the application by more than .
dead store queries ds .
sql queries are repeatedly issued to assign the same memory object with different database contents without any use of the memory object in between making all but the last query unnecessary.
unused data retrieval queries rd .
data is retrieved from the database but never used in the program making the corresponding data transfer and query execution unnecessary.
common sub expression queries cs .
queries with common sub expressions are issued causing unnecessary re computation.
api misuses ia .
different orm apis retrieve the same contents from the database but they differ drastically in terms of performance.
for example the two rails code snippets in figure both check if a user owns any blog posts.
however they use different apis count versus exist that are translated to different sql queries by rails select count vs.select limit .
the former query scans all records in the blogs table with specified user id counts the number of records and checks in the ruby application if the count is greater than .
the latter query returns immediately when it finds one record with the specific user id which can reduce query execution time by .
comparing to the former.
inefficient data rendering ir .
while rendering a list of objects helper functions are often used to render a partial view for one object at a time with much redundant computation repeated for every object.
for example the html in figure 4b is generated line by line by repeated invocations of link to with much redundancy across lines.
such inefficiency is particularly severe when there are many objects to render.
consequently it could become a scalability bottleneck when the objects need to be first retrieved from database.
we find these six anti patterns to be prevalent even in welldeveloped applications as developers are often unaware of what database queries are issued due to the orm abstraction.
suchqueries also cannot be optimized by traditional ruby compilers as they treat orm apis as black boxes nor database engines as they can only observe the queries issued by the application .
we next explain how powerstation can detect such patterns.
powerstation s static analysis powerstation s static analysis contains two components.
the first takes in rails source code and generates a database aware program dependency graph for every action 1which we refer to as the action dependency graph adg .
the second component takes in the adg identifies performance anti patterns and synthesizes fixes.
we anticipate extending powerstation to tackle other orm related performance issues in the future.
.
database aware static analysis framework powerstation s static analysis framework goes through the following steps to generate adg from ruby on rails source code.
pre processing.
powerstation performs inter procedural analysis on the source code by statically inlining all function calls.
it also inlines callbacks such as activerecord validations invoked by this action.
since ruby is dynamically typed powerstation performs type inference to statically determine variable types.
program dependency graph pdg generation.
powerstation generates a pdg for every controller action which is the entry function that eventually produces a webpage.
it uses jruby to parse the pre processed source code and then builds the pdg from jruby s intermediate representation ir as this ir nicely captures high level ruby semantics via instructions and operands.
as illustrated in figure 1b every node nin the pdg represents a statement in the jruby ir.
every edge ein pdg represents either control dependency or data dependency.
a data dependency edge n1 n2 indicates that the output object oofn1is used by n2without other statements overwriting oin between.
database aware adg generation.
powerstation then enhances the pdg generated above in three ways to create the adg changing and splitting some nodes to become query nodes annotating every query node with the database table and fields that are read or written annotating every outgoing data dependency edge of a query node with the exact field s that are used.
to accomplish this powerstation first analyzes every model class that extends the rails activerecord interface to determine all the database tables in the application and the association relationship among them.
for example analyzing the model classes illustrated in figure powerstation identifies the users table corresponding to the user class and similarly for the blog class and that these two models have a one to many relationship i.e.
each instance of user may own multiple instances of blog .
second powerstation analyzes the schema.rb file to determine how many fields each table contains.
for example parsing the schema.rb snippet in figure powerstation infers the schemas of the users andblogs tables as shown in the bottom of the figure.
third powerstation identifies queries from three sources explicit invocations of rails activerecord query apis such as 1an action is a member method of a ruby controller class.
when a web application receives a request a corresponding action will execute to respond to the request.
885powerstation automatically detecting and fixing inefficiencies of ... esec fse november lake buena vista fl usa class blog activerecord belongs to user end class user activerecord has many blogs end create table users do t t.string name t.datetime created at end create table blogs do t t.integer user id t.text contents end schema.rb user.rb user id name created at blog.rb schema.rb blog id user id contents schemas inferred by powerstation figure analyzing table schemas exist?
reload update destroy etc implicit queries generated by rails to access object fields e.g.
o1.o2 where the class of o1 and the class of o2are associated model classes e.g.
user.blogs would incur a query to retrieve records in blogs table that are associated with the specific user record in users table embedded sql queries through base.connection.execute .
any query identified above is represented as a query node in the adg.
.
detecting and fixing anti patterns loop invariant queries.
powerstation first identifies all query nodes inside loop bodies in adg.
for each such node n it checks the incoming data dependency edges of n. if all of these edges start from outside the loop lwhere nis located then nis identified as a loop invariant query such as call v3... in figure 1b.
to fix this powerstation inserts a new assign statement before the start of the loop where a newly created variable vgets the return value of the loop invariant query and replaces every invocation of the loop invariant query inside loop lwith v. dead store queries.
powerstation checks every adg node that issues a reload query i.e.
o.reload and checks its out going datadependency edge.
if there is no such edge i.e.
the reloaded content is not used then the query is marked as a dead store query that is deleted by powerstation.
unused data retrieval queries.
for every read query node n in the adg powerstation first computes the database fields loaded bynthat are used subsequently.
this is the union of the used fields associated with every out going data dependency edge of n. powerstation then checks if every loaded field is used.
for every unused field powerstation either deletes n if none of the fields retrieved by nare used or adds field selection .select f1 f2 .
.
.
to the original query in nso that only used fields f1 f2are loaded.
common sub expression queries.
powerstation checks every query node q0in adg to see if q0has out going data dependency edges to at least two query nodes q1andq2in the same control path.
if that is the case then by default rails would issue at least two sql queries that share common sub expression q0at run time one composing q0andq1and one composing q0andq2 with the latter unnecessarily evaluates q0again.
this can be optimized by changing the query plan and caching the common intermediate result for reuse .
so requires issuing raw sql commands that are currently not supported by rails activerecord apis.
2at run time multiple such queries could be composed by orm into one sql query.
such query chaining does not affect powerstation s analysis.
link tok v target b hashes.eachdo k v end l link to p1 p2 id b l.gsub p1 k .gsub p2 v a id b href v1 k1 a a id b href v2 k2 a a id b href v3 k3 a a id b href v4 k4 a a id b href v5 k5 a ... a b figure fix for inefficient rendering gsub is a string substitution api replacing its first parameter with the second api misuses.
powerstation uses regular expression matching to find inefficient api misuses as in previous work .
since these api mis use patterns are simple powerstation also synthesizes patches for each api mis use pattern through regular expressions.
inefficient rendering.
powerstation checks every loop in the adg to see if it iterates through objects returned by queries and contains a rails view helper function such as link to in every loop iteration.
if so powerstation identifies the code as having the inefficient rendering problem.
to fix this powerstation hoists the helper function out of the loop assigns its result to a newly created variable and replaces the original helper function in the loop with gsub a string substitution function on the newly created variable as shown in figure .
so removes the redundant rendering that is performed on every loop iteration in the original code.
discussion.
like other code refactoring tools powerstation currently suggests fixes to the user rather than deploying them automatically.
this is important for dead store and unused data cases since the powerstation suggested fixes would change application semantics if the retrieved data is used in multiple actions.
for the other cases however powerstation s suggested fixes do preserve program semantics.
powerstation ide integration .
powerstation ide plugin features we have implemented powerstation as an ide plugin for rubymine a popular ide for ruby on rails.
a screenshot of powerstation is shown in figure .
by pressing the powerstation button at the top of rubymine users can choose an analysis scope whole application or single action and launch powerstation analysis accordingly.
our website includes a tutorial .
issues list.
the right panel as highlighted in figure lists all the inefficiencies detected by powerstation each represented by a button displaying the file where the inefficiency is located.
by default all the inefficiencies found in the project are listed.
users can also choose to display inefficiencies of a particularly type as shown in figure loop invariant queries li dead store queries ds unused data retrieval queries rd common sub expression queries cs api misuses ia and inefficient rendering ir .
issues highlight.
clicking the file button in the issue list will navigate users to the corresponding file in the editor with the inefficient code highlighted.
hovering the cursor over the highlighted code will display the reason for highlighting as shown in figure .
issue fix.
clicking the fix button next to each issue in the issue list will pop up window asking the user whether she wants powerstation to fix the issue.
if so powerstation will synthesize a fix as discussed in section and display the fixed code in the editor panel.
at that point the original fix button becomes an undo button allowing users to revert the fix if needed.
886esec fse november lake buena vista fl usa j. yang c. yan p. subramaniam s. lu and a. cheung after fixissue detailissue liststart buttoncontroller blogs controller.rbfix figure screenshots of powerstation ide plugin .
implementation we used the apis provided by the intellij platform like toolwindow andjbtabbedpane to create the powerstation issues list.
highlighting the selected inefficiency is straight forward using the intellij api highlighterlayer given file name and line number provided by powerstation static analysis.
for every anti pattern powerstation prepares a string template that explains the inefficiency and the fix strategy such as is a dead store query.
fix delete .
for a dead store query figure .
this string is instantiated with program variables and expressions output from powerstation static analysis and displayed using the intellij api filedocumentmanager .
finally intellij api fileeditormanager textrange and document are used to insert replace and delete source code in the editor panel.
evaluation powerstation can be downloaded from intellij plugin repository and easily installed in rubymine.
we evaluated powerstation using the latest versions of opensource rails applications including the top two popular applications on github from categories forum collaboration e commerce task management social network and map.
as shown in table powerstation can automatically identify inefficiency issues and generate patches for of them i.e.
all but the common subexpression pattern .
we randomly sampled and examined half of the reported issues and the suggested fixes and found no false positives.
due to the limited resource and time we reported issues with of them already confirmed by developers none has been denied .
powerstation static analysis is fast taking only seconds to analyze the entire application that ranges from 4k to 145k lines of code in our experiments on a chameleon instance with 128gb ram and cpus.
developers can also choose to analyze one action at a time which usually takes less than seconds in our experiments.
related work recent work used static program analysis to find optimization opportunities in database related applications such as qbs for query synthesis quro for query reordering in transactions and pipegen for automatic data pipe generation.
none of these techniques detect or fix anti patterns addressed by powerstation.
dynamic profiling tools have been built for rails applications they cannot statically detect and fix inefficiency root causes.
static analysis tools have been built to detect code smells and code cleaning opportunities in rails applications.
however they do not detect performance problems.table inefficiencies detected by powerstation in apps app.
loop invariantsunused datacommon sub exprapi misusesinefficient rendersum ds lo gi re sp ro fu tr da on ff os sum conclusion and future work powerstation is a new tool that automatically detects and fixes a large set of orm related performance issues that are both common and severe in database backed web applications.
its integration with rubymine provides an easy way for rails developers to avoid making performance degrading mistakes in their programs.
we have used powerstation to identify and fix many performance related issues in real world applications and will extend powerstation tackle further performance anti patterns as future work.