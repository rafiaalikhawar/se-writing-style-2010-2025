efficient transaction based deterministic replay for multi threaded programs ernest pobee department of computer science city university of hong kong kowloon tong hong kong ernestpob gmail.comxiupei mei department of computer science city university of hong kong kowloon tong hong kong xpmei2 c my.cityu.edu.hkw .k.
chan department of computer science city university of hong kong kowloon tong hong kong wkchan cityu.edu.hk abstract existing deterministic replay techniques propose strategies which attempt to reduce record log sizes and achieve successful replay.
however these techniques still generate large logs and achieve replay only under certain conditions.
we propose a solution based on the division of the sequence of events of each thread into sequential blocks called transactions.
our insight is that there are usually few to no atomicity violations among transactions reported during a program execution.
we present tplay a novel deterministic replay technique which records thread access interleavings on shared memory locations at the transactional level.
tplay also generates an artificial pair of interleavings when an atomicity violation is reported on a transaction.
we present an experiment using the splash2x extension of the parsec benchmark suite.
experimental results indicate that tplay experiences a fold improvement in record log sizes and achieves a higher replay probability in comparison to existing work.
keywords concurrency deterministic replay transactions multi threading.
i. i ntroduction deterministic replay of a program involves recording data from the program execution and subsequently scheduling the program to achieve some desired state or output .
deterministic replay techniques are generally categorized into hardware based and software based techniques.
software based techniques often consist of a record phase and a replay phase.
some of them further include an offline phase to compute construct feasible schedules for replay.
due to the non ubiquitous nature of specialized hardware required for most hardware based techniques we present our technique in relation to software based replay techniques.
in the record phase replay techniques typically record three types of thread access orders known as interleavings squiggleright namely read write write read and write write interleavings on shared memory locations.
interleavings on synchronization primitives are also recorded.
some techniques also record other types of data such as read values to ensure value determinism in the replay phase.
chen et al.
refer this research is supported in part by the grf of hksar research grants council project nos.
and the hksar itf project no.
its the cityu mf ext project no.
the cityu srg project nos.
and and the cityu sgs conference grant.
correspondence authorto the proportion of interleavings recorded as the degree of record fidelity and indicate a positive correlation between the degrees of recording fidelity and replay fidelity.
towards the goal of achieving high record fidelity with minimal overhead huang et al.
propose leap which records data at a local level for shared memory locations.
this strategy reduces the record runtime overhead by 10x compared to the prior local order and global order based techniques.
zhou et al.
propose stride a relaxed recording technique which reduces the need of synchronization whilst recording interleaving orders and achieves a .5x improvement in runtime overhead as well as a .8x reduction in record log sizes compared to leap .
liu et al.
also propose light which achieves a 10x reduction in record log sizes compared to stride.
however due to its recording strategy light may fail to reproduce correct output for serialized write events to output devices involving multiple shared memory locations.
also its replay phase enforces a global order on an execution which increases replay runtime overhead and reduces concurrency.
aggreplay compresses some interleavings during the record phase using a read vector.
it then assigns threadlocal scheduling constraints during the replay phase improving replay concurrency.
however it suffers higher record overhead compared to light.
a desirable attribute of a deterministic replay technique is to minimize the impact of high record fidelity whilst ensuring deterministic replay.
we propose our technique based on the following insight during a program execution several interleavings may be observed between events executed by different threads on shared memory locations.
however there are usually few to no atomicity violations which means a thread accesses a shared memory location in an atomic region at the same time as another thread reported during a program execution.
therefore modeling the sequence of events of each thread as a sequence of transactions enables the application of transactional attributes and conditions to the events executed in the program.
in this paper we present tpla y a novel deterministic replay technique which segregates the sequence of events of each thread into a sequence of transactions.
during the record phase tpla y creates a new transaction on each thread s first 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
write event or on any write event preceded by a read event.
consider a scenario where two transactions tr1and tr2are created by threads t1and t2respectively.
suppose that all interleavings between tr1and tr2are in the form e squigglerighte where e tr1and e tr2 may be reduced to a single interleaving recorded as tr1 squigglerighttr2.
this reduces the record log whilst preserving record fidelity.
during replay the two transactions tr1and tr2can be executed sequentially preserving all interleavings between the two threads.
however to ensure deterministic interleaving reproduction at a transactional level the atomicity of each transaction must be ascertained.
we apply an existing transactional atomicity checker during the record phase.
for transactions whose atomicity is violated we propose a solution which we illustrate as follows suppose angbracketlefte1 e4 angbracketright tr1and angbracketlefte2 e3 angbracketright tr2and the trace is angbracketlefte1 e2 e3 e4 angbracketright.
tpla y records tr1 squigglerighttr2based on the interleaving e1 squigglerighte2.
then on the interleaving e3 squigglerighte4 a n atomicity violation is reported on tr1.
tpla y removes the transactional interleaving tr1 squigglerighttr2and records the interleaving tr2 squigglerighte4.h o w e v e r a sa te v e n t e4 no information about the interleaving e1 squigglerighte2is known.
to preserve any previous interleavings the immediate preceding event of e4in the same transaction i.e.
e1 is ordered before tr2 creating the artificial interleaving e1 squigglerighttr2which is recorded by tpla y .
this preserves all interleaving orders in the presence of an atomicity violation on any transaction.
during the replay phase tpla y replays a program using transactional level interleavings if no atomicity violation was reported during the record phase.
otherwise the generated interleavings are used in preserving the observed atomicity violations.
for the trace in our example tpla y enforces the replay constraints tr2 squigglerighte4and e1 squigglerighttr2during replay due to the atomicity violation.
to evaluate the performance of tpla y we answer the following questions using our experimental results rq1 can tpla y achieve smaller overheads compared to an existing technique in the record phase?
tplay s recording strategy results in an average of .44mb in record log size compared to an average of .20mb for light .
rq2 does tpla y achieve a small runtime overhead in the replay phase?
tplay s replay strategy does not enforce a global ordering of events on all threads.
this results in a significant decrease in replay runtime overhead especially.
our results indicate that tplay s replay phase executes at of the record phase runtime.
rq3 does tpla y exhibit high replay fidelity?
tplay reproduces the program state of benchmarks with a probability of .
.
our main contributions are as follows we present a novel deterministic replay technique which models the event sequence of each thread as a sequence of transactions then records interleavings between the transactions to reduce record log sizes.
we present an algorithm which preserves the original event interleavings during a transactional atomicty violation by generating an artificial pair of interleavings.
we show the feasibility of tpla y by implementing it as a tool and evaluate tpla y through an experiment.
the rest of the paper is organized as follows.
section ii outlines preliminary information.
section iii describes a motivating example used in presenting our technique.
section iv details our algorithm while section v contains evaluation and experimental results.
section vi discusses the related work.
finally section vii concludes the paper.
ii.
p reliminaries this section details the preliminary information used in this paper.
t able i preliminary informa tion operation op w x r x acq m rel m fork u join u x memory location m lock u thread event e angbracketleftt op angbracketright t thread op operation execution trace angbracketlefte1 e2 e3 ... en angbracketright ei event a. execution trace an execution trace angbracketlefte1 e2 ... en angbracketrightis a sequence of events observed from the execution of a program.
an event e represents one of the following t.r x a read instruction executed by thread ton memory location x. t.w x a write instruction executed by thread ton memory location x. t.acq m a lock acquisition instruction executed by thread ton lock m. t.rel m a lock release instruction by thread ton lock m. t.fork u thread tforks another thread u. t.join u thread tjoins another thread u. other synchronization primitives such as wait signal and barrier are also considered by our algorithm and follow procedures similar to the synchronization primitives above as show by table i. we omit them for brevity.
b. interleaving an interleaving squiggleright is defined as the order by which different threads access shared memory objects.
three types of interleavings may be observed in an execution write write two threads perform write events consecutively on some shared object.
write read a thread performs a write event followed by a read event by some other thread.
read write a thread performs a read event followed by a write event by some other thread.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
running example an execution trace 1of a multi threaded program with three threads t1t2 and t3.
dashed arrows represent the global trace 1 c. transactions regiontrack defines transactions as a sequence of events executed by a thread tin between of a matching pair of events begin t l and end t l as a regular transaction tx angbracketleftbegin t l ... ex ... end t l angbracketright where begin t l and end t l denote the beginning and the ending of an atomic region l and ex tx.
we adapt their idea to formulate our notion of a transaction and transactional atomicity violation or atomicity violation for short as follows.
definition .
transaction .
a transaction is a sequence of events executed by a thread trepresented by tr angbracketleftbegin t l ... ex ... end t l angbracketrightwhere begin t l refers to an event eiwhich satisfies the following three conditions eiis a write event.
there is either an immediate preceding read event e i or no event ei 1exists.
ei ei t. thread t s execution trace .
also end t l is a either read event ejin twhich immediately precedes a write event ej in tor the last event in t. definition .
atransactional interleaving ti squigglerighttris such that if ei squigglerightejand ei tr1and ej tr2 then tr1 squigglerighttrtr2.
definition .
happens before relation the happens before hb relation for a trace is the smallest transitively closed relation over the events in such that the relation a bholds whenever aoccurs before bin and one of the following holds program order the two operations are performed by the same thread.
locking the two events acquire or release the same lock.
fork join one events is t.fork u ort.join u and the other events is by thread u. fig.
.
illustration of tpla y record phase on 1. dashed arrows represent transaction level interleavings and double compound arrows represents event level interleavings.
for events a b c i fa band b c then a c. d. transactional atomicity violation each thread maintains a vector clock vc under regiontrack and assigns a vc to each transaction created by the thread.
regiontrack captures hb relations across threadsby performing a join operation on the vcs of threads during an hb event.
when an hb relation is captured the vc of the current thread is updated via a join operation.
given two events e iand ejwhere ei arrowtailrightejand ej tx regiontrack will report an atomicity violation on txif the vc of tx.begin the vc of ei.
e. read count v ector clocks a read count rc vector clock a variation of lamport s vector clock is a tuple of values where each value which tracks the number of read events of the correspondingthread in an execution trace.
an rc vector clock maintains a count of a thread s read events to a shared memory location in the form of rc t where trepresents the current thread.
iii.
m otiv a ting example we present a running example to motivate our work.
fig.
shows an execution trace 1of a multi threaded program with three threads t1 t2and t3 write and read events labeled as e1toe14 and two shared memory locations xand y. in fig.
t1executes a write then two reads e2and e3on location x. thread t2then executes a write e4onythen two reads e5and e6on location x. thread t3then executes a write e7onx then a write e8ony followed by two reads e9and e10toyand xrespectively.
thread t2executes two reads e11and e12toy and xrespectively.
thread t1then executes a write on ythen executes e14 which is a read on y. an existing technique light records inter thread flow dependencies write read interleavings .
for 1 light records the set e1 squigglerighte5 e8 squigglerighte11 e7 squigglerighte12 and passes them as constraints to a constraint solver to generate a feasible trace.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to enforce intra thread access orders light also encodes the constraints e1 squigglerighte2 e2 squigglerighte3 e3 squigglerighte13 e13 squigglerighte14 e4 squigglerighte5 e5 squigglerighte6 e6 squigglerighte11 e11 squigglerighte12 e7 squigglerighte8 e8 squigglerighte9 e9 squigglerighte10as constraints in the constraint solver.
as such light records a total inter thread interleavings and intra thread interleavings for 1. one main drawback of light is that it may fail to reproduce a serialized sequence of writes to an external device involving multiple shared memory locations.
as an example the interleaving e4 squigglerighte8may be e8 squigglerighte4in some trace prime .light is also limited by the capacity of constraint solvers to generate traces.
tpla y reproduces the program state by enforcing writewrite read write and write read interleavings in 1at a transactional level.
we discuss tpla y in detail in the next section.
iv .
tpla y a lgorithm in this section we present tpla y .
the algorithms are implemented as callback functions which are triggered on the execution of specific events.
the following notations are used in algorithms and represents a null instruction.
represents an empty set.
dset t the set of interleavings for thread t. rwset t the set of read write interleavings for thread t. aset t the set of artificial interleavings for thread t. bset t the set of event interleavings for thread t. trid t current transaction id for thread t. lwx last write operation to a shared memory location x. t last instruction type for thread t. lm last lock operation on lock m. tid e executing thread of operation e. lock e lock object acquired in operation e. var e shared object being accessed by operation e. rc t the rc vector clock for thread t. execute e the operation for event eis executed.
t.yield the executing thread twaits for other threads to advance without blocking.
pop removes data from the first index position of a data structure.
first represents data in the first index position of a data structure.
sinkthread the thread which performs the second event in an interleaving.
sourcethread the thread which performs the first event in an interleaving.
a. record phase during the record phase a modified version of regiontrack rt m is used to create transactions and track hb relations across threads.
when an interleaving is detected tpla y retrieves the transactional information of the interleaving events from rt mand records a transactional interleaving ti in dset .
when an atomicity violation over two events is reported by rt m tpla y removes any recorded ti associated with thetwo events then generates two event access orders which are stored in two different sets aset and bset .
the tpla y record phase is presented in algorithm .
lines initialize the rc vector clock of thread tto rwset t aset t bset tand dset tto empty trid tto and to for each thread.
during a write access event the transaction count of thread t is incremented by if no previous instruction exists or there is a read for t line .
the write operation is executed at line .
if the last write to the shared memory location was performed by some other thread t the last write made up of t and the trid t is ordered before the current write event and appended todset t lines .
this also eliminates thread local orderings which are inherently deterministic.
then the last write for the shared memory location is updated using tand trid tat line .
line records any read write interleavings in which the write event is involved and updates the last instruction type for thread t. for each read access event the index for the current thread in its rc vector clock is incremented by and the read operation is executed at line .
if the last write to the shared memory location was performed by some other thread t the last write is ordered before the current read event and appended todset t lines .
line updates the last instruction type for thread t. on lock acquisition the lock operation is executed at line .
if the last lock access to some lock object mwas performed by some other thread t lmis ordered before the current synchronization event and appended to dset t lines .
the last lock access to the shared object is updated at line .
the function recordrw lines is invoked at line in the onwrite function.
this function retrieves the read count values for every other thread in the set of threads line .
the updated rc vector clock for thread tand the current write event are appended as a triple to rwset t line .
lines detail the action taken when an atomicity violation is detected by rt m. if the executing thread s id and current transaction id exist in the dset of the last thread tto access the shared object refrenced by e the record is removed lines .
then at line angbracketlefttid e e prime t tr angbracketrightis recorded in aset twith e being the preceding event of ein tid e .
finally angbracketleftbig t tr tid e trid tid e angbracketrightbig is appended to bset tid e .
algorithm produces a record log which consists of aset rwset bset and dset.
fig.
illustrates the tpla y record scheme for 1.o ne v e n t e1 a transaction tr1is created by t1.lwxis also updated with the pair angbracketleftt1 tr1 angbracketright.
events e2and e3each increments rc t1 b y .
on e4 a transaction tr2is created by t2.lwyis also updated with the pair angbracketleftt2 tr2 angbracketright.r c t2is updated using rc t1and rc t3 and angbracketleftrct2 t2 tr2 angbracketrightis appended to rwset t2.events e5and e6 each increments rc t2 b y1 .f o r e5 lwxis retrieved and the interleaving angbracketleftt1 tr1 t2 tr2 angbracketrightis appended to dset t2.o n e6 angbracketleftt1 tr1 t2 tr2 angbracketrightis not recorded since it already exists in dset t2.
on event e7 a transaction tr3is created by t3.lwxis also updated with the pair angbracketleftt3 tr3 angbracketright.r c t3is updated using rc t1 and rc t2.
the triple angbracketleftrct3 t3 tr3 angbracketrightis recorded in rwset t3.
on e8 lwyis retrieved and the interleaving angbracketleftt2 tr2 t3 tr3 angbracketright authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is appended to dset t3.l w yis then updated with the pair angbracketleftt3 tr3 angbracketright.
however angbracketleftrct3 t3 tr3 angbracketrightis not recorded on e8since the values in rc t3have not changed.
events e9and e10each increments rc t3 by .
an atomicity violation is reported one11fortr2.
since an interleaving with the pair angbracketleftt2 tr2 angbracketright exists in dset t3 the interleaving is removed and an artificial interleaving angbracketleftt2 e6 t3 tr3 angbracketrightis then appended to aset t3.this ensures that tr2will be paused until e6has been executed to reproduce the atomicity violation on tr2.
then the interleaving angbracketleftt3 tr3 t2 e11 angbracketrightis appended to bset t2.
on event e13 t1creates transaction tr4.lwxis also updated with the pair angbracketleftt1 tr4 angbracketright.r c t1 is updated using rc t2and rc t3.
the triple angbracketleftrct1 t1 tr4 angbracketrightis recorded in rwset t1.
event e14finally increments rc t1 b y .
tpla y produces dset 1 angbracketleftt1 tr1 t2 tr2 angbracketright bset 1 angbracketleftt3 tr3 t2 e11 angbracketright aset 1 angbracketleftt2 e6 t3 tr3 angbracketright rwset 1 angbracketleft t2 t2 tr2 angbracketright angbracketleft t3 t3 tr3 angbracketright angbracketleft t1 t1 tr4 angbracketright as the record log for trace 1. b. replay phase during the replay phase rt mis used to create transactions only.
tpla y divides the record log into constraint sets based on the sinkthread in each interleaving.
each thread is assigned a set in the form aset t rwset t bset tand dset t .
the constraint set is treated as a stack where only the first record in each data structure is used in evaluating the current event.
when a record is successfully used in evaluating an event the record is popped out of the stack.
the tpla y replay phase is shown in algorithm .
the record log aset rwset bset and dset is used as input to replay callback functions.
lines initialize rc vector clock to trid tto and to for each thread respectively.
for each write event the checkevent and checkav functions are called on line to ensure that the current event is not involved in some atomicity violation.
the current operation is aborted if read write conditions are not satisfied line .
if the thread s dset tid e is not empty and the current transaction id of the thread is lower than the sink transaction id of the topmost record in dset tid e the write event is executed lines .
this means each sinkthread can execute up until its first transaction involved in an interleaving.
also if the thread s dset tid e is not empty and the current transaction id of the sourcethread is greater than or equal to the source transaction id of the topmost record in dset tid e this means the interleavings has been fulfilled.
the topmost record is popped out of dset tid e and the write event is executed.
lines .
when neither of the two previous conditions are met at lines and the thread waits without blocking other threads at line .
at lines and the transaction id for the thread is incremented if the last event for the thread is either a read event or a null event.
the write event is executed and the last instruction for the thread is updated at line .
on handling read events on line the two functions checkevent and checkav are called to ensure that the current event is not involved in some atomicity violation.
lines update the rc vector clock of tid e execute the readalgorithm tplay record algorithm t thread do rc t t trid t dset t rwset t aset t bset t onwrite event e do if tid e read trid t execute e if tid lw var e negationslash tid e dset t angbracketleftbig tid lwe lwe tid e trid tid e angbracketrightbig lw e angbracketleftbig tid e trid tid e angbracketrightbig recordrw tid e e tid e write onwrite onread event e do rc tid e execute e if tid lw e negationslash tid e dset t angbracketleftbig tid lwe lwe tid e trid tid e angbracketrightbig tid e write end onread onlockacquire event e execute e m v a r e if tid l m negationslash tid e dset t angbracketleftbig tid lm lm tid e trid tid e angbracketrightbig l m angbracketleftbig tid e trid tid e angbracketrightbig end onlockacquire recordrw thread t event e do t thread do rc t rc t rwset t angbracketleftbig rct tid e trid tid e angbracketrightbig end recordrw onatomicityviolation event e lvar e lwvar e t tid tr .trid if angbracketleftbig tid e trid tid e angbracketrightbig dset t dset t dset t angbracketleftbig tid e trid tid e t tr angbracketrightbig aset t angbracketlefttid e e prime t tr angbracketright bset tid e angbracketleftbig t tr tid e trid tid e angbracketrightbig end onatomicityviolation event and update the last instruction of the thread with a read instruction.
lock access events follow a similar replay strategy to read and write events.
if the current transaction id for tid e is less than the topmost transaction id in dset tid e the lock operation is executed lines .
otherwise if the sourcethread involved in the dependency has a trid t greater than or equal to the transaction id from dset tid e the lock operation is executed line and the topmost record in dset tid e is removed since the interleaving constraint has been satisfied at line .
the thread waits without blocking other threads at line if the conditions on lines and are not satisfied.
the checkrw lines function is invoked at line in the onwrite function.
this function retrieves the read count values for every other thread in the thread set thread and updates the rc vector clock of t line .
line iterates authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm the tplay replay algorithm t thread do rc t t trid t onwrite event e do checkevent checkav if !checkrw tid e e tid e .yield if dset tid e contains records rec dset tid e .first if trid tid e rec.
trid tid e skip to line else if trid t rec.trid t dset tid e .pop skip to line else tid e .yield if tid e read trid tid e execute e tid e write end onwrite onread event e do checkevent checkav rc tid e execute e tid e read end onread onlockacquire event e rec dset tid e .first if trid tid e rec.
trid tid e execute e else if trid t rec.trid t execute e dset tid e .pop else tid e .yield end onlockacquire checkrw thread t event e do t thread do rc t rc t t thread do if rc t rwset t .rc t return false rwset t.pop return true end checkrw checkevent event e do rec bset tid e .first if etid e rec.
e execute e else if trid t rec.trid t execute e bset tid e .pop else tid e .yield end checkevent checkav event e do rec bset tid e .first if trid tid e rec.
trid execute e else if et rec.e execute e aset tid e .pop else tid e .yield end checkeventover rc tand returns false if each thread s current read count value is less than the recorded value in rwset t. or else the interleaving is satisfied and removed from rwset tat line .
the checkevent function ensures that the sinkthread blocks prior to an event which is involved in an atomicity violation.
lines ensure thread execution until the the event in the topmost record in bset tid e has been executed.
alternatively line checks if the sourcethread s transaction id is greater than the recorded transaction id in bset tid e .
if the condition is satisfied the event is executed and the interleaving is removed from bset tid e at line .
when both conditions are not met the thread identifying by tid e waits without blocking other threads at line .
the checkav function ensures the artificial interleaving is enforced by the source thread.
lines ensure thread execution until the event in the topmost record in aset tid e .
otherwise line checks if the source thread s current event is greater than the recorded event.
if the condition on line is satisfied the event is executed and the interleaving is removed from bset tid e at line .
otherwise tid e waits without blocking other threads at line .
the trace 1is replayed as follows during the replay phase t1creates tr1with event e1in the abscence of any interleaving constraint involving tr1.
events e2and e3are executed and each event increments rc t1 by .
then t3 attempts to create tr3but fails since there are two constraints ontr3 angbracketleftt2 e6 t3 tr3 angbracketright and angbracketleft t3 t3 tr3 angbracketright not yet satisfied.
t1then attempts to create tr4and t1fails due to the interleaving angbracketleft t1 t1 tr4 angbracketright not yet satisfied.
t2then proceeds to create tr2since the constraints angbracketleftt1 tr1 t2 tr2 angbracketright and angbracketleft t2 t2 tr2 angbracketright are satisfied.
t2executes e5and e6 and updates rc t2 .t2pauses at e11due to the interleaving angbracketleftt2 e6 t3 tr3 angbracketright not yet satisfied.
t3proceeds to create tr3and executes events e7and e8.
events e9and e10each increments rc t3 b y1 .
t2then executes e11and e12 reproducing the atomicity violation on tr2.
finally t1creates tr4and executes e13and e14.
c. thread abstraction matching algorithms and present the thread abstraction process in the record phase and subsequent matching process in the replay phase using the following notations ostid t system assigned value for thread t. opstid t system assigned value for parent thread of thread t. ptid t the id of the parent thread of thread t. data structure mapping opstid ttoostid t. tlog set of thread abstractions.
data structure mapping each replay thread to its current number of children threads.
data structure mapping replay threads to threads from tlog.
at line of algorithm and tlog are initialized as empty structures.
on thread creation a value pair made up of the system assigned value and the thread id is appended to line .
for all threads with the exception of the main thread a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
value pair made up of the thread id and its parent thread id is appended to the set of thread abstractions tlog at line .
algorithm tplay thread abstraction algorithm tlog onthreadcreate thread t do angbracketleftostidt tidt angbracketright if tid t negationslash tlog angbracketlefttidt angbracketright end onthreadcreate for fig.
the resulting thread abstraction set is angbracketleft1 angbracketright angbracketleft2 angbracketright angbracketleft3 angbracketright .
algorithm tplay thread matching algorithm tlog onthreadcreate thread t do angbracketleftostidt t angbracketright if tid t angbracketleft0 angbracketright else freq parent childfreq angbracketlefta b angbracketright tlog if b parent freq childfreq angbracketleftt a angbracketright break elseif b parent freq negationslash replayfreq freq end onthreadcreate algorithm presents the thread matching algorithm in the replay phase.
tlog is used as an input to the thread matching algorithm.
data structures and are all initialized as empty sets at line .
on thread creation the system assigned value and the thread id pair is appended to at line .
if the thread is the main thread the pair angbracketleft0 angbracketrightis appended to line .the main thread in each execution is always assigned with id .
otherwise the number of children threads for the current thread s parent is incremented by at line .
then we iterate over each thread abstraction in tlog lines .
if the second value b of a thread abstraction matches a parent thread and the parent thread s freq value matches the value of childfreq the current thread id and the first value a of the matching abstraction is appended to lines .
otherwise the freq value is incremented by at line when the thread abstraction is parent thread is matched but the child frequency is not.
v. e v alua tion a. execution environment our hardware setup consisted of a dell poweredge r930 running the dell customized image esxi .
.
update a01.
our experiments were conducted on a bit virtual machine running the guest os ubuntu .
linux with 8t able ii execution met ada t a for benchmarks used in our experiment .
benchmarks of events read write lock cholesky fft lu cb lu ncb ocean cp ocean ncp raytrace radiosity radix volrend water nsquared water spatial barnes mysql intel xeon r cpu e7 v3 .20ghz processors and 16gb of ram.
we have implemented tpla y and light using intel pin version .
.
to be specific for each tool we implemented two separate pintools for the record and replay phases respectively.
in the case of light we followed the implementation in the paper using a solver for the integer difference logic theory in z3 .
the record implementation of light is publicly available without the replay phase and constraint solver and can only handle java applications.
our benchmarks were run on c c programs with the pthread standard.
this made direct comparison difficult.
a precaution taken was to test the correctness of our implementation of light on a small benchmark we developed prior to our experiments.
we also used code inspection on our implementations.
b. benchmarks we evaluated our implementation using benchmarks from the splash2x extension of the p arsec .
benchmark suite specifically barnes ocean cp radiosity raytrace volrend water spatial water nsquared water spatial as well as kernel applications cholesky fft lu cb lu ncb radix and mysql .
we selected the splash2x extension of p arsec for its focus on concurrent computation on parallel machines.
table ii details the number of read write and lock acquisition events in each program under the experiment configuration.
c. methodology we ran each benchmark in the native configuration to establish native execution runtime.
we reported this as the base time in our experiment results.
each splash2x benchmark program was configured with worker threads with the gcc pthreads configuration option and the test input workload.
this configuration provided each program adequate concurrency and input.
the input for mysql was mysql bug .
record and replay setup for our record phase each thread kept a local instruction counter and incremented it by for each instruction executed.
each thread also kept a vector authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able iii experiment al resul ts on record phase of tpla y and light .
benchmark application domainlog size mb base time s normalized slowdown tplay light light tplay cholesky hpc .
.
.
.
fft signal processing .
.
.
.
lu cb hpc .
.
.
lu ncb hpc .
.
.
.
ocean cp hpc .
.
.
ocean ncp hpc .
.
.
.
raytrace graphics .
.
.
radiosity graphics .
.
.
.
radix general .
.
.
volrend graphics .
.
.
water nsquared hpc .
.
.
.
water spatial hpc .
.
.
.
barnes hpc .
.
mysql database application .
.
.
.
mean .
.
.
.
t able iv record phase data f o r tpla y and light .
ti refers to transactional interlea vings .a v refers to atomicity viola tions .t he v alues marked with represent the interlea ving set sizes not sol ved by z .
benchmark of transactions o ft i a v of light w r interleavings cholesky fft lu cb lu ncb ocean cp ocean ncp raytrace radiosity radix volrend water nsquared water spatial barnes mysql mean clock to track reads by other threads as well as a transaction counter which was incremented for every transaction created by the thread.
for all shared memory locations we maintained a data structure to store data on the last access to each shared memory location.
we also kept a global map of each memory address with its associated data structure which is write protected by a single lock during initial creation and storage of the data structure.
however for subsequent access to each memory address index in the map we maintained a set of 210locks which were acquired via a hash function similar to light .
for read events we configured each thread to keep track of its read accesses to shared memory locations and made this data structure accessible to other threads.
we protected access to this data structure by assigning each thread its own lock.
throughout the record phase tpla y was configured to keep all recorded data in memory until the program exited or was terminated.
apart from read write interleavings we stored each interleaving regardless of interleaving type in the format angbracketlefta b c d angbracketrightwhere a b cand drepresented the sourcethread id the transaction event id executed by the sourcthread sink thread id and transaction event id executed by the sinkthread respectively.
a thread id was typically a bit integer whereas an event transaction id was a bit unsigned integer.
readwrite interleavings were stored in the format angbracketleftrc a b angbracketrightwhere rc represented a vector of read aggregate values from all threads and aand brepresent the sink thread id and sink transaction event id respectively.
we recorded time spent total processor clock ticks for each run using the clock function1.
the time spent for each tool is calculated by recording the value returned by the clock function at the beginning and at the end of each run.
the normalized slowdown difference between tpla y and light was calculated using the following formula time spent for light time spent for tplay and is shown in column of table iii.
during the replay phase each thread created during the replay phase was matched to a record phase thread using our thread matching algorithm i.e.
algorithm and each thread only kept a record of interleavings within which it served as a sinkthread.
during replay we maintained an 1man7.org linux man pages man3 clock.
.html authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
instruction counter transaction counter for each thread.
to ensure optimal concurrency each thread was configured to evaluate the interleaving constraint without synchronization.
this meant for every interleaving angbracketlefta b c d angbracketright the sinkthread c only had to check if the sourcethread a s current transaction id was greater than the recorded transaction id b. this ensured that the sourcethread was not blocked until the interleaving was confirmed by the sinkthread.
the artificial interleavings created on atomicity violations were evaluated in the same manner.
each interleaving was removed from the data structures once it was satisfied.
tpla y relinquished control of the program execution to the system scheduler when all interleavings were satisfied.
we recorded each interleaving for light in the format angbracketlefta b c d angbracketrightwhere a b cand drepresent the source thread id the source event id sink thread id and sink event id respectively.
our implementation of tpla y in the pin framework is available online2.
d. constraint solving approach to benchmark the light replay technique the z3 constraint solver was used with write read interleavings from the light record phase as inputs.
we did this in accordance with the steps stated in .
a constraint solver accepts as input a set of statements which are encoded as constraints.
in our experiments we implemented a constraint solver using the z3py library version .
.
of z3 theorem solver for python programming.
we present an example of the constraint solving approach as follows fig.
.
running example an execution trace of a multi threaded program with threads t1t2 t3.
dashed arrows represent the global trace 2 the trace 2 angbracketlefte1 e2 e3 e4 e5 e6 e7 e8 e9 angbracketrightrepresents the execution shown in fig.
.
the interleavings produced from 2are e1 squigglerighte3 e3 squigglerighte4 e2 squigglerighte5 e6 squigglerighte7 e6 squigglerighte8 e8 squigglerighte9 and e7 squigglerighte9.
light records the inter thread interleavings e3 squigglerighte4 e6 squigglerighte7ande6 squigglerighte8.
we encode each interleaving for the constraint solver in the form a b c d where a b cand 2github.com testrepo007 tplaydrepresent the thread id from the write event the event id for the interleaving write event the thread id for the read event and the event id for the interleaving read event respectively.
the set of write read interleavings for 2is encoded as .
the constraint solver also accepts the intra thread interleaving constraints .
the execution schedules e1 e2 e3 e4 e5 e6 e7 e8 e9 and e2 e1 e3 e4 e6 e5 e7 e8 e9 may be generated by the constraint solver.
our z3py code for the constraint solver is available online3.
e. record phase results table iii details our experimental results for the record phase.
the first two columns detail the benchmarks and their respective application domains.
the next two columns show the record log sizes for tpla y and light in megabytes.
base time represents the native runtime for each benchmark in seconds.
column of table iii shows the difference in time spent between tpla y and light.
on average light achieves of runtime overhead of tpla y because tpla y incurs runtime cost in creating and maintaining transaction data structures as well as the transaction atomicity checker rt m. our experimental results indicate an average of .44mb which is a fold improvement when compared to light s average of .20mb.
specifically tpla y records a smaller log size for out of programs.
light experiences a slight gain for mysql which does not produce enough transactions to highlight the efficiency of tpla y .
table iv shows the results on trace reduction for tpla y and light.
column shows the number of transactions created by tpla y for each program execution.
column shows the number of transactional interleavings whilst column shows the number of atomicity violations reported for each program execution.
finally column shows the interleavings recorded by light.
we also compare the number of transactional interleavings with the number of write read interleavings recorded by light.
table iv shows a fold improvement in trace reduction by tpla y over light.
atomicity violations were reported for two benchmarks volrend and radiosity .for each atomicity violation reported tpla y created a pair of interleavings one interleaving was stored for the sourcethread in aset and another was saved for the sinkthread in bset .
no atomicity violations are reported for out of benchmarks thereby confirming our insight.
this also means that these benchmarks could be replayed exclusively at the transactional level.
f .
replay phase results table v presents the experimental results on replay phases for tpla y .
a successful replay run for tpla y in our 3github.com testrepo007 constraint solver authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able v experiment al resul ts for repla y phase .
benchmarknormalized slowdown successful executions replay probabilitytplay light cholesky .
fft .
lu cb .
lu ncb .
ocean cp .
ocean ncp .
raytrace .
radiosity .
radix .
volrend .
water nsquared .
water spatial .
barnes .
mysql .
.
mean .
.
.
.
experiment was the reproduction of interleavings observed in the record phase and the program output.
a successful replay for light was the reproduction of write read interleavings for a program.
each subject program was run times.
recall that light employs a constraint solver in generating possible schedules for replay.
however in our experiment we found the constraint solver strategy to be limited in constructing feasible schedules due to the high number of writeread interleavings generated for our benchmarks.
column of table iv shows the number of inter thread write read interleavings recorded by light.
with the exception of mysql possible traces the constraint solver did not return any output even after several hours of constraint solving.
for mysql light succeeded in reproducing correct interleavings of the time.
the time spent for each tool in the replay phase was calculated in a manner similar to the record phase see paragraph of subscetion c of section v .
the normalized runtime for each tool in the replay phase is calculated as the time spent for tool in replay phase time spent for tool in record phase .
the results are presented in columns and of of table v .
tpla y s replay phase is able to execute at of its record phase on average.
on average tpla y replays programs with a .
probability with a mean of .
successful executions out of executions.
for cholesky and ocean ncp tpla y fails to achieve probability due to the program outputs being different from that observed in the record phase.
g. threats to v alidity the ability of the tplay tool in the experiment to report atomicity violations was dependent on the algorithm in .
our implementation of light and tpla y was also subject to inherent binary instrumentation limitations of pin.
also the constraint solver was developed using the python library of z3 z3py .
another way of encoding constraints or other constraint solvers may make light able to produce thread 4github.com z3prover z3schedules for its replay phase.
tpla y may also suffer overheads in the record phase mainly during the creation and maintainance of data structures for transactions.
threads not previously encountered in the record phase but observed in the replay phase may not be handled by tpla y .
vi.
r ela ted work there are many existing deterministic replay techniques such as samsara and odr that are implemented for c c applications based on the pthread execution model.
tpla y follows a similar implementation style to these techniques.
some recent techniques such as doubletake conduct record and replay in one sinlge phase.
in these techniques an execution is divided into epochs based on either irrevocable system calls or user defined conditions.
the programs state is logged just before each epoch creation and execution and the epoch is analyzed afterwards.
if any error is found in an epoch the program state prior to the epoch is restored and the epoch is replayed to reproduce the error.
otherwise the next epoch is created and executed.
doubletake requires special hardware support whereas tpla y does not.
unlike mobiplay tpla y does not modify the underlying framework to facilitate replay.
aggreplay tracks the number of read accesses by each thread prior to some write event then aggregates these numbers of read accesses by all threads in a read vector.
the read vector is then associated with the write event.
aggreplay however incurs higher overheads in the record phase compared to tpla y by recording all interleaving sets.
checkpointing is often used in replay techniques.
ireplayer stores the system state in memory and enables usercustomizable checkpointing rules.
ireplayer acheives small log sizes by not monitoring data races during record.
it may report them in the replay phase by iteratively replaying an epoch if there is a divergence from the thread interleavings observed during replay and the recorded thread interleavings.
tpla y does not use checkpointing and replays data races without iteration.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
processor oblivious record and replay focuses on recording the synchronization order for programs which employ task parallelism.
such programs do not have any notion of threads or data and are inherently data race free e.g.
cilk programs.
however current mainstream software supports multi threaded parallelism.
tpla y is applicable to most mainstream software.
recording write read interleavings has been explored by existing work.
light records inter thread and intrathread write read interleavings and uses a constraint solver to generate feasible execution schedules with the interleavings as constraints.
tpla y records write read interleavings at a transactional level and does not require any constraint solver.
minimizing record impact on runtime overhead via thread local data storage has been explored by existing work clap which relies on constraint solving to generate execution schedules.
care maintains thread local caches for shared memory locations records cache missed write read interleavings but does not record write read interleavings if the interleaving results in a cache hit.
care records exact readwrite interleavings unlike tpla y .
some existing techniques focus on trace reduction strategies.
netzer has proposed an adaptive tracing strategy which records the minimal amount of data required to replay a specific race condition.
this is achieved by optimizing transitively implied inter thread dependencies similar to light.
tpla y by default does not record interleavings at the event level.
xu et al.
proposes a regulated transitive reduction algorithm which improves netzer s trace reduction technique by generating artificial dependencies on inter thread dependencies.
tpla y generates artificial dependencies but only when an atomicity violation is reported on an event within a transaction.
octet avoids creating thread interleavings by associating each shared object with a thread local state variable and a mechanism based on the concurrent read exclusive write strategy.
tpla y reduces thread interleavings by executing threads instructions as atomic code regions and recording interleavings on these atomic regions.
existing replay techniques like stride include a search process and attempt to re construct the missing interleavings before generating a trace with the targeting output in its replay phase.
bbr uses a predefined set of location checkpoints to minimize record log sizes as well as a symbolic execution based search process to generate feasible traces involving the checkpoints.
tpla y does not rely on a search process symbolic execution nor any offline phase.similar to stride odr aims to reproduce a specific program output by extracting some execution trace data from a core dump and generating a trace through a search process.
deterministic replay is applied in other fields of discipline.
deter is a deterministic replay tool used in recording transmission control protocol tcp packets to reproduce communication network states.
tpla y does not focus on replay of communication networks.vii.
c onclusion existing deterministic replay techniques proposed strategies which attempt to reduce record log sizes and achieve successful replay.
however these techniques still generate large logs and and achieve replay only under certain conditions.
we have proposed a solution based on the division of the sequence of events of each thread into sequential blocks called transactions.
our insight is that there are usually few to no atomicity violations among transactions reported during a program execution.
we have presented tpla y a novel deterministic replay technique which records thread access interleavings on shared memory locations at the transactional level.
tpla y also generates an artificial pair of interleavings when an atomicity violation is reported on a transaction.
we present an experiment using the splash2x extension of the p arsec benchmark suite.
experimental results have indicated that on average tpla y experienced a fold improvement in record log sizes and achieved a high replay probability.
future work includes solving the problem of high runtime overhead in the record phase for tpla y .