hercules reproducing crashes in real world application binaries van thuan pham wei boon ng konstantin rubinov abhik roychoudhury school of computing national university of singapore singapore email thuanpv comp.nus.edu.sg noodiew1 yahoo.com.sg rubinov comp.nus.edu.sg abhik comp.nus.edu.sg abstract binary analysis is a well investigated area in software engineering and security.
given real world program binaries generating test inputs which cause the binaries to crash is crucial.
generation of crashing inputs has many applications including off line analysis of software prior to deployment or online analysis of software patches as they are inserted.
in this work we present a method for generating inputs which reach a given potentially crashing location.
such potentially crashing locations can be found by a separate static analysis or by gleaning crash reports submitted by internal external users and serve as the input to our method.
the test input generated by our method serves as a witness of the crash.
our method is particularly suited for binaries of programs which take in complex structured inputs.
experiments on real life applications such as the adobe reader and the windows media player demonstrate that our hercules tool built on selective symbolic execution engine s2e can generate crashing inputs within few hours where symbolic approaches as embodied by s2e or blackbox fuzzing approaches as embodied by the commercial tool peachfuzzer failed.
i. i ntroduction complex software systems are released and deployed with faults.
some faults trigger application crashes that elevate system security risks and are difficult to trace analyze and reproduce.
the problem of finding crashing paths has been addressed by previous research however few techniques cope with large real world binaries.
real world binaries present challenges for program analysis techniques due to their size complexity and multitude and depths of execution paths.
in addition the information about structure of programs in a stripped binary is incomplete when collected statically while recovering such information dynamically is often infeasible.
reproducing crashes in multi module systems requires targeted exploration.
the search space of potential crashing paths is too large to be exhaustively checked path by path for instance using symbolic execution the complexity of program inputs is too high for exhaustive set of inputs to be generated combinatorially or randomly for instance using fuzzing .
the space of program paths is intractable for modern analysis techniques a novel targeted exploration is needed.
given a real world program binary with a crash report our approach hercules tackles the problem of finding program paths and corresponding program inputs that cause a crash in a given program location.
the core idea behind our approach is to systematically detect bound and explore a subset of program paths necessary and sufficient for reaching and triggering a given program crash.
the approach builds upon concolicexploration and propagates a necessary but minimal subset of input data in symbolic form while keeping the remaining input data concrete.
the exploration uses targeted search strategy that helps to explore as few as possible paths while resolving enough information about program structure for finding the crashing path.
our approach works in three main steps figure .
each step progressively more precisely establishes program and input structures that are relevant to reproducing the crash.
the approach starts with a preprocessing step for initial reconstruction of a program structure and selection of input files step followed by two passes of concolic exploration.
application of two passes of concolic exploration is a distinct feature of the approach.
each pass serves different purpose the first pass step establishes a relationship between program input and relevant program structures and provides an input to the second pass step a focussed fine granularity search for a crashing path.
our search strategy infers the reasons for infeasibility of specific non crashing paths thus helping us to avoid exploring large numbers of paths that are non crashing for the same reason and to direct the search towards the paths that will crash the system.
we call our tool and method as hercules largely because of the herculean task of finding crashing inputs it accomplishes in a reasonable time frame.
this is because of smart search heuristics and structuring of the search into phases.
our approach builds upon selective symbolic execution technique s2e extends it and makes a number of technical contributions namely targeted search strategy implements our targeted search algorithm that detects reasons for infeasibility of noncrashing paths and directs concolic execution.
approximation of string functions scales concolic execution by bounding exploration of string manipulation functions that generally cause path explosion.
analysis of loop controlled crash instructions enables automatic synthesis of loop dependent crash conditions.
dynamic module selection adds flexibility to the s2e technique in the process of selective concolic execution our technique allows dynamic selection of program structures for concolic execution state forking .
dynamic cfg refinement .
in addition to the standard s2e functionality our technique builds and dynamically refines program control flow graph cfg and uses it for reachability analysis to inform concolic exploration.test suitetest suiteselected input filespush ebpmov ebp espmov edx esipush edimov esi mov edi static and dynamic analyses idaprobinariescfg and mdg symbolic fileconcolicexplorationand precise tainttrackingcfg and mdg pruned file structure infohybrid symbolic filetargetedconcolicexplorationcrash revealing inputcrash explanation 123crash report!fig.
.
an overview of our approach and hercules tool assumptions the few significant assumptions we make concern availability of a test suite a set of non crashing benign input files testsuite and indication of a crash location cl in a crashing module crashingmodule where execution of at least one test case in testsuite reaches crashingmodule .
we optionally assume availability of a list of modules invoked during crashing execution modulelist call stack and values of the program registers at the moment of crash that form a crash condition cc.
if available the knowledge about input file structure and layout may aid seed file selection and generation of hybrid symbolic inputs.
the required information is external to the approach and can be often produced by a separate static dynamic analysis.
ii.
o verview we illustrate the pertinent aspects of the approach using data from a vulnerability cve in windows media player a buffer overflow that triggers a system crash in a divide by zero exception.
figure shows fragments of information used by our approach in the search for crashing input.
according to the crash report the list of modules involved in crashing behavior contains quartz.dll wmp.dll and a main module wmplayer.exe out of total modules loaded by the program .1the module quartz.dll crashes at the program location 0x74902224 instruction div ecx .
a set of benign inputs does not reach this location.
instep of the approach we reconstruct the structure of a system with static analysis and dynamically by exploring the system with benign input files.
the result of this step is an incomplete program structure incorporating module dependence and control flow information.
step also selects benign inputs that trigger execution in the modules involved in the crash.
for cve step identifies a benign input that reaches the crashing module at an entry point internal function 0x74834010 but does not reach the crash location.
a fragment of the benign file is shown in figure .
instep we use concolic exploration as an apparatus for precise taint tracking and identifying input fragments relevant to reaching the crashing module.
from these data we generate hybrid symbolic inputs that maintain correct input 1we refer to a module to denote an executable file main module and any library it loads while for the entry points of a module we consider both exported and internal functions.
entry point 0x74834010 ... eq w32 0x46464952 concat w32 read w8 0x0 v3 sym byte 3 concat w24 read w8 0x0 v2 sym byte 2 concat w16 read w8 0x0 v1 sym byte 1 read w8 0x0 v0 sym byte 0 constraint eq false eq w32 0x44494d52 concat w32 read w8 0x0 v11 sym byte 11 concat w24 read w8 0x0 v10 sym byte 10 concat w16 read w8 0x0 v9 sym byte 9 read w8 0x0 v8 sym byte 8 ...retaddr module7490232d quartz 0xf222474901d96 quartz 0xf232d... ...748340a2 quartz!dllgetclassobject 0x404c7483df85 quartz!dllgetclassobject 0xa36 ... ...4b70c27a wmp!ordinal3000 0x192844b70c225 wmp!ordinal3000 0xa677d7c80b713 wmp!ordinal3000 0xa6728call stack path constraint at 0x74834010 input filecrashing module quartz.dll....text lpcriticalsection dword ptr .text arg 4 dword ptr 0ch.text arg 8 dword ptr 10h.text mov edi edi.text push ebp.text mov ebp esp...entry point 0x7490220a....text 7490221d shr ebx .text 7490221f add eax ebx.text adc edx .text div ecx.text shld edx eax 10h.text 7490222a pop ebx.text 7490222b pop ebp... eax ebx ecx edx esi edi eip esp 0167f6c0 ebp 0167f6c4 iopl nv up ei pl zr na po nc cs 001b ss ds es fs 003b gs efl 00000246register dump...4d 0b f0 4d mthd......... mt72 6b ff ff rk..... x...... ... 4d 0b mthd ....crash conditiontaint sourcesmodules to analyze taint infocrash locationentry close to crashfig.
.
crash analysis information for cve file structure.2forcve step collects a path constraint with a symbolic version of the benign input.
the path constraint indicates symbolic bytes from the input file that are propagated to the module entry point 0x74834010 arrows between the path constraint and the input file in figure .
these input portions are relevant to reaching crashing module and we mark them symbolic in a hybrid symbolic file.
generation of hybrid symbolic inputs addresses two main issues in symbolic execution for real world program binaries.
first hybrid symbolic inputs prompt less constraint solving in concolic exploration and result in smaller symbolic formulae.
second exploration with structurally correct hybrid inputs has higher chances of bypassing the parser component that incorporates multitude of conditions that cause state explosion in symbolic execution and prevent it from reaching deep program paths.
instep we apply a targeted search strategy second pass of concolic execution to explore the system in a directed fashion systematically eliminating groups of paths from analysis and generate crashing input.
the strategy stems from the observation that groups of non crashing paths often have the same cause for which they do not crash the system.
the main intuition behind our strategy is that we can detect a reason of infeasibility of a certain path and eliminate from consideration in concolic execution groups of paths that do not crash for 2we refer to hybrid symbolic inputs as files containing fragments of symbolic and concrete data in contrast with fully symbolic files that contain only symbolic data.summary x y!
main module module c...module b 2 1crashing modulebranch conditionct x module a pc x y x !tf crashlocationprunedpath prunedpathfig.
.
schematic module dependence graph with paths to crashing module the same reason.
a contrived example of a shared cause for non crashing paths is shown in figure .
paths through nodes highlighted in yellow horizontal bars cannot crash the system because they are guarded by the condition x that does not satisfy the crashing condition x y!
.
to detect the reason of infeasibility of non crashing paths we conjoin the path constraint for a path that reaches crashing module with the symbolic summary of a crashing module with respect to crash location.
intuitively terms in path constraint that contradict terms in symbolic summary are the reasons of infeasibility of a complete path from program entry point to the crash location term x in path constraint pcin figure .
practically the conjoining of and amounts to two steps.
first to check the satisfiability of formula .
and second if the formula is not satisfiable the path does not crash the system to extract a minimal unsat core that contains contradicting terms t. the contradicting terms correspond to the causes of the infeasibility of a given non crashing path.
our search algorithm keeps track of each term in path constraint formula and corresponding program location the term is being introduced.
consequently a contradicting term indicates a point on a program execution path to which our search algorithm proceeds to pursue alternative paths and avoids executing paths that do not crash for the same identified reason.
crash reports often contain the values of program registers at the moment of crash register dump in figure .
a constraint on these values is a crash condition.
in case crash condition is available we can detect the reasons of infeasibility of a path with respect to specific crash condition cc in the same way as described above by extracting terms in unsat core from an unsatisfiable formula cc.depending on a type of a crash crash conditions are easier or more difficult to extract.
for instance crash due to division by zero could appear in crash report as instruction div ecx where the value of ecx as shown in figure .
consequently crash condition is ecx .
some crash conditions can be less evident and require additional effort for being captured as we discuss in section v a. iii.
p reprocessing and hybrid symbolic inputs the first two steps of our approach prepare information for the third step a targeted search for a crashing path section iv .
in particular the first step resolves incomplete information about program binaries while the second step generates a structurally correct hybrid symbolic input figure .
step recovering program structure and selecting seed files we statically analyze the system with ida pro toolset3 and use analysis results to obtain a program control flow graph cfg and module dependence graph mdg that we dynamically refine in the next steps of the approach.
the main sources of incompleteness in program binaries are register indirect jumps and calls and concealed library entry points non exported functions .
we process the output of ida pro and statically resolve jump targets for switch statements detect function boundaries and statically imported entry exit points for the modules in a list of modules involved in a crash.
we execute the system with benign input files to augment the statically collected information with dynamically imported entry and exit points of the modules of the system concrete targets for branches dependent on indirect register jumps and resolved register indirect call targets.
a resulting aggregated inter procedural control flow graph connects different modules of the system along the discovered module entry exit points.
we select seed files from a test suite according to their relevance to the crash and the modules involved in the crashing behavior.
the main criteria for file selection are traces of system executions with test files and file structure information.
file structure information indicates which objects in the file are required to exercise certain functionality of the system.
we aggregate the traces of system execution with the preselected test files and obtain a histogram for selecting files that most extensively use modules from modulelist .
we use the selected seed files in the next steps of the approach as the most relevant to the crashing behavior.
step generating hybrid symbolic inputs we use concolic execution to detect fragments of inputs that are relevant to reaching the crashing module input fragments that propagate data into the crashing module.
taint tracking using concolic execution precisely associates the fragments of program inputs and affected program locations.
it is more accurate than vanilla taint analysis that traces program paths affected by program inputs however does not establish which parts of the input are propagated to which program locations.
3ida is a state of the art multi processor disassembler and debugger https concolic execution we apply random exploration strategy upon branching the next path to explore is selected randomly with an exception that paths generated by string functions are selected from groups of paths as detailed in section v b. we automatically generate fully symbolic versions of seed files identified in the previous step of the approach and we trace the propagation of symbolic data from these files during concolic execution execution stops when it reaches crashingmodule .
given a path that reaches crashing module a path constraint contains symbolic input bytes taint sources relevant for reaching this module.
together with the knowledge of input file structure this information serves to automatically generate hybrid concolic input file that maintains the original file layout.
we prevent random exploration from drifting outside modules in modulelist and dynamically refine cfg of the system extending it with information from concolic exploration.
concolic exploration discovers new paths if it produces new concrete data to take these paths.
in particular if concolic executor reaches register indirect jump instruction jmp with a new concrete value in eax then it may explore a new path spanning from a new jump target.
a maximum number of resolved indirect jumps and calls is thus proportional to the number of new paths we can explore with the concolic data.
to prepare cfg for the targeted search we prune it with respect to crash location in crashing module and with respect to exit points that connect modules in modulelist .
a schematic module dependence graph with pruned paths is shown in figure where pruned paths are marked with x. iv.
t argeted search in the third step of the approach we apply targeted concolic execution to find crashing paths program paths that crash the system in crashingmodule .
the targeted exploration works on a pruned version of cfg and hybrid concolic inputs generated in the previous step of our approach.
the three phases of the exploration are replay summarization and a main phase targeted search .
figure illustrates transitions between these phases schematically.
the targeted exploration starts by deterministically replaying one of the observed paths to the crashing module with hybrid concolic input replay .
consecutive symbolic exploration symbolically summarizes the crashing module from module entry point to the crashing location using symbolic data propagated to the module from the program input summarization .
finally a targeted search phase selects and traverses alternative program paths in search for crashing paths.
targeted search phase evaluates the feasibility of a given path with respect to the crashing module summary and detects the reasons of infeasibility of the non crashing path as terms in the unsat core of the conjunction of the path constraint and module summary.
the algorithm uses the program states that introduced the infeasibility reasons as anchors to select alternative states to which to proceed.
as a result the search is directed away from groups of infeasible paths.
search proceeds replay phasetarget.
searchsummarizationalt.
locationstartreplaysummarytarget.
searchendstart crashing module!a1a2s1s2s3s4fig.
.
phases of targeted exploration until it finds a feasible crashing path or terminates after a user specified timeout or upon exhausting the memory.
algorithm outlines the key elements of each of the phases.
the search algorithm is general and can be implemented on top of any dynamic symbolic executor.
we illustrate the algorithm for a generic language with instructions identified by their locationl.
for simplicity we distinguish two types of instructions branches identified by branch l predicate with branch conditioncond l and non conditional instructions.
the target location of a branch instruction is identified by target l while for all instructions the next location is next l .
program state sis represented by a triple l m where lis a program location is a path constraint and mis a symbolic store.
symbolic store maps program variables to concrete values or expressions over input variables.
the initial program state is l0 true m wherel0is a program entry point path constraint is set to true andmis initialized with symbolic variables for each program input variable.
a. replay targeted exploration replays the path to one of the crashing module entry points e2e.
given a set of states se list of states for reaching efroml0 the replay is a concolic exploration where upon branching the states for execution are selected from se line .
during replay the searcher takes snapshots of the alternative states and stores them in a map with constraints introduced in the executed state condition s line .
figure schematically shows state s1 and its alternative state s2that the algorithm stores in the map .
replay terminates after traversing all the states in sein a state reaching entry point eof the crashing module.
note that in our implementation of the algorithm selist is lightweight.
it does not store the complete state representation as used by s2e but only the forking program locations.
b. summarizing crashing module symbolically upon reaching entry point of the crashing module the algorithm commences symbolic summarization line lines .
the summary is an aggregate of path constraints foralgorithm targeted search input l0 initial location crash location e list of module entry points se list of states for reaching e2efroml0 replay phase s l0 true m .initialize current state whilese6 do if branch l thens next l mhv ei ifbranch l then if sat cond l sat cond l then s1 next l cond l m s2 target l cond l m s fs1 s2g se .pick next state from se hcondition s fs1 s2gns i .snapshot se sens symb summary s .location of the last state in seise main phase x while sat do unsat core t pickterm .pick contradicting term using strategy x x ftg s .select alternative state whilel 2edo .until reached any of entry points if branch l thens next l mhv ei ifbranch l then if sat cond l sat cond l then s1 next l cond l m s2 target l cond l m s picknextstate s1 s2 hcondition s fs1 s2gns i.snapshot ifl 2echecked then symb summary s out x .we can continue search by proceeding to the remaining alternative states from line .
summarization procedure symb summary s .explore paths from sto require location s 2e echecked echecked location s s l true m .reset path constraint w fsg .initialize worklist whilew6 timeout do if branch l thenw w next l mhv ei ifbranch l then if sat cond l sat cond l then w w next l cond l m w w target l cond l m ifl then w wns s picknextstate w cc .
add crash condition to the summary return each path reaching crash location from the module entry point using symbolic data that is propagated to the module entry point.
symbolic store mholds the propagated symbolic data as expression over symbolic program inputs.
the summary is independent of the path constraint used for reaching the crashing module and the corresponding path constraint is reset totrue line .
a module summary is a disjunction of path constraints ifor each path reaching crashing location from a given module entry point wn i i. summarization procedure uses the pruned cfg to inform selection of the next states in symbolic exploration.
states extending outside cfg are not pursued as they do not reach crashing location.
this is implemented in procedure picknextstate that uses cfg to select successors forbranching instructions line .
this way the algorithm ensures selection of states for paths that reach crashing location.
the symbolic summary collected with our approach may be incomplete.
symbolic data in symbolic execution can be injected only from the input of the system it is not be generated in the process of symbolic execution.
concolic exploration may not reach the module with symbolic data for all of its inputs some of the inputs may be reached with concrete data resulting in an incomplete summary.
symbolic data may not reach the module for a number of reasons.
first seed input files may be inadequate or deficient with respect to the functionality of a crashing module input file may lack data structures that affect certain input of a crashing module.
second an input of the module may be independent of the program input.
and third a symbolic input may be concretized during concolic execution and propagated to the module input as a concrete data.
given a crash condition cc a module summary is a precondition with respect to reaching crashing location where crashingmodule cc is a logical formula over the module input which is true for all inputs that cause crashing module to reach a final state satisfying cc.
since cfg of crashing module is pruned module final state is in the crashing location .
the algorithm extends module summary with crash condition cc in the last step of summarization line .
the summary concisely captures a precondition for reaching crashing location.
c. searching for a crashing path targeted search phase starts from the point when concolic executor have reached the crashing module in the replay phase and consequently collected symbolic summary of the module in the summarization phase.
targeted search phase identifies program states that do not introduce infeasible constraints in the paths reaching crashing module and directs exploration through these states in the search for feasible crashing paths.
provided that the initial path selected for reaching the crashing module in the replay phase does not crash the conjunction of path constraint and symbolic summary is unsatisfiable.
to detect the reasons of unsatisfiability the algorithm queries smt solver for minimal unsat core that contains a list of contradicting terms from both path constraint and summary .
the algorithm extracts from unsat core a list of terms line .
these terms correspond to the reasons for infeasibility that originate from the specific program states on the path reaching crashing module.
in the schematic example in figure the cause for the path infeasibility is located by the contradicting term x from the path constraint.
to continue the search for a crashing path the algorithm selects alternative program states that do not introduce the identified infeasibility reasons.
the algorithm selects alternative states indicated by the list of contradicting terms using the map of constraints and alternative state snapshots captured during replay phase.
in particular a procedure pickterm selects one term tfrom the list and this term is then used to query the map to select the alternative state lines ....0x61161745 mov ecx esi0x61161747 call ebx0x61161749 add esi 0x6116174c dec edi0x6116174d jnz loop......0x61161146 mov eax ecx0x61161148 xor ecx ecx0x6116114a fstp qword ptr ds ...crash instructioncrash functioncall site loop fig.
.
example of loop dependent crash in real player inpickterm we select a term introduced in the topmost program location and a corresponding alternative state.
such term represents a general reason for infeasibility of multiple paths in a symbolic subtree and thus when selected can dramatically reduce the search space.
however some of the paths in that subtree may be feasible.
for instance in figure a path that passes through a blue node vertical bars in the cfg is feasible with respect to the crashing module summary.
each iteration of the targeted exploration continues from the selected alternative state until it reaches entry point of the crashing module with a new path constraint .
the search algorithm can reach crashing module through an entry point that it has not reached before line .
in this case the module summary is recomputed to consider new paths to the crashing location if they are reachable from this entry point.
algorithm iterates until the formula is satisfiable and hence the crashing path is found.
the output out of the targeted search consists of a path constraint and a list of contradicting terms xused for navigating the search.
the path constraint can be solved to generate a set of program inputs that exercise a particular crashing path.
the list of selected contradicting terms xserves as an additional explanation for the crashing path highlighting the data and deviation points a1anda2in figure that are crucial for pursuing it.
v. t ackling limitations of concolic execution a. synthesizing crash conditions for loop controlled crashes to reproduce a crash our approach reaches a crash instruction and among other information uses crash condition cc to direct the targeted search and ultimately synthesize crashing input.
in practice however crash condition cannot be formulated symbolically in terms of symbolic input of the program if concolic executor reaches crashing instruction without symbolic data in the operands of the instruction.
previous research demonstrated that this situation can be alleviated for loopdependent variables .
hercules solves this problem by inferring a function over dependent variables operands of crash instruction on a number of loop iterations.
this allows us to express the cc at the targeted crash instruction through another condition cc0at the beginning of the controlling loop s .
saxena et al.
used abstract interpretation and pattern matching to infer the function .
inhercules we infer the function using data fitting on runtime values in registers and memory locations during loop exploration .
a similar idea has been successfully applied in the context of segmented symbolic analysis to discover symbolic relationships between program variables .figure shows an example of loop controlled crash instruction in a crash module flvff.dll that causes a memory access violation in real player due to an integer overflow vulnerability cve .
in this example the crash function is iteratively called in a loop and the crash instruction at0x6116114a attempts to store data to the targeted memory address that is calculated using the value of eax register.
if the address is out of bounds the crash will occur.
hence the cc in this example must be expressed through symbolic data ineax aseax eax crash where the eax crash value comes from the register dump in the crash report.
however symbolic execution reaches the crash instruction with a concrete value ineax preventing the approach from formulating a symbolic crash condition.
we apply inter procedural data flow analysis to establish whether the crash instruction is loop controlled and if so to detect data dependencies between the operands of the instruction and the variables within the loop.
in the example we discover a data dependency between eax andecx in the crash function mov eax ecx at0x61161146 and between ecx and esi in the call site mov ecx esi at0x61161745 .
inside the loop esi is incremented by a concrete value passed through a function argument at each iteration.
the value of eax in crash instruction depends on the value of esi register inside the loop and in turn the value of esi depends on the number of loop iterations.
using data fitting hercules infers a relationship between esi and a loop count it esi esi it 0x23 .
in the example the number of loop iterations is controlled by the value of register edi that holds symbolic data instructions at 0x6116174c and0x6116174d .
in other words the value of eax in crash instruction is indirectly controlled by the symbolic input data in edi.
as a result we transform the concrete constraint cc on eax at the crash instruction to a symbolic constraint cc0on the value of edi before the start of the loop.
with this data we can synthesize crashing input by solving the formula cc0 where 0is the path constraints to reach the loop.
b. tackling path explosion to avoid path explosion during concolic execution of realworld binaries our approach tackles its most prevalent sources loops and string manipulation functions.
to tackle path explosion in loops we bound a number of loop iterations in which concolic executor forks new feasible states.
beyond the bound the executor does not fork new states in a loop.
recent research shows that bounding loop iterations is a practical and effective solution in the context of symbolic execution .
string manipulation functions are more difficult to tackle than loops.
in essence these functions are sophisticated loops over string data that are modelled with bit vectors and processed as unbounded data causing generation of infinitely many symbolic states.
yet symbolic exploration with string data is important a large class of crashes in software is caused by buffer and heap overflows when programs operate on string data.we define a heuristic that leverages string length estimation and approximation of standard string manipulation functions to help concolic execution in generating states with realistic string data while reducing the risk of path explosion.
the intuition behind our heuristic comes from the following observations there are many concrete strings encoded in the program code and thus many string length bounds can be obtained based on operations between symbolic and concrete strings.
moreover there are practical limitations on the size of strings such as function stack frame size and input file layout that provide estimates of string lengths.
finally semantics of several standard string manipulation functions can be abstracted to the level of groups of paths and inform symbolic execution.
for functions like strlen sym we bound concolic exploration in the function according to the length estimate of a symbolic string parameter sym that we gather dynamically from a number of sources.
a length estimate for strings allocated on stack should not exceed a current stack frame size while file layout and object boundaries boundaries between symbolic and concrete input data indicate upper bounds for lengths of strings derived from input file data.
for other standard string functions that operate on pairs of strings we approximate these functions by mapping their few semantically different high level paths to a multitude of low level paths.
one example of groups of high level paths for a function stricmp str1 str2 would be strings are equal strings are equal length and differ in content and strings differ in both length and content.
these three groups map to thousands of feasible low level paths stemming from two reasons.
first in llvm based symbolic execution engine s2e in our case the string function is converted to llvm bitcode that has larger number of branch instructions that in source code or binary.
for stricmp str1 str2 function the number of branches in llvm bitcode is versus in source code.
second the number of paths is also controlled by the number of loop iterations that depends on the length of the input strings.
we define the high level semantics of the string functions as a logical formula over function input output and properties of the input such as length of a string argument.
to avoid path explosion during concolic execution we bound the exploration of these functions until paths from all semantically different path groups are generated while controlling the number of generated paths.
consecutively we prioritize groups of paths and select single paths from each group for further concolic exploration.
for instance for stricmp function we give a higher priority to the path producing equal strings which covers the highly relevant case.
an experimentation with orbital viewer case study cve highlights the degree of reduction in path numbers our technique achieves for concolically exploring a standard string function.
s2e with depth first search configuration would need to fork 150k paths to fully concolically explore stricmp str1 str2 function with one symbolic string argument and one concrete string of length .
with our heuristic concolic executor only needs to explore 8k paths to populate elements for three high level groups of s2e coresystemwindowsmonitorstandard pluginsfunctionmonitormoduleexecutiondetector corepluginexecutiontrackerdynamiccodeselectorcrashdetectortargetedsearcherstringfuncinterceptorconditionsynthesizerloopexplorer modified pluginedgekillercfgprocessing refinementcustom plugins z3 integrationida probapfig.
.
components of the hercules toolset total paths that we keep one path strings are equal one path strings of equal length and differ in content and paths strings differ in both length and content .
each path in the third group corresponds to the strings being unequal in any of the first characters.
we only need to keep paths to cover all of the three high level paths of the stricmp str1 str2 function while the remaining low level paths can be removed from exploration.
overall we generate few paths that cover all high level paths of a function in a balanced way and produce realistic strings.
vi.
i mplementation our approach hercules builds upon and extends the selective symbolic execution technique s2e .
figure shows an overall view of the components of our toolset.
the main components of our system are built as custom s2e plugins.
in addition hercules provides tools for control flow graph processing outside s2e and data flow analysis built on bap.
a. cfg refinement and path pruning functionality hercules implements analyses for post processing the output ofida pro toolset and obtaining the static and the dynamic program structure information.
we build cfg for each selected module of the system using the static program structure information direct jumps direct calls jump tables and the dynamic information indirect register jumps and calls .
we refine the cfg whenever the dynamic program structure is updated while exploring the program under test in steps and 3of our approach.
apathpruner module implements a pruning algorithm similar to the algorithm for computing chop by brumley et al.
.
pathpruner indicates every path that does not lead to interesting targets in a module dependency chain.
in the crashing module this tool will prune the paths that do not reach the crash location.
the output of the tool will be used as the input of a plugin edgekiller that will kill a s2e state in runtime if it executes an undesirable path.
b. extensions of the s2e core stp the smt solver in s2e does not compute unsat cores .
to get the unsat core of a symbolic expression we integrate z3with s2e and pass symbolic constraintsbetween them in smt2 format.
our framework augments s2e to output symbolic formulae in smt2 format and implements a wrapper function to invoke z3solver from s2e.
another s2e core update takes snapshots of s2e states in the targeted search.
we make snapshots of symbolic states at each branch location during concolic execution to enable backtracking of concolic executor.
this functionality is implemented on top of cloning functionality of klee used bys2e and our version supports state cloning at an arbitrary execution point.
c. analysis and search plugins anexecutiontracker plugin outputs important runtime information.
it handles signals emitted by s2e core plugin when it executes an instruction or a basic block.
in addition it detects the process id of the program under analysis to keep track of the information it produces and excludes information produced by other programs that use shared libraries.
adynamiccodeselector plugin enables flexible runtime selection of modules executed concolically with forking enabled .
the original s2e codeselector plugin is less flexible and only supports static configuration of a list of modules in which s2e selectively enables forking.
our targetedsearcher plugin heavily relies on dynamiccodeselector for dynamically switching different search stages each having different configurations of forking enabled modules.
to synthesize crash conditions for loop controlled crash instructions we have developed three components.
first conditionsynthesizer is built as s2e plugin.
it outputs runtime values of all registers and updated variables at each iteration inside the controlling loop.
second a light weight data flow analysis is built on binary analysis platform bap .
its output supports user in selecting registers variables having relationship with a number of loop iterations.
third a tool to interface with the rstatistical package to invoke its regression models and infer function on dependent registers variables and the number of loop iterations .
hercules infers functions for simple and nested loops and covers three function forms linear polynomial and exponential by using simple linear and multiple linear regression models with logarithm and variable substitution transformations.
stringfunctioninterceptor controls the exploration inside string functions.
it intercepts every call to the list of standard string library functions such as strlen strcpy strcmp stricmp strcat strchr and strstr using handling signals emitted by the functionmonitor plugin of s2e onfunctioncall andonfunctionret signals .
for each of the functions we implement a special structure to define groups of semantically distinct high level paths section v b .
each group is defined as a logical expression over function input lengths of manipulated strings and function output.
finally the module dynamically extracts the stack frame size of the caller to estimate string length bounds.
atargetedsearcher plugin is a combination of the three searchers pathreplaysearcher symbolicsummarization and entrypointtargetedsearcher .
each searcher implementsthe dedicated phases of the targeted search algorithm defined in section iv.
the plugin switches between the searchers in the process of concolic execution using several signals emitted by the s2e core plugin onstatefork onstateswitch onexecuteinstruction and signals from our custom plugins.
in particular onstringfunctionstart and onstringfunctionend signals generated by the stringfunctioninterceptor plugin are used for state grouping and prioritization for string manipulation functions.
targetedsearcher populates the groups of states defined for each string function prioritizes these states and removes redundant ones.
acrashdetector module detects application crash by tracking windows error reporting service invocation and calls s2e api to solve path constraint and generate crashing input.
vii.
e xperimental evaluation we evaluated our approach experimentally on real world application binaries.
in this section we present the results of the evaluation that demonstrate that hercules successfully reproduced sixdistinct crashes in five applications adobe reader ar windows media player wmp real player rp orbital viewer ov and music animation machine mam player.
table i summarizes the results for the effectiveness of our approach as compared to the original s2e technique and widely used industrial black box fuzzing tool peachfuzzer hercules generated test inputs and reproduced all six crashes whereas baseline techniques failed or took considerably more time to succeed.
a. experimental setup we conducted all of the experiments on a computer with a .
ghz intel core i7 cpu and gb of ram.
the host os is ubuntu .
bit.
the guest os are windows enterprise bit sp1 and windows xp bit sp3.
our approach is implemented on s2e version from may obtained at we used freeware ida pro .
to disassemble binaries.
in table i case studies marked with have been tested on both windows xp and windows .
the case studies cover vulnerabilities of the four prevalent types buffer overflow integer overflow memory access violation and division by zero from and operate on five distinct structured file formats.
for the ov case study we used a developer test suite obtained at http for the adobe reader case study we used microsoft word to create pdf files with embedded fonts.
for the other four case studies we obtained test suites on the internet from a random sample of benign files of an appropriate format.
table i highlights the test suite composition with numbers of benign files and their variation in size.
we enabled forking in a subset of modules indicated by the crash reports as shown in table i. the toolset was configured for a timeout after twelve hours of exploration and run without parallelization of the execution process.
for hercules we have fixed a loop bound of three iterations and state timeout of seconds to prevent the exploration from drifting section iii .table i experimental setup and results vulnerability cve cve cve cve cve cve application wmp v9.
wmp v9.
ov v1.
mam v0.
ar v9.
rp sp .
selected total modules size of crash.
module .
mb .
mb kb kb .
mb kb test suite no.
of files kb kb kb kb kb kb s2e random search no hr no hr no hr yes min no hr no hr s2e dfs search no hr no hr no out of mem.
no hr no hr no hr peachfuzzer no hr no hr yes hr yes min no hr no hr hercules min min min hr min min hr min sec min hr min hr hercules yes min yes min yes min yes sec yes min yes min table i shows execution times for the cfg construction step concolic step and the targeted step exploration byhercules as per figure correspondingly marked in the table .
for step our automated scripts construct cfg from the output of ida pro within few minutes.
we used a practical time limit of two hours for exploration in step .
for the five case studies except cve hercules step explored resolved dynamic information and reached a crashing module within two hours while the case study on mam cve did not require exploration phase to reach the crashing module.
finally for all the case studies targeted search step reproduced the crashes within an hour.
b. reproducing crashes our approach reached and reproduced crashes cve andcve in windows media player quartz library .
cve is a vulnerability in windows media player version .
attackers can exploit this vulnerability to cause a denial of service via a crafted .wav file.
cve is a buffer overflow vulnerability in windows media player version .
it allows attackers to cause a denial of service via a crafted .mpg or.mid file that triggers a system crash due to a divide by zero exception.
hercules successfully reproduced the two crashes using the targeted search.
in both cases hercules avoided state explosion by bounding loop iterations while no string function analysis was required.
hercules reproduced cve using as little as of input data in symbolic form.
cve is a crucial stack based overflow in orbital viewer a tool for visualization of atomic and molecular orbitals.
by using a crafted .orb or.ov file attackers can trigger a system crash in memory access violation exception or execute arbitrary code.
the vulnerability comes from the code for reading data from input file using a known vulnerable function fscanf .
ov does not correctly check the data size before writing it into stack buffers.
the crash happens when the overwritten data section is accessed by ov after a series of function calls including calls to string manipulation functions.
hercules successfully bridged the distance between the location where crashing data is introduced and the crashing location by leveraging our heuristic for exploring string functions section v b and reproduced the crash.
cve is a vulnerability in mam midi player that allows attackers to easily cause a denial of service viaa crafted .mid file that crashes the program with a null pointer dereference.
this is the most simple case study in our experiments that hercules reproduced within seconds.
furthermore hercules does not require loop bounding nor string function analysis to reproduce the crash.
cve is an vulnerability in adobe reader .
.
that allows attackers to cause a denial of service or execute arbitrary code.
cve is an integer overflow vulnerability in realplayer sp .
that allows attackers to execute arbitrary code.
for both cases hercules can reach crash instructions by symbolically executing the programs with benign inputs however the programs do not crash because the crash instructions are loop controlled.
with the loop controlled crash condition analysis section v a hercules can identify the loop and infer a relationship between crash instructions and the controlling loops.
as a result hercules can successfully synthesize symbolic crash conditions on the number of loop iterations and use them to reproduce both crashes.
c. comparing with the baseline we demonstrate the effectiveness of hercules by comparing it with the baseline s2eand black box fuzzing tool peachfuzzer on the same six case studies.
we have run s2e with the input files that hercules used to successfully reproduce the crashes while peachfuzzer used all the files in each test suite.
the results shown in table i demonstrate that s2e can reproduce the simple crash cve and fails to reproduce the other ones.
non directed search of the baseline s2e prevents it from reaching relevant program locations in a given time and state space constraints.
when run with a depth first search dfs exploration s2e digs itself in a single path while for the ov case study cve it gets path explosion in string manipulation functions before reaching the crash location.
we run peachfuzzer in a fully automatic setting with infinite iterations of random mutation strategy and without user provided data model input grammar specification for up to hours.
peachfuzzer took substantially more time than hercules to generate crashing inputs for two case studies.
effectiveness of the fuzzing tool critically depends on the results of manual analysis to provide it with a correct input grammar specification and indicate input portions that can and must be mutated and portions that need to be preserved.viii.
r elated work recent research produced a rich body of work for intelligent navigation of program space and assisting symbolic execution in reaching certain program locations .
a common line in these approaches is to use distance metrics and anchor points for driving symbolic execution.
debugging approach esd and patch testing approach katch systematically direct symbolic exploration towards a specific program location.
differently from our approach that works with binaries esd andkatch assume availability of a program source code and thus have more precise system information.
both approaches analyze data flows to identify reaching definitions responsible for taking critical controldependent edges and steer symbolic execution towards these intermediate goals using proximity metric.
approaches that work on program binaries focus on resolving sufficient system information using static and dynamic analyses .
approach by babi c et al.
uses static analysis to guide automated dynamic test generation .
dynamic analysis resolves indirect jumps with seed tests and the static analysis helps symbolic execution directing exploration towards vulnerabilities based on the shortest paths and loop pattern heuristics.
mace by cho et al.
combines symbolic and concrete execution to build and refine an abstract finite state model of the system environment interaction and use it to guide the program exploration .
hi cfg by caselden et al.
generates hybrid information and control flow graph of a program to direct stages of backwards symbolic execution.
analogously to these approaches steps and2of our approach resolve program structure information and use it to inform symbolic execution.
fuzzing techniques integrate and interleave with symbolic and concolic approaches for synthesizing complex structured program inputs .
a notable example of white box fuzzing technique is sage .
it works on binaries and given an initial test input concolically explores the application using code coverage maximizing heuristic.
buzzfuzz an automated source code level technique uses dynamic taint tracing to automatically locate regions of given seed input files that influence values used at program attack points and infers the type of the input based on the taint information .
dowser uses taint analysis to identify program inputs that influence memory accesses and uses concolic execution with partially symbolic inputs for learning about pointer access patterns .
using this information dowser steers fuzzing technique towards complex pointer calculations in the program.
likewise by leveraging benign input files for generating hybrid symbolic inputs our approach retains intrinsic input structure helping to scale symbolic exploration.
the idea of summarizing functions or problematic behavior in symbolic execution have been investigated earlier.
godefroid proposed a compositional approach to capture and reuse function summaries to scale dynamic symbolic execution .
brumley et al.
describe vulnerability signatures as weakest preconditions .
several approaches have explored similar intuition for summarizing and reasoning about problematicbehavior in a backwards fashion to find program inputs that trigger such behavior .
a related line of research improves the scalability of symbolic execution .
kuznetsov et al.
introduced dynamic state merging and query count estimation .
by estimating the impact of symbolic variables on solver queries the approach merges states balancing between the number of generated states and the complexity of the solver queries.
mayhem by cha et al.
combines online and offline symbolic execution and models symbolic memory at the binary level .
built on mayhem veritesting enhances dynamic symbolic execution with static symbolic execution .
these approaches are orthogonal to our work and can be integrated to enhance its scalability.
our approach deals with high level sources of scalability issues in symbolic execution that are manifested in string manipulation functions.
prior research has been addressing the issues of operating on string data in dynamic analysis and symbolic execution .
larson and austin characterize and track bounds and null termination of string variables for dynamically checking validity of program inputs .
xu et al.
track the abstract length of the input string prefixes and instrument the string library to update abstract lengths in symbolic execution .
bucur et al.
associate high level execution paths of the program to some low level execution paths during symbolic execution of python programs .
our approach learns from these ideas and extends them in a new context of analyzing real world application binaries.
in our future work we plan to enhance our technique by integrating string solvers that can be adapted for working with program binaries .
ix.
d iscussion in this paper we have presented the design and evaluation of our hercules approach for finding test inputs which can reproduce a given crash.
our approach is based on symbolic execution and its distinctive features include i working on binaries without source code and encompassing techniques to construct the control flow graph directly from binaries in the presence of register indirect jump instructions ii combining taint tracking and symbolic execution to find which parts of the input file must be kept symbolic and iii search strategies to direct a path towards the crashing location by analyzing why the current path being traversed by the search cannot reach the crash.
experiments on real world application binaries such as windows media player and adobe reader show the efficacy of our approach in finding test inputs to reproduce a crash.
acknowledgment this research is supported in part by a grant from dso national laboratories singapore and in part by the national research foundation prime minister s office singapore under its national cybersecurity r d program award no.
nrf2014ncr ncr001 and administered by the national cybersecurity r d directorate.
the authors would like to thank kenneth cheong and chia yuan cho for their constructive comments at various stages of the work.