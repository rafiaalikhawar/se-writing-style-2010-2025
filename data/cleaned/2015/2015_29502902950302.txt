foraging and navigations fundamentally developers predictions of value and cost david piorkowski1 austin z. henley2 tahmid nabi1 scott d. fleming2 christopher scaffidi1 margaret burnett1 1oregon state university corvallis or usa 2university of memphis memphis tn usa piorkoda nabim cscaffid burnett eecs.oregonstate.edu azhenley scott.fleming memphis.edu abstract empirical studies have revealed that software developers spend of their time navigating through source code during development activities yet fundamental questions remain are these percentages too high or simply inherent in the nature of software development?
are there factors that somehow determine a lower bound on how effectively developers can navigate a given information space?
answering questions like these requires a theory that captures the core of developers navigation decisions.
therefore we use the central proposition of information foraging theory to investigate developers ability to predict the value and cost of their navigation decisions.
our results showed that over of developers navigation choices produced less value than they had predicted and nearly cost more than they had pre dicted.
we used those results to guide a literature analysis to investigate the extent to which these challenges are met by current research efforts revealing a new area of inquiry with a rich and crosscutting set of research challenges and open problems.
ccs concepts software and its engineering software notations and tools software and its engineering software creation and management keywords information foraging theory navigation value and costs .
introduction in a landmark paper in ko et al.
quantified the high cost developers incur when foraging for the information they need.
in their results developers spent of their time on the mechanics alone of foraging between code fragments .
expanding upon these findings we showed that when other aspects of foraging were also taken into account developers spent an average of of their time foraging .
these and other findings about developers foraging and naviga tions e.g.
have led software engineering re searchers to produce tools that help to reduce developers naviga tion costs as they look for the information they need .
despite these gains however little is known at the foundational level of developer navigation how well de velopers go about choosing where to navigate.
this is where theory can help.
the essence of theories is abstrac tion mapping instances of successful approaches to crosscutting principles.
in the realm of human behavior these abstractions can then produce explanations of why some software engineering tools succeed at supporting the efforts of software developers and why some tools that were expected to succeed did not.
as shaw eloquently explained scientific theory lets technological development pass limits previously imposed by relying on intui tion and experience .
for example her summary of civil engi neering history points out that structures buildings bridges tun nels canals had been built for centuries but only by master craftsmen.
not until scientists developed theories of statics and strength of materials could the composition of forces and bending be tamed.
these theories made possible civil engineering accom plishments that were simply not possible before such as the rou tine design of skyscrapers by ordinary engineers and architects .
and indeed in computer science we have seen the same phenomenon.
for example expert developers once built compil ers using only their intuitions and experiences but the advent of formal language theory brought tasks like parser and compiler writing to the level that undergraduate computer science students now routinely build them in their coursework .
in this paper we use information foraging theory ift as our theoretical foundation .
ift provides a conceptual framework describing how people in an information environment such as an ide seek information.
for example for developers faced with a bug the information they seek may include how to reproduce the bug what causes the bug where to fix the bug and whether simi lar bugs were fixed elsewhere .
according to ift developers make their navigation decisions by predicting the value a navigation will bring and the cost they will incur if they take that navigation.
when they carry out these navi gation decisions they may be in for disappointments if their destination does not provide as much value as expected or the cost of extracting the information or getting to it is higher than expected.
this suggests that the fundamental issue behind navigations is how accurate developers are about predicting value and cost and whether their accuracy is enough for them to be productive.
to investigate this issue we conducted an empirical study and litera ture analysis grounded in ift and structured according to the following research questions rq1 value how often do developers foraging decisions yield less value than they expect and why?
rq2 cost how often is the cost to gather and process de sired information more than foraging developers expect and why?
rq3 trends in aligning actual value cost with developers expectations what aspects of the above questions do current se research trends address and how?
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
.
background and related work .
information foraging theory in essence information foraging theory gives a meaningful way to carve up an information environment for software de velopment and the developers actions within that environment and then to investigate how developers use the environment.
ift has already proven useful for explaining and predicting developer behaviors during software maintenance in ways beneficial to tool design .
ift s main constructs are a predator here a developer who seeks prey the developer s information goals within an infor mation environment made up of information patches in this pa per java methods connected by links here ide features for navigating between methods e.g.
search results links clickable links to a method adjacent methods via scrolling .
each link has a cost time to get from one patch to the other that is influenced by both system performance and the human s cognitive and phys ical speed.
fig.
shows the information environment in this pa per.
within each patch are information features here words phrases and graphics in the code or documentation some of which may be the prey that the predator seeks.
information features have value and they also have cost e.g.
time for the human to read and process them .
some of the information features are cues that label outgoing links to other patches.
cues the labels on the links provide the predator with hints about what information features may be found at the other end of the link.
fig.
conceptually illustrates two patches with information features cues and links.
in modern development environments like eclipse most dis played text has some form of clickable link e.g.
the open decla ration shortcut on identifiers in the editor so there tends to be a high density of cues in such environments.
ift s constructs are tied together via ift s central proposition which says that the predator treats foraging as an optimization problem.
more specifically according to ift the predator s for aging actions try to maximize the value v of information they will gain from a patch per their cost c of getting to and interacting with that patch i.e.
max v c however predators do not have perfect information about a patch s value and cost so they make their choices based on their expectations of value v and of cost c i.e.
max e v e c the predator bases such expectations on whatever information they have gleaned so far such as by inferring them from available cues.
how accurate are foragers in forming these expectations?
soft ware engineering research has much to say about information professional developers seek e.g.
but has not systemat ically considered the question of how well developers can predict these values and costs or the accompanying implications for se tools.
these are the questions this paper investigates.
.
prior empirical studies of developers prior empirical studies have observed the navigation behavior of developers during maintenance activities.
that work has shed light on the different kinds of information that developers seek.
these include the need for information about how to use apis about data or control flow and about requirements .
these studies have also revealed that developers seek this information to answer specific questions that they have to test mental hypotheses about how an existing program works to develop an overall sense of context or to follow leads that simply look relevant to their current task .
rather than focusing on what developers seek and why our investigation examines the extent to which they accurately predict the value of what they find in particular patches and the cost of getting it.
often the reason for seeking code is to edit it and several prior studies have investigated how developers edit code.
for example ying and robillard investigated whether developers make edits differently depending on whether they are fixing bugs or adding enhancements .
as another example posnett et al.
investigat ed the extent to which developers make focused patterns of code edits across maintenance tasks sometimes called ownership of code and whether these patterns are statistically related to the resulting rates of defects .
in our study although participants were editing at times our research questions centered on foraging rather than on editing per se.
little empirical work has investigated the specific question of developers abilities to predict the value and cost of their navigations.
one study examined navigations of analysts through fig.
.
an information environment eclipse as a developer predator might see it during debugging.
patches of infor mation content are visible in the a package explorer b editor and c outline view plus a region d where other patches can appear .
as the blow up of a shows each item in the package explorer is an information feature and also a cue because the item has a link clicking it opens a file.
in b s blow up the text openfiles in the editor is also an infor mation feature and a cue because it has a clickable link.
fig.
.
conceptual depiction of an information environment with two information patches rounded boxes interconnect ed by links directed edges .
each patch contains infor mation features hexagons with some that are also cues connected to outgoing links .
documents and code as they attempted to recover requirement traceability between use cases and java classes revealing that the subjects spent a disproportionate amount of time in low value patches i.e.
more time than the value of those patches justified .
this result was consistent with an earlier study into the challenges of information foraging by developers such as the fact that searches in code frequently failed to turn up desired results and that developers spent substantial time organizing and re organizing files and bookmarks in the ide .
another study of how developers search online resources corroborated that searches often lead to irrelevant code and supporting documents except after developers had determined the right search terms for specific subtopics .
our work builds on these results.
.
empirical study methodology to answer our first two research questions rq1 and rq2 we conducted a think aloud study of professional developers.
the developers worked on a debugging task and we recorded their work.
we then collected developers insights by playing back the recording for the developer and pausing it to ask them questions about key events.
through this method we gathered data on the developers navigation decisions and their assessment of expected vs. actual values and costs relative to those decisions as they worked on the debugging task.
.
participants procedures and task ten professional developers at oracle participated in the study.
the participants had .
years of professional software devel opment experience and years of professional experience programming with java specifically.
we conducted the study one on one with each participant.
the sessions lasted no more than hours.
at the beginning of the session participants filled out a background questionnaire.
they then worked for minutes on the debugging task.
the task by design was sufficiently complex that no participant finished it in the allotted time.
during the debugging task we prompted partic ipants to talk aloud as they worked so as to gather data on their information goals and intentions of their navigations.
we recorded participants as they worked capturing the computer screen the participants facial expressions and their verbalizations.
the participants task was to debug an actual bug issue in the jedit open source project.
jedit is a code editor written in java with code base of non comment lines.
the bug was a problem with deleting folded text in the editor.
participants used the eclipse ide on a windows pc to complete the task.
we also allowed them to use any other tools they wanted to complete the task as they saw fit including using the web.
after the debugging session we conducted a retrospective semi structured interview.
the purpose was to collect participants expected value before a navigation and then the value they actu ally received.
to collect the data we played the session video for the participant pausing it at each to method event and away from method event on the video to ask the questions shown in fig.
.
the to method pauses occurred just as the participant navigated to a java method just before arriving there and the away from method pauses occurred just as the participant navigated away from the method just before seeing the new location .
if partici pants visited other kinds of files e.g.
properties files we asked them the same questions as for the methods.
.
qualitative analysis to analyze the data we used a qualitative coding approach to map key concepts codes to participants navigations .
specifi cally we coded the videos which included both navigation ac tions and corresponding verbalizations by the participants when ever participants talked about the value or cost of a navigation.
for the purposes of this paper we defined a navigation to a meth od to be any occurrence of the eclipse editor s text cursor auto matically moving to a method or the participant scrolling to bring a method into view while also talking about the method.
the des tination point of a navigation was a method in the editor.
the starting point of a navigation was any view in eclipse from which a participant scrolled or clicked to arrive at a method.
for exam ple selecting a search result or a link in an exception stack trace would open the corresponding code file in the editor and place the text cursor within the relevant method.
we coded each navigation for which participants assessed value or costs as follows.
first two researchers iteratively refined the code set.
then using the resulting code set on fresh data they independently coded of the data.
their resulting inter rater reliability was agreement using the jaccard index the inter section of all applied codes over the union of all applied codes on of the data for the value codes and agreement on of the data for the cost codes.
given that rate of agreement the coders then divided up the coding of the remaining data.
we detail each code set in the results sections that refer to them.
.
empirical results .
rq1 developers expectations of value .
.
did they get the value they expected?
to investigate the participants assessments of a patch s value we used an ordinal scale of measurement.
that is rather than attempt ing to quantify their value assessments numerically we derived from their verbalizations simply an order whether they received greater equal or less value than they had expected.
to perform this measurement we coded participants responses to the retrospective interview questions .
for expected value before they processed the patch we coded their responses to the to method questions and to measure their perceived actual value of the method after they processed it we coded their re sponses to the away from method questions.
table shows the code set we used to analyze these navigations.
by these measures the participants expectations of the infor mation value they would receive for their foraging efforts were optimistic they expected necessary or sufficient information from about of their navigations table s top two rows totals .
the first row shows navigations in which participants expected to find everything they needed sufficient about and the second shows navigations in which they expected to find at least something they needed necessary about .
to method questions what about location made you go there?
what did you expect the content to be at location ?
did you consider other options?
if yes what other options did you consider?
if yes why did the other options not jump out at you like ?
if partial list of foraging choices is abandoned what about these options made you not select any of them?
away from method questions did you find what you expected at location ?
if no what did you find at location ?
what did you learn from location ?
did what you learned cause you to change your course?
fig.
.
retrospective semi structured interview questions.
however many of these expectations of value were not fulfilled.
as table s bottom row shows of participants naviga tions about produced lower value than expected.
adding to these disappointments of the desperation navigations not expected to be either necessary or sufficient in which partici pants actually expected no value but tried anyway indeed led to no actual value.
thus in total about of participants naviga tions highlighted cells in table ended in some degree of dis appointment in the information value they received.
participants rarely found more value than they expected.
as ta ble s first column shows participants found higher information value than expected in only navigations and only one was a participant lucking into information in a desperation navigation.
.
.
why the challenges of signposting to find out why participants efforts so often returned disappoint ing value we analyzed the navigations in which participants received less value than expected from the perspective of ift s cues construct.
what we found was patterns of cues signposts that led participants astray in multiple ways.
many of the words in ides refer to places in the code e.g.
meth od names and in memory e.g.
variable names and when they are associated with a clickable or easily scrollable way to navigate to the place to which they refer these words serve as cues.
be cause cues like this are identifiable by lexically analyzing source code we term them lexical cues.
participants almost exclusively used lexical cues mostly method names to predict the value of a patch to which they were considering navigating.
unfortunately this type of cue often misled them to irrelevant patches even when participants expressed high confidence that the patch would be relevant to their information needs.
in particu lar three types of problems with lexical cues interfered with the participants expectations of a patch s value prior to going there cues that seemed to advertise falsely synonym cues and cues answering the wrong question.
.
.
.
false advertising content where the cue points some lexical cues beckoned participants toward a patch with a false advertisement of the value.
by way of analogy imagine this sign next to a store window buy brand name coffeemak ers .
this sign might be just what a shopper needs if the store actually has those coffeemakers but might lead them astray if it is merely advertising the coffeemakers e.g.
sold advertising space .
here the falseness of the advertising lies not in the content of the sign but the combination of its content and its apparent associa tion with this store.
at this point let us briefly consider whether the foundations oriented perspective we follow in this paper yields useful insights not produced by prior works.
for the case of developer naviga tions the results produce a new agenda of research challenges starting with the following research challenge false advertising how to reduce the problem of cues developers interpret as advertising prey in a patch that does not in fact have that prey.
the false advertising problem was very common among our par ticipants p2 p4 p7 p8 and p9 all suffered instances of it.
for example p8 navigated to method killring because it s obvi ously to do with deletion .
yet upon arriving in the method he was quickly disappointed when he realized it did not actually perform any of the work of deletion p8 when asked if he was hoping for something some more connection to deletion of the actual text... it was just the abstraction .
.
.
the problem with synonym cues some participants used their knowledge of synonyms to navigate.
for example in looking for code that deletes it seems reasonable to also look for code with names that mean the same as delete .
however synonyms sometimes led our participants astray.
p8 s killring false advertising problem above was exacerbated when synonym difficulties also arose.
other examples were p2 clear.bsh is that related to deleting?
no it s not p7 i m assuming invalidate means delete ... uh it just doesn t delete we were surprised to see the problems that arose with synonyms as cues because several tools use synonyms directly or indirectly to good effect e.g.
tools powered by natural language vocabulary devices like tf idf .
for example the search tool findconcept uses synonyms to expand the search query and krec uses standard english synonyms .
these approaches bring to mind seminal work on what was origi nally termed the vocabulary problem .
that paper showed how huge variations in designers terminology across numerous application domains are an inherent property of the english lan guage.
this result suggests not only the advantage of automatical ly agglomerating synonyms but also its disadvantage bringing together synonym related patches greatly expands developers search space as with p2 p6 and p8 above.
thus too little syno nym agglomeration produces too many false negatives but too much synonym agglomeration produces too many false positives.
research challenge synonyms how to improve develop ers foraging through synonym filled code without incurring high navigation costs from numerous false positives or false negatives.
the synonyms problem may relate to ge et al.
s observation that over of relevant synonyms are unique to software engineer ing .
for example in software invoke is a synonym of ex ecute and instantiate is a synonym of create .
they point out that tools could use a thesaurus tailored to the lexicon of se.
our table .
code set for expected prior to navigating and actual after navigating values.
category definition necessary sufficient sufficient participants believed that the navigation will e v or did v fully answer their current forag ing goal.
necessary participants believed the information in the patch at the end of the link will be e v or was v necessary related to their current foraging goal.
table .
participants expectations of value vs. actual value.
gray cells highlight navigations in which participants had some degree of disappointment .
of navigations .
actual v expected e v v e v v e v v e v totals necessary and sufficient n a .
.
.
necessary but not sufficient .
.
.
.
not necessary not sufficient .
.
n a .
totals .
.
.
results are consistent with this point but also suggest that the problems with synonym cues may extend beyond that solution.
.
.
.
cues that answered the wrong question our participants often used lexical cues such as method names to try to answer variants of the following foraging question what will that patch do for my goal?
unfortunately many of the meth od names they encountered were never intended to answer that question.
instead method names generally reflect a method s purpose what is this method?
.
however instead of asking what is questions participants often asked where does ques tions and method names often failed to answer these.
for example of our participants p1 p2 p4 p5 p8 p9 p10 ran into trouble foraging for the methods that actually update jed it s underlying model when a jedit user performs an editing ac tion.
for example while navigating among numerous method calls in the stack trace p10 said p10 i m trying to figure out which piece of ac tually updates the buffer state variables raised even harder where does questions and here again lexical cues did not help.
for example p1 was working his way up the exception stack trace trying to understand where physicalline s value came from.
after several navigations following the execution flow of the program he finally arrived at a method that did some computations on physicalline.
p1 this is the first place where ... there was some com puting of physicalline as opposed to just passing it along and throwing exceptions.
some systems try to address where does problems.
for exam ple whyline is well suited for where does questions about state and variables and reacher answers where does ques tions about methods.
however proof of concept tools like these need to be investigated in the context of the entire ide.
such tools require developers to navigate away from the main part of the environment into other tools and screens potentially causing them to lose context and adding to developers costs simply by the cost of navigating to other tools.
research challenge answering the wrong question how to more often answer the right question i.e.
the one a developer is actually asking in their particular situation giv en their particular context and state of the ide.
.
.
an open problem the value estimation problem with developers navigations table summarizes the research challenges in better supporting developers attempts to predict patch values before paying the cost of navigating to those patches.
these research challenges come together to reveal a large open problem space the value estimation problem aligning e v with v how to help developers more accurately predict the value they will gain from planned navigations without bearing the cost of navigating among a plethora of special purpose tools.
the challenges identified so far in this paper show that this prob lem is nuanced difficult and multidimensional.
even so address ing this problem promises high rewards.
recall from table that solving this problem could potentially improve developers navi gation efficiency by up to .
.
rq2 developers expectations of cost .
.
did participants incur the costs expected?
participants did not verbalize their expectations of cost before navigating so we did not measure e c and c separately.
instead we measured how e c related to c because after navigating they often verbalized a navigation s cost exceeding their expectations c e c .
thus our code set allocated these verbaliza tions among the two possible ways costs can be incurred by navi gating between patches cb or by processing within the patch once there cw .
thus c cb cw.
the results in table show that participants discussed facing unexpected costs in of the navigations analyzed .
.
.
.
why unanticipated costs between patches although there were several instances of unexpectedly high with in patch costs cw about of the navigations those can be summarized as simply being time consuming to understand p1 uh the whole thing was really frustrating.
the code was hard to read.
p5 looking for ... but then i got so lost in that i didn t really fully understand what was going on.
however the dominant type of unexpected cost was between patch cb affecting over of participants navigations.
table .
frequency of actual costs cb or cw that were unexpectedly higher than the developers had expected e cb or e cw .
the total is instead of because categories can co occur in the same navigation.
category definition examples navigations affected complexity of patch cw participants decided that the cognitive difficulty of this patch was unexpectedly high.
can t understand comments documentation.
code too long.
can t figure out what the code is .
surrounding context cb participants decided they would now need additional information found only in other patches before they could gain value from this one.
don t know how to use this code correctly without visiting other patches.
don t know what the identifiers represent.
don t know how this code relates to or affects other code.
.
time cb or cw participants decided for unspecified reasons or for reasons other than the above that the cost of this patch is too high.
not enough time to process the patch.
.
total .
table .
research challenges with value estimation e v .
research challenge participants who encountered it false advertising content where p2 p4 p7 p8 p9 synonym false positives p2 p7 p8 cues answering the wrong question p1 p2 p4 p5 p8 p9 p10 for between patch cost cb we identified three patterns that the participants faced that repeatedly led to unexpectedly high costs the prey was in pieces scattered among multiple patches the path to the prey was long with no end in sight and some times there simply was no available path to the prey.
.
.
.
prey in pieces scattered among multiple patches having prey in pieces spread over multiple patches made foraging costlier than expected because participants had to locate all the relevant patches and assemble the prey themselves.
using the coffeemaker analogy from before this would be like buying a coffeemaker in parts with a different store exclusively selling each part.
to get a working coffeemaker one would have to go to one store to get a handle another to get the glass container yet another to get a lid and so on only to then also assemble the gathered components before brewing any coffee.
research challenge prey in pieces how to better sup port developers who are having to assemble prey that is in pieces scattered among multiple patches.
one situation in which participants had to collect and assemble information from multiple patches was when they tried to learn semantic information such as what a variable represented.
for example p1 p3 p6 p7 and p9 were confused by all of the dif ferent line variables.
documentation for the semantic differences between the variables existed within comments in the code but participants sometimes needed a combination of knowledge from several patches to understand the different variables.
p5 did you consider any other choices besides method name ?
no because the names didn t really say much to me ... i basically had no clue about context... to illustrate the cost involved in establishing such context con sider p1 s case.
as fig.
shows for p1 to build the context he wanted he would have had to not only move up the call stack to find the relevant relationships and documentation but also had to locate and navigate through the call relationships through the dashed methods in the figure before putting together his desired prey.
of course p1 had no way of knowing this and after forag ing within the first four methods of the call stack he gave up.
several other participants faced similar difficulties when they wanted to understand where and how the value of a variable changed during execution.
p1 p3 p6 and p10 all navigated be tween several methods that executed during the delete line action to determine how specific values of variables changed.
one ex ample was the physicalline variable.
to understand where physicalline came from participants navigated up the call hierarchy and identified patches where physicalline was being modified only to reach a method that showed that physi calline was calculated using a screenline as a parameter.
then they had to navigate through another call hierarchy.
with each additional variable there was yet another call hierarchy to investigate and the number of patches to investigate grew rapidly.
eventually all four of these participants decided the cost was too high and gave up.
.
.
.
the path to the prey is too long with no end in sight in contrast to the above with the prey being scattered about in pieces some participants prey were already fully assembled and in only one patch but the path was so long participants thought they were going in the wrong direction and gave up.
returning to the coffeemaker analogy imagine entering a store searching for a coffeemaker but having the clerk tell you they do not sell them but they can point you to a store that might.
then upon entering that store having that clerk send you to yet another store.
eventually you might get to a store with the coffeemaker or you might give up before you get there because with each trip to a new store it seems less and less likely that any of the stores has a coffeemaker available.
several participants engaged in this behavior of going from patch to patch until finally giving up.
research challenge endless paths how to better sup port developers when the path to the prey is very long so that the developer does not erroneously decide that the prey is not on that path.
for example when p3 was looking for methods related to folding or deleting text he set a breakpoint in the exception throwing method that he identified earlier.
he then foraged through the sequence of methods in the debugger s stack frames working his way down the stack sometimes returning to a previous frame to regain lost context.
after several navigations he gave up still three methods away from the deleteline method that he was looking for .
p1 p2 p3 p4 p5 p8 and p9 all experienced this expense of navigating through long sequences of patches en route to their desired prey.
.
.
.
sometimes there is no path some participants could not find a path to their prey because the information they wanted was located in a different topology alto gether.
a topology is a collection of patches and the links between them.
in this study one topology was the code itself with units of code such as methods or classes being the patches and the ways to navigate between them like scrolling or using various ide fig.
.
p1 was looking for the relationship between screen lines and visible lines after seeing both in the starred method.
but jedit has three line types so he would have also needed to under stand physical lines from the dashed locations far right .
fig.
.
p3 navigated down the debugger s stack frames searching for methods related to folding or deletion.
after several navigations down the stack he gave up only three methods away from the method he was looking for.
navigation affordances being the links.
another topology dis joint from the code topology was the jedit running instance with its own patches and navigation affordances not connected to code.
in the eclipse ide participants sometimes formulated a foraging goal while in one topology but had to fulfill the goal in another.
what was missing was a way for participants to easily navigate between related patches from one topology to another.
research challenge disjoint topologies how to enable developers to navigate through related patches among multi ple disjoint topologies.
this inability to move between topologies in a low cost way pri marily manifested when participants were mapping runtime gui behavior to code.
for example several participants while recreat ing the bug in jedit s running instance formulated the goal of finding the code that was triggered by gui actions.
however after formulating that goal they then had to switch over to jedit s code and start a fresh set of navigations since there was no direct way to go from executing the action in jedit to the code that han dles that action.
instead participants located the relevant code by using search tools by investigating the stack trace or by setting a breakpoint and stepping through code.
fig.
shows one common missing link between the two topologies mapping the delete lines menu action to the deleteline method.
in the above situation participants had to resort to finding the relevant representations of gui elements in the code by navi gating through code which was both costly and unfruitful.
p3 set a breakpoint and then navigated through several frames trying to find information.
p4 chose to trigger an action related to the bug and step through several methods of code to find relevant prey.
p5 simply selected a relevant looking method from the outline view and started to read code.
for jedit there were four disjoint topologies the gui runtime the source code the external menu library and the xml proper ties file.
besides the gui runtime topology and source code to pology jedit uses an external library the third topology to automatically build menus based on the content of an xml prop erties file the fourth topology disjoint from the others.
the prop erties file defined the content of the menus and specified which methods to fire for each menu item.
the disjointness was a source of confusion for participants since many of the methods that were called by menu items had no callers when an open call hierarchy action was used in eclipse.
there are a few beginnings toward addressing the disjoint topolo gies challenge.
for example whyline builds a path just in time to bridge the gap between two topologies from gui output to its relevant source code and sketchlink links sketches to code.
mining approaches like chen and grundy s are also emerging to find relationships among disjoint topologies such as documentation and source code.
however whyline does not scale to a program of jedit s size approaches like chen grundy s do not support navigations per se and few of the approaches we have located handle more than two disjoint topologies.
still these ap proaches provide promising starts upon which to build.
.
.
an open problem the cost estimation problem with developers navigations at table showed about of developers costs were much higher than they had expected.
in essence developers had to navi gate to patches without knowing what it would cost until after they had paid a situation not unlike writing a blank check for the coffeemaker of our earlier analogy.
table s summary of cost related foraging research challenges contributing to these issues reveals a substantive and difficult open problem space analogous to the value estimation problem presented in section .
the cost estimation problem aligning e c with c how to enable developers to more accurately predict the foraging costs they will incur before they incur them.
.
rq3 literature analysis to answer our third research question whether recent trends in software engineering research have begun to address these problems we conducted a literature analysis of papers from three literature repositories.
the first repository was the papers cited in the most recent journal paper surveying se tools that contribute to developers information foraging which included for example tools helping collect information for debugging reuse or infering what a developer seeks and for recommending appropriate resources e.g.
.
the journal paper sampled literature from a wide range of dates so to ensure currency we added two very recent repositories.
thus the second repository was fse papers which was the most recent fse available at the time we began this analysis and the third was icse papers i.e.
the same year as the fse repository.
.
analysis methodology from the resulting papers we selected for detailed analysis all papers that met the following criteria it must describe a tool that supports a software engineering foraging activity the activity must have a before navigation and an after navigation state and the paper or related resources must include infor mation of the navigation choices a developer can make.
we then qualitatively coded the papers that met these criteria based on the description of the foraging activity supported by the paper s tool or by following