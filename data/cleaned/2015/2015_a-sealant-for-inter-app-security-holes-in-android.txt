asealant for inter app security holes in android y oun kyu lee jae young bang gholamreza safi arman shahbazian yixue zhao and nenad medvidovic computer science department university of southern california kakao corporation bloom walk los angeles california usa seongnam gyeonggi korea younkyul gsafi armansha yixuezha neno usc.edu jae.bang kakaocorp.com abstract android s communication model has a major security weakness malicious apps can manipulate other apps into performing unintended operations and can steal end user data while appearing ordinary and harmless.
this paper presents sealant a technique that combines static analysis of app code which infers vulnerable communication channels with runtime monitoring of inter app communication through those channels which helps to prevent attacks.
sealant s extensive evaluation demonstrates that it detects and blocks inter app attacks with high accuracy in a corpus of over real world apps it suffers from fewer false alarms than existing techniques in several representative scenarios its performance overhead is negligible and end users do not find it challenging to adopt.
i. i ntroduction this paper targets a known vulnerability in the design of android s communication model in which components in a single app or across multiple apps communicate by exchanging messages called intents .
inter component communication icc via intent exchange can expose a vulnerable surface to several security attacks including intent spoofing unauthorized intent receipt and privilege escalation .
in these attacks a malicious app sends and receives intents in a way that appears as if those are ordinary message exchanges.
a large volume of research has focused on icc vulnerabilities in android .
however existing detection techniques target only certain types of inter app attacks and or do not support compositional analysis of multiple apps .
the state of the art techniques employ data flow analyses that rely on lists of frequently used android api methods but tend to overlook icc vulnerabilities caused by custom methods.
moreover these analyses have been shown to experience scalability problems when applied on large numbers of apps .
meanwhile the runtime protection techniques suffer from acknowledged frequent false alarms because of the coarse granularity at which they capture icc information.
additionally these techniques assume a degree of expertise in android security .
while certain techniques combine vulnerability detection with runtime protection to aid ordinary end users they also suffer from potentially large numbers of false alarms.
we present sealant security for end users of android via light weight an alysis techniques a technique that aims to enable ordinary end users to protect against inter app attacks.
sealant identifies vulnerable icc paths between a given set of apps inspects each intent sent via those paths at runtime to detect potential attacks and enables end users toblock the intent on the fly.
sealant is distinguished from the existing research because it simultaneously prevents multiple types of android inter app attacks with the current implementation focusing on intent spoofing unauthorized intent receipt and privilege escalation it extends the detection coverage via a novel combination of static data flow analysis and compositional icc pattern matching it causes fewer false alarms than existing techniques through a finer grained characterization of iccs it supports compositional analysis scaling to a number of apps and it integrates static detection with runtime monitoring and control of vulnerable icc paths.
sealant comprises two tools analyzer identifies vulnerable icc paths by performing static analysis on app bytecode interceptor is an extension to the android framework that manages inter app intent exchanges.
we elected to modify android over two other alternatives instrumenting the installed apps bytecode and acquiring administrator privileges i.e.
rooting because once our approach is applied to a device it does not require altering any of the installed apps and rooting itself introduces serious vulnerabilities .
we have evaluated sealant in four different ways.
we assessed its effectiveness via comparative analysis against existing techniques.
sealant suffered from fewer false alarms while blocking the same or greater number of vulnerable icc paths.
we performed a case study targeting analyzer s ability to identify vulnerable icc paths between a set of apps and interceptor s ability to selectively block those paths.
to this end we used a test suite comprising apps.
the test suite includes apps previously identified as vulnerable an opensource testing ground externally developed real world apps that implement inter app attacks and real world apps randomly selected from publicly available sources .
analyzer was able to identify vulnerable icc paths with high accuracy while interceptor was able to capture and block each identified path.
we evaluated sealant s performance by measuring the analysis time of analyzer on different numbers of apps and the resource overhead imposed by interceptor s runtime intent inspections.
analyzer is scalable to a large number of apps while interceptor requires nominal additional resources.
we performed a user study and survey involving android endusers in employing sealant .
overall the users were able to effectively use sealant to block vulnerable inter app intent exchanges and did not find it burdensome to use.
the research we present in this paper is based on our prior work on inter component communication in event based ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
systems ebs .
while this paper focuses explicitly on android sealant can be expanded to other ebs e.g.
with certain modifications.
this paper makes four contributions sealant a technique that enables android users to protect their devices from multiple icc vulnerabilities with a proof of concept implementation focusing on intent spoofing unauthorized intent receipt and privilege escalation analyzer a tool that accurately finds vulnerable icc paths between apps through a novel combination of data flow analysis and compositional icc pattern matching interceptor an android framework extension that automatically detects malicious intents at runtime and enables users to block them and extensive evaluations ofsealant that involve android apps compare sealant to existing alternatives and engage real end users.
section ii illustrates inter app attacks.
section iii describes sealant s architecture section iv its implementation and section v its evaluations.
related work is discussed in section vi and conclusions are presented in section vii.
ii.
m otiv a ting examples in this section we present simplified examples of the three inter app attack types that sealant targets intent spoofing unauthorized intent receipt and privilege escalation .
figure a and listings and depict intent spoofing .
figure a shows component m1from malicious app malapp1 that may send an intent to component v2from victim app vic app1 .
listing shows where vicapp1 s vulnerability resides v2is designed to transfer money to a recipient specified by an incoming intent.
listing illustrates how m1ofmalapp1 sends anexplicit intent that specifies v2as its destination component along with the attacker s account number as the recipient.
this is an example of a vulnerable icc path from m1tov2.
figure b and listing illustrate unauthorized intent receipt .
in android if an intent is broadcast without proper permission restrictions a malicious component can receive it by declaring attributes matching those of the intent.
component v3 ofvicapp2 from figure b is designed to broadcast intents to components in the same app such as v4.
listing shows v3 s code that broadcasts an implicit intent on a click event with the action attribute showlocation and the location information.
although not an intended receiver malicious component m2of malapp2 is able to eavesdrop by listening to showlocation intents and to obtain the user s current location.
this is another example of a vulnerable icc path from v3tom2.
figure c depicts privilege escalation .
component v6 ofvicapp3 provides a sensitive api that is protected with permission p1.
while component v8 ofvicapp4 is granted p1 m3ofmalapp3 is not which means that m3is restricted to directly access the api of v6.
nonetheless m3can still invoke the api in an indirect way via v8which is not protected by any permissions and can be triggered by any component via an explicit intent.
by triggering v8 m3 is able to access the sensitive api of v6 without acquiring p1.
this is an example of a transitive vulnerable icc path from m3 via v8 t ov6.component v3 vicapp2 component v1 malapp1 vicapp1 b unauthorized intent receipt a intent spoofing c privile ge escalation component v2 component m1 component v4 malapp2 component m2 component v5 component v6 component v7 component v8 malapp3 component m3 vicapp4 vicapp3 p1 p1 fig.
inter app attacks listing component v2of vicapp1 1public class v2extends activity 2public void onstart intent i getintent string recipient i.getstringextra recipient string amount i.getstringextra amount usd sendmoneytorecipient recipient amount listing component m1ofmalapp1 1public class m1extends activity 2public void oncreate bundle savedinstancestate intent i new intent i.setclassname com.vicapp1 com.vicapp1.v2 i.addflags intent.flag activity new task i.putextra recipient attackers account number i.putextra amount usd startactivity i listing component v3ofvicapp2 1public class v3extends activity 2public void onclick view v locationmanager m locationmanager getsystemservice context.location service location location m.getlastknownlocation locationmanager.gps provider intent i new intent i.setaction showlocation i.putextra location location.tostring sendbroadcast i the above examples demonstrate that the attacks are administered in a way that does not differ from ordinary intent exchanges between apps.
this makes the identification and restriction of inter app attacks especially challenging.
moreover since an icc can be performed in an essentially invisible way e.g.
via sendbroadcast or through transitive paths it is difficult for end users to recognize when the attacks are actually committed.
an app developer s caution may minimize the risk of the attacks but it requires error prone manual effort while end users may still download other unsafe apps.
although security violations such as these have been studied in computer networks and distributed systems those techniques cannot be directly applied to android due to the specifics of its communication mechanism and features.
for example role based access control has been applied in android as a form of permission grants however it can be violated by privilege escalation attacks.
encryption authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
another popular technique is not a good fit for android due to encryption key distribution issues and limited mobile resources.
meanwhile techniques specifically targeting android have either not focused on these issues or have been unable to adequately resolve them as detailed in sections v and vi.
iii.
sealant this section introduces sealant a technique that automatically identifies vulnerable icc paths between android apps and enables users to control the iccs on those paths at runtime.
sealant recognizes each instance of icc as a relation between a sender a receiver and an intent.
when an intent from a sender component matches an intent that can be received by a receiver component either explicitly or through an intent filter sealant reports an icc relation.
sealant builds an icc graph in which vertices are components and edges are the icc relations.
it then extracts all possible vulnerable icc paths in the icc graph and monitors them at runtime.
when an instance of icc matches one of the extracted vulnerable paths sealant may block it based on the user s choice.
figure shows two key components that comprise sealant analyzer uses static analysis to generate a list of vulnerable icc paths between apps and runs on a user s computer or as an online service interceptor extends android to perform runtime monitoring and enable advanced icc control such as blocking of specific iccs identified by analyzer .sealant s overall process is as follows analyzer processes the apk1files of the installed apps and identifies the vulnerable icc paths between them.
analyzer can optionally contact expert users to confirm specific vulnerable paths that should be monitored.
analyzer feeds the highlighted vulnerable icc paths to the interceptor in a pre defined format sealant list .
at runtime whenever an intent is sent interceptor captures the information of the corresponding icc path e.g.
sender s name from android s activitymanager .
if the captured path information matches one of the vulnerable paths in the sealant list interceptor contacts the end user to determine whether to propagate the intent.
based on the end user s choice interceptor will instruct the activitymanager either to block or to route the intent.
we discuss analyzer and interceptor in more detail next.
a. analyzer analyzer performs static analysis on apk files in four phases analyze target apps build icc graph find vulnerable paths and generate sealant list .analyzer is novel in that it returns multiple types of vulnerable icc paths in a single pass and distinguishes different types of threats which enables tailor made countermeasures.
it does so by focusing both on the data flow between components and on compositional patterns of iccs derived from published literature .
this enables analyzer to identify a larger number of vulnerable paths and path types than existing techniques e.g.
paths involving 1apk is an archive file format that distributes and installs android apps.
2activitymanager is the android component that governs icc.
end user analyzer interceptor app app app application layer framework layer .
.
.
.apk sealant component modified android component .
.
.
.
.
.
sealant list activitymanager end user s device fig.
overview of sealant s operation custom methods .
its summary based model enables analyzing a number of apps at a time as well as reusing prior analysis results when apps are installed updated or removed.
analyze target apps analyzer extracts and summarizes each app s architectural information by analyzing the apk file.
the summary includes components intents intent filters and permissions.
analyzer extracts each component s name package permissions held or required and exported status.
to communicate across apps an android component must have its exported status set to true or contain an intent filter.
analyzer only considers exported components in creating icc graphs.
analyzer extracts each intent s attributes i.e.
target component action categories and data using string constant propagation .
if an attribute s value cannot be determined analyzer conservatively assumes it to be any string.
once extraction is completed analyzer examines each component s vulnerability.
a vulnerable component is the one containing an intra component path between an icc call method and a sensitive method.
an icc call method is a standard android method for sending or receiving intents e.g.
startactivity .
a sensitive method is an android api method that can access sensitive user information e.g.
getlastknownlocation or trigger a sensitive operation e.g.
sendtextmessage .
analyzer identifies the relevant paths by employing a static taint analysis that tracks data flows between methods .
if the direction of an intracomponent path is from an icc call method to a sensitive method analyzer sets the component s vulnerability type to active because the component is vulnerable to attacks such as intent spoofing and privilege escalation .
if the intra component path is from a sensitive method to an icc call method the vulnerability type is passive representing attacks such as unauthorized intent receipt .
in figure b for example the vulnerability type of v3ispassive because the location data directs from getlastknownlocation tosendbroadcast .
if a component has multiple intra component paths analyzer creates separate component models for each path.
by managing a summary based model of each app analyzer is scalable to inspecting a number of apps in a single pass as evaluated in section v c .
furthermore when apps are authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able i attributes of component and intent in icc graph entity attributes description componentname the name of the component pkg the name of the package to which the component belongs vultype the type of vulnerability i.e.
active passive or null vulmeth the name of the sensitive method e.g.
sendtextmessage permuse the name of the permission that the component holds permreq the name of the required permission to access the component intenttarget the name of the component to which the intent is directed intentattr the intent s attributes action category data type and data scheme sender the name of the component which sends the intent senderpkg the name of the package to which the sender component belongs installed or updated subsequent to running analyzer analyzer extracts only the architectural information from the newly updated apps and reuses the prior analysis results on the rest.
build icc graph with the extracted information analyzer builds an icc graph based on the rules from android s api reference documentation .
it defines an edge as a tuple s r i where sis a sender and ra receiver component and iis an intent between them.
component and intent are entities that manage summarized information as shown in table i. since the extraction of architectural information is performed in a conservative way specifically relying on attributes of intents the set of edges may include false positives.
however this will not affect sealant s runtime accuracy because no icc instances to be routed via those edges will ever be initiated.
find vulnerable paths analyzer implements algorithm on the icc graph to identify vulnerable paths.
analyzer marks an edge as vulnerable if it has a vulnerable component at one or both ends or if it forms a particular compositional pattern.
to find vulnerable transitive icc paths analyzer recursively identifies a set of connected edges that can access a vulnerable component by calling the pathfinder method algorithm .
xyindicates attribute yof entity x depicted in table i and x.yrepresents element yin edge x. analyzer first parses edges into two sets inter app iac for edges between components belonging to different apps and inter component icc otherwise.
algorithm iterates over each edge einia c icc lines and considers four different cases that cover all types of vulnerable paths we target in this paper the first two cases identify paths that involve vulnerable components the latter two cases identify paths based on previously identified compositional patterns .
case line occurs when edirects to a receiver vertex whose vulnerability type is active .i f eis an iac edge algorithm determines the type of attack by calling permcompare c1 c2 m line a method that returns the type of attack by comparing the permissions of components c1and c2 where mis a sensitive method that forms an intracomponent path with an icc call method within c2.i fc2holds a permission that c1does not and the permission is required to use m permcompare returns privilege escalation otherwise it returns intent spoofing .
once the type of attack is determined algorithm adds e to the set vulp aths that contains all detected vulnerable icc paths line and thenalgorithm identifying vulnerable icc paths input g an icc graph output vulp aths a set of vulnerable paths 1let ia c be a set of iac edges in g 2let icc be a set of icc edges in g 3let sbe a sender component 4let rbe a receiver component 5foreach e ia c icc do s e.sender r e.receiver if rvultype active then ife ia c then add e permcompare s r rvulmeth to vulp aths pathfinder s r e else if svultype passive and e ia c then add e unauthorized intent receipt to vulp aths else if e ia c then foreach g icc do if r g.receiver then add e intent spoo f ing to vulp aths else if s g.sender e.intent g.intent then add e unauthorized intent receipt to vulp aths algorithm pathfinder input s r component e a list of distinct edges output updated vulp aths 1foreach f ia c icc do if f.receiver s and e e e.receiver negationslash f.sender then append f to e if e e e ia c then add e permcompare f.sender r rvulmeth to vulp aths pathfinder f.sender r e 7remove the last element o f e calls pathfinder to identify transitive icc paths line .
as depicted in algorithm pathfinder iterates over each edge f ia c icc to check if fconnects to the previously identified edge s sender component s and if f s own sender is a newly visited component line .
if so pathfinder appends fto the list of distinct connected edges e line .
if econtains an inter app edge e ia c pathfinder determines the type of attack by calling permcompare and adds etovulp aths line .pathfinder recursively identifies other components that are connected to a vulnerable component through edges in the icc graph.
it stops its processing when it visits all transitively connected components to the original edge s receiver ror reaches an already visited component.
when it finishes iterating pathfinder removes the last element from eto enable correct exploration of additional transitive paths.
case lines in algorithm deals with the situation when the vulnerability of e.sender ispassive and e ia c which may result in leaking sensitive information between apps through e. if so the type of attack is set to unauthorized intent receipt and e is added to vulp aths line .
case lines occurs when edges e ia c and g icc e negationslash g both lead to the same receiver vertex.
it represents a pattern of attack in which gis an intended access to rwithin an authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
app but emay be a spoofed access from a malicious component across apps.
in this case the type of attack is set to intent spoofing and the edge e is added to vulp aths line .
case lines occurs when edges eand gshare the same sender and intent.
if grepresents an originally intended receipt within the app and ean unintended receipt across apps algorithm will set the type of attack to unauthorized intent receipt and append e tovulp aths line .
generate sealant list as the last step analyzer generates the sealant list based on vulp aths the output from the previous phase.
analyzer first normalizes the output by checking for redundant paths.
it then transforms the information about identified paths into a pre defined format that is compatible with sealant sinterceptor component.
b. interceptor interceptor monitors and analyzes each instance of icc.
whenever an icc is requested interceptor checks whether it is specified in the sealant list .interceptor s icc control strategy is distinguished from competing techniques due to its finer grained characterization of icc paths based on sender receiver and intent.
as evaluated in sections v a and v b this increases the accuracy in blocking iccs.
interceptor resolves two challenging issues extracting each component s information at runtime to effectively prevent malicious iccs while minimizing the impact on android s functionality.
interceptor captures a sender component s information by instrumenting the framework level class of each type of component e.g.
activity in the android framework while it captures an intent s and a receiver s information by extending a core component that governs intent routing i.e.
activitymanager .interceptor minimizes the impact on android by avoiding removal of standard components or modification of core methods further discussed in sections iv and v c .
interceptor s architecture interceptor extends the android framework with four components as depicted in figure .
three components blocker choicedatabase and listprovider are newly added while one activitymanager is a modification of an existing android component.
blocker interacts with end users and performs interceptor s core functionalities monitoring matching and blocking.
malapp1 component m1 ... startactivity intent i ... application layer framework layer intent i from who send what to whom component v2 ... onstart ... end user block intent i interceptor component modified android component vicapp1 listprovider .
.
.
.
.
.
choicedatabase blocker class activity ... startactivity intent i ... activitymanager .
fig.
the architecture and operation of interceptorblocker directly communicates with activitymanager to obtain the detailed information of each instance of icc and to possibly induce activitymanager to block a particular instance of icc.
blocker imports the sealant list from listprovider and refers to the previously made choices from choicedatabase .
activitymanager controls every instance of icc processed through the android framework by collaborating with other android components e.g.
packagemanager .
we extended activitymanager to capture the information of each icc instance sender and receiver components and intent s attributes share the information with blocker and block a particular instance of icc upon blocker s request.
choicedatabase stores end user choices to block or route for each vulnerable icc path.
stored choices are automatically applied when the same icc is requested and can be removed upon end user s request.
when a new sealant list is imported choicedatabase expunges only the choices that correspond to the updated or removed apps.
finally listprovider imports and maintains the sealant list .
when a sealant list is installed in the pre defined space of the user device e.g.
external sd card listprovider imports it and maintains the specified information as a permanent condition until a new sealant list is introduced.
interceptor s operation figure illustrates the interaction among interceptor s four components.
for clarity the depicted six step scenario is based on the example from listings and but it is reflective of interceptor s operation in general.
when m1 ofmalapp1 tries to send intent iby calling startactivity request is routed to activitymanager .
activitymanager extracts sender s i.e.
m1 s information and searches for components permitted to receive intent i. if a receiver is identified i.e.
v2 ofvicapp1 activitymanager passes the icc information to blocker .
after receiving information about the icc blocker first examines choicedatabase .
if a choice for the icc already exists blocker induces activitymanager to act block or route the icc without engaging the end user.
in case no corresponding choice exists in choicedatabase blocker scans the sealant list provided by listprovider .
if the information about the requested icc matches that in thesealant list blocker will give the user four options allow the icc once block it once allow it always and block it always.
if the user selects options or her choice will be stored in choicedatabase .
if the end user chooses to allow resp.
block the requested icc blocker will instruct activitymanager to send intent itov2 resp.
trap it .
interceptor s strategy for blocking iccs interceptor is engaged between the times when an intent is first requested and when it is actually dispatched to its destination.
interceptor s operation may thus cause a delay in processing intents which may be exacerbated by the number of vulnerable icc paths in thesealant list .
however since android s icc is performed via asynchronous api calls we hypothesize that this delay will not significantly impact the system s operation.
in section v c we empirically evaluate interceptor s performance overhead.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in case when an end user has blocked a requested icc the apps that are involved in the icc will not get any response to their request back from the framework.
since android implements iccs asynchronously those apps will simply skip the corresponding operation without causing runtime crashes.
to block a vulnerable transitive icc interceptor begins by matching the first path of the vulnerable transitive icc path and setting its transitive flag totrue .
this flag is managed per each vulnerable transitive icc path and remains true as long as the subsequently requested iccs match the subsequent paths in the vulnerable transitive path.
once the last path of the vulnerable transitive icc path is reached interceptor alerts the end user and resets transitive flag tofalse .
in the example from figure c let us assume that the vulnerable transitive icc path m3 v8 v6 is in the sealant list .i fm3 launches v8 via an intent interceptor will set transitive flag totrue .
then if v8launches v6 via an intent interceptor will alert the user and reset the flag.
iv .
i mplement a tion we have implemented sealant sanalyzer as a stand alone java application that receives as input a set of android apps in apk files and exports a sealant list in the pre defined xml format.
analyzer s implementation combines approximately newly written loc with three off the shelf tools.
the tools are used in the first of analyzer s four phases recall section iii a .analyzer integrates two static analysis tools ic3 and covert to extract architectural objects from apps.
we employed both tools because neither of them alone discovers all of the needed information ic3 misses outbound intents in certain scenarios while covert only returns coarse grained intent information that excludes certain attributes e.g.
data type .
analyzer orchestrates the two tools together and combines their outputs in order to generate a more complete list of architectural objects.
in identifying intra component paths between icc call methods and sensitive methods analyzer uses flowdroid a highly precise intra component taint analysis tool for android.
we implemented sealant sinterceptor on top of android open source project aosp .
.
kitkat which is the most popular version of android today.
we directly modified the source code of several standard android components including activitymanagerservice activitymanagernative and intentfirewall .
in total we introduced about loc spread over classes.
to minimize the impact on the original functionality of android we did not remove any standard components or methods.
our modification was limited to parts of android that are usually a layer beneath manufacturers customizations and can easily be applied to android versions .
and later without significant changes.
we were able to successfully run interceptor s system image both on the android emulator and on a google nexus device.
since framework level components in android do not provide a user interface ui we also implemented an android app that provides a ui to perform pushing the sealant list from an external sd card to interceptor slistprovider removing the list from listprovider and removing previous choices from interceptor schoicedatabase .
running sealant requires compiling interceptor s source code with the provided drivers and installing the image files using the freely available android debug bridge and fastboot .
this cost can be minimized by bundling sealant with android.
sealant s code required drivers and compiled tools are available at .
v. e v alua tion we evaluate sealant for effectiveness section v a accuracy v b performance v c and usability v d .
a. effectiveness to the best of our knowledge two existing works share sealant s goal of providing protection of end users from inter app attacks separ previously named droidguard and xmandroid .
separ identifies vulnerable surfaces of a set of apps via static analysis and uses dynamic memory instrumentation that hooks the method calls of target apps at runtime.
for example in the scenario from figure a sep ar would identify the vulnerability of v2and hook the startactivity method that sends an intent to v2.
xmandroid is a technique that only targets privilege escalation attacks by leveraging an extension to android.
xmandroid enables a user to pre define a list of icc restriction policies and automatically blocks iccs that match any of those policies.
an ideal comparison of sealant against these two techniques would have included executing their implementations in a controlled setting and or on a set of real world android apps.
however the implementation of xmandroid we obtained from its authors only runs on a prior version of android .
.
while the current prototype implementation of separ is missing certain features covered by the underlying technique e.g.
the policy enforcement module .
in section v b we do evaluate sealant directly against one of the implemented features of separ.
we tried unsuccessfully to build an installation of xmandroid on several recent versions of android.
given the changes in android since .
.
continuing with this strategy proved impractical.
for these reasons we decided to analytically compare the three techniques relying on the published algorithms of sep ar and xmandroid .
comparison with separ a detailed comparison of sealant and separ using probabilistic random variables to capture their respective operations can be found at .
here we provide a summary of that analysis.
sealant raises fewer false interapp attack alarms compared to sep ar because sep ar does not support a finer grained characterization of icc paths i.e.
sender receiver and intent .
for example in the scenario depicted in figure a whenever an explicit intent is routed tov2 separ would raise an alarm even if the intent was sent from the component in the same app i.e.
v1 .
comparison with xmandroid sealant suffers from fewer false negatives than xmandroid.
the detection mechanism of xmandroid requires a user to explicitly specify policies authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able ii applying sealant on the apps in our core test suite attack type of test suitenumber of apps vulnerable icc paths identified icc paths precision recall block ed icc paths precision recall vulnerable malicious trick direct transitive sep ar icct a analyzer interceptor is .
.
.
.
.
.
.
.
uir .
.
.
.
.
.
.
.
pe .
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
is intent spoofing uir unauthorized intent receipt p e privilege escalation .
indicating the types of inter app attacks she wishes to detect and icc paths to monitor at runtime.
this may omit critical interapp attacks.
recall the privilege escalation attack scenario from figure c .
when component m3inmalapp3 requests an icc to access v8invicapp4 xmandroid inspects the permissions ofmalapp3 andvicapp4 based on the pre defined policies.
although a few general policies for xmandroid have been proposed they do not cover all vulnerability scenarios.
in the above scenario if a user specified policy does not prohibit an icc between an app with permission p1and another app without it xmandroid will not raise an alarm.
since sealant inspects all icc paths via static analysis to identify vulnerable paths it does not suffer from this type of false negative.
sealant also suffers from fewer false positives than xmandroid.
xmandroid finds iccs that match policies specifying the sender and receiver permission combinations.
however this would also block safe iccs initiated by a benign app with an identical set of permissions as a malicious app.
suppose that xmandroid has a policy that would block iccs between malapp3 andvicapp4 in the scenario depicted in figure c and the device had another app benignapp which is confirmed as reliable and holds identical permissions to malapp3 .
in that case even if benignapp initiated an icc to a method of vicapp4 that does not require p1 xmandroid would block that icc.
sealant would not trigger such a false alarm.
b. applicability and accuracy we evaluated analyzer s accuracy in identifying vulnerable icc paths by comparing its results against those of sep ar and iccta state of the art tools for icc vulnerability detection .
we evaluated interceptor s ability to block vulnerable icc paths at runtime.
we used a test suite of android apps in total.
experimental setup to build our test suite we first selected several real world apps that are vulnerable to inter app attacks.
among the apps that were previously identified from repositories such as google play f droid malgenome and bazaar we selected that are exposed to the three types of attacks sealant targets.
we also included six apps from droidbench .
an app collection for benchmarking icc based data leaks.
since several of the vulnerable apps did not have readily available malicious apps targeting them we built malicious apps each of which performed one inter app attack.
to mitigate internal threats to the validity of our results we also asked graduate students at university of southern california usc to build sets of apps that implement inter app attacks based on published literature .
each of those sets was either a pair of apps forming a simple path or a trio of apps forming a transitive path.
each set consisted of at least one vulnerable app andat least one malicious app that exploits the vulnerable app.
without any intervention by the authors the students built distinct sets.
this yielded apps in total of which were new while were modified and unmodified apps obtained from public sources .
in total this yielded sets containing apps with vulnerable icc paths and vulnerable transitive icc paths.
to ensure that inter app attacks can be actually launched we manually inspected the code of each set and installed and ran the set on a google nexus .
we confirmed that the attacks from the malicious apps were successfully launched and exploited the vulnerable apps by observing the apps behavior via the device s ui and via logcat a native android tool for monitoring system debug outputs .
our test suite also includes trick apps containing vulnerable but unreachable components whose identification would be a false warning.
we divided this core test suite into three different groups based on the type of attack to which a vulnerable app is exposed as shown in table ii.
subsequently we created an expanded test suite totaling apps by including another apps randomly selected from google play and malgenome .
evaluation of analyzer we evaluated sealant s analyzer for accuracy in identifying vulnerable icc paths as compared to sep ar and icct a. we used our core test suite to measure all three approaches precision i.e.
identified icc paths that were actually vulnerable and recall i.e.
the ratio of identified to all vulnerable icc paths.
as depicted in table ii analyzer detected vulnerable icc paths with precision and of recall.
it was unable to correctly extract intent information in three cases due to the inaccuracies inherited from ic3 and covert recall section iv .
analyzer correctly ignored all trick cases with unreachable vulnerable paths.
sep ar had precision and recall.
this is primarily because sep ar was designed to identify vulnerable components or interfaces rather than specific icc paths between them and to return an icc path only when both sender and receiver contain sensitive android api methods hampering its applicability in cases such as privilege escalation via a transitive icc.
iccta had precision and recall.
since it targets a single type of attack privacy leaks iccta also returned an icc path only when it involved sensitive api methods .
although sealant outperformed sep ar and icct a in our evaluation it is important to note that sep ar and icct a support both intraand inter app analysis and may detect additional vulnerabilities that sealant does not.
we then used our expanded test suite of apps components icc paths .
we created non overlapping bundles each comprising apps randomly selected from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able iii analyzer s performance on different num.
of apps number of apps avg.
number of components .
avg.
number of iccs .
.
.
avg.
analysis time sec.
.
.
.
.
the suite.
we created app bundles because this number is higher than the recently cited number of apps an average smartphone user regularly uses each month .
we ran all three tools on each bundle and manually checked if each identified icc path is indeed vulnerable.
analyzer flagged icc paths with precision.
the six false positives were caused by ic3 s inaccuracy in identifying intents and covert s omission of intent attributes in certain scenarios.
sep ar and icct a were unable to analyze the bundles on four different hardware configurations.
sep ar s logs indicated that it was unable to generate flow analysis results in some cases while it did not return any vulnerabilities in other cases.
icct a invariably crashed it was unable to analyze more than one app at a time in more than of our attempts.
evaluation of interceptor we evaluated interceptor s accuracy in detecting and blocking malicious iccs at runtime.
to monitor all iccs exchanged on a device we integrated a logging module that outputs information of each icc instance via logcat into activitymanager recall section iii .
we installed the apps in our core test suite on a google nexus with interceptor set up ran analyzer on the device and provided the resulting sealant list tointerceptor .
to run test scripts that trigger iccs we used monkeyrunner an android tool for running test suites.
we designed each script to trigger one type of vulnerable icc in the sealant list as well as various benign iccs.
we configured the scripts to choose to block an icc when interceptor prompts for a blocking choice.
we repeated executing each script until we accumulated blocked iccs.
at the end of each test script execution we manually inspected the logs in order to measure precision i.e.
if all blocked iccs corresponded to vulnerable paths specified in the sealant list and recall i.e.
if interceptor allowed any icc attempts over the vulnerable paths.
interceptor was able to block vulnerable iccs in the core test suite with perfect precision and recall see table ii .
c. performance evaluation of analyzer to evaluate the performance of analyzer we used a pc with an intel dual core i5 .7ghz cpu and 4gb of ram.
we divided our expanded test suite into four categories with different numbers of apps and .
for each category we created ten different bundles randomly selected from the apps and ran analyzer on each bundle.
on average extracting architectural information from each app took .95sand identifying vulnerable icc paths took .08s per app.
while the extraction is relatively time consuming in scenarios where an app is newly installed or updated analyzer reuses the previously extracted app models to minimize the execution time.
it performs the extraction only on the new app and then runs the vulnerable path identification over all apps.t able iv differences in execution times in milliseconds mean min max std dev inter ceptor .
.
.
.
aosp .
.
.
.
difference .
.
.
.
table iii shows the average numbers of components and iccs in each category.
since our approach manages an individual summary based model of each app the analysis time scales linearly with the number of apps.
evaluation of interceptor to evaluate interceptor s impact on performance we measured the differences in execution times between android with interceptor and without it in the remainder of this section referred to as interceptor and aosp respectively .
we configured the two environments to be highly similar and to reasonably reflect the real world.
we employed the google nexus in both environments and configured both to use android kitkat .
.
.
we installed the most popular third party apps on the devices.
to observe interceptor s worst case performance overhead we manually created a sealant list that would induce the longest execution time.
the list contained paths amounting to of the installed apps none of which matched the actual icc paths between the installed apps.
this maximized the overhead of interceptor s detection operation which sequentially matches an icc to each path in its list.
the above numbers were selected because they reflect in fact surpass those found in the real world an average user regularly uses about apps per month and around of android apps are vulnerable to inter app attacks .
to trigger a large number of iccs on the test devices we used monkey which generates pseudo random streams of user and system level events on a target device.
we used the same seed value in interceptor and aosp so that monkey would generate identical event sequences in both environments.
we injected events in each environment and measured the time it took to process each event.
we repeated this five times to mitigate the impact of conditions such as battery status changes.
table iv describes the results we obtained.
the difference in mean execution times was less than 1ms and in maximum execution times under 40ms.
differences of this degree are negligible because the threshold at which an end user begins noticing slowdown in mobile app response is 200ms .
interceptor introduces low overhead because it simply extends an existing operation that aosp already regularly performs to match a requested icc with the list of paths on the device .
d. usability when an intent exchange matches a vulnerable icc path sealant requires the end user to either block or allow the exchange in order to secure her device.
to assess how challenging such choices are for end users we conducted a user study and a survey guided by two hypotheses h1 the intent exchange control choices sealant requires an end user to make are not more difficult than the choices required of end users by stock android.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able v difficulty confidence and response time per dialog type dialog typeuser study survey difficulty confidence response time difficulty confidence n x s n x s n x m s n x s n x s type .
.
.
.
.
.
.
.
.
.
.
type .
.
.
.
.
.
.
.
.
.
.
type .
.
.
.
.
.
.
.
.
.
.
type .
.
.
.
.
.
.
.
.
.
.
type .
.
.
.
.
.
.
.
.
.
.
n num participants.
x mean.
m median.
s std deviation.
difficulty and confidence values are on point likert scales very difficult very easy not confident at all fully confident .
response time values are in seconds.
the type row presents merged data from type through type rows.
h2 a non expert user can make intent exchange control choices that prevent an inter app attack most of the time .
experimental setup our user study and survey were designed to simulate situations in which users make choices reflective of daily android use e.g.
whether to install an app after being shown the list of permissions it requires .
among those choices we also inserted choices required by sealant .
we asked the participants how difficult it was to make each choice and how confident they were in making the choice.
the study included participants all graduate students at usc recruited via an e mail list.
the students majors spanned engineering communication business and social work.
the background survey showed that the participants had used a mobile device for months on average.
of the participants reported android as their primary mobile platform or one they had experience using had not used android previously.
participants were aged between and and the remaining between and .
we provided each user study participant a google nexus with sealant pre installed.
they were presented with a series of common scenarios of four different types type a dialog asks the user whether to install an app randomly selected from a credible source google play given the list of permissions the app requires.
type same as type but with apps randomly selected from an unreliable source.
type intent matches multiple filters.
android displays a dialog so the user can choose which app to use.
type a dialog prompts the end user to make a choice to block or allow a vulnerable inter app access.
we used native android dialogs in of the scenarios type and in the remaining we used sealant s customized dialog type that presents the sender receiver apps names the identified attack type and block allow and always buttons among which the end user must choose.
half of the apps used in type scenarios were selected from apps used in type and the other half from type scenarios.
during the study we logged every interaction between a participant and the device via logcat .
at the end of each scenario we asked participants to assess the scenario s difficulty and confidence in their choices using a point likert scale.
in order to expand our dataset we designed the online survey in the same manner as the user study.
we took screenshots of what a user would see on her device as she went through the scenarios presented the screenshots to the survey respondents and prompted them to make the corresponding choices.we sent out survey requests and received valid responses people did not respond or only partially completed the survey.
we sent requests to known e mail lists and contacts and allowed them to self select.
the respondents had used a mobile device for months on average.
named android as their primary mobile platform or had experience using it.
the survey covered a range of age groups and occupations.
respondents were aged were were were and were .
respondents included students medical doctors business people housewives software engineers professors retailers lawyers and others .
more detailed information about the user study and survey is available at .
results we evaluate hypotheses h1 and h2 using the user study and survey data.
for simplicity we refer to the user study participants and survey respondents as participants .
h1 we compared the difficulty perceived by participants in making their choices the confidence participants had in their choices and the time it took to make choices for native android dialogs type and sealant dialogs type .
table v presents the data we obtained.
a comparison of the mean degrees of difficulty showed that they did not differ significantly between the two groups of scenarios student s t test p value .
for user study and .
for survey .
a comparison of the mean degrees of confidence yielded the same conclusion student s t test p value .
for user study and .
for survey .
finally the median response time was significantly lower for type than for type scenarios the mann whitney wilcoxon test p value .
.
these results support the conclusion that sealant s intent exchange control choices are not more difficult than those of stock android.
h2 we measured the proportion of instances in which a participant elected to block an intent exchange and prevent an attack in a type scenario.
in general users may deliberately allow vulnerable intent exchanges e.g.
a user trusts both apps .
however in our study unbeknownst to the users we only included paths actually leading to exploits allowing us to know the correct behavior.
recall that one half of the apps in the type scenarios came from reliable and the other half from unreliable sources.
in the combined type credible apps andtype unreliable apps scenarios participants chose to cancel installation of the time.
that tendency halting an on going activity to avoid security threats was much higher fortype scenarios.
the user study participants chose intent blocking of the time while survey participants authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chose blocking of the time.
participants were thus able to make intent exchange choices that did not lead to inter app attacks at a much higher rate than their average behavior.
e. threats to v alidity our user study participants were students.
to address any resulting bias we additionally conducted the survey whose respondents spanned a variety of ages and occupations.
the survey merely emulated a mobile environment possibly influencing the participants choices.
as a mitigation we carefully described each scenario to provide the participants with the context they would have had if they had used an actual device.
we also separately analyzed the user study and survey results and both support our conclusions.
lastly the participants elected to allow a fair portion of the vulnerable iccs in cases we designed blocking to be the appropriate choice.
while we consider the users choices to block the rest of iccs that would otherwise have remained uncaught without sealant as a positive result this indicates that improvements may be possible with regards to how sealant presents the vulnerable iccs to end users.
vi.
r ela ted work approaches that target android s vulnerabilities use program analysis icc analysis and or policy enforcement.
program analysis is employed by several approaches .
comdroid categorizes vulnerabilities in inter app communication and detects vulnerabilities in target apps via static analysis.
flowdroid provides intracomponent taint flow analysis.
chex leverages data flow analysis to discover component hijacking vulnerabilities.
unlike sealant these techniques mainly focus on individual apps.
icc analysis is the focus of another body of research .
epicc and ic3 statically extract information from android apps for icc aware analyses.
didfail uses taint flow analysis to locate sensitive inter app data flows but targets only activity components and neglects intents data scheme.
amandroid identifies privacy leaks by tracking components interactions but has been shown to work incorrectly on content provider components and certain icc methods.
iccta is a taint flow analysis targeting privacy leaks.
while instrumenting source code to resolve the connections between components does improve its precision it does not target other types of inter app attacks.
covert introduces a compositional analysis of inter app vulnerabilities especially against permission leakage.
it does not target other types of inter app attacks or handle intents data scheme.
these approaches detect but do not protect against icc vulnerabilities.
policy enforcement in android is explored via app code instrumentation android framework extension and dynamic memory instrumentation .
aurasium enforces arbitrary policies by interposing code into the target app.
droidforce enforces custom data centric policies by instrumenting an app s bytecode.
while rewriting apps can be effective incomplete implementations of bytecode rewriting results in a number ofpotential attacks .
since repackaging assigns a different signature to a target app it can also no longer be updated by the original issuer.
saint extends android to enable control of an app s behavior via app provider s policies.
xmandroid also extends the monitoring mechanism of android to prevent applevel privilege escalation attacks based on permission based policies.
asm provides an api that enables enforcement of app specific security requirements.
end users typically lack expertise in devising policies and have to rely on general policies written by experts.
by contrast sealant provides finer grain protection by automatically generating and enforcing what amounts to target specific policies for a set of apps.
deepdroid provides enterprise policy enforcement by applying dynamic memory instrumentation i.e.
rooting to android s runtime environment.
separ automatically synthesizes security policies which it also enforces through dynamic memory instrumentation.
rooting may introduce vulnerabilities and compatibility issues on custom rom .
vii.
c oncluding remarks sealant is an integrated technique that monitors and protects icc paths through which android inter app attacks can take place.
sealant s combination of static and dynamic analysis improves upon existing techniques in automatically identifying the vulnerable icc paths between a set of apps monitoring each instance of icc to detect potential attacks and empowering end users to stop the attacks.
our evaluation demonstrates sealant s effectiveness efficiency accuracy scalability and usability.
notably we have shown that sealant outperforms existing alternatives in blocking interapp attacks and can be applied in real world scenarios with a negligible performance overhead and a minor adoption barrier.
several avenues of future work remain.
analyzer shares two limitations of static analysis tools it leverages i.e.
ic3 covert and flowdroid .
first reflective calls are resolved only when their arguments are string constants.
to this end we will explore reflection analysis techniques .
second incomplete models of native methods and dynamically loaded code can cause unsoundness in our results.
this can be remedied by leveraging additional sources of vulnerabilities and dynamic analysis techniques .
inter app attacks can also be launched via covert channels in the android core system components and via kernel controlled channels e.g.
confused deputy attacks over a local socket connection or collusion attacks over the file system .
we can counter such attacks by combining our solution with kernel level solutions e.g selinux and flaskdroid .
another direction for our work is to feed end users choices into a statistical model to provide more specific guidance.
eventually we can incorporate these techniques in designing applications .
viii.
a cknowledgments we appreciate the reviewers helpful comments and the contribution of ruhollah shemirani in evaluating an earlier prototype of sealant .
this work is supported by the u.s. national science foundation under award number .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.