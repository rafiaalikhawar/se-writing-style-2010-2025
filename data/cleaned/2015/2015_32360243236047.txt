automated patch extraction via syntax and semantics aware delta debugging on source code changes masatomo hashimoto chiba institute of technology narashino chiba japan m.hashimoto stair.centerakira mori national institute of advanced industrial science and technology ikeda osaka japan a mori aist.go.jptomonori izumida iij innovation institute chiyoda ku tokyo japan tizmd iij.ad.jp abstract delta debugging dd is an approach to automating debugging activities based on systematic testing.
dd algorithms f ind the cause of a regression of a program by minimizing changes between a working version and a faulty version of the program.
however it is still an open problem to minimize a huge set of changes while avoiding any invalid subsets that do not result in testable programs especially in case that no software con f iguration management system is available.
in this paper we propose a rule based approach to syntactic and semantic decomposition of changes into independent components to facilitate dd on source code changes and hence to extract patches automatically.
for analyzing changes we make use of tree differencing on abstract syntax trees instead of common differencing on plain texts.
we have developed an experimental implementation for java programs and applied it to bug f ixes from defects4j and real life regression bugs from open source java projects.
compared to a dd tool based on plain text differencing it extracted patches whose size is reduced by at the cost of more test executions for the former dataset and by at the cost of more test executions for the latter both on average.
ccs concepts software and its engineering software testing and debugging software reverse engineering software evolution keywords software regression delta debugging tree differencing acm reference format masatomo hashimoto akira mori and tomonori izumida.
.
automated patch extraction via syntax and semantics aware delta debugging on source code changes.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa 12pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro f it or commercial advantage and that copies bear this notice and the full citation on the f irst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci f ic permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn ... .
introduction debugging is still a demanding manual task that relies on experience and intuition in general.
there have been a number of studies on automated debugging focusing on activities such as identifying program statement s responsible for the failure understanding the root cause of the failure and determining how to modify the code to remove the root cause .
delta debugging dd pioneered by zeller is an approach to automating the debugging activities based on systematic testing.
it resolves regression causes automatically and effectively.
dd algorithms f ind the cause of a regression of a program by minimizing changes between a working version and a faulty version of the program.
zeller demonstrated dd for narrowing down changed gdb lines to a single failure inducing change relying on line by line differencing .
dd is distinguished from the prior approaches by its ability to handle interference inconsistency granularity and non monotony a combination of several individual changes may be responsible for a failure while each of the changes is not interference there may also be combinations of changes that do not result in a testable program inconsistency a single logical change may affect several hundred or even thousand lines of code but only a few lines may be responsible for the failure granularity a change set may not fail even if it contains a change that causes a failure non monotony .
however it is still an open problem to minimize a huge number of changes while coping with inconsistency in case that no software con f iguration management system is available.
suppose that we naively perform dd on a huge number of hunks obtained by comparing program versions with extensive modi f icaton gaps in between by using an ordinary line by line diff tool.
then due to dependencies between the hunks we would frequently fail to build the variants derived from the original program by applying the possible subsets of the hunks.
zeller suggested in his pioneering work using syntactic or even semantic criteria in order to group changes based on the affected entities such as statements functions and modules.
the basic idea was to group changes applied to a program by the following steps construct a couple of program dependence graphs pdgs for a working version and for a faulty version of the program for each change and each pdg construct the forward static slice from the nodes affected by the change group changes by the common nodes contained in their respective slices.
unfortunately however static slices can be overly conservative and therefore tend to grow quickly .
thus grouping changes based on their relevant static slices would result in a single large esec fse november lake buena vista fl usa m. hashimoto et al.
group in the worst case.
on the other hand dynamic slices can be precise since they are computed for speci f ic program executions.
however we cannot rely on them to group changes since they can tell us nothing about the dependencies between portions that are not executed while producing all possible executions is infeasible in practice.
in order to overcome the problem we propose a rule based approach to syntactic and semantic decomposition of changes into independent components to facilitate dd for minimizing source code changes and hence for extracting patches automatically.
given two versions v1andv2of a program we model them as abstract syntax trees asts instead of plain text documents.
then the set of changes between the versions is decomposed through the following steps comparing v1with v2by using an ast differencing algorithm generating ast delta consisting of atomic tree hunks that operates on ast nodes based on the result of the ast differencing and grouping tree hunks syntactically and semantically based on a set of rules that describe dependencies between tree hunks by exploiting syntactic and semantic information embedded in the asts.
once changes are decomposed into individual components we can apply dd algorithms on the components.
furthermore we accelerate the dd process by way of staging which is achieved by exploiting dependencies between tree hunks and the hierarchical structure of ast delta in a similar way to hierarchical delta debugging hdd .
we have developed an experimental implementation of a dd system for java programs based on the proposed method and applied it to bug f ixes from defects4j dataset and real life regression bugs from open source java projects.
the remainder of the paper is organized as follows.
section 2reviews an ast differencing method that we employ.
then a method of generating decomposable ast delta is presented in section .
after an overview of syntactic and semantic decomposition of ast deltas is given in section section 5brie f ly explains staged dd.
section 6details experiments conducted for evaluating our method of patch extraction.
after related work and threats to validity are reviewed in sections 7and8 section 9concludes the paper.
ast differencing figure 1illustrates an overview of our method of ast differencing.
first asts are obtained by parsing the source f iles prog1 andprog2 .
then the tree differencing engine compares the asts to generate an ast delta ordelta for short.
finally the delta is converted into xml delta description xdd format.
the delta can be applied to prog1 to reproduce prog2 .
moreover an arbitrary part of the delta can produce an intermediate version between prog1 andprog2 which will be explained later.
based on a structural change analysis tool diff ts we have designed and implemented the delta generation mechanism.
we begin with reviewing diff ts s way of representing a difference between asts that is an edit sequence .
figure ast differencing.
!
!
!
figure tree edit operations.
!
!
.
figure a tree mapping.
.
edit sequence an ast is naturally modeled by a rooted labeled ordered tree.
in the remainder of the paper we mean a rooted labeled ordered tree by a tree unless otherwise speci f ied.
for trees t1andt2 we calculate an edit sequence that transforms t1intot2.
an edit sequence consists of four kinds of edit operations delete insert relabel and move all of which operate on ast nodes.
the f irst three operations are illustrated in figure .
bydelete 1xo xis removed and the children ofxbecome the i th and 1i n 1o th children of prespectively.
byinsert 1p i n xo the i th and 1i n 1o th children of pare removed from pto become the children of x and xbecomes the i th child of p. by relabel 1x l0o the label of xis changed into l0 where we denote that xhas a label lby x l .
the last operation move is the composition of delete andinsert move 1p i n xomeans delete 1xothen insert 1p i n xo.
.
tree mapping lett1andt2be trees and sbe an edit sequence that transforms t1 intot2.
byn1towe denote the set of nodes contained in t. then by removing deleted inserted or moved nodes by s we obtain a tree mapping m n1 t1o n1 t2owhich satis f ies the following conditions v.alt1 w1iff v.alt2 w2 v.alt1is an ancestor of w1iff v.alt2is an ancestor of w2 and v.alt1is to the left of w1iff v.alt2is to the left of w2 599automated patch extraction via syntax and semantics aware dd... esec fse november lake buena vista fl usa for any v.alt1 v.alt2o mand 1w1 w2o m. in other words a tree mapping is a one to one partial mapping that preserves ancestordescendant relationships and sibling relationships.
figure 3depicts a tree mapping where dashed lines designate the elements of the mapping.
note that the untouched or the relabeled nodes are contained in the mapping while others are not cis deleted afii10069.italis inserted andhis moved.
we call nodes in a tree mapping mapped nodes .
.
optimizing edit sequences for each pair of trees t1andt2 there exist trivial edit sequences which correspond to the empty tree mapping that removes all nodes int1and then adds all nodes in t2.
to quantitatively evaluate an edit sequence we compute the edit cost of it.
given a cost value for each edit operation the edit cost of an edit sequence is obtained as the sum of the costs of the operations contained in the sequence.
if we exclude the move operations there are several tree differencing algorithms that f ind optimal edit sequences in terms of edit cost.
however such algorithms are quasi quadratic at best in time complexity and quadratic in space complexity hence are inefficient for large trees that contain tens of thousands of nodes such as asts derived from thousands of source lines of code.
note that f inding optimal edit sequences containing move operations is known to be np hard .
while diff ts is based on an optimal tree differencing algorithm it has achieved good processing speed and precision needed for investigating large scale software projects by employing tree decomposition subtree hash encoding and post processing mechanisms based on elaborated heuristics for source code.
the core algorithm of diff ts accepts a couple of trees as input and decomposes the entire comparison task into manageable subtree comparisons by means of hash value matching and tree f lattening .
it applies an optimal algorithm for subtree comparisons.
an edit sequence is computed by integrating the results of the subtree comparisons and then post processed to yield the f inal edit sequence.
the postprocessing step performs generate and validate move generation and revises the resulting edit sequence based on heuristics speci f ic to source code.
for example we can correct move operations and or relabel operations based on def use relationships .
.
tree hunks the post processing step of diff ts also aggregates edit operations of the same kind that operate on the connected nodes in the ast.
we call an aggregated set of edit operations a tree hunk or simply ahunk if there is no confusion.
figure 4illustrates three kinds of hunks.
by relabel delete insert and move we denote a relabel hunk adelete hunk aninsert hunk and a move hunk respectively.
note that a relabel hunk is always a singleton since we perform relabeling one by one.
application of hunks other than relabel hunk takes extra arguments in addition to those of the original edit operations.
delete 1x eowhere edenotes a set of excluded nodes insert 1p i n x iowhere idenotes a set of nodes with their positions or insertion points and move 1p i n x e iowhere eand idenote excluded nodes and insertion points respectively.
then application of the hunks in figure 4are represented as follows !
!
figure tree hunks.
figure ast patching.
delete v.alt fbgo insert 1a x f1 y.alt 1o 1z 0ogo and move 1a w fcg o. .
ast delta an ast delta is a set of augmented hunks hunks are augmented with several annotations that make arbitrary combination of them applicable to asts to produce valid patched versions of the asts.
instead of detailing such annotations we will explain our design of the delta application in the next sections.
ast patching figure 5depicts an overview of our method of ast patching.
a delta obtained from an xdd f ile is applied to ast obtained from prog to produce a patched version ast0ofast.
then we obtain prog0by unparsing ast0.
the de f inition of delta application above assumes a rough ordering of hunk application.
without such assumption the de f inition would have been much more complicated since it has to take arbitrary partial delta application into account.
in order to apply a hunk sequence sto a tree t we can easily reorder sas follows s relabel z e0 eidelete z ei ejinsert z ej ek where each move hunk is decomposed into a delete hunk and an insert hunk.
figure 6illustrates application of a hunk sequence composed of the hunks shown in figure .
firstly a relabel is applied although not illustrated in the f igure figure .
secondly delete and deletion part of move are applied figure .
then insert is applied figure .
finally insertion part of move is applied figure .
however if we apply a subsequence of stot nodes to be inserted may not be inserted into tand nodes to be deleted may be left in t. to cope with such situations we should be able to insert a node when its insertion target is not present yet and also be able to insert a node even when its insertion target has a node sitting at the 600esec fse november lake buena vista fl usa m. hashimoto et al.
!
!
!
!
figure delta application.
1a a a a a a a a a a a figure node access paths.
position where the node is to be inserted.
to remedy the both we introduce notions of node access path andvirtual insertion target .
.
node access path we locate a node in a tree by a path from the root.
a path is essentially a list of ancestors represented by an ordered list of positions.
figure 7shows examples of paths.
suppose that a7is a mapped node and that a6anda5are to be inserted and a6is the insertion target of a5.
ifa5is inserted before a6is inserted a5 s insertion target will be a7 which is the latest present node in the path of a6.
.
virtual insertion target since we allow partial delta application an insertion target aof an insert hunk rooted at xmay have another node v.alt to be deleted at the position where xis to be inserted as seen in figure .
if the insertion hunk has no insertion points xwill be safely inserted next to v.alt.
otherwise we f ind a virtual insertion target which is the latest common ancestor of the nodes to be inserted into the insertion points.
for example in figure bandcare inserted into insertion points at zand y.altin the insertion hunk respectively.
in this case the virtual insertion target is v.alt which is the latest common ancestor of bandc.
inserting the insert hunk and the insertion part of the move of wyields an intermediate tree as shown in figure .
note that performing deletion including the deletion part of the move of won the intermediate tree yields the same result as that in figure .
while the above works there exists exceptional cases as shown in figure where the original program fragment and its ast are !
latest common ancestor!
21figure a virtual insertion target.
!
!
!
!
!
!
!
!
h h h h h figure an exceptional case.
on the left and the modi f ied version of the program and its ast are on the right.
inserting a hunk h3into a virtual insertion target the root which is the latest common ancestor of s0ands1 yields the tree shown at the upper right of figure .
then inserting h4 yields an intermediate tree shown at the center of figure 10since s2is already taken by h3.
if we delete h1later the location of s2 should be adjusted as shown in figure .
we have covered several such cases as they emerged.
now the tool can correctly generate patched programs for most cases.
syntactic and semantic decomposition of delta our aim is to decompose an ast delta into independent delta components each of which is composed of tree hunks so that any subset of the set of components does not cause build failures when it is applied to a program.
to achieve this we introduce three kinds of logical rules for coupling tree hunks syntactic rules refactoringbased rules and change based rules.
syntactic rules are de f ined so that any delta component does not violate syntactic constraints.
refactoring based rules are derived from the de f initions of refactoring patterns.
change based rules are elaborated based on dependencies between tree hunks to avoid build failures.
601automated patch extraction via syntax and semantics aware dd... esec fse november lake buena vista fl usa !
!
!
!
h h h h h figure node location adjustment.
.
coupling by syntactic constraints for an ast node its children s labels and or the number of the children are constrained by the syntax of the underlying programming language.
for example a node labeled with a constant value would have no children while another node labeled with if would have two or three children for a condition expression and a then part and possibly else part.
if a hunk contained in a delta incompletely changes a part of an ast and hence violates syntactic rules the requisite hunks to complete the change should be included in the delta.
for example a hunk that deletes the condition of a if statement should be coupled with another hunk that inserts a condition into the statement.
.
coupling by refactoring patterns hunks related to a refactoring pattern should be coupled together.
for example add parameter pattern couples hunks for adding parameters to a method with those for adding arguments of the corresponding method invocations.
in order to f ind refactoring patterns we employ a framework for analyzing f ine grained source code change patterns .
since the framework requires a database query for specifying a change pattern we translated descriptions of refactoring patterns cataloged by fowler into database queries.
let us consider the case of remove parameter pattern for instance.
we regard a parameter pas removed when the following f inegrained conditions hold mandm0are method declarations qis a parameter list corresponding to q0is a parameter list the parent nodes of qandq0aremandm0 respectively the version v.alt0ofm0is the immediate successor of the version v.altofm q0is a new version of q that is qis mapped to q0 m0is a new version of m that is mis mapped to m0 and pis deleted from q.it is not difficult to check these conditions based on the information reported by diff ts.
.
coupling by other changes this kind of couplings are further divided into directed andundirected couplings.
suppose that a hunk h0depends on another h1 while h1does not depend on h0.
then h0is coupled with h1in a directed way.
for example insertion of an instance creation of a new class requires insertion of the class if there is any while the class insertion does not.
if h0andh1depend on each other they are coupled in an undirected way.
informal descriptions of the directed coupling rules include the following dr1 inserting a statement requires inserting the enclosing method body dr2 inserting a use of a variable requires inserting an initialization of the variable before the use dr3 inserting an abstract method into an abstract class requires inserting a concrete overriding method into a concrete subclass of the abstract class dr4 deleting a method declaration requires deleting an invocation of the method dr5 deleting a single type import declaration requires deleting an occurrence of the type name and dr6 deleting a loop requires deleting a continue statement in the loop.
informal descriptions of the undirected coupling rules include the following ur1 a f ield name changes together in the f ield declaration and in the f ield accesses ur2 return values of a method and the return type of the method change together ur3 throws and throw statements are inserted in a method together ur4 a parameter and a corresponding argument are inserted together into a method and into an invocation of the method ur5 throws of a method and throws of an overriding method are deleted together and ur6 deletion of an abstract modi f ier from a method and insertion of a body into the method are simultaneous.
note that dr2 requires control f low graphs while dr4 andur4 require call graphs.
figure 11shows a decomposed delta namely grouped tree hunks derived from bug of jedit where red circles represent hunks blue rectangles represent refactoring patterns green rectangles represent other change patterns lines between red circles represent syntactic couplings lines from blue rectangles represent refactoring based couplings and lines from green rectangles represent change based couplings.
staged delta debugging .
delta debugging delta debugging dd is an approach to automated debugging based on systematic testing .
we employ ddmin algorithm to minimize failure inducing or bug f ixing changes of a program.
unless otherwise noted we mean ddmin by dd.
602esec fse november lake buena vista fl usa m. hashimoto et al.
figure grouped ast delta hunks.
suppose that we have a program and a test for it.
dd starts a minimization process with a set of changes between two versions vgood andvbadof the program where the test passes for vgood and fails for vbad.
the test is required to distinguish three test results pass fail and unresolved.
dd divides the change set into two subsets in order to produce a virtual intermediate version of the program based on one of the subsets and apply the test to the intermediate version.
dd repeats bisecting and testing until it obtains minimal failure inducing changes which means that the changes no longer cause test failure if any of the changes is removed.
in this process we apply coupling rules explained in section to avoid unwanted build failures.
for example if a change set is composed of method name changes in invocations we can augment the set with method name changes in the corresponding method declarations to avoid symbol not found errors.
.
staged delta debugging by virtue of ast differencing that diff ts offers we can effectively apply hierarchical delta debugging hdd to our method.
like the original hdd we intend to accelerate the dd step in our method by exploiting the hierarchical structure of an ast delta and dependencies between delta components.
suppose that we take an ast delta as an input of a dd algorithm.
we divide the whole dd step into several stages .
at the f irst stage delta components are grouped together based on the f iles to which they belong.
note that a delta component may belong to multiple f iles since it is composed of multiple tree hunks possibly coupled across f ile boundaries.
if a delta component that belongs to a set of f iles depends on another that belongs to another set of f iles the dependency is naturally extended to the dependency between f iles.
then the f ile level dd namely dd on the groups of the delta components is performed.
at the following stages the method level dd and the statement level dd are performed similarly.
at the f inal stage the f inest node level dd namely dd on the original delta components is performed.
it should be noted that we would have hierarchies consisting only of f iles and text hunks if we based our method on a line by line text patch.
experiments in order to evaluate our method we have developed a couple of prototype systems by overloading test method of dd.py created by zeller.
ddj is an implementation of our method for changes of java programs which was created based on diff ts and the querybased analysis framework used in several software engineering studies .
we prepared more than database queries for specifying coupling rules.
as mentioned in section some of the coupling rules require control f low graphs and call graphs.
for this we prepared several dozens of queries for implementing simple control f low analysis and simple call graph construction based on class hierarchy analysis cha .
note that ddj also overloads resolve method of dd.py in addition to test method.
the resolve method takes care of resolving dependencies arising from a set cof components in two directions by adding delta components to cand by removing delta components from c. ddj resolves dependencies from cbased on the directed couplings of tree hunks contained in c. as a baseline system we have also implemented programminglanguage agnostic dd system ddp for changes of plain texts based on gnu diff.
ddp decomposes a plain text patch into patch components namely text hunks as opposed to ddj decomposing an ast delta into delta components.
we conducted a couple of experiments that extract bug inducing changes and bug f ixing patches from pairs of commits revisions versions.
we evaluate the results by the number of build test executions by build success rate and by the size of the resulting patches.
in order to measure the size of an ast delta and that of a plain text patch uniformly we convert them into token sequence differences.
that is an ast delta or a plain text patch is converted into a list of deleted or inserted token sequences replacement of a token sequence sbys0is interpreted as deletion of sfollowed by insertion of s0 obtained by tokenizing the original and the patched programs and then by applying a sequence matching algorithm to the tokenized programs.
by tokenizej andtokenizep we denote conversions into token sequence differences namely lists of deleted or inserted token sequence lists from an ast delta and an plain text patch respectively.
we de f ine the size of an ast delta or a text patch as the sum of the number of tokens occurring in the token sequence difference obtained by tokenizej ortokenizep respectively.
we employed javalang and difflib for tokenizing java programs and differencing token sequences respectively.
.
automated isolation of bugs for defects4j defects4j d4j for short is a database of real life bugs for reproducible studies in software engineering research .
at the time of writing d4j version .
.
contains bugs from open source 603automated patch extraction via syntax and semantics aware dd... esec fse november lake buena vista fl usa isolated bug fixother changes!
!
!
!
!
figure isolating a bug f ix.
java projects jfreechart chart closure compiler closure apache commons lang lang apache commons math math mockito mockito and joda time time .
each bug is accompanied by a comprehensive test suite that contains at least one failing test that triggers the bug.
a bug is stored in d4j as a pair of a faulty and a f ixed source code versions vbugandv f ix that differ only by the bug f ix.
for each bug they f irst identi f ied v f ix and then isolated the f ix from the source code difference vprevv f ixbetween two consecutive versions vprev andv f ix where vprevis the previous faulty version of v f ixin the repository.
note that vprevv f ixmay include irrelevant changes such as refactorings.
a virtual intermediate version vbugis synthesized in a way that the difference between vbugandv f ixbecomes equivalent to the isolated bug f ix obtained by removing unrelated changes to the bug f ix from vprevv f ix.
figure 12illustrates the relationship between vprev v f ix and vbug.
.
.
interpretation of the original test results.
for each bug d4j provides pairs of triggering tests and their expected exceptions 1t0 e0o 1tn enowhen they fail.
the test script testddfor both ddj and ddp checks whether the same set of tests as that of d4j s triggering tests fails on the patched source code and also checks whether the thrown exceptions are consistent with those in d4j.
for each bug in d4j testddoutputs pass when any of the triggering tests t ft0 tngsucceeds fail when one or more tiintproduce failure with exceptions consistent with ei and unresolved otherwise.
note that testddcannot exactly match exceptions against those provided by d4j since exceptions may also change according to the source code changes and or the execution environment.
for example a test of math triggers bug with an unhandled exception bobyqaoptimizer pathisexploredexception in 38b namely vbug of bug .
however changes between 38p vprevof bug and 38f v f ixof bug contain move class refactoring that moves the exception into class bobyqaoptimizer hence the test triggers bug with another pathisexploredexception without class pre f ix bobyqaoptimizer in38p.
other examples include several tests of lang that trigger bugs with assertionfailederror messages that contain the date and or time of the test executions.
.
.
dd on defects4j dataset.
by reversing the chronological order of vprevandv f ix we regard the d4j bugs as regressions.
then we performed dd with ddp and ddj on changes between v f ix andvprevof d4j projects that do contain unrelated changes to the bug f ixes.
we dropped trivial cases where there was no need to isolate bug f ixing changes.
as mentioned above the bugs in d4j are derived from real life bug f ix commits some commits involve changes unrelated to bug f ixes and others do not.
note that we turned off staging of ddj in order to avoid fruitless overhead since chartclosurelangmathmockitotimetokens in patch 050010001500200025001st quartile3rd quartileminimummaximumoutliermedianmeanfigure amount of difference between v f ixand vprev.
the differences between v f ixandvprevof d4j projects are relatively small as shown in figure .
the results of ddp and ddj are summarized in table .
from pairs of versions ddp and ddj extracted patches consisting of tokens and tokens in total respectively.
thus ddj extracted smaller patch in tokens than ddp did at the cost of more build executions than ddp required.
by virtue of syntaxand semantics awareness ddj caused far less build failures than ddp did although ddj decomposed the difference into .
times as many components as ddp did see cddp cddj rddp and rddj .
.
.
validity of the resulting patches.
although any of the resulting patches is valid in the sense that it causes the triggering tests to fail with consistent exceptions we further examine whether it overlaps with the corresponding human extracted d4j patch.
table2 opddpandopddj shows that half of the tokens in token differences dddp namely pairs of deleted inserted token sequence lists derived from ddp patches by tokenizep match those in dd4j from d4j s manually extracted patches while of the tokens in dddjderived from ddj patches by tokenizej match those in dd4j.
it should be noted that both ddp and ddj extracted patches that do not overlap with d4j patches for and bugs respectively seenoddpandnoddj .
the reasons behind this are the following.
semantic equivalence of patches the overlaps shown in table1are the numbers of syntactic tokens.
by manually inspecting the resulting patches we found that out of the ddp patches and out of the ddj patches are semantically equivalent to those of d4j.
ambiguity of tests some triggering tests are ambiguous in that multiple independent subsets of the input delta or patch components cause the tests to fail with expected exceptions.
moreover testddcannot expect exact matching of the thrown exceptions as mentioned in section .
.
.
604esec fse november lake buena vista fl usa m. hashimoto et al.
table minimizing reverse bug fixing changes for defects4j b number of bugs p tokens in patch op tokens in common with d4j patch tokens in patch no number of patches overlapping with no d4j patch c number of patch delta components r build success rate project b pv f ixvprev pd4j opddp opddj noddp noddj cddp cddj rddp rddj chart .
.
closure .
.
lang .
.
math .
.
mockito .
.
time .
.
total .
.
single output of dd algorithm the original dd.py on which ddp and ddj are based looks for the f irst failing subset and hence reports only a single subset.
we have added capability to obtain other subsets by rerunning dd on the complement of the resulting subset as long as it causes failure and or by shuffling input sets in order to randomize bisection.
in fact by rerunning ddj we could extract other patches that syntactically overlap with d4j patches for all of the remaining bugs while ddp could do the same for the remaining bugs by shuffling the inputs.
.
automated extraction of regression fixes we collected real life regression bugs from open source java projects.
antlr is a parser generator for reading processing executing or translating structured text such as source code or binary f iles.
we chose a regression antlr type mismatch between left and right labels in left recursive rule .
apache commons math is a mathematics and statistics library addressing the most common problems that are not available in the java programming language.
we chose math percentile calculation is very slow when input data are constants .
hsqldb is an sql relational database software.
we chose hsqldb update statement with in criterion recently broken and hsqldb null pointer in casewhen and case... when use case .
hsqldb appeared also in experiments conducted by artho .
jedit is a text editor designed for programmers.
we chose jedit npe when scrolling to top after multiline delete soft wrap .
jsoup is a java library that provides an api for extracting and manipulating data from html f iles.
we chose jsoup regression wrong parsing for clippath and jsoup regression css attribute selector .
logback is one of the java logging frameworks.
we chose logback message formatting regression .
for each regression we searched the log backward from a faulty version vbadfor a regression free version vgood.
with ddp and ddj we performed dd on changes from vbadthrough vgood instead of from vgood through vbad.
we detect a regression f ixing change set instead of a failure inducing change set by modifying the test scripts to invert the test results.
the results are summarized in table .
for each regression vbadandvgood indicate a version number pre f ixed by v a revision number pre f ixed by r or a commit id with no pre f ix.
the largest input change set was the one taken from math while the smallest from jsoup .
note that even the smallest 110100100010000patch components ddp delta components ddj tests exec utedddjddpfigure dd run for minimizing math f ix patch.
110100patch components ddp delta components ddj tests exec utedddjddp figure dd run for minimizing jsoup f ix patch.
input change set is much larger than that of each bug in the d4j dataset.
the dd runs for minimizing math and jsoup regression f ixes are shown in figures 14and15 respectively.
performing ddj on math resulted in a patch which is times as small as that by ddp at the cost of times as many test executions as ddp required.
the three worst build success rates were set for math hsqldb and hsqldb by ddp mainly 605automated patch extraction via syntax and semantics aware dd... esec fse november lake buena vista fl usa table minimizing regression fixing changes p tokens in patch c number of patch delta components r build success rate project vgood sloc vbad sloc pvbadvgoodpddp pddj cddp cddj rddp rddj antlr 14f05bb aacd2a2 .
.
math v2.
v2.
.
.
hsqldb r3227 r3262 .
.
hsqldb v2.
.
v2.
.
.
.
jedit r12114 r12710 .
.
jsoup b033535 v1.
.
.
.
jsoup v1.
.
v1.
.
.
.
logback v1.
.
v1.
.
.
.
total n a n a .
.
1101001000patch components ddp delta components ddj tests exec utedddjddp figure dd run for minimizing hsqldb f ix patch.
due to increasing numbers of dependencies between text hunks in accordance with the sizes of the change sets as well as the lack of coupling rules for the text hunks.
on the other hand the best build success rate .
was set for hsqldb and jedit by ddj and for logback by both ddp and ddj.
the dd run for minimizing the hsqldb regression f ix is shown in figure .
overall ddj extracted patches .
times as small as ddp did at the cost of test executions .
times as many as ddp required both on average.
note that the resulting patches are no more than f irst aid patches that undo minimal failure inducing changes.
as opposed to the d4j experiment that is based on the actual bug f ixes the patches are qualitatively different from the actual f ixing patches.
related work ast differencing and patching.
although several ast differencing methods and their implementations have been developed to the best of the authors knowledge no study has so far been made on ast patching that directly operates on ast nodes and even allows partial application of ast deltas like ours.
nevertheless a few attempts have been made at tree patching for other tree structures such as xml and json .
unfortunately however we cannot employ xml json patch toolsfor our method by converting ast into xml or json since their de f initions of tree delta are not compatible with ours.
refactoring reconstruction.
prete and others conducted an extensive study on refactoring reconstruction methods where they presented a tool called ref finder for detecting refactoring patterns as cataloged by fowler .
ref finder takes as input a pair of revisions from java projects and reports refactoring instances as output.
ref finder f irst extracts facts from the given revisions using logical predicates such as method methodname typename denoting that a method named methodname is de f ined in a class or an interface named typename .
then the difference between the revisions is obtained by taking the set difference of logical assertions in a simple case.
for example deletion of a method is easily identi f ied by a disappearing assertion of method .
for a complex change such as refactoring ref finder applies prede f ined template logic rules that cover patterns from the fowler s book.
compared to our approach ref finder is weak in identifying renamed entities since the set difference of logical assertions tells nothing about the correspondence between nameless entities.
our method is based on a f ine grained ast differencing method that provides mappings even between nameless ast nodes.
recently tsantalis and others proposed a similar tool rminer for identifying refactoring patterns occurring within a single github commit by employing ast based statement matching.
our method is based on full scale ast differencing as opposed to rminer s limited ast differencing up to statements.
thus ddj can directly handle f ine grained patterns such as extract variable and inline temp that rminer cannot.
moreover our tool is capable of identifying refactoring patterns between any given pairs of program versions compared to rminer s patterns within a commit.
we plan to work on a detailed comparative study for these tools.
delta debugging on code changes.
surprisingly few studies have ever tried dd on source code changes although dd has been applied to various failure inducing circumstances such as program inputs thread schedules and program states .
zeller demonstrated dd for narrowing down changed gdb lines to a single failure inducing change by making use of line by line differencing .
to reduce the number of tests executed he grouped changes based on a f ile system hierarchy that involves directories f iles and also on common usage of identi f iers.
he also added a failure resolution loop to the dd step.
in the loop body if a group of changes causes a build failure the error messages are scanned 606esec fse november lake buena vista fl usa m. hashimoto et al.
for identi f iers and then all changes that refer those identi f iers are added to the group for another trial.
this is repeated until the build succeeds or until there are no more changes to be added.
instead of this somewhat ad hoc resolution our method resolves such build failures based on the dependencies between changes described by a set of syntactic and semantic rules supported by ast differencing.
a distributed version control system called git provides a command git bisect that identi f ies failure inducing commits between good and bad commits based on a consistent test script.
the command would be a good tool for f ighting regressions if any commit contains relatively small set of changes .
ddj does not require any development history.
it only requires a pair of good and bad versions to isolate failure inducing sets of delta components.
automated patch extraction.
over the past several years a considerable number of studies have been made on automatic software repair .
the basic idea behind them is to generate fault f ixing patch candidates that can be validated later.
a number of approaches have been proposed for repairing different classes of faults under different conditions and hypotheses .
although our method focuses on f ixing regression bugs by minimizing the difference between good and faulty versions it can also be used for extracting minimal patches from machine generated patches that are often indirect and lengthy.
threats to validity granularity of delta component.
an ast delta component is composed of tree hunks each of which is a set of edit operations aggregated as much as possible.
for example removal of a whole subtree is not interpreted as a set of node deletions but as a single deletion of the subtree.
such implicit grouping of changes may impact the result of dd on ast deltas.
it would reduce the number of test executions when an implicit group of changes coincide with a group of syntactically and or semantically coupled changes.
on the other hand it would needlessly increase the size of resulting patches when changes related to a target failure depend only on a single change in a large implicit group of changes.
partial application of delta.
our implementation of partial application of ast deltas is just one of the possibilities.
there might be a completely different design that better achieves the goal of the partial application any sub delta or subset of delta components of a delta is applicable to any source code where the full delta is applicable.
adequacy of test.
as martinez and others pointed out automatic program repair methods relying on test suites suffer from under speci f ied bugs for which trivial or incorrect patches still pass the test suites .
since dd relies heavily on tests as well our method of extracting patches is affected similarly as suggested by the results of our experiment on the same dataset namely defects4j as theirs.
even the task of minimizing a set of changes including a bug f ixing subset may depend on adequacy of tests.
experiments.
our experiments are based on a proof of concept implementation for java programs which consist of examples of bug f ixes taken from defects4j and examples of regression bugs taken from open source java projects.
the setting maynot generalize to other programming languages other real life regressions and or bug f ixes.
as for refactoring identi f ication we did not measure precision and recall in the experiments.
although we cannot precisely estimate the impact of low precision recall on the results we have not yet experienced negative effects caused by the false positives at least for both of the datasets.
the scalability of our method depends on the number of test executions which is further broken down into the performance of each test execution the size of source code to be built for a test and the complexity of the test itself.
in the experiments performed on a machine with a .0ghz cpu and 8gb of memory each individual dd run required several minutes to a day according to the number of test executions.
the total amount of time spent on ast differencing and database construction was relatively small compared to that on the test executions.
each ast differencing task required a few to a dozen minutes according to the size of the source code and the gap between versions while each database construction task required at most several dozen minutes.
conclusion delta debugging is an approach to automating debugging activities based on systematic testing.
it f inds the cause of a regression of a program by minimizing changes between a working and a faulty versions of the program.
in this study we tackled an open problem of minimizing a huge amount of changes while avoiding combinations of changes that do not result in a testable program especially in case that no software con f iguration management system is available.
our solution to the problem is a rule based method of decomposing changes into independent components both syntactically and semantically.
a key technique in the method is to make use of tree differencing on abstract syntax trees asts instead of traditional differencing on plain texts for analyzing changes.
to evaluate the proposed method we have developed ddj which is an implementation of dd on node by node ast changes of java programs and ddp which is a language agnostic implementation of dd on line by line source code changes.
a couple of experiments have been conducted.
one is on minimizing differences for each of the pairs of good and faulty versions contained in the defects4j dataset .
the other is on extracting patches for real life regression bugs from open source java projects.
compared to ddp ddj extracted patches of half the size at the cost of more test executions for the former dataset and patches of size at the cost of more test executions for the latter both on average.
we have created a docker image containing ddj and ddp in order to reproduce the results of the experiments.
the image will be available at .
acknowledgment this work was supported in part by jsps kakenhi grant number jp26280025.
the second author was supported by nedo s development of a highly dependable humanoid robot system that can work in unstructured environments project.
607automated patch extraction via syntax and semantics aware dd... esec fse november lake buena vista fl usa