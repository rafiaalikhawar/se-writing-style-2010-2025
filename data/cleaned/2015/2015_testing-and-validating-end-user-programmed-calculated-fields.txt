see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation testing and validating end user programmed calculated fields conf erence paper oct ober .
.
citation 1reads author s including v ctor a. br aberman univ ersity of buenos air es publica tions citations see profile diego garber vetsky univ ersity of buenos air es publica tions citations see profile javier ignacio godo y univ ersity of buenos air es publica tions citations see profile seb astian uchit el univ ersity of buenos air es publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y diego garber vetsky on no vember .
the user has r equest ed enhanc ement of the do wnlo aded file.testing and validating end user programmed calculated fields v ctor braberman diego garbervetsky javier godoy icc uba conicet argentinasebastian uchitel icc uba conicet argentina imperial college london ukguido de caso ignacio perez santiago perez medallia inc. usa abstract this paper reports on an approach for systematically generating test data from production databases for end user calculated eld program via a novel combination of symbolic execution and database queries.
we also discuss the opportunities and challenges that this speci c domain poses for symbolic execution and shows how database queries can help complement some of symbolic execution s weaknesses namely in the treatment of loops and also of path conditions that exceed smt solver capabilities.
ccs concepts software and its engineering software testing and debugging theory of computation program analysis information systems data management systems keywords program analysis symbolic execution query generation acm reference format v ctor braberman diego garbervetsky javier godoy sebastian uchitel guido de caso ignacio perez and santiago perez.
.
testing and validating end user programmed calculated fields.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa 6pages.
introduction end users tend to under test their programs and be overcon dent about their correctness .
the lack of oracles partly due to the overhead of producing speci cations and also over reliance on domain expertise pushes end user program testing to the realm of informal validation rather than veri cation.
in this context producing test inputs based on real world relevant data is perceived as a way of improving end user validation.
there has been signi cant e ort in validation of end user spreadsheet programs yet it is acknowledged that there is a large community of non developers that write database related code to support their jobs .
an example of the latter is code that computes values permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci c permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
calculated elds.
the value of a calculated eld is de ned by the values of other elds using a procedure which can be non trivial to write and hence error prone.
in companies providing business intelligence and analytics services and products end user programs for computing calculated elds are commonplace.
in this line of business end user programmers have a strong understanding of the domain talk directly to customers or may even be customers and must develop calculated eld programs test and validate the code and then apply the calculation to every row of the potentially very large database.
calculated eld programs are written in general purpose programming languages or turing complete domain speci c programming languages and are a ripe ground for end user programmer errors.
consequently e ective automated support for validating these programs is of critical importance.
to improve the support it provides to its calculated elds programmers medallia inc. uses a restricted domain speci c version of javascript for developing calculated elds and developed infrastructure that allows programmers to produce inputs based on real database registers that cover their code.
because it is real data these inputs and their corresponding calculated eld output can be more easily validated by business analysts.
furthermore code that cannot be covered with existing data is a valuable piece of information that leads to improved business analysis.
to support rapid interactive provision of feedback in early stages of calculated eld program development code coverage and output coverage the return type of calculated eld is typically an enumerated type is achieved via random selections from the database.
scanning an entire database of millions of registers for examples for each possible output is simply too expensive.
this paper reports on a joint e ort to improve early provision of real database test data to calculated eld program developers via a novel combination of symbolic execution and database queries.
the aim is to use a symbolic execution engine to produce path conditions that can be translated into database queries that retrieve from databases real test data that covers the end user programmed code.
automated test case generation techniques based on symbolic execution face signi cant challenges to be applied in practice due to di culties in reasoning about loops and recursion and complex path conditions those beyond smt capabilities .
these di culties are compounded in our speci c case by the choice of a dynamic language javascript for end user programming.
however in practice we have found that end user programs for calculated elds have a number of characteristics that provide a window of opportunity for using symbolic execution.
these programs tend to use simple control features notably with no loops operate over simple data types but exhibit an intricate pattern ofesec fse november lake buena vista fl usa braberman garbervetsky godoy uchitel de caso i. perez s. perez.
conditional statements that hinders human validation.
this setting could be regarded as bene cial for automated test case generation based on symbolic execution engines.
the setting is not as simple as it seems.
end user programs for calculated elds call non user de ned functions that can be of signi cantly greater complexity including loops and more complex data types.
such functions can be either show stoppers for symbolic execution engines attempting to produce path conditions and for translating them into database queries.
a key observation that allows addressing these obstacles is that end user programs for calculated elds used at medallia call a reduced api that includes only a small set of functions from the standard javascript library and from a set of non user de ned domain speci c functions.
the latter have been designed in the spirit of a domain speci c language many of which can be dealt with e ciently if appropriately translated and embedded in a database query.
thus the insight that follows is that the functions that are complicated to handle for a symbolic execution engine can be hidden away and delegated to the database management engine e.g.
as sql supported constraints or stored procedures .
summarising we report on a joint e ort to support end user validation of javascript programs used for calculated elds in data warehouse applications.
we discuss a prototype tool chain that given an end user javascript program for a calculated eld generates a set of unit tests that cover end user code.
each test is created using when they exist real values extracted from a production database.
the main components of the tool chain are the pex dynamic symbolic execution engine a path condition to database query translator to retrieve real test inputs from a production database and a test suite generator to produce unit tests.
we prevent pex from analysing complex procedure calls within an end user program by annotating these calls as uninterpreted functions.
as a result pex produces path conditions for which the interpreted portion of the path condition is guaranteed by construction to be feasible reducing the total number of infeasible paths.
the translator maps procedures marked as uninterpreted into database query functions that implement them e ciently in the database engine.
the resulting query exploits existing indexes for the feasible part of the path condition typically reducing signi cantly the number of registers to be analysed and then scans the rest running the more complex procedures on each register until it nds a suitable input.
in the remainder of this paper we rst provide examples motivating the di culties in producing real database test data for calculated eld programs we then describe the approach and discuss its evaluation.
finally we present related work and conclusions.
motivation in this section we present a series of increasingly complex examples that illustrate the di culties in providing real database test data for calculated eld programs.
the examples are set in a ctional company sales that is analysing the introduction of a reward program.
a sales analyst becomes end user programmer and develops code for a calculated eld that classi es customers into di erent tiers basic frequent silver gold and platinum .1function cf points row var points row.points if points null return null if points return platinum if points return gold if points return silver if points return frequent return basic listing a simple calculated eld program a rst basic program might simply classify customer into elds based on their accumulated points.
the function in listing 1shows a possible implementation of this criterion.
to cover all statements in this program it su ces to provide di erent inputs one for each return statement.
to generate the input for one speci c return statement an input that satis es the chain of conditions determined by the control path to the statement is required.
in other words an input that satis es the path condition for each return statement is needed.
a sequential scan or random picking from the sales production database may be used to show the sales analyst real examples of customers that fall into each tier.
depending on the distribution of customers into the return values and the size of the database this may be a costly approach.
a symbolic execution engine like pex or jpf can automatically produce synthetic inputs to cover statements.
a by product that is sometimes o ered is the path condition of the program under test.
each condition is a predicate on the input parameters that must hold in order to reach a particular statement.
these path conditions can be used to produce database queries that can nd e ciently by exploiting database engine infrastructure including indexes registers that satisfy each path condition.
as an example the path condition that corresponds to return value can be used to generate the following database query select from row where row.points and row.points limit a further re ned and more complex customer classi cation criterion possibly elicited after analysing previous criteria may reward customers who have been in the program for longer.
it could include calls to standard library functions to calculate di erences between dates as the function years date lastseen date signupdate .
despite the added complexity and system library calls a symbolic engine such as pex is still able to produce inputs that cover all statements for that function ... 4611686018427387903ul 13835058055282163712ul row.lastseen.datedata 4611686018427387903ul 13835058055282163712ul row.signupdate.datedata 864000000000l note that pex analyses all the code including that of the library functions.
thus the path condition predicates over the internal .net representation of dates.
we do not need nor want the symbolic execution engine to delve into the full detail of operations and data types that can be managed by the database engine.
to tackle this problem we need to tell the symbolic execution engine to handle some speci c calls as uninterpreted preventing the engine from reason within these calls.
note that symbolic execution engines typically do not provide annotation mechanisms for identifying uninterpreted functions.
for the prototype reported in this paper some tricks that force the symbolic engine to consider sometesting and validating end user programmed calculated fields esec fse november lake buena vista fl usa 1function cf pointpromotion row ... if relevantdays return cf points row if isplatinum row return ... 7function isplatinum row return isplatinum row cf computepointsreqforcountry row function isplatinum row pointsforplatinum var points row.lastpoints .split if points .length row.numdays return var isplatinum true for i i row.numdays i var calcpoint int.parse points isplatinum isplatinum calcpoint pointsforplatinum if isplatinum return return function cf computepointsreqforcountry row if row.countrycode null return null if row.countrycode row.countrycode return if row.countrycode row.countrycode return return null listing calculated eld with a loop calls as uninterpreted were devised see section .
by declaring the function years as uninterpreted the path condition will look as... years lastseen si nupdate .
if uninterpreted functions have straightforward mappings to functions supported by the database query language the path condition can then be translated into a database query.
a further re nement of the reward program may be to o er upgrade to customers that acumulated points above some baseline for a certain number of days in a row.
the required amount of points varies according to the country of origin.
in the code below the function isplatinum reads a text eld containing a semicolon separated list of points e.g.
lastpoints ... and checks that the rst numdays values are above a threshold determined by the country.
there are also some extra conditions that are shown in listing .
this calculated eld program goes beyond the capabilities of symbolic execution engines which cannot produce an input nor a path condition that covers line .
one way to overcome this issue is to postpone the analysis of the complex method isplatinum and leave this job to the database engine.
this of course can only be done if the database query language supports an equivalent function.
if function isplatinum row pointsforplatinum is marked as uninterpreted then pex is able to obtain a path condition for line row.lastpoints null row.numdays null row.numdays row.countrycode null row.countrycode isplatinum row execution of queries such as the above will typically include cutting down the number of records very e ciently.
using the conditions on countrycode points and numdays the database query would rst nd a reduced number of candidates records and then will need to check the condition isplatinum on it reduced set of records.
this is a signi cantly more e cient mechanism than random picking or sequential scan over the entire database.
for a database with million records a sequential scan and execution of a simple function such as the one above on each register canbe orders of magnitude slower than path condition generation translation and query execution.
approach in this section we report on an approach aimed at assisting end user programmer validation of programs used for computing calculated elds in data warehouse applications.
in figure 1we present a ow chart that sketches how calculated elds are processed to tests using inputs from real database data.
the prototype consumes a javascript program that computes a calculated eld and produces i a set of test inputs taken from database records that cover statements of the calculated eld program and ii a set of synthetic test inputs that cover the statements for which no input in database exists.
programs are rst pre processed to mark uninterpreted functions.
pex a symbolic execution engine is then used to produce path conditions to cover all statements.
path conditions are translated into database queries which are then run to retrieve real test input data.
finally the test inputs are used to produce executable tests.
pex also produces synthetic inputs.
for every path condition that produced a query whose result was empty the synthetic input for that path condition generated by pex is used to generate additional tests to augment coverage.
.
a domain speci c language before discussing the main procedures of figure 1we discuss a pre condition of the approach the existence of a domain speci c language dsl for calculated eld development.
this language may be de facto or formally de ned and enforced.
in medallia the dsl restricts end user programmers to writing functions that have as an input a database register and output the value of particular elds i.e.
the calculated eld .
programmers are not allowed to access the database itself hence calculated elds that consider aggregation from several rows results are not allowed.
in addition a library of domain speci c functions is provided.
these functions raise the level of abstraction of the database elds encapsulate business rules and can be called by end user programs.
an example of such functions in section 2isisplatinum .
finally the language de nes the functions that are to be considered uninterpreted calls by the symbolic execution engine.
these functions calls will appear verbatim in path conditions and need to be translatable into expressions that the database engine can handle in a query.
for example years lastseen signupdate can be de ned to be the expression date part year age date1 date2 while isplatinum row num may be implemented directly as a stored procedure.
the choice of functions to be considered uninterpreted is crucial highly domain dependent and may need to be revised over time.
as the goal is to build database queries directly from path conditions it is undesirable to include in path conditions low level constraints arising from code that is already functionally supported by the database query engine.
examples of these are math operations such as round and date operations.
marking these functions as uninterpreted will make the symbolic execution engine consider them black boxes making them appear as symbolic expressions in the path condition.
the uninterpreted manipulation of years in section 2exempli es this case.esec fse november lake buena vista fl usa braberman garbervetsky godoy uchitel de caso i. perez s. perez.
calculated field js pex enginecalculated field c with encoded uninterpreted functions manual systematic translation and preprocessingpath conditionstranslatorqueries dbtest case generatorinputs test case generatortests using db records synthetic tests figure real data test case generation it is also worth considering function calls as uninterpreted when end user programs implement stable functionality that has complex control structures or data types that can break the symbolic execution engine.
in these cases it may be preferable to translate them to expressions that the database query engine can manage.
the uninterpreted manipulation of isplatinum in section 2is an example.
another is code that can be e ciently implemented in terms of optimised access to internal tables.
.
calculated field program preprocessing preprocessing involves marking uninterpreted functions calls in the calculated eld program according to the de nition of the dsl.
although conceptually simple our choice of symbolic execution engines introduced two accidental challenges programming language translation and forcing symbolic execution to not interpret marked functions calls.
as mentioned previously javascript is the language used by medallia s end user programmers.
we considered symbolic execution tools for javascript including jalangi concluding they were insu ciently robust.
we also considered using symbolic jpf which is for java and supports user de ned uninterpreted function calls.
however the tool does not correctly support conditions over null values.
we nally opted for pex which despite supporting .net rather than javascript and not supporting user marked uninterpreted calls has the advantage of being a well established industrial strength tool e.g.
that is available through visual studio suite.
pex is actually a concolic execution engine it combines concrete and symbolic execution to produce inputs covering a determined set of statements of a given procedure.
having chosen pex the rst accidental issue that the prototype s preprocessing must address is the translation of javascript into c which for calculated eld end user programs is straightforward and can be systematically done manually.
given a end user javascript program and a list of uninterpreted functions translation starts at the program entry point and recursively translates each javascript method into a corresponding c method.
this process ends at calls to uninterpreted functions which are not translated.
the second issue is that pex does not support user speci cation of calls that are to be treated as uninterpreted.
to overcome this limitation we convert function calls that should be uninterpreted into c n dimensional arrays.
the trick behind this encoding is to use pex s ability to handle arrays symbolically.
given an uninterpreted method uninterpreted a1 .
.
.
an we encode it in an n dimensionalarray of integer types uninterpreted .
the idea is to use the ghost variables a1 sel f ... an sel f of integer type as proxies of the original arguments of the uninterpreted function of arbitrary types .
using this encoding pex can produce an input and a path condition by instantiating the array and ghost variables with arbitrary values.
.
path condition generation once the calculated eld programs are preprocessed and translated to c we are ready to run pex and produce path conditions.
the interpreted portion of the conditions is guaranteed to be feasible reducing the total number of infeasible paths.
the uninterpreted part is evaluated on the database in the next phase.
for instance the verbatim path condition returned by pex for theyears function in the previous section is ... years !
int null lastseen self years.getlowerbound lastseen self years.getlowerbound years.getlength signupdate self years.getlowerbound signupdate self years.getlowerbound years.getlength the following is a path condition for cf pointpromotion row.lastpoints null row.numdays row.countrycode null isplatinum row.
self row.countrycode isplatinum row.
self ... row.countrycode row.countrycode row.countrycode row.countrycode isplatinum row.
self row.countrycode isplatinum row.
self note that pex actually returns multiple path condition that cover a statement to account for di erent paths that reach the statement.
as we choose in this paper statement coverage we integrate the path conditions with a disjunction.
.
path condition to query translation converting path conditions into database queries requires that all functions identi ed in the dsl as uninterpreted have a mapping mechanism from function calls to equivalent query expressions.
first we reverse from each path condition the encoding for uninterpreted function calls introduced in the previous section.
for example in the case of array years the function call years lastseen lastseen is extracted.
it also applied minor syntax transformations such as replacing expressions e.hasvalue !
false bye!
null and removes side e ect conditions produced by the encoding for uninterpreted calls.
note that treatment of null values is di erent in sql than in javascript and c .
finally uninterpreted calls are replaced by their equivalent query expressions.testing and validating end user programmed calculated fields esec fse november lake buena vista fl usa .
test case generation this process produces a unit tests by executing queries against a database and using the selected records as inputs for unit tests.
each query when executed by the database query engine exploits existing indexes for the feasible part of the path condition typically reducing signi cantly the number of registers to be analysed and then scans the rest running the more complex procedures on each register until it nds a suitable input.
should the query result be empty this means that there are no database records that satisfy the original path condition.
in these cases it may be possible to obtain from pex for a synthetic input instead.
the only potential problem is that the synthetic input is by construction consistent with the interpreted part of the path condition but may be inconsistent with the uninterpreted function call expression.
generated inputs real or synthetic are then used to produce the test cases.
the prototype uses mocha to execute synthesised tests and measure coverage of calculated eld programs.
evaluation the purpose of the prototype described above is to understand the feasibility of applying advanced test case generation techniques for systematically covering with real data end user calculated eld programs at medallia.
we used anonymised programs and database consisting of records extracted from an internal production database.
the aim of the evaluation was to assess to what extent these programs considered representative of those developed at medallia by end users could be covered by the prototype.
the programs operate over simple data types such as integer oats and strings and outputting enumerated types in out of cases integers and strings .
they lack loops and recursion but exhibit intricate patterns e.g.
nested conditional statements early program exit with return statements that hinder human validation.
other characteristics of the programs include the use of many checks for null values stored in elds integer oat and string manipulation in conditional statements using javascript standard functions such as indexof touppercase parseint and round .
in addition the programs included multiple invocations to functions of a medallia library some of which essentially encapsulate lookups on auxiliary tables others supporting operations such as regular expression search over strings.
we rst developed the list of functions to be treated as uninterpreted.
the list was de ned to include all functions in the medallia library plus operations over oat string and date types.
a mapping for each one to equivalent database query expressions was developed.
for basic types the mapping is very straightforward see years in section .
.
for medallia library functions supporting lookups for instance sql join expressions were used.
having then translating manually all programs into c tests data was generated.
we measure statement and branching coverage of the calculated eld programs.
we report coverage using two di erent notions of test unit each calculated eld program can be thought of as a testing unit as it is common that end user programmers develop or change one program leaving the rest unchanged.
however many of thesetable analysed programs.
anonynous cf stms covered stms tests cf 1 .
cf 2 .
cf 3 .
cf 4 .
cf 5 .
cf 6 .
cf 7 .
cf 8 .
cf 9 .
total .
programs actually call other calculated eld programs which were developed by other end user programmers and in many cases these programs need to be changed consistently together.
thus we also consider as a test unit the entire set of calculated eld programs.
when considering the set of calculated eld programs as a test unit we computed coverage achieved by executing all tests generated for each calculated eld program individually.
this amounts to path conditions converted to database queries.
all queries but one returned results which led to test cases covering statement coverage.
although we did not aim for branch coverage the tests achieved .
we also report see table the coverage of test units comprising only one calculated eld program at a time.
the tool covered all statements in each individual calculated eld program with the exception of one statement which could not be covered due to the non existence of records in the database satisfying the corresponding query.
the symbolic execution engine however was able to produce a synthetic input to cover the statement.
our experimentation was run on an anonymised version of a production database.
to gain insight on the domain relevance of test cases that the approach can produce we provided the experimental subjects and database queries to independent end user programmers at medallia.
they de anonymised eld names in code and queries and then ran the queries on the production database.
while validating the resulting test cases the end user programmers identi ed one mismatch between informal requirements and the calculated eld program.
the mismatch had to that point not been identi ed.
furthermore the mismatch was subtle enough that initially end users assumed that there was a problem of the prototype test case generator.
both the high coverage and the success in producing ndings regarding existing calculated eld programs are promising results that provide preliminary evidence that symbolic execution combined with database queries is a technically feasible solution for medallia s end user calculated eld programs.
related work testing of end user programs has attracted much attention much of it addressing spreadsheet programs .
we are not aware of any work supporting testing and validation of end user calculated elds programs written in general purpose programming languages.
other kinds of end user programs that are related to databases haveesec fse november lake buena vista fl usa braberman garbervetsky godoy uchitel de caso i. perez s. perez.
been studied though most notably those that include explicit database queries in the code and assume a xed database state.
those approaches aim at practical code or query coverage by generating program inputs or by reducing database state e.g.
.
although in some cases part of their internal workings resemble ours e.g.
construction of auxiliary queries based on intermediate information there are some key di erences rstly we pursue detecting database records covering statements of an imperative program there is no sql query or query manipulating code in the programs we target.
secondly our test cases retrieval queries end up executing user de ned code or some equivalent database query code.
finally a distinctive aspect of our approach is the identi cation of uninterpreted functions to simplify symbolic analysis and transfer complexity to the database engine.
lessons learned the project has left us with some lessons learned that may be of use in a more general setting when coverage needs to be achieved using test cases based on real inputs taken from large databases a viable alternative to sequential scan of the data or random picking can be to use symbolic execution to generate e cient queries over the data set.
we identi ed three main pitfalls when attempting to generating database queries from path conditions.
in some cases the code is too complex for the symbolic execution engine to output a path condition e.g.
code with complex iterative or recursive structure .
alternatively the path condition may be expressed in terms of low level constraints that include how types are represented in the program and which cannot be mapped to the database.
finally a path condition may be over constrained due to the complexity of the code leading to a query that does not retrieve any data.
a viable approach to overcome these limitations is to identify code blocks that can be declared as uninterpreted predicates over the data set.
note that importantly it must be possible to implement these predicates e ciently using the database query engine e.g using native sql operators or developing within the database engine appropriate user de ned functions .
identifying uninterpreted code facilitates the symbolic engine s task as it can avoid complex loops and low level representation issues.
the resulting high level path condition can be translated into a query to select from the database an appropriate input.
note that a downside of introducing uninterpreted code blocks is that the symbolic engine cannot guarantee the feasibility of a resulting path condition hence the approach may generate more database queries than necessary.
conclusions we have reported on a project to improve testing and validation of end user programs that compute values for calculated elds.
the approach is based on symbolic execution to systematically achieve coverage and database queries to obtain test inputs based on real data.
identi cation of calls that should not be interpreted during symbolic reasoning and resolved by the database engine is a key part of the approach.
the test case generation prototype has shown that such a tool chain can fully cover statements of real calculated eld end user programs using real data.our approach hints that for some domains the challenge for symbolic execution engines is not scale loops nor smt support for more complex theories all three of which are main thrusts of the community .
in some domains increased applicability of symbolic execution may be achieved by providing support for user de ned uninterpreted functions and better supporting more end user oriented programming languages such as javascript.
this work has led us to an additional observation that may inform research in test case generation based on dynamic symbolic execution in some domains rather than trying to produce and solve di cult path conditions an e cient search over real values in a database may not only allow covering code that otherwise remains uncovered but also can provide tests that use real data aiding test comprehension and validation.
in other words there may be bene ts to produce a more abstract path conditions avoiding the interpretation of functions that can be handled by a database engine.
if the database is su ciently populated to always have at least one record that satis es each query and su ciently e cient to process queries a method for systematically constructing test cases that use realistic data for end user programs can be deployed.
future work aimed at the construction of a fully automated test case generator for medallia will include incorporating and improving javascript symbolic execution tools of the likes of jalangi including the addition of support for user de ned uninterpreted functions.
more generally we believe there are opportunities in investigating the use of database engines to replace limitations of smt solvers for test case generation.