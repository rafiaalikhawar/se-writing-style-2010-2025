automated decomposition of build targets mohsen vakiliani raluca sauciucg j. david morgenthalerg vahab mirroknig iuniversity of illinois at urbana champaign ggoogle mvakili2 illinois.edu ralucas jdm mirrokni google .com abstract a build target specifies the information that is needed to automatically build a software artifact.
managing the dependencies between the targets of a large code base is challenging.
this paper focuses on underutilized targets an important dependency problem that we identified at google.
an underutilized target is one with files not needed by some of its dependents.
underutilized targets result in less mod ular code overly large artifacts slow builds and unneces sarybuild and test triggers .
to mitigate these problems programmers decompose underutilized targets into smaller targets.
however manually decomposing a target is tedious and error prone.
although we prove that finding the best target decomposition is np hard we introduce a greedy algorithm that proposes a decomposition through iterative unification of the strongly connected components of the target.
ourtool found19 decomposable targets inaset of40 java library targets at google.
a decomposable target is one that can be decomposed to at least two targets.
our tool found that decomposing any of the decomposable targets would save at least one build or test trigger.
the evaluation results show that our tool is efficient because on average it analyzes a target in two minutes and effective because for each of targets it would save more than of the total execution time of the tests triggered by the target.
.
introduction software evolves rapidly.
google s code repository has over million lines of code .
with over programmers the code base is growing rapidly.
half of the code base changes every month .
to make the rapid evolution of software more economical and reliable google has developed an in house continuous integration ci system.
for each code change the ci system first invokes the build system to build the code affected by the change.
then it runs all the tests that transitively depend on the affected code .
permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
draft as of march .
copyright .the practice of ci is not unique to google.
other companies and open source projects have adopte d this practice .
the faster the software evolves the heavier the load on the ci system is.
on average the google code repository receives over code changes per day which make the ci system run over million test cases per day .
these numbers grow as google grows.
dedicating more compute resources to the ci system is not sufficient to keep up with this growth rate.
thus google employs advanced technologies to ensure that build and test results are delivered to programmers correctly in a timely manner .
the google build system like other build systems takes as input a set of build files that declare build targets.
we refer to a build target as atargetin the rest of this paper.
targets specify whatis needed to produce an artifact such as a library or binary.
a target also specifies i ts unique name kind source files and dependencies on other targets figure .
the build system decides howto build a given target based on the target s specification.
buildspecificationsareoftenthoughtofas merelyameans to transform source code into executable and other artifacts.
however build specifications are used more widely in practice because they capture an important architectural a spect of software namely the dependency structure between pieces of code.
for example at google several systems other than the build system e.g.
integrated development environments ides and ci systems rely on build specifications.
ides rely on the build specifications to determin e the code that an ide has to index for a given package.
similarly a ci system uses the build specifications to compute the set of tests affected by a code change.
despite the sophisticated caching and parallelism of google s build system slow builds ci and ides are still majo r issues.
like code in languages such as c and java build specifications require significant continuous maintenance.
resear ch suggests that build maintenance accounts for and of code and test development respectively .
our prior work showed that build specifications are prone to code smells such as unneeded andmissing direct dependencies .
this paper focuses on a specific code smell which we call underutilized targets .
an underutilized target has source files that some of its dependents do not need.
underutilized targets make the builds and ides slower increase the size of executables and increase the load on the ci system by triggering unnecessary builds and tests.
brought to you by core view metadata citation and similar papers at core.ac.uk provided by illinois digital environment for access to learning and scholarship repositoryarefactoring is a code change that preserves the behavior of the program .
target decomposition or simply decomposition is our term for a refactoring that mitigates the problems of underutilized targets.
it first decomposes an underutilized target into smaller targets which we refe r to asconstituent targets or simply constituents and then updates the dependents of the original target to depend on only the needed constituents.
identifyingandrefactoring underutilizedtargets is tedi ous and error prone to do manually for several reasons.
first a large code base has many targets over targets at google .
this makes it nontrivial if not impossible to find the targets whose decompositions would yield the largest gains.
second there are often many possible decompositions for a target.
choosing an effective decomposition from this large space is a daunting task.
third manually decomposing a target is error prone because a valid decompositio n must obey the dependencies between the source files of the target.
finally decomposing a target without updating its dependents will yield limited benefits.
once a target is decomposed into smaller constituent targets its dependent s have to change so that they depend on the constituent targets.
this refactoring is tedious and error prone because a target can have many dependents owned by different development teams.
we propose two tools decomposer andrefiner for identifying and refactoring underutilized targets.
decomposeridentifies underutilized targets and suggests how to decompose them to constituent targets.
refiner is a refactoring tool that updates the dependents of the underutilize d targets to depend on only the needed constituent targets.
decomposer estimates the impact of a decomposition on the number of triggers i.e.
the number of binary and test targets that the ci system builds and runs respectivel y. in addition it suggests a decomposition using a greedy algorithm that accounts for both the file level dependencies between the source files of a target and the target level ones between the target and its dependents.
the algorithm first computes the strongly connected components sccs of the graph formed by the file level dependencies of the target.
then it iteratively unifies two sccs at a time until only two sccs are left.
finally the algorithm promotes each scc to a target.
although we implemented decomposer andrefiner at google the underlying techniques are generalizable to oth er environments.
these tools can be adapted to any environment that can provide its file level and target level dependencies.
our tools are sound assuming that the provided file level and target level dependencies are sound.
the results of our large scale empirical study show that decomposer is bothefficient andeffective section .
we randecomposer on a large random sample of targets that consisted of java library targets at google1.decomposeranalyzes a target within minutes mean sd .
out of the targets decomposer found decomposable targets.
a decomposable target is one that has at least one valid decomposition section .
decomposer is also effective at saving unnecessary triggers.
it estimat ed that its proposed decompositions would significantly reduc e the test execution time minutes per change to each target mean sd .
on average a decomposition 1forconfidentialityreasons wedonotreportexactstatisti cs about the dimensions of the google code base.proposed by decomposer reduces the total execution time of the tests triggered by the target by .
for each of targets thedecompositions proposedby decomposer would save more than of the execution time of the tests triggered by the target.
decomposer has been deployed at google and used by about a dozen programmers so far.
this work makes several research contributions we quantify the benefit of a decomposition in terms of the number of triggers that it saves section .
we formalize the decomposition problem as a graph problem andprovethat findingthebest decomposition is np hard section .
we present the algorithm section and implementation section of decomposer a tool for decomposing targets.
we present refiner a tool that refactors build specifications to take advantage of a decomposition section .
we evaluate decomposer through a large scale empirical study in an industrial environment section .
.
build system a build system is responsible for transforming source code into libraries executable binaries and other artifacts.
the build system takes as input a set of targets that programmers declare in build files.
figure shows sample build specifications.
when a programmer issues a command to the build system to build a target the build system first ensures that the required dependencies of the target are built.
then it builds the desired target from its sources and dependencies .
the final artifact depends on the kind of the target.
for example for java targets the build system produces jar files.
build targets programmers have to specify four attributes in the specification of a target name kind source files and dependencies.
the buildfiles shown in figure specify three targets with names b1 l1 andl2.s denotes the set of source files of the target named .
the targets shown in figure set their source files to be the set of java files in the directory that encloses the buildfile.k denotes the kind of target which can be binary library ortest.
in figure k b1 binaryandk l1 k l2 library.
for both library andbinarytargets the build system generates jar files.
the difference is that the jar file for a binary target has an entry mainmethod and contains all the transitive dependencies of the target.
deps is the set of targets that need to be built before building .
in figure deps b1 l1 l2 .
dependency graphs programmers havetoconsiderbothtarget levelandfile lev el dependencieswhenspecifyingtargets.
thegraphinfigure2 illustrates both kinds of dependencies.
build graph target leveldependencies targetsspecify abuild graph b t e where tis the set of all targets.
21java binary 2name b1 3srcs glob 4deps l1 l2 a contents of file b1 build1java library 2name l2 3srcs glob 4deps l1 b contents of file l2 build1java library 2name l1 3srcs glob 4deps c contents of file l1 build figure three buildfiles that declare targets b1 l2 andl1shown in figure .
attribute namespecifies the name of the target.
the srcsattribute specifies the source files of the target.
the expres sionglob resolves to all java files in the enclosing directory of the buildfile.
the depsattribute lists the targets that need to be built to compile the source files of the target.
figure a graph that illustrates both target level and file level dependencies for an underutilized target l1.
sccirepresents a strongly connected component section .
of the cross