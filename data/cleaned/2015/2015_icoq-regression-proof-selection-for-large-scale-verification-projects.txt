icoq regression proof selection for large scale v erification projects ahmet celik university of texas at austin austin tx usa ahmetcelik utexas.edukarl palmskog university of illinois at urbana champaign urbana il usa palmskog illinois.edumilos gligoric university of texas at austin austin tx usa gligoric utexas.edu abstract proof assistants such as coq are used to construct and check formal proofs in many large scale verification projects.
as proofs grow in number and size the need for tool supportto quickly find failing proofs after revising a project increases.we present a technique for large scale regression proof selection suitable for use in continuous integration services e.g.
travis ci.we instantiate the technique in a tool dubbed icoq.icoq tracks fine grained dependencies between coq definitions propositions and proofs and only checks those proofs affected by changesbetween two revisions.
icoq additionally saves time by ignoring changes with no impact on semantics.
we applied icoq to track dependencies across many revisions in several large coq projectsand measured the time savings compared to proof checking fromscratch and when using coq s timestamp based toolchain forincremental checking.
our results show that proof checking with icoq is up to times faster than the former and up to times faster than the latter .
i. i ntroduction v erification projects based on construction and certification of formal proofs inside proof assistants have reached a hitherto unprecedented scale.
la rge projects take two main forms formalizations of mathem atical theories and programs with accompanying proofs of correctness at the level ofexecutable code .
the former includes the proofs of the four color theorem and the feit thompson odd order theorem in coq and a proof of the kepler conjecture inhol light the latter includes the certified sel4 operating system kernel in isabelle hol and the compcert c compiler in coq .
using proof assistants has advantages with respect to scalability modularity and reliab ility compared to using more automated methods based only on model checking or smtsolving .
on the other hand proof assistants are more human resource intensive to use than model checkers and come with less tool support than what is available to programmers using mainstream programming languages.
specifically wenzel has recently noted the need for more systematic toolsupport to maintain repositories of formal proofs .
large verification projects based on proof assistants are similar to regular software projects in that a the end goal isa software artifact with certain properties b developers use an integrated development environment ide to write code which is then checked by a tool and submitted to a versioncontrol system shared with others.
evidence from earlier undertakings indicate that such projects require engineering effortsimilar to or beyond some of the most complex software projects for example the proof of the odd order theorem in coq was a six year effort of a team of people resulting in lines of code .
we believe that proper tool support for large scale proof engineering using proof assistants is an important and growing concern .
in particular it is important to quickly find and report errors in evolving coq and isabelle hol projects.
however just as for large projects in e.g.
java determining the errors caused by a particular change can be a timeconsuming process.
for instance the coq correctness proofs of an implementation of the raft distributed consensus pro tocol are around 50k lines in total and take more than minutes to check from scratch on a computer with an intel core i7 4th generation processor.
potentially a coq user has to wait all this time to find out whether a change in some definition makes a seemingly unrelated proof fail.
until recently all proof assi stants in the lcf family including isabelle hol and coq relied on user interactionthrough a read eval print loop inherited from their predecessor.this interaction model effectively prevents event based user interaction with proof assistant files inside an ide in the style of eclipse.
initial work in isabelle hol to address this problem paved the way for recent architectural changes in coq towards a document oriented interaction model where the proof assistant backend asynchronously receives definitions proof commands and proof checking tasks from the user all of which may concern disparate parts of a project .
in this paper we show that potential gains in productivity from coq s new interaction model go beyond recentapplication inside ides .
we present icoq a tool for regression proof selection for large scale coq projects suitable for use in workflows involving version control and continuousintegration services ciss e.g.
travis ci .
ciss run tests proofs of a project whenever code of the project changes.
these services have become widely used travis ci one outof more than available ciss is used by more than 300k projects .
icoqworks by tracking dependencies between definitions propositions and proofs.
when presented with aset of changes to coq files icoq uses this knowledge of dependencies to only check the proofs affected by the changes potentially saving significant time in comparison to checking everything from scratch.
in addition icoq saves time by .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research171 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ignoring changes with no impact on the semantics of files e.g.
additions of comments or whitespaces.
our approach is based on a fundamental analogy between tests and proofs .
as beck has noted in context of extreme programming a test can be viewed as a method that checksapartial functional specification of a system.
consequently a proposition about a pure function in coq s logic alongwith its proof can be viewed as an amalgamation of many possibly an infinite number of tests.
for example changing the definition of a function in a coq file can potentially impact many proofs analogously to how changes in java programs affect tests in a test suite.
using this analogy icoq mirrors previous work in regression testing for mainstream programming languages in particular techniques forlightweight regression test selection which have been shown to significantly lower the cost of running test suites and hence find errors more quickly .
such tools have recently been adopted by many large open source java projects.
icoqopens the door for similar benefits to accrue to developers of large coq projects.
nevertheless proofs and tests are also different in several important ways.
first the proof of one claim typically dependson other claims tests are typically completely independentof other tests.
second function definitions claims and proof scripts are often interspersed in coq files test code is seldom interspersed with program code.
third coq proof checking is done in the same environment as the processing of definitions and even computation executing tests is usually done completely separately from code compilation.
we overcome these three challenges by leveraging coq s newly added toolchainfor asynchronous proof processing .
to evaluate icoq we applied it on the version control histories of several coq developments including three large scale projects and measured the time savings compared to proof checking from scratch typical use in continuous inte gration systems and incremental proof checking using coq s timestamp based toolchain typical command line use .
our results show that processing proofs with icoq is up to faster than the former and up to faster than the latter.
we make the following contributions t echnique we propose regression proof selection inspired by regression test selection a technique that can substan tially reduce proof checking time for evolving verification projects.
to the best of our knowledge this is the firstapplication of research in regression testing to the domain of formal proofs.
our insight is that due to simpler language features in proof assistants than in imperative languages e.g.
java regression proof selection can straightforwardly collect fine grained dependenc ies which are used to identify proofs to recheck at each project revision.
t ool we implemented regression proof selection in a tool dubbed icoq which supports coq projects.
we provide a version of our tool on the following url utexas.edu icoq.
evaluation we performed an empirical study to measure the effectiveness in terms of both number of executed proofs and proof checking time of regression proof selection using icoq.
we used several open source coq projects including three large scale projects.
ii.
c oqbackground the coq proof assistant can be viewed as on the one hand a small and powerful purely functional programminglanguage and on the other hand a system for specifyingproperties about programs and proving them.
coq is based on a constructive type theory called the calculus of inductive constructions cic .
in cic both programs and propositions about programs are types inhabited by terms in effect putting program construction and proving on the same footing.
via a frontend e.g.
emacs with proof general a user interactively constructs tent ative proof terms for propositions assertions using operations called tactics and the final result is only accepted after coq s type checker was run successfullyby the backend on the term.
barring use of inconsistent axioms and frontend issues the user need only trust that the comparatively small type checking kernel is correctly implemented and compiled to trust the results.
the interactive proof development process in coq is illustrated in figure .
user logic engine type checkercoqtactics subgoalsproof term fig.
.
coq interactive proof development overview definitions of functions and lemmas processed by coq are written in the gallina language and reside in files ending in .v.
the standard coq batch proof processing compilation tool coqc takes a .vfile as input and produces a .vo file as output that contains full binary representations of processed gallina constructs including proofs.
if the proofs are large and complex .vo files can be tens of megabytes large .
since files may depend on other files checking all proofs in a coq project requires some form of dependency analysis.
the standard coq makefile tool generates a makefile which by default calls the coqdep tool for this purpose .
coqdep builds a dependency graph for all input files based on simple syntactic analysis of require commands similar toimport statements in java in files which indicate direct dependency at the file level.
when proof checking is thenperformed via the makefile the generated dependency graph is used to compile .vfiles in some allowed order possibly in parallel.
the generated makefile also enables timestamp based incremental processing of coq projects which is known to be limited .
figure shows the content of three example gallina files where a simple function on lists of natural numbersis defined specified and proved correct.
alternate.v contains definitions used in the two other files and these authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
alternate.v require export list.
export listnotations.
fixpoint alternate l1 l2 list nat match l1with l2 h1 t1 match l2with h1 t1 h2 t2 h1 h2 alternate t1 t2 end end.
inductive alt list nat list nat list nat prop alt nil forall l alt ll alt step forall a l t1 t2 alt l t1 t2 alt a t1 l a t2 .
lemma alt alternate forall l1 l2 l3 alt l1 l2 l3 alternate l1 l2 l3.
proof .
induction l1 intros .
inversion h.subst .simpl .reflexivity .
destruct l2 simpl inversion h inversion h4 auto .
apply ihl1 inh9.
rewrite h9.
reflexivity .
qed.
altlem.v require import alternate.
lemma alt exists forall l1 l2 exists l3 alt l1 l2 l3.
proof .
induction l1 intros destruct l2.
exists .apply alt nil.
exists n l2 .
apply alt nil.
exists a l1 .
apply alt step.
apply alt nil.
specialize ihl1 l2 .
destruct ihl1.
exists a n x .
repeat apply alt step.
auto .
qed.
alternatelem.v require import alternate.
lemma alternate alt forall l1 l2 l3 alternate l1 l2 l3 alt l1 l2 l3.
proof .
induction l1 simpl intros .
rewrite h.apply alt nil.
destruct l2 subst apply alt step try apply alt nil.
apply alt step.
apply ihl1.
reflexivity .
qed.
lemma alternate correct forall l1 l2 l3 alternate l1 l2 l3 alt l1 l2 l3.
proof .
intros split .
qed.
fig.
.
coq gallina file examples dependencies are found by coqdep .
the dependency data is used to generate a makefile that calls coqc to produce .vo files if alternate.v is subsequently modified in any way after compilation the other files will also be automatically recompiled when running make .
on the other hand modification of the other files does not trigger recompilationofalternate.v .
in effect the coqdep tool produces a coarse grained dependency graph of a coq development at the level of .v files as shown in figure a for the example gallina files dashed arrows indicate dependencies on files from coq s standard library which are usually disregarded.
internally coq maintains a fine grained dependency graph at the level ofconstants reminiscent of the graph shown in figure b .
in each coq file the commands between proof.
and qed.
are proof scripts comprised of tactic calls along with bullets to indicate goal structure.
proof scripts instruct coq how to build a proof term.
tactics can be pipelined and mayperform sophisticated and time consuming search operations splitting of goals and term rewriting.
ultimately tactics produce a proof tin coq s term syntax of which a fragment is shown in figure .
for example the beginning of the proofofalt alternate can be represented as const lambda l1 app list nat app list ind ... where list and nat are the ind terms for the algebraic datatypes for polymorphic lists and natural numbers respectively and list ind is the const term for a list induction principle.
coq version .
the first stable release to include architectural changes to support a document oriented interactionmodel introduced the option to quick compile .v files to the binary .vio format a process which avoids checking and emitting representations of proofs that have been indicated asopaque by ending with qed .
only the type assertion of an opaque identifier such as alt alternate i.e.
not the body term can be referenced in other parts of a coq development whence type checking of all such terms can normally be performed in complete isolation.
specifically .vio files contain proof checking tasks which can be performed individually by issuing a coqc co mmand referencing the task identifier.
a coq user can depend on more rapidly produced .vio files in lieu of .vo files in most developments but must then assume that all proofs are correct.
for example the lemma alternate correct alternatelem.v in the coq development in figure depends on the types assertions of alternate alt and alt alternate but not their proofs consequently the proof of alternate correct need not be re checked if only the proof of alt alternate is changed.
in this case the sole required action is to re check the proof of alt alternate which can be accomplished by first quick compiling alternate.v and then running the single proof checking task in alternate.vio .
figure illustrates the possible workflows for alternate.v made possible by coq s document oriented model.
c o qu s e san o t i o no f sections to organize common assumptions made in a collection of lemmas say that equality on typeais decidable a eq dec .
a lemma may reference one or more such assumptions which then become quantified variables that must be instantiated when the lemma is referenced outside of the section.
however by default coq only determines the used section variables of a lemma when the end of the section is reached.
this means that the final type assertion of the section lemma is not known when considered in isolation whence its proof cannot be immediately checked as an asynchronous task.
to get around this problem coqallows section lemmas to be annotated with the assumptions they use e.g.
proof using a eq dec .
the required annotations can be derived from metadata produced by coqduring compilation of source files to .vo files and then inserted back into the source files.
in the evaluation of our technique we used this approach to add annotations to all revisions of the projects under s tudy as a separate initial step.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a list.v alternate.v altlem.v alternatelem.v b alternate alt alt alternate alternate alt alt exists alternate correct fig.
.
coarse vs. fine grained depende ncy graphs for example coq development t var x prod n t t prime lambda n t c app c ca const c ind i construct cs fix f ... fig.
.
coq term syntax fragment alternate.v coqc coqc quick alternate.vo alternate.vio coqc check vio tasksalt alternate proof script alt alternate proofalt alternate proof task fig.
.
coq workflows for alternate.v iii.
t echnique this section describes our proof selection technique.
we first describe its phases at a high level then details on the lower level steps and finally our implementation in the icoq tool.
the key idea is to incrementally build and analyze both coarse grained and fine grained dependency graphs to produce the minimal set of proofs that need to be checked after a change has been made to a project.
the advantage of our technique compared to the tim estamp based incremental processing of files stems from that generally checking a few proofs in isolation spread out across a development takes much less time and effort than checking all proofs in all affected source files.
a. phases roughly our technique follows the three phases of a typical regression test selection technique an initial analysis phase that locates proofs affected by recent changes followed by an execution phase that checks the selected proofs followed by a final collection phase which produces dependencies for the next revision.
we assume that both the file level andlemma level dependencies and checksums of the last revision of the project are available at the start of the initial phase.
analysis phase first for each source file in the project we check whether its checksum is still the same since the last revision.
then we perform file level dependency analysis and build an up to date coarse grained dependency graph that includes checksums with changed files marked.
this graph is then used to quick compile the changed source files allowingus to compute checksums of the term representations of individual definitions and le mma statements that may havechanged.
at the same time we also determine the prooftasks available in each changed source file and compute the checksum of each proof script associated with a proof task.using our knowledge of proof tasks and checksums for finegrained entities we obtain a fine grained dependency graph where each modified entity is marked and from which recently removed entities are purged.
by going through all modified e ntities in the fine grained dependency graph we then calculate the transitively impactedentities and mark them in the graph.
the set of proof tasks to execute is then precisely the tasks associated with the set of modified and impacted entities.
note that this process of discovering impacted proofs is similar to the process of invalidating the upward transitive closure in some build systems e.g.
bazel .
execution phase given the list of proof tasks and their associated source files and bin ary quick compiled files from the previous phase we emit the commands for checkingthose tasks.
after each command is executed we note the dependencies of the proof on ot her lemmas and definitions this information is only available when the proof term has actually been constructed and stored in memory.
collection phase this phase finds the dependencies of all modified definitions and lemmas by extracting them fromthe quick compiled files and combining the results with the proof dependencies obtained in the previous phase.
we usethese dependencies to build a complete up to date fine grained dependency graph that includes checksums.
we then store this graph as a file to be used in the analysis phase of the next project revision.
running example we exemplify our technique for coq using the code in figure .
assume that we integrated icoq in the project at revision v1.
at that revision we compute the checksums of all .v files run coqdep on them and build the graph shown in figure a no checksums existedin revisions prior to v1 and therefore the current values are considered different by defin ition.
since all file checksums are different we quick compile all files into .vio files and compute all the checksums for all definitions and lemmastatement terms.
then we note the proof tasks in each file and compute checksums for the associated proof scripts.
again all checksums are different by definition so we check the proofs of all lemmas alt alternate alt exists alternate alt a n d alternate correct .
from the corresponding proof terms and the terms for alternate and alt we construct the graph in figure b and add checksums for all nodes.
the graphs and checksums are then stored forfuture use.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fixpoint alternate l1 l2 list nat list nat match l1 l2 with l2 l1 h1 t1 h2 t2 h1 h2 alternate t1 t2 end.
fig.
.
modified coq function definition in alternate.v suppose that the developer of the example coq project rewrites the definition of the function alternate to the one in figure this change leads to a new revision v2 of the project.
at the file level the checksum of alternate.v becomes different from before.
however coqdep reveals that the file dependency graph is still the same as in figure a .
since the other .v files depend on alternate.v w e compile all .v files into .vio files in some order allowed by the graph.
after then computing checksums of terms usingalternate.vio and proof scripts using alternate.v we conclude that only the body of alternate has been modified.
using this information and the graph in fig ure b we determine that the proofs of alt alternate alternate alt a n d alternate correct are impacted and must be checked.
consequently we run the com mands to check these proofs while alt exists is not checked because it was not impacted .
after each proof checking task has completed we note that no dependencies in the proofs have changed.
finally weextract and analyze dependencies from the only modified nonproof term alternate confirming that the graph in figure b is up to date after the new checksum for alternate has been added.
b. icoq components and w orkflow our current implementation of the technique is written in ocaml java and bash.
we developed a number of separate coq tools and plugins.
since coq developments are not upwards or downwards compatible in general we target coq version .
to support the largest range of project revision histories susceptible to asynchronous proof checking we ex pect no fundamental issues with supporting .
and future coq versions.
our tools and plugins can also be used and be useful outside the context of icoq.
coq depends plugin to extract dependencies from compiled coq files .vo and.vio we adapted and extended previous work on the coq dpdgraph coq plugin which builds dependency graphs for given identifiers or modules files .
in essence the derived plugin called coq depends traverses a coq term abstract syntax tree ast and records the globally unique kernel name of all referenced identifiers it encounters such as those of inductive types lemmas and functions.
by performingthe dependency extraction at the level of asts in the coq backend our tool is isolated from complexities at the gallina level such as custom notations and implicit arguments.
in contrast to coq dpdgraph coq depends does not perform recursive dependency extraction and supports .vio files which do not contain the proofs of opaque identifiersthatcoq dpdgraph expects to be present.
the pluginmakes no distinction between depending on an identifier of a lemma or function that is inside the scope of a project or outside it.
in particular if there is a dependency on a lemma in the coq standard library which is normally assumed to be stable across revisions it must be filtered out from the plugin output to be excluded from analysis.
for example from the proof term for the lemma alt alternate described in section ii coq depends extracts the set of kernel names alternate.
alt alternate.
alternate coq.init.
datatypes.
list coq.init.
datatypes.
list ind ... .
here to filter out unnecessary dependencies it suffices toexclude names with the prefix coq.
.
coq ast plugin to compare coq identifiers across project revisions we developed a plugin for computing shortsummaries digests of coq term asts that capture thestructure of the trees.
we use a technique for computing summaries based on cryptographic hashes that was shown tobe effective at programming language syntax fingerprinting by chilowicz et al.
.
more specifically letting cbe a hashing function the string concatenation operation tat e r ma s t with root node rand child trees t ... t n a n dva function from ast nodes to strings chilowicz et al.
define a hash function hcsuch that hc t c v r hc t1 ... hc tn .
note that this function which we implemented in ocaml with c md5 is linear in the number of nodes in the tree.
the function vis defined in an obvious way based on the syntax in figure as an example figure shows afragment of the ast of the proof of alt alternate in alternate.v wherevhas been applied to each node.
to keep asts as shallow as possible we do not unfold bodies of referenced inductive types or constants and simply use their unique kernel names.
const lambda name l1 app app ind list ind nat const list ind ... fig.
.
ast with string values of nodes for example coq term coqdigest tool since we cannot compute digests of asts of opaque identifiers without actually performing allthe proof checking work that we are trying to skip we use digests of the actual proof scripts tactic soups in the .v files.
from the standard coqdoc tool which translates .vfiles into documentation we derived a tool dubbed coqdigest that extracts the proof scripts of opaque lemmas while ignoring sequences of characters that do not affect semantics and returns the md5 hash of the results.
the tool also notes whether a lemma is admitted i.e.
whether an identifier with an unfinished proof is assumed as complete for the rest of the development this is a common device used in early phases of verification projects.
for example when parsing alternatelem.v from figure coqdigest determines that there are two proof tasks authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
file dep graph new revision identifier dep graphimpacted .vfiles .vfile checksums impacted proofs.vio files identifier checksums checking commandsidentifier deps new identifier dep graph fig.
.
toolchain workflow in the file one for the lemma alternate alt and one for the lemma alternate correct .
for the latter specifically coqdigest computes the md5 hash of the proof script intros split .
coqc dependency extraction extension a proof term for a proof task in a .vio file is only available when the proof task completes.
yet to properly update the identifier dependency graph for the next revision all dependencies must be extracted from such terms.
consequently we extended the coqc tool with an additional command that when given a .vio file its associated .vfile and a proof task checks the task and then outputs all the dependencies in the proof term using the technique from coq depends .
due to how the proof checking interface works in coq .
accessing the proof term is only possible when the proof is complete i.e.
has not been admitted.
for this reason icoqignores checking proofs of admitted lemmas although changes in their statement type can lead to checking of other proofs that depend onthem.
since our coqc extension only uses the existing proof checking facilities it does not affect the soundness of coq.
dependency graph builder and analyzer we implemented our own dependency graph builder and dependency analysisin java.
the resulting program reads files mostly in json format output by the coq tools and plugins as well as json representations of dependency graphs from previous revisions and finally writes the updated dependency graphs to disk.
t oolchain workflow if all proofs in a .v file need to be checked compiling a .vo file is usually significantly faster than first producing a .vio file and then executing all proof tasks.
consequently we compile all .v files in the initial revision of a project into .vo files and via those extract dependencies directly from both proofs and definitions.
for subsequent revisions the toolchain workflow illustrated in figure follows the general steps of the technique outlinedin section iii a. first the java program reads the json representations of the file level and identifier level dependency graphs from the last revision.
then it computes checksumsof all .vfiles in the revision runs coqdep on changed files parses the output and updates the file level dependency graph.using the graph the program calls coqc to quick compile all impacted files into .vio files.
then it runs coqdigest on all new and changed .vfiles and coq ast on their .vio counterparts obtaining via parsing of json files checksums for all identifiers and a list of proof tasks.
this is sufficient to enable marking all impacted identifiers in the dependencygraph.
from the updated graph the program obtains and runs all proof tasks associated with impacted identifiers using thetable i verifica tion projects used in the eva l uat i o n project url sha loc revisions ctltctl ac57a84f infseqext 5a52a76f structtact 8f1bc10a weakupto e570e6dc flocq 4161c990 unimath 5e525f08 ver di 15be6f61 summationtextn a n a avg.
n a n a .
extended coqc command and then parses and incorporates the json output into the fine grained dependency graph.
finally it uses coq depends to obtain the dependencies of all impacted non proof identifi ers writing the up to date graph to disk along with the file level graph.
iv .
e va l uat i o n to assess the usability of icoq on large verification projects we answer the following research questions rq1 how effective is icoq compared to the state of theart techniques i.e.
what is the reduction in the number of checked proofs?
rq2 how effective is icoq in terms of the proof checking time in a continuous integration environment?rq3 how effective is icoq in terms of the proof checking time outside a continuous integration environment i.e.
for verification on a user s machine ?
we run all experiments on a core intel core i7 cpu .40ghz with 16gb of ram running ubuntu .
lts.
a. v erification projects under study table i shows the list of projects used in our study all projects are publicly available all but one on github .
we selected projects based on a public availability of their re vision history during principal development b compatibility of their revision history with coq .
c their size and popularity and d our familiarity with their codebases the latter was necessary for a successful experimental setup.
for each project we list the name reference the repository location and show the last revision sha we used for our experiments the number of lines of coq code loc for the last revision as reported by cloc and the number of revisions for the experiments.
based on projects characteristics we say that the first four projects are micro benchmarks and the other three projects are large scale proof developments.
ve rd i a n d ve rd i r a f t v erdi is a framework for verification of implementations of distributed systems .
while theframework is not currently tied to any one particular verification project it was initially bundled with a verified implementation of the raft distributed consensus protocol .
weconsider revisions from mar to jun before v erdi and theraft implementation were separ ated.
each revision comprises over 50k loc making v erdi one of the largest publicly authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
available software verification projects.
many v erdi proofs use extensive custom tactic based automation the resultant long proof checking time was one of the initial motivations for developing icoq.
unimath unimath is a comprehensive library of formalized mathematics based on the univalent interpretation suggested by v oevodsky of the types in coq as so called homotopy types rather than mathematical sets .
the revisions of unimath under study are from jan to mar and each consist of more than 43k loc.
flocq flocq is a coq library that formalizes floating point arithmetic in several representations e.g.
as described in the ieee standard.
flocq is used in the compcert verifiedc compiler to reason about programs which use floating point operations .
we considered revisions of flocq from jan to mar each consisting of more than 22k library loc.
b. v ariables independent variables we manipulate two independent variables proof checking techniques and the development environment .
regarding the proof checking techniques we use a coq s timestamp based toolchain that we described in section ii we refer to this technique as coq makefile and b icoq that implements regression proof selection.
our development environments include ci env and loenv.
ci env describes an environment that uses a continuousintegration service cis to check proofs.
note that a cischecks proofs in a clean environment for each revision.
loenv describes an environment where developers use their local machines to check proofs.
note that file timestamps are preserved in the latter case but not in the former.
dependent variables our dependent variables measure the effectiveness of proof selection techniques at reducing the amount of effort required to reproof modified programs.
to do this we compute the proof selection percentage and measure the proof checking time .
the proof selection percentage is derived from the ratio of selected proofs to the total numberof available proofs executed by coq makefile in the cienv environment.
we use p selto denote this variable.
proof checking time is measured as the end to end time that includes all phases described in detail in section iii of our proof selection technique.
c. experiment procedure figure illustrates our experiment procedure that collects the data necessary to answer our research questions.
as input the procedure accepts one of the projects under study table i a number of revisions to be used in the experiment and a development environment either ci env or lo env .
in theinitial step line the procedure clones the project repository from the url in table i. next the procedure iterates over the latest revisions from the oldest to the newest revision.
in each iteration of the loop the procedure a obtains a copyof the project for the current revision line b configuresthe project as the preparation for the proof checking and c selects proofs that are affected by changes and checks thoserequire pa project under study require the number of revisions require a development environment procedure experiment procedure p clone p.url for all la test revisions p do checkout configure p select execute andcollect p if ci env then touch files p end if end for end procedure fig.
.
experiment procedure revision of proofs a infseqext0255075100 revision of proofs b structtact fig.
.
proof selection percentages for two micro benchmarks proofs.
finally if the procedure is simulating the ci env the timestamps of all files have to be updated.
it is important to observe that we need to save dependency files for icoq between two revisions.
recently many ciss have started supporting caching which we can utilize to store the dependencies.
considering that caching is fast and icoq s dependency files are small we do not associate any overhead with keeping dependencies in the ci environment.
one of the key steps in the experiment procedure is to select and check proofs line .
during this step our procedure stores the execution logs which include the list of selected proofs and the proof checking time.
we analyze these logs in the following subsection to answer our research questions.
d. results we obtained all necessary data by invoking the procedure in figure twenty eight times one invocation for each project in table i two proof checking techniques coq makefile and icoq and two environments ci env and lo env .
in total we selected and checked proofs on revisions.
rq1 how effective is icoq compared to the state ofthe art techniques i.e.
what is the reduction in the numberof checked proofs?
figure shows the proof selection percentage for two out of four micro benchmarks.
we can observe substantial reduction in the number of executed proofs at many revisions.
overall across all revisions we find that icoq executes on average .
and on average .
proofs for infseqext and structtact respectively.
onthe other hand we find that the coq makefile technique executes on average .
and on average163.
proofs for infseqext and structtact respectively.
inother words icoq reduces the number of checked proofs by .
and .
for infseqext and structtact respectively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii total and average number of selected proofs and proof checking time for large verifica tion projects project proofs ci env time lo env time icoq total psel coq makefile icoq c i coq makefile icoq c i flocq summationtext n a .
.
n a .
.
n a avg.
.
.
.
.
.
n a .
.
n a unimath summationtext n a .
.
n a .
.
n a avg.
.
.
.
.
.
n a .
.
n a verdi summationtext n a .
.
n a .
.
n a avg.
.
.
.
.
.
n a .
.
n a revision icoq total psel coq makefile icoq c i coq makefile icoq c i verdi details 40d0e96f .
.
.
.
.
.
.
6b8a7d06 .
.
.
.
.
.
.
56b15cb5 .
.
.
.
.
.
.
9403f6f5 .
.
.
.
.
.
.
112b39b0 .
.
.
.
.
.
.
57cf9bb1 .
.
.
.
.
.
.
bbf66a54 .
.
.
.
.
.
.
46b6be65 .
.
.
.
.
.
.
27537ec2 .
.
.
.
.
.
.
0f2b8090 .
.
.
.
.
.
.
0201fc23 .
.
.
.
.
.
.
cad0e753 .
.
.
.
.
.
.
2cb92f55 .
.
.
.
.
.
.
21f660c1 .
.
.
.
.
.
.
c28a126c .
.
.
.
.
.
.
.
.
.
.
.
.
.
ade568dc .
.
.
.
.
.
.
997ad0a6 .
.
.
.
.
.
.
cee72d1e .
.
.
.
.
.
.
8ee9b856 .
.
.
.
.
.
.
d4406a1b .
.
.
.
.
.
.
687a4eaf .
.
.
.
.
.
.
06a76847 .
.
.
.
.
.
.
15be6f61 .
.
.
.
.
.
.
although we obtained proof selection percentages for the other two micro benchmarks weakupto and ctltctl we do not show these numbers because the developers of the projects have not changed any code in the last revisions.
as expected icoqhas not selected any proofs for execution.
note that open source projects have frequent non code changes that have no impact on tests proofs these changes can include changes in documentation and metadata files.
finally we show the results for the three largest projects used in our study.
we format the results slightly differentlyfor several reasons including a large number of revisions anda low proof selection percentage that is not appropriate to be visualized with a bar chart.
table ii shows the results the table contains two parts and we discuss each part in turn.
the top part of the table shows result summaries for each project the sum and the average values are computed across24 revisions.
the third column shows the number of proofsselected by icoq and the fourth column shows the total number of proofs at each revision the fifth column showsthe proof selection percentage.
for example for v erdi we find that icoq executes a total of proofs while the existing technique executes proofs across the same set of revisions.
in other words across all revisions the proof selection percentage for icoq is .
note that the proofselection percentage is the sam e regardless of the execution environment ci env vs. lo env .
the bottom part of the table shows detailed results for v erdi.
we show the values for each revision the revision sha is s h o w ni nc o l u m n2 .table iii rat i o o f total times from table ii project ci env lo env flocq .
.
unimath .
.
v erdi .
.
rq2 how effective is icoq in terms of the proof checking time ina continuous integrationenvironment?
we used the three large verifica tion projects not only to obtain a proof selection percentage but also to obtain the proof checking time.
first we consider the ci env developmentenvironment.
recall that in ci env coq makefile will always execute all proofs and thus be costly.
on the otherhand icoq saves time by only running a subset of all proofs.
table ii shows the proof checking time.
columns and show the proof checking time for ci env when using coq makefile and icoq respectively.
table iii shows the summaries.
in summary icoq reduces the proof checking time .
.
and .
for flocq unimath and v erdi respectively.
note that ci env is of the highest importance due to the proliferation of ciss.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
although we also measured proof checking time for microbenchmarks we find that the time savings are insignificant in those cases due to very fast proof checking.
similar to regression test selection tools which inspired our work we believe that icoq will be most beneficial to large verification projects with many dependencies and elaborate proofs.
rq3 how effective is icoq in terms of the proof checking time outside a continuous integration environment i.e.
forverification on a user s machine ?
we were curious what savings could be obtained with icoq in the lo env development environment.
as when obtaining our answer to the previous question we measured the proof checking time forlarge verification projects.
columns and in table ii show time for coq makefile and icoq respectively.
we can see that coq makefile can save some proof checking time in lo env i.e.
whenever changes do not affect code.however even if a change has minimal effect on code e.g.
in revision 9403f6f5 for v erdi coq makefile runs almost all proofs.
we find table iii that icoq reduces the proof checking time .
a n d3 on average for flocq unimath and v erdi respectively.
we believe the greater reduction in proof checking time for v erdi is primarily due to its many long running proofs andopaque constants that end in qed.
.
in contrast unimath contains many non opaque constants whose processing cannotbe deferred during quick compilation and nearly all proofs in flocq have a relatively short running time.
v. d iscussion safety in a regression testing context a test selection technique is safe when for every possible change to a project the technique never omits to run a test affected by the change .analogously a proof selection technique is safe whenever no necessary proof checking task is ever omitted.
icoqcurrently gives no formal guarantee of safety in this sense a proof of safety would have to reason about coq s toolchain which is certainly possible at an abstract level but difficult to do at the level of code.
nevertheless verifying safety for a proof selection algorithm for coq and gallina is arguably morestraightforward than so for a test selection algorithm for an object oriented language with elaborate semantics e.g.
java which may include complicated features such as dy namic class loading.
t actic language dependencies icoq currently does not perform parsing and dependency analysis of custom tacticsdefined in the ltac language that occur in source files.
this means that an isolated change in the definition of a tactic never results in lemmas whose unedited proof scripts contain callsto that tactic being marked as changed even though the semantics of such a proof script may have changed.
analysis of ltac definitions is a planned future extension of icoq.
similar concerns as for ltac hold for custom coq language extensions written in ocaml that are used in some projects.
universe constraints sozeau and tabareau recently introduced support for generic coq definitions that can be used across universes of types .
however coq s toolchain forasynchronous proof processing ignores universe constraints since such constraints must be checked for consistency at the global level .
consequently coq projects that make heavy use of universe polymorphism are not good targets for icoq.
parameterized modules ac o q module encapsulates a collection of definitions and lemmas in a namespace.
aparameterized module or functor takes modules with a certain signature as input and can contain lemmas involving types inits parameters.
consequently the file that contains the functorhas corresponding proof tasks for those lemmas.
however no identifiers are exposed at the global level until the functor is fully instantiated with argument modules eluding coq ast .
this problem can be solved e.g.
by conservatively compiling the file to a .vo file checking all proofs.
however functors appear to be used rarely outside of the standard library ofthe projects under study only v erdi uses them and in a minimalistic way.
hence we omitted support for functors inthe initial version of icoq.
overhead icoq introduces several sources of overhead compared to lcf style top down processing of .v files into .vo files.
one source is quick compilation and task based proof checking itself which is performed in independentphases and requires book keeping for lemmas and proofs.additionally icoq requires computing a fine grained dependency graph and checksums to discover the impact of changesto a development.
consequently icoq may not be suitable to use in small scale projects since the overhead can make regression proof selection as a whole take longer to complete than straightforward compilation to .vo files similar conclusions were drawn for regression test selection .
vi.
t hrea ts to validity external our results may not generalize to all coq projects.
to mitigate this threat we used several micro benchmarks andthree large projects.
the large pr ojects use different feature sets of coq and target verification of disparate application domains.
we used revisions per project for large projects from segments in the version histories with active development thatwere straightforward to compile with coq version .
thefirst version with asynchronous proof checking support and the stable version available when we started development of icoq.
our findings could differ for longer sequences of revisions and different segments in software histories.
the number of revisions was determined by the setup cost and recent studies of regression testing techniques .
internal our implementation of icoq as well as our evaluation infrastructure may contain bugs.
to mitigate thisthreat we did extensive testing of our code and code reviews.
in particular we tested icoq on a benchmark set of pairs of revisions of small coq developments representing typical changes to proofs and definitions.
construct we implemented proof selection only for a single proof assistant coq .
although our technique shouldbe applicable to other proof assistants e.g.
isabelle hol further work is needed to confirm the applicability.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vii.
r ela ted work incremental verification kurshan et al.
consider the problem of incremental verification of models of systems assuming full verification is expensive.
they suggest techniques based on hashes of reduced models to avoid performing re verification when the required properties still hold in a changed model.
this is similar to smart hashing in regression testing .
henzinger et al.
consider incremental verifi cation of safety properties of programs using model checking.
in contrast to regression proving whose aim is to find failingproofs quickly their approach uses previous results to attempt to automatically overcome instances where a program change makes verification fail.
bohme et al.
introduced partition based regression verification that partitions the input space and gradually performs verification.
godlin and strichman define regression verification as establishing the equivalence of successive related versions of programs.
in effect regressionverification is a strengthening of regression testing which canonly provide limited evidence of preserved functionality.
parallel and asynchronous proof checking coq s 1970s precursor lcf was based on synchronous sequential interaction between a human prover and the proof tool .
this legacy is reflected in coq s read eval print loop and by extension in the top down interaction with coq files in classic interfaces such as proof general.
over time both theassumption on synchrony and on sequential interaction have been reconsidered which enabled us to develop icoq.
support for parallelism in construction and checking of proofs to exploit multi core hardware has been addressed previously in several proof assistants notably isabelle andacl2 .
isabelle leverages the support for threads in its host compiler poly ml to spawn proof checking tasks processed by parallel workers.
using a notion of proof promises proofs that require some previous unfinished result can proceed normally and become finalized when extanttasks terminate.
isabelle also includes a build system with integrated support for checking of proofs and management of parallel workers.
acl2 uses the thread based parallelism inlisp systems to e.g.
perform parallel proof discovery and fine grained proof case checking.
the lack of native threads in coq s host language ocaml prevents similar low cost fine grained parallelism .
however more coarse grained parallelism is possible at the level of processes.
parallelism at the task level usually necessitates support for some form of asynchrony which can then also be exploited at the user interface level to provide greater interactivity.
architectural changes in isabelle towards a document oriented asynchronous interaction model were pioneered by wenzel resulting in the prover ide pid e framework.
pide defines an xml based protocol between a proof assistant backend andclients such as ides.
efforts to bring asynchronous interaction to coq were initiated by wenzel and barras et al.
resulting in a new isabelle inspired document oriented inter action model and support for asynchronous proof processing in coq .
.
the potential of coq s new document model toimprove user productivity was highlighted in an extension to the eclipse ide called coqoon by faithfull et al.
which performs fine grained monitoring of changes to coq files and reactively processes modified definitions and proofs.
regression testing there has been more than three decades of work on regression testing techniques .
these techniques were the key inspiration for the work presented in this paper.
specifically our work is closely related to regression test selection rts .
most of the pioneering work on rts has studied techniques that collect for each test fine grained dependencies e.g .
statements a nd methods.
these techniques are frequently unsafe i.e.
they may miss to select some affectedtests for modern programming languages.
recently gligoric et al.
introduced ekstazi a n rts technique that collects dynamic file dependencies ekstazi is more inclusive than prior techniques.
interestingly we have decided to use finegrained dependencies for proof selection in icoq.
our insight is that gallina does not include the language features that makemany rts techniques unsafe for imperative languages e.g.
dependency injection class inheritance and macros.
to thebest of our knowledge icoqis the first proof selection tool.
build systems our dependency graph is similar to dependency graphs seen in build systems like google s bazel and microsoft s cloudmake .
bazel keeps track of dependencies on a level of targets.
similarly to how icoq discovers changed proofs and definitions these modern buildsystems discover affected targets by computing checksums ofthe files used by the target and then marking all nodes targets that depend on the modified node target.
viii.
c onclusions we presented a technique for regression proof selection in large scale verification projects and its implementation for the coq proof assistant in the tool icoq.
in particular icoq is suitable for use in continuous integration systems to quicklyfind failing proofs in rapidly evolving projects.
by trackingfine grained dependencies icoq avoids checking unaffected proofs as changes are made to files.
our evaluation shows thatusing icoqis up to faster than checking all proofs from scratch which is typical in a ci setting .
icoq can also be used from the command line as an alternative to the defaultmakefile based toolchain our evaluation shows that icoq is up to faster in this case.
while our implementation is coqspecific our technique works in any setting where it is possibleto separate the processing of source files with proofs scripts into a fast pre processing phase and a mostly independent potentially time consuming proof checking phase.
a cknowledgments we thank the anonymous reviewers for their comments talia ringer and zachary tatlock for their feedback on this work.
this work was partially supported by the us national science foundation under grants nos.
ccf ccf and ccf and by a google faculty research award.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.