understanding asynchronous interactions in full stack javascript saba alimadadi ali mesbah karthik pattabiraman university of british columbia vancouver bc canada saba amesbah karthikp ece.ubc.ca abstract javascript has become one of the most popular languages in practice.
developers now use javascript not only for the client side but also for server side programming leading to full stack applications written entirely in javascript.
understanding such applications is challenging for developers due to the temporal and implicit relations of asynchronous and event driven entities spread over the client and server side.
we propose a technique for capturing a behavioural model of full stack javascript applications execution.
the model is temporal and context sensitive to accommodate asynchronous events as well as the scheduling and execution of lifelines of callbacks.
we present a visualization of the model to facilitate program understanding for developers.
we implement our approach in a tool called sahand and evaluate it through a controlled experiment.
the results show thatsahand improves developers performance in completing program comprehension tasks by increasing their accuracy by a factor of three.
categories and subject descriptors d. .
testing and debuggingtracing d. .
distribution maintenance and enhancement keywords program comprehension asynchronicity full stack javascript .
introduction javascript has been selected as the most popular programming language for three consecutive years and it is the most used language on github .
javascript has been the lingua franca of client side web development for some years.
but platforms such as node.js have made it possible to use javascript for writing code that runs outside of the browser.
as such full stack applications written entirely in javascript from client side to the server side have permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than theauthor s must be honored.
abstracting with credit is permitted.
to copy otherwise orrepublish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa copyright held by the owner author s .
publication rights licensed to acm.
isbn .
.
.
.
seen an exponential growth recently.
node.js provides a light weight non blocking fast and scalable platform for writing network based applications.
it is also more convenient for web developers to use the same language for both front and back end development.
despite all the advantages this approach imposes many challenges on the developers comprehension of the dynamic execution of a web application.
understanding an application is the necessary first step of almost every software engineering task.
there are three groups of challenges involved in understanding the execution on the client side the server side and their interactions.
first javascript is a single threaded language and thus callbacks are often exercised to simulate concurrency.
nested and asynchronous callbacks are used regularly to provide capabilities such as non blocking i o and concurrent request handling.
this use of callbacks however can gravely complicate program comprehension and maintenance a problem coined as callback hell on the web by developers.
second the document object model dom and custom events timers and xmlhttprequest xhr objects interact with javascript code on the client and server to provide real time interaction all of which complicate understanding.
moreover node.js deploys the event loop model for handling and scheduling asynchronous events and callbacks the improper use of which can lead to unexpected behaviour of the application.
finally client and server code communicate through xhr messages and multiple messages and their responses can be in transit at a given time.
as in any distributed system there is no guarantee on the order or time of the arrival of requests at the server and responses at the client.
the uncertainty involved in the asynchronous communication makes the execution more intricate and thus more di cult to understand for developers.
despite the popularity of javascript and severity of these challenges there is currently no technique available that provides a holistic overview of the execution of javascript code in full stack web applications.
the existing techniques do not support full stack javascript comprehension .
in our earlier work we proposed a technique called clematis for understanding client side javascript.
clematis is however only designed for client side javascript and is agnostic of the server where most of the program logic is located in full stack applications.
in this paper we present a technique called sahand t o help developers gain a holistic view of the dynamic behaviour of full stack javascript applications.
our work makes the following contributions.
we propose a novel temporal and behavioural model of ieee acm 38th ieee international conference on software engineering full stack javascript applications.
the model is contextsensitive and creates lifelines of javascript execution on both the client and server sides.
the model connects both sides through their asynchronous communications to provide a holistic view of the application behaviour.
we create a visual interface for displaying the model tothe developers to help them understand the underlying mechanisms of execution.
we treat the model as amulti variate time series based on which we createa temporal visualization of the lifelines of javascript execution.
we implement our approach in a tool called sahand .
the tool is browser independent and non intrusive.sahand can handle the simulated concurrency of javascript through asynchronous execution of callbacks xhr objects timers and events.
we evaluate our approach through a controlled experiment conducted with participants.
our results show that using sahand helps developers perform program comprehension tasks three times more accurately.
.
challenges and motivation to comprehend the behaviour of a full stack web application one must understand the full lifecycle of a feature on both the client and server sides.
we elaborate on some the challenges involved using the examples illustrated in figures .
these are simple examples and the challenges are more potent in large and complex applications.
.
challenge server side callbacks receiving requests at the end points.
various types of http requests are received at the end points on a server.
node.js applications have one or more handlers assigned to each incoming request.
each of the handlers can change the flow of execution return a response to the client or passthe execution to the next handler.
the ability to register anonymous functions or arrays of functions can complicate the process of understanding and maintaining the handling and routing the requests.
example.
the example of figure depicts an end point for receiving a getrequest lines use express.js apis .
three items are registered as handlers of the locate request.
first an anonymous function is registered lines which can return a response to the client conditionally lines and prevent the execution of the remaining handlers.
the second assigned handler line is an array of callback functions cb1 and cb2 line .
an additional function cb0 can be pushed to the array at runtime based on dynamic information lines .
cb0 can itself a ect the control flow and send a response to the client in a specific scenario lines .
finally another anonymous function is added to the list of request handlers line .
understanding how a request is received and routed in the server depends on understanding the complex control flow of all these handlers.
this task becomes more challenging as the number of handlers increases in practice.
callback hell.
functions are first class citizens in javascript.
they can be passed as arguments to other functions and be executed later.
callback functions are widely used in javascript applications .
however it is not trivial to understand the javascript code that deploys callbacks.
in many cases callbacks are nested up to eight levels deep1var cb0 function req res next var region locateclient req.body .client if region .asia res.send customizedres req.body .content next 8var cbacks c b c b 9if user .isloggedin cbacks .push cb0 app.get locate function req res next if req.header appstats res.send statcollectionresponse req.body .
stats next cbacks function req res do stuff figure receiving http requests at an end point 1app.post cparse function req res 2customparse req.body function er list list .foreach function row index buildscript row req.body .format .
extractargs row function insttype row.foreach function arg i resolvealiases insttype arguments send response back figure callback hell or are assigned in loops which negatively impacts the readers ability to follow the data and the control flow.
this problem is know as the callback hell by developers .
to aggravate the situation node.js deploys the event loop model for scheduling and organizing callbacks.
the event loop is not visible to the developers but it determines the asynchronous execution on the server side.
example.
the code in figure depicts a simple example of callback hell.
many callback functions are passed as arguments to other functions in a nested manner lines .
callbacks can also get assigned in loops.
in the case of our example lines the same anonymous function is assigned as a callback for all iterations of a loop.
.
challenge asynchronous client side there are two asynchronous events typically used in the client side.
first asynchronous xhr messages are used to seamlessly communicate with the server without changing the state.
second timing events are utilized for performing periodic tasks or tasks that must take place after a temporal delay.
to handle asynchronous events developers typically use callbacks which are triggered when the event occurs.
however mapping the observed functionality of the event to its original source is a challenging task for developers.
this is especially so when the source and the callback are often semantically and temporally separate.
example.
the sample code in figure displays a simplified client side javascript code.
the updateunits function line posts a set of xhr requests to the server in a loop lines .
each of these messages has a callback function that is invoked upon receipt of the server s response.
thecallback function of all sent is the same anonymous function lines .
based on the content of the response data a timeout may be set that will execute after a certain delay line .
in another part of the code an interval is set that executes the periodicupdate function at periodic 11701function updateunits for var i i unit .length i function i .post extracturl i function data if data .requiresalert settimeout extractmessage data msgdelay i 9function periodicupdate .get pupdate function data do stuff setinterval periodicupdate updatecycle figure asynchronous client side javascript intervals throughout the lifecycle of the application.
periodicupdate in turn sends a get request to the server and continues its execution upon arrival of the response.
.
challenge network communication the server and the client communicate through request response messages.
hence the role of the network layer needs to be taken into account to obtain a holistic overview of the execution.
the requests do not necessarily arrive at the server in the same order as they are sent on the client side.
the processing times of di erent requests can vary on the server side as well.
moreover after the responses are sent from the server there is no guarantee on the time and order in which they will arrive at the client.
observing the behaviour of the application as a whole on both client and server sides is non trivial.
however this is necessary for developers to understand the full functionality of the features throughout their lifespan.
.
approach in this section we first present the building blocks of our model.
we then discuss the di erent steps of our approach and how they contribute to the generation of the model.
.
temporal and context sensitive model our approach creates a custom directed graph of the context sensitive executions of events and functions during their lifespan.
the model is designed to accommodate the temporal nature of function executions and the asynchronousscheduling mechanisms of full stack javascript.
the relations of functions and a synchronous events are also temporal to reflect the precise dynamic and asynchronous behaviour of the application.
we use the notations introduced here to show how our approach creates the model based on dynamic analysis.
vertices.
the vertices of the graph can be events or lifelines of function executions v ll lifeline of a function execution e a synchronous client server event function executions are the focal points of the model.
each function can go through four phases in its lifecycle.
hence a lifeline of the ithexecution of function fat time during execution ll f i manifests as one of the following phases table types of vertices in the model graph event typenode client serverinformation gathered domeventv e client user input information dom element handler function custom eventve client custom event type dom element handler function node.js eventve s server custom event type registered function timeoutsetv ll t c l i e n t servercustom id delay callbackfunction setter function timeout callbackvll t c l i e n t servercustom id callbackfunction setter function xhr sendvll x c l i e n t servercustom id sent data callback function opening andsending functions xhrcallbackv ll x c l i e n t servercustom id response data callback function opening andsending functions ll f i sch f scheduled as a callback act f active being executed ina f inactive in stack but another function is active te r f terminated execution has finished to understand the lifeline of each execution the model must account for all these phases.
there can be a maximum of one scheduling phase per function execution depending on whether it was triggered asynchronously.
this means sch f can occur or times in the beginning of a lifeline.
each execution has at least one active phase act f .
if the function invokes another function the callee becomes active and the caller becomes inactive until the execution of the callee is finished.
hence after an initial active phase a lifeline can contain an arbitrary number of ina f a c t f pairs before its execution is finally terminated te r f .
however there are cases where the execution is left unterminated for instance due to exceptions or ending the execution before a scheduled callback occurs.
in general the lifeline of function fcan be depicted as ll f act f ina f act f the other type of nodes included in our model are events.
the events can be synchronous or asynchronous and can be triggered on the client or the server code.
capturing the events and extracting their relations with the rest of the entities in the application is crucial for program understanding.
table summarizes the information required for analyzing various types of vertices that is captured by our approach in addition to the time of event occurrence.
edges.
the edges of the graph have three primary attributes namely time type and direction.
function lifelines are temporal entities over a contiguous time period.
a lifeline can interact with other lifelines and events at multiple points in time during its lifespan.
the edges must preserve the temporal aspects of the interactions and reflect them in the model.
the type of each edge represents the type of interaction between the two involved graph nodes.
function lifelines can interact with each other and with events through various types of relations which are summarized in table .
the direction of an edge represents the direction of the control flow between the involved nodes which depends on the type of the edge.
1171ina act ina ina ina ina act act act act act act act act sch act sch act act act act ina ina sch actclient serverwindow of synchronization between client and serverdom event handling dom event propagation programmatic evant function invocation actfunction termination callback scheduling act xhr sent by client xhr received by server act sch scheduled xhr callback invoked act server sends the responseevent loop ticks event act sch inaactive inactive scheduled client server act settimeout timeout expiry a b c d e f g h j act sch act schasynchronous callback i sync event kasynchronous callback act sch l m figure a sample temporal context sensitive and asynchronous model of events lifelines and interactions.
table interaction edges edge relation src dst sync gathered information ec calls ll ll yes args context info et terminates ll ll no return value ecs schedules ll el l no callback type ess schedules s ll ll no callback type ets timeout set ll ll no delay exs xhr send ll ll both data et triggers ll e yes event type ee emits el l yes event type table summarizes the algorithm of creating the model graph based on a selective trace of execution.
the rows of the table are the transactions in the trace and the columns formulate the handling of nodes edges and the logic of the algorithm for each transaction.
figure provides a schematic representation of the model.
we refer to the algorithm table and the model figure throughout the rest of the section as we discuss the formation of the model.
.
client side analysis on the client side each function is either invoked directly by another function or is triggered by a dom event a scheduled callback including timing events or a response to a request sent earlier.
next we discuss how we create the client side model based on these entities and their relations.
events and dom interactions.
our approach captures both dom and custom client side events.
for each event we gather information on the involved dom element the type of user action or programmatic event the user input and the invoked handler.
furthermore our previous study shows that around of the triggered handlers are not invoked directly by an event.
these handlers are indirectly called through event propagation mechanisms of javascript where a single event can trigger multiple handlers of the ancestors of the target element .
thus we capture propagated handlers and their relations with the original events.
upon invocation of the original handler we create a node representing the event and add it to the model table row1 figure a .
the node contains information about the target dom element and the input data if applicable .
if thecall stack at the time of event is empty and the event can be handled immediately a new lifeline is created for the handler and is initialized with an active phase.
however if the call stack is not empty and the browser thread is executing other javascript code the lifeline will start with a scheduled phase which will terminate and enter an active phase as soon as the stack and waiting event queue are empty and the handler can be invoked.
for each propagated handler a new lifeline is created linked to the same event node of the originalevent that is initialized with a scheduled phase table row figure b .
the lifeline enters the active phase after the execution of the original preceding event and its synchronous callers is finished but before any asynchronous event callback scheduled in the preceding event handler.
a new edge is created from the event node to each of the newly created handler lifelines.
the edge to the original handler s lifeline maintains the user action.
the edges to the propagated lifelines if any will indicate the occurrence of the propagation as well as the initial user action.
weintercept event handling by instrumenting the registrationof event listeners in the code.
our tracing technique then retrieves information regarding the element the event and the handler s once the event occurs.
timeouts.
there is often temporal and semantic separation between settimeout and the callback function.
even in the case of immediate timeouts the callback is not executed until the javascript call stack is empty and there are noother preceding triggered dom and asynchronous eventsthat are yet not handled.
hence a settimout s delay is merely the minimum required time until the timeout expires.
we intercept all timeouts by replacing the browser s settimeout similar to our previous work .
each timeout must be set within the current active phase of a lifeline.
upon setting a timeout we create a new life line representing the callback function execution that is initialized with a scheduled phase in the beginning.
an edge is created from current active lifeline to the newly created 1172table creation and extension of the behavioural graph based on the operations tll stack of function lifelines.
node.js event loop.
fe l i s to ffi r e dd o me v e n t s .
ue list of unhanded dom events.
the time and the side server client are included in all transactions.
row operation typenode edge instructions original dom event ev el e newv e ev el ll newv ll ev!handler tll t ll ll fe fe ed newe e src e dst ll action if js active ll.init phase.sch ue ue e o.w.
ll.init phase.act propagateddom events pe ep fe!head 8ei2 pe lli newv ll pe!handler tll t ll ll8ei2 pe d newe e src ep dst lli ep!action 8ei2 pe lli.init phase.sch fe fe ei timeout set to id newuniquetoid llc tll!head ll newv ll to id delay d newe ts src llc dst ll delay ll.init phase.sch if serverside to l l timeoutcallback ll tll.get to!to id ll.end phase.sch ll.start phase.act if serverside .pop ll!to id xhr send xhr id newuniquexhrid llc tll!head ll newv ll xhr id url method d newe xs src llc dst ll data ll.init phase.sch if serverside xhr l l xhr callback ll tll.get xhr!xhr id ll.end phase.sch ll.start phase.act if serverside .pop ll!xhr id server events llc tll!head e newv e ev ll newv ll ev!handler tll t ll lld newe e src llc dst e e!type d newe e src e dst ll ll.init phase.act llc.init phase.ina callbackscheduling llc tll!head ll newv ll callback d newe cs src llc dst ll ll.init phase.sch if serverside cb l l callbackinvokation ll !
head ll.end phase.sch ll.start phase.act if serverside .pop cb l l function invokationllc tll!head ll newv ll function d newe c src llc dst ll ll.start phase.act llc.start phase.ina function terminationllc tll!pop llp tll!headd newe t src llc dst llp llc.start phase.ter llp.start phase.act scheduled lifeline table row figure c .
the new edge includes the data regarding the details of the timeout delay and passed arguments .
the lifeline proceeds to an active phase when the timeout expires and the callback is executed table row figure d .
xhrs.
the server is treated as a blackbox at this stage.
our technique captures the information regarding sending the request e.g.
method data and the means of receiving the response e.g.
response data callback and how it is handled on the client side sync or async .
when the active lifeline sends a request we create a new node initialized with a scheduled phases table row figure e .
a new edge connects the current active lifeline to the new scheduled one.
the new edge encapsulates information regarding the request type of the request sync async url possible sent data .
when the response is received the captured information is completed with the response data table row figure f .
function executions.
our analysis of function executions is similar to creating a dynamic call graph that is temporal and context sensitive.
our method accumulates a trace of function executions initiated by regular function calls as well as the function executions caused by any of the mechanism discussed above.
the lifeline node representing the lifecycle of a function execution preserves the temporal states of the function andtheir respective edges represent their relations with the rest of the application.
lifelines and their edges map to particular executions of functions and maintain the information regarding the context of that execution e.g.
caller information dynamic arguments return values .
there are three possible cases of function invocation each of which is handled di erently.
first when a function is invoked without passing any callbacks a new lifeline node is created table row figure g .
the new lifeline is initialized with an active phase and the execution continues from there.
meanwhile an inactive phase is added to the caller lifeline which finishes and enters the active phase when the callee returns.
second when a function is invoked with a callback but the callback is not immediately synchronously executed a new lifeline is added for the callee.
the lifeline is initialized with a scheduled phase and is not marked as active yet table row figure h .
finally when a function is invoked with a callback function and the passed callback function is executed our method retrieves the existing lifeline where the callback is already scheduled and transitions it to anactive phase table row figure i .
synchronous callback invocations are treated as regular function calls.
every time a new lifeline is created it is added to a stack of lifelines t ll .
when the execution of a function lifeline terminates after an active phase the lifeline enters the terminated phase and is popped table row figure j .
1173our technique instruments all javascript functions in order to gather a detailed execution trace dynamically.
javascript functions can have di erent return statements in di erent intra procedural execution paths.
hence our method instruments all existing return statements individually.
should a path terminate without a return statement we inject adi erent logging function for marking the termination of the function.
function invocations are wrapped within our trace functions.
all arguments are examined and if they are functions additional instrumentation is added to distinguishpotential callback scheduling.
the analysis recursively checks the subprogram and if the potential callback is eventually invoked the actual callback invocation are annotated through additional tracing code.
further to distinguish between multiple invocations of the same function we maintain its contextual information in the caller function and update it per execution of the callee.
we pass the updated state to the callee through our instrumentation where it is used to customize the collected trace for that specific execution.
.
server side analysis our approach tracks the incoming requests from their arrival at the endpoints of the server.
the endpoint layertypically contains minimal logic but can highly a ect the flow of execution e.g.
routing to di erent handlers sending the response back .
the essence of this part of the analysis is similar to the client side.
however the focus at this stage is on challenges specific to server side javascript development such as the callback hell and the server side events.
before discussing our analysis of the server side behaviour of a javascript application we need to describe the role of the event loop on the server.
event loop.
the event loop consists of a queue of asynchronous events waiting to be executed at each tick of the loop when the stack of synchronous functions becomes empty.
the stack the event loop and the mechanisms of pushing popping events in from the loop determine the order and time of asynchronous events execution.
hence we need to consider them in our analysis.
for example there are three ways of scheduling an immediate callback in a node.js application namely immediate settimeout a timeout with delay setimmediate and process.nexttick however the order and time of execution of the callbacks using each method di ers based on the contents of the event loop.
process.nexttick pushes the callback to the front of the event loop queue regardless of the contents of the queue.
setimmediate enters the callback into the queue after the i o operations but before timing callbacks.
settimeout pushes the callback to the end of the queue after all existing callbacks .
hence even though the delay is set to itmay be executed with more delay in practice.
this shows the importance of reflecting the exact dynamic execution of asynchronous javascript in helping developers understand the behaviour of the application.
callbacks.
we capture all callback invocations synchronous or asynchronous their relations with the events in the loop that triggered them and the consequences of their executions.
when a callback is scheduled a new lifeline node is created in the server side of the model for the callback function which starts with a scheduled phase.
the respective asynchronous event is added to the list of events in the loop.
later when the event is popped and the callback is invoked the lifelineis retrieved the scheduled phase is terminated and the active phase starts.
this part of the analysis is similar to that of the client side although we consider the event loop and the respective scheduling methods table rows figure k .
events.
there is no dom on the server side and hence there are no user events.
however developers can take advantage of node.js events to trigger custom events and invoke their handlers using eventemitter s. a major di erence between eventemitter s and client side events is that the former are synchronous in nature and thus do not occur in the event loop.
although these events can be emitted in asynchronous functions the invocation of handlers is di erent from asynchronous handlers and thus has to be analyzed di erently.
in our model for each emitted event a new event node is created.
an edge connects the current active lifeline to the event.
the current lifeline enters an inactive phase.
a new lifeline in the active phase is created which is connected to the new event node through an edge.
when the execution of the handler finishes the inactive phase of the original lifeline will finish and it will be active again table row figure l .
.
connecting client and server in a typical web application execution starts on the client side with an event which can trigger an asynchronous request to the server.
this entails code execution on the server and sending the response back to the client which will complete the lifecycle of interaction when the execution terminates on the client side.
however javascript execution can continue on the client side even while the asynchronous request isbeing handled on the server.
the synchronization of the client and server side executions of a full stack feature occursin our model when the two ends communicate through xhr objects table rows figure m .
we create temporal models for both client and server sides.
due to the network layer in the middle each side initially treats the other side as a black box.
the connections between the two sides are made by marking and tracking the xhr objects.
because the client and the server may have di erent clocks we cannot use the timestamps produced by their respective clocks for synchronization.
hence we track all communications between the client and the server.
this way our approach can find windows of synchronization between the two sides which start by a request arriving at the server and end when the response is sent back to the client.
while this approach only provides a relative sense of time globally in practice this is su cient for the purposes of our approach since it is accurate for each specific full stack interaction.
.
visualizing the model in the last step of the approach we create a visual interface based on our inferred temporal model.
the visualizationshows the temporal characteristics of the lifelines events and their relations to facilitate understanding of execution patterns.
there are three major criteria that need to be considered in creating a visualization for temporal data .
time.
there are two types of temporal primitives .time points are specific lines on the time axis.
time intervals constitute ranges on the time axis.
our visualization usestime points to represent events and event loop ticks and time intervals to depict function lifelines and the phases of their lifespans.
the time axis can follow one of the common 1174client serverlifeline of function execution aevent queueon the client side.color specifiesevent type dom timeout xhr i different phases of lifelines are depicted with different colours bscheduling phase c interactions betweendifferent lifelines d simulated node.js event loop.each icon types maps to one event type.green and red borders represent pushand pop operations.
jxhr requestis sent g xhr responseis received h e f figure a snapshot of the visualization.
structures of time linear cyclic orbranching.
the structure of our time axis is a mixture of subsets of both linear and branching structures.
as a linear structure it follows the natural perception of time where time passes from past to future and the temporal primitives are ordered as opposed to a cyclic perception of time .
moreover similar to the branching structure multiple edges can exit a single temporal primitive node.
but unlike branching the outgoing edges actually occur at di erent timestamps and do not represent alternatives.
data.
data is the second criterion of time series visualization and can be examined from di erent aspects.
the frame of reference for our data is abstract since it does not encompass a spacial layout.
the data is multivariate since each node contains a set of information variables accumulated for the event or lifeline it represents.
representation.
the final criterion is the representation of the time relevant data.
this can be of two kinds static oranimated.
we deploy a static approach meaning that our visualization makes all the information available on screen on demand and hence the viewers can concentrate on the data itself and make comparisons on di erent parts of the model.
we collect multiple variables for each node.
presenting them all to the viewers can be overwhelming and obstruct the overview of the whole model.
we utilize basic interaction to allow users to view information on demand by clicking on any of the events.
lifeline visualization has been extensively used for displaying histories in domains such as medical records .
weincorporate custom lifeline visualization in the interface of our behavioural model.
visualization example.
figure displays a sample snapshot of the interface.
the main frame of the visualization depicts our lifelines.
each lifeline represents a particular context sensitive execution of a function a .
di erent phases of a lifeline are depicted as rectangles with di erent colours on the lifeline b .
if a lifeline represents an asynchronous call back it will start with a scheduling phase c .
lines betweencaller scheduler lifelines and their respective callee scheduled lifelines display the edges between the function executions d .once an xhr is sent to the server an edge connects the the scheduled callback to the handler on the server.
however due to the potential network delays the handler execution may start later than when the request is sent g .
the request is then dispatched and handled until the response is sent back to the client h .
in addition to the main panel there are two smaller panels to represent the client side events and the server event loop.
the first row on the client panel i represents the dom events and timeout and xhr callbacks that occur on the client side.
the colour and label of each cell on this row depict the type of each event.
the server s event loop is depicted at the bottom of the server panel j .
every time a user defined callback is scheduled a timeoutis set or an xhr is sent an event is pushed to the event loop marked with a green border .
when it is a callback s turn to be executed the corresponding event is popped from the loop marked with a red border while the remaining events if any can still be observed in the loop.
finally the horizontal axis below both panels represents the time.
.
implementation we implemented our approach in a tool called sahand.
we instrument javascript code on the server side at startup using a proxy server built with node.js and express.js and on the client side code on the fly.
we create an ast ofthe code using esprima instrument the ast using estraverse and serialize the ast back into javascript code with escodegen .
the visualization is built on top of the timeline view of google chart tool .
sahand is publicly available .
.
evaluation we conducted a comparative controlled experiment to investigate the e ects of using sahand on the performance of developers when understanding full stack web applications.
our experimental dataset is available online .
.
experimental setup the participants in our study are asked to perform three comprehension tasks on a full stack javascript application.
experimental subjects.
we recruited participants for 1175table comprehension tasks of the experiment task description t1 understanding full cycle implementation of submitting a correct answer on the client side.
t2.a understanding time triggered feature of terminatinggame rounds managed by the server.
t2.b detecting a potential for an event race condition duringclient server communications.
t3.a understanding the purpose of a new feature involvingnested callbacks.
t3.b understanding the asynchronous execution of a functioninvolved in nested callbacks.
the experiment males and one female aged between and .
all of the participants are graduate students at ubc who regularly program with javascript.
none of the participants had used sahand prior to the experiments.
experimental object.
we use math race as our experimental object.
it is an open source online game that allows multiple players to compete over solving simple mathematical problems.
during timed cycles of the game they players can answer questions keep the history of their scores and enter the game s hall of fame if they achieve high scores.
we chose this application because it is a full stack javascript application built on node.js.
it is also relatively small about loc of javascript on each of the client and server sides and hence it is feasible for our participantsto understand its main features during the limited time of the experiment about minutes .
although it is a small application it employs many advanced features such as asynchronous events and callbacks.
our participants had never seen math race before the experiment.
experimental design.
the experiment had a betweensubject design.
we divided the participants into two groups.
the experimental group used sahand for performing a set of comprehension tasks.
the participants in the control group were allowed to use any existing web developmenttool.
they all selected google chrome s developer tools one of the most popular client side development tools as they all self reported as experts in it.
we also provided the control group with jetbrain s webstorm a popular javascript ide for working with the server side code of the experimental object.
in contrast the experimental group were only allowed to view the code in addition to sahand s visualization and not permitted to use an ide or debugger.
we limited their access to other tools because we wanted to gain a better control of sahand s impact on understanding.
task design.
we designed a set of tasks that represented common comprehension activities performed in normal development proposed by pacione et al.
.
each of our tasks covers multiple activities and also involves elements specific to javascript comprehension.
the tasks are summarized in table .
variables.
we wanted to measure the performance of developers in performing program comprehension tasks.
thedependent variables dv should quantify developers performance.
our design involves two interval dependent variables task completion duration andaccuracy.
we also considered two nominal independent variables iv .
the first iv is the tool set of tools used for the experiment and has two levels.
one level is sahand and the other is the set of chrome s devtools and webstorm.
the second iv is the expertise level of participants.
we wanted to investigate the e ectsof expertise of the participants on how they comprehend web applications.
we classified participants into two groups namely experts and novices based on their responses to a pre questionnaire form described below .
experimental procedure.
this consists of four parts.
in thefirst part the participants completed a pre questionnaire form where they ranked their expertise in web application development using a point likert scale and prior experience with software development in general.
we used a combination of their self reported expertise and experience to assign an expertise score to each participant.
the expertise score was used to assign the participant to either the experimental or control group.
we manually balanced the distribution of expertise in both groups.
we also used the expertise score to assess whether the expertise of participants a ects their program comprehension performance.
in the second part of the experiment we presented a short tutorial on sahand for the experimental group.
however we did not present any tutorial to the control group as they identified themselves asexpert in chrome developer tools.
both groups were given a few minutes to familiarize themselves with the settings of the application the object application and the tools.
in the third part the participants performed the tasks .
we presented each task to the participants on a separate sheet of paper and measured the time from when they started the task until they returned the answer.
this setup ensured that the time tracking process was not biased towards either the examiner or the participant.
we measured the accuracy of the answers later based on a grading rubric that we had finalized prior to conducting the study.
the accuracy ofthe tasks could be quantified with a grade between and per task.
the tasks and their rubrics along with the rest of documentations of the study are available online .
in the fourth part when the participants finished all of the tasks they were given a post questionnaire form.
theform asked about their experience with the tool used inthe experiment and its pros and cons.
we also solicited participants opinions on the features they thought would be useful for a web application comprehension tool.
.
results we were interested in observing the e ects of tool and expertise on task completion duration and accuracy.
both variables are conceptually dependent although we did not observe a correlation between them in our experiments.
imagine a case where a participant finishes the tasks early thinking she has found the correct answer but the answer is incorrect or incomplete.
in this case the fast completion of a task is not an improvement since the purpose of the question is not fulfilled and the participant has not performed better.
because of this relationship we performed a multivariate analysis where we examined the pair of both duration and accuracy as the dependent variable.
we performed a set of multivariate analysis of variance manova tests to investigate the e ects of tool and expertise on the integration of duration and accuracy.
using manova entails two advantages for our analysis.
first it can reveal di erences that are not discovered by anova.
second it can prevent type i errors that may occur when multiple independent anova tests are conducted.
we performed the manova tests on the total duration and accuracy combining all tasks .
next we ran a manova teston each individual task.
if the results of a manova test t1 exp t1 ctrl t2 exp t2 ctrl t3 exp t3 ctrl tot exp tot ctrl020406080100accuracy figure accuracy results.
gold plots display experimental sahand group and green plots display the control group.
higher values are better.
were significant we examined the univariate tests anova to see if the significance in performance improvement was due to the duration accuracy or both.
examining the total results we found a significant main e ect of tool p .
on the group of accuracy and duration but no significant main e ect of expertise p .
.
for individual tasks too we found a significant main effect of tool t1 p .
t p .
t p .
but not of expertise.
we then examined the univariate tests anova for each significant result to find which dependent variable s contributed to the significance.
from the results we found that there is a statistically significant difference p .
in accuracy between the group using sahand m sd and the control group m sd .
however we did not find a statistically significant di erence for duration p .
between the group using sahand m sd and the control group m sd .
the above results suggest that that task completion accuracy was the determining factor in the significance of the results of the multivariate tests.
the accuracy results are shown in figure .
we find that sahand helped developers perform comprehension tasks three times more accurately in about the same amount of time used by the control group.
.
discussion fast is fine but accuracy is everything .
using sahand significantly improved the accuracy of each individual task in the experiment.
the large di erence between the means of two groups and the high confidence of the test results emphasize the impact of the challenges of understanding full stack javascript even for a simple application as our experimental object.
tasks t1 and t2 were seeking developers understanding of two of the basic features of the application whose implementation was divided between both ends of the application.
the tasks also involved understanding features such as event propagation on the client side and asynchronous time management on the server side.
task t3 required understanding the execution of a nested callback code segment which can create implicit and intricate connections in the application.
manual analysis of the answers of the control group showed that they all had an incomplete and sometimes incorrect vision of the full stack execution of the features.
their mental model of the application s behaviour missed both entities and connections on both client and server and their interactions.
they gained significantly lower accuracy scores whilespending about the same time as the experimental group.
on the other hand sahand users were able to see all the involved entities and their relations.
the model allowed them to extract the information usually hidden in the application and finish the tasks much more accurately.
it will get better ... in time .
the results did not show a statistically significant di erence of task completion duration between experimental and control groups.
manual investigation of the control group s answers showed that almost all of them had incomplete and not necessarily wrong answers for most of the questions.
therefore it is possible that these participants spent the whole time on a small portion of the answer compared to the experimental group.
this means that overall as the multivariate tests found sahand users performed better than the control group as they used approximately the same amount of time for providing significantly more accurate answers.
further none of the participants in the experimental group had seen sahand before the experiment.
we observed that sahand users looked more often at the source code and spent more time analyzing and interpreting the interface at the beginning of the session.
however near the end of task t1 they would shift almost all of their attention on the model while solving the problems.
we believe this is due to two main reasons the users required a short learning phase for performing a real task although they had a tutorial in the beginning only after multiple comparisons between the interface and the actual code were the users able to trust sahand as a fair representation of the behaviour.
we believe that developers will get faster using sahand once these barriers are overcome.
examining the average time spent on each task we observed that sahand users finished t1 only faster than the control group in the beginning of the session.
however by the end of the session sahand users finished t3 faster on average.
this result strengthens our intuition that by adopting the tool for a longer period of time users will become much faster in performing the tasks.
user feedback.
according to the post questionnaire forms allsahand users found the tool useful.
they particularly liked the overview it provided of the whole interaction.
they found the unified client server view most useful.
the participants also found it easy to infer function relations from the model and liked the abstraction and filtering of details in the visualization.
however some of them mentioned that the context sensitive depiction of functions can become overwhelming in large interaction sessions.
they requested interface features such as direct links to the code showing connections to the dom and integration with a debugger.
these are interesting directions for future work.
threats to validity.
the first internal threat is the examiner s bias in measuring the time.
we addressed this threat by enforcing a mutual supervision on timekeeping by theexaminer and the participant.
the start and end time ofeach task were marked by the exchange of sheets of paper containing the question and the answer of that task between the examiner and the participant.
the same threat arises from examiner s bias while marking the accuracy of the tasks.
we mitigated this risk by devising the rubrics of each task before conducting the experiments.
the rubrics were later used to mark the accuracy of the answers.
another threat is the impact of the expertise level of the participants on their performance in the experiment.
we eliminated this threat 1177by determining the expertise level of participants through a pre questionnaire form before conducting the experiments.
we used this information to rank participants into multiple bins based on their expertise levels and then used random sampling to assign the members of each bin to one of the control and experimental groups.
the tools used by the control group can introduce another threat.
we avoided this threat by letting the participants choose the browser development kit for client side analysis all chose chrome .
for the server side we provided them with webstorm a popular enterprise ide for web development.
we resolved the bias of the experiment tasks by designing the tasks based on a framework of common comprehension tasks .
using this framework we also eliminate a potential external threat arising from the representativeness of the tasks.
the second external threat is the representativeness of the participants.
we addressed this threat by recruiting graduate students who regularly performed and researched javascript development.
many of the participants had professional development experience during or prior to the time of this work.
however our participants were not full time professional developers and this could still threaten the validity of our experiment.
finally to ensure the reproducibility of the experiment we used an open source experimental object and made our tool the tasks questionnaires and the rubrics public .
.
related work javascript analysis.
there are numerous static analysis techniques proposed for javascript analysis in di erent domains .
we did not choose a static ap proach since many event driven dynamic and asynchronous features of javascript are not well supported statically.
dynamic and hybrid javascript analysis techniques have at tempted to solve the shortcomings of static analysis .
however existing techniques focus on the client side and do not consider the server.
magnus et al.
recently proposed a technique to build an event based call graph for node.js applications .
there are two di erences between their work and ours.
first sahand considers functions in the graph as temporal and context sensitive nodes which can interact with each other and with events throughout di erent phases of their lifecycle.
second sahand accounts for various means of asynchronous scheduling.
it integrates client information client server interactions and asynchronous server execution and creates a behavioural model.
it is through this model that sahand can provide a holistic and temporal overview of full stack execution.
asynchronous events.
di erent approaches target asynchrony in di erent domains such as comprehension debugging and testing.
frameworks such as arrows have been proposed to help developers understand and avoid asyn chronous errors.
zheng et al.
used static analysis to findasynchronous bugs in web applications.
wave is a test ing platform for finding concurrency errors on the client side.
libraries and features such as async.js and promises have been adopted to tame the asynchronous javascript issue.
despite being very useful and promising async.jsis not native to javascript.
both async.js and promises require the current and future code to follow specific design and syntactic guidelines which impede their wide adoption.
feature location record replay and tracing.many papers have focused on locating the implementation of ui and interaction based features in web applications.
however they only retrieve the client side implementation of a feature and they require a constant manual e ort for selecting the elements or features under investigation.
firedetective is a firefox add on that captures the client server interactions to facilitate comprehension.
although its purpose is similar to sahand it only supports partial java execution on the server side.
further it does not support a higher level model or a temporal visualization of the trace.
record and replay techniques aid the understanding and debugging tasks of web applications .
the goal ofthese techniques however is to provide a deterministic replay of ui events without capturing their consequences.
unlike sahand they don t collect detailed traces of the execution and only support client sider javascript.
jalangi is a multipurpose framework for record replay and dynamic analysis of javascript .
unlike sahand it neither extracts full stack interactions nor does it provide a high level visualization of the model as its goals are di erent from ours.
tracing techniques such as firecrystal and dynaria collect traces of javascript execution selectively.
in our prior work we introduced clematis a tool for code comprehension which creates a behavioural model of the captured trace.
clematis focuses entirely on the client side code and does not take into account server side features such as the routing and handling the requests and responses.moreover it does not target callbacks their scheduling transmutations and interactions.
overall clematis introduces a more primitive type of model that does not support the temporal nature of execution.
unravel is a more recenttool for supporting developer learning.
similar to our work these tools provide a high level abstraction and visualizationof the trace.
however all these techniques only focus on the client side javascript.
sahand on the other hand traces models and connects both client and server side traces with a focus on asynchronous javascript execution.
.
conclusion full stack javascript development is becoming increasingly important yet there is relatively little support for programmers in this space.
this paper introduced sahand a novel technique for aiding developers comprehension of full stack javascript applications by creating a behavioural model of the application.
the model is temporal and context sensitive and is extracted from a selectively recorded trace of the application.
we proposed a temporal visualization interface for the model to facilitate developers understanding of the behavioural model.
the implementation of the approach is available as an open source node.js application .
we investigated the e ectiveness of sahand by conducting a user experiment.
we found that sahand improves developers performance in completing program comprehension tasks by increasing their accuracy by three times without a significant change in task completion duration.
.