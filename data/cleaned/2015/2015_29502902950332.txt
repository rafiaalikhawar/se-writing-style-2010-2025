echo instantaneous in situ race detection in the ide sheng zhan jeff huang parasol laboratory texas a m university usa echo tamu.edu je cse.tamu.edu abstract we present echo a new technique that detects data races instantaneously in the ide while developers code.
echo is the rst technique of its kind for incremental race detection supporting both code addition and deletion in the ide.
unlike conventional static race detectors echo warns developers of potential data races immediately as they are introduced into the program.
the core underpinning echo is a set of new change aware static analyses based on a novel static happens before graph that given a program change e ciently compute the change relevant information without re analyzing the whole program.
our evaluation within a java environment on both popular benchmarks and realworld applications shows promising results for each code addition or deletion echo can instantly pinpoint all the races in a few milliseconds on average three to four orders of magnitude faster than a conventional whole program race detector with the same precision.
ccs concepts software and its engineering !software maintenance tools software veri cation and validation keywords data races change aware instantaneous detection ide .
introduction data races are among the hardest to debug types of bugs in software systems.
as software becomes more parallel race detection techniques are proliferating .
several industrial strength tools have also been deployed.
most techniques and tools however are designed for late phases of the software development cycle e.g.
testing or production where the whole program is completed.
although races detected in a later phase are more likely to be real bugs scaling to programs with a large code base without sacri cing detection coverage or accuracy is di figure instantaneous race detection by echo.
cult.
moreover the later a bug is found the more expensive it would be to x it .
we advocate detecting races early in the programming phase ideally in the ide such that it is both easier to scale the race detector by amortizing the analysis cost and cheaper to x the detected races by providing developers early feedback.
however existing ides e.g.
eclipse lack the support for detecting sophisticated bugs such as data races because of the expensive analysis cost.
for example static race detectors typically require pointer analysis which often takes several seconds or minutes to compute for realistic programs.
upon a code change in the ide instead of running a conventional race detector and waiting for seconds or minutes developers would favor an in situ race checker running in the background that similar to checking syntax errors detects races instantaneously as they are introduced and as non intrusively as possible.
in this paper we present echo a new technique and a prototype tool that realize the above vision in eclipse.
a snapshot of echo is shown in figure see also a video demo at .
the two statements at lines form a race on a shared variable x.echo detects this race and displays the bug warning instantly i.e.
in a few milliseconds as the two statements are introduced into the program.
when either of the two statements is deleted or the statement at line 37is moved into the synchronized region echo will invalidate the warning again instantly.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
in a nutshell echo leverages the fact that programming often involves frequent but small changes which can be analyzed quickly together with only their respective dependencies without re analyzing the whole program.
yet for race detection the problem of how to e ciently update the change e ects and correctly relate them to races is quite challenging.
we develop a new change aware race detection algorithm based on a novel graph representation of the happens before relation that handles a realistic subset of multithreaded java programs see section supporting both addition and deletion of di erent types of statements.
a critical component of our algorithm is an on they points to analysis that determines the heap locations accessed by program statements and pointer aliases for reasoning about lock operations.
although points to analysis has been intensively studied before including a few incremental algorithms there is no previous technique that is applicable within an ide in which both code addition and deletion must be handled.
in particular handling deletion is di cult because it may involve complex dataow analysis and invalidation of the existing points to set.
a reset then recover algorithm does not scale because the analysis is cubic in the program size.
we develop a novel reachability based algorithm that optimizes the invalidation of the points to set when a statement is deleted achieving as much as 41x see section .
speedup over the resetthen recover algorithm on a real world application.
like other static race detectors echo is incomplete and can report false positives due to the limitation of static analysis.
however compared to conventional race detectors we argue that echo is less over whelming to developers as they receive immediate feedback on potential races rather than getting a large number of warnings all at once.
moreover echo implements two optimizations to improve precision.
first echo uses a hybrid algorithm combining happens before and lockset.
as observed by other researchers the hybrid algorithm is e ective in pruning false positives reported by purely locksetbased detectors.
second echo builds on top of an object eld sensitive but context insensitive locally ow sensitive andersen style analysis .
the eld and locally ow sensitivity e ectively reduces false positives caused by objectlevel false sharing and ow insensitivity within a method.
our evaluation on a variety of popular benchmarks and real world applications shows that echo detects of the known races with a false positive ratio and it takes only 5ms on average to handle each change.
compared to a whole program race detector with the same recall and precision echo is three to four orders of magnitude faster.
we highlight our contributions as follows to our best knowledge echo is the rst static race detection technique that makes instantaneous in situ race detection possible in the ide.
we present a set of novel change aware static analyses including e cient data structures and new points to analysis algorithms that enable echo to quickly respond to both code addition and deletion.
we present an evaluation of echo on both popular multithreaded benchmarks and real world java applications and demonstrate that it can pinpoint races in milliseconds with a reasonable precision.
we also identify three common sources of false positives.
.
overview we rst present an overview of echo with an arti cial example and then discuss the technical challenges.
example.
imagine that in an ide the developer has written the java program in figure a but not yet the code in the gray region i.e.
the changes .
the program starts two threads testing a vector container by storing and retrieving objects of the conference class which has two attributes name andyear.
the main thread t1 rst creates twoconference objects c1andc3 and assigns c1to another object reference c2.
it then adds c2to the vector vand starts the child thread t2 passing vas an argument.
t2 traverses the vector and prints out each element contained in it.
the vector implementation here is not thread safe because its methods are not synchronized.
however there is no data race in this program so far because all operations are ordered by happens before i.e.
t2 must execute after the thread start operation by t1 at line .
.
echo in action suppose the developer now performs the changes .
we next show how echo reacts to them one by one.
change .when the rst change v.add c3 is introduced echo displays two races between lines and .
the reason is that the change adds the second conference object referenced by c3 to the vector which modi es both the size of the vector count and the corresponding array element elems at line .
these two writes are not ordered with the two method calls v2.size and v2.get i byt2 which respectively read count and elems on the same vector at lines 19and .
none of these four accesses is protected by any lock and they form two races.
changes .upon seeing the two race errors the developer attempts to x them by introducing change adding synchronized keyword to both add e andsize .echo detects that the race is xed because both of the two accesses are now protected by the same lock and clears the warning.
however the other race remains because the access at line 27is not protected.
as a result the developer proceeds to introduce change adding synchronized toget i .
after this change the race warning also disappears because echo detects that both accesses to the array element are now protected by the same lock.
changes .now the developer adds c3.incrementyear at line .echo detects a new race because this method call modi es the attribute year at line 8and it is not ordered with the method call p.tostring byt2 at line51 which reads year at line .
both c3 and pcan refer to the second conference object and these two methods are not synchronized so the two accesses to year form a real race.
to x this race instead of adding synchronization the developer realizes that c3 should not be added to the vector and hence performs change deleting v.add c3 at line .
upon the deletion echo invalidates the race warning because now lines 8and 10access di erent objects and pcannot refer to the second conference object.
.
echo in a nutshell figure b shows an architectural overview of echo consisting of three components a change tracker a race detection engine and a race displayer.
the rst and the third components are both ide speci c. the second component takes one or more changes as input and runs a change776 a example d static happens before graph b architecture overview c points to graphchangetracker 1 in decrementalrace detectionstatic hb graphchange awarepoints to analysischange aware 4 racedisplayerc1o33t c2c3o35evo36v1v2thrd2o38p 1 mainv.addt.startthrd2.runv.addv2.sizev2.getp.tostringread v2.countread v2.t read p.yearwrite v.t t1t2 write t1o36.t read t2o36.countread write v.countwrite t1read t1 t2o33.yearo35.yearwrite read t2read t1 t2 1 write t1 4 c3.incyear 4 read write c3.year 3 1234567891011121314151617181920212223242526272829class vector object elems int count vector this.elems new object public int size return count void add object e object t this.elems t e writes t object get int i object t this.elems return t reads t class conference string name int year conference string n int y this.name n this.year y public void incrementyear this.year public string tostring return name year public static void main string args string name fse int year conference c1 new conference name year object c2 c1 conference c3 new conference name year vector v new vector v.add c2 thread2 thrd2 new thread2 v thrd2.start v.add c3 v.add c3 c3.incrementyear class thread2 extends thread vector v2 public thread2 vector v1 this.v2 v1 public void run for int i i v2.size i object p v2.get i system.out.println p.tostring 1 2 synchronizedsynchronized4 5 figure echo technical overview.
aware algorithm to detect races.
the algorithm relies on three mutually dependent graphs a points to graph a call graph and a static happens before shb graph all of which are computed in a change aware manner only those facts nodes and edges in the graph that are a ected by the change are recomputed and the rest of the graph remains the same.
the points to graph and call graph are standard.
we refer the readers to previous work for their background.
the shb graph is a new data structure static happens before shb graph.
the shb graph augments the call graph with directed edges representing the happens before relation between abstract threads and heap accessing statements read or write to abstract heap locations ahl a eld of an abstract object or an array element.
figure d shows the shb graph of the example program.
the edge v.add!t.start means that v.add should be executed before t.start andt.start!thrd2.run because thrd2.run can only execute after the thread is started.
the edges are transitive.
in addition for the race detection algorithm to identify con icting accesses to ahl the shb graph is also associated with two states from each heap access statement to the corresponding ahl a read set and a write set denoting reads and writes to the ahl respectively.
for example the method v.add byt1 writes to t and count onv.
because vcan point to o36 these two writes by t1 are included in the write sets of o36.t and o36.count respectively.
algorithm echo race detection p input p a set of program changes.
additions a1 a2 ... deletions d1 d2 ... .
global states ptg points to graph cg call graph shb static happens before graph.
ptg cg updatepointstoandcallgraph p shb updateshbgraph p ptg cg detectdataraces shb ptg .
algorithm overview.
an overview of our race detection algorithm is shown in algorithm .
given a set of pro gram changes p including both addition and deletion1 the points to graph and call graph are updated rst we will show how in section .
then ptogether with the changes in the call graph cg are used to update the shb graph.
finally we check if any update in the points to graph ptg and the shb graph shb can lead to new races or invalidate any existing races.
there are two basic steps nding and invalidating con icting accesses and checking happensbefore and lockset .
the rst step tracks changes of states i.e.
read and write sets associated with each ahl.
if the write set contains accesses from at least two di erent abstract threads or at least one access from a thread that is different from any thread in the read set the two corresponding accesses are considered con icting.
the second step checks for the two con icting accesses their happens before relation and locksets which can be computed using the shb graph.
if the two accesses are not ordered by happens before or their locksets do not overlap they are reported as a race.
example.
the points to graph and the shb graph before the changes are shown in figure ignoring the colored nodes and edges.
when v.add c3 is added both of the two graphs are updated.
a new edge c3 eis added in the points to graph because c3is passed as the method argument.
a new node v.add is added in the shb graph and a new edge from t.start is added to this new node.
in addition because pcan now refer to o35 the read set of o35.year is updated to include t2.
the new v.add node has the same read and write statements as that of the rst v.add node before t.start .
however the di erence is that this node is not ordered with the nodes from t2.
hence by checking happens before and lockset related to the new accesses too36.t ando36.count our algorithm detects two races and .
similarly when c3.incrementyear is added a new c3.incyear node is added to the shb graph and a new edge from t.add is added to the new node.
both the read and write sets of o35.year are updated to include t1 because c3.incrementyear reads and writes the eld 1note that a code update can be treated as two changes deletion of the old statement and addition of the new statement.
large code chunks can be treated as a sequence of small changes.
777p defn e program defn class cffield meth g class decl field t f eld decl meth c m arg s return z method decl s j x new c allocate j x y simple assign j x y.f eld read j1x.f y eld write jox o.m arg method call j x y array read j1 4x y array write j1 t.start thread fork j3 t.join thread join j synchronized x s lock jj loop b s loop j if b s conditional j e other figure simjava.
year and c3can refer to o35.
the read set of o35.year contains t2 so the two accesses at lines 8and 10are conicting.
by checking their happens before and locksets our algorithm detects a new race .
.
technical challenges to achieve both fast speed and good precision there are several tough technical problems that we must solve .change aware race detection.
how to correctly and e ciently react to a program change?
how to correctly handle di erent types of changes?
how to e ciently maintain the happens before relation and lockset upon a change?
.change aware points to analysis.
how to soundly update the points to graph and call graph upon a change?
by soundness we mean that any true points to relation must be represented in the points to graph.
meanwhile we would like to compute a points to graph that is as precise as possible.
for example in figure before change the variable pcannot refer to o35.
otherwise a false positive would be reported.
.sound static happens before graph.
how to construct a sound shb graph such that any true happensbefore relation is represented and no reachable heap access is missed?
how to handle back edges caused by loops or recursion?
how to identify abstract threads that may have multiple runtime instances?
we next present our algorithms to address these challenges.
.
algorithm we rst introduce a multithreaded language simjava which contains a subset of java basic constructs for multithreaded programming.
based on simjava we then present our change aware analysis algorithms.
the simjava language.
simjava is inspired from concurrentjava with a few di erences and extensions that make it more powerful for expressing concurrency and also cleaner for change aware analysis.
figure shows the syntax.
simjava supports three types of interthread synchronization operations fork join and synchro table static hb graph construction.
array accesses are treated similarly to eld accesses as to a single eld and are omitted.
statement nodes x y.f read y.f 1x.f y write x.f ox o.m y 8oc2pts o call oc m 2t.start 8oc2pts t fork oc 4t.join 8oc2pts t join oc synchronized x 8oc2pts x lock oc s unlock oc jloop b s unroll twice s s two fake nodes 8oc2pts t start oc end oc edges 8oc2pts t fork oc !end oc end oc !join oc method call s o.m 8oc2pts o node s !firstnode oc m lastnode oc m !nextnode s 8s1 s22m s1 s2 node s1 !node s2 nized .
the forkand joinoperations together form the interthread happens before relation and synchronized forms the lock mutual exclusion relation.
statements include the typical operations for object allocation assignments eld and array read and write method invocation as well as the concurrency primitives.
all these statements are analyzed in our race detection.
in addition simjava supports the loop operation jloop b s that evaluates a boolean variable band iterates the statements s .
the loopoperation re ects loop constructs such as forand while .
for race detection loopoperations must be considered in our algorithm because they may spawn multiple threads and may also introduce multiple other types of synchronizations.
however conditionals are ignored because our algorithm is path insensitive.
.
change aware data race detection the core of our algorithm is a change aware static happensbefore shb graph powered by an on they points to analysis.
we rst present the shb graph construction algorithm.
.
.
shb graph construction starting from a unique entry method e.g.
main the shb graph is constructed following the rules in table .
there are nine di erent types of nodes in the shb graph corresponding to the nine statements insimjava .
eld read and eld write are similar to array read and array write except that the index to eld is xed and bounded but to array it is not.
to improve e ciency array index is often ignored in static analysis.
we also do not distinguish di erent array elements instead we create a single eld xfor each array object aand consider all accesses to aas to a .
in this way and1 4are equivalent to and respectively.
we hence omit the discussion of and1 in the rest of this paper.
the synchronization statement synchronized x s generates two nodes lock and unlock inserted at the beginning and end of the synchronized block marked by and respectively.
in addition we introduce two fake nodes for each abstract thread start and end which are used to construct the inter thread happens before relation.
abstract heap location ahl .
for eld and array 778read write node we maintain a linkfrom the node to one or more ahl which corresponds to the abstract data the node accesses.
the ahl is identi ed by o.f for eld or o.x for array where ois an abstract object in the pointsto set of the base variable.
each ahl is associated with two states a read set and a write set recording write and read accesses to the location from abstract threads.
this information is used to identify con icting heap accesses.
abstract thread and lock.
for the other nodes each node is associated with one or more abstract object which is computed using the points to set of the corresponding base variable.
for example for fork and join and start andend their abstract object is the corresponding abstract thread identi ed by the points to set of tint.start t.join or the main method for only the main thread .
forlock andunlock their abstract object is the corresponding abstract lock the points to set of xinsynchronized x .
handling loop.
for loop statements j loop b s we create more than one sequence of nodes for s because each smay generate multiple reads writes or fork multiple threads.
the challenge is that the number of loop iterations is unknown statically.
nevertheless for race detection it su ces to unroll the loop twice.
the reason is that data races involve only two abstract threads and two memory accesses.
unrolling a loop twice will guarantee to expose the same set of races as unrolling more than two times.
similarly we handle recursion by unrolling all loops in the call graph twice and removing the corresponding back edges.
statement location.
each node in the shb graph is also associated with a unique location corresponding to the program location of the statement.
the unique location is used to determine the program order for statements from the same method.
for synchronized blocks and loop statements the locations of their corresponding nodes are treated in the following way.
for lock and unlock their locations correspond to the locations of and of the synchronized block.
for loops we add a loop iteration identi er either i1ori2 to each node all nodes with i1should happen before nodes with i2unrolled from the same loop statement.
together with the call graph the node location information is used to compute the intra thread happens before relation.
happens before.
the happens before edges are constructed over fork!start andend!join for each abstract thread object and over method calls.
for a method call s o.m for each abstract object oc in the points to set of o an edge is added from its corresponding node node s to the rst node of the callee method firstnode oc m .
in addition an edge is added from the last of the callee method lastnode oc m to the next node of s nextnode s .
furthermore happens before edges are added between consecutive nodes in oc mfollowing the program order.
lockset.
lock andunlock nodes do not introduce happensbefore edges.
instead we associate every memory access node read and write protected by each pair of lock and unlock nodes with a lockset and add all the abstract lock objects to which these lock variables may refer to the lockset.
the lockset is used together with happens before to improve precision of race detection.
.
.
change aware shb algorithm if any of these nine types of statements is added or deleted our change aware shb algorithm updates the shb graph.
this step is relatively straightforward by following the rulesin table .
for addition we rst insert the corresponding nodes introduced by the new statement into the shb graph according to the statement location.
we then add the links for ahl and add the happens before edges according to the points to set.
for deletion we simply remove all the corresponding nodes and their links and edges from the graph.
if a removed node nis between two nodes n1!n!n2 then the two nodes will be connected n1!n2.
for loop statements their addition and deletion are equivalent to adding and deleting s in the loop body.
for synchronization statements we update the lockset of each read and write node that they protect accordingly.
for statements allocate and simple assignment they may change the points to graph and call graph.
for points to changes we update the shb graph by adding or deleting the corresponding nodes edges links according to the changed points to set of each base variable.
for call graph changes we delete only the related edges but not the nodes to reuse the nodes later if a method call statement to the same method is added.
a caveat is that a statement may appear as multiple nodes in the shb graph because the statement is in a loop or its enclosing method is called in multiple places.
therefore for changes to these statements we must track and update all their occurrences in the shb graph.
we track these statements by maintaining a map from each method to its locations in the graph and a boolean state for each statement indicating if it is in a loop.
for a statement change we locate all their occurrences by checking both the map with its enclosing method and the boolean state.
we do not handle method recursion separately because recursion is already handled by unrolling the loops twice in the call graph.
.
.
change aware race checking the race checking procedure is triggered upon a change in the shb graph.
there are three types of changes links to ahl lockset and happens before.
when a link to an ahl is added or deleted it means that a read orwrite node x is added or deleted and we perform race checking speci c to x. we rst nd all the pairs of con icting nodes including xby checking the associated read and write sets.
because any of these pairs may become a race or no longer a race for each pair we check the happens before relation and the lockset condition between the two nodes.
if the two nodes cannot reach each other on the shb graph and their locksets do not intersect we ag them as a race.
the lockset condition here is essentially a may alias analysis that determines if two lock variables may refer to a common lock.
if the ag of any pair is changed we update the race warning in the ide.
for happens before changes we only handle inter thread changes because intra thread happens before is determined by program order and it alone cannot introduce new races or invalidate existing races.
there are two types of inter thread happens before edges fork!start and end!join.
for we check only the con icting node pairs involving those nodes that happen before the fork node and those that happen after the start node because only the happensbefore relation of those nodes can be a ected by this happensbefore edge.
similarly for we check only the con icting node pairs involving those nodes that happen before the end node and after the joinnode.
for lockset changes similarly we only nd and check those con icting node pairs involving nodes whose locksets are changed.
779table extended andersen s algorithm ocrefers to abstract objects of type c .
statement points to set constraint points to graph edge x new c oc2pts x oc x x y pts y pts x y x x y.f 8o2pts y pts o f pts x o f x 1x.f y 8o2pts x pts y pts o f y o f ox o.m y from method c.m pts y pts y0 and pts z pts x z xandy y0 call m y0 s return z 8oc02pts o add c m cs c0 m0in the call graph cs call site .
change aware points to analysis our change aware points to analysis builds on an on they andersen style algorithm .
it is context insensitive but eld sensitive and locally ow sensitive i.e.
ow sensitive within each method.
the key novelty of our new algorithm algorithm is to make the analysis more e cient in handling program changes including both addition and deletion.
on they andersen s algorithm.
letpts v denote the points to set of a variable vandovthe abstract object directly assigned to v. points to analysis is often cast as a graph closure problem.
each node represents a variable v and has an associated points to set pts v orov.
in andersen s algorithm edges represent subset constraints between nodes an edge a bmeans that pts a is a subset of pts b .
forsimjava there are seven types of statements relevant to points to analysis.
allocate and simple assignment are used to initialize the points to graph and the rest ve may add more edges on they.
table shows an extended anderson s algorithm.
the statement o method call is also directly related to call graph construction.
when a new call graph edge is discovered the pointsto graph may also be updated because of the new points to facts introduced by parameter passing and value returning.
as a result the on they algorithm works in a loop until reaching a xed point i.e.
both the points to graph and call graph are unchanged.
in each iteration a worklist is used to track the new points to facts and the points to information is propagated along the two graphs following the constraint rules in the second column in table .
.
.
statement addition handling statement addition follows the same rationale as the on they anderson s algorithm.
new points to facts nodes edges are rst extracted from the added statement and put into the worklist.
then the points to information is computed along the relevant paths in the two graphs until reaching a xed point.
the key advantage of our new algorithm is that only those nodes in the paths related to the new facts are recomputed all the other nodes are untouched.
the algorithm algorithm lines takes an added statement sand its enclosing method c m as input c m is needed for building the call graph .
it rst nds out all the new edges that smay introduce using the function findedges algorithm .
findedges handles each type of statements following the rules in the third column of table .
for the rst two types and the new edges can be added straightforwardly note that the side e ect of statement x y is handled by the xed point computation in algorithm at lines .
for the other three 1o which we call complex statements their corresponding edges are not xed but depend on the points to set of their base variable.
for example for x y.f suppose pts y contains two objects o1ando2 then two edges mustbe added o1 f xando2 f x. moreover when pts y is changed during the computation the corresponding statement must be re evaluated because new edges may be added or deleted.
therefore in addition to nding edges for these complex statements findedges also maintains a map cs that records the corresponding complex statements and their methods for each base variable.
for example for x.f y x c m s is added to csfor statement addition and deleted for deletion.
statement o x o.m y may additionally update the call graph trigger new statements in the callee method to be added or introduce points to edges related to both formal parameters and return.
we handle all these cases correspondingly in algorithm .
for each new edge src dst if it is not already in the points to graph it is added to the graph and its pointsto set is updated following the subset constraints pts dst pts dst pts src .
ifpts dst is changed all edges from dstin the points to graph are added to the worklist and reprocessed to update the points to set of v. in addition all the complex statements that have dstas their base variable will be re processed because new points to edges may be introduced by the change in pts dst .
.
.
statement deletion handling statement deletion is more complicated than addition.
intuitively it is the reverse of addition and if we can track the state changes of the points to graph by each addition we may undo the changes for deletion of the same statement.
yet this intuition is not true because points to analysis is not reversible .
deletion is fundamentally di erent from insertion in that it requires updating not only the pointer information of the speci c change but also previous changes that are dependent on this change.
moreover for large graphs it is expensive to memorize the state changes.
reset then recover.
one less e cient solution algorithm lines is to reset the points to sets of all relevant nodes and then recompute them.
we can rst nd all the points to edges that are related to the deleted statement remove all these edges and reset set to empty the points to sets of their destination nodes as well as all nodes that they can reach.
then following the same method for addition we can add all the edges in the remaining points to graph that can reach the reset nodes into the worklist and repeat the xed point computation.
this method is ine cient because the points to sets of some reset nodes may in fact remain unchanged before and after the deletion such that all the reset then recover computations are wasted.
reachability based algorithm.
our optimized solution is based on two observations.
first after deleting an edge x y the points to set of ymay remain the same if x is still reachable to y. second for any abstract object o if ois reachable to ythen omust be included in the points780algorithm change aware points to analysis input s a new added or deleted statement in c m. global states ptg vp ep points to graph cg vc ec call graph pts points to set function w worklist cs variable to complex statements addition w findedgess c m s while w6 do e select from w e src dst ife62epthen eis a new points to edge ep ep e pts dst pts dst pts src ifpts dst changed then foreach dst v 2epdo w w dst v process complex statements foreach c m s 2cs dst w w findedges c m s deletion reset then recover reset w findedges c m s while w6 do e select from w e src dst ep epne remove efrom ep reset reset dst while reset6 do v select from reset pts v reset the points to set of v foreach v dst 2epdo reset reset dst foreach src v 2epdo w w src v while w6 do e select from w e src dst pts dst pts dst pts src ifpts dst changed then process complex statements foreach c m s 2cs dst w w findedges c m s deletion reachability based w findedges c m s while w6 do e select from w e src dst if isreachble src dst then continue foreach o2pts src do l a set of nodes whose points to sets may change l l dst while l6 do v select from l if isreachble o v then continue pts v pts v no remove ofrom pts dst foreach v dst 2epdo l l dst propagate the change process complex statements foreach c m s 2cs dst w w findedges c m s algorithm findedges c m s output e a set of edges initially empty.
notation n union for addition removal for deletion.
switch sdo case x new c e e oc x case x y e e y x case x y.f foreach o2pts y do e e o f x cs csn y c m s case1x.f y foreach o2pts x do e e y o f cs csn x c m s caseox o.m y foreach oc02pts o do ifc m c0 m062ecthen foreach s02c0 m0 y0 fs0 return zgdo e e findedges c m s0 e e fy y0 z xg ec ecn c m c0 m0 cs csn o c m s return e. to set of y. our new algorithm shown in algorithm lines hence lazily updates the points to set by checking the path reachability beforehand using the function isreachable x y .
the algorithm updates the points to set of y denoted by pts y only when isreachable x y returns false and it removes an abstract object ofrom pts y only when isreachable o y returns false.
po1yqwo2xzdeleted figure an example of edge deletion.consider the example in figure where the edge x y is deleted.
we rst check if xis still reachable to y if yes e.g.
in the existence of the path x p y we simply stop.
if not we go on to check the reachability from each abstract object oinpts x toy.
ifois not reachable to y we remove ofrom pts y and continue to check the reachability from oto the nodes that are reachable from y e.g.
zin the example and propagate the removal if not reachable.
otherwise oremains in pts y and we stop the propagation for o. if the path x p ydoes not exist after deleting x y o1can no longer reach y ando1is hence removed from pts y .
the removal is propagated to pts z because zis reachable from yando1is no longer reachable to z. however o2is still reachable to y via the path o2 w q yando2remains in pts y .
the computational improvement here is that we can skip the propagation to pts z because pts y is unchanged.
.
soundness and other optimizations soundness.
both of our change aware happens before graph construction and points to analysis algorithms are sound.
our incremental computation on the happens before graph and points to graph produces the same state as the one shot whole program computation.
the key to the proof is that adding removing a statement computed by our algo781table race detection performance.
echo is typically four orders of magnitude faster than conventional whole program race detector.
pointer analy.
whole prog.
echo one time detector average worst example .3s .3s .27ms 153ms filewriter 4s .1s .96ms 837ms loader .4s .5s .27ms 197ms manager .5s .5s .32ms 269ms mergesort .9s .3s .3ms 238ms racey .5s .6s .25ms 226ms pool .4s .4s .24ms 122ms weblech .4s .5s 5ms .4s h2 .2s .2s .89ms .0s rithms leave the states of the two graphs the same.
however our race detection algorithm is unsound due to its use of may alias for reasoning about lockset.
may alias may incorrectly determine that two di erent lock variables that refer to di erent locks at runtime alias each other and certain real races may be missed.
nevertheless this issue rarely happens in practice when the points to analysis is locally ow sensitive.
in our studied benchmarks echo can detect all known real races.
scc optimization.
precise tracing of all e ected edges and nodes can be expensive due to the presence of cycles in the points to graph.
however all nodes in the same cycle are guaranteed to have identical points to sets so we can collapse those strongly connected components scc into a single node.
previous research has shown that the scc optimization is e ective scaling to millions lines of code.
we also apply this optimization in our algorithm.
speci cally we maintain a super node for each scc and update the super nodes after the initial worklist is set.
a super node can be either augmented for addition or shrinked or broken for deletion .
once updated both the graph traversal and the update of points to set in the sccs become faster.
.
evaluation we implemented echo as an eclipse plugin based on the wala framework .
we modi ed the zeroonecfa implementation of andersen s algorithm that identi es abstract objects by allocation sites .
we evaluated echo on a variety of popular java multithreaded benchmarks collected from previous concurrency studies including three real world systems the h2 database the weblech spider and the apache commons pool library.
our evaluation answers two sets of research questions .performance how e cient is echo in reacting to program changes?
how scalable is echo in detecting races?
how much speed up compared to wholeprogram race detection?
.recall precision can echo detect all real races?
how precise is it?
what is the false positive ratio and what are the reasons for false positives?
benchmarks.
table summarizes the static characteristics of the benchmarks including our example program in figure .
the size of the smaller benchmarks ranges from to .8k lines of code.
the size of real world programs ranges from 10k to 172k.
all benchmarks except h2are self contained i.e.
each of them has a single entry point the main method for the analysis.
for h2 we use thetest driver class org.h2.test.synth.thread.testmulti in the h2 test suite as the entry point.
all jdk libraries e.g.
java.lang.
and java.util.
are included in the analysis except those excluded by wala by default such as java.awt.
and sun.
.
these jdk libraries account for the majority of the classes the number reported in column for building the class hierarchy.
nevertheless for pointsto analysis only those methods that are reachable from the entry points are analyzed.
the number of reachable methods for these benchmarks ranges from to .7k containing 27k to 108k ssa instructions.
the points to graph for each benchmark contains 9k 41k pointer keys i.e.
reference variables .2k 5k instance keys i.e.
object allocation sites and 60k .5m points to edges.
for weblech its points to graph is much larger and more dense than the other benchmarks.
it is particularly interesting for our evaluation of scalability because anderson s algorithm in the worst case is cubic in the size of the graph.
evaluation methodology.
echo can be used by developers starting either from an empty project or from an existing code base.
we choose the latter scenario for our evaluation.
for each benchmark we run the experiment in three phases run points to analysis and static happensbefore graph construction for the whole program delete a statement and run race detection add the deleted statement back and run race detection.
phase is needed only once for echo .
phases and are performed for each statement in each method.
to understand the performance improvement of our novel change aware algorithms we also implement a whole program race detector and compare its performance with echo .
the whole program race detector uses the same hybrid algorithm and the same pointer analysis as we use in echo .
the only di erence is that for every change it has to re run the whole program analysis.
hence the whole program race detector and echo have the same race detection ability i.e.
report the same races with same precision and recall except that echo is faster.
in addition to show the improvement of our reachabilitybased algorithm for handling deletion we compare its performance with the reset and recover algorithm.
all experiments were performed on an apple mac pro with .5ghz dual core intel i5 processor and 4gb of memory running java hotspot bit server vm version .
.
.
.
performance table reports the performance of echo compared to the whole program race detector.
column reports the time for performing the points to analysis for each benchmark.
the points to analysis time typically ranges between 2s 5s except for weblech which takes .4s because of its large points to graph.
column reports the time taken by the whole program race detector to detect races upon a change.
the whole program race detector needs .5s .5s to detect races.
columns report the average and worst case time including all incremental analyses and the race detection taken by echo for each change.
for most benchmarks including h2and pool echo takes less than 1ms on average per change and 1s in the worst case.
compared to the whole program race detector echo is typically four orders of magnitude faster.
the only exception is weblech which has a much larger and more dense points to graph.
however even for weblech 782table benchmarks.
jdk libraries are also analyzed except those excluded by wala by default.
benchmark loc classes methods ssainstructions pointerkeys instancekeys pointeredges example filewriter loader manager mergesort racey pool 10k weblech 35k h2 172k table performance of addition and detection.
fast insts instructions that take .1s to handle.
average worst case fast insts delete add delete add delete add example .4ms .06ms 153ms 21ms filewriter .7ms .23ms 837ms 28ms loader .44ms .07ms 197ms 29ms manager .5ms .07ms 269ms 25ms mergesort .53ms .06ms 238ms 36ms racey .44ms .06ms 226ms 34ms pool .43ms .06ms 122ms 22ms weblech .9ms .1ms .4s 219ms h2 .6ms .17ms .0s 79ms table performance of detection algorithms.
reach based reset then recover average worst average worst example .4ms 153ms .5ms .3x 507ms .3x filewriter .7ms 837ms .4ms .4x .3s .6x loader .44ms 197ms .48ms .1x 319ms .6x manager .5ms 269ms .58ms .2x 317ms .2x mergesort .53ms 238ms .55ms .0x 338ms .4x racey .44ms 226ms .46ms .0x 343ms .5x pool .43ms 122ms .49ms .1x 517ms .6x weblech .9ms .4s 368ms 41x .2s .5x h2 .6ms .0s .7ms .3x .9s .9x echo takes only 5ms on average for each change and .4s in the worst case a 3000x speedup over the whole program race detector on average and .5x in the worst case.
addition deletion.
table compares the performance between addition and deletion.
columns and columns report the average and worst case time respectively taken by echo for adding and deleting a statement.
columns report the percentage of instructions that take echo less than .1s to handle.
overall addition .
.1ms on average and 219ms in the worst case is much faster than deletion .
9ms on average and 112ms .4s the worst .
the reason is that addition does not involve the complex invalidation of existing points to sets.
nevertheless over of all the statements take less than .1s .
reachability based deletion vs reset then recover.
table compares the performance between the reachabilitybased and the reset then recover algorithms for handling statement deletions.
in the average case the reachabilitybased algorithm takes .
.9ms per change whereas the reset then recover algorithm takes .
368ms.
in the worst case the reachability based algorithm takes .
.4s while the reset then recover algorithm takes .
54s.
on average the reachability based algorithm is .6x faster than reset then recover for the average case and .3x faster for the worst case.
the speedup is more signi cant for the real world systems.
in particular for weblech the reset table results of detected races.
total true races false positives example filewriter loader manager mergesort racey pool weblech h2 urlgetter urlgetter new urlgetter config list newurls downloadurl urlgetter... class spider run urlgetter.geturl url downloadurl if failurecount failurecount failurecount class urlgetter geturl t1 t2 figure false positives on failurecount in weblech due to the lack of object sensitivity.
then recover algorithm takes 368ms on average and .2s the worst while the reachability based algorithm takes only .9ms and .4s respectively which is 41x and .5x faster.
.
recall precision table reports the results of detected data races by echo .
each race has a unique signature i.e.
a pair of program statements.
for several benchmarks they have one or more known data races.
we rst studied all the known races and manually inspected the races reported by echo .
we found thatecho reported all those known races in these benchmarks.
echo detected true races and false positives in total all these races are available at .
the precision is and recall .
nevertheless echo may still miss certain true races in other java programs because of its limited support of language features e.g.
echo does not handle re ection and its use of may alias as described in section .
.
however both of these two issues are fundamental to static analysis.
false positives.
echo reported false positives in these benchmarks.
the false positive ratio is .
previous research has shown numerous sources of false positives raised by static analyses.
we identi ed three main if m icount m isize doublearray m dataarray new data data class datastorage putdata t1t2int rand math.abs randomizer.nextint int count datastorage.getinstance .getcount int place rand count datastorage.getinstance .getdata place class dataprinter run class datastorage getdata synchronized m sync ret m dataarray getcount return m icount figure false positives on m dataarray in filewriter due to indistinguishable array indexing.
sources in our experiments object sensitivity.
identifying static objects by their allocation sites is imprecise.
it can often lead to false positives between accesses to objects allocated at the same program location but are di erent.
consider an example in weblech figure .
the program starts two concurrent threads both executing the runmethod of the spider class.
each thread creates a new urlgetter object at line and uses it to fetch url which accesses the object eld failurecount at lines .
echo reported false positives on failurecount because the underlying pointer analysis does not distinguish the two urlgetter objects allocated at the same site by the two threads.
indistinguishable array indexing.
echo does not distinguish between di erent array indexes which can lead to false alarms because accesses to di erent elements of the same array are considered as to the same memory.
this issue can be more complicated when the array indexes are under complex data ow and path conditions.
consider an example in filewriter figure .
thread t1writes to a shared array m dataarray with index m icount at line .
thread t2reads m dataarray with index place which is computed by a random value mod m icount .
the two indexes cannot be equal because of the mod operation.
echo reported false positives in filewriter due to this problem.
ad hoc synchronization.
echo handles standard thread synchronizations in java such as thread fork join and the synchronized keyword but does not recognize ad hoc synchronizations.
missing ad hoc synchronizations caused several false positives in our experiments.
due to space reasons we refer the readers to our technical report for a detailed example of this issue.
these issues open several interesting directions that we plan to investigate in future work.
for example adding more object and context sensitivity in the pointsto analysis could reduce false positives.
a more precise array index analysis could alleviate the second issue and recognizing ad hoc synchronizations could further improve the precision of echo .
.
related work a large number of static race detection techniques have been proposed including many types systems scalable whole program analyses model checking and other specialized techniques .
the key advantage of static race detection is that it provides the potential to detect all races over all program paths which eliminates false negatives although most techniques in practice sacri ce soundness for scalability.
a primary limitation of static analysis is that it is imprecise and may produce false positives.
a few sophisticated data ow analyses have been proposed to improve precision via more expensive analysis.
compared to existing techniques echo amortizes the analysis cost across many small program changes and avoids redundant computation through change aware analysis.
moreover echo works in the ide and can detect races and warn the developers to x the races as they are introduced.
type based race checking systems can perform well in the ide but they typically require a significant amount of manual annotations and or work only for an ideal language.
echo is fully automatic without any annotation and works for a realistic java like language.
praun et al.
propose an object use graph oug model that statically approximates the happens before relation between accesses to a speci c object.
the key di erences between oug and our shb graph are that the shb graph is eld sensitive while oug is object sensitive and that oug does not model lock operations.
points to analysis has been extensively researched in several di erent dimensions e.g.
owsensitivity context sensitivity heap modeling etc.
precise points to analysis is np hard .
any practical points to analysis must approximate the exact solution and balance between precision and performance.
a few incremental and demand driven points to analysis algorithms have been proposed based on cfl reachability logic programming and data ow analysis .
however demand driven approaches do not handle changes and existing incremental approaches cannot e ciently handle code deletion.
moreover none of them has been applied in ides for multithreaded programs before.
.
conclusion and future work we have presented a new ide based static race detection technique and a tool echo that can detect data races as soon as they are introduced into the program.
echo is powered by a set of novel change aware static analyses that e ciently compute change relevant program information upon code changes without re analyzing the whole program.
our results on a variety of multithreaded benchmarks and real world java applications show that echo can detect races within milliseconds upon a code change with a reasonable precision.
in future work we plan to conduct empirical studies with developers to evaluate the usability and usefulness of echo for diagnosing and xing real races.
we also plan to improve the precision of echo by addressing the sources of false positives as discussed in section .
.
.