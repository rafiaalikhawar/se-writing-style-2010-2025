treker tracing error propagation in operating system kernels nicolas coppik oliver schwahn stefan winter neeraj suri deeds group tu darmstadt darmstadt germany fnc os sw surig cs.tu darmstadt.de abstract modern operating systems oss consist of numerous interacting components many of which are developed and maintained independently of one another.
in monolithic systems the boundaries of and interfaces between such components are not strictly enforced at runtime.
therefore faults in individual components may directly affect other parts of the system in various ways.
software fault injection sfi is a testing technique to assess the resilience of a software system in the presence of faulty components.
unfortunately sfi tests of oss are inconclusive if they do not lead to observable failures as corruptions of the internal software state may not be visible at its interfaces and yet affect the subsequent execution of the os beyond the duration of the test.
in this paper we present t rek er a fully automated approach for identifying how faulty os components affect other parts of the system.
t rek ercombines static and dynamic analyses to achieve efficient tracing on the granularity of memory accesses.
we demonstrate t rek er s ability to support sfi oracles by accurately tracing the effects of faults injected into three widely used linux kernel modules.
index terms software fault injection robustness testing test oracles execution tracing operating systems i. i ntroduction complex modern software systems1generally consist of many interacting components.
in larger systems these components may be developed or maintained by different teams of developers and may differ in numerous aspects including code quality and the amount of residual faults.
in order to assess the resilience of the overall system it is necessary to understand how it is affected by individual faulty components a condition named error propagation in the laprie taxonomy .
for this purpose software fault injection sfi the deliberate introduction of faults in specific components to simulate their behavior in the presence of residual software faults is an established approach .
in sfi tests the system under test sut is exposed to erroneous behavior of a component it is interacting with the injection target.
these fault injections are similar to mutations for mutation testing but commonly based on different assumptions regarding the types and distributions of the introduced faults see for an overview of common fault assumptions in either application .
after the injection interactions between the sut and the injection target are triggered by a test workload.
to assess error propagation from the injection target 1we will refer to software systems in the sense of software compositions from separately developed and compilable modules as systems in the following.to the sut the behavior of the sut is observed while it is processing the workload to identify behavioral deviations in response to the injection.
unfortunately oracles of this type are generally insufficient to make any conclusions whenever no such behavioral deviations are observed.
in such cases it is unknown whether the fault has not been activated has been activated but its effects have not propagated to the user interface or does generally not affect the system behavior.
while the first case can be identified by additional code that logs the activation of injected faults disinguishing the latter two requires introspection of the system during test execution.
sfi test frameworks commonly use execution trace comparisons across setups with and without injected faults as a secondary oracle to distinguish between these cases .
a. the sfi oracle problem for oss while the usage of execution traces alleviates the aforementioned oracle problem it is challenging for an important class of suts operating system os kernel components because all kernel components are interacting within the same address space and with the same privileges.
without memory protection between kernel components all memory is shared and directly accessible via pointers.
this makes every memory operation in the system a potential cross component interaction affecting the sut that needs to be traced.
existing memory tracing approaches for user space applications e.g.
using valgrind or pin are not applicable for os kernels.
existing tracing approaches for os kernels e.g.
systemtap or lttng on the other hand only provide tracing on the granularity of function calls instead of individual memory accesses.
a na ve tracing of allmemory operations is infeasible as the kernel code base is large and some parts such as hardware interrupt handling routines are performance critical.
b.treker solving the sfi oracle problem to correctly identify and characterize the effects of residual software faults in kernel components we present t reker a scalable fully automated approach for t racing error propagation in operating system k ernels that relies on a combination of static and dynamic analyses to infer error propagation from a faulty kernel component to other parts of the kernel.
t rekerlimits the trace points to the injection target and infers error propagation from deviations in the injection target s state and behavior that are visible to other parts of .
c ieeease urbana champaign il usa technical research377 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the kernel thereby effectively improving the soundness of sfi tests for oss at the cost of execution time overheads for trace collection and analysis.
we demonstrate t reker s ability to trace the effects of faults in three widely used kernel components on the linux kernel.
we find that up to of seemingly successful runs in our fault injection experiments would be misclassified by conventional oracles.
the remainder of the paper is organized as follows section ii gives an overview over related work.
our proposed approach is detailed in section iii.
we discuss t reker s implementation in section iv and the experimental analysis in section v. concluding remarks can be found in section vi.
ii.
r elated work to classify the results of sfi tests on kernel code t reker traces the effects of injected software faults in os kernels.
we discuss existing trace based approaches for user mode software in section ii a alternative approaches for kernel level sfi tests in section ii b and trace comparison in section ii c. a. execution trace based oracles for user mode software execution tracing has been widely adopted to determine the outcome of sfi tests similar to our motivation for t reker.
execution traces of the unmodified sut are recorded and later used as a golden run oracle to compare executions with injected faults against.
to record execution traces three different techniques are used.
one class of approaches e.g.
uses debuggers to record execution traces.
this imposes execution latencies that are not tolerable by most suts among them os kernels targeted by our work.
interrupt service routines for instance need to have short response times and exceeding those may result in unintended os failures during test.
a second class of approaches e.g.
uses fullsystem simulation for execution tracing.
full system simulators implement the semantics of low level hardware operations for a given platform in software.
the sut is executed on this simulated hardware model.
although the simulation of every single hardware operation in software imposes massive execution time overheads this is not observable by the sut.
any latencies observable by the sut are based on the simulated hardware timer.
therefore full system simulators are generally suitable for tracing os kernel executions but massively impair test throughput due to the simulation overhead.
the third class of approaches e.g.
relies on dynamic binary instrumentation translation dbi t e.g.
using pin or valgrind .
similar approaches have been developed for os kernels but none of them has been used for execution tracing in sfi tests.
as t rekerinstruments kernel code during compilation it is independent from kernel modules that need to co evolve with changing kernel interfaces.
in this respect it differs from the work of feiner et al.
or kedia et al.
.
moreover approaches based on binary translation only work for a specific hardware architecture and require adjustment for others.
pinos for instance islimited to ia .
the applicability of t reker in contrast is not limited to any specific os kernel or hardware architecture as long as the instrumentation target can be compiled for that architecture with clang llvm.
as both pinos and decaf rely on virtualization they cannot be applied for hardware specific kernel code such as device drivers if that hardware cannot be emulated by the underlying hypervisors.
b. oracles for kernel level sfi tests due to the sut architecture specificity of available kernel tracing tools sfi tests for these suts commonly employ other less accurate oracles.
koopman et al.
have introduced a classification of os failure modes that they consider relevant and implemented corresponding detectors in the ballista project .
their classification comprises five different failure modes collectively referred to as the crash scale where each letter of the acronym stands for a failure mode.
catastrophic failures are failures that render the entire system unusable e.g.
kernel panics.
restart failures denote cases where the os silently stops serving requests made by the executing test case.
cases where the os detects a problem and notifies the executing test e.g.
by signaling a segmentation fault are called abort failures.
silent failures denote the violation of the kernel s specified behavior without corresponding notification to the executing test.
hindering failures on the other hand are failures that mislead debugging efforts e.g.
by returning a wrong error code.
arguing that these are the most critical failure classes ballista and similar approaches to os robustness testing limit their oracles to the detection of the first three classes of the crash scale .
trekerfocuses on the detection of silent or non crashing failures such as silent data corruption sdc which constitute a significant threat to reliability and have been mostly ignored by existing work on os level sfi tests.
the reliable detection of restart failures requires kernel execution traces containing every single executed instruction.
while t reker is capable of implementing such a tracing policy the required heavy weight instrumentation may result in performance degradation similar to the approaches discussed in section ii a. we therefore limit the scope of our approach to the detection of error propagation in the case of terminating test executions and employ existing timeout based detectors for restart failures.
while a number of tools e.g.
systemtap and lttng exist to trace the execution of os kernel code using probes cf.
for sfi tracing they are only capable of tracing function invocations and not individual memory accesses.
to identify how faults affect sut state i.e.
the data the sut operates on t rekerselectively instruments memory operations that are invisible to these tools.
c. trace comparison to detect error propagation t rekercompares traces of executions with injected faults to golden run traces of the unmodified sut.
trace comparison is also commonly used for fault localization.
wong et al.
give an extensive overview .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
such approaches typically compare traces of the same version of the sut with different inputs to identify the root causes of behavioral divergences.
therefore they are not directly applicable to the scenario targeted by t reker.
iii.
s ystem model we propose an approach for identifying how faults in components in a monolithic operating system affect the rest of the system.
to that end this section starts with a brief overview of the underlying fault taxonomy followed by a discussion of the systems we consider and their component interactions.
a. faults and their consequences as hinted at in section i we follow the laprie taxonomy .
any system or system component2is assumed to implement asystem function according to a functional specification.
the system implements the system function as a sequence of states.
the fraction of a system state that is perceivable at the system s interface is called the external state.
the sequence of external states implementing the system function is referred to as service and the deviation of service from the functional specification is called a failure.
the deviation of an external state in the sequence that constitutes the service may be caused by a prior deviation of the system s internal state that is invisible at the interface from a correct implementation of the system function.
such a deviation of the system state is called an error.
the cause of an error is termed as a fault.
by these definitions a fault is something that possibly leads to an error an error something that possibly leads to a failure and a failure a deviation of observed behavior from specified behavior.
when a fault causes an error this is referred to as fault activation and the effect an error has on subsequent system states is called error propagation.
b. monolithic operating systems and composition we assume that monolithic operating systems consist of a a core part which provides essential functionality and is therefore always necessarily present and b an arbitrary number of modules implementing additional functionality.
modules can interact with one another or the core kernel through function calls thereby exchanging information via parameters and return values.
furthermore the system does not enforce any memory isolation between its components.
all modules and the core kernel share the same memory address space and can in theory freely access and modify each others data structures.
finally modules can also access and modify any global data structures in the system.
although the implementation we describe in section iv utilizes runtime loading and unloading of kernel modules the fundamental approach described here does not conceptually rely on the availability of this functionality.
due to the lack of runtime isolation or protection mechanisms a faulty module can affect other modules or the core kernel in a variety of ways.
in particular tracing mechanisms 2we mean system or system component whenever we refer to system in this subsection.that only consider parameters and return values of function calls cannot capture differences in communication through shared memory.
however due to the aforementioned lack of isolation distinguishing between memory accesses that constitute potential shared memory communication particularly write accesses by a faulty component and those that do not is usually not straightforward without examining the entirety of all other modules and the core kernel.
however the result of such an analysis would be dependent on the particular modules present in the system in question and changes to this configuration might well yield different results.
therefore we limit our analysis to the faulty component itself and analyze which fraction of its state can be expected to be accessible byanyother component in the system independent from the actual system configuration.
we denote this fraction of expected externally visible behavior as the component s interface.
the interface includes parameters of function calls from and return values of function calls to the component as well as memory accesses to locations that can reasonably be assumed to be used for transmitting data to other components via shared memory.
we detail in the following what we do and do not consider such interface relevant memory accesses within a component targeted by our analysis.
read accesses are not generally considered part of the component interface.
if the value that is read was previously written by the faulty module itself the read access clearly does not constitute external communication.
if on the other hand the value was written by another module we do not consider the read access itself to be behavior visible to other components while a faulty module may attempt to read from the wrong address resulting in an unexpected value this does not directly result in externally visible differences in behavior.
cases where it has indirect influence for instance if the faulty module proceeds to use the wrong value as a function parameter will be captured under our notion of interface at the point where the behavior in question becomes externally visible.
local write accesses are store operations to addresses that are not known to any components other than the faulty one.
most notably this includes accesses to stack allocated local variables unless their address is passed to another component either directly e.g.
as a function parameter or implicitly by writing it to another externally visible memory location .
access to regions of memory that are allocated and freed without ever being referenced in an externally visible manner that is as with stack addresses passed to external functions or written to externally visible addresses in between also fall into this category.
such accesses are not considered externally visible for the purposes of our analysis and are therefore not deemed part of the component interface.
externally visible write accesses are store operations to addresses that are known to components other than the faulty one.
this includes all addresses that are passed to the module from another component for instance as a parameter or return value as well as globals and addresses belonging to memory that has been allocated by the module itself but then communicated to other components.
as mentioned above authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
int global void c foo int x int a e bar a void e bar int y ... void c baz int z int c z c global c global global i32 define void c foo int i32 alloca i32 alloca i32 store i32 i32 store i32 i32 call void e bar int i32 ret void define void c baz int i32 alloca i32 alloca i32 store i32 i32 store i32 i32 load i32 i32 load i32 i32 store i32 i32 load i32 i32 store i32 i32 global ret void fig.
.
three different cases in which write accesses can be externally visible in c and simplified llvm ir.
it also includes all memory addresses that are reachable by following pointers from another externally visible address.
of these three categories the one most relevant for our analysis is the last one externally visible write accesses.
we distinguish between three different cases of external visibility of write accesses writes to an address that the component passes to another component or to addresses that are reachable from such an address writes to an address that was passed to the component by another component or to addresses that are reachable from such an address writes to global variables or to addresses that are reachable from a global variable.
these three cases are illustrated in figure .
in the first case a function in the component c foo writes to a variable a and then passes the address of that variable to an external function e bar .
should the external function dereference that address the result of the written value would be accessible to it.
note that we do not inspect whether such an access actually occurs we just check whether it is possible.
in the second case a function in the component c baz has received a pointer z as an argument and writes to that address.
if the caller of c baz is an external function e.g.
e bar that write access is visible to that caller.
in the final case a function in the component writes to a global variable global .
in all of these examples the external visibility of the stores in question is fairly straightforward to recognize requiring at most one pointer dereference.
however more complicated cases exist for which we introduce the following notion of reachability an address pisdirectly reachable from an address qifpis stored at q i.e.
q p orqis the base address of a data structure e.g.
an array or struct and pis the address of a member of that data structure e.g.
p q foo .
an address pisindirectly reachable from an address qif there is an address rsuch that pis directly reachable from randr is reachable directly or indirectly from q.we consider the externally visible behavior of a component at its interface with the rest of the operating system to consist of the values of parameters passed to functions outside the component the values returned to callers outside the component the externally visible memory addresses it writes to and the values it writes to them.
error propagation occurs when a faulty component exhibits externally visible behavior that a fault free version of the same component will never exhibit under the same workload.
iv.
t reker tracing error propagation in os kernels the implementation work required to realize our proposed approach comprises two essential parts an instrumentation tool capable of gathering the information required to fully capture the externally visible behavior of a target component and an analysis tool to perform the filtering and transformations required to distinguish between the cases described in section iii.
we describe these parts in section iv a and section iv b respectively.
trace comparison is described in section iv c. a. component interface identification and instrumentation the purpose of the instrumentation phase is to gather all the information required to reconstruct an accurate model of the externally visible behavior of the target component.
to that end it needs to capture the addresses and values of memory accesses as well as function calls parameters and return values.
function call instrumentation needs to be performed both on the caller side when the target component calls functions in other components as well as the callee side when other components invoke functions of the target component.
in order to avoid limiting t rekerto a specific os or architecture we have decided to implement compile time instrumentation as an llvm optimization pass allowing us to support native execution on a various different architectures.
as an llvm optimization pass the instrumentation step operates on llvm ir a static single assignment ssa representation.
unlike x86 assembly only a small number of llvm instructions operate on memory most notably the load andstore instructions.
in addition to the memory accesses themselves the instrumentation also needs to capture accesses to fields of data structures or more specifically the computation of their addresses based on the base address of the data structure.
in llvm this is typically modeled by the getelementptr instruction.
furthermore the instrumentation should capture basic tracing information such as function entry and exit arguments and return values.
therefore it also handles function calls callerside function entry and function exit callee side .
finally t rekeris designed to handle kernel code necessitating a way to instrument inline assembly which is common in operating systems code.
attempting to parse and process inline assembly directly suffers from many of the same drawbacks that make binary instrumentation an unattractive choice for kernel tracing including lack of portability across different architectures and significant added complexity.
in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
practice however inline assembly is usually specified using extended inline assembly syntax.
such extended inline assembly statements take a list of input and output variables and clobbers.
the instrumentation can rely on these arguments and constraints to extract which memory addresses may be read from or written to by the inline assembly without parsing it directly.
based on this information instrumentation can be performed as it would be for load orstore instructions.
for each of the instrumentation points identified above the instrumentation pass inserts a function call with the first argument indicating its type.
the subsequent arguments differ for the different types of instrumentation points.
in addition to memory addresses and values the information passed to the function also includes static type information e.g.
whether a value is of a pointer type and hashes of global variable names where applicable.
this way later analysis steps e.g.
the trace analysis described in section iv b can identify pointer values in the trace without having to rely on heuristics such as checking whether a value belongs to a previously seen address range as in .
the instrumentation pass inserts calls to inst wrapper .
for our experiments on linux kernel modules we applied a patch to the linux kernel that implements a stub for this function and a kernel module that once loaded handles the logging at instrumentation points.
prior to loading this runtime kernel module the kernel stub is effectively a no op allowing the instrumented module to function even when the runtime has not been loaded.
for other application scenarios such as user level code different implementations of the runtime for instance in a library would be possible as well.
when the runtime module is loaded it changes a function pointer in the inst wrapper stub to point to the actual logging implementation.
that implementation uses printk to output information at each instrumentation point in order to enable reliable tracing even in cases where the target may crash.
for other use cases a trivial performance optimization would involve caching trace data in memory to reduce the number of calls to printk.
b. trace analysis we have implemented a trace analysis tool that is capable of performing the reachability analysis for externally visible write accesses that we have described in section iii as well as deriving symbolic values for the addresses of memory accesses in order to facilitate comparisons between traces.
we first describe our implementation of the reachability analysis followed by our symbolic address generation.
reachability we have introduced a notion of reachability that incorporates both reachability through pointers as well as through access to member fields of data structures in section iii.
our implementation of reachability analysis applies this notion to individual execution traces.
first we split the trace by dynamic function calls.
for each function call we extract the caller arguments return value and called functions.
for calls to internal functions we additionally extract the trace entries generated during that function call.
this results in atree structure in which nodes represent dynamic instances of function calls and edges represent a caller callee relationship.
next we perform the aforementioned reachability analysis for each of the three different cases in which stores performed by the instrumented component may be externally visible.
for the first case writes in the component that are reachable from arguments passed to an external function we first identify each node representing a call to an external function taking at least one pointer argument in the aforementioned tree.
then for each such node we iterate backwards over the preceding trace entries until we encounter another node representing an external function call.
during this traversal we build up a separate graph which we term the reachability graph from the encountered trace entries as follows for load or store entries check if the address node has an outgoing edge representing a previously seen load or store from that node and if so skip this trace entry.
otherwise if the read or written value is a pointer add an edge from the address node to the value node.
for data structure member access entries i.e.
getelementptr instructions in llvm ir add an edge from the source i.e.
base address to the destination member address node.
non existent address nodes are created on demand during the construction of the reachability graph.
in this reachability graph we identify the set of nodes addresses that are reachable from any of the nodes representing pointer arguments passed to the external function.
this set of addresses is a subset of the addresses that are visible to the external function and for each of these addresses the last write access is deemed visible to the external function.
an illustration of a graph for this case can be seen in figure the stack allocated struct s baz is accessible via the pointer ppassed to the external function and both of the stores to its members are visible to the called function.
for the second case writes in the component to global addresses or addresses reachable from them we iterate over the trace constructing a reachability graph as follows for load or store entries if the address node already has an outgoing edge representing a read or write access remove it.
add an edge from the address node to the value node.
for data structure member entries add an edge from the source to the destination address.
mark global addresses when they are encountered and annotate the corresponding node.
in this reachability graph we identify the set of nodes that are reachable from any node annotated as representing a global variable.
as in the first case write accesses operating on any of these addresses are deemed visible to the external function.
for the third case writes in the component that are reachable from arguments passed by an external function we identify each node representing a call to an external function that in turn calls functions provided by the component.
this corresponds to any external function node including the root node in the tree that has internal function child nodes.
then for each component authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
struct s baz int x y void c foo int x struct s baz s struct s baz p s.x s.y p s e bar p define void c foo int i32 alloca struct.s baz alloca struct.s baz getelementptr struct.s baz struct.s baz i32 i32 store i32 i32 getelementptr struct.s baz struct.s baz i32 store i32 i32 store struct.s baz struct.s baz call void e bar s baz struct.s baz ret void p s s.y s.xfig.
.
an example of a reachability graph and the corresponding code snippet.
solid lines indicate values stored at an address dashed lines indicate offset calculations.
writes to s.x ands.y are visible to e bar.
function that takes at least one pointer argument called by such an external function we iterate over all trace entries belonging to that function node and its child nodes performing an in order traversal of a sub tree with the component function at its root.
the traversal is stopped when we encounter another external function node.
during this traversal we once again build up a reachability graph in the same manner as for global addresses apart from annotating nodes representing global variables.
we identify the set of nodes that are reachable from any node representing a pointer argument passed by the external function and as in the previous cases deem the last write accesses to any of these addresses visible to the external function.
symbolic addresses to compare traces from different executions where absolute addresses may differ a mechanism to map concrete addresses to symbolic addresses is required.
we generate symbolic addresses from reachability graphs similar to the ones described previously.
a symbolic address consists of an anchor point and a path starting from that anchor point.
for writes in the component that are reachable from arguments passed by an external function and writes that are reachable from a global value the second and third cases discussed above symbolic addresses use the argument or the global variable as the anchor point and the shortest path from there to the address that was written to as the path.
if for instance a pointer xis passed to the component and the component writes to an address ythat can be obtained by dereferencing xand adding an offset k the resulting symbolic address is x !k !.
for writes in the component that are reachable from arguments passed to an external function symbolic addresses are created using a similar mechanism.
in this case however a set of anchor points consisting of return values of external functions stack allocations global variables and the results of pointer arithmetic is considered.
if an address is reachable from several anchor points we compare the lengths of the shortest paths from each anchor point to the address and pick the shortest one.
the same symbolification is performed for values of pointer types.c.
trace comparison assessing the impact of faults on visible write accesses requires a mechanism for comparing traces of executions with activated faults to fault free executions golden runs .
moreover in order to minimize the impact of non deterministic runtime behavior we need to compare a faulty execution to a set of fault free runs.
while this allows us to more precisely extract those differences between traces that result from the activation of a fault i.e.
behavior that a fault free implementation would never exhibit it also complicates the comparison process.
we compare traces using the following two step approach trace merging first a set of traces from fault free runs is processed in order to generate a merged trace structure containing information about the addresses anyexecution writes to as well as the adddresses allexecutions write to along with the corresponding values let t1andt2be traces from two fault free executions both of which consist of the same sequence of function calls and write to address a1 with the values being v1 t1 and v2 t2 .
the resulting merged structure then contains a write access a1 fv v2g.
furthermore let t1 also write to address a2.
the merged structure then contains separately the set of addresses that all executions have written to aall fa1g as well as the set of addresses that at least one trace has written to aany fa1 a2g .
let t3be a trace from a third fault free execution which consists of a different sequence of function calls.
the addresses and values written byt3are stored separately from those of t1andt2.
in order to support workloads which exercise the target module using multiple threads or processes merged structures are stored separately for different threads and processes.
trace comparison next this merged structure is used in a comparison with a faulty execution.
let tfbe a trace from such an execution.
first the threads or processes in tfneed to be matched to their counterparts in the merged structure.
since absolute thread or process ids may differ between executions they do not form a reliable foundation for such a mapping.
instead we perform the mapping by call sequence looking first for exact matches.
in cases where no exact match is found the trace exhibiting the previously unknown call sequence can either be ignored so as to avoid introducing false positives or a best effort comparison with the known call sequence with the longest common prefix can be performed.
we call the former option strict mode.
in the latter option situations may arise in which several known call sequences have the same longest common prefix length with the new call sequence.
in this case we compare with all of them and report the results for the case in which we discover the fewest divergences.
best effort comparisons are only performed over the common prefix so that we never compare store visibility for different functions.
for each address afthattfwrites to the trace comparison checks if that address is also written to in at least one faultfree execution.
in case it is not the write to afis deemed anadditional write access.
moreover the comparison also checks if tfwrites to all addresses aithat every fault free execution writes to.
if it does not a write to such an aiis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
deemed missing.
finally for the set of addresses that both the faulty and at least one fault free execution write to the value vfwritten by tfis checked against the set of values written by the fault free executions.
if vfis not in that set the write access differs from the corresponding write accesses seen in fault free runs.
non pointer values are not assigned symbolic counterparts during trace processing but may in some cases take on different values even during most fault free runs.
this can be the case with for instance addresses that are written as non pointer types timestamps or random values.
in order to minimize the number of false positives introduced by such cases the comparison between faulty and fault free runs ignores any values that differed in a majority of fault free runs i.e.
for which the number of observed values is greater than half the number of fault free runs .
the numbers of missing additional and differing stores are gathered separately for the three cases of write access visibility.
v. e xperimental analysis in this section we evaluate our approach by performing experiments with real world linux kernel modules a storage device driver and two file systems.
the questions that we strive to answer in this evaluation are detailed in the following section v a. we describe our sut in section v b. section v c covers the injection targets and section v d our choice of workload.
we report on our experimental results in section v e. a. research questions is t rek era sound detector for error propagation?
to answer this question we analyze if there are any spurious indications of error propagation by comparing memory traces of sfi tests for which the injected mutations have not been activated.
as the injected faults cannot have an effect on the correct execution of the workload in this case any differences in the memory traces are false positives.
does t rek erimprove the soundness of sfi tests?
even if t rekeris a sound detector it only improves the soundness of sfi tests if silent error propagation actually occurs in these tests.
to assess if silent error propagation goes unnoticed in conventional os level sfi tests we analyze t reker s memory traces for sfi tests that complete without any obvious error indications.
what are the overheads resulting from t rek er s instrumentation?
static code instrumentation always imposes a certain overhead at both compile time and run time.
we compare both compilation and execution times of t reker against native sfi test compilation and execution.
does t rek er s instrumentation affect sfi test results?
as code instrumentation modifies the sfi target s binary code and thereby potentially its behavior it is conceivable that the results of sfi tests are affected or even invalidated by the instrumentation.
in order to assess if such an effect is observable for our approach we compare the results of sfi tests with and without instrumentation of the injection target using fisher s exact test for independence.b.
sut although t rekersupports native execution we perform our evaluation in a virtualized environment to avoid frequent hard machine restarts due to system crashes resulting from the tests.
the toolchain we use in the experiments is illustrated in figure .
the guest system is debian .
running in qemu .
.
.
it is configured with one cpu and gib of ram and has virtual scsi and nvme devices attached.
kvm is enabled.
the guest kernel is linux .
.
patched to support compilation with clang llvm using a modified version of the patch set created by the llvmlinux3project and compiled with clang llvm .
.
.
the host system is debian .
running the distribution provided .
kernel.
all experiments are performed using four parallel qemu instances running on a host system equipped with an i7 cpu and gib of ram.
experiment control and timeout detection are handled by a controller running on the same host.
the timeout value for all tests is 45seconds excluding boot and setup time.
in addition to the timeout mechanism we employ detectors operating on the serial output of the guest system to detect error messages from the kernel.
our detectors distinguish between five different classes of kernel error messages call trace gpf bug oops and panic .
we also check exit codes during the workload execution to detect workload failures that did not result in kernel error messages resulting in a total of eight different experiment result classes.
c. injection targets and faultload selection we apply our proposed approach to three different widely used linux kernel modules f2fs the flash friendly file system a file system specifically designed for nand flashbased storage devices btrfs a copy on write file system implementing various advanced features and nvme the kernel module providing support for nvme devices.
for each of these modules we perform the following series of steps we inject software faults using the safe tool4 with default settings build the resulting module using our compile time instrumentation tool section iv a execute a workload that utilizes functionality provided by the module and observe the resulting effects during execution and via memory trace comparison.
safe performs fault injection at the source code level using the g swfit fault operators.
we build and instrument the target modules with clang llvm .
.
.
we use prefix matching for btrfs andf2fs to maximize the usage of recorded memory traces see section iv c .
as nvme directly interfaces with the system hardware and thus has a higher exposure to non determinism we use the strict mode to limit false positives resulting from this.
d. workload selection all three modules in our study provide functionality related to file i o. two of them btrfs andf2fs are file systems authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
moduleinstrumented modulekernel runtimeqemuexperiment control result detection ssh serial console traceexp.
logprocessed tracetrace analysis symbolificationinstr.fig.
.
the qemu based virtualized test environment and toolchain and the third one nvme provides support for an interface standard for storage devices.
consequently we apply the same workload to all three modules.
specifically the workload consists of the following sequence of steps loading the target module and any other required modules creating a filesystem f2fs for the f2fs andnvme modules btrfs for the btrfs module on either an nvme nvme f2fs or scsi btrfs device mounting that filesystem creating a new file and writing to it creating a new directory reading the file removing the directory removing the file unmounting the filesystem removing the target module and all other modules that were loaded in the first step.
the instrumentation is active throughout the execution of the workload that is the runtime module is loaded prior to the first step and removed after the last step .
this workload exercises most commonly used filesystem features and through module insertion device registration i o activity and removal also exercises the essential functionality of the nvme module.
e. results we report on the experimental results obtained with trekerand how they answer the research questions posed in section v a. the overall result distribution for runs with activated mutation according to the simple detectors discussed in section v b is shown in figure .
soundness of treker in mutation based sfi there is a risk that the mutated code fraction does not get executed during the test and obviously no error propagation should occur in these cases.
to reliably identify these tests we track the execution of mutated code by dedicated log instructions.
we then use t rekerto analyze their memory traces.
any error propagation indicated by t rekerare false positives.
figure shows the number of trace deviations detected by t rekerfor different numbers of golden runs used as comparison basis for runs with and without mutation activation with the latter case representing false positives indicated by the dashed lines.
for all three modules we observe a false positive rate below .
from .
.
.
.
success workload timeout workload failurecall tracegpf bugoops panic result classrelative frequencymodule btrfs n f2fs n nvme n fig.
.
result distribution for runs with activated mutation figure we see that the number of detected trace deviations does not change beyond 800golden runs.
consequently we use this number as a comparison basis in our further experiments to keep the false positive rate in the presented results below and the comparison stable.
soundness of sfi tests with treker to assess the suitability of the proposed approach for detecting divergences in mutant behavior during apparently successful runs we examine the sets of sfi test traces with mutant activations which finished without any obvious error indication i.e.
the runs that are marked as successful in figure .
we show the trace deviations found by t rekerin figure with overall rates ranging from btrfs to10 nvme .
from the analysis of different visibility types we observe instances of at least two different types of visibility for all modules.
however store visibility via a global variable only occurs for nvme .
we conclude that although the different types of visibility occur with different frequencies analysis of all three is needed to obtain a complete picture of differences in memory access behavior between executions.
the significantly higher rate of propagation to the callee rather than the caller is an interesting observation as it indicates that errors tend to not propagate directly to components that invoke functionality of the targeted modules i.e.
their callers but rather tend to spread further in the system.
while a detailed study is needed to substantiate such a result this finding illustrates the insights that t reker fosters and that traditional sfi oracles cannot provide.
instrumentation overhead to assess the overhead associated with our instrumentation we compare the durations for compiling and executing mutated modules in different instrumentation modes.
compile time overhead we measure the user time5that make needs for building instrumented and uninstrumented versions of our mutants from a clean work space.
table i summarizes the median and the median absolute deviation 5we employ the gnu time utility to collect user times.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
.
.
.
golden runstrace deviation ratemodule btrfs f2fs nvme strict mutation activation activated inactivefig.
.
result stability with increasing number of golden runs.
.
.
.
.
.
btrfs f2fs nvme strict modulerelative frequencyvisibility type total callee caller global fig.
.
trace deviation rates for the three modules and different types of store visibility when compared with golden runs.
mad of user times.
column ohreports the overhead factors between median values for compilation with instrumentation for all modules.
in the median the compile time overhead ranges from a factor of 4forf2fs to a factor of 7for btrfs .
we deem these overheads as manageable in practice especially since compilation is often a one time effort and the actual needed real time for compilation is much smaller than accumulated user time due to parallel compilation capabilities of build tools like make.
run time overhead we run the same sfi tests using the full set of mutants in three different modes without instrumentation with instrumentation compiled into the mutants but disabled during runtime and with active instrumentation.
we measure the durations of all workload executions that complete in all three modes.
table ii summarizes the median and the median absolute deviation mad of workload durations in seconds of real time.
column ohreports the overhead factors betweentable i compile time overhead oh of instrumentation .
user times are reported in seconds .
module buildtype median mad oh btrfsinstr uninstr f2fsinstr uninstr nvmeinstr uninstr table ii run time overhead oh of instrumentation .
w orkload durations reported in seconds .
module mode median mad oh btrfsinstr active instr inactive uninstr f2fsinstr active instr inactive uninstr nvmeinstr active instr inactive uninstr median values compared to the uninstrumented execution.
the overhead for runs with active instrumentation ranges from a factor of 5forbtrfs to a factor of forf2fs .
we attribute the higher relative overhead for f2fs to the high concentration of logging output in its mount routine.
we expect to achieve a lower overhead for such cases if data logging is changed to use a more efficient format rather than relying on the kernel s printk facilities.
execution with inactive instrumentation imposes a negligible overhead.
we observe the highest overhead for nvme with14 ms .
by comparison pinos overheads with inactive instrumentation range from a factor of 12to120.
decaf incurs a overhead with disabled instrumentation in addition to the overheads incurred by qemu emulation.
t reker in contrast can run on bare metal configurations to avoid this overhead.
we conclude that with t reker instrumented modules could even be used in production but data logging should be enabled only for tests or execution periods of interest for trace analysis.
instrumentation impact on sfi test results we examine the effect of our instrumentation on the results of sfi tests.
we use the same set of tests with three instrumentation modes table iii p values of fisher s test of independence of observed result distribution and instrumentation mode module p btrfs f2fs nvme authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that we used to assess the run time overhead in section v e3.
we consider all tests with activated mutation and compare the obtained result distributions for each module.
we use fisher s exact test to test the null hypothesis h0 that there is no association between observed result distributions and the instrumentation mode .
table iii reports the p values obtained from fisher s test.
with p for all three modules we cannot reject the null hypothesis i.e.
there is no statistically significant evidence that the instrumentation systematically changes the result distribution.
nonetheless in pairwise comparisons of executions of the same mutant with different instrumentation modes we observe a small number of differences in outcomes.
we focus on the comparison between runs with activated instrumentation and uninstrumented runs and see a total of and differences for btrfs f2fs andnvme respectively amounting to and2 .
as it is the module that most frequently exhibits such divergences we discuss the nature of the divergences seen for nvme in some more detail in of the cases we observe a timeout only for the run with activated instrumentation.
we hypothesize that these are most likely cases of spurious timeout detection potentially a result of the overheads we discuss in section v e3.
in a further cases we observe neither a success nor a timeout but different failure modes.
for instance there are several cases in which the uninstrumented run results in a kernel panic whereas the run with activated instrumentation merely results in a kernel oops before reaching the execution time limit.
these are once again likely related to longer test execution times due to the instrumentation.
we also observe two cases in which the instrumented run completes successfully whereas the uninstrumented run does not suggesting non deterministic behavior by the mutant.
among the remaining cases we observe twelve in which the instrumented run fails shortly after activating a mutation whereas the uninstrumented run does not our data does not reveal whether the mutation was activated during the uninstrumented run six cases in which the instrumented run results in a failure after the end of the workload execution and after removal of the runtime but prior to system shutdown and finally one in which the uninstrumented execution times out but the instrumented run does not.
we conclude that most of the differences in outcome we observe are related to timeout detection and execution time limits and could be tackled by adjusting the corresponding values at the cost of a lower test throughput similar to what has been reported in .
threats to validity we identify the following threats to validity non determinism in the memory access patterns of the target modules that can even in the absence of faults lead to divergences between execution traces for the same workload limitations of the presented approach for identifying visible stores assigning symbolic addresses and detecting divergences the choice of target modules sut and workload.
we take several measures to minimize the effects of nondeterminism we use a large number of golden runs as a comparison base assign symbolic values to memory addresses including pointers that are used as value rather than address operands in load or store operations to avoid non determinism introduced by concrete address values and handle different processes and threads individually as opposed to explicitly tackling concurrency.
the low false positive rates obtained in our evaluation demonstrate the effectiveness of these measures.
trekerhas several restrictions on the scope within which for instance store visibility is determined e.g.
only stores between the prior external function and the current one are considered or symbolic values are assigned pointer arithmetic that is not modeled by getelementptr instructions is not analyzed .
these restrictions result from the deliberately limited scope of our instrumentation and from performance optimizations in the trace processing.
consequently there may be visible stores outside of the range considered by t rekeror different memory addresses that are assigned the same symbolic address.
such instances may result in the proposed approach reporting fewer divergences than actually exist.
finally the evaluation targets three different kernel modules providing related functionality running on one kernel version and one system setup.
other categories of kernel modules or other operating systems may behave in a significantly different manner and our results may not generalize.
furthermore different workloads could exercise different parts of the module.
long running workloads for instance may be expected to spend less time executing parts of the module for which the instrumentation is particularly expensive such as module insertion potentially leading to lower mean overheads.
furthermore the likelihood of error propagation may increase with longer workload running times.
we believe that t reker is applicable to a wide variety of usage scenarios and our evaluation demonstrates the viability of the approach.
vi.
c onclusion in this paper we have presented t reker an approach for identifying how faulty os components can affect other parts of the system.
t rekerenables tracing memory accesses in a target module using compile time instrumentation and achieves low instrumentation overheads.
we have presented a method for utilizing t rekerto improve oracles for fi experiments targeting os components.
an evaluation with several widely used modules for the linux kernel demonstrates the viability of the approach finding that conventional oracles would misclassify up to of seemingly successful runs.
the evaluation shows a false positive rate below .