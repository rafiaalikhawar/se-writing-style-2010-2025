scheduling constraint based abstraction refinement for weak memory models liangze yin laboratory of software engineering for complex systems national university of defense technology changsha hunan china yinliangze .comwei dong laboratory of software engineering for complex systems national university of defense technology changsha hunan china wdong nudt.edu.cn wanwei liu laboratory of software engineering for complex systems national university of defense technology changsha hunan china wwliu nudt.edu.cnji wang state key laboratory of high performance computing national university of defense technology changsha hunan china wj nudt.edu.cn abstract scheduling constraint based abstraction refinement scar is one ofthemostefficientmethodsforverifyingprogramsundersequential consistency sc .
however most multi processor architectures implement weak memory models wmms in order to improve the performance of a program.
due to the nondeterministic execution of those memory operations by the same thread the behavior of a program under wmms is much more complex than that under sc which significantly increases the verification complexity.
this paper elegantly extends the scar method to wmms such as tso andpso.tocapturetheorderrequirementsofanabstractioncounterexample under wmms we have enriched the event order graph eog ofacounterexamplesuchthatitiscompetentforbothscand wmms.
we have also proposed a unified eog generation method which can always obtain a minimal eog efficiently.
experimental resultsonalargesetofmulti threadedcprogramsshowpromising results ofour method.it significantlyoutperforms state of the art tools and the time and memory it required to verify a program under tso and pso are roughly comparable to that under sc.
ccs concepts software and its engineering software verification and validation keywords concurrent program verification weak memory model scheduling constraint event order graph corresponding authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
reference format liangzeyin weidong wanweiliu andjiwang.
.schedulingconstraintbasedabstractionrefinementforweakmemorymodels.in proceedings of the 33rd acm ieee international conference on automated softwareengineering ase september3 montpellier france.
acm new york ny usa 11pages.
introduction sequential consistency sc is a simple and commonly assumed memoryconsistencymodelforconcurrentprograms.mostexisting work for concurrent program verification focuses on sc.
however to improve the performance of concurrent programs most multi processor architectures use weak memory models wmms .
programs under wmms exhibit two kinds of nondeterminism the inter threadnondeterminismduetothethreadinterleaving andthe intra threadnondeterminismduetotheoutofordereffectonthose memory operations by the same thread.
due to the intra thread nondeterminism aprogramunderwmmsallowsmanymorepaths thanthatundersc whichsignificantlyincreasesthecomplexity of writing and verifying concurrent programs.
bounded model checking bmc is one of the most efficient techniquestoalleviatethepathexplosionproblemofconcurrent programs.however a largeformulaisusually requiredtogivean exact encoding of the program behavior.
to avoid the large encoding wehaveproposedaschedulingconstraintbasedabstraction refinement scar methodforverificationofconcurrentprograms under sc .
the idea is that observing that the scheduling constraint usually dominates the monolithic encoding we initially ignoretheschedulingconstraintandobtainanover approximation of the original program.
if a counterexample is found further validationofthecounterexampleisperformedandtheabstractionis refined if the counterexample is determined to be infeasible.
toprune more search space in each iteration we have proposed a notionofeventordergraph eog andtwograph basedalgorithms over eog for counterexample validation and refinement generation.
we have proved that our method is both sound and complete w.r.t.
the given loop unwinding depth.
our tool implementing this methodhaswonthegoldmedalintheconcurrencysafetycategory of both sv comp and .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france liangze yin wei dong wanwei liu and ji wang in this paper we try to extend this method to wmms such as tso and pso.
we first analyzed the difference between the monolithicencodingsofconcurrentprogramsunderscandwmms.
the only difference is on the execution order of those memory operationsbythesamethread whichisdeterministicunderscbut nondeterministic under wmms.
the out of order effect of wmms allowsafollowingoperationtoexecutebeforeapreviousone.inthe scar method the execution order of different memory operations iscapturedbytheeogofanabstractioncounterexample.toextend thismethodtowmms wehaveenrichedtheeogbyemploying a directed graph rather than a line to restrain the intra thread execution order.
an intuitive method to obtain the eog usually generatesmanyredundantorders whichmaysignificantlyincrease the overhead of those graph analysis processes.
to address this problem we have devised a unified eog generation algorithm whichcanalwaysobtaintheminimaleogforbothscandwmms efficiently.then weobtainedaunifiedscarmethodwhichcan deal with programs under both sc and different wmms.
we have implemented our method on top of yogar cbmc and evaluated it on the benchmarks in the concurrencysafety category of sv comp .
experimental results show promising performanceofourmethod.ithassuccessfullyverifiedallexamplesunder tso and pso and performs much better than cbmc one of the most popular verifier for concurrent program verification.
we also observedthatourmethodisnotsensitivetodifferentmemorymodels.
in our experiments the time and memory it required to verify a program under wmms are comparable to that under sc.
the contributions of this paper are listed as follows.
this paper has elegantly extended the scar method to a unified approach for different memory models which can deal with programs under both sc and wmms.
thispaperhasproposedaunifiedalgorithmforeoggeneration which is suitable for different memory models and can always obtain the minimal eog efficiently.
we have implemented our method on top of yogar cbmc.
experimentalresultsonalargenumberofprogramsshow promising performance of our method.
we have verified all examples in the concurrencysafety category of sv comp under tso and pso.
to the best of our knowledge we are the first to give exact results to all these examples under tso and pso.
the rest of this paper is organized as follows.
section 2introduces the preliminaries.
section 3reviews the scar method under sc.sections 4extendsthismethodtowmms.section 5enriches theeogtowmmsandpresentsoureoggenerationmethodwhich can obtainthe minimal eog efficiently.
section 6provides theexperimentalresults.section 7reviewstherelatedwork andsection concludes the paper.
preliminaries .
multi threaded program amulti threaded program consists of multiple concurrent threads.
it contains a set of variables which are partitioned into shared variablesandlocalvariables.eachthreadcanread writeboththeshared variables and its local variables.
we assume each variable access is atomic.
this paper focuses on programs based on pthreads one of qlwldoo u v figure a simplified dekker algorithm.
themostpopularlibrariestowardsmulti threadedprogramming.
it uses pthread create t attrib f args to create a new thread t and pthread join t return to suspend current thread until thread tterminates.
givenamulti threadedprogram wewrite vforthesetofshared variables.
an eventeis a read write access to a shared variable.
we useeto denote all events.
each e eis associated with an elementvar e vand a literal guard e which represent the accessedvariableandtheguardliteral respectively.anevent ecan be either a read or a write of the shared variable var e .
to express the execution orders of different events we associate each event withauniquenaturalnumber clk e .clk e1 clk e2 represents thate1executes before e2.
theprogram pdeterminesapartialorder p e e.intuitively e1 pe2 orwewrite e1 e2 p indicatesthat e1shouldhappen beforee2according to the program order ofp .
a read write link e1 e2 representsthat e2readsthevaluewrittenby e1 .therefore var e1 var e2 e1is a write e2is a read and the value of e2is equal to that of e1.
in addition there should be no other write of var e1 happening between them.
.
weak memory model scisthemostsimpleandcommonlyassumedmemoryconsistency model.
it requires the execution order of those events by the same thread wecallit intra threadorder inthefollowing tobeconsistent with the program order.
consider the simplified dekker mutualexclusionalgorithmshowninfigure whichconsistsof two threads p1andp2.
it contains two shared variables xandy.
both of them are initialized to .
under sc it requires the write ofxto execute before the read of yforp1 and the write of yto executebeforethereadof xforp2.afterboth p1andp2terminate at least one of randsmust be .
under wmms to make full use of hardware and compiler level optimizations it allows the intra thread order to be inconsistent withtheprogramorder.thatis forthoseeventsbythesamethread it allows a following event to execute before a previous one.
we usually call this feature the out of order effect of wmms.
the most widely used intel x86 and sparc architectures use the tso total store ordering model which relaxes the write to read program order i.e.
a following read can execute before a previous writetoadifferentaddress.thepso partialstoreordering model further relaxes the write to write program order i.e.
it further allows a following write to execute before a previous write to a different address.
the ibm powerpc model relaxes program order betweenalloperationstodifferentaddresses .thus afollowing read or write can execute before a previous read or write to a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scar for weak memory models ase september montpellier france 0xowl 7kuhdghg 3urjudp evwudfwlrq 0rgho udsk edvhg 9dolgdwlrq rqvwudlqw edvhg 9dolgdwlrq rqvwudlqw edvhg 5hilqhphqw udsk edvhg 5hilqhphqw rxqwhuh dpsoh qihdvleoh qihdvleoh 1rw 6xuh hdvleoh 3urri7uxh rxqwhuh dpsoh evwudfwlrq5hilqhphqw rqvwudlqw uuru vwdwhv k d figure an overview of the scar method .
differentaddress.weinthispapermainlyfocusontsoandpso.
nevertheless our method can also be applied to other models.
theoutofordereffectofwmmsplaysacrucialroleinimproving the program performance.
however programs based on wmms mayexhibitmanybehaviorsthatviolatetheprogrammer sintuition.
fortheexampleshowninfigure undertso thereadof ycan execute before the write of xforp1 and the read of xcan execute beforethewrite of yforp2.hence randsmaybothbe0 after p1 andp2terminate.
the scar method for sc bmc is one of the most applicable techniques to alleviate the path explosion problem of concurrent programs.
instead of explicitly enumeratingallthreadinterleavings itemploysasymbolicrepresentation to encode the verification problem which is then solved by a sat smt solver.
if a positive answer is given then a satisfying assignment corresponding to a feasible counterexample isacquired.
otherwise the program is proven safe w.r.t.
the given loop unwinding depth.
in bmc a multi threaded program under sc is usually encoded asamonolithicencoding sc init sc where initis theinitialstates encodeseachthreadinisolation formulates that eachreadofavariable vmayreadtheresultofanywriteof v and scformulates the scheduling constraint which defines the orderrequirementsamongalleventsoftheprogramundersc.the scis constituted of two parts po scand rf sc where po screquires that the intra thread order should be consistent with the program order and rf scdefines that for any read write link e1 e2 there should be no other write of var e1 between them .
a problem for bmc of concurrent programs is that the monolithicencoding scusuallygeneratesalargeformulawhichoverwhelmsmodernconstraintsolvers.observingthat scisusually dominatedbytheschedulingconstraint sc w ehav epr oposeda schedulingconstraintbasedabstractionrefinement scar method forverificationofmulti threadedprogramsundersc whichcan avoid the large formula .
figure 2presents the overview of the method.
given a multi threaded c program it first ignoresthe scheduling constraint in the encoding.
an over approximated abstraction of the original program is then obtained as 0 init .itthenaddstheabstraction 0andtheerrorstates errtotheabstractionmodel.ifitisunsatisfiable thentheproperty is proven safe w.r.t.
the given loop unwinding depth.
otherwise a counterexample of the abstraction is provided.
given that the schedulingconstraint scisignoredintheabstraction thiscounterexample may be infeasible and further validation is required.
to validate the feasibility of an abstraction counterexample a notion of event order graph eog is proposed.
we have proved that an abstractioncounterexampleisfeasibleiffthecorrespondingeog is feasible.
an intuitive method for eog validation is constraint solving.iftheeogisinfeasible thentheabstractionisrefinedbyexploringtheunsatisfiablecore.however thismethodisnoteffective for refinement generation.
to obtain an effective refinement we devised two graph based algorithms over eog for counterexample validationandrefinementgeneration inwhichasmallyeteffective refinement can always be obtained if the eog is determined to be infeasible.however thismethodisnotcomplete.itcanonlygive aninfeasibleanswer.tomaketheoverallmethodbothefficientand sound wefirstadoptthegraph basedeogvalidationmethod.if theeogisdeterminedtobeinfeasible thegraph basedrefinement processisperformedtoobtainaneffectiverefinementconstraint.
otherwise weemploytheconstraint basedvalidationprocessto further validate the eog.
abstraction counterexample.
a counterexample of an abstraction i is a set of assignments to the variables in i err where erristheerrorstates.itdefinesasetofeventsoccurringin and theread write linksfor each readevent.
denote by e e the set of events occurring in .
a counterexample is said to befeasibleifaconcreteexecutionoftheoriginalprogramcanbe constructed from .
given that the events occurring in a concrete executionmustsatisfytheorderrequirementsdefinedin po scand rf sc the crucial issue to validate a counterexample is to find a total order overe s.t.
obeys all the order requirements defined in scheduling constraint.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france liangze yin wei dong wanwei liu and ji wang lqw p q yrlg wku yrlg duj p yrlg wku yrlg duj q yrlg pdlq swkuhdgbw w w swkuhdgbfuhdwh w wku swkuhdgbfuhdwh w wku swkuhdgbmrlq w swkuhdgbmrlq w dvvhuw p q lqw p q yrlg wku yrlg duj p yrlg wku yrlg duj q yrlg pdlq swkuhdgbw w w swkuhdgbfuhdwh w wku swkuhdgbfuhdwh w wku swkuhdgbmrlq w swkuhdgbmrlq w dvvhuw p q d 7kh ruljlqdo surjudp e 7kh vwdwhphqwv ri wkh surjudp figure a three thread program .
eventordergraph.
todefinetheorderrequirementsofacounterexample two partial orders 0 and triangleleft are defined on e e .
the 0 denotes the order requirements due to po sc.
any order e1 e2 0 requirese1to execute before e2.
the triangleleft denotes the order requirements due to rf sc.
any order e1 e2 triangleleft represents that e1 e2 isaread writelinkin whichrequires e1toexecute beforee2 and there should be no write of var e1 happening between them.
an order 0 resp.
triangleleft is called a program order resp.
read from order of .
aneventordergraph eog isagraphthatcapturesalltheorder requirements of a counterexample.
given a counterexample the eogg is a triple angbracketlefte 0 triangleleft angbracketright where the nodes are the events ine and the edges are the orders defined in 0 and triangleleft .
each nodecorrespondstoeithera read ora write of andeachedge corresponds to either a program order or a read from order of .
for each edge corresponding to a program order e1 e2 0 i t requiresthat clk e1 clk e2 andforeachedgecorrespondingtoa read fromorder e1 e2 triangleleft itrequiresthat clk e1 clk e2 and for any other write of var e1 ine it requires clk e3 clk e1 orclk e2 clk e3 .
a counterexample is feasible iff there exists atotalorder overe s.t.
obeysalltheorderrequirements defined in g .
eogbasedcounterexamplevalidationandrefinementgeneration.
any edge e1 e2 of an eog g requires that clk e1 clk e2 .hence aneogmustbeinfeasibleifitcontainssomecycles.
given that a read from order e1 e2 triangleleft further requires that no other write of var e1 could happen between e1ande2 some derivedorders deduciblefromtheeogmustexist.threeruleshave beenproposedin todeduceasmanyderivedordersaspossible first.
if some cycle exists in the result graph then the eog must be infeasible.ifacounterexampleisdeterminedtobeinfeasible one shouldaddsomeconstraintstotheabstraction topreventthiscounterexample from appearing again in the future search.
to prune p q p p q q u u u u u u k k figure an eog of the program of figure .
more search space the kernel reasons that make the counterexample infeasible are analyzed and the negations of them are then added to the next abstraction.
consider the example presented in we will use it later .
the example is shown in figure where figure a is the original program andfigure b isthestaticsingleassignment ssa statementsoftheprogram inwhichtheprogramvariablesarerenamed suchthateachvariableisassignedonlyonce.figure 4isaneog ofacounterexample forthisexample.inthefiguresthatdescribe eogs the white and gray nodes denote writes and reads occurring in the corresponding counterexample respectively.
a solid arrowwithatriangularheadfrom e1toe2representsa programorder whichrequires e1tohappenbefore e2.adashedarrowfrom e1 toe2representsa read writelink e1 e2 .itrequiresthat e1should happenbefore e2 and2 nowriteof var e1 shouldhappenbetween them.
a solid arrow with a hollow head from e1toe2represents a derived order which is derived from existing order requirements.
italsorequires e1tohappenbefore e2.figure4showstwocycles including c1 clk x2 clk y3 clk y4 clk x5 clk x2 andc2 clk x2 clk x4 clk y4 clk x5 clk x2 .
hence is infeasible.
the kernel reasons of these two cycles are then analyzed to refine the abstraction which contains only two simple cnf clauses.
the scar method for wmms forprogramsunderwmms themonolithicencodingcanberepresented as wmm init wmm where init and are the same as those for sc.
the wmm po wmm rf wmmformulates the scheduling constraint under wmms which defines theorderrequirementsamongalleventsofaprogram.here the rf wmmisthesamewith rf sc whichdefinesthat foranyread write link e1 e2 there should be no other write of var e1 between them .
the only difference between the encodings under sc and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scar for weak memory models ase september montpellier france wmmsison po scand po wmm whichcapturetheorderrequirements due to the program order of sc and wmms respectively.
under sc the intra thread order must be consistent with the programorder.
but under wmms the intra thread order is relaxed and a following event may execute before a previous one.
under sc the intra threadorderisdeterministic andtheencodingof po scislinear in the number of events.
but under wmms the intra thread order is nondeterministic and the encoding of po wmmis quadratic in the number of events.
as observed in the monolithicencoding scisdominated bytheschedulingconstraint sc.formostexamplesintheirexperiments scusuallyaccountsformorethan85 oftheencoding.for programsunderwmms themonolithicencodingissamewiththat under sc except for po wmm which is much larger than po sc.
hence the monolithic encoding wmmis even larger than sc and the scheduling constraint wmmaccounts for a even larger proportion than that under sc.
toavoidthelargeformulaof wmm wewillextendthescar methodtowmms.theideaisthat similartotheframeworkshown infigure wefirstignoretheschedulingconstraint wmmfrom the monolithic encoding wmm and obtain an over approximated abstraction of the original program 0 init .
here the initial abstraction 0is exactly the same as under sc.
we then addtheabstraction 0andtheerrorstates errtotheabstraction model which is then solved by a constraint solver.
if it is unsatisfiable giventhattheabstractionisstillanover approximationofthe originalprogramunderwmms thepropertyisprovensafew.r.t.
thegivenloopunwindingdepth.otherwise acounterexample oftheabstractionisprovided andfurthervalidationofthecounterexample is required.
given that the abstraction is obtained by excludingthe schedulingconstraint wmm the counterexample is feasible iff there exists a total order overe s.t.
obeys all the order requirements defined in wmm.
again we can employ an eog g to capture all the order requirementsthattheeventsin mustsatisfy.ifthereisatotalorder ofe which satisfies all the order requirements defined in g then isfeasible.todeterminethefeasibilityofaneog wefirst employthegraph basedeogvalidationmethod.particularly we deduceas manyderivedordersas possiblebythe sameruleswith that under sc.
if there exists some cycle in the result eog then we can conclude that no total order of e can satisfy all the order requirements.inthiscase weanalyzethekernelreasonsleadingto these cycles which are then negated to refine the abstraction.
the kernel reason analysis method is exactly the same with that under sc.ifnocycleisfound weemployaconstraintbasedmethodto further decide the feasibility of the eog.
the method is that weencode all the order requirements of the eog into a constraintformula which is then solved by a constraint solver.
the eog is feasibleiffasatisfiableresultisreturned.ifanunsatisfiableresultis obtained weemploytheunsatisfiablecoretorefinetheabstraction.
the overall framework of the scar method can be elegantly extended to programs under wmms.
moreover the methods for initialabstractiongeneration eogvalidation andkernelreason analysis etc.
are all exactly the same with that under sc.
the only difference is that given that po wmmis different from po sc the eogand the constraint formula encoding order requirements of the eog should be different from that under sc.
a unified eog for both sc and wmms an eog is used to capture the order requirements that must be satisfied for those events of a counterexample.given a counterexample theeog g isatriple angbracketlefte 0 triangleleft angbracketright wherethenodesare theeventsin e andtheedgesrepresenttheorderrequirements definedin 0 and triangleleft .forprogramsunderwmms the e and triangleleft are exactly the same with that under sc.
the only difference is on 0 .
for ease of presentation for an eog we discuss only 0 in the following.
.
the eog for wmms the 0 definestheorderrequirementsduetotheprogramorder.
undersc itrequirestheintra threadordertobeconsistentwith theprogramorder.accordingtotheprogramorder theintra threadorderofanycounterexampleisdeterministic.itusuallyformsaline foranythreadofacounterexampleundersc.figure a demonstrates the 0 under sc for the counterexample shown in figure .
however for programs under wmms the intra thread order is relaxed.
the tso model allows a following read to execute before a previous write to a different address.
figure b demonstrates the 0 undertsoforthecounterexampleshowninfigure .for thread thr1 giventhat x2isawriteto xandy3isareadto y w e havey3can execute before x2and there is no order requirement betweenx2andy3.however giventhat y2shouldexecutebefore y3 andx2should execute before m3 we have the orders y2 y3 and x2 m3 .
the order requirements for thread thr2are the same with those of thread thr1.
thepsomodelfurtherallowsafollowingwritetoexecutebefore a previous write to a different address.
figure c demonstrates the 0 underpsoforthesamecounterexample.forthread thr1 according to the semantics of pso we have m3can execute before x2 andx3canexecutebefore m3.
however x2mustexecutebefore x3 andy3must executebefore m3andx3.
moreover according to the program m2should wait until all events in thr1have finished.
theordersshowninfigure c obeyalltheserequirements.the order requirements for thread thr2are the same with those of thread thr1.
from the above analysis the 0 under wmms is much more complexthanthatundersc.theintra threadorderisdeterministic and can be represented as a line under sc.
however it is nondeterministic and needs to be represented by a directed graph under wmms.
in fact the 0 under sc can be treated as a special case of the 0 under wmms.
.
intuitive eog generation method given a counterexample to generate the eog we should obtain e 0 and triangleleft .
given that both e and triangleleft are exactly the same with that under sc we introduce the method to generate 0 here.
toobtain 0 anintuitivemethodisthat foreacheventpair e1 e2 by the same thread where e2is a following event of e1 we check whethere1should execute before e2according to the wmm effect.
if it does then we add the order e1 e2 to 0 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france liangze yin wei dong wanwei liu and ji wang d 7kh xqghu e 7kh xqghu f 7kh xqghu e e ewku wku pdlqwku wku pdlqwku wku pdlq p q p p q q p q p p q q p q p p q q figure the 0 s under sc tso and pso for the counterexample shown in figure .
given a memory model mmand two events e1 e2 by the same thread where e2is a following event of e1 algorithm 1presents the procedure mustbefore which determines whether e1should executebefore e2.theprocedurereturnstrueif mmissc which representsthatnoprogramorderisrelaxedundersc.italsoreturns true ife1ande2are of the same address which represents that the program order is relaxed only on events of different addresses.
otherwise which already implies that e1ande2are of different addresses for tso it returns true if e1is not a write or e2is not a read for pso it returns true if e1is not a write or e2is neither a writenoraread.underwmms afencestatementrequiresthat any eventbefore resp.after afencestatementshouldexecutebefore resp.
after this statement .
the semantics of fence statements has also been considered in the mustbefore procedure.
we allow an eventtobeafencetoo.accordingtotheprocedure itwillreturn true if either e1ore2is a fence.
input amemorymodel mm andtwoevents e1 e2 wheree2 is a following event of e1.
output returntrueife1should execute before e2undermm falseotherwise.
ifmm scthen returntrue end ifvar e1 var e2 then returntrue endifmm tsothen return iswrite e1 isread e2 endifmm psothen return iswrite e1 isread e2 iswrite e2 end algorithm the procedure mustbeforeconsiderthe 0 ofthecounterexampleshowninfigure 4under tso.accordingtotheintuitiveeoggenerationmethod itwillgeneratetenordersforthread thr1 including y2 x2 y2 y3 y2 m3 y2 x3 x2 m3 x2 m3 x2 x3 y3 m3 y3 x3 m3 x3 .
.
our eog generation method a problem for the intuitive eog generation method is that it may generate many redundant orders in 0 .
definition5.
.
anorder e1 e2 issaidtoberedundantin 0 if can be deduced by other edges in 0 .
in other words an order e1 e2 is redundant if there exists apathfrom e1toe2in 0 .fortheaboveexample theorder y2 m3 isredundantbecauseitcanbededucedbytwootherorders y2 x2 and x2 m3 .theexistenceofredundantordersmaysignificantlyincreasetheoverheadofthegraph basedcounterexample validationandrefinementgenerationprocesses.forexample the numberofcyclesintheeogmayincreaseexponentially.however mostofthesecyclesmayberedundant thatis theirkernelreasons may be redundant with other cycles.
to address this problem we have devised a 0 generation algorithm which can always obtain the minimal 0 efficiently.
this algorithmissuitableforallmemorymodels includingsc tsoand pso etc.
actually it is a unified algorithm for generating 0 of different memory models.
our algorithm is shown in algorithm .
the 0 is initialized to .
we first use the eventsextract function to obtain e .
we denote by e ithe events of thread pi.
here the events in e iare stored in the program order.
to generate the intra thread orders of a thread pi we add the events in e ito theeogonebyoneintheprogramorder.let ejbetheeventsto be added.
then we check whether we should add an order fromsome of its previous event ektoejreversely.
the method is that we first use the mustbefore procedure shown in algorithm 1to determine whether ekshould execute before ejaccording to the wmmeffectof mm.ifitdoes weemploythe isredundant function to check whether the edge is redundant in current 0 .
if it cannot authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scar for weak memory models ase september montpellier france be deduced from 0 then we add the order ek ej to 0 .
after the intra thread orders of all threads have been added we use theinterthreadordergeneration function to add those programordersamongdifferentthreads i.e.
theorderrequirements due topthread create s andpthread join s. when the algorithm terminates we will obtain a minimal 0 with no redundant orders.
input a counterexample and a memory model mm output the program order 0 0 e eventsextract foreach thread pido generate intra thread orders of pi lete i e pi forj j e i j do letej e i fork j k k do letek e i ifmustbefore mm ek ej then let ek ej if isredundant 0 then 0 0 end end end end end 0 0 interthreadordergeneration algorithm our 0 generation algorithm.
the performance of algorithm 2significantly depends on the performance of the isredundant function.
to improve its performance for each node of the graph we maintain two bit vectors tomarkthepredecessorsandsuccessorsofeachnode.whenever a new order is added to 0 the two bit vectors will be updated properly.
in this manner an order e1 e2 is redundant in 0 iffe1is a predecessor of e2.
we prove that we always obtain a correct and minimal 0 in algorithm 2as follows.
theorem5.
.
foranyrequiredorderrequirement nelement 0 could be deduced from 0 .
proof.inalgorithm if isrequiredintheeogbut nelement 0 then must be redundant in 0 .
according to definition .
i t could be deduced from 0 .
square theorem .
.
for any order requirement 0 cannot be deduced from 0 .
proof.let em en .
suppose that can be deduced from 0 .
then there must exist a path from emtoenin 0 .
suppose that the path is em e0 ek en.
given that all orders in 0 must start from a previous event to a following event emandallei i k shouldbepredecessorsof en.hence should be redundant in 0 and the isredundant function in algorithm 2should return true when is considered.
hence will not be added to 0 which is contradict with that 0 .
therefore any order requirement 0 cannot be deduced from 0 .
square .
eog encoding if the graph based eog validation process is not sure about the feasibility of the eog we need to further validate its feasibility via a constraint based eog validation process.
the method is that we directlyencodealltheorderrequirementsdefinedintheeogintoa constraintformula.theeogisfeasibleifftheconstraintformulais satisfiable.
again to avoid the encoding of those redundant orders onlythoseordersin 0 shouldbeconsideredintheencoding such that the size of the constraint formula can be reduced.
experimental results we have implemented our method on top of yogar cbmc which has won the gold medals in the concurrencysafety category ofsv comp2017and2018.weusethe1047multi threadedprogramsofsv comp2018 asourbenchmarks.ourtoolsupports all features of c language in the experiments.
.
benchmark of sv comp theopen source representative andreproduciblebenchmarksof competitiononsoftwareverification sv comp havebeenwidely accepted for program verification.
given that these benchmarks aredevisedforcomparisonofthosestate of the arttechniquesandtools asignificantnumberofstudiesonconcurrentprogramverificationhaveperformedtheirexperimentsonthem.theconcurrency benchmarks of sv comp include examples and cover most of the publicly available concurrent c programs that are used for verification.
these programs contain hundreds of lines to threads complex structure variables with dimensional point ers and hundreds or even a thousand read write accesses.
with thesecomplexfeatures theseprogramsarechallengingforstateof the artconcurrencyverification techniques andtools.
though many studies have been performed on this benchmark these studies mainly focus onsc.
existingworkfor wmmsusually performs their experiments on a small subset of this benchmark .
.
experimental setup weconduct allofourexperiments usingacomputerwith intel r core tm i5 4210m cpu .60ghz and gb memory.
a 600second time limit is observed.
our experiments are presented in four parts.
we first present the verification results of our method under tso and pso.
then we compare our performance of tso and pso with that of sc and discuss the overhead due to wmms.
third we compare theperformance of our method with a popular verifier cbmc whichalsosupportstsoandpso.differentfromourmethod it providesanexactencodingoftheschedulingconstraintforprogram verification.
we use cbmc .
the latest version of cbmc in our experiments.
lastly we compare our method with the intuitive eoggenerationmethodanddiscusstheimprovementbenefitfrom our eog generation method.
the loop unwinding depths for both our method and cbmc are setasthatof yogar cbmc whichdynamicallydeterminesthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france liangze yin wei dong wanwei liu and ji wang table results under sc tso and pso.
sctsopso true246237125 false801810922 total104710471047 unwinding depth through syntax analysis.
particularly the bound isset to2for programswitharrays and nifsome oftheprogram s for loops are upper bounded by a constant n. .
effectiveness and efficiency .
.
verification results for tso and pso.
the results of the examplesunderscareknowntothepublic whichinclude246true examplesand801falseones.
however ther esultsoftheseexamples undertsoandpsoremaintobeunknown.giventhattheorder constraintsofsc tsoandpsoareinturnweaker afalseexample undersc resp.tso is alsofalseundertso resp.pso butatrue example under sc resp.
tso may be false under tso resp.
pso .
we perform our method on the overall examples under sc tso and pso.
table 1presents the number of true and false results we have obtained under the three memory models.
yogarcbmc has won the gold medal of sv comp and which can successfully verify all these examples.
in our experiments we have observed that under sc the eogs generated by our eog generationmethodareexactlythesamewiththosegeneratedby theoriginalyogar cbmc.hence ourresultsundersccoincide withthoseof yogar cbmc.fortsoandpso ourmethodcanstill solve all examples under these two memory models.
it is observed fromtheexperimentsthat undertso allthe801falseexamples underscarestillfalse and9trueexamplesfliptofalse.underpso allfalseexamplesundertsoarestillfalse butthereare112true examplesbecomingfalse.fromtheexperimentalresults itseems thatallowingthereorderoftwodifferentwritesismorelikelyto affect the program than allowing the reorder between a write and a following read.
.
.
performance for tso and pso.
given that the behaviors of a program under wmms are much more complex than that under sc more efforts are usually required in existing work to verifyaprogramunderwmms.toevaluatetheefficiencyofour method we compare the performance among sc tso and pso.
in ourexperiments wehaverespectivelyspent1568 and1930 seconds under sc tso and pso to solve all examples.
meanwhile thememorywehaveconsumedunderthethreememorymodelsare and45gb respectively.fromtheseresults inourmethod thetimeandmemoryitrequiredforwmmsarejustalittlemore than that under sc.
figure6furthercomparestheperformanceofthethreememory modelsforeachexample wherefigure a forscandtso and figure6 b for tso and pso.
in these figures each point stands for an example.
the x coordinate of a point denotes the spent time s under one memory model or for one method and the y coordinatedenotesthatofanothermodel ormethod .among all these examples there are examples which can be verified fasterundertsothanundersc andthereare338exampleswhich vhf vhf a tso versus sc vhf vhf b pso versus tso figure comparison among sc tso and pso canbeverifiedfasterunderpsothanundertso.thereareonly89 resp.
exampleswhichrequireshalfmoretimefromsc resp.
tso to tso resp.
pso .
though programs under wmms have more behaviors it also provide a higher probability to obtain a feasible counterexample in our method.even forthose trueexamples due tothe randomness of counterexample generation the verification under wmms may also performs better than that under sc.
moreover in the scar method the core kernel reasons of a cycle is more sensitive to the read fromlinkliterals.hence ourmethodisinsensitivetothetype of memory models.
.
.
comparison with cbmc.
we further compare the performance of our method with that of cbmc which supports tso andpso.toverifyprogramsunderthesetwomemorymodels it adopts the monolithic encoding which gives an exact encoding to the scheduling constraint.
in our experiments under tso cbmc ran error for examples ran timeoutfor examples and gave wronganswers for3 examples itturnedafalseexampletotruefromsctotso .tofinishall examples cbmchasspent32605secondsandconsumed128gb ofmemoryintotal.underpso cbmcranerror rantimeoutand authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scar for weak memory models ase september montpellier france 2xu 0hwkrg vhf vhf a tso 2xu 0hwkrg vhf vhf b pso figure comparison with cbmc gave wrong answers for those same examples under tso.
it has spent seconds and consumed gb of memory to finish all examples in total.
figure7further compares the performance of our method with thatof cbmc wherefigure a isfortsoandfigure b isfor pso.
from these two figures we can see that our method performs better than cbmc for nearly all examples no matter under tso or underpso.thescarmethodperformsmuchbetterthancbmc undersc.thisadvantagehasbeenbroughtintofullplaytowmms inourmethod.forcbmc giventhattheencodingforwmmsis much larger than that under sc its performance is worse under wmms than that under sc.
hence the results coincide with our original expectation.
.
.
comparison with the intuitive eog generation method.
one of our majorinnovation is on theunified eog generation method whichcanalwaysobtaintheminimal 0 withnoredundantorders.
toevaluatetheimprovementbenefitfromthismethod wecompare the performance of our method with that of the intuitive eog generation method.
undertsoandpso theintuitiveeoggenerationmethodcan solve only and of the examples respectively.
actually itcannotsolveanyexampleinthe pthread wmm directory which vhf 2xu 0hwkrg vhf qwxlwlyh 0hwkrg a tso qwxlwlyh 0hwkrg 2xu 0hwkrg vhf vhf b pso figure comparison with the intuitive method contains898examples.fortheseexamples therearealargenumber of shared variable accesses.
the intuitive eog generation method may generate thousands of orders in 0 which significantly increasestheoverheadofthegraph basedcounterexamplevalidation and refinement generation processes.
but with our algorithm the numberoforderscontainedin 0 isreducedtoaboutthreehundred.hence ourmethodperformsmuchbetterthantheintuitive eog generation method on these examples.
figure8further compares the performance of our method with thatoftheintuitiveeoggenerationmethod wherefigure a is fortsoandfigure b isforpso.fromthesetwofigures forthose examples which generate relatively fewer redundant orders the performance of the intuitive eog generation method may be comparablewithourimprovedmethod.therearesomeexampleson whichtheintuitivemethodperformsevenalittlebetter.thereason isthatintherefinementgenerationprocess toreducetheoverhead ofcycledetection wehavelimitedthenumberofdetectedcyclesto .obtainingdifferentcyclesmaygeneratedifferentrefinement constraints whichwillaffecttheefficiencyoftheverification.however forthoseexampleswhichgeneratemanyredundantorders our improved method runs much faster than the intuitive eog generation method.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france liangze yin wei dong wanwei liu and ji wang related work verification of concurrent programs under sc has been extensively studiedinrecentyears.themostsuccessfultechniquestoalleviate the path explosion problem include stateless model checking boundedmodelchecking andabstractionrefinement etc.thegeneralmethodofstateless modelcheckingistoemploypartialorderreduction por toexplore only non redundant interleavings.
there are also some work which reduces the search space by restricting the schedules of the program .
bounded model checking has been considered anefficienttechniquetoaddresstheinterleavingproblem.insvcomp2017 16outofthe18participantsintheconcurrencysafety categoryhaveadoptedthistechnique .however purebmcis not efficient enough.
many existing tools combine this method with other techniques .
abstraction refinement is also an importanttechniqueforconcurrentprogramverification.mostof existing work employs predicate abstraction to address the data space explosion problem which uses a finite number of predicates to abstract the program.
for programs under wmms given that the path explosion problemisstillthemainchallenge mostoftheexistingworkisbasedon the techniques for sc.
existing work for verifying programs under wmms can be divided into two directions.
the first direction is to convert a program under a wmm to another program under sc andthenemploythetechniquesandtoolsforsctoverifytheresult program.
in the work of to verify the reachability properties ofaprogram pundertso itfirstconverts pintoanewprogram p primeunder sc such that the reachable sets of pandp primeare the same.
theworkin furtherextendedthisapproachtopso rmoand powerpc etc.
precise conversion usually makes p primemuch more complex than p. to improve the verification performance some work tried to decrease the complexity of the result program by fenceinsertion.ho wever fenceinsertionmayloosesomeprecision.
to find a better trade off between precision and efficiency how to insertthefencesiscrucial.theworkof and employed cegar predicateabstractionandstatic analysismethodsrespectively to help insert fences.
in the work of e. tomasco et al.
employed shared memory abstraction sma to convert a program pundertsoandpsointoanewprogram p primeundersc whichis then verified by lazy cseq.
nevertheless the obtained program p prime is usually much more complex than the original program p which makes the verification of programs under wmms much difficult than that under sc.
anotherdirectionistoextendthetechniquesofsctowmms.
themoststudiedapproachistoextendstatelessmodelchecking to wmms.
stateless model checking explicitly explores all possible paths one by one.
to alleviate the path explosion problem it employs por to reduce the number of exploredpaths.
hence the crucial issue of extending stateless model checking to wmms is to extend por to wmms.
in the work of n. zhang et al.
relaxed the definition of enabled set and proposed a unified framework whichcanmodelboththeinter threadandintra threadnondeterminismunderwmms.intheworkof p.abdullaetal.proposed thenotionofchronologicaltraceforwmms whichcandistinguish theequivalentpathsunderwmms.theporisthenextendedto wmms based on this trace.
there are also some work extendingbmctowmms .theseworkemploysalogicformulatorepresentthebehaviorofprogramsunderwmms whicharethensolved by a constraint solver.
however encoding the program behavior directly usually requires a large formula which overwhelms modernconstraintsolvers.inthispaper weextendthescarmethod to wmms which avoids the large monolithic encoding.
conclusion mostmulti processorarchitecturesadoptwmmstoimprovethe performanceofaprogram.duetothenondeterminismoftheintrathreadexecutionorder thebehaviorofaprogramunderwmms ismuchmore complexthanthatundersc.
inthispaper wehave enriched the eog and elegantly extended the scar method to wmms.
to further improve the performance of this method a unifiedeoggenerationmethodhasbeendevisedwhichcanalways obtainthe minimaleog efficiently.weimplemented ourmethod on top of yogar cbmc and performed our experiments on the benchmarks in the concurrencysafety category of sv comp .
experimentalresultsshowthatourmethodisnotsensitivetomemory models and it performs much better than cbmc one of the state of the art tools for wmms.