effectiveness of code contribution from patch based to pull request based tools jiaxin zhu minghui zhou institute of software eecs peking university key laboratory of high confidence software technologies ministry of education beijing china zhujiaxin zhmh pku.edu.cnaudris mockus university of tennesee middle drive knoxville tn usa audris utk.edu abstract code contributions in free libre and open source software projects are controlled to maintain high quality of software.
alternatives to patch based code contribution tools such as mailing lists and issue trackers have been developed with the pull request systems being the most visible and widely available on github.
is the code contribution process more effective with pull request systems?
to answer that we quantify the effectiveness via the rates contributions are accepted and ignored via the time until the first response and final resolution and via the numbers of contributions.
to control for the latent variables our study includes a project that migrated from an issue tracker to the github pull request system and a comparison between projects using mailing lists and pull request systems.
our results show pull request systems to be associated with reduced review times and larger numbers of contributions.
however not all the comparisons indicate substantially better accept or ignore rates in pull request systems.
these variations may be most simply explained by the differences in contribution practices the projects employ and may be less affected by the type of tool.
our results clarify the importance of understanding the role of tools in effective management of the broad network of potential contributors and may lead to strategies and practices making the code contribution more satisfying and efficient from both contributors and maintainers perspectives.
ccs concepts software and its engineering !software maintenance tools collaboration in software development keywords code contribution effectiveness pull request issue tracker mailing list floss corresponding author.
.
introduction in free libre and open source software floss projects non core contributors have to go through the steps of code contribution process from code creation to review and acceptance.
these steps are essential to ensure the quality of contributions because of the diverse nature and skills of floss participants.
mailing lists and issue trackers where code contributions are submitted by patches have been widely employed to support code contributions.
the participation in and efficiency of the code contribution process from the perspective of code reviews have been extensively studied see e.g.
.
these studies indicate that a bulk of submissions do not receive a response and therefore do not involve a code review and are not considered to be within the scope of these studies.
the ignored submissions however are a critical part of the contribution practice as they require participants to create submit and document their code.
such wasted effort may detract submitters from further contributions and deter them from contributing altogether.
the core members at the same time may miss important and valuable contributions.
it is therefore imperative to understand the nature of code contribution efficiency at every stage in order to increase the overall effectiveness of code contribution practice.
in the past decade the code contribution tools based on pull requests e.g.
pull request systems provided by github and bitbucket have attracted wide attention .
in these tools code contributions are submitted reviewed and integrated through pull requests.
recent studies of pull requests have started to look at some aspects of the possible inefficiencies by investigating what makes it likely for a code submission to get accepted what the challenges faced by and working practices of integrators and contributors are .
however the role of tools in the overall effectiveness of code contribution practice and the relative amount of wasted effort have not been scrutinized in the research literature.
in this study we attempt to understand a complete picture from the perspective of a participant submitting code contribution to getting it accepted.
more specifically we aim to answer the following research question rq0 what are the differences of code contribution effectiveness between pull request based and patch based tools ?
we gather information from published literature and retrieve development data for four github projects to quantify the overall effectiveness of code contribution using different toolpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
s. following the literature we measure the contribution effectiveness via the code accept and ignore rates the times until first response and final resolution and the numbers of contributions adjusted for codebase size.
we start with the ruby on rails rails a high profile project on github which migrated from an issue tracker to the github pull requests.
we investigate whether the migration of tools within rails is associated with a change of contribution efficiency.
we continue the study by comparing eight projects using mailing list in the literature with four github projects using pull requests.
overall we find that the pull requests are more efficient in terms of making submissions processed faster and are associated with larger numbers of contributions.
however the within and cross project comparison lead to contradictory findings for accept and ignore rates.
as discussed in section the contradiction may be explained away if we assume that the accept and ignore rates are primarily determined by the project contribution practices and may be less affected by the type of tool used.
this understanding could help improve the code contribution process from both contributors and maintainers perspective.
first projects that do not have good review practices like svn or linux kernel both are still using mailing lists may consider a move to pull request like tools.
second practitioners or tool designers may consider adding features associated with higher effectiveness to their code submission tools.
in particular providing information on which version a submission is based on and transferring the base to the newest could prevent conflicts when the reviewers are experimentally merging the commits to verify their correctness.
the communication mechanism similar to github review board that keeps the discussions related to a contribution in single track along with the additional features such as view and notification are likely to help participants focus their attention on the nature of the change.
it s also worth to note that the utilization of social features presented by github may help attract and sustain participation.
the rest of the paper is organized as following.
we introduce background and review related work in section and the methodology in section and section reports the results.
we discuss the limitations of this work in section and conclude in section .
.
background and related work in software development usually a shared central version control repository is set to manage the code and an experienced group of developers control write access to this repository.
to keep high quality of the codebase the code contribution practices tend to adhere to a protocol as illustrated in figure a contributor makes and submits code before any changes are applied to the shared repository i.e.
committed the code must receive positive reviews and be approved by the project maintainers.
this review then commit rtc approach is the most common practice of code contribution in floss projects.
in this study we only consider contributions using rtc channel.
we introduce the evolution of the supporting tools in section .
and review related studies in section .
.
.
evolution of code contribution tools the code contribution tools have evolved from traditional patch based tools such as mailing lists e.g.
mailman and figure code contribution process.
issue trackers e.g.
bugzilla to modern pull request based tools e.g.
github pull request system .
a code contribution is a patch attached to an email or an issue report or a set of commits encapsulated in a pull request.
.
.
patch based tools the mailing list and issue tracker which were originally designed for communication and task management respectively were the first introduced by floss projects to manage code contributions.
for example linux kernel uses its mailing lists and mozilla uses its issue tracker .
in mailing lists the process begins with an author creating a patch a change of the codebase broadcasting to the potentially interested individuals via an email while in issue trackers the patches are published with issues.
after submission the patch may receive no response be ignored or it may be reviewed with feedback sent to the contributor through emails in mailing lists or comments in issue trackers.
the contributor and other developers revise and discuss the patch until it is ultimately accepted or rejected .
.
.
pull request based tools after the pull request mechanism for distributed version control system dvcs was introduced on collaboration platforms e.g.
github1 bitbucket2 gitlab3 etc.
at the time of this study many github floss projects are using pull request systems for code contribution e.g.
rails jquery etc.
in a pull request system users fork which is know as clone in dvcs the central repository of a project.
that allows users to experiment on their own copy of the repository without affecting the original project i.e.
the central repository .
when a set of changes are ready to be submitted to the central repository they submit a pull request which specifies a local branch with the changes to be merged with a branch in the central repository.
project s core team members are responsible for reviewing the changes and merging them to the project s branches.
.
related studies there are many studies investigating the code contribution practice from various aspects including the participation quality assurance review interval and contribution acceptance.
participation.
asundi et al.
conducted a case study on five floss projects that either use mailing lists or issue trackers for code contribution.
the study compared the extent of code inspection participation of core developers among the projects and found it varying among projects.
nurolahzade et al.
studied patch review on bugzilla of mozilla firefox and highlighted that peer developers play 872github repository lighthouse repository literature contribution records of projects using pull request systems mailing list observationsissue tracker observations pull request system observations cross project study within project study metrics on effort time activeness of code contribution contribution records of projects using issue trackers of rails figure study design.
supporting role by offering insights and ideas that help create more quality patches.
rigby et al.
investigated the mechanisms and behaviours that developers use to find code changes they are competent to review and explored how stakeholders interact with one another during the review process.
quality assurance.
mockus et al.
investigated the number of defects found in formal code inspection and found that the inspection team size the number of sessions and the sequence of the inspection steps do not affect defects detection.
rigby et al.
also found the number of reviewers increase the number of defects found in mailing list based review.
mcintosh et al.
studied the impact of code review coverage and code review participation on software quality with three gerrit based projects and found that both of them share a significant link with software quality in terms of number of post release defects.
review interval.
rigby et al.
studied the code inspections on mailing list of six floss projects exploring how participation of code inspection experience and expertise of the authors and reviewers churn and change complexity of the patches impact the review interval.
contribution acceptance.
wei gerber et al.
found that small patch has a higher chance to be accepted in a study on two floss projects.
jiang et al.
inspected the patch acceptance of linux kernel project and found that experience of developers number of affected subsystems and number of requested reviewers relevant.
bosu et al.
investigated the impact of developer reputation on code review acceptance in eight floss projects which use gerrit and observed that the core developers receive quicker first feedback on their review request complete the review process in shorter time and are more likely to have their code changes accepted into the project codebase.
recently gousios et al.
conducted a study of the github pull requests usage within github projects and inspected effects of a number of features on the acceptance of a pull request including characteristics of the pull request project and developer.
evolution of tools from mailing lists to pull request systems suggests that modern tools may improve the code contribution practice.
for example projects migrate to github for team collaboration in commercial context .
however in floss the question of whether or not the changes of tools brought the changes in code contribution effectiveness remains open.
in this study we aim to evaluate the difference in effectiveness of patch based and pull request based tools and to shed more light on the potential ways to make the contribution process efficient.
.
methodology we describe how the study is designed in section .
.
we introduce the studied projects in section .
and the used metrics in section .
.
we present the research questions in section .
.
.
study design we synthesize the results of published papers and a new investigation of four github projects to understand the differences of code contribution practice for different tools.
figure shows the design framework of this study.
first we borrow metrics for analyzing contribution practice from literature as detailed in section .
.
the value of replicating software engineering experiments has been highlighted by many researchers .
by reusing the published metrics and the results on patch based tools in the literature we are able to efficiently and effectively study the differences between code contribution practices using patchbased and pull request based tools.
second based on available resources we conduct two substudies to address the internal and external validity concerns of empirical studies within project study where we investigate the rails project which migrated from an issue tracker to the github pull request system.
software development is complicated and associated with many factors.
the within project study ensures that the project context is approximately constant during the studied time periods such as the project domain culture leaders project size and review policy.
we choose to study rails for reasons explained in section .
.
.
cross project study where we compare a number of classic projects that use patch based tools and pull request based tools respectively.
in particular we gather results of eight mailing list based projects from the published studies and retrieve the contribution history of four github projects that use pull request systems and measure their effectiveness using published metrics.
.
projects table presents an overview of the projects used in this study.
in the following two sections we elaborate on the nature of projects and data extraction for within and crossproject studies respectively.
.
.
within project study the rails project is a web application framework based on ruby.
it was migrated from an issue tracker lighthouse4 to the github pull request system in september .
we choose rails for two reasons.
first rails is a popular project on github with its code contribution practices that may be typical for the github projects.
second none of the mailing list based projects studied in literature such as have migrated to pull request based tools.
the retrieval of rails pull request data is detailed in section .
.
.
for the issue tracker data of rails before september we download the html pages and attachments of the issues from the lighthouse archive.
for each patch we extract the submitter and submission time the operator who changes the status of the issue and operation time and the commenter and comment time.
rails had been using lighthouse since may until september .
considering the instability in the transition period 873table studied projects project domain sloc period tool ref apache web sever40297219962005 mailing list svnversion control30052720032008 linuxos995070320052008 freebsd kdeos gui649403420022008 gnome pythonprogram language postgres database railsweb app framework1723052011.
.6pull request system .
.6issue tracker .
.6pull request system jqueryjavascript library646922011.
.
pull request system ppsspppsp emulator2017852012.
.
rustprogramming language2160412011.
.
mean sloc in the studied period.
we skip three months before september and include the patches published within two years i.e.
between june and june .
similarly we include pull requests submitted within another two years starting from one year after the end of using the issue tracker i.e.
between june to june .
.
.
cross project study as shown in table the eight projects using mailing lists are retrieved from previous two papers .
one covers three and the other covers six the apache project was studied in both papers.
we select four projects using pull request systems from github.
they are rails jquery ppsspp and rust representing different application domains scale and popularity.
jquery is a small javascript library mainly used for building dynamic web pages ppsspp is a virtual emulator of sony play station portable and rust is a programming language which targets at running fast preventing crashes and eliminating data races.
among the four projects rust is the biggest with 210k sloc followed by ppsspp and rails with 200k and 170k sloc respectively and jquery with 64k sloc is the smallest.
rails and jquery are popular on github ranking among the top of all the github repositories in terms of number of forks and stars 20k stars 9k forks when this study is conducted while rust has 10k stars 2k forks and ppssp is somewhat less popular with .6k stars and forks.
we locate the primary repositories of the four github projects rails rails5for rails jquery jquery6for jquery hrydgard ppsspp7for ppsspp and rust lang rust8for rust and retrieve their code contribution data through github for each repository we obtain issues pull requests are combined with issues in the api issue comments pull request comments review comments these comments are directly attached to diffsnippets which are separated from the pull request comments in github api comments these comments are attached in the commit view outside pull request view which are also separated from the previous two types of comments in the api issue events pull request events which include open subscribe merge close etc.
pull request commits and all the commits on master branch of the central repository.
for each pull request we extract the submitter and submission time the operator who merged or closed the pull request and operation time and the commenter and comment time as what we do for the patches on the rails issue tracker.
before the version .
of github pull request system was released it did not support discussions10.
therefore for rails jquery and rust we set a study period from april about half a year after the version .
was released to june half a year prior to when the data were retrieved for our study.
because ppsspp started in november we retrieve its data from december to june .
the youth of pull request systems restrains us from using the same studied periods as the prior studies.
.
metrics borrowing metrics from existing literature we quantify contribution effectiveness from three aspects contribution effort time interval and contribution activeness.
.
.
effort accepted ignored to what extent the contribution effort is not wasted represents one important aspect of the contribution effectiveness.
we borrow the metric of contribution acceptance rate from bird et al.
s paper .
to highlight the wasted effort we add a new metric contribution ignore rate.
m1.
accept rate of contributions the ratio of accepted contributions out of all the contributions.
many participants in floss communities are volunteers spending their limited spare time working for the projects.
the more contributions are accepted the less effort of making and reviewing the code changes is wasted for both contributors and reviewers.
bird et al.
detected accepted patches by searching the central repository and finding the file version that applied the patch in the mailing lists.
we identify accepted pull requests through checking whether there is a merged event or a closed event associated with commits integrated in the central repositories.
this approach was used by gousios et al.
and they also analysed the comments to detect merged pull requests that are merged informally which leads to an average accept rate of .
.
because we do not incorporate this strategy the number of merged pull requests detected by us should be a lower bound.
the detection of accepted patches in issue trackers is relatively simple.
if the status of the issue attaching the patch is changed to committed orresolved we label the patch as accepted.
m1.
ignore rate of contributions the ratio of ignored contributions that don t receive any response out of all the contributions.
this measure may represent the attention for peripheral contributors from the community sug9 874gesting an appreciation for contributors effort of making the code changes and therefore motivating contributors to sustain in the project .
the attention could help the contributors find out problems with their contributions learn project skills and continue getting involved in the community and may eventually have their contributions accepted.
in rigby et al.
s study if a patch posted to the mailing list did not receive response from other developers it was considered as ignored.
similarly we consider a pull request or a patch in issue report which neither received at least one comment from others nor has the status changed as ignored.
.
.
time interval time is a common concern for contribution process because it may affect project development course and contributors enthusiasm.
borrowing the metrics from rigby et al.
s study we use the time until the first response and final resolution to demonstrate the efficiency of the community to process the contribution.
m2.
time until first response the time span from the submission of the contribution to the first response to the contribution.
quick response may make contributors feel appreciated and help motivate contributors to take more active participation in the project .
rails employed rails bot11 in which implies the need for rapid response in practice.
we calculate the response time from the submission of a contribution to the first comment or first issue status operation or a pull request event introduced in section .
.
whichever occurred earlier.
m2.
time until resolution the time span from the submission of the contribution to the final comment or resolution accepted or rejected of the contribution ignored contributions are filtered .
the resolve time determines how fast the acceptable contributions can be merged and delivered to the users.
fast resolution may also reduce waste of time for failed rejected contributions.
we calculate the resolve time as the time spent from submission to the final comment of a contribution.
because there are spam comments on rails issue tracker which falsely extend the lead time in the within project comparison we calculate resolve time of a contribution as the time spent from submission to the final issue or pull request status operation stopped at committed resolved merged closed of a contribution.
it should be noted that the study of rigby et al.
did not consider multiple versions of a single patch .
the resolve time for a contribution extracted from their study may be a part of the whole process time i.e.
lower than actual value.
.
.
contribution activeness it is important to have a wide participation in floss projects which may be the powerful engine supporting the high efficiency of code development .
evidences show that effective process increases user interest in contributing to floss projects .
a tool that improves process may appeal to developers and promote them to make contributions.
we use the number of contributions a metric to measure the contribution activeness to indicate whether or not developers prefer to use the tool to contribute.
m3.
contribution frequency number of contributions per month.
as found by rigby et al.
project size is associ11 contributions accepted in rails toolssubmissions fisher s exact test all accepted ratio p value odds ratio issue tracker2574 .
.
.
pull request system6014 .
ated with the frequency of contributions.
therefore in our measurement we adjust it with source lines of code sloc of the project.
because sloc changes while project evolves we retrieve the sloc of each project in december of each year it is each month for the within project comparison of rails in the studied period from the openhub12and calculate the mean value because there is no sloc data for rust on openhub we download its repository and count sloc each year with the tool of cloc13 .
.
research questions targeting the research question rq0 we measure the effectiveness of code contribution from three aspects effort time and activeness and derive three specific research questions as follows rq is less contribution effort wasted when using pull request systems?
rq are contributions processed faster using pull request systems?
rq are contributions more frequent using pull request systems?
.
results we answer the research questions through the analysis of within and cross project respectively.
.
within project comparison from the issue tracker to the pull request system rails shows a minor variation of accept rate and ignore rate.
however both the response and resolve time are reduced over and the number of contributions are doubled.
accept rate of contributions m1.
.
table shows that .
of the contributions were accepted when rails was using the pull request system a bit higher than .
when it was using the issue tracker.
we employ fisher s exact test to quantify the differences14.
in the test each observation is a contribution characterized by whether or not it is a pull request and whether or not it is accepted.
the test produces a p value with the odds ratio of .
.
although there is a statistically significant improvement of accept rate in the pull request system the practical importance odds ratio is modest in magnitude.
ignore rate of contributions m1.
.
the ignore rates of the two periods within rails presented in table .
and .
are both quite small.
it appears that both the pull request system and the issue tracker perform well on 14fisher s exact test is used to examine the significance of the association between two kinds of classifications .
we conduct the test using r 875table contributions ignored in rails toolssubmissions fisher s exact test all ignored ratio p value odds ratio issue tracker2574 .
.
.
pull request system6014 .
table first response time in rails toolshours median p value of wilcoxon rank sum testmedian decrease issue tracker30.
.
pull request system0.
stimulating awareness of code contribution submissions.
we employ fisher s exact test to quantify the differences of the ignore rates and obtain a p value higher than the significance level of .
that suggests an insignificant difference between the chance of a contribution getting ignored in pull request systems and the chance in issue trackers.
time until first response m2.
.
group fr.it and fr.pr in figure show the boxplotof the first response time in the the issue tracker and the pull request system.
the decrease from the issue tracker to the pull request system is dramatic.
in table we can see that the median value of first response time in the pull request system decreases .
compared to that in the issue tracker.
we quantify their differences through wilcoxon rank sum test15 using r where each observation is the first response time of a contribution.
the result verifies that rails responds faster to the contributions using the pull request system than when it used the issue tracker.
time until resolution m2.
.
group rs in figure shows the boxplot of resolve time where the median time for the pull request system is .
lower than for the issue tracker.
we quantify the difference through wilcoxon rank sum test and find statistically significant difference see table .
it appears the contribution resolve time is reduced by using the pull request system we therefore fit linear regression models to verify the impact.
we start with the model log resolve time isp r each observation in it is a submitted contribution patch or pull request .
the response is the resolve time and the predictors is whether the contribution is made via a pull request system.
15wilcoxon rank sum test is used to examine the significance that a particular population tends to have larger values than the other .
table resolve time in rails toolshours median p value of wilcoxon rank sum testmedian decrease issue tracker390.
.
pull request system5.
rs.it rs.pr fr.it fr.pr 1e 1e 1e 1e time hour group rs and group fr indicate resolve and rst response time respectively.
it and pr are short for issue tracker and pull request system respectively.
the time axis is in log scale.
figure time intervals in rails.
the fitting results of model shows the use of the pull request system is significantly correlated with the resolve time.
the factors that influence the resolve time of contributions have been previously investigated.
we therefore add the predictors that have been widely considered e.g.
and fit a more complicated model log resolve time log churn log reviewers log cexperience log rexperience log cexpertice log rexpertice isp r the predictors are defined as following.
churn of the contribution churn the number of added and removed lines of code in the contribution.
this is a common measure in the literature and several studies have found that the contributions with small change size would have a higher chance to be accepted.
experience of contributor cexperience and reviewer rexperience the time between a participant s first message in tool and the time of the submission.
expertise of contributor cexpertice and reviewer rexpertice the adjusted amount of previous submissions or reviews done by a participant.
the adjustment is detailed in rigby et al.
s paper .
number of reviewers reviewers the number of participants who comment or manage the contribution except for its contributor.
the level of reviewer participation is found to have the largest impact on review time .
the fitting results of model are shown in table .
the coefficients of ispr whether the submission is a pull request is significant at .
level.
its negative sign means that use of the pull request system decreases the resolve time.
the analysis of variance shows that of the deviance is explained by isprin this model which ranks in the middle among all the predictors.
the variations from the previous studies are discussed in section .
.
contribution frequency m3.
.
the number of monthly contributions adjusted for codebase size increases as rails moves from the issue tracker to the pull request system as 876table model for resolve time in rails model est std.err.
p value intcpt .
.
ispr .
.
adjusted r square .
model est std.err.
p value intcpt .
.
ispr .
.
log churn .
.
.
log reviewers .
.
log cexperience .
.
.
log rexperience .
.
.
log cexpertise .
.
log rexpertise .
.
adjusted r square .
table number of monthly contributions in rails toolsaverage number sloc adjusted p value of wilcoxon rank sum testaveragely increase issue tracker107.
.
pull request system250.
shown in figure .
table presents the normalized number of monthly contributions in rails.
the number in pull request system period is double of that in issue tracker period.
the wilcoxon rank sum test where each observation is the number of contributions adjusted for sloc per month produces the p value indicating that the difference is statistically significant.
.
cross project comparison compared to mailing lists pull request systems double the accept rate and decreases ignore rate around .
both the response and resolve time in pull request systems are less than half of that in mailing lists.
the number of adjusted contributions is increased by a magnitude.
it s worth noting not all of the mailing list sources appear in each comparison because not all the compared measures were reported in the papers from which we obtain them.
accept rate of contributions m1.
.
table shows the accept rates of projects that use mailing lists and pull request systems respectively.
less than half of the contributions are accepted in all the mailing list based projects with postgres having the highest accept rate of .
.
three out of four projects using pull request systems have higher ac00.
.
.
.
.
.
months of using the pull request system number of contributions sloc adjusted months of using the issue tracker issue tracker pull request system figure monthly contributions of rails.table contributions accepted across projects projects toolssubmissionsref all accepted ratio apache mailing list4267 .
python .
postgres .
rails pull request system9933 .
jquery .
ppsspp .
rust .
p value odds ratio of fisher s exact test .
table contributions ignored across multiple projects projects toolssubmissionsref all ignored ratio apache mailing list4.6k .2k .
svn .9k .1k .
linux 50k 22k freebsd 73k 48k .
kde 22k 14k .
gnome 12k 4k .
rails pull request system9933 .
jquery .
ppsspp .
rust .
p value odds ratio of fisher s exact test .
cept rates than postgres except for jquery with a .
rate.
we quantify the differences with fisher s exact test where each observation is a contribution characterized by whether or not it is a pull request and whether or not it is accepted.
the resulting p value is statistically significant with the odds ratio of .
favoring accept rates in pull request systems over accept rates in mailing lists.
ignore rate of contributions m1.
.
for ignored contributions the performance difference between tools is bigger than that of the within project study see table .
only a small portion .
to .
of contributions are ignored in pull request based projects while ignore rates of mailing list based projects are much higher except for svn .
.
there is a large variation among projects with mailing lists.
svn has very low rates while more than of the contributions are ignored in freebsd and kde.
meanwhile svn has .
even in mailing lists while jquery has .
in pull request systems.
the exceptional performance of mailing lists in svn may be at least partially attributed to a very strong discipline of the team to follow community policy of reviewing all published contributions .
fisher s exact test yields p value indicating statistical significance of the impact.
the odds ratio of shows that magnitude of the impact is large.
time until first response m2.
.
third column in table shows the median first response time of contributions in the projects.
the median first response time in projects using mailing lists ranges from .
to .
hours and for pull request systems it ranges from .
to .
.
the slowest and fastest of pull request based projects are faster than the two of mailing list based project respectively.
we quantify the difference through fisher s exact test.
because only the shortest and longest median first response times of mailing list based projects those without prefix in ta877table first response and resolve time across multiple projects projects toolfirst response time hour resolve time hour ref apache mailing list .
svn linux .
freebsd kde gnome .
rails pull request system0.
.
jquery .
.
ppsspp .
.
rust .
.
fisher s exact testp value odds ratio .55p value odds ratio .
all the values are median.
numbers with prefix are estimated according to the figure in .
ble are given in rigby et al.
s paper we select linux kernel which has the shortest time as benchmark to test the pull request based projects.
in the test each observation is the first response time of a contribution characterized by whether it is made via a pull request system and whether it is lower than the median first response time of linux kernel.
the p value is lower than i.e.
the difference is significant.
time until resolution m2.
.
the forth column of table presents the median16resolve time of contributions in the projects.
the median resolve time in the projects using mailing lists ranges from to hours.
for pullrequest based projects the fastest is ppsspp where it takes only .
hours in median and the slowest jquery .
hours in median is still faster than the mailing list based svn.
we quantify the difference through fisher s exact test.
similar to the response time only the shortest and longest median resolve times of mailing list based projects those without prefix in table are given in we use the fastest one freebsd as benchmark to test the pull requestbased projects.
in the test each observation is the resolve time of a contribution and each contribution is characterized by whether it is a pull request and whether it has lower than the median resolve time of freebsd.
the resulting pvalue is lower than suggesting the difference is significant.
contribution frequency m3.
.
table shows the average number of monthly contributions adjusted for codebase size.
all the numbers of mailing list based projects are higher than those of pull request based projects.
we quantify the difference through wilcoxon rank sum test where each observation is the adjusted average number of monthly contributions to a project.
the p value of the test is lower than the significance level of .
therefore we accept the alternative hypothesis that pull request systems are associated with more contributions than mailing lists.
so far we obtain positive answers to rq2 and rq3 but no firm answer to rq1.
in summary the answer to rq0 is that contributions are processed faster and participants contribute more frequently in pull request based tools.
the 16we use median because the time until resolution is heavily skewed and mean is not a good summary statistic for such data.table number of monthly contributions across multiple projects tools projectsnumber of contributionsref all months sloc month mailing listapache svn linux50000 freebsd73000 kde22000 gnome12000 pull request systemrails jquery ppsspp rust p value of wilcoxon rank sum test .
all the values are mean and adjusted with divided by the codebase size in terms of average sloc in the studied period.
github pull request system showed a substantial improvement on accept and ignore rates in cross project comparison but not in the within project comparison.
these variations in the effort reduction may be most simply explained by the differences in contribution practices the projects employ and may be less affected by the type of tool used for code contribution.
for example older projects with exception of svn may be used to the low accept and high ignore rates for historic reasons while newer projects may be more tolerant.
the accept rates may be more likely to be underestimated in mailing list based projects than in pull request based projects.
.
discussion we discuss the differences of our findings from previous studies in section .
and the insights of using pull request systems in section .
.
.
differences from previous findings we model resolve time with predictors used in the existing literature and with an additional consideration on tool type.
we discovered several interesting exceptions and variations.
compared to earlier results the significance and coefficient sign of some predictors flip over in our results.
in particular the significance of code churn and reviewers experience disappears while it emerges for reviewers expertise.
the sign of contributors experience changes from positive to negative.
we speculate that pull request systems may simplify the review of complex contributions and make code churn less impact the resolve time.
these may be instances of the theory that social media has dramatically changed the landscape of software engineering challenging some old assumptions about how developers learn and work with one another .
we develop conjectures for the variations in .
.
in the survey conducted by gousios et al.
respondents told that reaching consensus of the decision on a contribution was challenging and the process could be delayed.
however we find that pull request systems reduce the time spent.
the respondents did not mention how pull request systems perform compared to other tools it would be interesting to make further investigation with developers who have experience in using different tools.
878we reproduced the analysis used by gousios et al.
to model the chance of a contribution getting accepted in rails.
we didn t find the most relevant factor the number of total commits on files touched by the patch or pull request over three months before the submission time to be significant and that may require further investigation.
.
insights of using pull request systems .
.
advanced features of pull request systems integrating with dvcs .
the pull request systems are built on the distributed version control system dvcs like git.
the branch model of dvcs is considered to be efficient and help participants save effort .
contributors could rebase their branches to relieve the core team members from solving the merge conflicts.
a contribution through a pull request system is a sequence of commits on the contributor s branch which can be easily merged into the target branch in the central repository.
the update of a contribution is simple what the contributor needs to do is making new commits on the branch in his own fork.
the pull request systems close relationship with codebase may also lead to quick response.
when maintainers are working on the central codebase they will immediately find new contributions and give a quick response.
if there is no conflict the maintainer can merge the accepted submission through just clicking a button.
track mechanism .
the pull request systems automatically track the contributions.
in the track mechanism contributions are tracked independently and participants can easily find the new submitted or updated contributions through key words status etc.
while mailing lists broadcast contributions i.e.
users are passively receiving emails and core developers may receive as many as emails per day .
participants have to make strategies to filter the mails themselves to avoid being overwhelmed.
if the filtering is not well handled they may miss what they are interested in or spend a long time to discover them.
meanwhile the states e.g.
open resolve of the contributions benefit awareness that is considered important in the distributed tasks .
for example the open pull requests always make developers aware that there are still contributions not resolved.
however contributions via mailing lists are not traced with a state and participants have to remember the unresolved ones.
naturally some contributions may remain forgotten and ignored.
the insignificant difference between pull request systems and issue trackers on ignore rate indicates that pull request systems and issue trackers may be more adept at keeping track of submissions.
as the primary function of an issue tracker is to keep track of things it is reasonable that it does well as a pull request system in this regard.
review board .
the pull request systems review board has two modules the code viewer and the review list .
the diffandcomment functionalities of the code viewerclearly present the code changes with colored lines e.g.
red for deletion and green for addition.
that could promote the communication between submitters and reviewers to improve the code quality iteratively and lead to the acceptance .
comments can be attached on code lines in diffview.
it associates the review comment with specific code to make the discussion convenient and efficient.
while mailing lists and issue trackers do not have such functions.thereview list offers more convenient communications for a code submission .
first most of the discussions of one contribution are recorded in single track which simplifies the review of previous discussions.
second any contributor can subscribe to a contribution to receive notifications.
this makes followers aware of news of a contribution.
third the states of contributions can remind the followers the in processing contributions.
however the communications around a contribution via mailing list are scattered into different mails threads and even lists .
it s hard for the followers to recall the ongoing contributions and review the discussion thread each time a change is made to the contribution.
therefore the iteration of contributions via pull request systems are likely to be more efficient.
it s worth noting that the convenience of communication may make the inspection outcome more complex than simple acceptance or rejection .
both core project members and third party stakeholders sometimes implemented alternative solutions to address the issues over both the appropriateness of the problem that the submitter attempted to solve and the correctness of the implemented solution.
.
.
influence of social platform we observed a statistically significant increase of contributions for projects using pull request systems.
the pull request system we studied is embedded in the popular platform github.
in addition to integrating the advanced features of the pull request system being a social collaboration platform itself github may substantially contribute to the broader participation.
integration.
github integrates code submission issue tacking and review discussion together helping simplify the pull request contribution process and therefore may stimulate the participation.
the publication of a contribution can be easily achieved within the system through clicking thenew pull request button and for maintainer if there is no conflict she merges the accepted submission through clicking the merge button.
while in issue trackers and mailing lists contributors have to follow guidances to make a patch and publish the patch by sending an email or reporting commenting an issue.
meanwhile the authorship of contributions through pull requests on dvcs is kept by default and is easy to trace.
that helps to build a contributor s reputation and therefore may motivate contributors to stay and continue their contributions.
while in issue trackers and mailing lists the authorship has to be manually maintained and is easy to get lost in the codebase.
some automatic technologies that have been integrated into github may also facilitate the contribution process.
for example the continuous integration system travis ci is found to increase software quality and team productivity .
collaboration.
github is a fast growing software development platform17.
it promotes social coding with a number of features which are similar to those of the social network sites such as twitter.
the users can follow others star repositories watch a repositories etc.
the transparency of such social activities can help people find what they are interested in and participate .
moreover the social network on github is found to connect the projects with common participants .
as a result github provides the 17it has been used for other purpose e.g.
education data sharing writing books etc.
879hosted projects a large pool of potential contributors and is likely to facilitate the contribution participation.
.
limitations the way measures are collected the confounding factors that may not be considered and the generalization of the results are primary limitations of this study.
measures .
first the measures of contributions using patch based and pull request based tools in different epochs may introduce bias as the practice may evolve over time.
this limitation is unavoidable as discussed at the end of section .
.
.
second in mailing lists different versions of a patch may scatter into multiple mails and mail threads.
in the study of bird et al.
related patch versions are not grouped and each patch is split by files therefore the number of contributions is higher than actual.
in this study we only use the accept rate which is relative value and may not be sensitive to the absolute number.
third both related papers and our analysis may suffer from the method of detecting accepted submissions.
there could be accepted submission being detected as rejected false negative and rejected submission being identified as accepted false positive .
fourth the contributions through pull request systems may be made by mistake and closed by the authors themselves without external response.
the metric defined in the literature would incorrectly regard such contributions as ignored.
in this paper we filter out the pull requests closed by their authors within one hour.
finally the within project study is conducted between the issue tracker and the pull request system rather than mailing lists and pull request systems because rails switched from the issue tracker to the pull request system and we do not have other projects in our sample where a switch between mailing lists and pull request systems has occurred.
confounding factors .
software development is a knowledgeintensive activity with a large number of potentially confounding factors and this makes it difficult or impossible to discern the impact of code contribution tools.
we address the challenges from a study design including a withinproject comparison where the project context is controlled and a cross project comparison where the external validity is considered.
we spend effort on reusing existing metrics and reproducing published analysis in order to make fair comparisons between different tools.
generalization .
in the comparison of tools the mailinglist based projects are borrowed from previous papers and the pull request based projects are selected from github covering a variation of domain and scale.
they may not be able to represent all the floss projects but they cover a relatively large scope of application domains and project size.
moreover the comparison between issue trackers and pull request systems is only conducted with the data of one project rails because of the availability of projects that changed their tools and this may restrict the generalization of our findings.
.
conclusions build software better together.
is the slogan of github meaning that it aims for a better collaboration in software development through implementing the distributed fork pull request model which makes contributions easier to make evaluate improve and integrate.
in this study we investi gate the effectiveness of floss code contribution practice through the github pull request system and compare it to patch based tools.
we measure tool effectiveness via the effort time and activeness and compare within a project that changed from an issue tracker to an pull request system and across projects that use mailing lists and pull request systems respectively.
the results show that modern tools such as pull request systems have a lower processing time and attract more participation.
we argue that these improvements are at least partially attributed to advanced features of pull request systems.
in particular the coupling with code repository issue tracking and review discussion enables easier participation and better traceability.
this in turn helps reduce time and effort.
furthermore the social features enhanced by the collaboration platform of github may help attracting new contributors and contributions.
in practice this knowledge may help improve tools and practices for code contribution.
projects using traditional tools may want to add features of pull request systems that are associated with higher contribution effectiveness by plug ins additional modules ect.
practitioners who have already used or intend to move to pull request systems may need to pay more attention to leveraging these features.
pull request systems high efficiency however does not imply that patch based tools should be abandoned.
we observe that good discipline and skills of using traditional patchbased tools may work well too.
for example linux kernel still uses its mailing list to do code inspection even though it has a mirror repository hosted on github.
it provides a guidance of making contribution title prefixed by tags enclosed in square brackets subject summary phrase .
svn has the community norm to have contribution reviewed that appears to be quite effective .
such strategies should not be discounted when trying to improve the effectiveness of code contribution.
although pull request systems have a higher effectiveness they may have weakness that can be improved.
for example some developers think there should be code analysis functionality for quality assurance on the github pull request system some are still unsatisfied with the way github handles notifications .
maintainers find reaching consensus of the decision of a contribution through the pull request comment mechanism and handling the workload imposed by the open submission process of pull request systems to be sometimes challenging .
contributors think the communication within pull requests although effective for discussing low level issues appears to be limited for other types of their communication needs .
in future we intend to conduct a survey with developers who have experience of using different types of tools to improve our understanding of exactly what has been achieved and what challenge of contribution practices are still outstanding.
.