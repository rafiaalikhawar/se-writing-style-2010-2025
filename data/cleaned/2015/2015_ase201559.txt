region and effect inference for safe parallelism alexandros tzannes stephen t. heumann lamyaa eloussi mohsen v akilian vikram s. adve univ.
of illinois at urbana champaign dept.
of computer science atzannes heumann1 eloussi2 mvakili2 vadve illinois.edumichael han autodesk inc. michael.han autodesk.com abstract in this paper we present the first full regionsand effects inference algorithm for explicitly parallel fork join programs.
we infer annotations inspired by deterministic paralleljava dpj for a type safe subset of c .
we chose the dpjannotations because they give the strongest safety guarantees of any existing concurrency checking approach we know of staticor dynamic and it is also the most expressive static checking system we know of that gives strong safety guarantees.
thisexpressiveness however makes manual annotation difficult and tedious which motivates the need for automatic inference but it also makes the inference problem very challenging the codemay use region polymorphism imperative updates with complex aliasing arbitrary recursion hierarchical region specifications and wildcard elements to describe potentially infinite sets ofregions.
we express the inference as a constraint satisfactionproblem and develop implement and evaluate an algorithm for solving it.
the region and effect annotations inferred by the algorithm constitute a checkable proof of safe parallelism and itcan be recorded both for documentation and for fast and modularsafety checking.
i. i ntroduction in imperative parallel programs the overwhelmingly many possible dynamic interleavings of instructions make it difficult for programmers to reason about the correctness of theirprogram and the non deterministic or unstable nature ofdynamic execution schedules makes it challenging to exposeor reproduce parallelism bugs .
many dynamic and staticapproaches have been proposed to address these challenges.dynamic approaches have been devised to address the issue but all incur substantial performance overhead and some also require specialized hardware.
static approaches havezero runtime performance overhead but suffer from limitedexpressiveness and sometimes impose a heavy annotation bur den on programmers.
ideally we would like to have a highlyexpressive static checking approach with strong guarantees and minimal annotation burden on the programmer.
the strongest guarantees we know of in any parallelism checking approach static ordynamic are provided by deterministic parallel java dpj .
for fork join parallel programs dpj guarantees data race freedom strong atomicity determinism by default and compositional reasoning for de terministic and non deterministic parallel components usingonly modular static checking cf.
section ii .
using dpj however can impose a significant burden every variable parameter and field must be annotated with one or moreregion arguments specifying where it lives and or points to every method must be annotated with an effect summaryspecifying which regions the method may read or write every type is optionally annotated with one or more region parameters allowing the aforementioned annotations to takeparametric forms potentially allowing to distinguish betweendifferent dynamic instances of objects of the same type.
inshort manually annotating the code involves conceptuallysophisticated program annotations which are likely to be toocomplex for general purpose programmers to use in practice.
in this paper we present the first regions and effects inference algorithm dpj annotations.
in particular a pro grammer only has to parallelize a program using fork joinparallelism and the algorithm infers the annotations neededfor the dpj checker to enforce all its guarantees.
the currentimplementation of our algorithm has limitations that makesome manual annotations necessary but we will argue that allof them can be inferred using the same principles as we haveused for the rest of the annotations and it is merely a matter of implementation effort to support the necessary extensions.
the expressiveness and complexity of dpj s annotations makes inference much more challenging than similar but less expressive static approaches for safe parallelism such as type qualifier approaches cf.
section v .
moreover unlike other approaches that require programmer involvement when multi ple solutions are possible our annotation generation phase willautomatically find a satisfying set of annotations if one exists and it can optionally be queried for alternate solutions.
in orderto allow programmers to guide the inference algorithm whennecessary we support partially annotated code our inferencemust then find a solution that honors existing annotations.
v akilian et al.
present an algorithm for inferring the dpj effect annotations given the region annotations.
this is insuffi cient to make dpj practical because the region annotations which the programmer must still provide are significantlymore challenging to select than the effect ones and they are still too numerous.
also in terms of the inference algorithm effect inference has to solve only effect constraints with allregions therein completely specified i.e.
no region variables only effect variables whereas our inference has three typesof constraints to solve and those constraints include both effectand region variables to be determined.
in short the inferenceproblem we are solving is substantially more challenging.
we tackle the complexity of inferring region and effect annotations by proceeding in four phases cf.
section iii .
first we introduce region and effect variables at all syntactic locations where manual annotations are missing.
second w e parse method declarations and their bodies to generate con straints according to the rules of the region and effect annotation language.
third we process the generated constraints to simplify them and to infer simpler constraints that effectively prune the search space.
f ourth we instantiate all region and effect variables produced in the first phase with values thatsatisfy the constraints output by the third phase.
the third phase which simplifies the constraints generated during the second phase is one of our core contributions.
30th ieee acm international conference on automated software engineering .
ieee its role is to prune the solution space by inferring properties of region variables and by simplifying the complexconstraints produced by the previous phase without making the set of constraints unsatisfiable sound complete .
at its core are two lemmas and two theorems that transformsets of constraints matching a pattern into sets of constraintsthat are simpler to solve.
the first theorem applies to caseswhere object distinction is necessary because two objects areupdated in parallel and the second one applies to recursiveupdates.
section iii c explains the theorems intuitively andour technical report provides the formal proofs.
our contributions are a new algorithm that infers both region and effect annotations to statically guarantee that aparallel code is safe this algorithm also works with partiallyannotated code allowing the programmer to control multipleaspects of the parallelism checking and allowing to modularizeinference by providing manual annotations at module boundaries section iii .
formalized constraint generation rules for an object oriented core language section iii b constraint simplification rules that prune the solution space and greatly reduce time to solution and formal proofs that thesesimplification rules are sound and complete section iii c a prototype implementation of our inference algorithm for a type safe subset of c and an evaluation of it thatdemonstrates the feasibility of the inference.
ii.
b ackground this section gives the needed background on the dpj annotations to be inferred.
a complete presentation of dpj canbe found in .
figure gives a first running example.
1class point region p region x y double x in p x double y in p y void setx int v writes p x x v void sety int v writes p y y v void setxy int vx int vy writes p cobegin setx vx sety vy region foo void foo writes foo region r1 r2 point foo r1 p1 new point point foo r2 p2 new point i n tx effects on locals y are ignored cobegin p1.setxy y x writes foo r1 p2.setxy x y writes foo r2 fig.
.
example of annotated point class effects in comments are computed by the checker region names region parameters and rpls.
to reason about memory accesses and aliasing at an appropriate granularity and level of abstraction dpj groups memory locationsinto regions .
regions are logical not necessarily contiguous sets of memory locations.
line declares region names x andy which may be used in region arguments for types as we will describe below.
line indicates that the class takesa region parameter p which allows to distinguish between different dynamic instances of objects as we will see later.the field xis declared to be in region p x which is the region of field xof a particular instance of a point object.
definition rpl a region path list rpl is a colonseparated list of region parameters region names and wild cards that represents a set of regions e.g.
x p x p x .
the only wildcard we consider in this paper is which stands for zero or more colon separated rpl elements.
definition fully specified rpl an rpl is fully specified if and only if it does not contain wildcards.
similarly field yis in region p y which is disjoint from region p x and both are disjoint from regions p x and y .
definition disjointness two rpls are disjoint if they are distinct from the left l or from the right r .
rplsr1andr2are distinct from the left if they are the same in the first nelements they differ in element n and neither contains a in the first n elements.
symmetrically rpls r1andr2are distinct from the right if they are the same in the lastnelements they differ in element n from the end and neither contains a in the last n elements.
rpls allow us to describe nesting of regions which is important for capturing many parallel idioms such as paralleltree traversals parallel divide and conquer algorithms andparallel updates through an array of pointers.
however thesemantics of rpl nesting may be slightly counterintuitive atfirst we say that p xisunderpand write p x p b u t the two rpls describe disjoint regions.
in order to describe a parent region and all the child regions nested under it we append a star to the rpl of the parent region p in our example .
then p xis included in p p x p .
definition inclusion rplr 2includes rpl r1if the set of regions described by r1is a subset of the set of regions described by r2 r1 r2.
for example p includesp p x p y p x etc.
effect summaries.
each method is annotated with an effect summary which must cover the effects of its body.
in this paper we focus on read and write effects and leave other kindsof effects for future work.
we denote with the absence of visible side effects which we call pure effect .
a read effect on an rpl r readsr indicates a read operation on one or more of the regions described by r. similarly a write effect on an rpl r writesr indicates a write operation.
definition coverage effecte 1on rplr1covers effecte2on rplr2 e2r2 e1r1 if and only if e2 e1 andr2 r1 wheree1 e2 reads writes and reads writes .
line of fig.
defines method setx which writes field xand thus has effect summary writes p x. similarly method sety on line writes p y. method setxy calls the previously defined setter methods of the current object and has the declared effect summary writes p which is coarser than needed for illustration purposes.
the effects of thebody are invocations so the static checker fetches the effectsummaries of these methods computes their union writes p x p y and checks that it is covered by writes p .
the dpj checker does not trust effect summary annotations it checks them by inferring the effects of the methodbody using region information for all