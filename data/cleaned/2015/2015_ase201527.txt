static analysis of javascript web applications in the wild via practical dom modeling changhee park kaist changhee.park kaist.ac.krsooncheol won kaist wonsch kaist.ac.krjoonho jin kaist myfriend12 kaist.ac.krsukyoung ryu kaist sryu.cs kaist.ac.kr abstract we present safe wapp an open source static analysis framework for javascript web applications.
it provides a faithful partial model of web application execution environmentsof various browsers based on empirical data from the main webpages of the most popular websites.
a main feature ofsafe wapp is the configurability of dom tree abstraction levels to allow users to adjust a trade off between analysis performanceand precision depending on their applications.
we evaluatesafe wapp on the most popular javascript libraries and the main web pages of the most popular websites in terms of analy sis performance precision and modeling coverage.
additionally as an application of safe wapp we build a bug detector for javascript web applications that uses static analysis results fromsafe wapp .
our bug detector found previously undiscovered bugs including ones from wikipedia.org and amazon.com.
i. i ntroduction javascript was originally developed as a simple scripting language to develop interactive and dynamic web pages but now it is used to construct large web applications with theevolution of web contents.
although javascript is the mostdominant programming language on the web its quirkyfeatures make it difficult to understand behaviors of complexjavascript programs.
many researchers have developed var ious program analysis techniques to alleviate this problem but many of them have focused on analyzing stand alonejavascript programs which is not enough foranalyzing real world web applications.
to analyze javascript web applications in the wild modeling browser environments is critical since javascript programsoften reside in web pages and interact with users and browsersvia events.
however one of the main challenges is that nosingle standard document describes browser environments for mally.
while some commonly used specifications are availableonline their descriptions are huge informal andincomplete and modeling all of them manually is tedious time consuming and error prone.
furthermore non standardand inconsistent behaviors of various browsers complicatemodeling.
while previous approaches presented partial modelsof browser environments selected from several documents theyare not applicable to real world web applications because theysupport only subsets of javascript or limited models of webdocuments .
in this paper we present safe wapp an open source framework that statically analyzes javascript web applications andshow how to extend the existing static analyzer safe to support an extensive model of browser environments.
by so safe wapp extends the applicability of any clientapplications that are built on top of safe from stand alone javascript programs to web applications.
to implement a prac tical model of browser environments we investigated 465popular websites and summarized uses of native javascriptobjects and apis provided by most major web browsers.based on extensive empirical data we design a model ofbrowser environments.
a main feature of safe wapp is the configurability of dom tree abstraction levels in three ways two from the literature and one new which maintainsprecise tree structures of web documents.
we show howdom tree abstraction levels affect analysis performance andprecision with the analysis results of the most popularjavascript libraries and the main web pages of the mostpopular websites.
furthermore we implement a bug detectorcapable of detecting language level bugs as a client applicationof safe wapp and show that it detects previously undiscovered bugs in the main web pages of popular websites.
note that ourapproach is not tied to its base analyzer safe and thus it is applicable to other static analyzers for javascript programs.
the contributions of this paper include the followings we present empirical data from the most popular websites to show the usage of native objects and apis that browsers support.
this data will be helpful to model browser environments practically.
we explain how to extend a static analyzer thatsupports only stand alone javascript programs to theone that supports web applications with a model ofbrowser environments practically.
this approach isapplicable to other static javascript analyzers.
we present safe wapp a framework that statically analyzes real world javascript web applications.
it provides configurable dom tree abstraction models in three levels two existing ones and anew one that captures dom tree structures of webdocuments precisely.
we present experimental resultsabout the effects of dom tree abstraction levels onanalysis results of real world web applications suchas javascript libraries and websites.
to show the usefulness of safe wapp we implement a bug detector as an application of safe wapp and evaluate it on the main web pages of the mostpopular websites.
we found previously undiscovered bugs in wikipedia.org andamazon.com .
we make safe wapp and the bug detector publicly available .
30th ieee acm international conference on automated software engineering .
ieee function setlang lang var uilang navigator.language navigator.userlanguage date new date if uilang.match w lang date.settime date.gettime else date.setfullyear date.getfullyear document.cookie searchlang lang expires date.toutcstring domain location.host fig.
main web page of wikipedia.org along with some javascript code in the page before fixing the bug ii.
m otiv a ting examples this section presents two examples motivating design decisions of safe wapp .
the first example is the bug we found fromwikipedia.org which requires analysis of interactions between javascript and dom apis.
the second example requires precise dom modeling for precise analysis.
first the javascript code of the setlang function in figure is an excerpt from the main web page of wikipediaalso shown in the figure.
a user can select a language in whichsearch results are displayed via the selection button next tothe search box in figure the selected language is english.
when the user changes the selected language to another onevia the button it calls the setlang function.
the intended semantics of setlang is as follows.
if the selected language is different from the default language of the browser in use the function saves the information in a cookie on the user scomputer and keeps it for a year otherwise it simply discardscookies if any.
when the user visits wikipedia next time if thecookie keeps the previously selected language the site uses itto set the default language in the selection button.
otherwise it sets the default language to the browser s default one.
however we found that a bug in setlang produces an unintended behavior.
when the if statement compares the browser s default language uilang.match w with the selected language lang the comparison always evaluates to false!
note that the result of the match function is either an object or null while the value of lang is always a string.
because the strict equals operator always returns false if the types of two operands are different the conditionalexpression always evaluates to false which always sets theexpiration date of the cookie to one year later.
consequently whenever setlang is called the time in date sets to one year later of the current time and the cookie never expiresimmediately leaving the information on the user s computer.
we reported the bug to the wikipedia developers and they confirmed the bug and fixed it right away .
we can fix thebug by using the equals operator instead of because implicitly converts two operands of different types.
we found that wikipedia uses the strict mode recommended byecmascript in their javascript code to enforce more checks but the example shows that the checks are not enough to catchsuch a bug while a bug detector using safe wapp can detect it.
note that the modeling of both the event system and browserenvironments is necessary to catch the bug precisely.
withoutconsidering the event system the setlang call is unreachable and without the precise type information of browser languages navigator.language we cannot detect the conditional expression as a definite bug.
the second is the following pattern in web documents var canvas document.queryselector leftcol .logo while the document.queryselector call returns an object ofhtmlcanvaselement by searching the dom tree common approaches that model the dom treeimprecisely fail to provide precise analysis results they simplyreturn any html element which includes other elementsas well resulting in imprecise analysis results.
for moreprecise analysis results more precise modeling of dom isnecessary .
hence safe wapp provides not only existing dom tree abstraction models in the literature but also a newprecise model of dom trees with the new model it can returna single htmlcanvaselement object by searching an abstract dom tree as a result of the document.queryselector call in an html document with the canvas tag element.
in section iv we show that such apis for searching dom treesare frequently used in real world web applications and insection vii we show how dom tree abstraction levels affectstatic analysis results of javascript web applications.
iii.
j ava script in web applica tions we explain the execution model of javascript web applications and discuss challenges in analyzing them statically.
a. execution of javascript web applications a javascript web application runs in a web browser and users can interact with it through user events such as mouse and keyboard events.
figure illustrates an execution of asimple javascript web application which first shows a pictureof eggs and then changes it to a picture of a chicken when auser clicks it.
the source of the web application is an htmldocument consisting of a series of html tags.
javascriptcode usually resides inside script tags either inlined as in figure or imported from an external source as follows script type text javascript src sourcepath sourcefile.js such javascript code can access the enclosing html docu ment and change its structure contents and display.
553fig.
execution of a sample javascript web application to allow javascript code to manipulate html documents web browsers provide the document object model dom a tree representation of html documents.
a node in dom usually represents an html tag and is treated asa javascript object with links to its parent children andsibling nodes.
the tree diagram in figure shows a domtree for the html document in the figure.
note that ac tual dom trees created by web browsers are often morecomplex than the one in the figure.
the changepicture function inside the script tag of the html document in figure shows an example where javascript code changesthe contents of its enclosing html document by manip ulating dom.
it first gets an htmlimageelement object representing the img tag in the html document by calling document.getelementbyid and it assigns the object to imgobj .
then it creates a new htmlimageelement object by callingdocument.createelement and designates the source of the new image as the path to a new picture.
finally itchanges the structure of dom by replacing a child of thebody element imgobj with the new object newimg .
functions like getelementbyid andcreateelement are not described by the ecmascript specification.
they arelike apis that browsers provide to enable javascript code to access browser environments such as dom trees.
dom objects returned by such browser apis correspond to html elements.they share some common properties such as links to their par ents and children nodes but some dom objects have their ownproperties for example both objects for htmlimageelement andhtmldivelement have the parentnode property in common but only the objects for htmlimageelement have thesrc property.
browsers usually implement dom objects and browser apis in native code for performance reasons.
finally most web applications run with a variety of events from user interface events like keyboard and mouse events tobrowser behavioral events like load and change events.
theevent system enables developers to catch event triggers andto define actions to handle events by registering event handlerfunctions.
for example changepicture is an event handler function registered to the onclick attribute of the img tag with the picture of eggs.
when a user clicks the picture theevent system calls changepicture and changes the picture to the picture of a chicken.b.
static analysis challenges precisely and correctly analyzing javascript web applications requires modeling of browser environments includingdom browser apis and the event system in a base analyzer.without the modeling for example when safe supporting only stand alone javascript analyzes a simple web applicationin figure it does not analyze the changepicture call because the function is unreachable without an event system even if it can analyze the function call it signals a run timeexception at the first line of the function body with undeclaredvariable access to document becausedocument is an accessor that browsers provide for the root element of the dom tree then it terminates the analysis because the rest of source partsare unreachable due to the run time exception.
however such modeling involves several challenges.
first because no single standard specification describes browserenvironments it is not clear what to model among thousandsof properties related to dom objects and browser apis.
whilesome commonly used specifications about browserenvironments are available they are huge informal andincomplete.
moreover modeling dom objects only in thedocuments may be insufficient because many browsers supportnon standard features for example while the screen object is not a part of any specifications we found that more than of the most popular websites use it in their web pages.in addition incompatibility between browsers makes it evenmore difficult to select modeling targets for example whileinternet explorer provides attachevent to register event handlers neither of safari and chrome provides it.
instead ofmodeling only subsets of certain documents we model domobjects and browser apis based on our extensive empiricalstudy.
we present the empirical data in the next section.
second because execution of javascript code in html documents may interleave with parsing of html documents only a partial structure of a dom tree may be visible in thejavascript code of a certain script tag and events may occur while parsing html documents.
to precisely analyzesuch an execution we may need to incorporate html parsingwith static analysis which requires a meta circular analyzer.instead we simplify the execution model we assume that allscripts are executed after completion of html parsing and allthe events happen after execution of the top level code.
iv .
p ractical dom m odeling this section presents empirical data to identify frequently used dom objects and browser apis.
the purpose of thisempirical study is to lessen the burden of modeling efforts bysuggesting modeling priorities on dom properties and domtree abstraction levels.
while modeling mechanism itself is nota main focus of our work automatic modeling mechanism as in safe wapi can generate modeling from api specifications.
a. method we investigated what dom related fields and browser apis are commonly used in real world javascript applications.
forthis we instrumented webkit an open source web browser engine used in safari and chrome to identify dom related 554t able i usage of fields apis defined in dom specifications fields apis spec.
def.
no use def.
no use core .
html .
.
events .
.
total .
.
t able ii usage of fields apis in main pages of sites type sites sites sites site field api total property accesses.
specifically webkit has two modules javascriptcore and webcore which deal with javascriptcode execution and web page rendering respectively.
sincejavascriptcore communicates with webcore when in need toaccess dom properties we can identify all the accesses byobserving the communications between two modules.
using the instrumented webkit we made minibrowser a simple browser provided by webkit navigate to sitesexcluding inaccessible sites from the most popularwebsites according to alexa 2and stay for minute per site just loading the main web pages.
whenever minibrowservisits a new website the instrumented webkit dumps variousinformation such as the names of all dom fields and apisaccessed in the main web page for minute.
we also built atool to compute statistical data like the total number of accessesfor each field or api and the number of websites where eachfield or api is used.
b. results usage of the fields and apis defined in specifications.
first we demonstrate that it is not necessary to model all the fields and apis defined in various dom specifications.
table isummarizes the usage of the fields and apis defined in kindsof dom specifications in the w3c community dom level3 core dom level html and dom level events from top to bottom.
for each specification the columns of thetable show from left to right the number of defined fields the number of the fields never used in any site the number ofdefined apis and the number of the apis never used in anysite.
as the last row shows about half of the defined fields andapis were never used during execution of javascript code inthe main web pages of popular websites.
interestingly even for the dom level core specification which definesa core subset of web apis more than a half of the fields andapis were never used.
this result shows that most javascriptweb applications use only some subset of the dom properties.
modeling priorities.
while modeling all the properties defined in all dom specifications would be most useful itwould be practically helpful to set priorities between the domproperties so that one can incrementally model them in theorder of importance.
table ii summarizes the numbers of thefields and apis used in the main web pages of the targetwebsites.
the second column shows that fields and 52apis were found in more than sites and the fifth column able iii most frequently used dom properties defined in the w3c dom level core specification rank interface field sites 1document documentelement 2nodelist length node parentnode node nodetype node firstchild node ownerdocument node childnodes node nodename node lastchild node nextsibling rank interface api sites 1document getelementbyid 2document createelement node appendchild 4document getelementsbytagname node insertbefore 6element getelementsbytagname 7element getattribute node removechild 9element setattribute 10document createcomment shows that fields and apis were found in more thanor equal to site which means that the total number of domproperties used in websites are .
while modeling all properties found in websites would be time consuming and tedious if we give a higherpriority to those found in more than sites the modelingbecomes manageable with properties.
after modeling themfirst one can model other properties selectively depending onthe target applications.
for instance we modeled about 800properties using hand written code the model includes 196among properties found in more than sites we didnot model properties such as htmldocument.write which require html parsing and possibly dynamic javascript sourceloading.
we make the full list of the properties used in websitespublicly available .
dom tree modeling.
the abstraction level of concrete dom trees affects analysis precision and performance.
forsimple treatment of abstract objects existing approaches ab stract a dom tree as either one single node object ormultiple objects to keep separate abstract objects only fordifferent kinds of dom elements both approaches giveup maintaining the original tree structure at the initial state.while the approaches can always keep small fixed numbersof abstract objects for a dom tree regardless of its originalstructure they cannot provide precise analysis results forweb applications manipulating the tree structure .
on theother hand if a model maintains the dom tree structure byabstracting each node as a single abstract object the analyzercan provide more precise analysis results with the cost of moresophisticated modeling work and a large number of abstractobjects depending on source html documents.
observation on which fields and apis are frequently used in real world web applications can help to decide the abstrac tion level of concrete dom trees.
table iii shows the mostfrequently used fields and apis defined in dom level corewith the numbers of the websites where they were found.the properties marked with indicate that they either search or manipulate dom trees.
as the table shows more than ahalf of the websites are using them which implies that the 555fig.
overall structure of the safe wapp framework dom related properties are being used significantly in many web applications.
therefore a crude abstraction that does notmaintain dom tree structures would lead to imprecise analysisresults in web applications.
based on empirical data our modelprovides a precise dom tree abstraction model but we make itconfigurable to other two aforementioned existing abstractionmodels allowing users to choose an appropriate one dependingon their applications.
we provide more detailed explanation ofthe three dom tree abstraction models in section v d. v. safe wa ppframework now we present safe wapp built on top of an open source safe framework as illustrated in figure .
solid and dashed boxes represent modules and data respectively andarrows show flows of data between modules.
the modules inthe shaded boxes indicate the ones in safe and the others outside the shaded boxes are new additions.
a. safe and static analyzer we give a brief introduction to safe and its analyzer in this section and refer the interested readers to its manual .
safe is an open source analysis framework for stand alone javascript programs.
it transforms a javascript source program to an abstract syntax tree ast an intermediate represen tation ir with simpler language constructs than ast anda control flow graph cfg to enable various analyses ondifferent levels of representations.
its default static analyzer oncfgs supports flow sensitive and context sensitive analyses ofjavascript programs by faithfully modeling the semantics ofecmascript .
a safe analysis computes the following summary map for a program s s node context heap which maps a program point represented by a pair of a cfgnode and a context to an over approximate abstract heapinformation.
a variable or an object property in an abstract heap h heap maps to an abstract value vrepresented by a tuple of lattice elements as follows v v undef null bool number string loc where loc is a finite set of abstract locations that map to abstract objects in abstract heaps and the others are simple abstract domains for primitive types undefined null bool number andstring .
their definitions are available in the safe manual .
for example an abstract value vthat may betrue ornull is represented as follows v bot undef null true botnumber botstring .with the domains the default static analyzer performs sound and elaborate analyses on cfgs of javascript programs with the transfer function f s sto compute a final summary map sfinalfrom the following least fixpoint computation sfinal leastfix s. si s f s where the initial summary map simaps an initial program point to the initial heap hinitand all the other program points to botheap .
the analysis starts with siand updates the map until it reaches a fixpoint.
the initial heap hinitcontains abstract value information of javascript built in objects and functions.
in addition the analysis supports various analysistechniques such as object recency abstraction distin guishing recently allocated objects from summary objects at aprogram point k cfa distinguishing function calls with klength of call strings that represent call history and loopsensitivity distinguishing loop iterations during analysisusing loop contexts that contain loop information to improveanalysis precision.
the safe analysis supports such multiple analysis sensitivities by configuring context accordingly.
note that safe wapp extends hinitof the safe analyzer with more information about dom trees and browser apis so that it cananalyze web applications.
without such information when aninput program calls browser apis for example the safe analyzer wrongly identifies them as undefined function accessesor non function calls making further analysis unsound.
b. html parser and event system the first step to extend safe for stand alone javascript programs to web applications is to provide a way to parse html documents.
because the webkit html parser isnot well structured or documented enough to provide neces sary information about the html documents being parsed safe wapp uses a combination of two third party html parsers with different capabilities.
safe wapp uses jericho to extract javascript code and its source location from anhtml source and passes them to the original javascript parserin safe .
then it uses cyberneko to construct a dom tree from the html source and passes it to the dommodeler anddombuilder modules which create abstract models of browser environments and dom trees respectively and passthem to the analyzer as shown in figure .
then we model the event system of browser environments to support interactions between web applications and users viaevents.
while previous work uses an event model whereload event dispatches preceded dispatches of other events we found that this model may produce unsound analysisresults because dispatches of other events indeed can precedeload events.
hence we choose a more conservative eventmodeling for soundness after analyzing a given program itanalyzes all event handlers registered by the program andsafely combines their analysis results.
note that users mayregister event handlers not only statically using html at tributes such as onload andonclick but also dynamically using the addeventlistener api.
safe wapp maintains a special abstract object which serves as a table to keep allregistered event handlers including the ones registered dy namically during analysis.
the eventcfgbuilder module in figure adds an event execution loop at the end of thecfg of the program.
the event loop represents program flows 556of all possible execution sequences of event handlers.
since combining analysis results may harm the analysis precision ofthe whole program safe wapp provides a configurable option to enable or disable the event system.
c. dom prototype objects and browser apis to provide browser environments to the analyzer module thedommodeler module adds dom prototype objects and other built in browser objects that have abstract browser apis to the initial heap of the analyzer.
note that unlike class basedlanguages like java javascript does not support classes andinheritance by subclassing but supports prototype based objectinheritance.
when looking up a property in an object if theobject does not have the property it looks up the property inthe objects in its prototype chain.
the dommodeler module creates abstract dom prototype objects that dom node objects inherit and built in browser ob jects with browser apis constructs prototype relations amongthem and puts them in the initial heap of the analyzer.
wefaithfully modeled according to the dom specifications fromthe w3c and wha twg communities about abstractobjects and properties that include among prop erties that we found in more than sites in the empiricalstudy of section iv b. while the specifications also definesome interfaces that instance node objects in a dom treeshould implement they however do not clearly describe ahierarchy between dom interfaces and objects implementingthem.
for example a div tag in an html document creates anhtmldivelement instance object which should implement thehtmlelement interface an object that implements the htmlelement interface should implement the element interface likewise an object that implements element should implement the node interface.
however the specifications do not describe how to implement such relations.
to provide the relationships between dom objects in a precise and practical way safe wapp models prototype relations between dom interfaces following the implementation modelof browsers rather than the specifications.
in real implementa tion while apis defined in an interface are properties of theprototype object of the interface fields defined in an interfacemay not be properties of the corresponding prototype object.
for instance the appendchild api defined in the node interface is a property of the node.prototype object but the firstchild field defined in the same node interface becomes a property of all the instance node objects in a dom tree.
d. dom tree construction thedombuilder module constructs an abstract dom tree and adds it in the initial heap of the analyzer.
safe wapp provides configurable dom tree abstraction levels in three ways two from the literature and one new model a keeps one single abstract node that approximates all kinds of dom nodes regardless of htmlsource structures like the model that g a tekeeper uses all links to parent children and sibling nodesalways point to the one single abstract node.
model b keeps one single abstract node for nodes in the same kind for example nodes with the sametag but different abstract nodes for those in differentkinds regardless of html source structures like themodel that t ajs uses all links to parent children and sibling nodes always point to all possible abstractnodes.
model c keeps a single abstract node for each dom node by cloning the concrete dom tree from htmlparsers links to parent children and sibling nodespoint to precise single abstract nodes initially but theymay be over approximated during analysis.
while model c provides the most precise dom tree model bthe second and a the least model a and b always keep thesame numbers of abstract objects for a dom tree regardless ofan html source structure which are usually smaller than thenumber of abstract objects in model c the number of abstractobjects for a dom tree varies depending on html sourcestructures in model c. thus three models can have trade offs between analysis precision and performance.
smallernumbers of abstract objects make an analysis domain smaller which helps the analysis to reach a fixpoint earlier.
moreover model a and b make the implementation of abstract apisfor dom tree search and manipulation simpler than model c.while model c implements actual search and manipulationon abstract dom trees for the apis model a and b simplyreturn all possible abstract nodes for search and do nothing formanipulation which improves analysis performance.
we showthe effect of each model on analysis precision and performanceusing analysis results of real world applications in section vii.
vi.
a pplica tion of safe wa pp now that safe wapp provides an extensive model of browser environments it extends the applicability of clientapplications built on top of safe from stand alone javascript programs to web applications.
v arious client applications canutilize analysis results of safe wapp for program understanding debugging and optimizations.
in this paper we presenta bug detector that detects javascript language level bugs asan application of safe wapp .
the bug detector can detect the following bugs errors and warnings absentvar signals undefined variable accesses which cause the referenceerror exception in javascript.
callnonfun signals function calls with non function values which cause the typeerror exception.
nullorundef signals property accesses of null or undefined which cause the typeerror exception.
binaryt ype signals non object values used in the righthand sides of the in orinstanceof operator which cause the typeerror exception.
condbranch signals conditional expressions with constant values or applications of the operator that evaluate to always true or always false in if statements subtleties in correctly using and operators can cause unintended behaviors as we showed insection ii.
convertundeft onum and primitivet oobj signal suspicious implicit type conversions from undefined to 557fig.
bug detector using analysis results form safe wapp a number and from a primitive value to an object respectively.
figure illustrates the overall structure of the bug detector the shaded box indicates the bug detector with itsmain modules.
it takes the cfg of a target program and itsanalysis results from safe wapp as inputs and produces a bug report as an output.
as with cfgs in traditional compilersand analyzers a cfg node in safe wapp corresponds to a basic block containing a list of instructions and an instructioncontains expressions that have no side effects on heaps andabstract heaps during evaluation and analysis .
recall thatthe safe wapp analyzer computes a summary map sfrom each program point a node and a context to an abstract heap at theprogram point as an analysis result.
in order to perform bugdetection efficiently the bug detector first trims unnecessaryinformation from the summary map s. the bugdetector module refines sto another one sbthat maps a pair of an instruction ior an expression eand a context cto an input abstract heap hat the instruction ior expression ewhile traversing the cfg by the t raversecfg module.
then using sb the c module inspects all cfg nodes and calls the imodule when it inspects instructions in the nodes.
likewise the imodule inspects instructions and calls the vmodule when it inspects expressions in the instructions.
while inspecting instructionsand expressions the imodule and the vmodule call the instdetect module and the exprdetect module respectively to perform actual bug detection and pass detected bug informationto the bugstorage module.
finally the bugstorage module collects all the bugs detected and reports them in a user readable format with source locations.
because false positives are one of the main reasons why developers do not use static analysis tools our bugdetector reports only definite bugs by default and provides anadditional developer mode to report all detected bugs that mayinclude more false positives.
thus with a default mode thebug detector uses the following restrictions on bug detectionto reduce false alarms it does not consider cfg nodes in branches with uncertain conditions it reports only such bugs that are detected in all contexts for example if it detects a bug at the sameprogram point in one call context but not in anothercall context it does not report the bug it reports bugs only with definite value information for example if an abstract value vmay be null oran object then the bug detector does not report the nullorundef bug with the property access of v. note that since safe wapp soundly over approximates program behaviors bug detection with a developer mode will reportmore bugs possibly with more false positives.
due to the space limitations we present only the detection rules for nullorundef and binaryt ype with a default mode in this paper and we refer interested readers for details tothe safe wapp repository .
when evaluating a property accesse.p javascript first evaluates the expression eto a value and implicitly converts the value to an object.
safe wapp models such an implicit type conversion from a value to an object with the instruction x toobject e and the instdetect module of the bug detector inspects the instruction to detect any nullorundef errors as follows instdetect llbracketx toobject e rrbracket sb signalbug nullorundef if c context h heap and v vsuch that sb x toobject e c h fe e h c v v. undef v. null v. bot bool v. bot number v. bot string v. where fe e h c evaluates the expression ewith the abstract heap hand the context cto an abstract value and v.naccesses then th element in the tuple of the abstract values v. the rule signals the nullorundef bug only when the expression e evaluates to either undefined ornull not to other values in all contexts to minimize false positives.
to detect non object values used in the right hand sides of thein orinstanceof operator the exprdetect module of the bug detector inspects binary operation applications as follows exprdetect llbrackete1 e2 rrbracket sb signalbug binaryt ype if in instanceof c context h heap and v vsuch that sb e1 e2 c h fe e2 h c v v. .
the rule signals the binaryt ype bug only when the right hand side expression e2evaluates to a non object value v. i n all contexts to minimize reporting of false positives.
in the nextsection we present bug detection results of our bug detectoron real world applications.
vii.
e xperiment al ev alua tion we evaluate safe wapp with the analysis results of popular javascript libraries and websites.
our implementation of safe wapp and target programs are publicly available .
table iv summarizes the evaluation results.
the first andsecond columns of the table show the target programs of theevaluation and line numbers of their pretty printed javascriptsources respectively.
the first targets are simple programsthat just load the most popular javascript libraries accordingto w3techs and the remaining targets are the main webpages of the most popular websites according to alexa thatwe collected using source saving functions of browsers.
weused javascript libraries because they have been the majortargets for javascript analysis and we selectedweb sites because javascript code in web pages may be theclosest one to javascript web applications in the wild.
558t able iv analysis results of the most popular javascript libraries and main web pages of the most popular websites with different dom tree abstraction models.
model a and b are previously used by g a tekeeper and t ajs respectively and model c is proposed in this paper.
the analysis time is in seconds with the timeout of hours denoted by .
the analysis precision is measured with md multiple dereferences mc multiple calls and pr non constant property accesses .
target locmodel a model b model c time md mc pr time md mc pr time md mc pr jquery .
.
.
modernizr .
.
.
.
.
bootstrap .
.
mootools .
.
.
prototype .
.
.
.
.
google.com .
facebook.com youtube.com baidu.com yahoo.com .
wikipedia.org .
.
.
amazon.com twitter.com taobao.com qq.com average statically analyzing javascript code in web pages is full of challenges.
one big challenge also common in all static analyses is dealing with dynamic code generation.
javascript codein some websites is statically invisible since it is dynamicallygenerated by calling functions such as eval andfunction or loaded lazily by the script tag with javascript source code using document.write ordocument.createelement at run time.
because such code fragments are not availableat compile time but appear at run time they may invalidatestatic analysis results.
among the most popular websites we detected eval calls inyoutube.com baidu.com and qq.com during analysis.
since all calls are with constant string arguments we could easily replace the eval function calls with other language constructs .
with the target programs we first evaluate how dom tree abstraction levels affect analysis results with respect toperformance and precision.
we compare the analysis resultsof three different dom tree models that safe wapp provides model a b and c described in section v d. note that sincemodel a and b are dom tree abstraction models previouslyused by g a tekeeper and t ajs respectively the evaluation results also allow us to compare existing modelsin the literature model a and b and a new one modelc .
next we discuss the modeling coverage of all detectedbrowser apis during analysis and we present bug detectionresults on the main web pages of the most popular websitesusing our bug detector.
for fair comparison we used thesame configurations with call context sensitivity and loop sensitivity but different ones only for dom tree models.we conducted all experiments on a linux x64 machine with3.4ghz intel core i7 cpu and 32gb memory.
a. dom tree abstraction table iv shows analysis results of the target programs by the analysis of safe wapp with the timeout of hours when we use three different dom tree abstraction models.
the first columns in the sections of table iv for model a b andc show the time in seconds that safe wapp took to analyze target programs.
when an analysis does not complete withinthe timeout we denote its time as .
the rest columns show three metrics that we used to measure the analysis precision md the number of object dereferences with multipleobject values multiple dereferences the total numberof analyzed object dereferences mc the number of calls with multiple function values multiple calls the total number of analyzed calls pr the number of object property accesses with aproperty name approximated as non constant non constant property accesses the total number ofanalyzed object property accesses except for thosewith constant property names such as o the experimental results show that while model a and bdo not show significant differences in analysis performanceand precision model c outperforms model a and b in bothperformance and precision in most cases.
for the analysis performance while using model a and b can finish analysis of only targets modernizr prototype and wikipedia.org using model c can finish analysis of more targets jquery mootools google.com andyahoo.com .f o r example while analysis with model a and b cannot analyzejquery the most popular javascript library with the marketshare of more than within the timeout of hours analysiswith model c finishes analyzing jquery in .
seconds.
notethat wikipedia.org is an outlier in analysis results.
even though analysis with model a and b can finish analyzing wikipedia.org in less than seconds it took more than minutes with model c. because model c provides precisedom modeling analysis using model c involves overhead inmaintaining precise dom models which may be an overkillfor analyzing simple programs like wikipedia.org .
as for the analysis precision all three metrics md mc and pr on average the last row of table iv show thatmodel c has the least ratios of multiple dereference multiplecall and non constant property accesses over correspondingtotal program points although it has the most numbers oftotal program points in the ratios for example model c has 559the least ratio .
on average in mc compared to .
and .
in model a and b but it has the most number of total program points as 566compared to and in model a and b respectively.note that the least ratios mean the most precise analysis resultsand the most numbers of total program points mean the bestanalysis coverage of target program points.
we found thatmodel c analyzes more program points than model b andc with the same timeout in most cases which implies thatmodel c shows better analysis scalability in such cases incase of google.com for example we found that analyses with model a and b cover .
and .
of cfg nodes respectively while that with model c covers .
withinthe same timeout of hours.
the results in table iv indicate that the precise dom modeling in model c can improve the analysis performancein some javascript web applications.
unlike analysis of c likelanguages where precise analyses often sacrifice the analysisperformance researchers recently reported thathigh precision in static analysis of javascript applications canincrease the analysis scalability significantly.
for instance lowprecision in analysis of higher order function calls mixed withdynamic property accesses as in o ... may lead to many spurious function calls increasing analysis computationimmensely.
likewise imprecise property values in dom treesof model a and b may harm the analysis scalability.
finally we investigated why safe wapp with configurable dom tree models fails to complete the analysis of targetprograms within the timeout.
one reason was prevalent uses ofstatically indeterminate values such as math.random and browser environmental information.
we observed that soundabstraction of such values as all possible ones would leadto state explosion during analysis.
another reason was thesound event system of safe wapp which considers all possible execution sequences of event handlers where the worst fixpointcomputation time of the analysis exponentially increases asthe number of registered event handlers increases.
we foundthat facebook.com registers mouse event handlers only with html attributes statically.
we expect that user inputsfor statically indeterminate values and more elaborate eventsystems would alleviate the scalability problem.
b. modeling coverage to evaluate the effects of the proposed modeling mechanism we measured the coverage of models encountered during analysis.
we first identified definite browser api calls eachof which has a single function value during analysis of 15target programs using model c within the timeout of hours.then we checked whether api function calls encounteredduring analysis are covered in a hypothetical model whichincludes only the modeling of apis found in more than1 websites from the empirical study of section iv.
wefound that the model covers all apis detected in targets the worst case was youtube.com where the model covered apis out of encountered apis .
and on averagethe model covers .
of all apis encountered in each tar get program.
the experimental results indicate that modelingbrowser apis based on empirical data is a promising approach.c.
bug detection we present bug detection results in the main web pages of the most popular websites using the bug detector we havebuilt as an application of safe wapp section vi .
the bug detector uses analysis results from safe wapp with the most precise dom tree abstraction model c with the timeout of 3hours.
it did not report any errors or warnings in google.com andbaidu.com but it reported errors and warnings in the remaining websites nullorundef condbranch convertundeft onum and primitivet oobj .
in addition to the bug in wkipedia.org we described in section ii we found another interesting bug in amazon.com detected as a convertundeft onum warning as follows var istouchdevice ... navigator.maxtouchpoints .
.
.
where the code checks if a current device is a touchdevice by checking if the maximum number of touchpoints in a current device is greater than .
how ever since browsers provide the maximum number oftouch points with navigator.maxtouchpoints rather than navigator.maxtouchpoints the code contains a typing error with the capital m. consequently this bug causes the condition expression to always evaluate to false via the followingevaluation steps first navigator.maxtouchpoints evaluates toundefined then the undefined value implicitly converts to a number nan in this case for the comparison with and n a n always evaluates to false.
the bug detector finds such suspicious implicit conversion from undefined to a number and signals the convertundeft onum bug.
after we reported the bug amazon is investigating it.
the bug detector finds suspicious conditional expressions that always evaluate to the same value in conditional branches and it signals condbranch warnings for such cases.
for example if true ... fromfacebook.com is such a case.
in this case we can safely rewrite the if statement to its true branch statement preserving the semantics of theprogram.
note that detecting and rewriting ever true or ever false conditional branches may enable web page optimizationby reducing code size.
primitivet oobj warnings signal suspicious implicit type conversions from primitive values to objects.
for example new date .tostring .slice fromtwitter.com illustrates such a case.
after creating an instance date object the code implicitly converts the object to a positive numberby applying the operator which subsequently converts to anumber object for the tostring method call.
while the implicit conversion from a primitive number to an object inthis code may be intentional since such conversions often leadto unexpected behaviors the bug detector reports them as the primitivet oobj warning.
finally we manually inspected all reported bug messages to check if they are true alarms.
using the developer modein various browsers we compared the bug detection resultsand real execution results to identify false alarms whichhave inconsistent messages with the real execution results.we found that bug reports out of messages were falsealarms.
the false alarms mainly come from lazily loaded script 560code and incomplete analysis results due to timeout.
considery.moduleplatform.init ... fromyahoo.com where y.moduleplatform is defined in a script loaded lazily from a different server.
since safe wapp does not have analysis results of such lazily loaded code the analyzer considers itsvalue as undefined which makes the bug detector identifyy.moduleplatform.init as an illegal property access ofundefined reporting nullorundef .
we can eliminate such false alarms if users provide lazily loaded scripts to safe wapp before analyzing the code.
another false alarm isthis.options.buffersize fromtwitter.com .
because the safe wapp considers this.options.buffersize as undefined the bug detector regards the code as a suspicious implicit type conversion from undefined to a number and it signals the convertundeft onum warning.
however we found that the property is actually defined in an event handler whichwas not analyzed due to the timeout of hours the bugdetector reported the false alarm since the safe wapp analyzer missed the event function during analysis .
we can eliminatesuch false alarms with longer timeout for analysis.
d. threats to v alidity soundness and precision.
although we faithfully modeled browser environments with frequently used apis web applications may use apis not included in our modeling.
in suchcases because safe wapp simply reports warning messages for the api uses the analysis results of web applicationsusing the apis become unsound or imprecise.
systematicand reusable modeling techniques may reduce the modelingeffort and enhance the soundness and precision of analysisresults.
also incomplete analysis results with timeouts mayproduce unsound results.
more sophisticated modeling of theevent system considering possible orders among events couldimprove the scalability and precision of the analysis as wellas the soundness by completing the analysis within timeouts.
bug detection.
while safe wapp could detect some previously undiscovered bugs with warning messages that maylead to unintended behaviors it did not find any true errors.however because the target websites have been deployedand used by many people for long periods it is highlylikely that all critical errors like run time exceptions mayhave been already reported and fixed.
we believe that the safe wapp bug detector would be more useful to detect bugs in javascript web applications under development rather thanafter deployment.
as safe wapi an extension of safe analyzes api specifications additionally to detect incorrectuses of apis in javascript web applications we believe thatintegrating safe wapi and safe wapp will enlarge a set of bugs that it can detect.
viii.
r ela ted work ga tekeeper combines a static points to analysis of javascript programs in the web and run time checks forunresolved names during static analysis.
it models a domtree and browser apis as a single node object and as mock up objects respectively.
on the contrary safe wapp is fully static and it supports the full javascript with the faithful modelof browser apis frequently used in real websites.
note that safe wapp incorporates the dom tree model of g a tekeeper as a configurable option.lerner et al.
formally modeled the event system of web browsers faithfully as specified in w3c dom level3 events.
the model includes the complex event dispatchmechanism with event capturing and event bubbling.
however their model supports restricted subsets of dom objects and thejavascript language only with event related features.
note thatour event model does not need to consider the event capturingand bubbling mechanism since it abstracts all possible eventdispatch and event handler execution.
jensen et al.
extended t ajs with a dom and browser apis modeling .
while their event modeling inspired ours there are significant differences between our approach andtheirs.
first they modeled browser environments based onselected specifications but our modeling is based on extensiveempirical data.
second their modeling supports only simpledom tree abstraction.
t ajs abstracts html elements withthe same tags as one single abstract object having a simpleabstract domain for a dom tree by sacrificing its tree structure.because of this simple abstraction all parent children andsibling links of a node in a dom tree point to all possible nodeobjects with imprecise information.
consequently t ajs failsto give precise analysis results on simple programs that exploreand manipulate dom trees .
on the contrary safe wapp provides configurable dom tree abstraction which supportsnot only the t ajs model but also a new dom tree abstractionthat captures the concrete dom tree precisely at the initial stateof the analyzer.
in section vii we showed that high precisionin dom tree abstraction can significantly improve the analysisscalability for real world javascript web applications.
ix.
c onclusions we presented safe wapp an open source static analysis framework for javascript web applications.
it supports thefull javascript language and features an extensive model ofbrowser environments.
unlike previous work based on a fewspecifications our dom model is based on empirical datacollected from the most popular websites.
it providesconfigurable dom tree abstraction models in three levels twoexisting models and one new model that captures the precisetree structure of a concrete dom tree at the initial state ofanalysis.
we evaluated how different dom tree abstractionmodels affect the analysis performance and precision usingreal world javascript web applications in the wild.
the ex perimental results showed that precise dom tree abstractioncan significantly improve the analysis scalability.
on top of safe wapp we have built a bug detector capable of detecting javascript language level bugs as an application of safe wapp .
while investigating the main web pages of the most popularwebsites using the bug detector we found previously undis covered bugs in wikipedia.org andamazon.com .
since our bug detector reports only definite bug messages by default thenumber of bug messages was manageable as in targetprograms and .
of all bug messages were true alarms.
wemake the implementation of safe wapp and the bug detector open to the public.
acknowledgment this work is supported in part by national research foundation of korea grant nrf 2014r1a2a2a01003235 samsung electronics and google faculty research a ward.
561references g. richards s. lebresne b. burg and j. vitek an analysis of the dynamic behavior of javascript programs in proceedings of the acm sigplan conference on programming language design and implementation .
s. bae h. cho i. lim and s. ryu safewapi web api misuse detector for web applications in esec fse proceedings of the 22nd acm sigsoft symposium and the 13th european conferenceon f oundations of software engineering.
acm .
e. andreasen and a. m ller determinacy in static analysis for jquery in oopsla proceedings of the 29th annual objectoriented programming systems languages and applications .
v .
kashyap k. dewey e. a. kuefner j. wagner k. gibbons j. sarracino b. wiedermann and b. hardekopf jsai a staticanalysis platform for javascript in fse proceedings of the 22nd acm sigsoft international symposium on f oundations of softwareengineering .
m. sridharan j. dolby s. chandra m. sch afer and f. tip correlation tracking for points to analysis of javascript in ecoop proceedings of the 26th european conference on object orientedprogramming .
w3c document object model activity statement org dom activity.
wha twg html living standard web apps current work multipage .
p .
a. gardner g. d. smith m. j. wheelhouse and u. d. zarfaty local hoare reasoning about dom in pods proceedings of the 27th acm sigmod sigact sigart symposium on principles of databasesystems.
acm .
b. s. lerner m. j. carroll d. p .
kimmel h. q. d. la v allee and s. krishnamurthi modeling and reasoning about dom events inwebapps proceedings of the 3rd usenix conference on webapplication development.
usenix association .
d. y u a. chander n. islam and i. serikov javascript instrumentation for browser security in popl proceedings of the 34th annual acm sigplan sigact symposium on principles of programminglanguages.
acm .
s. guarnieri and b. livshits ga tekeeper mostly static enforcement of security and reliability policies for javascript code in ssym proceedings of the 18th conference on usenix security sympo sium.
usenix association .
s. h. jensen m. madsen and a. m ller modeling the html dom and browser api in static analysis of javascript web applications inesec fse proceedings of the 19th acm sigsoft symposium andthe 13th european conference on f oundations of software engineering.acm .
h. lee s. won j. jin j. cho and s. ryu safe formal specification and implementation of a scalable analysis framework for ecmascript infool international workshop on f oundations of object oriented languages .
kaist plrg research material m. madsen b. livshits and m. fanning practical static analysis of javascript applications in the presence of frameworks and libraries inesec fse proceedings of the 9th joint meeting on f oundations of software engineering.
acm .
kaist plrg safe javascript analysis framework kaist.ac.kr .
s. ryu j. choi w .
choi y .
ko h. lee and c. park the safe specification .
ecma ecma ecmascript language specification.
edition .
.
p .
heidegger and p .
thiemann recency types for analyzing scripting languages in ecoop proceedings of the 24th european conference on object oriented programming .
r. mangal m. naik and h. y ang a correspondence between two approaches to interprocedural analysis in the presence of join in esop proceedings of the 23rd european symposium on programming.springer .
c. park and s. ryu scalable and precise static analysis of javascript applications via loop sensitivity in ecoop proceedings of the european conference on object oriented programming.
springerlncs .
jericho html parser cyberneko html parser b. johnson e. m. h. y oonki song and r. bowdidge why don t software developers use static analysis tools to find bugs?
in icse proceedings of the international conference on software engineering .
m. sch afer m. sridharan j. dolby and f. tip dynamic determinac y analysis in proceedings of the acm sigplan conference on programming language design and implementation .
a. feldthaus and a. m ller checking correctness of typescript interfaces for javascript libraries in proceedings of the acm international conference on object oriented programming systems languages andapplications .
s. h. jensen p .
a. jonsson and a. m ller remedying the eval that men do in issta proceedings of the international symposium on software testing and analysis.
acm .
s. h. jensen a. m ller and p .
thiemann type analysis for javascript in sas proceedings of the 16th international symposium on static analysis .
e. andreasen and a. m ller determinacy in static analysis for jquery in oopsla proceedings of the acm international conference on object oriented programming systems languages andapplications.
acm .