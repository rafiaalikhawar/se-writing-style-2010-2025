onspot s ystem test impact v isibility during code edits in real software muhammad umar janjua operating system group r d microsoft corporation redmond us mujanjua microsoft.com abstract for maintaining the quality of software updates to complex software p roducts e.g.
windows os an extensive broad level regression testing is conducted whenever releasing new code fixes or updates.
despite the huge cost and investment in the test infrastructure to execut e these massive tests the developer of the code fix has to wait for the regression test failures to be reported after checkin.
these regression tests typically run way later from the code editing stage and consequently the developer has no test impact visibility while introducing the code change s at compile time or before checkin .
we arg ue that it is valuable and practically feasible to tailor the entire development testing process to provide valuable and actionable test feedback at the development comp ilation stage as well.
with this goal this paper explores a system model that provides a near real time test feedb ack based o n regression tests while the code change is under development or as soon as it becomes compilable.
onspot system dynamically overl ays the results of tests on relevant source code lines in the development environment thereby highlighting test failures akin to synta x failures enabling quicker correction and re run at compile time rather than late when the damage is already done .
we evaluate onspot system with the security fix es in windows while considering various factors like test feed back time coverage ratio.
we found out that on average nearly of the automated windows regression test collateral could run under seconds providing same level of coverage thereby making onspot approach practically feasible and manageab le during compile time.
categories and subject descriptors d. .
software engineering testing and debugging general terms reliability design experimentat ion keywords software testing analysis code writing development early regression real product testing i. introduction the fact is that the bugs are mostly adde d to the source code at the moment it is fixed or changed.
the introduction of a change in the source code is crucial and risky.
we believe that t he right time to fix these bugs should ideally be closed to the time code change is added.large enterprise organizations like microsoft employ extensive broad level of testing to maintain the quality of the updates to existing products like windows .
such organizations invest lot of time and resources in the test infrastructure execution a nd test pass completion so that all the change related and component wide scenarios as well as dependent systems and diverse third party applications could be covered and confirmed to be regression free.
while there is a lot of useful information available about successful failing tests coverage percentage for the changed lines etc it is reported only after the developer has completed coding and made the checkin.
instead we se e a potential value and use of test related feedback at compile time as well and argue to tailor the entire testing process to provide test related feedback at the development compilation stage as well.
the advantage of providing such an on spot feedback to the developer is to detect and prevent runtime failures and regressions nea rly at the same time as the code edit happens.
otherwise such failures are normally discovered at the code check in time or by full test passes that incur higher costs.
by that time the damage is already done.
with onspot system we provide a unified s eamless and lightweight interface to developer that pulls relevant tests from diverse components and dependent software and provides precise test feedback about the current change being introduced at the compile development time .
this approach makes distant regression testing an integral part of the change introduction process or a first class citizen for developer where testing would not be taken as a post checkin activity but as a mechanism to seek insight about the code change right on the spot and before it is checked in or shared.
if we compare with local unit testing available to developers although these can complete faster yet these are limited to the component scope only and the included tests lack system wide breadth and diversity .
so it also becomes critical to conduct relevant regression testing early for scenarios that are not covered with simple unit tests.
many a times local unit testing succeeds but the buddy software tests fail way later.
with onspot sys tem we bring the test diversity and greater coverage from large scale system wide regression tests and make it available to the developer at code editing stage in a lightweight and actionable manner.
the contributions of this paper are .
first to propose and investigate the need for a lightweight model to run regression t ests at compile time while introducing code changes in the light of test failures.
.
implements the proposed model as a working prototype system onspot based on the real world wind ows test system that establishes a near real time link between the source changes and the state of regression test execution in one unified interface.
.
evaluat es the practical feasibility of the appro ach by running several real world security fixes shipped in windows .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
994onspot system is c ompatible with any existing test selection priorit ization minimization techniques and can integrate well with traditional software development processes with a little effort.
table comparing characteristics of onspot with other ii.
related tools and tech niques currently the type of static tools available to developers that can be used to assess the effect of a code change are quite limited in their feedback.
they only address limited classes of bugs and propertie s about the programs during development.
for example compiler techniques like syntax semantic type checking can only determine error typos missing variable undefined functions incorrect casts etc.
static source code analyzer like prefast take a step higher and can provide approximate feedback for example about buffer overflows and pointer allocation errors.
but what remains elusive from the prior techniques are more interesting use cases and richer class of program properties and behaviors capt ured as test cases.
currently at static time the developer has no clue how its current code change affects the relevant test cases .
on the other end there are series of profile driven tools relying on code coverage informatio n that can link up source code change with the related tests.
however these tools operate at post build time are applicable after the fix has been checked in and currently do not help the developer directly during code changes.
further there has been extensive work and techni ques on selecting minimizing and prioritizing tests based on co de coverage.
onspot system does not modify or build new techniques in this category.
however it is compatibl e with any of these techniques which can be incorporated in the onspot system.
iii.
model for code change introduction process we define a number of important ch aracteristics for onspot system and the model for change introduction.
refer to table and figure respectively.
figure model for change introduction consider the introduction of fix as a series of code changes with interleaved compilations.
let ci be the set of changes where ci code change at ithcompile time and cir ci such that r !
.
the relation r could be taken as a syntactic subset.
let cf be the final fix which is supposed be checked in to the source depot.
a. change granu larity testable change a change becomes a candidate for test when it is compilable.
the developer however can control the point when he wants invoke the test during his fix.
this might vary with his thought process and current understanding of his partial fix so far .
b. automatic build and deploy we propose an incremental build process incrbuild ci that produces a modified binary binar yci containing the code change ci.
c. test selection and coverage ratio assume we have a original code coverage data for the binary before any change ci is introduced .
let t be the set of all tests available for this binary.
we define a procedure selecttests ccov binary binar yci which takes the modified binary and the code coverage data and determines the tests tci t that are relevant to the change ci .
we define code coverage ratio to be the number of binary blocks covered by tests divided by the total number of blocks added or modified as a result of introducing change.
in practice onspot uses echelon s test selection method that analyzes the difference between the old and new binary in the light of previously stored baseline of code coverage data.
in the first step echelon identifies impacted binary blocks new pl us old modified using binary level differencing between the two versions .
then prior code coverage information is us ed to select tests th at cover the old modified block directly or cover the old immediate predecessor successors of the newly added block in the new binary .
d. test setup and execution once the related tests are identified the tests tci are automatically setup and run and the results logs are collected.
let resci be the test result set for executing tests.
e. feed back the developer has a pipeline of resci at his end for the series of changes ci introduced so far.
at any i th stage the developer is aware how the current change impacts the selected test results.
table result pipeline for developer f. test response time for change ci let the response time rt ci be the total time it takes run tests and show test feedback to the developer.
the goal is to show relevant tests with low rt ci and better coverage for developer for execution.
for complex products million s of line of code onspot syntax type checker prefast static code analyzer local unit testing traditi onal testing lightweight y y y y n bug prevention stage code editing code editing code editing at checkin after check in feedback time immediate somewhat immediate immediate delayed change sensitive y y y y n precision y y approximate y y corrective action at dev box y y y y n test diversity across entire system n a limited static checks only component across entire system code change relevant tests pass results ci tci resci ci tci resci .... .... .... .... cf tcf rescf for i ...f binar yci incrbuild ci tci selecttests ccov binary binar yci resci runtests tci showtestfeedback resci 995iv.
architecture and implementa tion in this section we layout the system components which implement the above model.
first a workflow is established on the developer s box that monitors code changes and compiles these automatically.
the changed binaries are passed to the backend where it is analyzed for changed binary blocks and determination of related tests that cover that change.
these tests with the associated coverage ratio execution time setup complexity component scope are shown to the developer.
the developer has two main views .
a. test centric view in this view the de veloper has a complete view of all the regression tests that cover the code change being introduced.
these tests are selected and prioritized according to the level of automation expected execution time coverage ratio and environment readiness.
the developer has a filter to select and search from the tests.
b. source centric view the source centric view in figure provides an o verlaying of the relevant tests and their results over each changed source line.
this enables developer not only to see how its current code changes introduced ar e affecting the selection of tests but also how results of test runs change from fail to pass or vi ce versa as he progresses towards the completion his f ix.
this brings a near instant link between test results and code editing.
the regression test resu lt become a kind of first class citizen in the developer s ide.
the source lines marked green have associated tests that cover these lines.
the lines ma rked yellow indicate no existing regression tests cover them.
this helps developer figure out how to bet ter write future tests that can cover yellow lines to improve test coverage.
v. case study analysis and discussion we have evaluated several window code fixes and successfully run these through the onspot system to figure out its practical usefulness and applicability .
for illustration purpose and demonstrate the developer s experience we shall tak e one representative w indows security fix .
this security fix modifies the string decoding function for asn.
standard implementation in the windows msasn .dll .
the fix detects for the null in the string encoding and handles it appropriately during parsing in lower level asn decode string functions.
this is a typical security fix and on average the numbers calculated should be valid for other fixes in the same security category with very little variation.
we used amd dual core 8gb ram machine as a developer box that was connected to coverage build test system s. to evaluate the various characteristics o f the onspot model proposed earlier we set four main evaluation criteria .. a. what was the average time to identify relevant tests during code edits and how it varies with increasing component scope in onspot ?
as the developer compiles the fix ons pot starts building up the test selecti on for the given ch ange .
from the entire window os regression tests onspot selected test jobs that covered the modified binary blocks of the fix in the new msasn1.dll.
each of these jobs could typically contain hundreds of test cases itself.
table time for identifying relevant tests in onspot scope of tests avg.
time s for selecttest of tci relevant tests wincore security crypto msasn1 as shown in table the time taken for selecttest increased expectedly as the test scope increased from smaller component msasn1.dll to the entire windows core but the interesting aspect to note wa s that the number of tci increased in multiple s of ten s in figure source centric view with overlayed test results figure test centric view 996comparison to just a second increase in allowed time for selecttests.
it was critical to show developer how his compilable code changes impact the test selection.
our experience with onspot demonstrated that large number of re levant regression tests that were not visible before at compile time were selected and shown in a light weight and quicker fashion wit h lower idle time f or developer from sec .
b. how diverse the test selection became across the system ?
the relevant tests selected belonged to d iverse set of components across windows core like kernel networking stor age file systems etc.
this provided an opportunity for substantially broader coverage across diverse components at development time than possible with unit regression tests of one component msasn1 alone.
in this fix test selection came from a scope of around window components.
c. how the test covergage increased with onspot?
table tests and scope contributing to coverage the developer can then look at the coverage provided by the test jobs and also at the number of tests that can run.
he can view the tests relative to the source line and then runs and selects these tests for running and retrieving test results.
nearly of the relevant tests had at least of the coverage for the fix.
further at most of the code changes in this fix had some sort of regression tests covering for it which was better than coverage alone with msasn1 tests only.
interestingly as the component scope for the tests increases we see that the coverage ratio increases as well.
this clearly demonstrated the advantage with onspot system that through these additional regression tests it provide d more coverage at compile tim e that would not have been possible with component specific tests only.
d. what percentage of the tests could run in r easonable time during code editing ?
one of the critical requirements for the onspot system to be practically useful was to have large proportion of selected tests that could complete the execution run in reasonable time as the code changes became compilable.
as per figure it turned out to be an encouraging percentage and clearly demonstrated that nearly half of the regression tests could provid e quicker feedback during code edits intervals of seconds or more and nearly a quarter of the tests for code edits intervals of seconds.
furthermore we learnt that by running these tests which compl ete execution within seconds it was still possible to achieve fix coverage of percent that was closer to the maximum coverage of percent if all the regression tests would have run.
the choice of the right size of code editing interval depends on how the deve loper writes the cod e and if there are regression tests that can complete within that time.
since we have evaluated thousands of windows core os regression tests we are confident that for regression test suites of such scale there will always be substantial number of test s that can complete within the preferred code editing intervals.
figure percentage of tests completing under varying code editing intervals with achieved coverage ratio vi.
conclusion we have provide d a simple lightweight model to bring distant regressio n testing at compile time to help developer detect and prevent bug s at the moment the change is introduced in a real software.
by overlaying test results coverage ratio over the changed source lines the developer has be tter comprehension of the effect of the code changes on the test results and wider selection of tests to run to achieve higher coverage than possible with local unit or component only tests we believe that organizations with complex and huge test collatera l should employ onspot system to detect possible test failures early to avoid later costs.
our experience with onspot shows that it s practically manageable and helpful for developers to provide regression test feedb ack during reasonable code editing inter vals.