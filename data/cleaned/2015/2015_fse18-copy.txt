large scale study of substitutability in the presence of effects jackson maddox iowa state university usa jlmaddox iastate.eduyuheng long google inc. usa csgzlong iastate.eduhridesh rajan iowa state university usa hridesh iastate.edu abstract a majority of modern software is constructed using languages that compute by producing side effects such as reading writing from to files throwing exceptions acquiring locks etc.
to understand a piece of software e.g.
a class it is important for a developer to understand its side effects.
similarly to replace a class with another it is important to understand whether the replacement is a safe substitution for the former in terms of its behavior a property known as substitutability because mismatch may lead to bugs.
the problem is especially severe for superclass subclass pairs since at runtime an instance of the subclass may be used in the client code where a superclass is mentioned.
despite the importance of this property we do not yet know whether substitutability w.r.t.
effects between subclass and superclass is preserved in the wild and if not what sorts of substitutability violations are common and what is the impact of such violations.
this paper conducts a large scale study on over million java classes in order to compare the effects of the methods of subclasses and superclasses in practice.
our comprehensive study considers the exception synchronization i o and method call effects.
it reveals that in pairs with effects only have the same effects and of submethods have more effects and the effects of a large percentage of submethods cannot be inferred from the supermethod.
ccs concepts software and its engineering software evolution empirical software validation maintaining software keywords substitutability side effects object oriented software engineering acm reference format jackson maddox yuheng long and hridesh rajan.
.
large scale study of substitutability in the presence of effects.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
https this work was done when the author was at iowa state university.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction a huge amount of software has been written in object oriented languages such as java c and c .
these languages frequently contain methods with side effects in order to perform work.
side effects can include a variety of operations such as throwing exceptions acquiring a lock and reading from a file.
inheritance is another frequently used feature and is often used to organize and modularize code by subtyping a class and overriding methods.
with these two features understanding how to safely use classes or apis requires understanding both the methods side effects and the side effects of any submethods that may override them.
this exhaustively is difficult for two reasons.
first determining a single method s side effects requires delving into the implementation of it and any other methods it may call.
secondly inheritance hierarchies mean re this process again for each overriding submethod due to polymorphism.
this process is highly simplified if we assume that the liskov substitution principle holds.
the principle says that a subtype should be able to replace a supertype without changing the supertype s properties such as its correctness or as is this paper s concern its side effects.
under this assumption we would not need to examine the submethods.
this leads us to ask several questions.
is this principle being upheld in practice?
if not in what ways is the principle being violated?
are the violations problematic and if so how?
this paper s focus is on answering these questions.
to see why violating substitutability is a problem consider the following example.
1class services map integer object map synchronized void addservice int id object service if map .
containskey id return map .
put id service from this implementation we can infer that the addservice method is thread safe due to the synchronized keyword.
it also does not throw exceptions so there is no error case to handle.
we might then have a client of this class such as the one below 1services s app .
getserviceslist 2s.
addservice service0 the client retrieves a services instance from a factory and adds a service .
it can be executed multiple times.
now suppose the app.getserviceslist method returned a subclass 1class trackedservices extends services override void addservice int id object service if map .
containskey id throw new illegalargument map .
put id service configfile .
println id service immediately we see several unexpected behavioral differences.
firstly if our client ran twice it would now unexpectedly crash with illegalargument since the 0thid was added after the first run.
secondly other clients may run concurrently and require threadesec fse november lake buena vista fl usa maddox long and rajan safety to avoid data races which they do not get in this subclass.
finally the subclass outputs to a configuration file that could change program wide behavior.
clearly this subclass both violates substitutability and causes problems for its clients.
motivated by these problems we aim to answer the following research questions.
rq1 can we accurately infer a subclass s effects based solely on the superclass s implementation or do the subclasses often violate substitutability?
rq2 when violations occur how do the two implementations differ and what common patterns arise throughout all violations?
rq3 when violations occur what is the impact?
for example it could be the source of a substitutability bug or a code smell.
this paper investigates these questions on real world java projects hosted on github.
we present a comprehensive study comparing the effects of superclasses to their subclasses in these projects using the boa infrastructure .
boa allows us to examine the java projects asts to determine the side effects of a method and compare them to its super and submethods .
to generalize our findings this study focuses on a broad range of effect kinds including exception synchronization and i o and method call effects.
we find that only method pairs have the same effects and of submethods have more effects than their supermethod when considering the effect types independently.
finally when analyzing method pairs in terms of these effects we confirm the above a large percentage of the effects of submethods cannot be inferred through the supermethod s implementation when at least one of them has an effect.
an artifact including the source and results is made available at the rest of this paper will discuss our methodology results threats to validity the related work future work and conclude.
methodology our substitutability study was conducted in two phases automated analysis followed by manual inspection.
for the first we analyzed boa s september github dataset containing java projects and excluding forks .
our analysis collected effect information on each non abstract method made scalable by using a lightweight syntax directed effect inference based on .
after this process the analysis pairs each non private non static nonconstructor method with the one they override if any forming many method pairs containing a submethod andsupermethod .
this pairing considers normal sub superclass pairs and includes nested non anonymous classes but not default interface methods as the boa infrastructure uses java .
.
each pair is then categorized by comparing the effects of the two methods with each other.
the exact categories used depend on the effect being examined.
we then use the pair categorization in order to investigate the effect differences in method pairs and later examine a few categories that suggest substitutability violations.
table shows the counts of examined projects classes and more in the dataset.
to make our analyses more accurate we added a few exceptions firstly pairs containing abstract methods are ignored since there isno implementation to compare with.
files containing junit tests identified by use of the test annotation are also ignored in an effort to skip mock objects used only for testing.
finally we found that many projects have duplicate class files identified by the package name plus the file name.
in these cases we took the file that was last modified or if both were modified in the same commit we discard both.
we assume the last modified file is the latest version of it but if the duplicates are modified in the same commit it can indicate that they are separate conflictingly named parts of the program.
the reasoning for this is that we want to avoid counting a class twice and to be sure that a given pair is correctly identified.
while our results do not filter out small projects we found that so does not change any of the trends in our results.
table summary of the data studied metric count of projects of source files of classes of methods of method pairs of project ast nodes the second phase consisted of studying cases sampled from the analysis output in order to better understand certain categories of method pairs.
we are interested in seeing if certain categories suspected of substitutability violations are in fact problematic.
in order to do this the analysis output was first filtered based on the desired category and then randomized.
from this we randomly gather samples discarding those pairs which cannot be found due to for example the repository having been deleted.
for each sample we manually inspected and compared the implementations of the sub and supermethods to see if the submethod s effects cannot be inferred from the supermethod s body a substitutability violation .
transitive effects from methods calls were also considered where possible.
if a substitutability violation is discovered we define a call sequence that if executed could trigger the effect difference.
an example of such a violation would be a call sequence causing the submethod to throw an exception that the supermethod will never throw.
the resulting set of violations was then examined in order to discover the most common patterns making them up.
this case study procedure was conducted by the first author and then the second author confirmed the labels given to each of the samples.
the side effects that this study focuses on are exceptions synchronization i o operations and method calls.
the reason for studying method calls as an effect is twofold.
first it is an important effect kind well explored .
second our effect inference tool ignores transitive effects from method calls so that it can scale up to very large datasets.
any transitive call analysis would also be very imprecise due to both the open world assumption and dynamic dispatch .
the method call effect provides a well understood technique for handling it by treating transitive calls abstractly in both the super and the subclass.
for the rest of this section we detail how each of these side effects were analyzed.
in order to study exception effects methods were assigned an exception effect if they contain a throw statement .
our effectlarge scale study of effect substitutability esec fse november lake buena vista fl usa inference then attempts to find the type of each thrown exception and if successful adds it to the method s set of thrown exception types.
otherwise the exception is given a generic unknown type and added to the set but this occurred in only of method pairs with an exception effect.
exceptions that may be thrown implicitly by e.g.accessing a null object or accessing an array out of its bounds are ignored as is standard in exception analyses.
for synchronization we differentiate between acquiring and releasing locks.
the analysis considers the synchronized keyword either as a modifier or block to be both acquiring and releasing a lock.
we also consider java s lock interface its implementations and the semaphore class.
in order to include the fine grain lock objects the analysis examines each method call.
from this it attempts to infer the type of the callee and when successful looks up the type and method in a table and assigns the appropriate effect if any.
in methods with i o operations we distinguish between operations related to input and output.
we consider a list of java standard i o classes and interfaces and assign an effect to each of these types methods.
in addition operations on system.out system.err and system.in are added as special cases to the analysis.
similarly to synchronization this analysis attempts to infer the type of object called and assign the appropriate effect.
finally for the method call effect we consider each call expression to be a pair consisting of a category and the method name standard in the intra procedural phase of effect inferences .
these categories are this super and other .
the this category means the callee is the object this and similarly for super while theother category covers the remaining method calls.
each of these pairs are added to a set representing the method s call effect.
results this section describes the results of our large scale study for each of the aforementioned side effects.
table lists the number of methods in the dataset whose method bodies contain different combinations of explicit side effects.
the table shows that about of methods have no studied side effects and at least have side effects other than method calls.
table effect kinds per concrete method exception sync i o call dataset methods total methods table shows data for submethod and supermethod pairs that have at least one effect.
the submethod has more effects categorymeans the submethod has more effects than the supermethod in at least one side effect kind and none where the supermethod has more .
for example a submethod reading from a file where the supermethod does not would fit this category.
the data shows that for a large number of cases the submethod has more effects compared to the supermethod.
table effect comparison of pairs with effects submethod has more effects supermethod has more effects both have same effects all others total pairs next we examine each side effect over all methods in the dataset and then move onto examining pairs of sub and supermethods.
for each pair we compare the effects of the paired methods in order to see how many have substitutability violations and verify this by examining a small subset of pairs in more detail.
.
exceptions we begin our examination of exception effects by first looking at how many individual methods explicitly throw an exception.
these results are shown in table which categorizes methods by the number of different exception types they throw.
in this table all private methods are grouped together including private constructors and static methods.
the next columns denote nonprivate static methods and constructors respectively and the other column denotes all remaining methods.
our results show that the vast majority of methods do not explicitly throw an exception.
for those that do most will only throw a single exception type regardless of the type of method.
proportionally private and static methods throw exceptions more often but there are far more methods in the other category throwing exceptions than those two combined.
these results are so far consistent with the previously published study on purity analyses although our study considers a thousand times more projects and later on other effect kinds.
table number exceptions types thrown per method kind np means non private and init means constructor types private np static np init other 14m 12m 14m 99m .2m 961k 509k .6m 86k 92k 39k 462k 14k 12k 98k total we now turn to examine method pairs where at least one of the methods contains a throws expression.
table shows our comparison of the sub and supermethods for these pairs.
each pair s methods were compared by the set of exception types each throws.
the pair was then placed into one of categories depending on both how the submethod s set s cardinality compared to the supermethod s and whether one was a subset of the other.
in eachesec fse november lake buena vista fl usa maddox long and rajan category subrefers to the set of exception types the submethod throws and super the set of exceptions the supermethod throws.
the pairs themselves are additionally split into an expected and unexpected grouping.
the term expected refers to pairs where the set of exceptions thrown in the submethod are covered by either the supermethod implementation its throws clause or both.
listing provides an example of this.
in this example the submethod throws illegalargument andioexception .
however it is consistent with the supermethod because the supermethod throws illegalargument and the throws clause declares that it may throw ioexception .
thus it would be categorized as expected .
1class super void m object x throws ioexception if x null throw new illegalargument 6class sub extends super override void m object x throws ioexception if x null throw new illegalargument else throw new ioexception listing example pair where submethod s exceptions are expected table exception pair types s sub p super categorypairs unexpected expected total s p 350k 350k s1p s p s p 163k 61k 224k s2p s p s p 103k 102k s p s p 34k 41k total pairs our results indicate that of submethods may be unsafe substitutes of the superclass equivalent when considering only the method implementations.
when including the throws clause this drops to which is still a large percentage of these pairs.
this finding motivates further study to understand whether these cases indicate substitutability violations.
to do this we start by examining what types of exceptions are most common in this situation.
finding in one quarter of the exception pairs submethod effects cannot be inferred from the supermethod s body or throws clause.
we will see similar results for the other three effect kinds.
implication programmers and tools should consider submethod implementations when analyzing a method s effects.
figure shows exceptions most commonly thrown by pairs where sub super .
notice that several of these exceptions are related to preconditions such as illegalargument andillegalstate .
this may indicate that these submethods have stronger preconditions than their supermethod which is problematic from the viewpoint of supertype abstraction .
another top exception unsupportedoperation is intended for an operation a class cannot support.
submethods throwing this exception likely indicate a violation of substitutability in which a client may expect a class to support an operation that it does not figure top exceptions thrown when the submethod throws more types exception suffix omitted due to being a subclass instance.
the case study investigates these two groups in more detail.
finally runtimeexception the most common is a very generic exception to throw and is used for a variety of different purposes.
in most cases a subclass of this exception should be thrown instead so that clients catching the exception have some idea of what the particular error is.
thus throwing this exception likely indicates a code smell.
even when normalizing figure by project i.e.each project can only count towards an exception runtimeexception is still the top exception type.
this indicates that these kinds of pairs are not specific to a few large projects but many.
.
.
are exception substitutability violations problematic?
to understand this we start by examining exceptions related to preconditions whose submethods throw more types of exceptions than the supermethod.
this group is further filtered so that the method pair must throw at least one of illegalargumentexception nullpoi nterexception illegalstateexception orindexoutofbounds exception in addition to the array and string variants of the out ofbounds exception.
from this set we sample method pairs that we examine for substitutability violations.
in the context of exceptions this means that we can construct a call sequence that would cause the submethod to throw an exception while the supermethod either throws a different or no exception.
we find that of these cases indicate a violation.
in general most of the violations have at least one of common patterns.
the first is brittle parameters either via instanceof cases or restricting the allowed range of values cases .
the supermethods generally do not have any explicit parameter restrictions in comparison and do not throw the precondition related exceptions the submethods throw.
the second pattern consists of state related exceptions almost completely characterized by illegalstateexception being thrown encompassing cases.
the general pattern for these is that the submethod checks to ensure the object state is valid while the supermethod has no such checks in place mostly due to not having the extra state that the subclass has.
for the third group cases the sub and supermethods have the same constraints but handle it differently.
for examplelarge scale study of effect substitutability esec fse november lake buena vista fl usa a supermethod may just return on a null argument while the submethod instead throws nullpointerexception .
this characterization leaves violations of which fit into multiple of the above patterns and that fit into none of the above.
we will now examine some of the violations in more detail.
the first pair from we examine is a case of a brittle parameter shown in listing and is from the java swing library.
the superclass inputmap accepts any other inputmap or subclass of it as a parent in the setparent method.
one may reasonably expect that given any object of that type we can assign the parent to be any other object of the same type.
however this assumption does not hold with a subclass.
instead componentinputmap only accepts other instances of that subclass as parent.
clearly we cannot rely on the static type to tell us what the potential effects of setparent are nor do we intuitively expect it to ever throw an exception.
1class inputmap public void setparent inputmap parentmap parent parentmap 5class componentinputmap extends inputmap public void setparent inputmap parentmap if parentmap !
null !
parentmap instanceof componentinputmap throw new illegalargumentexception ... listing preconditions added by the subclass our second example from shown in listing is a case where the submethod has a state related precondition via a switch statement.
the non constant static variables referenced in these methods are all set by the client of these classes.
while the superclass may throw indexoutofboundsexception iftagis set incorrectly the submethod may instead throw illegalstateexception if it cannot handle a certain constant object s tag.
what makes this example interesting is that clients of the superclass in the project avoid calling the submethod by using instanceof to check the runtime type of their attribute variable.
however checking the other samples shows that this pattern does not appear indicating that it is rare for a client to check runtime types explicitly before calling a method when it contains a substitutability violation.
1abstract class attribute public string tostring return constants .
attribute names 5class constantvalue extends attribute public string tostring constant c constant pool .
getconstant constantvalue index switch c. gettag case constants .
constant long buf ... break ... default throw new illegalstateexception ... listing different handling of the same precondition our results show that only in one case do clients use reflection viainstanceof to avoid an exception being thrown by a subtype method.
most clients do not handle substitutability violations explicitly by checking the object runtime type and that is an indication that violations can lead to mostly latent bugs.
we also sampled method pairs where the submethod throws more exceptions than its supermethod and also throws unsupported operationexception .all of these pairs violated substitutability.when examining the submethods we find patterns.
for examples the exception is used to restrict changes and notify the client.
this is to either make the subclass immutable or to enforce a specific container size in one case.
for another examples this exception is thrown due to the submethod being more specialized and unable to support an operation as stated in either javadoc or the exception message itself.
thirdly in only case the submethod uses unsupportedoperation as a to do that was never completed.
finally in the remaining examples no explanation is given through method documentation or as an exception message making it difficult to ascertain why the submethod is unimplemented.
finding program patterns where the submethod appears to have more effects than the supermethod are often indicators of substitutability violations.
implication code smell detection tools can accurately warn about substitutability violations from submethods that explicitly throw exceptions not found in the supermethod.
.
.
are developers documenting exception substitutability violations?
we found that the majority of the time the answer to this question was no though a number of cases were documented.
we examined the context in which these method pair implementations exist in order to see if developers are aware of and document substitutability violations.
in cases the supermethod s javadoc declares that the method may throw the submethod s exceptions where of these supermethods include a throws clause for the unchecked exceptions.
however for the remaining it is impossible to infer the exception side effect from the supermethod alone.
in cases the subclass javadoc alone states either the exception or at least the precondition.
the javadocs in these submethods indicate potential points of code smell where the supermethod s javadoc simply was not updated.
finally while javadocs do not provide information about either the exception or preconditions in the remaining cases at least provide a exception message though do not providing no information on why the exception occurred.
beyond looking at javadocs and exception messages we found evidence that some of the method pairs indicate problems or bugs.
in one case the javadoc of both the sub and supermethods is incorrect for the submethod s implementation.
for example in a repository clone of the jfreechart library the javadoc for vectorrend erer.finddomainbounds states that the null argument is permitted and indeed it is in the supermethod.
however the submethod throws illegalargumentexception if the argument is null indicating that a mistake may have been made in the submethod s implementation.
a similar situation was found in a repository that contains a copy of the java swing library.
specifically thetitledborder.getbaseline method whose javadoc indicates that the submethod expects its supermethod javadoc to say that nullpointerexception may be thrown via the inheritdoc but it does not.
one other sample has a similar inconsistency between the sub and supermethod documentation.
we also found two other cases where the submethod s precondition is likely valid in the supermethod.
however the supermethod does not check that the precondition is true.
for example in one repository a clone of gnu classpath the bandedsamplemodel.
getdataelement submethod checks the bounds of the argumentsesec fse november lake buena vista fl usa maddox long and rajan specifying an x y coordinate.
however the supermethod does not though some other methods in the superclass do bounds checking.
.
synchronization next we examine synchronization effects either via one of the java standard library locks or using the synchronized keyword.
methods may have no locking effect acquire or release a lock or do both.
no distinction is made between what object is used for the lock.
this is because many classes may use multiple different lock objects to ensure more fine grained thread safety so it will not necessarily provide useful information when examining these methods.
however we group these methods and pairs by how finegrained their locks themselves are.
that is whether they use a lock object finest synchronized blocks fine or just the synchronized method modifier coarse .
first we look at individual methods in table .
the columns represent the aforementioned lock grouping based on how fine grained the lock is and the rows represent whether the method acquires releases or both acquires and releases a lock.
note that the block column due to how synchronized works in java always acquires and releases the lock.
secondly the modifier column represents both methods that use only the synchronized modifier and those who have no synchronization effects.
the entries with n a indicate that the entry is not applicable for the group.
the vast majority of methods with synchronization use the keyword likely due to ease of use.
these methods split almost evenly between using synchronized blocks and the method modifier.
for those using a lock object from the standard library most both acquire and release locks indicating that they might not rely on other methods to release or acquire the necessary locks.
however of methods with lock objects seem to expect a different method to acquire or release a lock indicating more complex locking scenarios.
table synchronization types per method type lock block modifier none n a n a 145m acquire n a n a release n a n a both 94k .4m .5m total next is to examine the method pairs with synchronization shown in table .
similar to the previous table method pairs are grouped based on how fine grained their locks are with the exception that modifier does not include pairs without synchronization.
in the table categories a method mhaving more of an effect than the other m indicates that m has no effect and mdoes or m acquires or releases a lock and mdoes both.
the same category similarly means that the sub and supermethods have the same kind of synchronization effect and different means one method acquires a lock while the other releases it.
this last row is only applicable to locks since the synchronized keyword includes both acquire and release.
the different category would likely indicate a bug but since no pair fit into this category we cannot examine this idea further.
however a significant percentage of pairs have a supermethod with synchronization and a submethod that does not and maytable synchronization pair types categorypairs lock block modifier total super more 33k 24k 58k sub more 36k 44k 82k same 18k 27k 45k different n a n a total indicate the presence of substitutability bugs.
consider for example a supermethod that is thread safe but a submethod that is not.
if a client expects the superclass but gets a subclass it may assume it is thread safe and use the object among multiple threads.
this leads to race conditions and visibility bugs.
visibility bugs occur when a thread caches a value it updated without making it available to other threads leading to stale values and inconsistent object state.
.
.
are there synchronization substitutability violations and what kinds?
to understand this we sampled pairs where the supermethod has more synchronization effects than its submethod out of 58k cases.
the idea behind this is that perhaps synchronization in the subclass has been forgotten causing a client that believes an object with the static type of the superclass to be thread safe when it is not.
will two threads that operate safely on the superclass cause a potential race condition or state visibility bug when operating on the subclass?
we assume that the two threads initially obtained a properly published instance of the object in question.
we also assume the first thread knows of the subclass object while the second thread is only aware of the superclass.
out of the selection or have a substitutability violation caused via a race condition or value visibility problem.
of these cases of them are violations that will cause visibility problems of some sort such as the fields of the subclass getting out of sync across threads.
then in cases two threads calling the submethod can end up different things due to a visibility issue caused during execution of the call sequence.
of the violations from the aforementioned cases require one of the threads to be aware of the subclass and call subclass specific methods.
then for cases the violation leads to a race condition such as when manipulating a thread unsafe collection or other object.
finally the last violation is due to the supermethod being synchronized but only throwing unsupportedoperation whereas the submethod is unsafe.
1class preparedstatement void setncharacterstream int parameterindex reader reader long length synchronized checkclosed ... 6class jdbc4serverpreparedstatement 7extends serverpreparedstatement extends preparedstatement void setncharacterstream int parameterindex reader reader long length ... both calls supposedly thread safe bindvalue binding getbinding parameterindex true settype binding mysqldefs .
field type blob binding .
value reader ... listing reference visibility race conditionlarge scale study of effect substitutability esec fse november lake buena vista fl usa let us now examine two of these substitutability violations.
the first from as shown in listing contains a supermethod that enters a synchronized block does some work and exits.
in comparison the submethod has no explicit synchronization.
instead it calls multiple methods that are already thread safe e.g.getbinding and settype .
however after this it updates a bindvalue structure that is stored in its superclass s state without synchronization.
so if two threads both call this method on the same subclass instance they may see different versions of the same or other bindvalue s. whether this leads to a bug depends on what the threads do or do not do next.
for example if thread attempts to retrieve the binding thread modified and thread has not entered a lock by then thread may receive outdated information.
the second example from is a case of unsafe operations on collections and shown in listing .
in the superclass most methods are marked as synchronized except for several setters not shown .
however the subclass has no synchronization for its hashset prefixes .
in a case where two threads have an instance of the subclass and one knows the runtime type that thread may add to the collection and call the addabox method.
however when the second thread calls the sub method as well it may see an inconsistent or outdated version of the collection that could cause a call that would otherwise pass the filtering to fail.
1class linkfilterdefault synchronized void addabox node nx int i adduri nx i synchronized void adduri node nx int i ... 6class linkfilterprefix extends linkfilterdefault void addprefix string prefix prefixes .
add prefix void addabox node nx int i boolean found false for string prefix prefixes a hashset in sublass if nx .
tostring .
startswith prefix found true if found super .
adduri nx i listing unsafe operations now that we have examined the violations let us look at the cases with no synchronization violation.
in the submethod is either trivial returns empty method throws exception or delegates the call to the supermethod with no changes in logic.
for more cases the submethod delegates calls to an object that either itself delegates calls or is thread safe.
in cases the submethod conducts only thread safe operations on state such as calling a thread safe method and while it may be possible to use them in a way that causes strange results they do not appear to contain race conditions.
then in cases the supermethod has very specific locking behavior and alone may not be intended to be thread safe.
finally case s safety depends on something a user would implement and contain methods throwing unsupportedoperation .
.
.
do developers document synchronization substitutability violations?
of the violations in two cases the thread safe superclass was from the awt library and the unsafe subclass from the swing library.
since the swing library was built on top of the awt library and unlike awt did not attempt to be thread safe we consider these violations to not be bugs.
note that this determination required outside knowledge to understand the thread safety of the particular subclass.
in fact we found no documentation of the thread safety properties of any pair of the classes we studiedin their javadocs.
this suggests a problem where a client of a superclass may assume certain operations are thread safe whereas the subclass may have different ideas.
from these cases subtle race conditions or value visibility problems could appear that might not be discovered until much later.
for the remaining pairs with violations it is more likely that the thread safety of the subclass was not on the implementer s mind as there is no indication of locks or explicitly thread safe collections.
finding there is sparse to no documentation on class thread safety guarantees including between a sub and supertype.
it can only be inferred from general knowledge of the project or examining the implementation.
implication tools are needed first to help document synchronization guarantees and second warn on mismatches between the sub and supermethods based on these guarantees for large concurrent programs.
.
i o in this section we categorize methods based on whether they have input output both or no i o operations.
table shows how common different i o operations are among all the methods analyzed.
similarly to exceptions and synchronization the majority do not contain i o operations.
it turns out that the number of methods with output operations is about .7for private methods .6for non private constructors .3for non private statics and .2for the rest times the number of methods with input operations.
table i o effects per method np means non private and init means constructor io type private np static np init other no i o 14m 12m 15m 102m output 664k 878k 94k .0m input 205k 107k 21k 351k both 79k 124k 201k total in order to investigate why there were so many more write operations across all types of methods we examined what output i o objects were used most.
this was done by for each type counting the number of methods that do an i o operation on an instance of it.
we also make a distinction between any i o objects and the standard system.out andsystem.err objects.
as figure shows system.out is the most commonly used by far followed by printwriter combined making up over of output.
even if we ignore the percentage of methods with console output making the assumption they only used system.out orsystem.err writes will still outnumber reads in all cases.
now we discuss the comparison between method pairs with i o effects displayed in table .
like with synchronization the categories for one method mhaving more i o effects than the other call m refers to either mhaving an i o effect and m not or mhaving both read and write while m either write or reads.
method pairs are grouped into one of three categories in the table based on what kind of i o objects they use.
if either method uses console i o such as the console class or system.out they are placed in the console category.
otherwise if either uses file i oesec fse november lake buena vista fl usa maddox long and rajan figure top i o output types objects then they are placed in file .
finally the bus category signifies streams readers and writers referring to how these objects may be used to move bytes from one stream to another.
this last category includes pairs with file and console i o if the streams are connected to a file or the standard output input streams.
however this is not necessarily the case for all of these objects.
table i o pair types categorypairs console file bus total sub less 70k 70k sub more 36k 11k 34k 82k same 12k 26k 39k different total the table shows a marked difference between console and file i o with the rest where the first two pairs have a majority of submethods with more i o effects.
these types of pairs may indicate substitutability violations such as being able to crash the submethod but not the supermethod or with different exceptions due to an i o error or to cause unexpected output in the submethod.
we investigate these types of pairs further in the i o case study.
finding the majority of method pair console and file based i o is located in submethods.
implication tools that infer a call s potential i o effects will benefit from examining methods overriding the callee.
.
.
what kinds of i o substitutability violations are present?
as before we gather samples where the submethod has more i o effects than the supermethod of which there are 82k pairs.
there are two types of substitutability violations we consider.
first being if the submethod throws an exception caused by an i o error that in the supermethod causes a different or no exception to be thrown.
secondly whether there is an output difference e.g.the submethod outputs debugging info where the supermethod outputs nothing ?
overall or of the selected cases has at least one of these violations.
of these are due to differing behavior from an i o operation throwing an exception.
the remaining are due to output differences from directly using system.out orsystem.err .for those examples in which a violation is caused by a thrown exception all but are due to a pattern of the submethod containing an implementation while the supermethod is trivial simple return throws an exception or empty .
in two of these cases we can cause the exception to occur by calling a shutdown or similarly named method.
for the rest the difference can be seen by providing an illegal file name or already closed stream to operate on.
the example listing from is one of the i o violations due to a thrown exception.
the supermethod only closes the stream and then throws a particular exception also indirectly outputting to system.out if the call to close throws.
however the submethod during its execution outputs to the provided stream.
now when comparing the sub and supermethods in the case where the stream oshas already been closed we observe the following difference the supermethod will simply output the error to system.out but the submethod will throw ioexception when it writes to the stream.
of course any client of these methods will need to handle both checked exceptions that the method declares.
however anyone who uses the superclass s implementation as a point of reference may be misdirected without also examining subclass implementations.
the problem is exacerbated by the other examples where instead the supermethod is trivial which could be seen as a hint to look elsewhere for the true effects of the method.
1abstract class imageparser void writeimage bufferedimage src outputstream os map params throws imagewriteexception ioexception try os.
close catch exception e debug .
debug e output to system .out throw new imagewriteexception ... 8class gifimageparser extends imageparser void writeimage bufferedimage src outputstream os map params throws imagewriteexception ioexception ... os.
write x47 ... listing i o failure causing an exception in subclass in many other cases the submethod instead produces from the client s perspective undesirable i o output.
one example from is listing where the supermethod simply updates several class fields.
the submethod operates similarly but its operations can throw an exception in which case it catches the exception and disables some checks.
however notice that in addition to this the submethod outputs a message via system.err .
1abstract class sampler void setinput image inimage this .
inimage inimage this .
inwidth inimage .
getwidth ... 7class clip extends sampler void setinput image inimage ... try ... inimgscaler inimage .
getwcs .
getscaler inverse can throw transformationexception inimgscalerinv scaler inimgscalar .
inverse catch transformationexception e system .
err .
println ... pixelcheck false straddlecheck false listing i o output differencelarge scale study of effect substitutability esec fse november lake buena vista fl usa a client of the supertype will not notice that output had been produced.
this subtype s output would cause corruption in consolebased application output where the console is the user interface or is used to print results.
a similar situation would occur in applications using logging facilities rather than writing to the console.
similar patterns abound in the other related output violations.
in cases the output is due to detecting some sort of failure or announcing a warning.
a more common pattern cases are cases where the console output appears to consist of debug related statements.
that is statements that do not indicate errors nor necessarily useful information for a user.
a single case contains both debugging and failure messages.
finally the remaining come from a console based projects for which the output is neither apparent debugging or failure statements.
this leave cases that do not use system.out orsystem.err but still present output differences.
in only one of these the subclass transforms the input via another stream but the remaining examples generally consist of straightforward string output to either a stream or writer which doesn t throw ioexception object.
for those examples that turned out not to be violations are due to i o operations that will never throw an exception.
these i o operations also either not result in actual i o occurring or produce the same output as the supermethod when considering transitive calls.
an example of this is writing to a non subclassed stringwriter which simply builds a string for its client.
then there are only occurrences of system.out statements hidden behind a final debug flag set to false.
then extend an existing java stream class which relies on abstract method calls to work.
finally the last case contains what appears to be an output difference with no apparent way to trigger it from the code provided.
.
.
are these i o substitutability violations problematic?
when we examine the i o violations caused by an exception we note that in each of them the exception effect can be inferred from the supermethod signature through the supermethod throws clause in addition to the javadoc in cases .
this suggests that exceptions thrown from i o substitutability violations are not necessarily a problem at least in java with checked exceptions such as ioexception .
however violations due to output differences paint a different story.
in general the biggest problems would likely be caused by the submethod corrupting output unexpectedly.
for example submethods appear to output debug or informational messages.
to provide an example an android app has a class chapterreader whose methods use system.out that outputs some informational messages when certain methods are called.
interestingly the class also uses the standard android logclass for other messages.
further examination shows that this class is one of two in the repository that use system.out while logis used the rest of the time.
this is an inconsistency in logging with the norm of the project indicating that the use of system.out is a code smell.
in cases the subclass i o difference appears to be intentional either due to it being a console based program or due to the subclass s purpose indicating the intention e.g.verboseobject vs.object .
other cases use system.out orsystem.err solely for reporting problems or warnings though it may still surprise a developer aware only of the superclass implementation.finding whether i o substitutability violations are problematic are often situation dependent.
implication tools intended to warn about i o substitutability violations should be able to take into account the method pair s context.
.
method calls this section analyzes method calls as effects starting with individual methods in table .
the table show that unlike the other effects most methods have at least one call and call or more different methods.
the reason for considering method calls is that a method s side effects includes the side effects that occur during both direct and indirect calls.
for example a submethod calling another that throws an exception that the supermethod directly throws in its body.
in this case the pair is nota substitutability violation due to the method call effect.
table method calls per method np means non private and init means constructor calls private np static np init other .3m .8m .8m 39m .5m .3m .4m 23m .1m .2m .5m 12m .1m .7m .2m 30m total next we briefly examine pairs with method calls in table .
the categories seen in this table are similar to those in table but with sets of method calls rather than exception types thrown.
of these pairs are cases where transitive effects of submethods can be inferred from their supermethod.
however that leaves the remaining of pairs in which this is not the case.
this strongly indicates that similarly to our findings for other effects relying on the supermethod implementation is not helpful for determining effects.
in general this table shows that method calls in sub super pairs have a wide variety of differences leaning towards the submethod calling more and different methods.
table method call pairs s sub p super s p 524k s1p s p 743k s p .9m s2p s p 903k s p 398k s p s p 516k total pairs table considers only pairs where the submethod has more effects in at least one category than the supermethod and no effects where the supermethod has more.
this table effectively lists pairs that are very likely to be substitutability violations even when side effects occurring via method calls are taken into account.
under these conditions we see a large number of method pairs backing our results in previous sections.
for example approximately 75k sync pairs qualify which is close to table s 82k pairs.esec fse november lake buena vista fl usa maddox long and rajan table pair kinds where submethod have more effects exception sync i o call pairs effect pairs finding even considering method calls a significant number of pairs contain submethod that has more effects.
this in particular indicates violations for exception and i o effects.
implication while transitive calls can be important examining only the bodies of a pair of methods is a good simplification to help find many substitutability violations.
.
threats to validity .
.
external validity.
as in all mining studies representativeness and dataset quality affect the study s validity.
we noted e.g.
that a number of repositories included the java standard library and hadoop codebases.
since we use boa s dataset the study is also limited to java projects with github repositories.
however because the dataset contains over 380k java projects we believe this is not a problem.
in our case study we randomly selected examples and narrowed this selection down to specific types of cases.
because of the limited number of cases we were able to analyze we cannot make broad generalizations.
however it should still bring to light some common patterns where substitutability violated.
.
.
internal validity.
notwithstanding bugs our analysis is precise in that if an effect is found in a method then that method can have such an effect as we define it ignoring infeasible paths.
however it is incomplete due to three reasons.
first the open world assumption we did not have access to standard or external library asts unless included in the project.
second in order to scale the analysis we do not consider inter procedural effects from method calls and instead consider method calls as a separate effect to mitigate this.
this allows us to take into account method calls without attempting to find the correct method implementation to add the call effects to the caller.
thirdly the type of a thrown exception or object whose method is being called cannot always be determined by the analysis.
for exceptions we mark these types as unknown which happened very rarely.
this means that side effect comparisons determined by the analysis between method pairs may be imprecise if either methods effects are incomplete.
we believe our mitigation strategies have helped to reduce these problems impact.
related work there have been many studies on and tools introduced to manage side effects commonly targeting exceptions and synchronization.there have been many studies examining different ways developers handled exceptions.
many of the results are similar to ours.
kechagia et al.
found of a set of crash traces in android applications were avoidable if exceptions had been documented .
another study showed java checked exceptions were often ignored.
a third study showed that about of bug reports in a number of large projects are related to exceptions.
others examined lock usage and or concurrency bugs.
in comparison we focus on whether substitutability is upheld and examined a much larger set of projects.
long liu and rajan introduced language features such as effect reflection to promote the effect analyses precision for dynamically dispatched method calls.
these works assume that the effects of the subclasses and superclasses are different.
the finding of our large scale study greatly supports their assumption.
to our knowledge there have been very few studies on substitutability.
pradel et al.
created a tool to automatically test for exception and synchronization violations by random testing of method pairs.
this was used to show that many widely used java classes violate substitutability in ways that for of cases lead to crashes.
this work has previously confirmed that developers do care about exception and synchronization substitutability violations.
another work examined cxf a web framework and found many problematic violations.
gordon et al.
introduced a tool to reason about gui usage .
they found developers frequently created unsafe subtypes by overriding ui safe methods with ones that are unsafe outside of the ui thread and that documentation on thread safety was scarce.
our study was larger scale considered more side effects confirms some of these previous findings and produced some of our own.
we also considered i o and method call effects which have not been studied by previous work.
in summary previous work has examined various side effects or developed tools to manage them but most do not consider substitutability and or are small scale studies.
this study in contrast examines 380k java projects focuses on substitutability and includes exception synchronization i o and method call side effects.
conclusion and future work this paper describes the first large scale empirical study of how inheritance and side effects interact in real world java projects.
our study is comprehensive and general.
it is based on four different effect kinds and studied more than 380k projects.
our results show that a large portion of method pairs that have effects violating substitutability.
we have also discussed various patterns of these pairs and their potential impacts on supertype clients.
in the future it would be interesting to extend our study into other effects such as memory read write .
we could also create ide extensions that warn developers about effect substitutability violations or create other tools to help manage them.