trem a tool for mining timed regular specifications from system traces lukas schmidt department of electrical and computer engineering university of waterloo waterloo on n2l 3g1 canada lfschmid uwaterloo.caapurva narayan department of electrical and computer engineering university of waterloo waterloo on n2l 3g1 canada apurva.narayan uwaterloo.casebastian fischmeister department of electrical and computer engineering university of waterloo waterloo on n2l 3g1 canada sfischme uwaterloo.ca abstract software specifications are useful for software validation model checking runtime verification debugging monitoring etc.
in context of safety critical real time systems temporalproperties play an important role.
however temporal properties are rarely present due to the complexity and evolutionary nature of software systems.
we propose timed regular expression mining trem a hosted tool for specification mining using timed regular expressions tres .
it is designed for easy and robust mining of dominant temporal properties.
trem uses an abstract structureof the property the framework constructs a finite state machine to serve as an acceptor .
trem is scalable easy to access use and platform independent specification mining framework.
the tool is tested on industrial strength software system traces such as the qnx real time operating system using traces with morethan .
million entries.
the tool demonstration video can be accessed here youtu.be csd aj3 lh8 index t erms specification mining timed regular expressions real time systems i. i ntroduction temporal behavior of programs is an extensively studied topic .
recently the idea of mining likely temporal properties of programs from system traces has become pop ular .
many programs lack formal temporal specifications and mined specifications are therefore valuable since they can be used for a wide variety of activities in the software develop ment life cycle sdlc .
these activities include softwaretesting automated program verification anomaly de tection debugging etc.
critical and commonly occurring behavioral patterns are typically provided to the mining frameworks which then mine system specifications of that form.
the mining techniquesidentify a set of specifications that are satisfied by traces w.r.t.certain criteria.
further mined specifications can assist auto mated verification techniques because they provide an easyand user friendly way to describe a programs specifications.
ii.
r ela ted work specification mining has gained significant attention in recent times.
different techniques have been developed formining specifications from templates expressed using regular expressions l tl stl and other custom formats.there are numerous temporal property mining tools .
as argued by ammons et.
al.
automated verification techniques are unlikely to bewidely adopted unless cheaper and easier ways of formulating specifications are developed.
a vast majority of tools for mining of temporal properties infer properties in the form of state machines.
these tools learn a single complex state machine instantly and extractsimpler properties from it.
in they learn a state machinewhich captures both temporal properties and data depen dencies.
these find utility in identifying errors and refiningspecifications.
these also find use in automatic verificationtools to find bugs in the program execution.
these approaches suffer from one main drawbacks.
mining of a single state machine from system traces is a np hard problem .
another work based on the intuition that frequently occurring behavior that matches temporal patterns are likely to be true is the foundation of peracotta .
specifications refer to properties of systems for example a specification of a typical smart phone might be within sec onds of pushing the power button the screen should turn on .such specifications find applications in various domains forexample anomaly detection in networks specification based testing in software development and formal verificationin hardware .
the work on timed regular expression tre mining by cutulenco et.
al.
is the backbone of this tool.the work is similar to other temporal mining frameworks suchas montre .
this paper presents trem a hosted specification mining platform designed for easy and robust mining of temporalproperties.
the automatic generation of properties is useful forfinding missing program specifications debugging during thesoftware development life cycle exploration understanding oflegacy or undocumented software and anomaly detection.
section iii discusses the design and work flow of trem.
section iv provides an overview of the implied methodology of trem through an industrial strength case study.
finally section v concludes the paper by evaluating trem.
.
c circlecopyrt2017 ieeease urbana champaign il usa t ool demonstrations901 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iii.
w orkflow and design a. overview of the specification mining process used trem mines specifications of systems by analyzing the sequence of events emitted by the system.
these sequences of events are called traces.
traces must take the form of anevent series with time stamps.
the alphabet of a trace is theset of all events that the trace contains.
definition trace event and alphabet an event is a string.
a trace is a sequence of events with a time stamp for each event.
the alphabet of a trace is the set of all events inthe trace.
for example a trace of a smart phone may look like the trace displayed in table i. in this case the alphabetispower button graphics loaded screen on.
the elements of the alphabet are referred to as events.
t able i sample trace time seconds event power button graphics loaded3 screen on specifications are mined using behavioural pattern templates.
trem uses timed regular expressions tres to encode specifications and timed regular expression template tret to encode behavioural patterns.
both tres andtrets are defined below.
definition timed regular expression timed regular expressions tres over an alphabet also referred to as expressions are defined using the following families of rules afor every event a and the special symbol epsilon1are expressions.
if 1and 2are expressions and iis an integer bound interval then angbracketleft angbracketrighti 1.
2 1 2 and are expressions.
here.represents the concatenation operator is the negation operator is the disjunction or or operator and denotes the kleene .
these operators only allow for specifications on the order of occurrence of events without considering thetime at which these events occur.
the angbracketleft angbracketright ioperator allows for the creation of temporal properties this operator restricts themetric length of the time event sequences in t ob ei nt h e intervali.
it is important to note that we use tres as defined above to provide specifications.
definition event v ariables an event variable is an atomic proposition in a tret that can take any event valuefrom the trace alphabet .
definition tre template tret a tre template is a tre in which all of the atomic propositions are either eventvariables or events.
we use the term event variable to denote a placeholder for an event.
for example the tre template .
represents is always followed by within the time interval where and are event variables and where x y are fixed doubles used in the time interval.
we use pto denotethe number of event variables present in a tre template.
in the given example pis .
any expression within and has to be followed by a time interval that is specified within and .
the values xandyare separated by comma .
definition binding let be an alphabet of events and letvbe a finite set of event variables.
then a binding is a functionb v a tre instance corresponds to a tre template with an identical structure.
applying a binding to the event variablesin a tre template creates a tre instance corresponding tothat binding.
the binding is thus a map used to replace event variables with events from the given alphabet.
we mine all occurrences of tre instances generated by the bindingfunction on the alphabet of the input trace.
the mining framework trem uses timed automaton for mining properties.
timed automata have been investigated quite rigorously in the recent past.
the main motivationfor using timed automata is their suitability for modelingtime dependent behavior and the ability to monitor their reachability .
timed automata are equipped with clocks making them perfect for modelling and verification of real time systems behavior .
classical models like finiteautomata petri nets etc.
are not suitable since they cannotexpress such explicit timing constraints naturally present inreal life systems.
another important property of the timedautomata is that the reachability properties are decidable even though the timed automata have an infinite numberof configurations.
the main idea behind this result is theconstruction of a region automaton which finitely abstracts thebehavior of timed automata in a way that checking reachabilityin a timed automaton reduces to checking reachability in a finite automaton.
more details on the implementation can be found in .
the tre instances generated by the binding contain every permutation of events in the alphabet within the tret.
there is thus a total of ppossible tre instances.
generally we are interested in mining all of the valid tre instances.
however these instances contain both interesting and frequently occur ring patterns as well as those that might have been present justa few times in the trace.
we thus use a ranking component toreduce the mined set to contain only the dominant instances orspecifications.
we consider properties that are both frequentlyoccurring and interesting as dominant properties.
we use theconcepts of support and confidence from for findingdominant properties.
definition support the support of a tre instance on a tracetis the number of time points of trace twhich do not falsify .
definition confidence the confidence of tre instance on a trace tis the ratio of trace support to trace number of total instances.
the ranking component we use is a combination of support and confidence.
the effectiveness of selecting a meaningful subset of specifications depends on picking a good set ofthresholds.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
since the total number of mined tre instances is often very large in real systems we would ideally keep the confidence value at100 .
however the motivation to reduce this threshold slightly is due to the presence of imperfect traces.
traces can be imperfect as a result of dropped events or executionof faulty programs.
in such cases dominant properties maynot be perfectly satisfied in the collected traces.
reducing the threshold will thus include dominant properties from imperfect traces.
fig.
.
tre mining workflow figure provides a high level overview of the technique we use for mining temporal properties from system traces.
the binding function accepts a set of ntraces and a tre template.
we use execution traces collected during system runtime.
the time event traces are generated using instrumenta tion already present in the system and may include networktraffic logs operating system logs program instrumentationlogs etc.
the binding function accepts a set of nlogs where n .
from these logs the function extracts an alphabet of unique events.
the tre template is an abstraction of thedesired temporal property a temporal relationship of interestfor the system.
the tre template uses a set v of event variables where the variables range from 0top.
the binding function binds the set vto the alphabet of events to generate a set of tre instances.
the timed fsm evaluates the tre instances on the same set ofntraces.
the ptre instances are encoded in the p dimensional incidence matrix that is used by the timed fsmto keep track of state clocks and evaluation results.
as thetimed automaton evaluates each tre instance on the trace itupdates the success and failure values in a matrix.
when theautomaton is finished evaluating the tres on all the traces itpasses the results matrix to the ranker.
the ranker uses the results matrix generated by the timed fsm to calculate the confidence and support values for eachtre instance.
the rank criteria are the threshold valuesfor confidence and support that are used to select only the dominant tre instances.
the ranker uses these criteria to filter out any of the instances with confidence and support valuesbelow the specified thresholds.
thus we are left with onlythe dominant instances which are the dominant properties orspecifications for the system being analyzed.
let us demonstrate the above work flow through an example.
consider the tre template .
which isa simplified template for the response pattern.
the .
is the concatenation operator and the is the operator for one ormore instances of the expression.
the template specifies thatsome log event 1is followed by another log event 0within to time units and this pattern occurs at least once in the execution trace.
the property contains two event variables and1 meaning that the value of pis .
the binding function will bind the events in to the template and generate an adjacency matrix for the tre instances.
the timed finite state machine fsm iterates over the time event pairs in a trace and at each new event evaluates therelevant tre instances.
lets assume the matrix contains anentry where 0is bound to an event send and 1is bound to an event receive .
the fsm reads in the event send in thetrace at time .
according to the property if the next eventin the trace is not receive the fsm will enter an error state and will increase the failure count for this tre instance to 1in the matrix.
similarly if the next event is receive but the time stamp is the failure count would increase.
if the nextevent is receive and the time stamp is which is within the2 to interval then the automaton will enter a final state andwill increase the success count for the tre instance.
once the entire trace has been processed the ranker will iterate over the matrix to calculate the confidence and supportvalues for each tre instance.
the ranker will report only theproperties that meet the defined thresholds for these metrics.
b. interface design overview trem is a web application.
the front end is responsible for providing an interface to work with tres set up experiments view documentation and display results.
the back end is responsible for specification mining and trace storage.
this allows the front end to be light and delegatethe computationally intensive processes to the server figure2 .
fig.
.
overview of interface c. frontend design the front end of trem provides multiple ways to create trets select or upload traces and display results figure .
to create a tret we provide options visual tret creation using blockly we use google slibrary blockly to create a visual interface to entertrets.
there is a blockly block equivalent for everyrule in the syntax required to write tret s. therefore the blockly interface has the full expressive power over authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
overview of front end interface trets.
figure shows a sample blockly expression.
it is read from top to bottom for example in figure the equivalent tret is .
.
fig.
.
simple blockly expression for a tre pre defined trets there is also a list of commonlyused pre defined trets based on with accompanyingdocumentation.
figure shows a sample pre definedtret with its explanation.
fig.
.
pre defined tret with its explanation direct tret creation finally there is also a field whichallows the user to directly enter their own trets.blockly tret models may be converted to and from text trets.
this is encouraged to make the user comfortable with the syntax of trets over time.
there are three ways to provide the traces for evaluation to the tool as outlined below database connection the tool provides option to connect any postgres database.
a list of traces are shown foreach database connected to trem any number of thesemay be selected.
each comes with the option to limit thelength of the traces.
custom trace a field is provided into which a shortcustom trace may be written.
a pattern is mined on allthe selected traces and the custom trace if present.
csv file traces can also be uploaded in a csv fileformat.
the results are displayed in three different ways for ease of visualization and understanding of the end user figure .
histogram for immediate visual feedback a histogram isgenerated that displays the event combinations resultingin the largest success values.
the histogram displays theevent combination success and reset values.
tables there are tables displayed per trace the first ta ble is the equivalent of the histogram.
it displays the eventcombination success and reset values in the decreasingorder of successes.
the second table displays all eventcombinations that have sufficient support and confidencevalues when compared to the respective threshold values.
csv file finally a csv file is generated with the entireset of results.
the results take the form of matrices.the first one contains the success values the secondone contains the reset values and a list of the eventcombinations that passed the support and confidencethreshold.
d. interface backend description the back end is made up of a demo database connections to external databases and the interface with the tre mining framework.
during execution the relevant traces are loaded the tret is parsed and the traces are then mined by the tre mining framework .
the results are processed and returned to thegraphical user interface.
iv .
i ndustrial case study a. performance evaluation using real qnx traces the qnx real time operating system rtos is used in many safety critical systems such as medical devices nuclear monitoring systems vehicles etc.
the qnx rtos has a very advanced logging facility tracelogger .
tracelogger facilitates detailed tracing of the kernel and user process activity onany system.
more specifically it can log interrupt activity various states of processes and threads communication withinthe system kernel calls custom user events and much more.the logged events give a detailed view into the behavior ofthe system but due to the large quantity of the produced authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
tre mining results of qnx trace from hexacopter using the alternating tret information are often difficult to make use of by developers and system designers.
these traces are thus a perfect resourcefor dynamic mining of system properties and specifications.
for the evaluation we used a set of traces collected from an operational hexacopter loaded with the qnx neutrino .
and a user control process.
the vehicle is a commercially avail able gyro stabilized mikrokopter hexacopter equipped with electric motors and a mah lithium polymer battery.
thehexacopter can be seen in figure .
the trace length for ourexpriments have .
million event entries.
fig.
.
the hexacopter in flight the trace is uploaded into a database and then connected to trem via the connect database option.
for evaluation weuse the pre defined tret the alternating pattern as it isquite common in real time embedded systems.
the intuition for using an alternating pattern arises from the fact that a vastmajority of tasks in real time systems are periodic.
one can either select from our pop up screen or customize it as per the system under consideration either in text or blockly interface.
for example the time constraint for eachsystem would be unique and depend on the time units of the system trace.
in our case we modify the time constraintfrom to since that is a desirable value forinter event time lapse for qnx traces from hexacopter.
the histogram view of the results is presented in figure .
theresults presented here are for support and confidence .
.
these parameters can be changed to refine the results forbetter understanding of the system under evaluation.b.
result analysis the properties mined by trem under specified thresholds for support and confidence are analyzed for understanding the system.
the csv file contains all the mined specification thattake the form of the alternating pattern.
our goal is to identifydominant and interesting properties of the system.
therefore we sort the tre instances that obey the thresholds of support and confidence based on their frequency of occurrence in thesystem trace.
in figure the mined properties from the hexacopter trace are evaluated each bar represents a unique instance of atre.
in this case the most dominant property is where theplaceholder 0is associated with the event aps name and the placeholder 1is associated with aps new budget.
these events are associated with qnx and ensure that there is sufficient memory available all the time for the application.
the event aps name creates a new partition to ensure sufficient memory is available.
the event aps new budget is emitted automatically when the adaptive partitioning scheduler clearsa critical budget as part of handling a bankruptcy situation.
the timing constraint ensure the timely response to a memory request which is extremely critical in real time systems.
thisis just one of the dominant properties and is very importantas it ensures that in a safety critical real time application suchas a hexacopter there is always sufficient memory available.
the significance of such properties is better understood in case of system failure.
if the system prohibits memoryprovisioning for the application it may lead to catastrophicconsequences.
for example in case of hexacopter the autopilot module tries to obtain direction information from gy roscope to send a control signal to the elevation controller.
the inertial measurement unit imu requires memory to storeand process this information in real time.
for a faulty system the fault can be in imu or memory management system itis predicted that trem results would reveal that either the property described above is completely missing or has moreresets.
this indicates that the system is trying to clear memory but unable to do so.
not only does this allow us to monitoranomalous behavior of the system but also helps in post mortem analysis.
v. d iscussions and conclusions a. evaluation and scalability trem s server side is written in python using the microweb framework flask .
trem delegates all of the memory authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and processor intensive tasks such as trace storage and mining to the server.
trem requires minimal resources on the client device.
this allows trem to scale to handle large system traces.
we have tested the framework on industrial strength systemtraces from qnx controller area network can bus androbotics operating system ros messages of length more than million event entries.
the space and time complexity of our framework depends on the complexity of the tret.
it is exponential w.r.t the number of variables or placeholders in the tret whereaslinear w.r.t to the length of the trace.
generally most prop erties in systems are simple with only or variables.
thedetailed derivation of the space and time requirements of ourframework has been presented in .
b. conclusion since trem is a web app the client is platform independent and lightweight.
this allows it to be run on most modern terminal devices with a web browser.
trem is containerized through docker and can be deployed on most existing servers.
trem allows for fast iteration of specification mining patterns or trets due to the following processor intensive tasks are done on the server traces may be shortened quickly and easily to allow for testing short custom traces may be entered to quickly testdifferent variants of your trets trem provisions for mining of trets combined with thevisual interface and a visual summary of results.
this enableslearning and rapid development of specifications for complexsoftware embedded software legacy systems and evolutionof software systems.
r eferences caroline lemieux dennis park and ivan beschastnikh.
general l tl specification mining.
in proceedings of the 30th ieee acm international conference on automated software engineering ase ase pages washington dc usa .
ieee computer society.
matthew b dwyer george s avrunin and james c corbett.
patterns in property specifications for finite state v erification.
in software engineering .
proceedings of the international conference on pages new y ork ny usa .
ieee.
manuvir das.
f ormal specifications on industrial strength code from myth to reality pages .
springer berlin heidelberg berlin heidelberg .
v alentin dallmeier nikolai knopp christoph mallon sebastian hack and andreas zeller.
generating test cases for specification mining.
in proceedings of the 19th international symposium on software testing and analysis pages new y ork ny usa .
acm.
.
zachary kincaid and andreas podelski.
automated program v erification.
in language and automata theory and applications 9th international conference lata nice france march proceedings volume page nice france .
springer.
mihai christodorescu somesh jha and christopher kruegel.
mining specifications of malicious behavior.
in proceedings of the 1st india software engineering conference pages new y ork ny usa .
acm.
mark gabel and zhendong su.
online inference and enforcement of temporal properties.
in proceedings of the 32nd acm ieee international conference on software engineering v olume pages newy ork ny usa .
acm.
marco bonato giuseppe di guglielmo masahiro fujita franco fummi and graziano pravadelli.
dynamic property mining for embedded software.
in proceedings of the eighth ieee acm ifip international conference on hardware software codesign and system synthesis pages new y ork ny usa .
acm.
.
xiaoqing jin alexandre donz jyotirmoy v deshmukh and sanjit a seshia.
mining requirements from closed loop control models.
ieee transactions on computer aided design of integrated circuits and systems .
glenn ammons rastislav bod k and james r larus.
mining specifications.
acm sigplan notices .
dawson engler david y u chen seth hallem andy chou and benjamin chelf.
bugs as deviant behavior a general approach to inferring errors in systems code.
sigops oper .
syst.
rev.
october .
jinlin y ang david evans deepali bhardwaj thirumalesh bhat and manuvir das.
perracotta mining temporal api rules from imperfect traces.
in proceedings of the 28th international conference on software engineering pages new y ork ny usa .
acm.
.
jinlin y ang and david evans.
automatically inferring temporal properties for program evolution.
in software reliability engineering .
issre .
15th international symposium on pages saintmalo bretagne france .
ieee.
fabrizio pastore daniela micucci and leonardo mariani.
timed k tail automatic inference of timed automata.
corr abs .
.
tony ohmann michael herzberg sebastian fiss armand halbert marc palyart ivan beschastnikh and y uriy brun.
behavioral resource awaremodel inference.
in proceedings of the 29th acm ieee international conference on automated software engineering ase pages new y ork ny usa .
acm.
marc br nink and david s. rosenblum.
mining performance specifications.
in proceedings of the 24th acm sigsoft international symposium on f oundations of software engineering fse pages new y ork ny usa .
acm.
e mark gold.
complexity of automaton identification from given data.
information and control .
jinlin y ang and david evans.
dynamically inferring temporal properties.
in proceedings of the 5th acm sigplan sigsoft workshop on program analysis for software tools and engineering p aste pages new y ork ny usa .
acm.
r. sekar a. gupta j. frullo t. shanbhag a. tiwari h. y ang and s. zhou.
specification based anomaly detection a new approach for detecting network intrusions.
in proceedings of the 9th acm conference on computer and communications security ccs pages new y ork ny usa .
acm.
zerksis d. umrigar and vijay pitchumani.
formal verification of a realtime hardware design.
in proceedings of the 20th design automation conference dac pages piscataway nj usa .
ieee press.
greta cutulenco y ogi joshi apurva narayan and sebastian fischmeister.
mining timed regular expressions from system traces.
in proceedings of the 5th international workshop on software mining pages singapore .
dogan ulus.
montre a tool for monitoring timed regular expressions.
arxiv preprint arxiv .
.
paul caspi eugene asarin and oded maler.
timed regular expressions.
j. acm march .
rajeev alur and david l dill.
a theory of timed automata.
theoretical computer science .
kim g. larsen paul pettersson and wang yi.
upp aal in a nutshell .
tuan anh doan david lo shahar maoz and siau cheng khoo.
lm a miner for scenario based specifications.
in proceedings of the 32nd acm ieee international conference on software engineering v olume icse pages new y ork ny usa .
acm.
miguel grinberg.
flask web development developing web applications with python.
o reilly media inc. 1st edition .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.