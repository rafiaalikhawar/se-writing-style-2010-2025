greenbundle an empirical study on the energy impact of bundled processing shaiful alam chowdhury department of computing science university of alberta edmonton ab canada shaiful ualberta.ca takumi shuto information sc.
electrical eng.
kyushu university fukuoka japan shuto posl.ait.kyushu u.ac.jpabram hindle department of computing science university of alberta edmonton ab canada abram.hindle ualberta.ca ken matsui information sc.
electrical eng.
kyushu university fukuoka japan matsui posl.ait.kyushu u.ac.jprick kazman information technology management university of hawaii honolulu hi usa kazman hawaii.edu yasutaka kamei information sc.
electrical eng.
kyushu university fukuoka japan kamei ait.kyushu u.ac.jp abstract energy consumption is a concern in the data center and at the edge on mobile devices such as smartphones.
software that consumes too much energy threatens the utility of the enduser s mobile device.
energy consumption is fundamentally a systemic kind of performance and hence it should be addressed at design time via a software architecture that supports it rather than after release via some form of refactoring.
unfortunately developers often lack knowledge of what kinds of designs and architectures can help address software energy consumption.
in this paper we show that some simple design choices can have significant effects on energy consumption.
in particular we examine the model view controller architectural pattern and demonstrate how converting to model view presenter with bundling can improve the energy performance of both benchmark systems and real world applications.
we show the relationship between energy consumption and bundled and delayed view updates bundling events in the presenter can often reduce energy consumption by .
index t erms energy consumption mvp mvc architecture i. i ntroduction energy consumption is an important quality requirement for mobile devices and for mobile software such as apps that affects availability battery life and sales.
unfortunately and often app developers are addressing energy consumption when it becomes a problem rather than at design time before coding starts.
there is evidence that developers simply are not trained enough in the topic of energy consumption at the application level to be able to address energy consumption effectively .
also available optimization tips do not impact energy consumption in real world apps demanding higher level changes for efficient accesses of energy hungry components .
unfortunately developers have little idea about what design choices are even available that will affect energy consumption as well as the consequence and tradeoffs of those design choices.
yet interest exists as manotoas et al.
show experienced practitioners are often willing to sacrifice other requirements for reduced energy usage .
this paper discusses the kinds of design choicesand tradeoffs that architects face and seeks to illustrate how we can improve energy consumption of mobile applications and indeed of any application by relatively small changes in an architecture.
specifically we show how a change to model view presenter mvp with bundling or dropping strategies can improve the energy performance of apps.
but why focus on mobile?
by the number of global smart phone users is expected to reach .
billion .
smartphones are essentially portable networked pocket computers powered by batteries .
smartphone apps range from email apps to games to notifications prompts reminders stock tickers etc.
this wide variety of software and uses is ever present as the network bandwidth demands on mobile networks starts to eclipse pc network bandwidth .
this pressure on functionality and portable computing puts a huge strain on a mobile device s battery which unfortunately has not seen much technological improvement .
if the device s battery energy is consumed the device is typically unusable.
the importance of energy consumption on mobile devices has immediate consequences app developers quickly learn that their apps that use lots of energy suffer in ratings as consumers highly value battery life for their mobile devices .
we seek to aid developers in addressing energy consumption at design time before runtime.
our concern is that developers do not have good guidelines or evidence based models of the costs and benefits of the design choices they make in the design of energy efficient apps.
developers lack knowledge of architectures patterns and tradeoffs that are potentially green energy efficient or the parameters that can make an architecture green at runtime.
so in this work we demonstrate how the model view presenter pattern mvp can be modified to reduce the event processing overhead of model objects notifying view objects.
we discuss how to modify the presenter of mvp into a proxy that bundles requests or drops redundant requests by delaying notifications thus avoiding frequent expensive intermediate notifications or ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
context switches that update views.
our research questions and contributions include rq what is the impact of the number of event sources and event generation rates on software energy consumption?
rq can bundling and dropping events help in saving energy while varying the numbers of sources and rates?
contribution we developed a benchmark android app that follows the model view presenter mvp architecture to understand the impact of bundling and dropping on modelview presenter architecture.
we implemented the presenter in three different forms no bundling bundling and dropping.
the number of event sources and the rate of event generation i.e.
number of events second are determined at runtime with user input.
using the benchmark app we answer rq and rq .
rq what are the energy impacts of bundling and dropping on real world applications?
rq can bundling and dropping help address users feedback without harming apps energy consumption?
contribution we confirm the realism of the findings from the benchmarks with four different real world android apps to answer rq and rq .
because benchmark apps although good for conducting controlled tests do not necessarily reflect real world scenarios and performance .
rq why do bundling and dropping save energy?
contribution we investigate the cause of performance changes by analyzing resource access patterns e.g.
cpu use of apps with bundling and dropping to answer rq .
rq what are the maintainability consequences of implementing bundling and dropping on android apps?
contribution we analyze the difficulty of incorporating bundling dropping in android apps and the consequences of these changes on maintainability to address rq .
decoupling level dl metric is used for analyzing the maintainability cost of bundling and dropping versions.
we show that a small change to an architecture like mvp allows for making energy consumption tradeoffs allowing for energy aware decision making during design and maintenance phases.
in general developers can save significant amount of energy by adopting the proposed bundling and dropping mechanisms without harming user experience and without materially affecting the maintenance cost.
to support reproducibility and extension our energy measurements and the open source benchmark app are shared publicly .
ii.
b ackground a. energy efficiency is difficult to achieve power p is the rate of work expressed in watts .
energy e expressed in joules is the total amount of work in a given time t e p t. energy consumption is linearly proportional to the run time of a component but only when p is constant.
a reduced time tcan save energy but what if the cpu switches to a higher power consuming state for a reduced timet?
without actual energy measurements or estimates this is hard to answer.
moreover cpu access patterns are just one of the many considerations that affect energy consumptionin modern devices .
studies have recommended energy efficient java collections energy efficient communication protocols locating and finding energy bugs and building models and tools for energy estimation .
despite the increasing amount of energy efficiency research it is often unclear how software design decisions impact energy consumption and what tradeoffs developers should be aware of .
b. model view presenter model view presenter mvp is a form of model viewcontroller mvc .
mvc often uses a design pattern such as the observable pattern to ensure synchronization between data in the model and visual or concrete representations in the views while shielding the model from direct manipulation from view objects via a controller .
mvc has many variants.
some have different purposes.
one popular variant of mvc is called active mvc that is typically implemented with a single process whereby the observer pattern is used to allow interactions between the model objects and the view objects.
in active mvc model objects are observables that notify observers views when their representation or data is updated.
this is done by keeping a list of observers and then notifying each via a method call that the observable they are watching has been updated.
it is then up to the observer to query the model objects for the information they need.
this can be quite cumbersome as every change can cause a cascade of observers to react and deal with each change regardless of the granularity or usefulness of the change.
another problem with this pattern is that it puts the notification and listener logic into model objects.
active mvc is cumbersome and requires many model objects to keep track of observers.
model view presenter is a variant that uses the observer pattern but it provides a proxy presenter between the model and the views.
the model objects when modified updates the presenter.
the presenter notifies views and provides them with the information they need to update.
the views do not necessarily need the model objects as the presenter is in the way thus isolating the model objects further from views while removing the responsibility of model objects to notify views for updates.
the controller part of mvp is often folded into the presenter object itself.
using this presenter as a proxy allows one to put delegation logic into the presenter and keep that logic out of the model objects.
this means that a presenter could for example bundle updates or drop updates that were deemed irrelevant.
both of these choices could improve the runtime behaviour of an application.
because of its simplicity the mvp pattern has been recommended in several developers blogs and discussions .
our approach however can also be adopted with other architectures besides mvp.
c. events bundling and dropping presenters an event can be a database update request a packet transmission request a view update request and so on.
bundling is the act of storing and queuing incoming events such that they authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
uml class diagram of the benchmark app.
can be processed together even periodically.
dropping is the act of keeping only the last incoming event to be processed periodically or on demand it processes only the most recent event.
a bundling presenter stores incoming events and send them later in a single batch for processing them together.
on the other hand a dropping presenter discards previous events and processes only the most recent one.
bundling is applicable when a delay in processing is acceptable whereas dropping is relevant when along with the delay tolerance the most recent event nullifies the importance of previous events.
bundling has been found energy efficient in earlier studies.
pathak et al.
proposed i o bundling for reducing tail energy leaks in mobile apps.
the authors found that some hardware components such as the network interface card or sdcard suffer from the tail energy phenomenon.
tail energy is the wasted energy by a component while transitioning from the active to the inactive state.
bundling operations that involve such hardware devices reduces the tail energy phases significantly and thus save software energy consumption.
for the same reason chowdhury et al.
found that writing log messages in batches can reduce energy consumption.
other research found that http servers can reduce clients energy consumption by enabling a form of bundling compared to the http .
servers .
lyu et al.
has shown that energy efficiency can be significantly improved by grouping multiple database auto commit transactions into a single transaction.
in this paper however we focus on modifying an existing architectural pattern mvp with dropping and bundling.
we show that by adopting this modified architecture one can gain the maintainability and architectural benefits of mvp.
yet developers may still decide how to balance event based energy consumption against other qualities such as latency.
iii.
m ethodology this section describes the benchmark app we developed for our experimentation along with our energy measurement process and test scripts for driving the subject apps.
a. the benchmark app this app has three major components including model view and presenter in compliance with the mvp pattern.
figure illustrates the benchmark app with a class diagram.the benchmark app with an ui allows a tester to choose a configuration of parameters to test.
for example the number of emitters i.e.
event sources event generation rate test run duration and the version of the presenter no bundling bundling or dropping can be selected at run time.
for bundling and dropping a delay parameter is also provided i.e.
how long the app should wait for collecting the incoming events before processing all the saved events in a single batch?
this ui with a button click can then spawn a new experiment running on a thread separate from the ui thread .
the new experiment will have emitters and views of emitters emissions instantiated.
model the model is a collection of emitters objects i.e.
event sources based on the user s input.
the model is responsible for dealing with the emitters and forwarding their emissions to the presenter.
the model has a registerobserver method which can add any number of presenters that can be interested in an update from this model.
however for simplicity we used only one presenter in our experiments.
the model is an observable from the observer pattern.
the model component uses four different sub components emitter emission distribution and emitterqueue.
a emitter an emitter is an event source that emits events at a given rate i.e.
number of events second .
each emitter creates emission objects that contain all the data of the next scheduled transmission from that emitter.
the emitter is also responsible to notify the model about emissions so that the model can notify the interested presenter.
emitters are meant to simulate event sources like stock prices weather information or sensor output.
b emission an emission is an event that contains some data usually a message.
these messages are randomly generated and timestamped.
c distribution each emitter produces emissions following a probability distribution function pdf for scheduling the next emission.
the benchmark app is designed to accommodate any pdf at run time.
for simplicity and low variability in our energy measurements we used only the uniform distribution.
d emitterqueue the emitterqueue uses a priority queue java s priorityqueue to schedule emitters for emitting and transmitting the next emissions.
the priority queue enacts an efficient algorithm for scheduling the emitter.
the emitterqueue sorts all the emitters based on their next waiting time.
the model then removes the first emitter from the priority queue finishes its transmission and then insert it again based on its next scheduled emission time.
this process continues until the test run duration expires.
presenter the presenter is an observer of the model component.
it is notified whenever one of the model s emitters transmits.
the presenter maintains a mapping of emitters and views which the presenter uses to notify the view of the corresponding emitter with the emission.
there are kinds of presenter used in both the benchmark app and the study i no bundling forwards the update immediately ii bundling waits for the given bundling time saves all the incoming authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
updates and forwards each of them all together iii dropping same as the bundling except the presenter forwards only the most recent update and discards all the previous updates.
the presenter runs in a separate thread than the ui thread.
when the presenter receives an update it decides which view to notify and passes off the necessary information to the view in the view s thread such as the ui thread if the view has a ui.
the bundling presenter for example sleeps inside a timer thread and stores the incoming events in parallel.
it then forward all the stored events to the interested views once the sleeping time is over i.e.
the bundling time provided by the user .
the dropping presenter is identical except it discards previous events and only forwards the most recent one.
to help practitioners for implementing bundling dropping presenters we made the benchmark app public and open source .
view views are meant to receive updates from the presenter.
what they do with the update is up to them but typically they only talk to the presenter and updates them with the emission objects they receive.
they are observers of the presenter but might be associated with a particular object.
for simplicity the benchmark app maintains a one toone relationship between the emitters and view components a single view a textfield is interested in a single emitter.
a view in the benchmark app is thus responsible to display the received emission data from a emitter through the presenter.
b. energy measurements and test scripts we used two implementations to verify the generalizability of our proposed approach of the greenminer software energy measurement platform to measure the energy consumption and resource usage of the apps used in this paper.
the greenminer s tests and measurements can be accessed remotely and greenminer has been used extensively in a variety of software engineering energy consumption research .
the system under test is typically an android smartphone.
energy is measured using current sensor ina219 and ina159 chipsets that report to an arduino uno microcontroller.
the microcontroller processes and aggregates measurements sending to the test computer a raspberry pi model b computer.
the current sensors and the pi are connected to the phones under test.
the first greenminer is connected to galaxy nexus phones system under test running android .
.
with an ina219 while the greenminer is connected to an asus zenfone running android .
.
with an ina159.
for a given app and test the pi acts as the test runner which pushes runs and collects measurements for a given test script.
the first greenminer system has four identical settings with four galaxy nexus phones.
running different tests in parallel helps accelerate the measurement process.
greeminer has only asus zenphone .
greenminer test framework cleans any previously installed apps before running a new test.
this is to ensure the same system state for each test energy consumption of a particular test is therefore unaffected by previous tests.
we ran the real world app tests on the greenminer and greenminer the benchmark app was tested solely on thefig.
energy consumption of the benchmark app with different numbers of emitters and event generation rates.
bars indicate the confidence interval.
greenminer to simplify comparison of parameters and energy consumption.
previous greenminer based works recommended running the same test multiple times for the observed variability in energy consumption.
we ran all versions of our subject apps benchmark and real world apps 10times.
to minimize outlier effects we show the confidence interval of our measurement distribution.
in addition whenever necessary we used the kruskal wallis test to verify if two energy measurement distributions are statistically different.
the advantage of kruskal wallis test is that it does not assume any distribution of the data as it is non parametric.
to measure the energy consumption of an app we need to run the app multiple times which is infeasible with manual testing.
we used the android s adb shell script for writing the test cases.
for the benchmark app writing the test script was straightforward.
the script selects the number of emitters the presenter type the bundling time in case of bundling and dropping and provides the test duration and event generation rate before clicking the start button.
for the real world apps however the tests were written with two of the authors consensus that these tests represent an average user s interaction with these apps.
iv .
r esults benchmark app in this section we show the energy consumption of the different versions of the benchmark app with different settings.
to select the number of emitters and event generation rate we use powers of and .
this large range is able to show the big picture the impact on energy consumption with the increase in the number of emitters and event generation rate.
all versions at all settings of the benchmark app were run for a fixed period of seconds repeating times each.
rq what is the impact of the number of event sources and event generation rates on software energy consumption?
figure shows the energy consumption of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the benchmark app with different numbers of emitters i.e.
event sources and event generation rates.
clearly the energy consumption goes up when we increase the number of emitters and or the event rate.
the spearman correlation coefficient is .
p between the number of emitters and energy consumption in joules .
the coefficient is .
p between the event rates and energy consumption.
the coefficient would have been higher if the phones were able to process high numbers of events and emitters.
the variations in energy measurements among multiple runs for each setting are small figure shows that the confidence intervals are not noticeable until the performance is saturated.
this is because we kept the benchmark app as simple and deterministic as possible which is harder to control in realworld apps.
we also observe that for high number of emitters i.e.
emitters the energy consumption does not change with the increase in the event rate after a threshold.
this is because of the limited capacities of the phones we used for our measurements these phones can process a certain number of events within the allotted seconds test duration.
producing more events than this threshold does not impact the energy consumption for the phone can not process the extra events within the allotted time.
in fact with the kruskalwallis test we found statistical differences between the energy measurements until the numbers of emitters and rates are high.
for example with emitters .
p .
between events sec and events sec.
however for .
pis statistically insignificant .
between events sec and events sec when the number of emitters is fixed to .
table i shows the percent increase in energy consumption in the number of emitters and event generation rates compared against the energy consumption of one emitter with one event per second.
for example even with a single emitter the energy consumption can go up when the event generation rate is high events second .
and note that the percentage increase with high numbers of emitters and rates would have been much higher than the reported values if the phones were to able processing more events.
findings many modern applications deal with large numbers of event sources with high numbers of incoming events .
our results show that energy consumption is correlated with both the number of event producers and the rate of event production.
rq can bundling and dropping events help in saving energy while varying the numbers of sources and rates?
to answer this question we considered three different waiting times for both bundling and dropping .
second the corneal reflex time of human eyes .
second half of user acceptable latency and second the broadly used acceptable latency target for interactive applications .
unlike the real world apps presented later a wider range of waiting times were not considered for the benchmark app so the graphs are readable.
figure shows the energy savings of different bundling and dropping rates compared with no bundling or dropping presented as nobundling in the figures .
each graph showstable i percent increase of energy consumption compared with the energy consumption of emitter and event second.
for readability nearest integer values are presented.
rates emitters table ii energy savings in percent by different bundlers and droppers when compared with no bundling or dropping.
results are presented for just one emitter.
rates versions bundling .1s dropping .1s bundling .5s dropping .5s bundling 1s dropping 1s the results for all the possible scenarios for a fixed number of emitters.
except for very high numbers of emitters or rates the energy consumption goes up monotonically for the nobundling version.
while this trend is true for the bundling versions as well for the dropping versions we do not see such clear trends.
this is because the number of events processed by a dropping version transferring events from the presenter to the views is to some extent independent of the number of events generated.
the small energy increase for the dropping versions with increased rates is due to the cost of producing more events by the model component in our benchmark app.
not surprisingly dropping is more energy efficient than bundling the dropping versions process fewer events than the bundling versions.
the bundling versions in spite of processing the same number of events as the no bundling version can save significant energy.
it is encouraging that with bundling we can process and deal with the same amount of workload and yet can make apps significantly more energy efficient.
table ii shows the energy savings by different bundlers and droppers with fixed one emitter.
this is to ensure that the energy consumption is not affected by resource limitations thus enabling accurate comparison.
it shows that with bundling all the work without dropping anything and maintaining a latency such that a user does not notice any change .
second we can still save up to of the energy bundling .1s .
with useracceptable latency bundling 1s bundling can save up to in a simple app like our benchmark with just one event source.
we verified with the kruskal wallis test that these differences are indeed statistically significant with .
p .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
energy consumption of bundling and dropping compared with the nobundling versions for different number of emitters.
results for more than emitters are not presented due to resource limitations the energy consumption is inconsistent forvery high numbers of emitters and rates.
bars indicate the confidence interval.
findings dropping is the most energy efficient approach compared to bundling and no bundling.
however droppingmight not be an acceptable alternative when accuracy isimportant.
application developers can consider bundlingin such scenarios which still saves significant energy overno bundling.
v. r eal world apps results from the benchmark app shows that bundling and dropping can save significant energy in android apps.
andthis saving is larger with increased numbers of event sourcesor event generation rates.
it is however not obvious how suchoptimization approaches would perform in real world apps .in this section we evaluate bundling and dropping in four selected real world android apps.
a. selection of applications the apps we selected had to be open source so that we can implement bundling and dropping.
we explored the fdroid repository to find suitable apps.
f droid containssource code for all the posted android apps and was usedin earlier mining software repositories research .finding suitable apps with reasonably small code size so thatwe could easily identify where to implement bundling anddropping was challenging which hindered us from analyzingmore apps.
table iii shows the characteristics of the four selected apps.
the different types and code sizes of these four apps enables reliable evaluation of bundling and dropping.
the sensor readout app is also available on google play and hasbeen downloaded more than times as of writing .
thisapp has received reviews with an average rating of .
.this allows evaluating energy optimization techniques for appsthat are already popular.
acrylicpaint a finger painting app represents apps where users might spend more continuoustime making energy optimization more crucial.
we have implemented the bundling and dropping versions of these apps except for sensor readout following the approachpresented in section iii a2.
the original sensor readout app uses a timer function and processes only measurements per second although the app samples measurements continuously.as a result we did not have to implement our own timer forthe bundling and dropping variants.
the apps however didnot follow a clear mvp pattern.
instead their designs werecloser to the mvc pattern.
we have identified which classescontained the actual processing code and refactored thoseclasses to accommodate our bundling dropping presenters.
ourintention was to convert the existing design as close to thebundling mvp pattern as possible.
for ensuring correctness two of the authors were involved in refactoring and testing theapps afterwards.
b. rq what are the energy impacts of bundling and dropping on real world applications?
the energy savings from bundling and dropping are of course impacted by the bundling dropping time the time these two variants wait before processing a batch of events.we selected six different times .01s fastest human timeperception .03s animation speed .1s the corneal reflextime of human eyes .2s double the corneal reflex time .5s half of user acceptable latency second acceptable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii description of the selected four real world android apps from f droid.
test app type classes uloc test scenario duration s sensor readout real time graphs of sensor data measure the gyroscope sensor colorpick er pick colors and display values move the scroll bars for r g b angulo angle and distance measuring start the measurements and wait acrylicp aint simple finger painting draw a hexagon fig.
energy consumption of bundling and dropping compared with the original versions of four real world apps.
bars indicate the confidence interval.
user latency and seconds double user acceptable latency.
figure shows the energy consumption of bundling and dropping compared with the original versions of the four selected apps.
here we also show the results for the greenminer gm2 on the asus zenphone .
except for the sensor readout app we observe more energy consumption for the bundling and dropping versions for very low bundling and dropping times e.g.
.01s .
this suggests that running a timer thread for bundling or dropping incurs energy consumption overhead.
as we mentioned before sensor readout did not require a separate timer thread and does not have this overhead when bundling or dropping is used.
for all the apps however the energy consumption of bundling and dropping improve significantly when the waiting time is reasonably higher.
for example even for .1s latency which is difficult for users to perceive the bundling and dropping versions of acrylicpaint and angulo can save with gm and with gm energy consumption respectively when compared with their originalversions.
the energy savings become significant for larger latency.
for example we can save with gm energy consumption for the sensor readout app with a 1s latency in drawing the measurements graphs and that without losing any measurements i.e.
with bundling .
greenminer with the asus zenfone phone consumes less energy than the greenminer with the galaxy nexus phone for all apps and thus the energy savings are generally lower.
the trends in percent of energy consumption reductions however are similar across the apps for both the greenminers.
c. rq can bundling and dropping help address users feedback without harming apps energy consumption?
answering this question might require analysis from multiple perspectives.
however with one case study we show that there are scenarios where the developers can adopt our bundling approach to address user feedback that involves energy expensive modifications.
for this study we selected the sensor readout app the only app available on google play authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
energy savings of bundling dropping for the sensor app with higher sampling rates.
bundling dropping time is fixed to .
second.
bars indicate the confidence interval.
with a significant number of reviews.
for a selected sensor type this app shows updates measurements per second.
in general this app is praised by users.
however some reviews indicate user dissatisfaction.
for example one user desires to see colour changes with different measurements while updating graphs .
another user is unsure why the sampling rates from the sensors are low samples per second.
changing colors continuously and sampling at higher rates might increase the energy consumption of the app significantly.
and yet developers need to carefully address user feedback for their apps to stay popular .
in fact there are reviews on the sensor readout app suggesting similar apps are supposedly better than sensor readout.
we show that sensor readout can benefit by applying bundling by sampling measurements faster for timeline graphs but delaying graphical updates by only .
second without harming latency more measuresments per second but constant ui update rate .
figure shows the energy consumption of the original version compared with the bundling and dropping versions with different sampling rates.
the bundling dropping time i.e.
the latency in updating the graphs is fixed to .1s.
the average energy consumption of the original version is high joules when the sampling rate is second compared with the original second joules a increase in energy consumption.
the difference is also statistically significant kruskal wallis test .
p .
.
however bundling with samples second consumes similar energy to the original version with just samples second.
with sampling rate higher than the energy consumption of the phones does not increase as expected.
the galaxy nexus phones are unable to process more than a threshold number of samples.
findings real world android apps can save significant energy with bundling and dropping.
sacrifices in latency correlate with the energy savings.
bundling with almost imperceptible latency .1s can save energy without affecting user satisfaction.
in some scenarios bundling and dropping can help developers address users concerns with no meaningful sacrifice in usability.vi.
u nderstanding resource utilization patterns withbundling and dropping it is unsurprising that dropping saves energy in dropping the presenter only sends the most recent event for processing.
this requires less cpu slots for the process also known as cpu jiffies .
bundling however does the exact same amount of work as on time processing.
thus the question arises why does bundling save energy in spite of processing all the events?
assumption a cpu jiffy is an assigned cpu time slot for a process in linux .
more cpu jiffies for a process causes more cpu jiffies for the kernel because of more context switches between the user space and the kernel space.
in on time event processing system each event requires at least one user cpu jiffy.
this incurs at least one context switch and one kernel cpu jiffy.
this effect however can be minimized with bundled processing.
batching of events minimizes the number of context switches and the number of cpu jiffies.
if our assumption is correct the energy efficiency of bundling is explainable.
the number of cpu jiffies and context switches are almost linearly correlated with software energy consumption .
a. rq why do bundling and dropping save energy?
to verify the above assumption we have analyzed the acrylicpaint app.
similar to chowdhury et al.
we used the linux proc file system.
to capture the cpu jiffies used by an app we used proc pid stat .
this also includes the kernel cpu jiffies used for that app.
however app process specific context switches can not be captured using such a file system.
we captured the number of context switches from proc stat before and after running a test for an app.
the difference is thus approximately the number of context switches for the app.
figure shows the result measurements for each configuration .
the number of cpu jiffies and context switches follow a similar pattern to the energy consumption of the acrylicpaint s versions figure .
this observation suggests that our assumption is true bundling indeed reduces the number of cpu jiffies and context switches.
this also indicates that bundling and dropping enable efficient resource usage and thus can potentially provide similar energy savings for platforms other than android.
the mechanisms of context switches between the kernel and user space are similar across different platforms and architectures.
findings bundling and dropping access resources in efficient ways reducing the need for many context switches leading to energy efficient software.
this observation suggests that the energy efficiency of bundling and dropping is not restricted to android systems but also is applicable in other platforms.
vii.
m aintainability analysis developers and architects need to be concerned with the maintainability consequences of changes made to enhance any single aspect of a system s quality.
thus it is important authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
numbers of cpu jiffies and context switches for bundling and dropping compared with the original acrylicpaint app.
bars indicate the confidence interval.
to understand the consequences of the changes made to the apps to implement the bundling or dropping strategies.
this motivates our sixth and final research question.
rq what are the maintainability consequences of implementing bundling and dropping on android apps?
to assess these consequences we analyzed the before and after versions of the four selected real world apps.
we first reverse engineered each of the apps using the understand tool .
using this tool we were able to collect code metrics on all versions of the apps.
for the purposes of brevity we only report on the original and bundling versions of the apps here.
results for the dropping versions were very similar.
in each case the modifications to the apps were slight in terms of effort requiring fewer than additional lines of code and at most three new classes including one handler class and one thread class that runs the timer .
but counting the lines of code and classes is just the measure of the required effort for converting a typical app version to a bundled version.
another important question is whether these changes affected the longterm maintainability of the system.
if for example we added few lines of code but added many new dependencies between classes this would increase coupling in the system negatively affect the maintainability of the app going forward.
to determine whether this was the case we analyzed the coupling of the apps in their before and after versions using the decoupling level dl metric a system wide measure of coupling.
the dl metric has been empirically validated and shown to be more reliable than other coupling metrics such as propagation cost and independencelevel in predicting maintenance effort.
dl scores range from to and the higher the number the better as this indicates that the system s files are more highly decoupled and hence can be independently modified.
the purpose of using this metric is to determine if the changes made to address energy efficiency significantly lowered the value of the dl metric.
if so this would mean that the maintainability of the system was negatively impacted by the energy saving modifications.
the dl values of the before and after versions of four appstable iv dl values for before after versions of each app bundling only .
app dl score dl score dl original bundling angulo colorpick er acrylicp aint sensor readout are shown in table iv.
while the values of the dl metric varied widely indicating the inherent maintainability of the apps prior to our intervention the changes for the apps due to the addition of bundling were small.
the observed drops in dl scores were due to new relationships between classes that the bundling and dropping functionality required.
but since the dl scores do not change dramatically decreasing about for acrylicpaint increasing for angulo and staying the same for colorpicker this indicates that the tradeoffs made for energy efficiency were generally good ones improving the energy efficiency of the apps while sacrificing little if any maintainability of the apps for the long term.
in fact in it was noted that small variations in dl are typically not meaningful.
findings energy efficiency is largely ignored during software maintenance .
one reason could be the difficulty in fixing energy bugs .
bundling and dropping however are easy to implement and maintain.
viii.
t hreats to validity external validity is hampered by the single version of the android os that we used on four galaxy nexus phones.
also we do not know how many real world apps can directly take advantage of the proposed bundling approach.
the first threat is mitigated somewhat by using the greenminer with a different phone zenphone .
to mitigate the second threat we tried to select apps from different domains and with the context switching analysis we explained why bundling is energy efficient.
this might help predicting what other types of apps can adopt greenbundling.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
internal validity can be criticized for the way we calculated the number of context switches.
unlike the cpu jiffies process specific context switches are inaccessible using the procfs file system.
the difference between after and before when running a process can be affected by other processes e.g.
garbage collection .
the kruskal wallis test although it does not assume any normality distribution about the data still assumes that data in each group has similar skewness .
these threats are minimized by measuring each configuration times and then showing the means and confidence intervals.
construct and conclusion validity may also be questioned based on the tests scripts that we created for the real world apps.
it is not guaranteed that typical users of these apps would interact similar to the way our test scripts do.
however our test scripts exercise the main functionality of these apps e.g.
drawing measurement graphs and objects with the sensor readout app and the acrylicpaint app respectively.
ix.
r elated work in recent years developers have expressed more concerns about software energy consumption .
the software research community has been investigating several areas of this issue.
hasan et al.
pereira et al.
and manotas et al.
have presented recommendations for selecting energy efficient java collections.
energy efficient color transformation in android apps was proposed by li et al.
and agolli et al.
.
off loading jobs pre fetching content and enabling ad blockers have been found to save energy in some cases.
chowdhury et al.
suggested that http servers are more energy efficient from the clients perspective thanhttp .
servers.
energy efficient logging techniques for android systems have also been studied.
other research has shown correcting code smells helps to improve energy efficiency .
in a similar vein the impact of code obfuscation and refactoring on software energy consumption was studied by sahin et al.
.
the energy change from code obfuscation is too small to notice whereas refactoring can impact both positively and negatively.
developers need to measure or estimate their apps energy consumption.
hao et al.
proposed an instruction based energy estimation model.
machine learning based models were proposed by aggarwal et al.
greenadvisor chowdhury et al.
greenoracle and greenscaler and pathak et al.
.
nucci et al.
proposed petra to estimate android apps energy consumption leveraging various android tools.
locating software energy bugs and hotspots automatically is another important research area.
wakelock related energy bugs have been frequently reported by earlier studies .
developers need to exploit tools and techniques to locate and solve such bugs .
similar to the energy bugs developers should also resolve energy hotspots .
jabbarvand et al.
proposed a test suite minimization approach focusing only on locating energy bugs.
in their later work the authorsproposed an energy specific mutation testing framework with high precision in detecting energy bugs .
this paper however focuses more on high level design choices that can help developers writing energy efficient systems.
to the best of our knowledge this is the least explored area of software energy efficiency and there is still a need for more research on this avenue.
the closest to our work is the short study by sahin et al.
where the authors investigated different existing design patterns and their energy consumption.
in contrast to our work that study lacks proper guidelines and cost analysis for making a design choice.
x. c onclusion f uture work in this work we showed that an architectural choice such as choosing a bundled mvp architecture can improve the sustainability and energy consumption of a system without negatively impacting system maintainability.
the consequence of this research means that architects and developers can and should make design decisions to address energy consumption before they start coding.
we have demonstrated the value of a bundled presenter in mvp by first benchmarking a generic mvp architecture and then by demonstrating that the energy improvements demonstrated in the benchmark were in fact realized on real world apps that were refactored into bundled mvp architectures from more classical mvc architectures.
a significant reduction of energy consumption can in fact be achieved.
furthermore we showed that these modified apps did not seriously affect the user experience nor did the refactored versions suffer in terms of their eventual maintainability.
thus the energy savings that we achieved were truly win win.
our final message is this fundamental architectural choices such as the ones we have investigated in this paper can have substantial effects on energy consumption.
although we demonstrated our results on mvp based architectures it is our hope and belief that developers and researchers can use this study to motivate similar studies allowing them to address questions of energy consumption and their consequent tradeoffs at design time.
we do not need to wait until the app is built to make these important design choices.
in our future work we want to evaluate the proposed bundling architectures on other smartphones than android and with real end users for evaluating actual usability.
we also want to evaluate other architectural patterns and architectural choices so that architects can predictably translate sustainability requirements into designs and into working systems.