teevml tool support for semi automatic integration testing environment emulation jian liu school of software and electrical engineering swinburne university of technology hawthorn vic australia jianliu swin.edu.au iman avazpour school of information technology deakin university burwood vic australia iman.avazpour deakin.edu.au john grundy school of information technology deakin university burwood vic australia j.grundy deakin.edu.au mohamed abdelrazek school of information technology deakin university burwood vic australia mohamed.abdelrazek deakin.edu.au abstract software environment emulation provides a means for simulating an operational environment of a system.
this process involves approximation of systems ex ternal behaviors and their communications with a system to be tested in the environment.
development of such an envir onment is a tedious task and involves complex low level coding.
model driven engineering is an avenue to raise the level of abstraction beyond programming by specifying solution directly usin g problem domain concepts.
in this paper we propose a novel doma in specific modeling tool to generate complex testing environm ents.
our tool employs a suite of domain specific visual m odeling languages for modeling emulation environment at a high level of abstraction.
these high level specifications are then automatically transformed to runtime environment for application integration testing boosting development productivity and ease of use.
the tool demonstration video can be accessed here be h3vg20juq80.
ccs concepts software and its engineering model driven software engineering software and its engineering interoperability software and its engineering software testing and debugging software and its engineering empirical software validation software and its engineering integrated and visual de velopment environments.
keywords model driven engineering do main specific visual modeling language software component in terface description testing environment emulation.
.
introduction modern enterprise software systems usually operate in a distributed and heterogeneous environment.
these systems interact and cooperate with other systems in their environment for providing composite services to support daily enterprise operations.
thus the performance of a software system is governed not only by its internal implementation but also driven by interactions with other systems.
with the increasing complexity of the environments enterprise systems are deployed in it is becoming more difficult and expensive to replicate a realistic production environment for software systems integration testing.
on the other hand a production environment is generally unsuitable to conduct this kind of testing as a fault in the enterprise system may cause disrup tion or irreversible damage to that production environment.
the uml testing profile utp is often used to systemically define tests for static and dynamic aspects of systems modeled in uml .
utp provides a generic extension mechanism for the automation of test generation processes.
the model language tml is another testing language for describing markov chain usage models to characterize the probabilities of all usages using some statistic techniques and generate test cases accordingly .
however both the utp and tml are for server side system testing and do not have abstractions suitable for developing a testing environment for client side application integration testing.
testing environment emulation is an emerging technique to provide integration testing envir onment for a system under test sut that interacts with many external systems.
the main idea is to model the run time behaviors of each system also known as endpoint in the environment and re place each real system by an instantiation of the corres ponding model in the emulation environment.
the aim is to make the emulated testing environment rich enough to fool the sut that it is talking to the real systems.
other behaviors and the systems which sit underneath and in the background are ignored from the emulated environment perspective where possible.
there have been two approaches to develop such integration testing environment.
the first one is specification based approach where it professionals manu ally develop interaction models with the use of available knowledge about the underlying interaction protocol and system behaviors respectively.
the second one is interaction trace data record and replay approach .
this approach uses a traffic recording tool to sit between a sut and an endpoint recording information about how the sut and endpoint interact.
later thos e recordings can be used to simulate the endpoint response fo r each corresponding request by searching for the close matching request in traffic recordings.
both of these approaches have their shortcomings former approach has high development and set up costs and requires access to detailed system know ledge and implementations.
the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
later one depends on the availabilit y of traffic recordings for all interactive scenarios between a sut and its operational environment.
aiming to achieve high development productivity and ease of use for domain experts we have developed a novel specificationbased domain specific visual m odeling language for testing environment emulation teevml .
our teevml is based on a layered software components inte raction description framework where each layer represents a modeling problem domain.
we provide a separate domain speci fic visual language dsvl for each of these interaction layers.
domain experts use these dsvls to model their endpoint by laye rs.
teevml s te sting runtime environment is provided by transforming endpoint signature model wsdl xml file to axis2 web service platform .
.
motivation to motivate our teevml tool we use a business case as an example and describe the interactive behaviors between a sut and an endpoint.
the sut for this case study is an internet banking application.
it communi cates with a core banking system as the endpoint for accessing user and bank account records for each end user service request.
from descri ption simplicity consideration we assume that the internet banking application provides six services to its end users logon logout searchaccount deposit withdraw and moneytransfer .
from the sut s perspective the endpoint must provide integration testing functionalitie s which should mimic its real system services.
therefore we can realistically assume that the main testing endpoint characteristics are an endpoint only considers the external behaviors or call services of the real system and all internal implemen tations will be ignored an endpoint only provides a subset of the real system invoked by the sut and an endpoint should be able to detect all sut interface defects identifying their types and origins.
based on the above assumptions we can describe the core banking system endpoint from three different abstraction layers service signature service request name and paramete rs and response return values protocol valid temporal sequence of services and interactive behavior service request process and response generation.
we describe the end point from these three layers in table .
it is not feasible to test the internet banking application with the production core banking system.
it would also be very expensive to duplicate the core banking system.
hence conventional interaction trace data record and reply and specification based approaches would not be feasible or would be difficult to use as the former relies on the existence of interaction trace data and the later requires development of detailed endpoint model implementations.
we thus define three key objectives for our testing environment emulation tool testing endpoint functionalities the tool should be able to develop various types of testing endpoints which could be used to detect all so rts of interconnectivity and interoperability defects of suts development productivity the tool should ideally have high endpoint developmen t productivity and less development effort and time ease of use the tool should be easy to learn and use to specify endpoint interface and behavior at high levels of abstraction rather than implementation details.
.
our approach to identify the common entities and find out their relationships we conducted our testing environm ent emulation dom ain analysis by investigating three typical business applications interacting with their clients.
the domain analysis focused on two areas the interaction abstraction between a service provider and a service consumer and the requirement on integration testing environment.
from the domain analysis we proposed a layered software components interaction descri ption framework for testing environment emulation and identified service request defect types to be detected.
table .
core banking system endpoint description signature all services have a name and consist of one or more parameters for their request and or response.
all services have a reques t and response except for logout service which has a request only.
request and response parameters can be a string integer float boolean or date data type.
request and response parameters can be either mandatory or optional.
a logon service request has opti onal username and password fields for authenticating a secured interactive session.
the userid field in logon request is five di git integer amount field in deposit and withdraw requests ranges from .
to .
amount field in moneytransfer request ranges from .
to .
protocol a logon request transits the endpoi nt from idle state to home state and an interactive se ssion starts.
on the opposite direction a logout request terminates the session.
in a secured session all the services can be accessed by the sut.
otherwise only logout and searchaccount services can be invoked.
as the minimum money transfer amount is .
a moneytransfer request must follow a searchaccount request and the amount value in the searchaccount response will determine whether the moneytransfer request can be executed.
timeout event will automatica lly change the endpoint state from a from state to a to state after a certain period of time.
all service requests will be rejected when endpoint is processing a synchronous service.
all transaction services deposit withdraw and moneytransfer are considered as unsafe services and multiple requests for a same service are not allowed.
behavior to start a secured session logon request must be authenticated by userid username and password parameters if only userid parameter is provided the interactive session will be insecure.
all query and transaction services use userid field to find a bank account record and retrie ve the account balance.
if the account record cannot be found an error code and error message will be generated in response.
for withdraw and moneytransfer services the transaction amount must be equal or less than the account balance.
otherwise a not enough balance error occurs.
.
software components interaction description framework our software components inter action description framework abstracts an interaction into th ree horizontal a nd two vertical 841layers.
the horizontal layers in clude signature protocol and behavior.
the vertical layers incl ude data store data persistence access and quality of service qos as non functional requirements .
a sut service reques t is processed horizontally by an endpoint step by step from signature protocol down to interactive behavior layer.
whenever an error occurs at any layer the request process will be terminated.
the signature and protocol layers act as message pre processors for validating service request sy ntax and sequence correctness before handing it over to the behavior layer for generating response.
vertical layers are no t directly involved in request processing but provide support to horizontal layers.
we use modular development approach to model an endpoint i.e.
each module represents a partic ular interactive layer.
.
integration testing environment a testing endpoint is a server s ide application receiving and processing service requests from a sut based on remote procedure call rpc communicati on style.
thus the endpoint should be able to validate the correctness of service requests sent from the sut.
in general there are two types of service request defects functional defects which are directly related to service request processing by endpoint and non functional requirement defects such as non compliance with security requirement or robustness under different operati onal conditions.
table lists all the functional defects a sut se rvice request may cause.
our current version of testing endpoin t does not support qos testing and it will be our future work.
table .
service request defects no defect type description signature s1 a service request is not a service provided by endpoint.
s2 the parameters in a service request are not matched with the parameters of the corr esponding service provided by endpoint in terms of parameters name data type or order.
s3 one or more service request ma ndatory parameter s is are missing.
s4 one or more parameters in a service request is are beyond the defined value range of the corresponding endpoint service.
protocol p1 a service request is invalid for the current endpoint state.
p2 a service request is invalid for the current endpoint state as one or more parameter s vi olate s defined constraint condition s .
p3 a service request is invalid for the current endpoint state as one or more returned value s from a previous service request violate s define d constraint condition s .
p4 a service request is invalid due to endpoint state transition driven by some internal event such as time out.
p5 a service request is invalid as endpoint is in processing a synchronous service request.
p6 a service request is invalid as one such request for an unsafe service has been received by endpoint.
from design by contract dbc programming style s perspective a sut s obligation is to send correct service requests to an endpoint .
the way these requests to be processed is defined in the endpoint source codes a recorded demo video user study result reports and an in press publication are available at the endpoint s internal implementa tion.
while it may seem as if endpoint behavior modeling is not necessary for emulating an integration testing environment there are situations where a business process may have several interactions between a sut and an endpoint.
the sut may send a di fferent subsequent request to its endpoint depending on what valu es are returned in the response message it has received from a prev ious service request refer to p3 defect type of table .
as a result an emulated endpoint needs to have behavior modeling fu nctionality for capturing some runtime sut protocol defects.
testing endpoint functiona lities that is one of our tool s objectives is measured by the coverage of service request defects that can be detected by testing endpoint.
in the followings we discuss how the integration testing defects listed in table can be detected from our teevml s design.
.
teevml design our teevml consists of signature protocol and behavior dsvls.
each of the dsvls includes a coll ection of visual notations for modeling an endpoint layer and c ode generators for transforming the layer model to target forms.
th e design of visual notations is based on a metamodel or a progr amming paradigm which covers all endpoint layer modeling asp ects and their inter relationships.
we used metaedit .
as th e meta language to develop the dsvls.
in the following subsecti ons we briefly describe these dsvl designs.
more details of teevml tool and its visual notations are subject of another publication .
.
.
signature dsvl to improve components reusability and have a concise presentation we have adopted a hierarchical dsvl architecture design approach refer to figure .
the top level signature dsvl uses wsdl .
as its metam odel to define the five wsdl entity types and their relationships refer to figure 1a .
the middle level operation dsvl is for defining request and or response message s contained in an operation or call service refer to figure 1b .
the bottom level message dsvl uses w3c xml schema .
as its metamodel to define complex elements in a message refer to figure 1c .
figure .
signatu re dsvl metamodel the signature defects s1 to s3 in table are detected by axis2 web service engine transformed from signature wsdl file.
for s4 defect debugging two fields are added to element type for 842specifying the minimum and ma ximum values of a request parameter.
.
.
protocol dsvl to capture dynamic endpoint prot ocol behaviors we used an extended finite state machine efsm metamodel to describe endpoint protocol behaviors refer to figure .
one entity type and two entity properties are added to an operation driven state transition fsm marked yellow in fi gure .
the entity type is the internalevent which is used to define state transitions triggered by time event.
one of the entity properties is the statetransitionconstraint of the transition entity and it is used for specifying either static or dynamic constraints on state transition function.
another one is the statetimeproperty of the state entity which is for simulating synchronous and unsafe operations.
all the protocol defects listed in table can be detected by a testing endpoint developed by a modeling tool based on the efsm metamodel p1 the operation driven state transition fsm p2 and p3 the statetransitionconstraint of transition entity p4 the internalevent entity type and p5 and p6 the statetimeproperty of state entity.
figure .
protocol dsvl metamodel efsm .
.
behavior dsvl the endpoint behavior dsvl was designed based on dataflow programming paradigm .
we c hose this metaphor as it allows complex specification of behavi or models but is understandable by a wide range of target end users.
the dataflow programming execution model is represented by a directed graph.
the nodes of the graph are data processing units and directed arcs between the nodes represent data dependencies.
data flows in each node from its input connector.
the node starts to process and convert the data whenever it has the minimum requi red parameters available.
the node then places its execution resu lts onto output connector for the next node s in the chain.
.
example usage1 here we use the core banking system from the motivation section as an example to explain how a te sting endpoint is developed.
our testing endpoint development proce ss consists of three steps modeling endpoint to model endpoi nt signature protocol and behavior layers by using teevml transforming models to transform endpoint models to wsdl xml file signature model and java class files protocol and behavior models by code generators and integrating the generated codes with domain framework in a java ide environment.
.
signature modeling signature modeling starts from specifying endpoint level properties.
then signature dsvl is used to instantiate the five wsdl entity types service port binding porttype and operation by providing their names and relevant information.
they are linked together by using either a composition or an association relationship.
all the entity types ha ve just one instance except for the operation.
the number of th e operation instances depends on the services provided by the endpoint.
we use the operation deposit as an example to show how an operation can be modeled.
the operation is instantiated by assigning the operation name as deposit and pattern as in out.
then operation dsvl is used to specify the deposit request and deposit response messages in the operati on.
the request message label is in and response message label is out .
message elements are defined by using message dsvl.
the request message contains userid and amount elements and they are placed by their ids in alphabetic order.
the userid data type is defined as integer and the element is mandatory.
since a valid userid is a five digit integer the element s minimum field is specified as and maximum fi eld as .
similarly the amount element properties ar e defined with data type as float mandatory field minimum and maximum .
the response message consists of three elements newaccountbalance errorcode and errormessage .
the newaccountbalance is a float data type errorcode is integer and errormessage is string.
the newaccountbalance and errorcode fields are mandatory with default value of .
figure 3a illustrates the hierarchical signature model of the core banking system endpoint including the top level si gnature model the middle level deposit operation and the bottom level request and response messages.
.
protocol modeling endpoint protocol is modeled usi ng protocol dsvl.
the first step of protocol modeling is to initiate a session by using a logon transition relationship linking idle state to home state.
on the opposite direction a logout transition relationship ends the session.
the session can also be terminated by a timeout event using a timeout relationship from home state to idle state.
when the endpoint is at its home state it may accept one query service request searchaccount and two transaction service requests deposit and withdraw .
the query transaction can be accessed in a secured or an insecured session.
therefore a standard transition relationship is used to represent the state change from home to the searchaccount state.
on the other hand the transaction services are only valid in a secured session authenticated by username and password parameters in logon service request.
therefore a constraint transition relationship is needed to represent such a state transition.
the constraint condition is defined by specifying the inputusername parameter of the logon service as not equal to null value.
similarly as the minimum money transfer amount is .
the returned bank account balance from a searchaccount service determines whether or not a moneytransfer service is valid.
figure 3b illustrates the banking system endpoint protocol model.
.
behavior modeling endpoint behavior is modeled us ing behavior dsvl.
we use one service deposit as an example to show how endpoint behavior is modeled.
the first step of beha vior modeling is to define the service node by assigning its na me.
the request and response parameters of the service will be imported from the matching signature model automatically.
figure .
example endpoint three interactive layers modeling the service node behavior implement ation is specified by using a node or call method sub graph.
the first two constructs to use are a pair of entrance and exit bars.
they define inputs and generated outputs to and from the method and specify where the method execution starts and ends.
there are two out ports on the exit bar for normal execution outputs hollow circle and exceptions yellow circle respec tively.
the first operation is to retrieve account balance by searching bank account table using inputuserid parameter.
if the searching record is found the account balance will be assigned to a variable accountbalance .
otherwise a fatalerror string variable will be assigned and placed on the exception out port of the exit bar.
the next operation is to calculate new account balance by adding input amount to the accountbalance variable.
the calculation is specified by using an evaluator with assigned newaccountbalance variable name on the top parameters used in the middl e and formula at the bottom.
the last operation is to update the s ame bank account record with the newaccountbalance .
figure 3c illustrates the example endpoint deposit service node operations and dataflows.
.
testing environment creation our testing runtime environment is built by transforming the above endpoint layer models into a wsdl xml file and java class files.
we use eclipse as our java ide to build two projects for hosting server and client side ja va files separately.
the details of testing environment creation p rocess are described as follows .
testing environment platform creation the signature model is transformed to a wsdl file then the file is transformed to axis2 web service platform by using axis2 wsdl2java utility.
.
protocol and behavior mode ls transformation and integration the protocol and behavior models are transformed to java classes then these java classes are integrated with axis2 skeleton class.
.
axis2 web service generation and deployment an apache ant build xml file is us ed to build endpoint axis2 web service automatically and the built service aar file is loaded to tomcat application server.
.
sut integration a java api file is provided for integrating a sut with axis2 stub file in the client project.
by now the core banking system testing endpoint is ready to provide integration testing service to its sut.
figure illustrates the integration testing runtime envi ronment.
the sut is on the top of right hand side of axis2 client communicating with axis stub class through a java api.
the lowe r grey areas at both sides are axis2 soap engine for low level soap message exchanges.
the behavior and protocol classes are located on the top of left hand side of axis2 server integrated with axis2 skeleton class.
behavior classes soap processskeleton classaxis2 web servicce engine server side soap processstub classaxis2 web service engine client side soap messageemulated testing endpoint java api interfaceprotocol classsystem under test figure .
testing runtime environment .
evaluation and discussion to qualitatively eval uate our tool we have defined three evaluation criteria each corresponding to one of the three objectives defined in the motivation section.
our evaluation process has two parts in the first pa rt we have compared our tool versus two other testing enviro nment emulation approaches from a technical point of view.
in the second part we have performed a user study of software testing ex perts and developers to obtain their opinions on our tool s usefulness and ease of use.
.
technical comparison there are two main testing environment emulation approaches being used currently as describe d in the introduction section specification based by manual codi ng and interaction trace data record and replay.
in table we compare our tool with these existing approaches and give a three point ranking low medium or high subject to the level of support they provide for each of the evaluation criteria.
overall our tool compares well with these existing approaches.
.
user evaluation the user study was conducted in two phases to measure the two variables of the perceived use fulness and perceived ease of use defined by davis respectively.
in the first phase we conducted interviews with testing experts to examine the usefulness of an emulated testin g environment for sut integration 844testing.
in the second phase we asse ssed the ease of use of our tool by asking software developers to perform a modeli ng task.
all the survey participants were asked to fill an online questionnaire for collecting their opinions on each que stion statement.
for this paper evaluation results presentation we only summarise the overall responses to some of the questions and the full result reports are available online1.
table .
emulation approaches comparison manual coding interaction trace data our tool testing endpoint functionalities medium signature and static protocol behaviors.
low cannot provide defect information.
high complete signature and protocol behaviors.
development productivity low manually coding endpoint.
high interaction trace data recording.
high modeling endpoint.
ease of use low programming skill and domain knowledge.
high no special skill requirement.
medium domain knowledge only.
regarding the usefulness we have received in favour response rate as a whole.
this is a good indication of the participants acceptance of our em ulated testing environment.
in particular all participants liked the protocol layer testing functionality.
we believe the main reason is that many applications do not have a well documented protocol specification and protocol relate d defects can only be found by conducting integration testing.
as to what motivates our participants to use testing end points the top reason was early detection of interface errors rather than savings on cost and effort.
in current practice integratio n testing is normally conducted during the later stages of software development lifecycle.
this is partly because integration testin g environment is not available before then.
if a rapid and cheap solution for testing environment deployment was available software testers may have preferred to conduct at least part of in tegration testing earlier to evaluate the ease of use we used the ten questions from software usability scale s us .
the sus questions responses were quite positive w ith average in favour.
to capture participants ideas on how much of their time and effort will be reduced through using our toolset comparing with a third generation language respondents chose and .
as a result we can conclude that most participants believed that our tool coul d increase endpoint development productivity.
confirming this is the fact that most participants have finished the task of an endpoint service modeling in less than minutes.
based on this result we can generalize that it is possible to model a relatively complex endpoint with more than ten services within a day through using our tool support.
.
conclusion and future work current specification based te sting environment emulation approaches cannot validate sut s runtime protocol behavior as they check the validity of a co ming service request based on endpoint state only.
our tool pr otocol model is based on efsm and we use behavior model to ca pture dynamic protocol aspects.
furthermore our testing envir onment has rich functions for simulating typical business scenario s such as time driven state transition synchronous and unsafe operations.
in a realistic enterprise e nvironment endpoint security requirement may put extra constraint s on the validity of a service request.
some of the constraints are role related so that some services are accessible only to a certain group of users.
others are security policy related such as restriction on available time or specific pattern required for some service parameters.
also there are some robustness requirement s on sut for handling endpoint malfunctioning situations.
these and other non functional requirements modeling will be our future work.
.
acknowledgment the authors gratefully acknowledge support for this research by an australian post graduate award and an australian research council discovery projects grant.
.
reference schieferdecker i. dai z. r. grabowski j. rennoch a. .
the uml .
testing profile and its relation to ttcn3.
testing of communicati ng systems springer.
.
prowell s. j. .
tml a description language for markov chain usage models.
information and software technology.
.
hine c. schneider j g han j. versteeg s. .
scalable emulation of enterprise systems.
software engineering conference australian ieee.
.
du m. schneider j g hine c. grundy j. versteeg s. .
generating service mode ls by trace subsequence substitution.
proceedings of the 9th international acm sigsoft conference on quality of software architectures.
canada acm.
.
jayasinghe d. .
qu ickstart apache axis2.
packt publishing ltd. dai g. bai x. wang y. dai f. .
contract based testing for web services.
computer software and applications conferen ce compsac 31st annual international ieee.
.
kelly s. tolvanen j. p. .
domain specific modeling enabling full code generation.
wiley.
liu j. grundy j. avazpour i. abdelrazek m. .
a domain specific visual m odeling language for testing environment emulation.
ieee symposium on visual languages and human centri c computing.
cambridge uk.
in press.
odi es.google.com site teevmlase .
w3c.
.
web services description language wsdl .
.
world wide web consortium.
thompson h. s. beech d .
maloney m. mendelsohn n. .
xml schema part stru ctures second edition.
w3c recommendation.
sousa t. b. .
dataflow programming concept languages and applications.
doctoral symposium on informatics engineering.
davis f. d. .
perceive d usefulness perceived ease of use and user acceptance of information technology.
mis quarterly.
.
brooke j. .
sus a quick and dirty usability scale.
usability evaluation in industry.
.