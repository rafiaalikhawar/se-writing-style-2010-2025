an automated framework for recommending program elements to novices kurtis zimmerman and chandan r. rupakheti department of computer science and software engineering rose hulman institute of technology terre haute indiana zimmerka rupakhet rose hulman.edu abstract novice programmers often learn programming by implementing well known algorithms.
there are several challenges in the process.
recommendation systems in softwarecurrently focus on programmer productivity and ease of devel opment.
teaching aides for such novice programmers based onrecommendation systems still remain an underexplored area.
inthis paper we present a general framework for recognizing thedesired target for partially written code and recommending areliable series of edits to transform the input program into thetarget solution.
our code analysis is based on graph matching andtree edit algorithms.
our experimental results show that efficientgraph comparison techniques can accurately match two portionsof source code and produce an accurate set of source code edits.we provide details on implementation of our framework whichis developed as a plugin for java in eclipse ide.
keywords recommendation framework pq gram algorithm i. i ntroduction learning how to program can be a challenging endeavor to many novices.
past research has exposed many barriers to learning programming languages apis and frameworks .
novices often think about problems in the situation model which is an imprecise mental model of the problems.translation of problems in the situation model to a precise system model represented by artifacts such as source code often requires external help .
given a programming problem a novice may not know how to break it into meaningful pieces design barrier .
even if he breaks the problem properly he may not know whichprogramming elements to choose to get the desired result selection barriers .
after selecting programming elements hemay not know how to make them work together coordinationbarriers or how to use them correctly use barriers .
assum ing he was successful in all of these steps he may now wonderwhy it did not work as expected understanding barriers .even if he was able to form an idea as to why the algorithmdid not work he may not know how to check the internalproperties of the program to validate his idea information barriers .
ko et al.
identify these learning barriers as some ofthe central challenges in programming software systems .fischer on the other hand argues for a software frameworkconsisting of the necessary toolset to overcome the barriersbetween the situation model and the system model .
as instructors of introductory programming courses for several years we have experienced that example based learn ing and few coaching sessions can help overcome thedesign and understanding barriers to some extent.
there are debugging tools to help with information barriersthat work well.
the selection coordination and use barriers however present a unique challenge as they require constantguidance from instructors.
due to the lack of time instructorsmay fail to provide such guidance to novices.
search based tools may help novices to some extent however past research has shown that novices may notknow how to formulate the right queries to get meaningfulhelp from such tools .
an automated tool integrated witha novice s development environment that could read his code recognize the pieces of algorithms being implemented andrecommend a set of source code edits to achieve the correctsolutions iteratively seems ideal in this context.
this work isan effort in that direction.
we make the following key contributions i given a source and multiple target implementations we present algorithms forrecognizing the best matching target implementation ii givena source and target implementation we present algorithms forevaluating edit recommendations and iii we present a non invasive visualization of edit recommendations integrated to anovice s development environment.
in the rest of the paper we present a typical use case of the framework in section ii discuss related works in section iii present the framework s design in section iv discuss resultsin section v identify limitations and discuss future work insection vi and finally conclude the paper in section vii.
ii.
a m otiv a ting example let s assume that an instructor wants to use our framework and has all of her students install our plugin in their eclipseide.
the following is the typical use case the instructor will create programming problems.
she will create find different implementations of the programming problems java files and supply it tothe students ides as knowledge bases.
note that thecurrent prototype stores files locally.
this processcan be improved by having a remote server hostthe encrypted version of target implementations todiscourage students from directly copying the code.
among other relevant help she will provide students some guidance in designing the solutions.
a student writes some code for a problem in the set.
when he gets stuck he will press the help button ofthe framework.
the framework will read his code search for the best matching implementations in theknowledge base and recommend the next set of editstowards the best matched solution using error markers see figure .
in figure 1a two recommendations 30th ieee acm international conference on automated software engineering .
ieee a source code written by a novice b target code provided by an instructor fig.
the framework offering recommendations using markers based on the best matching target implementation.
are presented one for substituting the operator atline and another for the missing return statementimmediately after line .
step repeats until he gets the solution right.
in this way novices will work independently while still gettinghelp to overcome their learning barriers.
it is possible thatstudents may rely heavily on the framework rather than solvingthe problem themsleves.
to discourage such situtation as afuture work the framework will allow configurations thatthrottle recommendations based on the frequency of requests.
iii.
r ela ted work recommendation systems recommendation systems for software engineering extract vital information from most oftenthe source code or object code to provide help with softwareengineering tasks in a given context .
several tutoring sys tems have been developed in the past that automate generationof hints to help novices based on their code .however the generic hints produced by such systems can behard to translate to actual code for novices.
unlike theirs ourframework provides code specific edits.
programming tools there are tools that focus on searching for api methods understanding example code critiquing api client code and analyzing and de bugging programs .
other efforts include auto completiontools within ides to recommend api methods .
arelated tool strathcona uses structure of code and differ ent matching heristics such as inheritance relation methodcalls and types of objects declared in a method body tofind matching examples in a repository .
our frameworkcomplements theirs as we focus on programming constructsrather than higher level api methods.
syntax tree matching we use abstract syntax tree ast provided by eclipse s java development tools jdt to perform comparisons between source and target code.
notethat in syntax trees matching the use of different names for all urls verified on .the same variable between source and target code can be anissue.
a node mapping isomorphism technique can be usedwhere for example all instances of the variable iin the source is mapped to the variable pin the target program .
the algorithm stops after finding the first structural difference butour problem requires all differences.
falleri et al.
propose a method of source code differencing using ast called the gumtree algorithm .
given two asts the algorithm uses two phases to produce a mapping ofmatching or minimum difference subtrees from one tree toanother that can be fed into an algorithm to compute an editscript.
gumtree is similar to our pq gram based algorithmin that it is focused on producing fine grained realistic editsequences.
gumtree has a worst case complexity of o n where nis the number of nodes in the larger tree and assumes the source and target are known.
for a tool whose goal is todetermine the target and determine edits this algorithm couldonly feasibly be used after the closest target is determined.
graph matching a method for fast exact graph matching is proposed by etheredge making use of adjacency matri ces .
however the given algorithm does not take nodelabels into account and only performs subgraph matching.
weneed the best overall match between two graphs.
seeking anapproach to match source code and extract edits in one pass we explored the vf graph isomorphism algorithm .
adrawback of the vf technique is that it does not ensure anoptimal mapping between the two given trees.
an objectivefunction would have to be introduced for optimal mapping.determining this objective value is the essential problem weare trying to solve thus making this method ineffective.
we took inspiration from the similarity matrix based graph matching technique to develop a preliminary algorithmfor comparing graphs.
in the algorithm we compare the labelas well as total number of incoming and outgoing edges ofeach node in the two graphs.
this algorithm runs in o n time and takes o n2 space.
we switched to a more efficient pg gram based algorithm discussed shortly.
tree edit distance tree edit distance refers to the minimal number of node insertions node deletions and noderelabelings required to transform a given tree tinto a desired target t prime as originally detailed by tai as an extension of the string edit problem .
if vandv primeare the number of nodes in trees tandt prime respectively and landl primeare their respective maximum depths tai presents a node mapping approachwhich computes the edit distance in o v v prime l2 l prime2 time.
zhang and shasha improved on the time complexity of tai sapproach by eliminating certain subtree distance calculations too v log2 v where vis the number of nodes in the larger of the two trees .
an approximate but faster version of the tree edit distance algorithm called pq gram is developed by augsten et al.
.
the algorithm considers both labels and overall structure of thetrees during comparison.
it breaks the given trees into smallerstructures and compares the two for similarities.
we use pq gram to identify the best matching target code.
figure illustrates how pq gram profiles are created from the given source code.
the granularity at which a tree can bebroken down is given by the values pandq which are the number of non leaf and leaf nodes in the smaller structure respectively figure 2c .
the algorithm adds null nodes a sample code b ast for the sample code c pq gram structure d first pq gram for theroot node e start of profiles forthe ast fig.
translation of source code to pq gram profiles p program and w while .
to break each tree into all of its subtrees of the same shape.
figure 2d is the first pq gram corresponding to the root node ofthe ast in figure 2b.
similarly figure 2e is the beginning ofthe profile for the ast.
given two trees the pq gram distancebetween the two is a value between identical trees and no similarity .
the algorithm traverses each tree by visitingeach node just once taking o n time and o n space.
the end result relies on a multiset intersection that can be computed ino nlogn time which is the bottleneck of the algorithm .
pq gram is much more efficient than the similarity matrixbased approach in and provides a good approximationof the distance between the two trees.
iv .
f ramework design our framework can be divided into three primary modules i target recognition ii edit recommendation and iii pre sentation via user interface.
we have already demonstrated thepresentation part of the framework in section ii.
we explorethe former two modules in this section.
a. target recognition for each target code in the knowledge base the pq gram distance from the user s code to the target code is computed.
the target code corresponding to the smallest pq gram dis tance is selected for further processing.
if the minimum pq gram distance exceeds a threshold of certainty the systemcannot guarantee reasonable recommendations.
similarly ifmultiple targets correspond to the same pq gram distance thenthe framework non deterministically chooses one.
we present a necessary size criterion for target code to narrow the search scope early.
only targets that satisfythis criterion are selected for computing pq gram distances.assume that i icorresponds to the pq gram profile of tree ti.
size criterion theorem given trees t1andt2with i1 i2 and matching threshold r i fd dist t1 t2 is such that d r then i1 r r i2 .
proof in the pq gram distance is defined as dist t1 t2 i1 i2 i1 i2 .
note that in any case using multisets means i1 i2 i1 i2 .
in the best case scenario to maximize i1 i2 i fi i2 then i1 i2 i1 so we can make the simplification dist t1 t2 i1 i2 i1 i2 i1 i1 i2 .
then if ris the threshold such that r w ew a n t distance dto be such that d r so we must have r i1 i1 i i1 r r i2 after simplification .hence pre computing the size of pq gram profiles of targets in the knowledge base can significantly improve theperformance of this step.
at the conclusion of this step astst s source and tt target have been determined where tt corresponds to the closest matching target ast.
b. edit recommendation once the target code has been identified the next step is to provide the user with a set of recommendations to transform their code into the target implementation.
existing solutionssuffer from a debilitating runtime as they rely on a node to node mapping technique graph isomorphism which inthe worst case runs in exponential time.
in order to provide a reasonable experience for the user and maintain computational efficiency we developed a newrecommendation algorithm based on the pq gram profilesobtained earlier.
the algorithm has four steps acquiring pq gram profiles section iv b1 building common subtrees section iv b2 identifying naive edits section iv b3 andfinally minimizing insertions and deletions section iv b4 .
acquiring pq gram profiles the edits rely on information from the pq gram profiles i s source and it target which are computed in the previous stage section iv a .
tohelp understand all of the steps involved in edit recommenda tions let s use a running example of figure .
the algorithmwill be carried out with t sandttshown in figure 3a and 3b respectively.
the pq gram algorithm begins by extending eachtree with null nodes to ensure each node has the necessarynumber of siblings and children figure 3c and 3d .
then using the algorithm described in the profiles correspondingtot sandttare computed figure 3e and 3f .
at this point we proceed to building common subtrees.
building common subtrees by building the common subtrees a considerable number of nodes and edges areremoved and not considered for further edits.
note that thepq gram tuples are of the form a a2 ... a p c1 c2 ... c q where aiis the parent of ai and apis the parent of each ci.
algorithm takes advantage of this form by first adding all nodes as roots of common subtrees and then byremoving them once they have been added as children toanother common node.
at the end b sholds the set of roots of the common subtrees of tsandtt.
for our example in figure cs a c .
hence bs a anda cis the only common subtree.
identifying naive edits the simplest set of edits is to delete all extra nodes those not in the common subtrees int sand subsequently insert all missing nodes those not in the common subtrees in tt algorithm .
any nodes that show up in the extra tuples e s and not in the common tuples c s a ts b tt c extended ts d extended tt e is f it fig.
a running example for explaining the edit recommendation algorithm.
algorithm building common subtrees of tsandtt require pq gram profiles is it ensure setbsis roots of common subtrees of tsandtt cs is it bs for all a1 a2 ... a p c1 c2 ... c q csdo bs bs a1 bs bs a2 ... a p c1 c2 ... c q end for must be deleted while all nodes that show up in the missing tuples m s and not in csmust be inserted.
note that this set of edits is a correct solution but not an optimal one.
algorithm identifying insertions and deletions require pq gram profiles isandit ensure asis the set of insertions rsis the set of deletions as rs cs is it ms it cs es is cs for all a1 a2 ... a p c1 c2 ... c q msdo as as ai ai for2 i pifai cs as as ap ci for1 i qifci cs end forfor all a a2 ... a p c1 c2 ... c q esdo rs rs ai ai for2 i pifai cs rs rs ap ci for1 i qifci cs end for returning to our example in figure recall that cs a c .
missing tuples m s and extra tuples e s are shown in figure 4a and 4b respectively.
notice that themissing components in m s are the relationships a x andc y. we now add these to the set of insertions a s .
likewise the extra component from es i sa b. we add it to the set of deletions r s .
at the end of algorithm as a x c y andrs a b .
minimizing insertions and deletions we now introduce relabelings as shown in algorithm in an effort to minimizethe number of insertions and deletions generated by algo rithm .
there are two cases for which an insertion or deletionpair can be removed a node ais being deleted from x and a node b is being inserted onto x. in this case the insertion and deletion can be replaced by a single relabeling mapping atob.
a missing tuples m s b extra tuples e s fig.
msandes computed during algorithm .
a node ais being deleted from x and the node ais being inserted onto y and xis being relabeled to y i.e.
x y is in the set of relabelings .
notice that in either case the insertion and deletion can beremoved and only in the first case do we replace them witha relabeling.
in the second case the insertion and deletion aresimply inverses of one another.
algorithm minimizing insertions and deletions require set of insertions asand deletions rs ensure nsis the set of relabelings asandrsthe minimized sets of insertions and deletionsn s for all pi ci asdo for all pd cd rsdo ifns pd ns pi then ifcd negationslash cithen ns ns cd ci end ifa s as pi ci rs rs pd cd end if end for end for at the end of algorithm we are left with three sets one each for relabelings insertions and deletions.
these threetogether represent the total set of edits.
to finish our examplein figure recall that a s a x c y andrs a b .
because we must remove bfrom aand insert x onto a those edits can be squashed into one by replacing them with a relabeling b x s on s b x .
by removing one insertion and one deletion we are left with as c y andrs .
thus the final set of edits can be described as follows i relabel btox and ii insert yonto cin figure 3a.
starting from ts this sequence of edits will indeed match tt.
this concludes our discussion on recommendation a binary search b bogo sort c bubble sort fig.
graphs showing pq gram distances vertical axis for increasing code differences horizontal axis .
algorithms.
we now discuss an issue with variable names that needed special handling.
c. issue with v ariable names the source and target programs may use different names for the same variable.
since our approach utilizes node labels we want to ensure the variable names have no or minimal impact on both the pq gram distance scores and the recom mended edits.
to address this issue we slightly altered theast parsing process.
as the java method is parsed a mappingis constructed where each unique identifier points to all of itsnodes in the ast.
we proceed through the recommendationalgorithm as is.
we then filter out the target code identifierswhile maintaining the effect of the edits as follows.
if i is a string identifier let m i represent the set of nodes corresponding to each use of iin the user s code and let nbe an empty map which will be used to keep track of equivalentvariables between the source and target code.
for each i i f there exists a relabeling of icorresponding to each node in m i consider two cases if each relabeling maps ito the same i prime then remove all of the relabelings associated with iand add i prime i ton.
otherwise for each relabeling i i prime a if i prime n change the relabeling to i n i prime .
b otherwise if i primerefers to a variable in the user s source code keep the relabeling as itrefers to a variable that is in use.
c otherwise remove the relabeling because the variable name is not of interest.
all of these algorithms work together to create an optimal set of edit proposals for the user.
since eclipse providessupport for mapping ast nodes to the source code we areable to use the error notification markers of eclipse to denoteregions in the user s code where changes need to be made.
v. r esul ts our framework relies heavily on the ability of the target recognition algorithm section iv a to react to the followingsituations appropriately as the differences between two fragments of code increases the pq gram distance also increases.
the trend in pq gram distances should have minimal impact due to variable name differences sec tion iv c in the source and target programs.
as a preliminary evaluation of our prototype we focus on validating these two key technical assumptions.
a thoroughevaluation of edit recommendations section iv b needs userstudies and is out of the scope of this paper.
to test these assumptions as well as the recommendation algorithm itself a knowledge base of different searching and sorting algorithms was built each featuring a test suite ofperturbed implementations.
the test suites were divided intofour complexity classes as follows i semantically equivalent syntactic differences but semantically equivalent methods ii minimal edits are minimal including at most a few relabelings iii moderate edits are moderate including at least one insertion or deletion but no more than one of each and finally iv severe edits are more severe including a pair of insertions or a pair of deletions.
for each test suite two sets of the pq gram distances between the source and target asts were computed oneincluding identifiers and the other excluding identifiers.
infigure we sample the three representative cases out of32.
the result shows that in general the pq gram distancesincrease as complexity increases.
secondly the distance trendsfor asts with identifiers and without are similar with smalladjustments due to the number of ast nodes being reduced.the results are consistent across all test suites.
note that the trend in figure is not monotonically increasing due to one of the following two factors.
first theplacement of edits relative to one another can impact theireffect on the distance between trees.
for example two adjacentdeletions can disrupt significantly more sibling relationshipsthan removing two nodes far from one another.
second thelevel of placement of edits affects their impact on the distancescore.
an edit at a lower level particularly leaves affectsfewer pq grams than a higher level non leaf edit.
due tothe varying nature of the algorithms under test the editscannot be placed uniformly across all algorithms resulting innon uniform trends.
overall our preliminary evaluation showspromising results as it validates our key technical assumptions.
vi.
l imit a tions and future work we now present some of the limitations of the framework and opportunities for future improvements.
program analysis we use ast for our analyses.
ast based analyses work well even under compilation errors whichis critical for novices.
also our framework can be quicklyadapted to a new language that can be parsed into asts.however ast based analyses are intraprocedural analysis ofone method at a time .
use of interprocedural analyses spansmultiple methods remains a future work.
semantic equivalence one major pitfall of ast representations of source code is the loss of behavioral information.
287because syntactically different programs can behave equivalently the ast based approach toward finding differences willincorrectly classify many pieces of source code as differenteven though they accomplish the same task.
a few semanticequivalences are reduced to a canonical form in our currentprototype such as normalizing the for loop to the while loop and normalizing operators in the form x y tox x y but there are others that need special care.
we have exploredthe possibility of using control flow graphs cfg built ontop of jimple intermediate representation ir of soot instead of ast.
soot to a certain extent optimizes ir to havesimilar flow structures for semantically equivalent programs.however compilation and de compilation are asymmetric op erations and the recommendations based on ir do not mapwell with the original code.
semantic equivalence remains akey area to be explored in the future.
usability testing so far our evaluation efforts have been directed towards validating the technical aspects of the frame work.
as a future work we plan to conduct user studiesto assess the quality of recommendations in a controlledenvironment.
we also plan to evaluate the framework by usingit as a part of our introductory programming courses.
vii.
c onclusion novices may face several challenges while learning programming.
tooling efforts in software engineering have beenmore focused on helping programmers with higher level pro gramming tasks than with basic language specific constructs.we present a framework that can help novices in their learningprocess by recommending specific code edits relevant to theirproblems within the eclipse ide.
our preliminary resultsestablish technical feasibility of the framework.
in the future we plan to conduct user studies to test the usefulness of ourprototype.
we also plan to release the framework as an opensource tool for both instructors and students.
r eferences r. anderson r. anderson k. m. davis n. linnell c. prince and v .
razmov supporting active learningand example based instruction with classroom technol ogy in sigcse pp.
.
n. augsten m. b ohlen and j. gamper approximate matching of hierarchical data using pq grams in vldb pp.
.
j. brandt m. dontcheva m. weskamp and s. r. klemmer example centric programming integrating websearch into the development environment in chi pp.
.
m. bruch m. monperrus and m. mezini learning from examples to improve code completion systems in fse pp.
.
m. etheredge fast exact graph matching using adjacency matrices in pcg pp.
.
j. r. falleri f. morandat x. blanc m. martinez and m. montperrus fine grained and accurate source codedifferencing in ase pp.
.
g. fischer cognitive view of reuse and redesign ieee softw.
vol.
no.
pp.
.
g. fischer a. c. lemke t. w .
mastaglio and a. i. m rch using critics to empower users in chi pp.
.
m. grechanik c. fu q. xie c. mcmillan d. poshyvanyk and c. cumby a search engine for finding highlyrelevant applications in icse pp.
.
r. hoffmann j. fogarty and d. s. weld assieme finding and leveraging implicit