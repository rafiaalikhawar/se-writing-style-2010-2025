debugging for reactive programming guido salvaneschi mira mezini t echnical university of darmstadt germany salvaneschi mezini cs.tu darmstadt.de abstract reactive programming is a recent programming technique that provides dedicated language abstractions for reactive software.
reactive programming relieves developers from manually updating outputs when the inputs of a computation change it overcomes a number of well know issues of the observer design pattern and it makes programs more comprehensible.
unfortunately complementing the new paradigm with proper tools is a vastly unexplored area.
hence as of now developers can embrace reactive programming only at the cost of a more challenging development process.
in this paper we investigate a primary issue in the field debugging programs in the reactive style.
we analyze the problem of debugging reactive programs show that the reactive style requires a paradigm shift in the concepts needed for debugging and propose rp debugging a methodology for effectively debugging reactive programs.
these ideas are implemented in reactive inspector a debugger for reactive programs integrated with the eclipse scala ide.
evaluation based on a controlled experiment shows that rp debugging outperforms traditional debugging techniques.
categories and subject descriptors d. .
interactive environments keywords functional reactive programming debugging .
introduction reactive programming rp has been proposed as a viable alternative to the observer design pattern in developing reactive applications such as graphic user interfaces animations and event based systems.
the idea behind rp is to support language level abstractions for signals time changing values that are automatically updated by the language runtime.
in rp programmers specify the functional dependency of a signal on other values in the application and changes are automatically propagated when it is required.
this way programmers do not risk to forget updating dependent values and benefit from a programming style that is easier to read thanks permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citationon the first page.
copyrights for components of this work owned by others than acmmust be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or afee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt acm.
isbn .
.
.
.
declarative approach of rp and supports composition as signals can be composed to define other signals.
it has been shown that applications based on rp are more composable .
our earlier studies also suggest that rp is less error prone and easier to understand than the observer design pattern.
rp witnessed a long incubation in experimental research projects which clarified the semantics foundations and investigated the issue of providing a sound and efficient implementation.
since then researchers proposed several rp implementations such as frtime scheme flapjax javascript scala.react scala and dream java just to mention a few.
recently concepts from rp have been adopted in a number of front end javascript libraries like angularjs.js razor.js react web frameworks like scala lift and by microsoft s reactive extensions rx popularized by the netflix success story.
rp abstractions are now well understood and properly supported in a variety of languages.
y et programmers that want to embrace rp have to face a number of challenges due to the immaturity of the field.
a primary issue concerns supporting rp in the entirety of the development process through a proper tool ecosystem.
in particular novice rp developers struggle for the lack of proper debuggers essential instruments to fix errors and understand programs since the early age of computing.
of course modern ides provide support for debugging highlevel languages but unfortunately existing debuggers are hardly useful for rp applications.
the issue is a conceptual one.
existing debuggers are inherently based on the imperative programmingmodel for which they have been designed and they are unsuitablefor the declarative and data flow oriented model of rp .
concepts like stepping over statements breakpointing or inspecting memory changes assume an imperative model where statements execute one after the other and modify memory state.
designing a debugger for rp requires a paradigm shift.
in this paper we propose a novel debugging technique rp debugging which addresses the urgent needs of developers when debugging applications in the rp style.
the key contribution is to adopt the dependency graph among signals the same model developers adopt to reason about reactive applications as a primaryruntime representation of the program during the debugging process.
we show that well known concepts from traditional debugging find a natural mapping into this model.
rp debugging is implemented inreactive inspector a plugin for the eclipse ide.
a controlled experiment confirms the benefits of rp debugging.
in summary this paper makes the following contributions.
we propose rp debugging a debugging technique that specifically addresses applications written in the rp style.
the design ofrp debugging is motivated by our experience in rp on several projects requirements observed on independent projects and ieee acm 38th ieee international conference on software engineering a preliminary study based on subjects.
we show that traditional debugging concepts have an elegant counterpart in rp debugging.
we analyze the debugging process of reactive applications andidentify common error patterns.
we show that in contrast totraditional debugging techniques which hardly help for such applications rp debugging is effective.
we provide reactive inspector a reference implementation for rp debugging in the form of an eclipse plugin.
we evaluate reactive inspector with a controlled experiment involving subjects which confirms its advantages over traditional debugging for reactive applications.
reactive inspector and the data collected in the experiments are publicly available.
.
background reactive applications are traditionally developed in oo programming by using the observer design pattern.
this solution has been criticized for a long time.
for example as handlers typically return void and perform their action via side effects reactions cannot be composed.
also the execution of the application depends on both control and data flow which complicates program comprehension.
finally inversion of control makes automated analysis of reactive applications hard.
the interested reader can refer to for a complete overview.
rp solves the aforementioned problems by introducing timechanging values often referred to as behaviors or signals in the rest we use the latter conforming to most of scala literature .
signals are essentially constraints that are automatically enforced by the language runtime by recalculating their value when an inconsistency is detected.
for illustration consider the code snippet in figure .
it defines two vars aandb lines i.e.
reactive values that in contrast to signals can be imperatively updated.
line defines a signal swhich depends on aandbaccording to the signal expression a b .
the notation inside signal expressions establishes a dependency among reactive variables.
signals can depend on vars and on other signals like in line .
when a var is updated line the signals that depend on the var are automatically updated without programmer intervention lines .
it is easy to see that therelation between signals and vars can be described by a directed graph where edges model dataflow dependencies.
operationally a change in a node of the graph triggers a reevaluation of the signal expressions in the dependent nodes.
this is actually the implementation technique adopted by most rp frameworks.
figure shows the evolution of the dependency graph for the code in figure .
lines in figure correspond to node creations steps in figure and dependency construction steps .
a var update line triggers a reevaluation in the graph steps .
simple as it is this programming paradigm proved effective in managing the complexity of reactive applications in a numberof fields including web applications interactive guis animations wireless sensor networks and robotics .
for example the application in figure shows a validation formin a web application.
the pwd signal contains the current input of the user in the password field.
consistently with existing rp frameworks we assume that the graphic library in use is signalaware and directly provides such value as a signal e.g.
via the window.pwdfield field line .
the application requires that the password is at least characters long and contains at least a digit.
a var 2val b var 3val s signal a b 4val t signal s 5println s.get 6println t.get 8a 9println s.get 10println t.get figure signals and vars in rp.
a a b 2s ?
a b 2s ?
a b t s a b 2t s a b 2t s a b s a b t ?
s a b 2t s a b figure evolution of the dependency graph.
these conditions are expressed by the hasenoughchars signal and by the containsdigit signal lines .
the form color expressed by the signal in line is green only if the passwordinserted by the user is valid red otherwise.
similarly a proper warning message is displayed depending on which condition is not satisfied line .
crucially the entire application is written in adeclarative style where each entity is determined by its definition and no callbacks are required.
.
designing rp debugging rp debugging is a new debugging paradigm which provides support to inspect and reason about the flow of changes througha reactive application.
when an application is debugged with rp debugging the user can visualize the dependency graph and use it as the basic model for reasoning about the application execution.
in the rest of this section we will first motivate the need for a new debugging approach for reactive applications by a discussion of the conceptual mismatch between the concepts underlying rp and traditional debuggers followed by some empirical evidence collected in a preliminary study and by experience with reactive application development.
subsequently we provide a high level overview of the features of the rp debugging approach proposed in this paper.
.
motivation limitations of traditional debuggers.
debuggers can provide different functionalities but the fundamental feature is to interrupt the execution of theprogram regularly stepping or in certain points of the execution breakpoints to better understand the program flow and inspect the intermediate states of the memory.
this model developed in theold times of assembly languages is still adopted for modern highlevel oo languages.
such approach is inherently designed for an imperative shared memory based control flow driven programming model.
it is however unsuitable for rp functional based on immutable data and data flow driven.
in the rest we analyze this mismatch in detail 7971val pwd window.pwdfield input signal 2val hasenoughchars signal pwd .size 3val containsdigit signal pwd .contains .. 5val formcolor signal 6if hasenoughchars containsdigit color.green 8else color.red 11val warninglabel signal if !hasenoughchars password too short!
else if !containsdigit a digit is required!
else figure a validation form implemented with rp.
imperative vs. declarative .
in imperative programming developers explicitly define control flow by means of control structures.
this way they can reason about memory states and changes and instruction reachability .
instead in rp programmers do not explicitly define control rp is declarative and the execution flow among the evaluation of signal expressions is implicit and data driven.
hence a debugger that is only designed for explicit control structures ignores a fundamental part of the execution flow of a rp application.
lack of abstractions .
traditional debuggers are not aware of rp abstractions like dependencies among signal expressions or change propagation in the dependency graph.
hence programmers are forced to reason in terms of the low level concepts that in the specific rp framework are used to implement rp .
this state of the affairs is similar to a debugger for low level languages which ignoring exceptions steps through the goto statements that implement exceptions in that specific runtime.
mismatch in the mental model .
the runtime model adopted by traditional debuggers is the execution stack.
in rp instead developers reason in terms of dependency graph are interested in knowing which dependencies are active at a certain point in time and use the dependency graph as the runtime model to understand the evolution of reactive applications section .
.
collecting empirical evidence.
the validity of the dependency graph as the reference model to reason about rp programs is suggested by a number of independent experiences.
over the years we observed that programmers spontaneously develop the solution of an explicit representationof the dependency graph.
besides our personal experience as rp developers students involved in classes on rp independently developed small applications to visualize the dependency graph.
these systems adopt various technologies e.g.
graphviz flash and offer different levels of refinement but all of them focus on displaying the evolution of the graph over time.
also practitioners developed similar representations .
while none of these approaches offers all features of rp debugging these attempts strengthen our confidence in the solution we propose.
the design of rp debugging has been conceived during the development of a number of reactive applications publicly available.
these include software we developed from scratch like a distributed drawing application an rss feed reader and a text editor.
also we refactored existing applications to use rp such as the swing scala library the twitter api and a minimal reactive version of the scala collections framework .
the bugs presented in section are drawn from this experience and the functionalities we selected forrp debugging are those we needed during development.q1 i tried to use a debugger with a rp program at least once y n q2 traditional debuggers stepping over statements breakpoints variables inspection are not suitable for rp because these operations are hardly applicable to the declara tive rp model.likert q3 which features would you like to see in a debugger that specifically targets rp?open q4 visualizing the dependency graph would help debugging rp programs.likert q5 visualizing the propagation of the values in the dependency graph would help debugging rp programs.likert figure questions in the preliminary study.
to achieve a more objective view of the limitations of traditional debugging in the rp context and to collect guidelines for the design ofrp debugging we organized a preliminary study involving subjects.
all of them are 3rd 4thyear students from a cs program attending an advanced software engineering class which includes two lectures 2h 2h and homework on rp .
the problem of debugging rp programs was never discussed during the lectures.
subjects were given the questionnaire in figure .
order avoids that certain questions influence the answer to others especially q4 and q5 can bias q2.
y n indicates a y es no answer likert indicates a likert scale strongly agree agree neither agree nor disagree disagree strongly disagree open is for an open text question in q3 we let the answer optional to collect only genuine suggestions.
according to the answers of q1 subjects attempted to use a traditional debugger with a rp program.
given that students were not suggested to use a debugger during the lectures homework we consider this low number not surprising.
the answers to q2 show that traditional debuggers are considered unsuitable for rp by the majority of subjects figure top .
this trend seems to be stronger if we consider subjects who actually tried to debug rp programs figure bottom left than subjects whodidn t figure bottom right .
however statistical tests are only close to significance in showing a difference between populations mann whitney u test p .
.
.
in total subjects answered q3.
among them explicitly mentioned the visualization of the dependency graph e.g.
navigating the dependecy graph .
a separate set of subject did not explicitly mention the dependency graph but proposed features that also inspired the design of rp debugging e.g.
see how the computation values flow through when one value is changed live monitoring of the dependencies and snapshots of the whole environment at the time of a certain execution that it shows the current and the last value of a signal and possibility to step to next point in program execution when a specific event fires .
this result strengths our confidence that visualizing the dependency graph and its evolution is a real need for developers.
finally the answers to q4 and q5 figure also suggest that visualizing the dependency graph and change propagation through the graph is a desirable feature.
in q4 and q5 .
respectively .
of the subjects answered strongly agree oragree .
.
rp debugging in a nutshell main features of rp debugging.
rp debugging consists of adopting the dependency graph as the model to reason about rp code.
it includes the following features at the definition site of the signals the user can step through the construction of the graph visualizing the creation of new nodes and of new dependencies among reactive values as soon as they are established.
we demonstrate this feature in sections .
.
.
798figure answers to q2 top and their breakdown for yes in q1 bottom left and no in q1 bottom right .
figure answers to q2 left and q5 right .
when the execution reaches the assignment of a var the content in the nodes of the dependency graph starts changing.
similarto what developers would do with lines of code in imperative programming they can step through the update of values in the dependency graph and control the potentially changing shape of the graph to make sure it reflects their intentions.
this feature is demonstrated in section .
.
programmers can set conditional breakpoints on the updateof a node.
the execution continues to traverse imperative andreactive code in the application until the node update is hit.
at this point the reactive debugger stops and returns the control to the developer.
this feature is demonstrated in section .
.
programmers can inspect the performance of an application on aper node basis absolute performance .
also in rp debugging developers can observe the number of times a node outputs a different value as a percentage of reevaluation times relative performance .
this information is particularly useful to detect performance bugs related to erroneous graph configurations.
this feature is demonstrated in section .
.
paradigm shift.
figure shows how the main concepts of traditional debugging find a counterpart in the rest in rp debugging.
stepping users step over code to execute a statement at a time.
as the execution is slowed down the user can check the actual control flow of the application and stop the execution at interesting points.
stepping over statements makes little sense for declarative languages.
the user can step through the node update propagation in the dependency graph.
breakpoints stepping until a certain point in the execution may be tedious.
users can ask the debugger to stop the execution when an instruction in the flow is hit.
users can stop the execution when a node in the dependency graph is evaluated and the result of its expression is updated.
inspect memory during stepping programmers can inspect the content of the memory i.e.
the active variables in the stack frame and the visible objects on the heap.
programmers can inspecttraditional debugging rp debugging stepping over statements stepping over the dep.
graph breakpoint on line x breakpoint on node x inspect memory inspect values in the dep.
graph navigate object