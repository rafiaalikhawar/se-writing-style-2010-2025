code first model driven engineering on the agile adoption of mde tooling artur boronat school of informatics university of leicester uk artur .boronat leicester .ac.uk abstract domain models are the most important asset in widely accepted software development approaches like domain driven design ddd yet those models are still implicitly represented in programs.
model driven engineering mde regards those models as representable entities that are amenable to automated analysis and processing facilitating quality assurance while increasing productivity in software development processes.
although this connection is not new very few approaches facilitate adoption of mde tooling without compromising existing value their data.
moreover switching to mde tooling usually involves re engineering core parts of an application hindering backward compatibility and thereby continuous integration while requiring an up front investment in training in specialized modeling frameworks.
in those approaches that overcome the previous problem there is no clear indication from a quantitative point of view of the extent to which adopting state of the art mde practices and tooling is feasible or advantageous.
in this work we advocate a code first approach to modeling through an approach for applying mde techniques and tools to existing object oriented software applications that fully preserves the semantics of the original application which need not be modified.
our approach consists both of a semiautomated method for specifying explicit view models out of existing object oriented applications and of a conservative extension mechanism that enables the use of such view models at run time where view model queries are resolved on demand and view model updates are propagated incrementally to the original application.
this mechanism enables an iterative flexible application of mde tooling to software applications where metamodels and models do not exist explicitly.
an evaluation of this extension mechanism implemented for java applications and for view models atop the eclipse modeling framework emf has been conducted with an industrytargeted benchmark for decision support systems analyzing performance and scalability of the synchronization mechanism.
backward propagation of large updates over very large views isinstant .
keywords domain model mde emf roundtrip synchronization algebraic specification performance analysis.
i. i ntroduction agile methods do not provide guidance on design and na vely assume that it emerges from each iteration relying on re factoring to embed design decisions .
such an approach results in a possibly rather diffuse implementation of the domain model.
domain driven design ddd widely accepted approaches for building complex software systems regards application domain knowledge as the most important asset for their design relying on a model of the domain for clarifying requirements with domain experts andwith developers.
uludag et al.
showed how ddd facilitates the integration of design practices including the definition of a domain model in agile software development for large systems .
however it is difficult to systematize the design of the domain model according to ddd .
model driven engineering mde encompasses the application both of modeling notation for representing such domain and of model management tools for their automated analysis and processing .
a number of studies have investigated the state of practice of mde identifying core challenges that affect the adoption of mde highlighting poor documentation tool maturity synchronization of models with code.
in addition seybold et al.
remark a steep learning curve to use mde tools even for well seasoned java developers.
to adopt modeling practices hutchinson et al.
recommend a change of mentality in the organization as a progressive and iterative process.
whittle et al.
recommend more research on support for facilitating the creative process of modeling and a stronger emphasis on simple tools that can be embedded in software development processes.
we propose an approach to adopt non intrusive mde tooling in agile practices by cherry picking the most suitable tool either mde agnostic or mde aware depending on the task at hand.
developers can keep using the tools and programming languages that they are familiar with.
mde tooling can be applied for specific problems without requiring a strong commitment thereby fostering a gradual application of modeling practices and as a consequence learning mde.
our approach facilitates flexible modeling in technical spaces that are mde agnostic where a notion of metamodel does not exist.
we are thus approaching flexibility from the point of view of interoperability.
building domain models can be done using programming languages familiar to developers e.g.
java facilitating the development of executable prototypes that need not be thrown away.
while a model first approach has undoubtedly many benefits for software development practitioners usually prefer a code first approach that delivers feedback quickly without having to resource to heavyweight modeling frameworks.
in our work we consider the eclipse modeling framework emf which is a mature java based metamodeling framework that unifies the use of java uml and xml that can be used both for developing data driven systems and for designing domain specific languages.
accord8742019 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ing to emf is still by far the most popular mde tool within the eclipse ecosystem used in open source projects.
emf augments java with the possibility of exploiting the meta represented model through reflection facilities xml serialization and with non trivial facilities like ensuring systematic consistency of bidirectional associations which are common in many applications and usually implemented ad hoc.
unfortunately its adoption in the development of existing applications breaks backward compatibility which is a highly regarded practice in agile software development as its absence breaks continuous integration and delivery .
moreover model driven reverse engineering processes may also require non trivial data migration processes making emf rather a heavyweight technology.
while mde agnostic applications can be reverse engineered or adapted a few approaches build interfaces with mde technology for mdeagnostic systems at run time.
these approaches have been evaluated with a number of case studies used in industry.
a quantitative analysis of performance and scalability has nonetheless not been performed with very large data sets.
therefore it is unclear to what extent such interfaces can be used with state of the art techniques.
in this work we have implemented a bidirectional synchronization mechanism that bridges mde agnostic java programs and mde aware emf based systems at the data level using techniques from modern model transformation including transformation of feature values on demand and incremental propagation of updates.
this mechanism has been evaluated considering performance and scalability perspectives by using an industry targeted benchmark for decision support systems tpc ds that involves very large data sets.
the conclusions of this research should help inform decisions when adopting mde technology depending on the scalability requirements of the system to be developed.
in such decisions could only be taken for model cardinalities of up to 116k elements which are now raised to the millions.
the contributions of this work are summarized in this paragraph.
in section ii an algebraic presentation of domain models and view models and of model instances or system states and views is developed describing the view update problem at stake.
the formalization is novel revolving around the notion of feature value as opposed to object as unit of data and relies on standard mathematical entities.
this formalization scaffolds the conceptualization of our contribution independently of the chosen object oriented programming language and metamodeling framework fostering reuse of the proposed code first mde approach in a variety of use cases within the object oriented paradigm and in their implementation.
in section iii we discuss a solution to the view update problem by presenting a synchronization model that is independent of technical spaces and then discuss how it has been realized in emf s yncer using state of the art transformation techniques including deferredexecution and bidirectional incremental propagation of updates for syncing java programs with emf views at run time.
emf s yncer does not require modifying existing systems and guarantees backward compatibility.
the formal representation of the synchronization model adopts a declarative stance focusing on preconditions and key operation properties that facilitate their correct behavior without having to deal with implementation intricacies.
in section iv emf s yncer is analysed in terms of performance and scalability by using the tpc ds benchmark.
the results of this empirical evaluation are then used to discuss to what extent in terms of size of data sets it is feasible to use emf based tooling.
in section v related work is discussed concluding with some final remarks and future research directions.
ii.
v iew upda te problem our approach is inspired in the view update problem as we consider view models of existing domain models that are implicit and possibly scattered in object oriented programs.
a view model can be a faithful reflection of the domain model or a projection of it but extensions of view model classes involved in the synchronization are not supported.
this design decision is justified by the fact that we are interested in a pragmatic application of mde technology to non mde object oriented programs without losing information during synchronization.
this does not preclude a user from using additional classes to store auxiliary information during the mde process whose existence will be forgotten by the synchronizer.
in the following subsections we present an algebraic formalization of models of their instances and of updates concluding with an informal description of the synchronization problem.
this formalization lays the foundations for presenting synchonization model in section iii independently of specific programming modeling languages and accompanying tool support .
a. domain models and view models an excerpt of a domain model representation in a java program is given in listing which declares the domain class storereturns and decorates its fields with jp a annotations1that link the class to a table in a relational database used in the experiments in section iv.
the corresponding class in the view model where only the fields of interest have been captured is represented in figure and in section iii c the definition of a view model from a domain model is explained in more detail.
in this work we are interested in capturing updates at the granularity level of structural features within objects 1the meaning of the used jp a annotations is not relevant for the presentation of the work and they have been included to show that there is non mde technology that is made available to mde tools through the emf s yncer .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and they are treated as independent units.
therefore objectoriented domain models are represented as a set of structural feature values that are well typed from which specific objects can be derived.
we start by defining the notion of feature type and the notion of feature value definition feature type lettbe a value type indexed by the set nof natural numbers as defined by the following grammar t dt e c t t where dtdenotes any primitive data type such as string integer boolean etc.
available in ecore and their counterparts in java pg edenotes any user defined enumeration type and c denotes any class type representing sets of object identifiers o andt t denotes sets of entries mapping a key of type t to a value of type t .
a feature type fm c twheremis a record l u ordered unique cont op describing the usual properties of a feature a lower bound l an upper bound u whether the feature is ordered orunique whether it is a cont ainment and the opposite reference if any.
note that a feature type uses value types tthat are indexed by n i.e.
n t. however notation is abused and we represent them by t for the sake of simplicity but their valuesviare represented with an explicit indexed i n. a view model v m is represented by its set of feature types.
these can be either attribute values when either t dt ort e or reference values when t c. each feature type denotes a possibly infinite set of feature values representing the constituents of a model instance.
a domain model m can be regarded as a partial specification of a view model where some design decisions e.g.
multiplicity constraints are not captured nor documented probably not intendedly.
therefore the same representation can be used both for domain models where the mcomponent is optional and for view models.
entity public class storereturns onetoone fetch fetchtype.lazy joincolumn name sr returned date sk referencedcolumnname d date sk private datedim srreturneddatesk column name sr return time sk private long srreturntimesk embeddedid private storereturnsid srid manytoone fetch fetchtype.lazy joincolumn name sr customer sk private customer srcustomersk manytoone fetch fetchtype.lazy joincolumn name sr store sk referencedcolumnname s store sk private store srstoresk column name sr return amt private double srreturnamt ... listing .
excerpt of java domain class figure .
excerpt of view model used for the tpc ds benchmark for example considering the abbreviations storereturns assr storereturnsid assrid customer asc store ass datedim asd the class storereturns of figure is represented using the following feature types srreturnamt sr edouble srreturndatesk l u sr d srid l u sr srid srcustomersk l u op storereturns sr c srstoresk l u op storereturns sr s inheritance can also be considered in this representation.
a na ve and verbose strategy consists in defining feature types for the class in which it is declared and for each of its subclasses.
more precisely when a feature fis declared for a class with name cwith a type tand multiplicity constraints m a feature type fm c tis in the model together with each feature type of the form fm c t wherec is the name of a subclass of the class with name c. however such formal representation is only used at a conceptual level in our framework and end users can keep using the corresponding notation in their technical space java programs or emf models in this work.
b. domain model instances and views we use the notation v tfor denoting that a value vbelongs to the domain of a type t i.e.v llbrackett rrbracket.f o r representing values we use families of values vi denoting sets i v fori n. the notation for families of values viis abused and we also use it for representing a specific value v indexed by a given natural number i. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
this confusion is disambiguated from the context where the expression is used.
when the context mentions one feature value then virefers to an indexed value and it refers to a family of values viotherwise.
therefore we will use the predicate vi tto denote that all the values in the family vi are typed with t. definition feature v alue given a feature type fm c t a feature value is defined as a mapping f o vi whereo candvi t. given a modelm a model instance mis represented as a setmof feature values f o vithat are typed with the feature types inm and the instance of relation at model instance level is denoted by m m .
the notion of model instance may refer either to a domain model instance or system state or to a specific view .
when the component m in a feature type fm c tspecifies constraints the notion of feature value f o viis enriched as follows cardinality constraints the cardinality of a value family viis constrained as follows m.l vi m.u order is captured by the index iof a value family vi unique if a feature has the unique constraint m.unique then for any i the set i v for a particular feature value defines an injective mapping containment integrity if a feature f o viinmis a reference and has the containment constraint then for any object o referred by f there cannot exist another containment f inm which also contains the object o bidirectional associations if a feature finm is a reference belonging to object opoints to object o and has an opposite reference f then the feature value f o oi for a some i also belongs to m. c. view updates in our approach mde views which are synchronized with a domain model instance can be materialized through a persistence api in the mde technical space or it can be used as a virtual view at run time.
in both cases views can be updated and such updates are incrementally propagated to the underlying domain model instance on demand.
there are two main cases of view updates when root objects w.r.t.
the containment hierarchy are added or deleted and when feature values are updated.
in what follows we develop the notion of update that is used in our synchronization model and explain how an update is applied to a model instance which can be a domain model instance or its associated view.
definition atomic updates given a modelm and a model instance m such that m m an atomic update is represented as a pair f o vi upsert delete fm c t for a specific value vindexed by some i. according to this definition an atomic update can only affect one value in the family of values bound to the object othroughf.
2in emf the value 1is used to denote the uml value many b u t we simply consider that is the infinite natural number.the set of updates for a particular model m comes equipped with a binary operation so that for all given 1 2 3 is associative i.e.
1 2 3 1 2 3 1is the identity element i.e.
1 1 1 for any update there is an inverse delta 1that cancels the former i.e.
.
hence represents the set of composite updates that can be defined as sequences of atomic updates including empty and singleton sequences.
definition update application given a model m and a model instance m such that m m a delta is applied to m denoted by the expression m using the operator m m as follows upsert f o i v m f o vi i v m f o vi i v update upsert f o j v m f o vi m f o vi j v when i i j insert delete f o j v m f o vi i v m f o vi delete m m identity 1 2 m 2 1 m composition where represents disjoint union of sets.
in the equational presentation above terms with variables are used in the left hand side of the equations to denote a search of the relevant feature values in given model instance through pattern matching.
an upsert update is characterized with the equations update which updates the value v at position iwith the new value vin the featureffor object o and insert which inserts a new value at an index jthat is not used.
a delete update is characterized with the equation delete where the expression i v characterizes the set of indexed values with the value v in case there are duplicates.
hence deletion has set semantics and all entries containing the value vare deleted irrespectively of their indexes.
equations identity and composition define the base case of the inductive definition of the application operator over the structure of updates and that update application is compositional.
when considering updates the following assumptions are taken into account an atomic update can be applied if it refers to a valid feature type i.e.
updates are type preserving and to an existing object type preservation a feature value whose cardinality is the lower bound cannot be subject to a deletion lower bound a feature value f o vi with the unique constraint cannot be subject to an insert of a value that is already contained in vi a feature value whose cardinality has met the upper bound cannot be subject to an insertion although it may be updated upper bound when a reference value is updated and this reference has an opposite the update of the opposite reference is included in the update authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bidirectional reference integrity an update describing a move of an object from one container to another one is defined in terms of an atomic deletion of the object from the source container followed by a upsert of the object to the target container containment integrity when an object is removed all of its containments are removed recursively and resulting dangling