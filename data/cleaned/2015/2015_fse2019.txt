detecting concurrency memory corruption vulnerabilities yan cai state key laboratory of computer science institute of software chinese academy of science china ycai.mail gmail.combiyun zhu state key laboratory of computer science institute of software chinese academy of science and university of chinese academy of sciences china zhuby ios.ac.cnruijie meng state key laboratory of computer science institute of software chinese academy of science and university of chinese academy of sciences china mengrj ios.ac.cn hao yun state key laboratory of computer science institute of software chinese academy of science and university of chinese academy of sciences china yunhao ios.ac.cnliang he tca institute of software chinese academy of sciences china heliang iscas.ac.cnpurui su tca sklcs institute of software chinese academy of sciences and school of cyber security university of chinese academy of sciences china purui iscas.ac.cn bin liang school of information renmin university of china china liangb ruc.edu.cn abstract memory corruption vulnerabilities can occur in multithreaded executions known as concurrency vulnerabilities in this paper.
due to non deterministic multithreaded executions they are extremely difficult to detect.
recently researchers tried to apply data race detectors to detect concurrency vulnerabilities.
unfortunately these detectors are ineffective on detecting concurrency vulnerabilities.
for example most of data races are benign.
however concurrency vulnerabilities are harmful and can usually be exploited to launch attacks.
techniques based on maximal causal model rely on constraints solvers to predict scheduling they can miss concurrency vulnerabilities in practice.
our insight is a concurrency vulnerability is more related to the orders of events that can be reversed in different executions no matter whether the corresponding accesses can form data races.
we then define exchangeable events to identify pairs of events such that their execution orders can be probably reversed in different executions.
we further propose algorithms to detect three major kinds of concurrency vulnerabilities.
to overcome potential imprecision of exchangeable events we also adopt a validation to isolate real vulnerabilities.
we implemented our yan cai is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
as a tool convul and applied it on known concurrency vulnerabilities and the mysql database server.
compared with three widely used race detectors and one detector based on maximal causal model convul was significantly more effective by detecting of known vulnerabilities and zero day vulnerabilities on mysql four have been confirmed .
however other detectors only detected at most out of the known and zero day vulnerabilities.
ccs concepts software and its engineering multithreading software testing and debugging .
keywords concurrency multithreaded race conditions vulnerability acm reference format yan cai biyun zhu ruijie meng hao yun liang he purui su and bin liang.
.
detecting concurrency memory corruption vulnerabilities.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
introduction memory corruption vulnerabilities are frequently exploited to launch various attacks.
unfortunately these vulnerabilities can also exist in multithreaded programs due to improper synchronizations .
in this paper we call memory corruption vulnerabilities caused by improper synchronizations in multithreaded programs as 706esec fse august tallinn estonia yan cai biyun zhu ruijie meng hao yun liang he purui su and bin liang concurrency memory corruption vulnerabilities orconcurrency vulnerabilities for short.
they are extremely harmful and can be exploited to launch severe attacks.
for example the notorious vulnerability dirtycow in linux kernel occurs in multithreaded environment and can be exploited to gain root privileges for a normal user.
it has existed in linux kernel for about ten years from to .
hence it is urgent to detect concurrency vulnerabilities.
however the detection of concurrency vulnerabilities is challenging.
one straightforward approach would be to explore all possible thread interleaving e.g.
model checking approaches .
however unlike sequential programs the executions of multithreaded programs suffer from interleaving space explosion problem .
in practice it is impossible to explore all executions of a multithreaded especially on large scale programs.
a feasible solution is to borrow approaches on detecting concurrency bugs .
researchers have adopted data race race for short detectors .
these detectors have been used to detect all possible candidates for further detection of concurrency vulnerabilities .
however it is ineffective to apply the approaches for race detection to detect concurrency vulnerabilities.
this is because the two concepts are not the same one.
a data race involves two concurrent accesses to the same memory locations but a concurrency vulnerability involves two or more memory operations on a set of closely related memory locations .
another kind of feasible approaches is based on maximal causal models to predict additional execution from a single one .
although the model is sound it is too restricted and a tool based on pure maximal causal model can miss real vulnerabilities .
besides the prediction relies on constraint solver.
without an efficient solver the solving process will be time consuming.
in practice a tool usually adapts a relaxed model and consequently compromises its ability e.g.
ufo missed known concurrency use after free vulnerabilities in our experiment .
in this paper we target on detecting concurrency vulnerabilities involving memory corruptions.
we currently focus on three kinds of concurrency memory corruptions including use after free uaf null pointer dereference npd and double free df which are mostly considered to be caused by orders .
our insight is that the key to detect concurrency vulnerabilities is to determine whether two or more out of a set of events operating memory blocks in a given execution are exchangeable.
that is whether their occurrence orders can be different in alternative executions.if so they may cause a concurrency vulnerability.
from the above viewpoint we define exchangeable events section to determine whether the orders of two events can be probably reversed.
although two events in a race defined by happensbefore relation are also regarded to be exchangeable it is strictly based on synchronizations.
our exchangeable events are defined across synchronizations.
hence our definition has larger coverage.
based on exchangeable events we design three algorithms to detect three kinds of concurrency vulnerabilities from correct executions.
as relaxed exchangeable events are not precise exchangeable we further isolate real ones via scheduling.
we have implemented our framework as a prototype tool convul.
to evaluate it we selected a set of known concurrency vulnerabilities from a cve database and the latest mysql server.for comparison we also selected three well known and representative race detectors as well as a recent work ufo that detects concurrency uafs.
the experimental results show that convul significantly outperformed four tools.
it detected out of known vulnerabilities.
but the three race detectors and ufo only detected or of them.
on mysql convul reported concurrency vulnerabilities and of them have been officially confirmed by mysql developers.
however the three race detectors only detected of the zero day concurrency vulnerabilities on mysql.
ufo failed to detect any one of them.
in summary this paper makes the following contributions it proposes a concept known as relaxed exchangeable events to describe pairs of events indicating that the execution orders of each pair of events can be reversed with a high probability in alternative executions.
it proposes three algorithms to detect three kinds of concurrency vulnerabilities uaf npd and df from correct executions.
it develops a framework convul and reports a set of experiments.
the experimental result shows that compared with both race detectors and a recent work convul is significant effective on detecting both known concurrency vulnerabilities and zero day ones.
our data is available at .
challenges due to the non determinism property of multithreaded executions concurrency vulnerabilities only manifest themselves under certain thread interleaving and are extremely difficult to be detected.
hence traditional approaches e.g.
fuzzing targeting on sequential programs seldom detect concurrency vulnerabilities.
it is also infeasible to explore all possible interleaving.
recently researchers discussed and tried to apply approaches on detecting concurrency bugs to detect concurrency vulnerabilities .
the most promising ones are race detectors because races are widely considered as a cause to concurrency vulnerabilities and there is also a category of vulnerabilities known as race condition where a race is theoretically defined to be two concurrent accesses unordered and with at least one write to the same memory blocks .
although this is indeed true by focusing on races we actually focus on the correctness property of multithreaded executions.
unfortunately there is no gold rule to define races in practice .
for example among popular race detectors some are based on happens before relations and some are based on the lockset discipline as well as the hybrid of them .
hence it is still unclear whether and how a race detector can be well adopted to detect concurrency vulnerabilities.
for example in a recent work among all 645races in linux kernel reported by various race detectors only races are finally confirmed to be related to concurrency vulnerabilities.
there are other disadvantages by directly applying existing race detectors to detect concurrency vulnerabilities.
firstly race detectors not only report false positives but also miss true positives .
even in our experiment section 1note race conditions are not completely the same as races although some works do not distinguish them .
707detecting concurrency memory corruption vulnerabilities esec fse august tallinn estonia acq m free p p null rel m thread t1 thread t2 acq m p test rel m figure a concurrency vulnerability involving no race.
of known concurrency vulnerabilities cannot be detected by three popular race detectors.
secondly not all concurrency vulnerabilities can be detected by race detectors.
this is because that a race is restricted to two concurrent accesses that are expected to occur in parallel.
however a concurrency vulnerability does not have such a restriction it can even occur in a race free multithreaded program as long as the involved accesses can have a different execution order.
for example figure shows two threads a thread t1dereferences a pointer via p test and a second thread t2frees the same pointer free p .
and a concurrency uaf can occur if thread t2executes all its three lines before thread t1.
however the two accesses in the uaf p test andfree p are well ordered by the same lock m no matter which thread executes first.
hence no race detectors can report a race on the two accesses suppose there is a write in free p top .
lastly concurrency vulnerabilities particularly refer to those causing memory corruptions due and can be exploited to launch severe attacks .
however only about to races are harmful .
that is a larger number of races are actually benign and even some races are deliberately introduced .
if we rely on race detectors we have to pay additional effort to identify harmful ones.
other kinds of major concurrency bugs like atomicity violations and order violations may also cause concurrency vulnerabilities .
given an atomic region or an order between two events it will be easy to further identify any violations to them.
however the challenge is how to identify atomic regions or expected orders of two events .
another direction to detect concurrency vulnerabilities is based on scheduling prediction.
the representative one is based on the maximal casual model .
there have been works to predict concurrency npds and concurrency uafs .exceptionull relaxes this model to detect concurrency npds which can miss vulnerabilities .
another limitation of this model is that it relies on constraint solver to determine the feasibility of each potential scheduling.
this introduces performance challenges as it is usually time consuming to solve a large set of constraints.
hence in practice these tools have to relax their model based on heuristics.
this not only affects their precision but also makes them to miss real vulnerabilities.
for example to improve performance of the constraint solver z3 ufo adopts a sub optimal model which can miss uafs i.e.
does not encode all possible uafs see the two paragraphs right above section .
in as also verified in our experiments.
background and definitions .
background this paper focuses on multithreaded programs and is based on sequential consistency memory model .
a multithreaded program consists of a set of threads that execute a set of events concurrentlyand coordinate their paces via synchronizations on locks other synchronization primitives can be defined similarly .
particularly we focus on the following types of events memory read and write read t m andwrite t m a thread treads from or writes to a memory block mand lock acquisition andrelease acq t l andrel t l a thread tacquires or releases a lock l. for simplicity we may omit the thread identifiers in above events e.g.
to use read m instead of read t m .
we also use tid e to extract the thread identifier that executes event e. an execution trace is a sequence of all events tiis a projection of on thread ti i.e.
all events from thread ti .
thehappens before relation hbr for short denoted as is defined as three rules program order given two events and from the same thread if the event is executed before then .
synchronization order if a lock lis released by a thread denoted as rel l and is later acquired by another thread denoted as acq l then rel l acq l .
transition property if and then .
hbr can be tracked via vector clocks .
a vector clock vc of size nis an array of nintegers.
the corresponding algorithms are well known and we will not discuss them in details.
the basic idea is to set three kinds of basic vector clocks vct vcl andvcmfor each thread t for each lock l and for each memory block m respectively.
they are maintained on various events and checked to determine the happens before orders of two events.
.
exchangeable events the execution of multithreaded program exhibits non determinism.
given two events their execution orders may be different in different executions.
however there are still many events where their execution orders are fixed among all executions.
we are more interested in the former.
if their execution orders can be different from the observed orders they may cause a concurrent vulnerability.
to describe such pairs of events we define exchangeable events .
definition .
given two events e1ande2 among all executions if both e1 e2ande2 e1are observed we say that e1ande2are a pair of exchangeable events.
the orders of two exchangeable events must be reversible as both orders are already observed.
and we call such two events as strict exchangeable events.
however it is extremely difficult to observe all two orders in limited executions.
we then propose a concept of relaxed exchangeable event.
before that we firstly present two concepts to describe such kinds of events.
async edge is an edge either from an event acq m to its paired event rel m in the same thread or from an event rel m to a later event acq m by two different threads.
based on sync edge we define the sync distance ordistance for short of two event e1ande2as the minimal number of sync edges that order the two events denoted as d e1 e2 .
figure shows three threads and their synchronizations that totally execute non synchronization events where each gray block indicates a pair of acquisition and release on the same lock.
on the right of figure we also list the distances of all pairs of 708esec fse august tallinn estonia yan cai biyun zhu ruijie meng hao yun liang he purui su and bin liang thread t1 thread t2 e2 e4 e8 e10 e6e1 e3 e5 e9 e7e11thread t3d e1 e2 .
d e1 e3 .
d e1 e4 .
d e1 e5 .
d e1 e6 .
d e1 e7 .
d e1 e8 .
d e1 e9 .
d e1 e10 .
d e1 e11 .sync.
blocks acq ... ... rel ... d e2 e3 .
d e2 e4 .
d e2 e5 .
d e2 e6 .
d e2 e7 .
d e2 e8 .
d e2 e9 .
d e2 e10 .
d e2 e11 .d e3 e4 .
d e3 e5 .
d e3 e6 .
d e3 e7 .
d e3 e8 .
d e3 e9 .
d e3 e10 .
d e3 e11 .source event e1 e2 e3 figure a demonstration on sync distances.
acq m free p rel m thread t1 thread t2 p field ... acq m rel m acq m rel m free p thread t1 thread t2 acq m p field ... rel m acq m rel m free p thread t1 thread t2 p field ... acq m rel m a b c figure three variants of the example in figure .
events from e1 e2 and e3.
for example there are totally syncedges that order e2ande6 hence we have dist e2 e6 where the edges are along the path e2 e4 e5 e6which is short than the path e2 e4 e8 e9 e10 e6 .
and we have d e3 e4 0as there is no sync edge ordering them.
obviously the minimal distance of two events is zero indicating that no sync edge ordering the two events and they are expected to execute in parallel if they are from two threads .
in all other cases there is at least one sync edge ordering them.
hence one of them actually happens before the other.
that is the minimal non zero distance of two events from two threads is .2this case is shown in figure which further has three variants as shown in figure where in each of the three thread t1executes first and the distance of two accesses in bold is .
we are interested in these cases where the distance is larger than zero.
in such cases the order of the two events may still be reversed as shown in figures and .
intuitively given two ordered events if their distance is smaller there will be a higher probability to reverse the execution order of the two events.
besides if there is a third event such that the both distances from two events to it are smaller then there will be a higher probability to reverse the execution order of the two events.
based on these two heuristics we propose d relaxed exchangeable events that is predictable from a single execution as illustrated in figure .
definition .
given an execution trace and its projections on two different threads t1andt2as t1 ... e1 ... and t2 ... eany ... e2 ... respectively let d d e1 e2 if either d 0or d d eany e2 d eany e1 0holds then two events e1ande2ared relaxed exchangeable events denoted as e1 de2.
for example in figure there is a pair of relaxed exchangeable events where e1 p test e2 free p and eanyis any event right 2note for two events from the same thread their minimal distance can be and no two events have a distance of .
3unlike the example in figure for all cases in figure a race detector can report a race on two accesses if the lock acquisition order on mby two threads can be reversed.
e1 e2thread t2 thread t1 eanyd e1 e2 d. d eany e2 .
d e1 eany .figure illustration on d relaxed exchangeable events.
before acq m of thread t2 not shown .
generally for a consecutive lock acquisition and release by two threads if the hbr between two events are only determined by the two acquisitions then the two events are d relaxed exchangeable events for some value of d. in the rest of this paper without explicit explanation all exchangeable events refer to d relaxed exchangeable events.
admittedly like hbr our above definition is not precise.
a precise approach to determine whether the order of two ordered events observed in one execution requires analyzing all memory read and write accesses of all threads between the two events .
this might be partially feasible in theory but ineffective in practice especially on large scale programs .
besides in most cases any memory read or write in between two events does not affect the order of them hence such algorithms will further limit the interleaving coverage on inferring exchangeable events i.e.
reporting false negatives.
hence our definition by considering synchronizations plus an evidence i.e.
eany is more practical and provides larger coverage.
intuitively with increasing value of d the probability to reverse the order of a pair of d exchangeable events may decrease due to other constraints besides synchronizations.
hence in this paper we restrict the value of dto be i.e.
the minimal non zero distance for two events from two threads.
it is also the default value when the distance of two exchangeable events is not mentioned in this paper.
in experiment we show a result under additional difference distances.
our approach convul .
overview convul dynamically analyzes executions and identifies sets of critical operations related to memory operations.
if they can form any of three kinds of concurrency vulnerabilities by exchanging their orders they are reported as potential vulnerabilities.
next convul tries to isolate real ones by scheduling executions to trigger their occurrence.
in the rest of this section we firstly present a basic tracking algorithm for exchangeable events in subsection .
.
then we analyze how three kinds of concurrency vulnerabilities can occur in multithreaded executions as well as how to detect them by our convul .
.
check exchangeable events convul detects concurrency vulnerabilities according to a given distance value of d i.e.
consider d relaxed exchangeable events .
the na ve way to calculate the distance dis straight forward.
it only requires tracking all events and all synchronizations as a graph where memory access events and lock acquisitions are nodes and 709detecting concurrency memory corruption vulnerabilities esec fse august tallinn estonia algorithm check exchangeable events predv c emaps an event eto a predicted vector clock that should be formed when thread t id e releases a lock l. function onanyevent event e predv c e v ct where t t id e .
end function function areexchangeable e1 e2 if e1 e2 e2 e1 then i.e.
d e1 e2 return t rue end if let be the current execution trace.
lett1 t2be the thread ids of e1ande2 respectively.
leterel rel l be the first release on lafter e1in t1 and eacq acq l be the last acquisition on lbefore e2in t2.
leteanybe the event right before eacqin t2.
i.e.
limit d eany e2 if eany e1 e1 eany andv cl predv c e1then i.e.
d eany e1 0andd e1 e2 return t rue end if return f alse end function lock acquisition orders including both thread local ones and acrossthreads ones are edges.
the distance of two events will the be the number of edges on a shortest path from one event to another on the graph.
however this implementation consumes too much memory.
in this paper we design a different one for checking 3relaxed exchangeable events by utilizing hbr tracking based on vector clocks shown in algorithm .
given two events e1ande2 algorithm firstly checks whether they are ordered by hbr if not they are exchangeable events.
otherwise it further extracts three required events erelandeany as well as eacq lines and checks whether they satisfy the conditions in definition lines .
note that in algorithm given line the checking on the conditions in line is an effective implementation of the conditions in definition .
let s explain it below.
if the two events are ordered there must be a lock release event erel and a meaningful eanymust be in a different synchronization block from event e2 otherwise the condition d eany e1 will not be satisfied .
hence there will be at least one lock acquisition event eacq.
besides as we already limit the value of din d exchangeable event to be there will be at most one sync edge between two threads e.g.
see figures and .
as a result there must be the same lock l such that its release and acquisition are the above said lock release after e1and the lock acquisition eacqin between eanyande2.
this also indicates that the vector clock of the lock l right after ereland right before eacq keeps unchanged.
hence to reduce tracking effort algorithm introduces a new vector clock predvc efor each event eto keep a predicted vector clock of a lock lbeing held by tid e when this thread releases lock l line .
it is maintained when event eoccurs line .
if there is no such a lock l it becomes empty.
thus the checking vcl predvc e1determines whether lock lis the one in above events erelandeacq which further determines whether d e1 e2 is line .
a free p thread t1 thread t2 p test p field ... b free p thread t1 thread t2 p test p field ... figure how a concurrency uaf occurs.
algorithm detect concurrency uaf function onmemaccess m t letembe this event.
v cem v ct track status ofeach event end function function onfree p t p apointer toamemory block.
letef pbe this event.
sz derefsize p forifrom 0tosz 1do m deref p i if em such that em ef p then report a uaf.
end if end for end function .
analyze and detect concurrency uafs a uaf vulnerability occurs when a freed memory block is reaccessed .
it is known that more than uafs can be exploited to launch zero day attacks .
a uaf vulnerability is caused by at least two memory accesses free a memory block pointed to by a pointer pand later access the memory block via the pointer p. therefore it is possible that the two accesses can be performed by two threads.
figure shows an example of how a concurrency uaf can occur.
there are two statements p test andfree p where pis a pointer.
in correct executions shown in figure a thread t1first dereferences pointer pand then thread t2frees the memory block via pointer p. however if the memory location is freed by thread t2 first before its use in thread t1 a uaf occurs as shown in figure b .
the challenge is that given the execution order in figure a how we can know the existence of the order in figure b .
this is essentially the difficulty in analyzing multithreaded programs.
for example there might exist the same locks protecting the two accesses in a concurrency uaf and hence no race detector can report a race on it.
for other cases race detector may also be ineffective as discussed in section .
of course if these accesses are all protected by the same locks no race detector can detect the uaf.
our algorithm.
considering the semantics of uafs and the multithreaded executions we propose algorithm to detect possible concurrency uafs.
given a correct execution trace it tracks all memory accesses lines and updates corresponding vector clocks line .
later if there is any free call on p denoted as event ef p algorithm checks whether there is any event accessing memory blocks pointed by p denoted as event em lines .
the function derefsize p returns the size of the memory block pointed byp.
for any such event em ifem andef pare exchangeable events algorithm reports a potential concurrency uaf lines .
710esec fse august tallinn estonia yan cai biyun zhu ruijie meng hao yun liang he purui su and bin liang p test p nullthread t1 thread t2 p test p nullthread t1 thread t2 a b p test p nullthread t1 thread t2thread t3 p q p q p q p test p nullthread t1 thread t2 thread t3 p q p q p q figure how a concurrency npd occurs.
algorithm overcomes limitations of race detectors by checking whether two events are exchangeable events no matter they are well ordered by hbr or not.
.
analyze and detect concurrency npds when a pointer is set to be null and is dereferenced later a null pointer dereference npd occurs.
it can be usually exploited to launch various attacks .
a npd involves a memory write to a pointer with a null value and a later dereference e.g.
p test .
the two events in a npd can be produced by two different threads as shown in figure a where a thread t1dereferences a pointer p and a second thread t2later sets the pointer to be null.
however if the order of two events can be reversed so that thread t2firstly writes the pointer to be null and then thread t1tries to dereference this pointer causing a concurrency npd.
to ease our presentation we use circled number to denote each statement event.
in practice however it is not straightforward to analyze a concurrency npd.
this is because there are often other events in between the two events 1and .
we have systematically analyzed all possible cases and identify three unique ones.
besides the simple case shown in figure a another three cases are shown in figure b where one more event i.e.
or writing the pointer i.e.
p q exists in between the two events 1and .
and the pointer writing event p q can be executed by either of two threads or a third thread i.e.
forming an event or respectively as long as it is executed in between the two events.
in these cases if the pointer writing event p q occurs before the null writing event by thread t2 as or after the pointer dereference by thread t1 as 3or5 a concurrency npd occurs.
on detecting concurrency npds race detectors can precisely report a race on 1and 2in figure a .
however for three cases in figure b although they can report races these races cannot be directly related to concurrency npds.
our algorithm.
our algorithm algorithm tracks all recent null value writes to all pointers i.e.
onmemwrite p val t as well as all pointer dereferences i.e.
onmemread p ins t where ins is the instruction containing the read event to pointer p .
in order to detect all four types of concurrency npds in figure algorithm maintains three additional data structures vcwnulp vcwnnulp andvcrp to track null value writes non null values write and reads i.e.
dereferences to a pointer p respectively.
during runtime for each memory write algorithm checks the value to write to pointer p line .
if the value is null and there was a read event to the same pointer p it will report a concurrency npd if this read event and the current write event p lines arealgorithm detect concurrency npd v cwnulp track null value writes to pointer p. v cwnnulp track non null value writes to pointer p. v crp track reads to pointer p. function onmemwrite p val t ifval nu ll then letewnulp be this event.
if erpsuch that ewnulp erpthen report a npd.
case a end if v cwnulp v ct null value writes else v cwnp v ct non null value writes end if end function function onmenread p ins t leterpbe this event.
ifisderef ins t rue then return end if if ewnulp ewnnulp then ifewnulp ewnnulp then report a npd.
case b else if erp ewnnulp then report a npd.
case b end if end if v crp v ct end function function isderef ins letins n extins ins if hasr ins hasrw ins basere ins oprandre ins then return t rue end if return f alse end function exchangeable events.
this type of concurrency npd corresponds to the one shown in figure a .
next algorithm tracks this write event by updating vcwnulp line or vcwnnulp line according to whether the value to write to pointer pis null.
for the concurrency npds shown in figure b algorithm detects them when a pointer is read in onmemread p ins t .
for a memory read event erpto a pointer p if there are two events ewnulp andewnnulp which are respectively expected to be 2and one of and 5in figure b that write a null value and a non null value to p algorithm further checks the following conditions to detect concurrency npds if the two events ewnulp andewnnulp are exchangeable events a concurrency npd is reported lines .
here the two events are 2and 4or2and .
if the two events erpandewnnulp are exchangeable events a concurrency npd is also reported lines .
here the two events are 1and 3or1and .
711detecting concurrency memory corruption vulnerabilities esec fse august tallinn estonia free p free p thread t1 thread t2thread t3 p ... p ... p ... free p free p thread t1 thread t2thread t3 p ...p ... p ... a b figure how a concurrency df occurs.
in algorithm we check whether a memory read is a pointer dereference in isderef ins .
it is based on the following heuristic a pointer dereference usually corresponds to two consecutive binary instructions insand its next instruction ins line where the operand register of the first memory read operations insis used as the base register of its next memory access instruction ins .
of course this heuristic might be imprecise and can be improved.
.
analyze and detect concurrency dfs a double free df vulnerability occurs when a memory location is freed twice .
df is also a kind of serious vulnerability and can be exploited to launch remote code execution attacks .
a df involves two events and can occur in multithreaded programs.
unlike uaf and npd a df involves the same type of two memory free events.
hence once two free events on the same memory location occur a df must occur.
in practice a concurrency df may be hidden by other pointer assignments in between two free events.
hence the two frees via the same pointer actually free two different memory blocks.
the assignment can be either from one of the two threads or a third thread.
we show an example in figure a .
in the example two threads t1andt2execute two frees on the same pointer p. and in between two free p calls a write to pexists from either thread t1 case or thread t2 case or thread t3 case .
as a result although the pointer pis freed twice no df occurs.
however given a different thread schedule as shown in figure b if the assignment to pointer poccurs after both free p as case or before both free p as cases and a concurrency df occurs.
given the concurrency df in figure a race detector may report a race between the read to pinfree p and the write to p. this however is insufficient to infer a df.
similarly when it involves lock protection no race detector can detect the df.
our algorithm.
algorithm assumes if there is any potential concurrency df there must exist three events two free events on the same pointer by two different threads and one assignment to the same pointer as shown in figure .
algorithm maintains two data structures a map ptsthat maps a memory mto a set of pointers to memory block m and a map frsthat maps a pointer pto a set of free events on p. the structure ptsis maintained by fully tracking any assignment from a memory block mto a pointer p inonpointerassign p m .
that is when an address of a memory mis assigned to a pointer p all mapped items to pfrom other memory m are removed line and pis remapped from memory m line .algorithm detect concurrency df pts a map from a memory mto a set of pointers to m. frs a map from a pointer to an event that frees p. function onpointerassign p m for m such that pts m do pts m pts m p end for pts m pts m p end function function onfree m t m the1staddr ofamemory block.
letefbe this event.
foreach p pts m do letewpbe the event associating pointer ptom.
if efp frs p then ifefp ewpthen report a df.
case a else if ewp efthen report a df.
case b end if end if frs p frs p ef end for end function the core part of algorithm is how it checks freeevents and detects concurrency dfs as shown in function onfree m t .
given a free event free p that actually frees memory mby thread t denoted as event ef it tries to find a previous assignment event to pointer pfrom a memory m denoted as event ewp such that there is also a previous free event on the same pointer p denoted as efp lines .
then a concurrency df is reported in one of two cases case a the two events efpandewpare exchangeable events line i.e.
the case where thread t2has an assignment to pin figure .
case b the two events ewpandefare exchangeable events line i.e.
the cases where thread t1ort3has an assignment to pin figure .
.
schedule executions hbr is not guaranteed to be precise .
similarly our relaxed exchangeable events are also not precise.
to overcome this imprecision we adopt scheduling techniques with aim to trigger occurrences of all reported concurrency vulnerabilities.
given a set of ordered events from a trace we try to produce a set of new orders our target among these events.
the basic idea is to suspend the first event in each order to enforce the targeted order to table scheduling rules cancelled events are not required to appear .
detected orders targeted orders uaf euse ef ree ef ree euse npd ederef ewnull ewnull ederef ewnull ereassi n ederef ereassi n ewnull ederef ewnull ederef ereassi n df ef ree ereassi n ef ree ef ree ef ree ereassi n ereassi n ef ree ef ree 712esec fse august tallinn estonia yan cai biyun zhu ruijie meng hao yun liang he purui su and bin liang occur.
table shows both the events and the orders of each reported concurrency vulnerability by convul as well as the targeted orders among these events.
there are totally six rules.
in the last four rules if the targeted order of the first two events is satisfied then the third event may not appear i.e.
become meaningless as the vulnerability already occurs .
convul adopts the existing scheduling work to validate each reported vulnerability by including support of memory access events.
as novelty of convul is at its predictive detection of concurrency vulnerabilities we omit the detailed scheduling algorithm.
readers may refer to the work .
discussion convul is a two phase approach to detect three kinds of concurrency vulnerabilities in real world programs.
it does not adopt heavy strategies e.g.
via maximal casual models to find all vulnerabilities but relies on a practical prediction and a practical validation.
hence it can miss vulnerabilities.
however its validation guarantees that no false positive is reported.
in future we will extend convul to detect more concurrency vulnerabilities.
experiments .
experiment setup .
.
implementation.
we implemented convul on top of pin for c c programs with pthread.
convul instruments both synchronizations and memory accesses during program loading time to produce various events.
during runtime these events are passed to the algorithms of convul .
for comparison purpose we also selected three representative race detectors fasttrack ft helgrind hel and thread sanitizer tsan as well as a recent work ufo .ft andhel are two well known happens before based race detector and such detectors usually report fewer false positives but miss real races.
tsan is a practical hybrid race detector based on both happens before relation and lockset discipline which is claimed to report the largest number of races without reporting false positives and benign races .
both hel andtsan are available online for ft we adopted the implementation from a recent work .ufo targets on detecting concurrency uaf and is available online.
exceptionull detects npds based on the similar idea asufo unfortunately it is for java and is not available.
besides above tools we adapted ufo on known vulnerabilities to detect concurrency npds denoted as ufo npd see the next subsection .
we did not compare convul with detectors like address sanitizer as which only detects occurred vulnerabilities but cannot predict ones from correct executions.
.
.
benchmarks.
we aim to evaluate the ability of convul at detecting not only known but also zero day concurrency vulnerabilities including on real world large scale programs.
we then searched the nvd vulnerability database i.e.
at the site https nvd.nist.gov .
we restricted all cves under category of race published in the past ten years from to .
this results in records.
we then manually identified those caused by uaf npd and df which resulted in cves.
next we excluded those on non linux platform i.e.
on android apple java windowskernel and qualcomm and those with no clear descriptions or without source and inputs like poc .
finally there are cves left.
we extracted the code involving vulnerabilities.
we also replaced non pthread synchronizations with pthread ones.
table shows the details of these cves including their cve ids category program and detection results by all detectors.
we further selected mysql database server of the latest version .
.
at the time of evaluation .
mysql is a widely used large scale programs consisting of2 927sloc.
it mainly adopts pthread model with several customized synchronizations and contains 933test cases.
note as ufo only detects uafs we revised the known npd vulnerabilities by changing the null pointer assignment as frees i.e.
change p null to free p .
thus ufo asufo npd are expected to detect the npds as uafs.
however on mysql we are unable to do such changes for its whole code and it also crashed after we applied above changes to all npds detected by convul .
hence ufo npdwas only evaluated on the known npds.
.
.
setting.
the default distance of convul is i.e.
to check relaxed exchangeable events .
we also configured it with other distances and present the results in section .
.
for other tools we adopted their default configurations.
our experiment was conducted on a thinkpad workstation w541 with an i7 4710mq processor installed with ubuntu .
gcc .
llvm .
.
we run all tools for times and collected their results but times for collecting time and memory overhead .
.
effectiveness on known vulnerabilities table shows the results of the all detectors on concurrency vulnerabilities.
note that the three detectors only detect races hence we count a reported race as a vulnerability if it reflects a concurrency vulnerability otherwise we further check whether they report any race on the variable of a concurrency vulnerability if so we append a star marker in the corresponding cell in table .ufo only detects uafs and ufo npdonly detects npds we put a to indicate the case where they are not applicable.
from the table convul successfully detected out of vulnerabilities.
however others only detected to vulnerabilities.
in other words all three race detectors missed at least known vulnerabilities.
these results are consistent with our claim that not all concurrency vulnerabilities can be detected by race detectors.
even simply counting any race on variables involved in vulnerabilities indicated by three detectors still missed to about vulnerabilities.
ufo only detected out of known uafs and ufo npdonly detected out of npds.
obviously on unknown cves convul was significantly effective than others.
asconvul only missed one vulnerability which was also missed by all other detectors we investigated it and outline its code below initialization 2head mm null 3head next node thread texit 6acq mmlist 7head next head 8rel mmlist thread tworker 10tmp ... 11if head next !
head acq mmlist tmp head next rel mmlist 16tmp mm ... dereference 713detecting concurrency memory corruption vulnerabilities esec fse august tallinn estonia table descriptive statistics and detection results.
cve id category programdetection results convul ft hel tsan ufo ufo npd cve npd linux .
.
rc6 cve npd linux .
.
cve npd linux .
.
cve npd linux .
.
cve uaf firefox .
cve uaf firefox .
cve npd linux .
.
cve df linux .
.
cve uaf df linux .
.
cve uaf linux .
.
total table six zero day concurrency vulnerabilities detected by convul on mysql and a comparison with other detectors.
bug id category statusdetected by others?
ft hel tsan ufo mysql uaf confirmed mysql npd submitted mysql npd submitted mysql npd confirmed mysql npd confirmed mysql npd confirmed total from the code we see that a npd will occur if thread texit lines and executes in between line and line of thread tworker .
this npd is caused by a null value write to pointer mmat line and a dereference on the same pointer mmat line .
in a normal execution thread tworker executes first followed by thread texit.
this case falls out of our models shown in figure and convul failed to detect it.
for three race detectors as a lock mmlist is used to order two writes to head next no race was reported by them.
.
effectiveness on unknown vulnerabilities .
.
summary of results.
table shows the number of concurrency vulnerabilities or races reported on mysql by all tools.
convul predicted concurrency vulnerabilities and of them was triggered.
ftreported up to races.
both hel andtsan reported almost the same number of races and respectively.
surprisingly ufo detected no uaf.
.
.
result analysis.
from table we see that the three race detectors reported many races from hundreds to thousands .
it is unknown whether all these reported races are real ones and how many of them reveal concurrency vulnerabilities.
however convul reported concurrency vulnerabilities and of them were zero day vulnerabilities.
we have reported these vulnerabilities to mysql developers.
and of them have been confirmed as real vulnerabilities the remaining are waiting for confirmation.
we first discuss the zero day vulnerabilities and then discuss the three not triggered ones in the next subsection .
table of concurrency vul.
or races reported on mysql.
convul ft hel tsan ufo vul.
or races due to limited debug information by pin this result contains duplicated races.table shows all zero day concurrency vulnerabilities consisting of uaf and npds.
the table includes bug ids allocated by mysql bugzilla after we submitted our result vulnerability category and vulnerability status.
in the last major column we indicate whether ft hel tsan and ufo detected the vulnerabilities or not.
from the last major column we see that ftandufo detected none of the vulnerabilities helandtsan both detected only one of them.
this further confirms that race detectors are ineffective in detecting concurrency vulnerabilities and ufo can miss uafs.
compared to them our tool convul is more effective.
.
.
study on false positives from prediction.
for the three false positives we have investigated them and found that all were caused by the similar reason as illustrated below.
thread t1 may be a lock here 3for each node in list node ... thread t2 sometimes a lock here 8for each node in list if node ... remove list node free node in the simplified code there is a list structure.
in testing executions thread t1executes first to iterate each node in list.
hence the pointer node is firstly dereferenced line and then freed by thread t2 line .
and convul predicted this as a concurrency vulnerability.
however when thread t2executes first it will remove the node from the list and then frees the memory pointed by node.
next when thread t1executes it will never read the node freed by thread t2again.
as a result the dereference is actually missing as the node is no longer in the list .
we further verified that for three variables in three false positives ftreported three races while both hel andtsan reported two races on two variables.
based on our above analysis all these reports are false positives.
actually such false positives cannot be easily excluded without scheduling runs even for pure hbr based race detectors.
and this is still a hot topic .
.
convul with different distances besides relaxed exchangeable events we also set other different distances from to to convul and applied it to both known vulnerabilities and mysql.
on the known vulnerabilities convul did not detect them with d .
this is understandable as each of them only contains 714esec fse august tallinn estonia yan cai biyun zhu ruijie meng hao yun liang he purui su and bin liang code producing vulnerabilities.
on mysql with d one npd was detected with d two npds were detected.
they are a subset of the vulnerabilities listed in table .
in other cases i.e.
d no vulnerability was detected.
.
ineffectiveness analysis of other detectors the three widely used race detectors were significantly ineffective in our experiment.
after detailed investigation we found that the reasons were still those which we have discussed in sections and .
ufo adopted a sub optimal model and hence can generates simple constraints that are accepted by high performance constraint solvers like z3 which prevents it to detect all uafs see the last paragraph of section .
.
it only detected uaf out of known and unknown uafs.
.
performance evaluation table time overhead an average of runs .
pin convul ft hel ufo tsan cve avg.
.8x .9x .8x .8x .4x .0x mysql .4x .1x .87x .7x .0x .1x table memory overhead an average of runs .
pin convul ft hel ufo tsan cve avg.
.0x .8x .6x .2x .9x .7x mysql .2x .3x .6x .3x .4x .1x pin and valgrind are two heavy dynamic binary instrumentation framework.
convul andftare built on pin and hel is built on valgrind.
tsan is integrated into a program during compilation time.
ufo collects traces at runtime and offline detects uafs.
to compare their performance we collected both time overhead and memory overhead of all.
on cve programs all detectors incurred the similar time and memory overhead we only show the average data on them.
the data is shown in table and table including the overhead of pin with no tool for reference.
from two tables we see that tsan incurred the least time overhead and memory overhead which is reasonable due to its integration implementation.
and we will not discuss it.
other four detectors incurred heavy time and memory overhead on cve programs where the time overhead of ufo and the memory overhead of both hel andufo are extremely heavy i.e.
from 430x to 520x .
on mysql both convul andhel incurred almost the same time and memory overhead however ufo incurred the least time overhead but the largest memory overhead.
overall compared to both ft hel and ufo the performance ofconvul is acceptable to us.
related works detection of concurrency vulnerabilities has begun to gain more focus recently.
the work first shows important features of concurrency attacks and reveals that many of concurrency bugs can lead to severe attacks such as privilege escalation malicious code execution and security check bypassing.
2ad focuses on the concurrent attacks on databases but cannot handle other programsefficiently.
owl detects concurrency attacks based on race detectors and we have discussed it in this paper.
it automatically identifies the real concurrency bugs and eliminate false positive produced by existing tools.
and then based on inter procedural analysis and attack input fuzzer owl can detect the attack sites derived from shared memory corrupted by the concurrency bugs.
compared with owl convul does not need to identify the concurrency bugs but directly focuses on concurrency vulnerabilities.
among concurrency bugs data race is the mostly closed one to concurrency vulnerabilities as explained in this paper.
there have been many works to detect them .
razzer focuses on fuzzing harmful races in linux kernel.
one hot topic on race detection is to improve the detection coverage in single executions but not to explore all possible executions like model checking .
other topics are to focus on a small portion of interleaving space and randomized scheduling with guarantees .
these research directions can also benefit our convul to detect additional concurrency vulnerabilities.
lastly fuzzing techniques become one of most effective methods to detect sequential vulnerabilities by simply mutating inputs including afl and peach which have found a huge number of notable security vulnerabilities in thousands of large scale programs on various systems.
symbolic execution and taint propagation can be further used to improve code coverage and bypass some special input validation checks in fuzzing .
stress testing can be an alternative one to increase thread parallelism .
convul can be integrated into these tools.
conclusion this paper studies how the order of two events can be reversed in different executions.
it further proposes convul implementing three algorithms to detect concurrency vulnerabilities.
the experiment results on known concurrency vulnerabilities and on a database server demonstrated that convul is significantly more effective than existing works on detecting both known vulnerabilities and day vulnerabilities.