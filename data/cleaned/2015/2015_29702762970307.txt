radius aware probabilistic testing of deadlocks with guarantees yan cai state key lab oratory of computer science institute of softwar e chinese academy of sciences beijing china ycai.mail gmail.com zijiang yang department of computer science western michigan university kalamazoo mi usa zijiang.yang wmich.ed u abstract concurrency bugs only occur under certain interleaving .
existing randomized techniques are usually ineffective.
pct innovatively generates scheduling before executing a program based on priorities and priority change points.
hence it provides a probabilistic guara ntee to trigger concurrency bugs.
pct randomly selects priority change points among all events which might be effective for non deadlock concurrency bugs .
however deadlock s usually involve two or more threads and locks and require more ordering constrai nts to be triggered.
we interestingly observe that every two events of a deadlock usually occur within a short range.
we generally formulate this range as the bug radius to denote th e max distance of every two events of a concurrency bug .
based on the bug radius we propose rpro radius aware probabilistic testing for triggering deadlocks .
unlike pct rpro select s priority change points within the radius of the targeted deadlocks but not among all events .
hence it guarantee s larger probabilities to trigger deadlock s. we have implemented rpro and pct and evaluated them on a set of real world benchmarks containing unique deadlocks.
the experimental results show that rpro triggered all deadlocks with higher probabilit ies i.e.
.7x times larger on average than that by pct .
we also evaluated rpro with radius varying from to or .
the result shows that the radius of a deadlock is much small er i.e.
from to in our experiment than the number of all events.
this further confirms our observation and makes rpro meaningful in practice.
ccs concepts software and its engineering deadlocks software and its engineering software testing and debugging .
keywords deadlock random testing bug radius multithreaded prog ram .
introduction concurrency bugs widely exist in multithreaded programs including data races atomicity violations and deadlocks .
their occurrences usually involve multiple memory accesses or synchronizations known as events in this paper from different threads.
among t hese concurrency bugs deadlocks are a kind of high level concurrency bugs caused by incorrect synchronization orders whereas others e.g.
atomicity violations are usually caused by wrong memory access orders .
many techniques differentiate concurrency b ugs as deadlock bugs and non deadlock bugs as they require different techniques to detect.
for example concbugassist only focuses on non deadlock bugs while sherlock only focuses on deadlocks.
a deadlock occurs when a set of threads are holding some locks and are waiting for other locks held by the threads in the same set .
there are both static and dynamic approaches to detect deadlocks.
however static approaches may report false positives as it is difficult to infer whether two events may occur concurrently .
dynamic ones usually predict a set of potential deadlocks from the execution traces by identifying cycles or cyclic lock dependencies.
these potential deadlocks also include many false positives and henc e the real deadlocks should be further isolated .
randomized testing does not rely on predicted information from concrete execution s to infer potential deadlocks.
traditional randomized testing approaches try to introduce additional randomness e.g.
random sleep on top of os scheduling.
other kinds of testing e.g.
heuristic directed ones and systematic scheduling may be effective on detecting certain kinds of concurrency bugs .
but they do not provide any guarantee .
pct then introduces mathematical randomness to provide a guarantee to trigger concurrency bugs of given bug depths .
the bug depth of a concurrency is the minimal number of ordering constraints to trigger this bug see section .
for details .
the innovation of pct is to generate a scheduling prior to executing a program .
the scheduling consists of a set of initial thread priorities and a set of priority change points.
a priority change point is an event such that if this event is executed the priority of the involved thread is changed accordingly.
as the scheduling of pct is generated purely based on the mathematical randomness it probabilistically guarantees to detect a concurrency bug with bug depth of d at a probability of n kd where n and k are the approximated number of threads and the approximated numbe r of events respectively of the given program.
however pct assumes that the events of a concurrency bug are uniformly distributed among all events.
therefore it randomly selects thread priority change points a mong all events.
hence if the bug depth increases by one the guarante ed probability decreases to be k times.
for real world programs the value of k could be very large which makes pct ineffective .
we interestingly found that all events involved in a concurrency bug usually fall into a shor t range which is also suggested by corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
existing works e.g.
short depth and small scope hypothesis .
the number of events in the range is much smaller compared to the total number of events of a program.
besides existing works also show th at deadlocks usually involve more ordering constraints than other concurrency bugs .
for example a data race only involves two events i.e.
memory accesses and an atomicity violation only involves three however a deadlock must involve at least four direct events and other indirect events .
therefore random selection of events among all events could be ineffective for pct to trigger a concurrency bug especially for deadlocks.
in this paper we propose a new approach rpro radius aware probabilistic testing to generate execution .
given a bug depth rpro selects the first priority change point randomly among all .
let s denote th is event as k1 in term of the order of events to be executed .
however for the remaining priorit y change points rpro selects them out of a certain range of event k1.
the range is defined to be excluding the k1 itself where the number r is referred as the radius of the concurrency bug.
in this way all priority change points are within the range .
hence rpro guarantees to trigger a concurrency bug with a probability of n k rd which is k r d times of the guarantee by pct if all events of the bug fall within the range where k and n are the number of events and the number of threads of the given program respectively.
in theory the radius of a bug could be as large as the number of the total events.
even a concurrency bug has very large radius the same bug can be manifested with a much smaller radius.
that is a concurrency bug that must ha ve very large distance e.g.
is rare.
after an event is selected assuming the same concurrency bug can be triggered by selecting another event at either distance r1 or r2 from all even ts where r1 r2 k and k is the number of total events.
by randomly selecting an event the probability to trigger the event is k k k corresponding to select ing either r1 or r2 .
however i f we restrict the radius to be r where r1 r r2 the probability becomes r corresponding to only select r1 which can be significantly larger than k. in practice this radius is usually much smaller than the number of total events e.g.
from to vs or more events in our experimen ts .
we have implemented rpro and evaluated it on a set of real world benchmarks .
we run both pct and rpro on each benchmark for times .
in the experiment we configure d two radiuses and to rpro .
the experiment al result show s that with either radius rpro triggered each deadlock with a much higher probability.
that is on average rpro achieved 7x probabilities of that by pct .
particularly on two large scale benchmarks i.e.
two versions of mysql pct failed to trigger any deadlock whereas rpro triggered the two deadlocks with probabilities of .
and .
with radius and .
and .
with radius .
we also configured rpro with radius from to or .
the experimental results show rpro achieved the highest probability with the radius at most even the events of some benchmarks could be .
this show s that in practice a deadlock usually has a smaller radius e.g.
vs .
the main contributions of this paper are as follows it proposes a new approach rpro toward randomized testing of deadlocks with probabilistic guarantees .
compared to pct rpro has a larger probabilistic guarantee to trigger a deadlock with depth of three or more .
we have implemented rpro as a prototype tool to trigger deadlocks .
the experiment results demonstrate the effectiveness of rpro compared to pct .
it also shows t hat the radius of a concurrency bug is usually much smaller compared to the number of events in a program.
the rest of this paper section presents the preliminaries and the motivation of our work.
section presents our rpro approach .
section presents an experiment to evaluate rpro .
section discusses the related works followed by the conclusion in section .
.
preliminaries and motivations .
events and deadlocks an execution of a multithreaded program involves the following kinds of events acq t m a thread t acquires a lock m acq m for short.
rel t m a thread t releases a lock m rel m for short.
others e.g.
memory read and write an execution trace or a trace is a sequence of events.
a deadlock occurs if a set of threads wait mutually for a set of locks that are held by other thread s in the same set .
for example figure shows an example program with a deadlock d1.
the program has two threads t1 and t2 that totally execute eight events i.e.
lock acquisitions and releases on locks m and n .
deadlock d1 occurs if thread t1 tries to acquire lock n after it acquired lock m but thread t2 tries to acquire lock m after it acquired lock n. the two threads then mutually wait for each other to release a lock.
.
the pct algorithm we firstly explain the concept bug depth of a concurrency bug.
a concurrency bug occurs if the involved events occurring under a certain interleaving.
in other words there is one or more ordering constraints amo ng these events.
if a concurrency bug could occur in a way such that the number of required constraints is minimal we say the bug depth of this bug is the number of these constraints.
for example deadlock d1 in figure occurs only if both the event acq m at site s01 occurs before the events acq m at site s06 and the event acq n at site s05 occurs before the event acq n at site s02 as indicated by two arrows.
the two conditions are known as two ordering constraints of deadlock d1.
if only one of two ordering constraints is satisfied deadlock d1 cannot occur.
therefore the bug depth of deadlock d1 is .
pct firstly gener ates a scheduling prior to executing a program.
during runtime it enforces an execution to follow its generated schedul ing.
hence pct can mathematically explore the interleaving to trigger a concurrency bug of given bug depths .
therefore it can guarante e a probability to trigger a concurrency bug.
algorithm outlines the core idea of pct .
pct accepts a program p and the following parameters over p a parameter n indicating the approximated number of threads a parameter k indicatthread t1 thread t2 s01acq m s02 acq n s03 rel n s04rel m s05acq n s06 acq m s07 rel m s08rel n figure .
an illustration of pct on a simple deadlock d1.
ing the approximated number of events and the parameter d indicating the bug depth of the targeted concurrency bugs .
pct is based on priorities to schedule all threads.
in step pct randomly assigns n priorities d d ... d n to the n threads where a larger number indicates a larger priority.
the lowest d priorities ... d are reserved for runtime scheduling.
next step from all k events labeled from to k pct randomly selects d unique events k1 ... kd as the priority change points.
each event ki is associated with a priority value of i. totally the d prio rities are ... d .
finally step pct executes the given program and changes the priorities of all threads as follows pct only executes events from the thread with the largest priority and counts all executed events starting from .
if an event is counted as the number k and k is equal to ki out of k1 ... kd pct changes the priority of the current thread to be i. the priority chang e brings a chance for other threads to be executed.
pct repeat s the above procedure until the execution terminate s. in practice the scheduling generated by pct is not always feasible.
for example pct may first schedule a thread that is not forked by the main thread or is disabled by operating system.
in this case pct schedules a thread with the largest priority out of all enabled threads.
illustration of pct .
we show an illustration of pct on our example in figure .
the program contains threads and events i.e.
n and k .
i ts deadlock d1 has a bug depth d as indicated by two solid arrows.
therefore pct randomly assigns two priorities and i.e.
d ... d n to the two threads .
it then randomly selects i.e.
d priority change point and this priority change point is reversed for runtime prio rity change .
suppose that the randomly assigned priorities of threads t1 and t2 are and indicated by the symbols and in figure respectively and the change points is i.e.
right after executing the 1st event of thread t1 indicated by the symbol .
then pct generates a scheduling for the example program toward triggering deadlock d1 as indicated by the dotted red arrow in figure .
please ignore whether the generated scheduling is feasible or not as discussed in the last paragraph .
during execution pct follows its schedule to execute the program.
it firstly schedul es thread t1 i.e.
the thread with the largest priority to execute.
after executing the event acq m at site s01 pct counts the executed events where t he count is that is equal to the sel ected change point .
hence pct changes the priority of thread t1 to be the 1st reserved priority that is .
and the priorities of threads t1 and t2 are and respectively.
pct then schedules thread t2 that has a larger priority to execute its events and counts the executed events.
as there is only one priority change point which has been consumed by thread t1 no priority of any thread would be changed.
finally after thread t2 executes event acq n at site s05 and further executes the event at site s06 i.e.
acq m it fails as the lock m is being held by thread t1.
in this case thread t2 is disabled.
pct has to schedule thread t1 as it has the large r priority that can be scheduled.
when thread t1 tries to e xecute the event acq n at site s02 it fails as the lock n is being held by thread t2 and a deadlock occurs.
that is in order to trigger deadlock d1 in the example pct should select the first event of the thread with the largest prio rity that are randomly assigned .
the probability of this selection is corresponding to select the first event with the probability of of the thread with a largest priority with the probability of .
intuitively from the above illustration pct targets to select a set of priority change points that could form a minimal set of ordering constraints to trigger a concurrency bug.
formally g iven a program p that contains at n threads and executes at k events pct is able to find a concurrency bug of depth d with a probability at least n kd .
.
motivations pct can avoid exploring similar interleaving mathematically resulting in relatively effective scheduling with repeated ly executing the same program .
and it also has a probabil istic guarantee to find concurrency bugs of given bug depths.
however pct utilizes the randomized generation of priority change points.
the randomized generation may become ineffective in practice if the bug depth is or even larger.
for example to det ect data races or atomicity violations the required bug depths are usually or respectively .
if the bug depth is or the guaranteed probability is n or n k respectively.
however for real world deadlocks such bug depths could be or larger.
in this case pct might be come ineffective as its guaranteed probability decreases by a factor of k if the bug depth increase s by one.
for example if the bug depth is the guaranteed probability becomes n k2 .
for real world programs the number of events i.e.
k is usually large and hence the guaranteed probability by pct becomes much smaller.
we illustrate this by another real world example shown in figure .
the program in figure a is adapted from a real world deadlock program i.e.
jdbc connector .
with bugid .
it contains two threads t1 and t2 that may form a deadlock d2 on two locks p and n at sites s06 s08 of thread t1 and sites s15 and s16 of thread t2 as shown in bold .
figure b and c shows two different scheduling to trigger deadlock d2.
unlike deadlock d1 in figure deadlock d2 requires more ordering constraints i.e.
the two dotted arrows from site s14 to site s03 and from site s05 to site s15 to be triggered besides the two ordering constraints between the events directly involved in deadlock d2 i.e.
the two solid arrows from site s06 to site s16 and from site s15 to site s08 .
that is if thread t1 is firstly scheduled to execute as shown in figure b after executing the event rel k at site s02 thread t2 should be scheduled to execute the two events acq s and rel s at sites s13 algorithm pct p k n d input p a given program.
input n an approximation of the total number of threads.
input k an approximation of the total number of events.
input d a bug depth of the targeted concurrency bug.
.
assign the n priority values d d ... d n randomly to the n threads.
a larger number indicates a lager priority.
.
pick d unique random priority change points k1 ... kd in the range .
these d priority change points are ordered and each ki has an associated priority value of i. .
schedule the k threads by their priorities assigned in step and count the events executed.
after executing an event .
if the count becomes ki change the priority of the current thread to be i. .
if a concurrency bug occurs report the bug.
and s14.
otherwise if thread t1 is allowed to execute events from site s03 to site s07 i.e.
all events before site s08 thread t2 cannot reach site s15 to execute event acq n as lock s is being held by thread t1.
figure c also shows the second case if thread t2 is firstly scheduled to execute where thread t1 should be scheduled to execute right before thread t2 executes event acq s at site s14.
for pct if we follow deadlock d1 to set up a bug depth of i.e.
by only considering the two solid arrows in figure a it never triggers deadlock d2 theoretically as the minimal number of ordering constraints to trigger deadlock d2 is corresponding to the scheduling shown in figure b .
even if we configure pct to work with the bug depth of it has to assign thread t2 to have a larger priority initially.
note that due to symmetric property pct could trigger deadlock d1 with any one of two initial assignments of two priorities to two threads under the bug depth of .
that is besides the priority assignment s and change point selection shown in figure pct can trigger deadlock d1 by assigning priorities and to threads t2 and t1 respectively and select ing a priority change point at site s05 as shown in figure .
the generated scheduling is denoted by a dotted red arrow.
however not all concurrency bugs have a symmetric property to be triggered such as data races.
besides pct treats all events uniformly.
however in practice a concurrency bug usually has a short depth to be exposed .
in other words if one priority change point is selected the remaining priority change points should not be randomly selected in practice .
in section we introduce how our algorithm selec ts more effective priority change points to trigger concurrency bugs as well as the rationales .
lastly the generated scheduling of pct is meaningful in theory .
during real execution pct has to resolve various thrashing.
for exampl e figure shows that a scheduling generated by pct indicated by the dotted red arrow where the priority change point marked as is right after evt2.
the actual scheduling denoted by the solid green arrow differentiates the generate scheduling as there is a pair of wait m and notify m .
this pair of events requires that thread t1 has to wait after executing evt1 until thread t2 sends a notification to thread t1.
such kinds of synchronizations are very common .
but it is difficult to be considered by pct which may further reduce the probability of pct to trigger concurrency bug s. .
rpro algorithm this section present s our algorithm rpro .
we firstly present the design rationales of rpro followed by the rpro algorithm and its probabilistic guarantee .
.
rationales of rpro pct is designed not to consider any program information except the basic progr am statistics i.e.
the approximations on the number of threads and the number of events .
it treats each thread and each event uniformly.
therefore for any given bug depth d it randomly selects d priority change points section .
discusses why pct selects d but not d prior ity change points .
this selection is fair to all events.
we illustrate this selection strategy in figure a .
in figure the arrows under different threads indicate the events of each corre sponding thread .
the solid black circle s indicate the events sele cted as priority cha nge points and the red dotted arrows indicate the communications among all threads .
the dotted a rea depicts the range among which pct or our rpro selects priority change points.
by following pct the selected priority change points are uniformly distributed among all events as shown in figure a .
thread t1 thread t2 evt1 wait m evt2 evt3evt4 evt5 notify m evt6 generated scheduling by pct an actual but complex scheduling figure .
comparison between a generated scheduling by pct and an actual scheduling .
thread t1 thread t2 s01acq m s02 acq n s03 rel n s04rel m s05acq n s06 acq m s07 rel m s08rel n figure .
the second way for pct to trigger deadlock d1.
thread t1 thread t2 thread t1 thread t2 s01acq k s01acq k s02rel k s02rel k s03acq s s03acq s s04acq n s13acq s s04acq n s13acq s s05rel n s14rel s s05rel n s14rel s s06acq p s15acq n s06acq p s15acq n s07 acq m s16 acq p s07 acq m s16 acq p s08 acq n s17 rel p s08 acq n s17 rel p s09 rel n s18rel n s09 rel n s18rel n s10 rel m s10 rel m s11rel p s11rel p s12rel s s12rel s b a scheduling by pct with a bug depth of .
c a scheduling by pct with a bug depth of .
thread t1 thread t2 s01acq k s02rel k s03acq s s04acq n s13acq s s05rel n s14rel s s06acq p s15acq n s07 acq m s16 acq p s08 acq n s17 rel p s09 rel n s18rel n s10 rel m s11rel p s12rel s a the four ordering constraints to trigger deadlock d2.
figure .
an example program p and with a deadlock d2 adapted from the deadlock of jdbc connector .
with bugid .
however our observat ion is that a multithreaded program is not arbitrarily designed and developed.
for example there are many synchronization primitives to coordinate different threads of a program such as wait notify barrier operations as well as various customized conditionals .
that is a concurr ency bug are unlikely to involve two or more events that have a n execution distance in term of the number of events as long as the total number of events in the program .
contrastly for a concurrency bug the execution distance of its events may be centr alized such that if one of its event occurs the other events of the same bug may also occur after or before several other events .
figure b illustrates this kind of scenarios if an event occurs all other events of the same concurrency bug fall into the r events of the first event.
in this paper we define the radius of a concurrency bug to be the largest distance of every two events involved in the bug during execution where the distance of two events is x and x is the number of events executed or to be executed immediately i.e.
the next event of a thread between the two events .
from th is definition the radius of a concurrency bug is interleaving sensitive.
in figure b by following the scheduling indicated by green arrows the radius of deadlock d2 is as the trace is ... s15 s03 s04 s05 s06 s07 s08 s16 ... .
note that although the event acq n at site s15 is executed as the second last executed event of deadlock d2 it is the next event to be executed after the execution of rel s at site s14.
therefore the event acq n at site s15 underlined in the trace is the first event to trigger deadl ock d2 in the execution in figure b .
for the scheduling in figure c the radius of deadlock d2 is where the corre sponding trace is ... s15 s01 s02 s03 s04 s05 s06 s07 s08 s16 ... .
our observation is that during an execution threads are actually synchronized to execute their events with similar pace.
let s consider the example in figure again.
suppose that the two events evt2 and evt5 form a concurrency bug .
this kind of bugs widely exist in real world programs e.g.
shared conditionals to control whether the next wait m or notify m should be executed .
then the two events are actually very close one is right after the wait m event and the other is right before the notify m event and the two events wait m and notify m are expected to execute almost at the same time as the execution of wait m has to be suspended until the notify m is executed .
now let s re consider t he real world deadlock d2 in figure again.
both scheduling s in figure b and c can successfully trigger deadlock d2.
when the deadlock occurs the distance of the involved events are or .
however t he program containing this bug actually involves more th an additional events s ee the experiment in section not related to this bug .
compared to the total number of events the radius of or is much small er.
therefore if the priority change points of a scheduling could be selected within the radius of a concurrency bug the probability to trigger this bug could be significantly improved.
let s consider the scheduling in figure c .
there are two priority change points as indicated by and .
the probability for pct to select the two points is actually k k k2 as pct selects them independently where k is the number of total events.
however if considering the radius denoted as r of deadlock d2 the probability would be k r k r as once the first priority change point is selected to be one of events of deadlock d2 corresponding to a probability of k the remaining one is selected within the r events from the first one corresponding to a probability of r .
therefore the probability to select the right priority change points could be improved to be k r times of what pct guarantees .
for deadlock d2 as the radius r and there are actually more than events the above probability could be improved to be times larger .
.
rpro algorithm to improve the probability of pct we present a new approach based on our bug radius concept known as rpro namely radius aware probabilistic testing .
rpro algorithm is straightforward as shown in algorithm .
the difference between pct and rpro is highlighted i.e.
steps and in algorithm .
rpro takes a program p with the approximated number of threads and events i.e.
n and k as well as the bug depth d and the radius r of the targeted concurrency bug.
prior to executing the program p rpro selects a random priority change point k1 among all k events step like pct .
then it selects the remaining d priority change points k2 ... kd within the r events starting from k1 i.e.
the range step .
during runtime scheduling it adopts the same schedu ling strategy as that of pct to trigger the targeted bug.
algorithm rpro p k n d r input p the given program.
input n the approximation of the total number of threads.
input k the approximation of the total number of events.
input d the bug depth of the targeted concurrency bug.
input r the radius of the targeted concurrency bug.
.
assign the n priority values d d ... d n randomly to the n threads.
a larger number indicates a lager priority.
.
pick one unique random priority change point k1 in the range .
.
if d is larger than pick d unique random priority change points k2 ... kd in the range k1 r k1 k1 r .
together with k1 these d priority change points are ordered and each ki has an associated priority value of i. .
schedule the k threads by their priorities assigned in step and count the events executed.
after executing an event .
if the count become s ki change the priority of the current thread to be i. .
if a concurrency bug occurs report the bug.
threads t1 t2 ... tn a uniform distribution b centralized distributionexecution execution of events coordination among threads ranges of events to be selected by pct or rpro threads t1 t2 ... tn ... ... figure .
two distribution models of bug events .
.
guarantee and limitations of rpro in this subsection we present an analysis on the probabilistic guarantee of rpro on triggering concurrency bugs .
we firstly present lemma to show the formal guarantee of pct .
lemma .
given a concurrency bug of depth d from a program that produces at most n threads that totally execute at most k events pct guarantees to trigger this bug with a probability of n kd .
and this probability is n times of the probability by selecting d ordered events among all k events i.e.
kd .
proof .
see the proof of pct .
it is interesting that the guaranteed probability of pct is n kd but not kd.
from the pct algorithm i.e.
algorithm we know that pct only selects d but not d priori ty change points where d is als o the number of minimal ordering constraints to trigger the same bug.
actually the first ordering constraint is enforced by the initial priorities randomly assigned to all threads.
let s consider the example in figure again and suppose that a concurrency bug only requires ordering constraint from evt1 to evt6.
then pct only needs to assign a larger priority to thread t1 without selecting any priority change point i.e.
.
this probability is n k1 n where n is the number of threads of the program .
one may refer the detailed proof in to find more about the proof of lemma .
theorem .
given a concurrency bug of depth d d from a program that produces at most n threads that totally execute at most k events if the radius of this bug is less than or equal to r d r k rpro guarantees to trigger this bug with a probability of n k rd .
proof sketch .
we prove theorem based on pct algorithm and lemma .
like pct rpro selects the first priority change point randomly from all k events with a probability of k. however for the remaining d priority change points rpro selects them only within the r events of the first priority change point with a probabil ity of rd .
as the all events of the given bug are within the r events1 of any event from this bug the probability of rpro to exactly select all the priority changes is x times of the probability of pct where x is x k rd kd k r d .
by lemma pct guarantees to trigger the given bug with a probability of n kd which is n of that probability by select ing d ordered events out of k events .
therefore rpro guarantees to trigger the given bug with a probability of n kd k r d n k rd .
theorem is proved.
theorem show s that rpro is more effective than pct if the bug radius r is smaller than the total number of events k. of course pct can be viewed as a special case of rpro where the radius is the number of all events i.e.
r k .
another point that should be strictly if we randomly select one event out of a range with a radius r i.e.
by following the step of algorithm then the probability to select a certain event is r instead of r. mentioned is that with increasing depth value d the guaranteed probability by rpro decreases much slower than that by pct .
discussion on the bug radius of rpro .
pct relies on the approximated program execution information to generate scheduling but does not consider the practical features of concurrency bug s especially the deadlocks.
whereas rpro takes this into consideration.
it is based on the radius of a concurrency bug to generate scheduling.
however like the bug depth this radius is also unknown until a concurrency bug is detected.
therefore if rpro takes a smaller radius than the actual radius of the bug it may fail to select the right set of priority change points hence it may fail to trigger any concurrency bug .
and its guaranteed pro bability becomes zero .
if rpro takes a too large radius value tha n the actual radius of the targeted concurrency bug its guarantee d probability may also decrease.
for example in the worst case given that r k rpro would have the same guaranteed probab ility as that of pct.
figure shows such a comparison where x axis is the value of radius r and the y axis is the guaranteed probability.
we use rbug to denote the actual radius of a concurrency bug.
as pct is unware of bug radius i t always has the same probabilistic guarantee.
for rpro it guarantees either a probability of zero if the radius is less than rbug or a larger probability if the radius is from rbug to the number of events i.e.
k .
in practice even if the given radius is less than rbug rpro may still trigger occurrences of a concurrency bug.
this also applies to pct because the ir guaranteed probabilit ies are only the low bound s and has been verified in our experiment s see the observation in section .
.
.
in figure we also the practical probability of rpro .
.
optimization for deadlock triggering rpro is designed for triggering concurrency bugs with larger bug depth.
however in this paper we focus on deadlocks .
and a deadlock occur s only after the involved threads try to acquire some locks but these locks are already acquired by the same set of threads .
that is an acquisition may result in a deadlock occurrence but a release event cannot directly resu lt in a deadlock occurrence.
therefore rpro considers lock acquisition events but discards lock release events.
hence rpro only needs to select priority change point among the half of events of a program as a release ev ent is paired with an acquisition event .
.
limitations rpro considers the bug radius to select priority change points.
however it still suffers from several limitations.
firstly it might be difficult to find a proper radius value in practice although this value is usually much smaller compared to the total numb er of events.
secondly compared to pct rpro restricts its priority change points into a smaller range hence it may not be able to expose th ose bugs with a large radius although the probability for pct to find such a bug is small.
lastly like pct rpro also requires a larger number of executions to exhibit its effectiveness as bug radiusprobability n kd n k rd rbug rbug pct guaranteed probability rpro guaranteed probability rpro probability inpractice r k figure .
comparison of the probabilities of pct and rpro with d both of them have probabilistic guarantees.
from the last two points there is a tradeoff between the probability and the number of executions i.e.
cost to find a concurrency bug.
.
experiment .
benchmarks we collected a set of widely used real world benchmarks including one java program i.e.
jdbc connector .
and five c c program i.e.
hawknl sqlite and three versions of mysql database server .
there are totally test cases and unique deadlocks covering most of deadlocks cases .
all these benchmarks and their test cases have been used in previous work s multiple times and are available either online or from the previous works .
table shows the statistics of all benchmarks including benchmark names with version number s if available bug ids if available program size sloc the number s of threads of each benchmark prog and its threads in each unique deadlock dlk the number of deadlocks dlks as a deadlock may have two or more variants in each benchmark.
the next column shows the total number of events events produced in the execution.
the last column show s the descriptions on how each deadlock occurs .
.
implementation and experimental setup for java programs w e use d asm .
to identify all synchronized operations of each loaded class and wrap ped them to produce events.
following the mechanism in java we take each object as a lock instance.
the c c implementation was based on pin .
on linux.
w e use d the probe mode of pin because the analysis of deadlock is a high level problem and there is no need to monitor low level memory access in our case besides the probe mode provides almost native execution performance .
we used pin to instrument a c c binary program to produce events by wrapping the pthread library functions.
besides lock acquisition and release events we also modeled other synchronizati on events e.g.
wait notify barrier by following fasttrack .
we then implemented the pct and rpro algorithms to work on generated events.
we conducted the experiment on four thinkpad w540 workstation s. each workstation is configured with a .
ghz up to .4ghz i7 4710mq processor with eight cores and 250g ssd installed with ubuntu .
gcc .
and jdk .
.
we concurrently run each algorithm up to eight instances.
rpro requires a radius value.
we selected two values and as two radius es for rpro and refer them as rpro and rpro respectively.
we firstly run each benchmark for times under each algorithm to collect the probabilities of each algorithm to trigger the corresponding deadlocks from each benchmark.
and the probability is computed to be the ratio of the number of the runs triggering deadlock s out of all runs.
note that some benchmarks may contain one or more variants of the same deadlock and we treat ed these variants as the same deadlock.
to evaluate whether a s hort value of the radius is required to trigger deadlock s in practice we further configured rpro to run additional times under each of the radius es from to to calculate the corresponding probabilities except on mysql and mysql .
on these t wo benchmarks we run them with radiuses from to in order to show a clearer trend of the probability changes by rpro .
.
result analysis this section presents our analysis on the experimental result by comparing rpro rpro and pct on their probabilities to trigger each deadlock.
finally we analyze the effectiveness of rpro with different radius values i.e.
to or .
.
.
effectiveness comparisons table shows the probabilities of three algorithms on each benchmark.
the first column shows the benchmark name.
the second major column program parameter s lists the program information i.e.
t he number of events k the number of threads n and the bug depth d .
these three parameters are collected from executions and are used as the approximations of three.
the sub column guaranteed probabilities shows the guaranteed probabilities of three .
the third major column lists the c ollected probabilities of pct rpro and rpro as well as the ratio of probability increases of rpro and rpro to the probabilit ies of pct .
the probability increase is calculated by the following formula rpro x pct pct where x is or .
the last row also shows the average improvement s on the probabilities of rpro and rpro to trigger all deadlocks.
we also use the symbol and to indicate whether the probability increase d decreased and did not changed respectively in the two delta columns i.e.
.
from the program parameters shown in table and the program descrip tion shown in table these programs are representative as they include large scale ones.
for example mysql has more than lines of code and its executions in our experiment produce more than threa ds and more than events.
table .
statistics of benchmarks and deadlocks.
benchmark bug id sloc threads prog dlk dlks events deadlock descriptions jdbc .
.3k statement .executequery and conenction .preparestatement jdbc .
.3k preparedstatement .getwarnings and connection .close jdbc .
.3k connection .preparestatement and statement .close jdbc .
.3k preparedstatement .executequery and connection .close hawknl .6b3 n a .3k nlshutdown and nlclose sqlite .
.
.0k sqlite3unixentermutex and sqlite3unixleavemutex mysql .
.4a .6k alter on a temporary table and a non temporary table mysql .
.4a .6k insert and truncate on a same table using falcon engine mysql .
.
.7k puge binary log acquires locks in wrong order mysql .
.
.7k show innodb status deadlocks if lock thd data points to lock open from the second major column in table we observe that these real world deadlocks require three or more priority ch ange points to be triggered .
besides the events of these deadlocks are hidden within to events except on hawknl and sqlite .
as a result the guaranteed probabilities of all three approaches are small i.e.
at the level of to except on hawknl and sqlite .
therefore it is challenging to triggering these deadlocks in practice.
however we still observe that both rpro and rpro has larger guarantee probabilities except on sqlite where only events were produced which are less than the radius of rpro .
for example on jdbc the guaranteed probability of rpro is at the level of which is about larger than that of pct i.e.
at the level of .
with increasing number of events we could observe that the guarantee probabilities of rpro decrease much slower tha n that by pct .
for example on four versions of mysql the guarantee probabilities of rpro is about to larger than that by pct .
from the last major column in table we observe that all three techniques triggered all deadlocks with larger probabilities tha n what they guaranteed except for pct on mysql and mysql4.
this result is consistent with the previous results evaluating pct as a deadlock may occur in several ways .
however on the two deadlocks form mysql and mysql pct failed to trigger any deadlock in runs i.e.
producing a probability of zero highlighted in table whereas rpro and rpro both triggered two deadlocks in to runs out of runs.
with our strategy on selecting priority change points rpro achieved higher probabilities on triggering deadlocks.
table shows that both rpro and rpro achieved an increases on the probabilities from .
to more than except on mysql1 on which rpro achieved the same probability as pct .
on average the probability improvement of rpro was more than times .
this improvement is significant.
in summary from table we observe that the strategy of rpro is much more effective than that of pct over all benchmarks.
.
.
effectiveness of rpro with different radius es figure shows the probabilities of our rpro on each benchmark with different radiuses varying from to or .
in each sub figure of figure the x axis shows the or radiuses and the y axis shows the corresponding probability on triggering each deadlock.
on each subfigure we show the point i.e.
peek value where rpro achieved the largest probability in the form of r x p y indicating that the achieved largest probability was y when the radius was x. for comparison purpose we also show the probability of pct in each sub figure.
in table we further list the best radius rbest of rpro that produced the largest probability on each benchmark as well as the ratio of rbest to the number of events i.e.
rbest events except for hawknl and sqlite that produced two few events .
table also includes the number of events the numb er of threads the bug depth and the largest probability for each benchmark.
in table we sort all rows according to the column rbest.
from figure and table we have the following four observations observation .
when the radius varied from to or the p robabilit y of rpro on each benchmark firstly increase d. after the probability reached a certain value i.e.
the marked peek point of each sub figure it began to decrease.
and the increase speed before the peek value was usually faster than the decrease speed from the peek value.
for example on jdbc the probabilit y was around .
when the radius is from to however when the radius increased from to the probabilities jump ed from about .
to around .
.
when the radius increased from to the probability gradually decrease d from .
to around .
.
this is roughly consistent with our theoretical analysis on the guaranteed probability of rpro see figure .
table .
the best radiuses rbest of each benchmarks.
benchmark events threads bug depth rbest rbest events probability hawknl .
sqlite .
jdbc .
.
jdbc .
.
jdbc .
.
jdbc .
.
mysql .
.
mysql .
.
mysql .
.
mysql .
.
all rows are sorted on the data in this column.
table .
probability comparisons of pct and rpro where the two radiuses of rpro are and rpro and rpro respectively .
benchmark program parameters probabilities k events n threads d bug depth guaranteed probabilities pct rpro by rpro rpro by rpro pct rpro rpro jdbc .
.
.
.
.
.
.
.
jdbc .
.
.
.
.
.
.
.
jdbc .
.
.
.
.
.
.
.
jdbc .
.
.
.
.
.
.
.
hawknl .
.
.
.
.
.
.
.
sqlite .
.
.
.
.
.
.
.
mysql .
.
.
.
.
.
.
.
mysql .
.
.
.
.
.
.
.
mysql .
.
.
.
.
.
.
.
mysql .
.
.
.
.
.
.
.
avg.
.
.
note that in practice if pct or rpro fails to select a set of right priority change points it is still possible to trigger the deadlock due the randomness of program execution however the probability should be smaller than what they guarantee.
we have also shown the trend of th is practical probability changes in figure which is roughly consistent with the curve in figure .
besides when the radius increased to a larger value e.g.
more than the probabilities by rpro on some benchmarks were still larger than that of pct .
there are two reasons.
for some benchmarks e.g.
jdbc jdbc jdbc mysql mysql mysql3 and mysql the radius is still much smaller than the number of events on other benchmarks e.g.
hawknl and sqlite our optimization of rpro on deadlock triggering also played an important role.
observation .
our benchmarks include programs of different sizes and they also produced different number of events from less than to more than .
from figure and table one could observe that roughly a large scale program have a larger radius than a smaller one.
however one may also observe that a program containing more threads have a larger radius.
this also indicates the complex ity of deadlock triggering.
for example mysql has the largest number of threads the largest bug figure .
probabilities of rpro with different radiuses from to or .
the legend of subfigure a applies to all other subfigures.
p .0020r p .
.
.
.
.
.
.
150pct rpro p .0385r p .
.
.
.
.
.
.
p .0005r p .
.
.
.
.
.
.
150p .0680r p .
.
.
.
.
.
.
.
p .1755r p .
.
.
.
.
.
.
.
.
150p .4326r p .
.
.
.
.
.
.
.
p .0004r p .
.
.
.
.
.
.
300p .0088r p .
.
.
.
.
.
.
p .0000r p .
.
.
.
.
.
.
300p .0000r p .
.
.
.
.
.
.
.
.
a jdbc b jdbc c jdbc d jdbc e hawknl f sqlite g mysql h mysql i mysql j mysql depth and the second largest number of events.
it also required the largest radius i.e.
to trigger its deadlock.
besides on this benchmark the largest probability produced by rpro is the smallest one among all the largest probabilities o n other benchmarks.
actually pct also produced the smallest i.e.
.
probabilit y on this benchmark as well as on mysql .
we will further investigate the correlation between radius and program parameters including the program size and the number of threads.
observation .
the radius of rpro to effectively trigger each deadlock is usually much smaller compared with the number of events from the same program.
for example except on hawknl and sqlite that produced too few events the best radius rbest of each program is less than .
of the corresponding number of events as shown in the column rbest events in table .
therefore for deadlocks with larger bug depth s rpro is more effective than pct .
for example on mysql where the bug depth is pct never triggered any occurrence of the deadlock out of runs whereas rpro successfully triggered it in to runs as shown in table .
beside s rpro triggered occurrences of the deadlock when the radius is see figure i .
observation .
figure also shows that on all benchmark the probabilities of rpro exhibited different vibrations with increasing radius values although the overall trends are clear.
this becomes particularly obvious on four version of mysql benchmarks.
we are interested in this phenomenon but we have not find the cause.
in summary this experiment further validated the effectiveness of rpro that selects priority change point s based on the radiuses of deadlocks.
it also shows that such radius is much smaller in practice than the total number of events of the same program.
.
related work in this section we review related work on deadlock detection and fixing and recovery of concurrency bugs.
.
deadlock detection detection of deadlocks is mainly based on detection of cycles in lock order graphs or cyclic lock dependencies on lock dependency relation .
both static and dynamic approaches could detect them .
static approaches may report false positives compared as they cannot precisely infer the runtime information even with various filter s .
although dynamic approaches are relatively precise they also report false positives.
hence many works target on detect ing real ones through reachability analysis or active te sting .
other works r ecently focus on how to actually trigger occurrences of real world deadlocks by searching for possible scheduling .
esd synthesizes an execution from a core dump file of an execution with a deadlock occurrence.
penelop e also synthesizes part of execution to replay an observed atomicity violations or deadlocks .
these techniques may fail due to the lack of thread interleaving and test cases.
contege targets to generate concurrent test cases so as to trigger an expected concurrency bug.
omen further synthesizes executions for deadlock triggering based on contege .
sherlock actively in fers test cases based on interleaving constraints of threads involved in a targeted deadlock via concolic executions .
deadlocks easily exist in database appl ications e.g.
mysql database servers .
these deadlocks could also be detected and prevented by analyzing hold and wait relations among threads and locks .
on the other hand pct and rpro focus on random testing.
pct has a probabilistic guarantee to find concurrency bugs including deadlocks of given bug depths.
rpro further takes bug radius into consideration to improve the probabilities of pct both theor etically and exper imentally.
.
concurrency bug fixing and recovery manual bug fixing not only takes a long time but is also error prone .
recently automated bug fixing become popular .
most of these techniques on fixing concurrency bugs insert new locks known as gate locks statically or dynamically to serial ize all executions of threads involved in a concurrency bug including afix axis grail gadara and .
one of challenges on fixing concurrency bugs is whether new concurrency bugs could be introduced.
for example by introducing new locks to fix atomicity violations or deadlocks new deadlock s may also be introduced .
even manual fixing may also introduce deadlocks e.g.
.
incorrect fixing indeed introduced new deadlocks .
axis further iteratively fixes introduced deadlocks by adding more new gate locks.
grail adopts petri net analysis to eliminate such introduced deadlocks which however is only applicable to deadlocks with two threads .
dfixer is designed to fix deadlocks without introducing new deadlocks.
our rpro could be easily adapted to test for deadlocks in fixed program by selecting priority change points near to the events of the original deadlocks.
recovery techniques could be integrated with deadlock detection and fixing.
sammati aims to provide deadlock recove ry by rolling back the executed operations once a deadlock is detected.
conair tries to recover most concurrency bugs including deadlock.
lin et al.
propose to change lock acquisition primitives to the corresponding primitives with trials e.g.
from pthread mutex lock to pthread mutex trylock to partially fix a deadlock .
they further propose to recover program executions once a deadlock occurs .
however there are still challenges for recovery from deadlock occurrence as discussed in .
.
conclusion existing randomized scheduling might be ineffective to trigger concurrency bugs.
pct randomly schedules a program based on priorities generated before executing a program and probabilistically guarantees to trigger concurrency bugs.
however pct may also become ineffective for concurrency bugs with l arger bug depths such as complex deadlocks .
we proposed the bug radius concept and rpro approach to generat e priorities based on bug radius.
rpro has a larger probabilistic guarantee to trigger concurrency bugs with bug depth of three or more .
the experime nt on a set of real world program also shows that rpro was much effective on unique deadlocks than pct .
in future we will apply rpro to trigger other kinds of concurrency bugs.
.
acknowledgement we thank anonymous reviewers for their invaluable comments and suggestions on improving this work .
this work is supported in part by national program of china 2014cb340702 and national natural science foundation of china nsfc grant no.
and national science foundation dge ccf .
.