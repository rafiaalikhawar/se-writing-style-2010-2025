syminfer inferring program invariants using symbolic states thanhvu nguyen university of nebraska lincoln usa tnguyen cse.unl.edumatthew b. dwyer university of nebraska lincoln usa dwyer cse.unl.eduwillem visser stellenbosch university south africa wvisser cs.sun.ac.za abstract we introduce a new technique for inferring program invariants that uses symbolic states generated by symbolic execution.
symbolic states which consist of path conditions and constraints on local variables are a compact description of sets of concrete program states and they can be used for both invariant inference and invariant verification.
our technique uses a counterexample based algorithm that creates concrete states from symbolic states infers candidate invariants from concrete states and then verifies or refutes candidate invariants using symbolic states.
the refutation case produces concrete counterexamples that prevent spurious results and allow the technique to obtain more precise invariants.
this process stops when the algorithm reaches a stable set of invariants.
we present syminfer a tool that implements these ideas to automatically generate invariants at arbitrary locations in a java program.
the tool obtains symbolic states from symbolic pathfinder and uses existing algorithms to infer complex potentially nonlinear numerical invariants.
our preliminary results show that syminfer is effective in using symbolic states to generate precise and useful invariants for proving program safety and analyzing program runtime complexity.
we also show that syminfer outperforms existing invariant generation systems.
i. i ntroduction program invariants describe properties that always hold at a program location.
examples of invariants include pre postconditions loop invariants and assertions.
invariants are useful in many programming tasks including documentation testing debugging verification code generation and synthesis .
daikon demonstrated that dynamic analysis is a practical approach to infer invariants from concrete program states that are observed when running the program on sample inputs.
dynamic inference is typically efficient and supports expressive invariants but can often produce spurious invariants that do not hold for all possible inputs.
several invariant generation aproaches e.g.
idiscovery pie ice numinv use a hybrid approach that dynamically infers candidate invariants and then statically checks that they hold for all inputs.
for a spurious invariant the checker produces counterexamples which help the inference process avoid this invariant and obtain more accurate results.
this approach called counterexample guided invariant generation cegir iterates the inference and checking processes until achieving stable results.
in this paper we present a cegir technique that uses symbolic program states.
our key insight is that symbolic states generated by a symbolic execution engine are a compact encodings of large potentially infinite sets of concrete states b naturally diverse since they arise along different execution paths c explicit in encoding relationships between program variables d amenable to direct manipulation and optimization such as combining sets of states into a single joint encoding and e reusable across many different reasoning tasks within cegir algorithms.
we define algorithms for symbolic cegir that can be instantiated using different symbolic execution engines and present an implementation syminfer that uses symbolic pathfinder spf a symbolic executor for java.
syminferuses symbolic states in both the invariant inference and verification processes.
for inference syminfer uses symbolic states to generate concrete states to bootstrap a set of candidate invariants using dig which can infer expressive nonlinear invariants.
for verification syminfer formulates verification conditions from symbolic states to confirm or refute an invariant solves those using a sat solver and produces counterexamples to refine the inference process.
symbolic states allow syminfer to overcome several limitations of existing cegir approaches.
idiscovery ice and pie are limited to computing relatively simple invariants and often do not consider complex programs with nonlinear arithmetic and properties such as x qy r x2 y2 z2.
these invariants appear in safety and security critical software and can be leveraged to improve quality e.g.
to verify the absence of errors in airbus avionic systems and to analyze program runtime complexity to detect security threats .
as our evaluation of syminfer demonstrates in sec.
v idiscovery which uses daikon for inference does not support nonlinear properties and both ice and pie timeout frequently when nonlinear arithmetic is involved.
recent work on numinv also uses dig to infer invariants but it invokes klee as a blackbox verifier for candidate invariants.
since klee is unaware of the goals of its verification it will attempt to explore the entire program state space and must recompute that state space for each candidate invariant.
in contrast syminfer constructs a fragment of the state space that generates a set of symbolic states that is sufficiently diverse for invariant verification and it reuses symbolic states for all invariants.
we evaluated syminfer over distinct benchmarks which consist of programs.
the study shows that syminfer can generate complex nonlinear invariants required in nla benchmarks is effective in finding nontrivial complexity bounds for programs with of those improving .
c ieeease urbana champaign il usa technical research804 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
int idiv int x1 int x2 assert x1 x2 int y1 y2 y3 y1 y2 y3 x1 while y3 !
if y2 x2 y1 y1 y2 y3 y3 else y2 y2 y3 y3 return y1 concrete l states x1 x2 y1y2y3 ... ... fig.
.
an integer division program and concrete l states observed on inputs x1 x2 and x1 x2 on the best known bounds from the literature improves on the state of the art pie tool in programs in the hola benchmark and outperforms numinv across the benchmarks while computing similar or better invariants.
these results strongly suggest that symbolic states form a powerful basis for computing program invariants.
they permit an approach that blends the best features of dynamic inference techniques and purely symbolic techniques such as weakest precondition reasoning.
the key contribution of our work lies in the identification of the value of symbolic states in cegir in developing an algorithmic framework for adaptively computing a sufficient set of symbolic states for invariant inference and in demonstrating through our evaluation of syminfer that it improves on the best known techniques.
ii.
o verview we illustrate invariant inference using symbolic states on the integer division algorithm in figure lmarks the location at which we are interested in computing invariants.
this example states assumptions on the values of the parameters e.g.
no division by zero.
the best invariant at l is x2 y1 y2 y3 x1.
this loop invariant encodes the precise semantics of the loop computing integer division i.e.
the dividend x1equals the divisor x2times the quotient y1plus the remainder which is the sum of the two temporary variables y2andy3.
existing methods of dynamic invariant inference would instrument the program at location lto record values of the local variables and then given a set of input vectors execute the program to record a set of concrete states of the program to generate candidate invariants.
since the focus here is on location l we refer to these as l states and we distinguish those that are observed by instrumentation on a program run.
it is these observed concrete l states that form the basis for all dynamic invariant inference techniques.
on eight hand selected set of inputs that seek to expose diverse concrete l states running daikon on this example results in very simple invariants e.g.
y1 x2 .
these are clearly much weaker than the desired invariant for this example.
moreover the invariant on x2is actually spurious since clearly 1can be passed as the second inputv2 y1 y2 y3 x1 v11 y1 y2 y3 x1 2x1 x2 l1 l2 l3 l4 l5 l6x16 retx 4x2 1x16 retx 3x2 1x16 retx 2x2 1x16 retx 1x2 l7 l8 l9 l10x16 retx 3x2 2x16 retx 2x2 l11 l12x2 l13x 3x16 retx 2x 2x16 retx 1x2 1x16 retx fig.
.
symbolic execution tree and symbolic l states which will reach l. applying the more powerful dig invariant generator permits the identification of the desired invariant but it too will yield the spurious x2 2invariant.
spurious invariants are a consequence of the diversity and representativeness of the inputs used and the l states that are observed.
leveraging symbolic states can help address this weakness.
a. generating a symbolic state space figure depicts a tree resulting from a depth bounded symbolic execution of the example.
the gray region includes paths limited to at most branches in this setting depth is a semantic property and syntactic branches with only a single infeasible outcome are not counted e.g.
the branches with labels enclosed in gray boxes.
we denote the unknown values of program inputs using variables xiand return points with ret.
the states at location lare denoted liin the figure.
an observed symbolic l state li is defined by the conjunction of the path condition i.e.
the set of constraints on the tree path to the state and vi a constraint that encodes the values of local variables in scope at l. for example the symbolic state l2is defined as x2 x16 x1 x2 y1 y2 y3 x1 .
as is typical in symbolic execution it is possible to increase the depth bound and generate additional states e.g.
l6 l10 l12 andl13which all appear at a depth of branches.
there are several properties of symbolic states that make them useful as a basis for efficient inference of invariants authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a symbolic states are expressive dynamic analysis has to observe many concrete l states to obtain useful results.
many of those states may be equivalent from a symbolic perspective.
a symbolic state like l2 encodes a potentially infinite set of concrete states e.g.
x1 x2 .
invariant generation algorithms can exploit this expressive power to account for the generation and refutation of candidate invariants from a huge set of concrete states by processing a single symbolic state.
b symbolic states are relational symbolic states encode the values of program variables as expressions over free variables capturing program inputs i.e.
xi.
this permits relationships between variables to be gleaned from the state.
for example state l2represents the fact that y3 x1for a large set of inputs.
c symbolic states can be reused invariant generation has to infer or refute candidate invariants relative to the set of observed concrete l states.
this can grow in cost as the product of the number of candidates and the size of number of observed states.
a disjunctive encoding of observed symbolic l states w i2 li can be constructed a single time and reused for each of the candidate invariants which can lead to performance improvement.
d symbolic states form a sufficiency test the diversity of symbolic l states found during depth bounded symbolic execution combined with the expressive power of each of those states provides a rich basis for inferring strong invariants.
we conjecture that for many programs a sufficiently rich set of observed l states for invariant inference will be found at relatively shallow depth.
for example the invariants generated and not refuted by the disjunction of l states at depth lk fl1 l2 l3 l4 l5 l7 l8 l9 l11g is the same for those at depth w i2 li.
consequently we explore an adaptive and incremental approach that increases depth only when new l states lead to changes in candidate invariants.
b.syminfer in action syminfer will invoke a symbolic executor to generate a set of symbolic l states at depth k e.g.
k 5in our example for the gray region.
syminfer then forms a small population of concrete l states using symbolic l states to generate a set of candidate invariants using dig.
dig produces three invariants at l for this example y1 y2 y3 x2 y1 x1 y2 y3 andx1 y3 y1 y3 y2 y3 y32 .
syminfer attempts to refute these invariants by using the full expressive power of the observed l states to determine if all of the represented concrete states are consistent with the invariant.
it does this by calling a sat solver to check implications such asw l2lk 5l y1 y2 y3 .
this refutes the first and third candidate invariant.
syminfer then seeks additional l states by running symbolic execution with a deeper bound k .
while this process produces an additional states to consider none of thosevoid pldi fig2 int m int n int p assert m n p int i j k int t counter variable while i n loop j t while j m loop j k i t while k p loop k t i k i fig.
.
a program that has several nonlinear complexity bounds.
can refute the remaining invariant candidate.
thus syminfer terminates and produces the desired invariant.
iii.
d ynamically infer numerical invariants a. numerical invariants we consider invariants describing relationships over numerical program variables such as x y idx jarrj x 2y .
these numerical invariants have been used to verify program correctness detect defects establish security properties synthesize programs recover formal specifications and more .
a particularly useful class of numerical invariants involves nonlinear relations e.g.
x y2 x2 y1 y2 y3 x1.
while more complex these arise naturally in many safety critical applications .
in addition to capturing program semantics e.g.
as shown in section ii nonlinear invariants can characterize the computational complexity of a program.
figure shows a program adapted from figure of with nontrivial runtime complexity.
at first this program appears to take o nmp due to the three nested loops.
but closer analysis shows a more precise bound o n nm p because the innermost loop which is updated each time loop executes changes the behavior of the outer loop .
when analyzing this program syminfer discovers a complex nonlinear invariant over the variables p m n andt a temporary variable used to count the number of loop iterations at location l program exit p2mt pm2t pmnt m2nt pmt2 mnt2 pmt pnt 2mnt pt2 mt2 nt2 t3 nt t2 this nonlinear degree equality looks very different than the expected bound n nm por even nmp .
however when solving this equation finding the roots of t we obtain three solutions that describe the exact bounds of this program t when n t p m when n p t n m p n when n p these results give more precise bounds than the given bound n mn pin .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
input terms states output equalities among terms 1eqinvs 2template createtemplate terms 3eqts eqts instantiate template states 4sols solve eqts 5eqinvs extracteqts sols terms 6return eqinvs fig.
.
infereqts dig s algorithm for finding candidate equalities b. inferring invariants using concrete states to infer numerical invariants syminfer uses the algorithms in dig .
for numerical invariants dig finds potentially nonlinear equalities and inequalities.
like other dynamic analysis tools dig generates candidate invariants that only hold over observed concrete l states.
nonlinear equalities to generate nonlinear equality invariants dig uses terms to represent nonlinear information from the given variables up to a certain degree.
for example the set of terms f1 x y z xy xz yz x2 y2 z2gconsist of all monomials up to degree 2over the variables fx y zg.
dig then applies the steps shown in figure to generate equality invariants over these terms using concrete states observed at location l and returns a set of possible equality relations among those terms.
first we use the input terms to form an equation template c1t1 c2t2 cntn where and tiare terms and ciare real valued unknowns to be solved for line .
next we instantiate the template with concrete states to obtain concrete equations line .
then we use a standard equation solver to solve these equations for the unknowns line .
finally we combine solutions for the unknowns if found with the template to obtain equality relations line .
octagonal inequalities dig uses various algorithms to infer different forms of inequality relations.
we consider theoctagonal relations of the form c1v1 c2v2 kwhere v1 v2are variables and ci2f 1gandkis real valued.
these relations represent linear inequalities among program variables e.g.
x y x y .
to infer octagonal invariants from concrete states f x1 y1 g we compute the upper and lowerbounds u1 max x i l1 min xi u2 max y i l2 min yi u3 max x i yi l3 min xi yi u4 max x i yi l4 min xi yi and form a set of octagonal relations fu1 x l1 u2 y l2 u3 x y l3 u4 x y l4g.
although computing octagonal inequalities is very efficient linear in the number of concrete states the candidate results are likely spurious because the upper and lower bound values might not be in the observed concrete states.
syminfer deals with such spurious invariants using a cegir approach described in section iv.iv.
cegir a lgorithms using symbolic states the behavior of a program at a location can be precisely represented by the set of all possible values of the variables in scope of that location.
we refer to these values as the concrete states of the program.
figure shows several concrete states observed at location lwhen running the program on inputs x1 x2 and x1 x2 .
the set of all concrete states is the most precise representation of the relationship between variables at a program location but it is potentially infinite and thus is difficult to use or analyze.
in contrast invariants capture program behaviors in a much more compact way.
for the program in figure invariants at location linclude x1 x2 y2 y3 x2 y1 y2 y3 x1 the most useful at lisx2 y1 y2 y3 x1 which describes the semantics of integer division.
the inequality y2 y3is also useful because it asserts that the remainder is non negative.
dynamic invariant generation techniques like daikon and dig use concrete program states as inputs to compute useful invariants.
we propose to compute invariants from the symbolic states of a program.
conceptually symbolic states serve as an intermediary representation between a set of concrete program states and an invariant that might be inferred from those concrete states.
we assume a fixed and known set of variables in scope at a given location in a program.
moreover we assume variables are indexed and that for an index i var i is a canonical name for that variable.
invariants will be inferred over these named variables.
this is straightforward for locals and parameters but permits richer naming schemes for other memory locations.
we write a set of appropriately typed values for those variables as v hv1 v2 v ni where the indexing corresponds to that of variables.
undefined variables have a ?value and theith value is written v .
a concrete state is l v where control is at location land program variables have the values given by v. letibe a set free variables that denote the undefined input values of a program.
a symbolic value is an expression written using constants elements of i and the operators available for the value s type.
we write a sequence of symbolic values as e he1 e2 e ni.
definition .
a symbolic state is l e c where control is at location l cis a logical formula written over i and a program variable takes on the corresponding concrete values that are consistent with cand symbolic value.
the semantics of a symbolic state is j l e c k f l v jsat i v e c g the role of cin a symbolic state is to define the constraints between variables for example that may be established on execution paths reaching l a path condition.
a. using symbolic states symbolic states can help invariant generation in many ways.
we describe two concrete techniques using symbolic states authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
input progp l number of states n depth d output cstates 1block false 2cstates 3sstates symex getstatesat p l d 4foreach s2sstates do ifsat s c then i getmodel cstates cstates l eval s e i block block v i2i i i 9whilejcstatesj n do s choose sstates ifsat s c block then i getmodel cstates cstates l eval s e i block block v i2i i i 15return cstates fig.
.
genstates generate concrete states from symbolic states to generate diverse concrete states and to verify candidate invariants.
bootstrapping dig with concrete states our method generates candidate invariants using existing state of the art concrete state based invariant inference techniques like dig.
in this application we need only use a small number of concrete states to bootstrap the algorithms to generate a diverse set of candidate invariants since symbolic states will be used to refute spurious invariants.
in prior work fuzzing was used to generate inputs and that could be used here as well but we can also exploit symbolic states.
figure shows how we use symbolic states to generate a diverse set of concrete states at least one for each symbolic state.
it first generates the set of symbolic l states reachable depth less than or equal to d line note that these states can be cached and reused for a given pandl.
the loop on line considers each such state checks the satisfiability of the states path condition c and then extracts the model from the solver.
we encode the model as a sequence i indexed by the name of a free input variables.
the symbolic state is then evaluated by the binding of concrete values to input variables in the model.
this produces a concrete state which is accumulated.
a conjunction of constraints equating the values of the model i and the names of inputs i is added to the blocking clause for future state generation.
the loop on line generates additional concrete states up to the requested number n. this process will randomly choose a symbolic state and then call the sat solver to generate a solution that has not already been computed here i is converted to a conjunction of equality constraints between input variables and values from a model.
when a solution is found we use the same processing as in lines to create a new concrete state.
symbolic states as a verifier figure shows how symbolic states are used to verify or refute a property.
theinput progp locl prop p clauses to block output counterexample cex 1p isinv unknown 2result unknown 3result0 unknown 4cex 5k default depth 6while true do sstates symex getstatesat p l k vc w s2sstates s c v ivar i s e vc vc wblock result0 sat vc p ifresult0 result then k k break result result0 ifresult0 satthen p isinv false cex getmodel break else if result0 unsat then p isinv true else if result0 unknown then p isinv unknown k k 24return cex fig.
.
verify check a candidate property using symbolic states algorithm obtains new symbolic states when it is determined that they increase the accuracy of the verification.
symbolic states are obtained from a symbolic execution engine.
there are potentially an infinite number of symbolic states at a location but most existing symbolic execution tools have the ability to perform a depth limited search.
we wrap the symbolic execution engine to just return the symbolic l states encountered during search of a given depth getstatesat .
the number of symbolic states varies with depth.
a low depth means few states.
few states will tend to encode a small set of concrete l states which limits verification and refutation power.
few states will also tend to produce a smaller and faster to solve verification condition.
to address this costeffectiveness tradeoff rather than try to choose an optimal depth our algorithm computes the lowest depth that yields symbolic states that change verification outcomes.
in essence the algorithm adaptively computes a good cost effectiveness tradeoff for a given program location of interest and invariant.
the algorithm iterates with each iteration considering a different depth k. the body of the each iteration lines works as follows.
it extract a set of symbolic states for the current depth using symbolic execution line note this can be done incrementally to avoid re exploring the program s state space using techniques like .
it then formulates a verification condition out of three components.
for each symbolic state it constructs the conjunction of its path condition c with constraints encoding equality constraints between variables and their symbolic values e these perstate conjunctions are then disjoined.
this expresses the set of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
concrete l states corresponding to all of the symbolic states.
the negation of the disjunction of the set of states that are to be blocked is formed.
these components are conjoined which serves to eliminate the concrete l states that are to be blocked.
if the resulting formula implies a candidate pthen that candidate is consistent with the set of symbolic states.
we use a sat solver to check the negation of this implication.
the solver can return sat which indicates that the property is not an invariant lines .
the solver is also queried for a model which is a sample state that is inconsistent with the proposed invariant.
this counterexample state is saved so that the inference algorithm can search for invariants that are consistent with it.
the solver can also return unsat indicating the property is a true invariant at least as far as the algorithm can determine given the symbolic states at the current depth.
finally the solver can also return unknown indicating it cannot determine whether the given property is true or false.
for the latter two cases we increment the depth and explore a larger set of symbolic states generated from a deeper symbolic execution.
lines work together to determine when increasing the depth does not influence the verification.
in essence they check to see whether the same result is computed at adjacent depths and if so they revert to the shallower depth and return.
b. a cegir approach using symbolic states counterexample guided invariant generation cegir techniques consist of a guessing component that infers candidate invariants and a checking component that verifies the candidate solutions.
if the candidate is invalid the checker produces counterexamples i.e.
concrete states that are not consistent with the candidate invariant.
the guessing process incorporates the generated counterexamples so that any new invariants account for them.
alternation of guessing and checking repeats until no candidates can be disproved.
syminfer integrates symbolic traces into two cegir algorithms to compute candidate invariants.
these algorithms use the inference techniques described in section iii for equality and inequality invariants.
nonlinear equalities figure defines our cegir algorithm for computing non linear equality invariants.
it consists of two phases an initial invariant candidate generation phase and then an iterative invariant refutation and refinment phase.
lines define the initial generation phase.
as as described in section iii b1 we first create terms to represent nonlinear polynomials line .
because solving for nunknowns requires at least nunique equations we need to generate a sufficient set of concrete l states line .
this can either be realized through fuzzing an instrumented version of the program that records concrete l states or as described in figure one can use symbolic l states to generate them.
the initial candidate set of invariants is iteratively refined on lines .
the algorithm then refutes or confirms them using symbolic states as described in figure .
any property that is proven to hold is recorded in invs and counterexample states input program p location l degree d output nonlinear equalities up to deg datl 1states 2invs 3block 4vars extractvars p l 5terms createterms vars d 6states genstates p l jtermsj 7candidates infereqts terms states 8while candidates6 do cexs foreach p2candidates do newcexs verify p l p block cexs cexs newcexs ifp isinv then invs invs fpg ifcexs thenbreak block block cexs states states cexs newcandidates infereqts termsstates candidates newcandidates invs 19return invs fig.
.
cegir algorithm for finding equalities.
cexs are accumulated across the set of properties.
generated counterexample states are also blocked from contributing to the verification process.
if no property generated counterexample states then the algorithm terminates returning the verified invariants.
the counterexamples are added to the set of states that are used to infer new candidate invariants this ensures that new invariants will be consistent with the counterexample states line .
these new results may include some already proven invariants so we remove those from the set of candidates considered in the next round of refinement.
octagonal inequalities our next cegir algorithm uses a divide and conquer approach to compute octagonal inequalities.
given a term t and an interval range we compute the smallest integral upperbound koftby repeatedly dividing the interval into halves that could contain k. the use of an interval range allows us to exclude terms ranges are too large or that do not exist .
for example if we check t maxv and it holds then we will not compute the bound of t which is strictly larger than maxv .
we start by checking a guess that t midv where midv dmaxv minv 2e.
these checks are performed by formulating a verification condition from symbolic states in a manner that is analogous to figure .
if this holds then k is at most midv and we tighten the search to a new interval .
otherwise we obtain counterexample with t having some value c where c midv .
we then tighten the search to a new interval .
in either case we repeat the guess for kusing an interval that is half the size of the previous one.
the search stops when minv andmaxv are the same or their difference is one in which case we return the smaller value if tis less than or equal both .
to find octagonal invariants over a set of variables e.g.
fx y zg we apply this method to find upperbounds of the termsfx x y y y z y zg.
note that we obtain authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
both lower and upperbound using the same algorithm because the upperbound for tessentially lowerbound of tsince all computations are reversed for t. syminfer reuses the symbolic states from the inference of equalities to formulate verification conditions for inequalities.
this is another example of how reuse speeds up inference.
v. i mplementation and evaluation we implemented syminfer in python sage .
the tool takes as input a java program with marked target locations and generates invariants at those locations.
we use symbolic pathfinder spf to extract symbolic states for java programs and the z3 smt solver to check and produce models representing counterexamples.
we also use z3 to check and remove redundant invariants.
syminfer currently supports equality and inequality relations over numerical variables.
for nonlinear equalities syminfer uses techniques from dig to limit the number of generated terms.
this allows us for example to infer equalities up to degree for a program with variables and up to degree for program with variables.
for octagonal invariants we consider upper and lower bounds within the range we rarely observe inequalities with large bounds.
syminfer can either choose random values in a range by default for bootstrapping or use the algorithm in figure .
all these parameters can be changed bysyminfer s user we chose these values based on our experience.
a. research questions to evaluate syminfer we consider three research questions is syminfer effective in generating nonlinear invariants describing complex program semantics and correctness?
can syminfer generate expressive invariants that capture program runtime complexity?
how does syminfer perform relative to pie a state ofthe art invariant generation technique?
to investigate these questions we used benchmark suites consist of java programs described in details in each section .
these programs come with known or documented invariants.
our objective is to compare syminfer s inferred invariants against these documented results.
to compare invariants we used z3 to check if the inferred results imply the documented ones.
we use a script to run syminfer times on each program and report the median results.
the scripts automatically terminates a run exceeding minutes.
the experiments reported here were performed on a core intel i7 cpu .0ghz linux system with gb of ram.
b. analyzing program correctness in this experiment we use the nla testsuite which consists of programs implementing mathematical functions such as intdiv gcd lcm power.
although these programs are relatively small under locs they contain nontrivial structures such as nested loops and nonlinear invariant properties.
to the best of our knowledge nlatable i experimental results for 27programs in the nla testsuite .
xindicates when syminfer generates results sufficiently strong enough to prove known invariants .
prog desc locs v t d invs time s correct cohendiv int div .
x divbin int div .
x manna int div .
x hard int div .
x sqrt square root .
x dijkstra square root .
x freire1 square root freire2 cubic root cohencu cubic sum .
x egcd1 gcd .
x egcd2 gcd egcd3 gcd prodbin gcd lcm .
x prod4br gcd lcm .
x knuth product fermat1 product .
x fermat2 divisor .
x lcm1 divisor .
x lcm2 divisor .
x geo1 geo series .
x geo2 geo series .
x geo3 geo series ps2 pow sum .
x ps3 pow sum .
x ps4 pow sum .
x ps5 pow sum .
x ps6 pow sum .
x contains the largest number of programs containing nonlinear arithmetic.
these programs have also been used to evaluate other numerical invariant systems .
these nla programs come with known program invariants at various program locations e.g.
mostly nonlinear equalities for loop invariants and postconditions .
for this experiment we evaluate syminfer by finding invariants at these locations and comparing them with known invariants.
results table i shows the results of syminfer for the nla programs.
column locs show the number of locations where we obtain invariants.
column v t d shows the number of variables terms and highest degree from these invariants.
column invs shows the number of discovered equality and inequality invariants.
column time shows the total time in seconds.
column correct shows if the obtained results match or imply the known invariants.
for programs syminfer generates correct invariants that match or imply the known results.
in most cases the discovered invariants match the known ones exactly.
occasionally we obtain results that are equivalent or imply the known results.
for example for sqrt for some runs we obtained the documented equalities t 2a s a and for other runs we obtain t 2a t2 4s 2t which are equivalent to s a 2by replacing twith 2a .
we also obtain undocumented invariants e.g.
syminfer generates the postconditions x qy r r r x r y 1for cohendiv which computes the integer division result of two integers q x y the first invariant is known and describes the precise semantics of integer division the dividend xis the divisor ytimes the quotion qplus the remainder r. the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii experimental results for computing programs complexities .
x syminfer generates the expected bounds .x program was slightly modified to assist the analysis .xx syminfer obtains more precise bounds than reported results .
prog v t d invs time s bound cav09 fig1a .
x cav09 fig1d .
x cav09 fig2d .
x cav09 fig3a .
x cav09 fig5b .
x pldi09 ex6 .
x pldi09 fig2 .
xx pldi09 fig4 .
x pldi09 fig4 .
x pldi09 fig4 .
x pldi09 fig4 pldi09 fig4 .
x popl09 fig2 .
xx popl09 fig2 .
xx popl09 fig3 .
x popl09 fig4 .
x popl09 fig4 .
xx popl09 fig4 .
x popl09 fig4 .
x other obtained inequalities were undocumented.
for example r 0asserts that the remainder ris non negative and r x r y 1state that ris at most the dividend x but is strictly less than the divisor y. our experience shows thatsyminfer is capable of generating many invariants that are unexpected yet correct and useful.
syminfer did not find invariants for programs marked with in table i .
for egcd2 egcd3 the equation solver used in sage takes exceeding long time for more than half of the runs.
for geo3 we obtained the documented invariants and others but z3 stops responding when checking these results.
freire1 andfreire2 contain floating point arithmetic which are currently not supported by syminfer.
spf failed to produce symbolic states for knuth for any depth we tried.
this program invokes a library function math.sqrt and spf does not know the semantics of this function and thus fails to provide useful symbolic information.
for egcd2 egcd3 and geo3 syminfer times out after minutes and for freire1 freire2 and knuth it exits upon encountering the unsupported feature.
c. analyzing computational complexity as shown in section iii nonlinear invariants can represent precise program runtime complexity.
more specifically we compute the roots of nonlinear relationships to obtain disjunctive information e.g.
x2 x 2 x which apture different and precise complexity bounds of programs.
to further evaluate syminfer on discovering program complexity we collect programs adapted from existing static analysis techniques specifically designed to find runtime complexity .
these programs shown in table ii are small but contain nontrivial structures and represent examples from microsoft s production code .
for this 1we remove nondeterministic features in these programs because syminfer assumes determinstic behaviors.experiment we instrument each program with a fresh variable trepresenting the number of loop iterations and generate postconditions over tand input variables e.g.
see figure .
results table ii shows the median results of syminfer from runs.
column bound contains a xif we can generate invariants matching the bounds reported in the respective work and xxif the discovered invariants represent more precise bounds than the reported ones.a x indicates when the program was modified slightly to help our analysis described below.
for programs syminfer discovered runtime complexity characterizations that match or improve on reported results.
for cav09 fig1a we found the invariant mt t2 100m 200t which indicates the correct bound t m 100 t .
for these complexity analyses we also see the important role of combining both inequality and equality relations to produce informative bounds.
forpopl09 fig3 4 syminfer inferred nonlinear equality showing that t n t mand inequalities asserting that t n t m together indicating that t max n m which is the correct bound for this program.
in four programs syminfer obtains better bounds than reported results.
the pldi fig2 programs showing in figure is a concrete example where the obtained three bounds are strictly less than the given bound.
for several programs we needed some manual instrumentation or inspections to help the analysis.
for popl09 fig4 1 we added the precondition asserting the input mis nonnegative.
for pldi09 fig4 5 we obtained nonlinear results giving three bounds t n m t m and t which establish the reported upperbound t max n m m .
for pldi09 fig4 4 we obtained invariants that are insufficient to show the reported bound.
however if we create a new term representing the quotient of an integer division of two other variables in the program and obtain invariants over that term we obtain more precise bounds than those reported.
d. comparing to pie we compare syminfer to the recent cegir based invariant tool pie .
pie aims to verify annotated relations by generating invariants based on the given assertions.
in contrast syminfer generates invariants at given locations without given assertions or postconditions.
we use the hola benchmarks adapted by the pie developers.
these programs are annotated with various assertions representing loop invariants and postconditions.
this benchmark consists of small programs but contain nontrivial structures including nested loops or multiple sequential loops.
these programs shown in table iii have been used as benchmarks for other static analysis techniques .
for this experiment we first run pie and record its run time on proving the annotated assertions.
next we removed the assertions in the programs and asked syminfer to generate invariants at those locations.
our objective is to compare syminfer s discovered invariants with the annotated assertions.
because these hola programs only consist of asser811 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii syminfer run on hola benchmarks .x produce sufficiently strong results to prove assertions .
fail to make sufficiently strong invariants .
benchmark pie time s syminfer time s correct h01 .
.
h02 .
.
x h03 .
.
x h04 .
.
x h05 .
.
x h06 .
.
x h07 .
x h08 .
.
x h09 .
x h10 .
.
x h11 .
.
x h12 .
.
x h13 .
x h14 .
.
x h15 .
.
x h16 .
.
x h17 .
.
x h18 .
.
x h19 .
x h20 .
.
x h21 .
.
h22 .
.
x h23 .
.
x h24 .
h25 .
x h26 .
.
x h27 .
h28 .
.
x h29 .
.
x h30 .
.
h31 .
.
x h32 .
.
x h33 .
x h34 .
.
x h35 .
.
x h36 .
x h37 .
x h38 .
.
x h39 .
.
x h40 .
.
x h41 .
.
x h42 .
.
h43 .
.
x h44 .
.
x h45 .
.
x h46 .
.
x tions having linear relations we ask syminfer to only generate invariants up to degree quadratic relations can represent linear relations e.g.
x2 x 2 x .
results table iii shows these obtained results from pie and syminfer.
column pie time shows the time in seconds for pie to run each program.
column syminfer time shows the time in seconds for syminfer to generate invariants for each program the median of runs .
the symbol indicates when pie fails to prove the given assertions e.g.
because it generates invariants that are too weak.
column correct shows whether syminfer s generated invariants match or imply the annotated assertions and therefore prove these assertions.
for this experiment we manually check the result invariants and use z3 to compare them to the given assertions.
a xindicates that the generated invariants match or imply the assertions.a indicates that the generated invariants are not sufficiently strong to prove the assertions.
for programs syminfer discovered invariants are sufficiently strong to prove the assertions.
in most of these cases we obtained correct and stronger invariants than the given assertions.
for example for h23 syminfer inferred the invariants i n n2 n 2s i n which imply the postcondition s .
for h29 we obtained the invariants b c a d a b a which imply the given postcondition a c b d. surprisingly syminfer also found invariants that are precise enough to establish conditions under forms that are not supported by syminfer.
for example h8 contains a postcondition x 4 y which has a disjunctive form of strict inequalities.
syminfer did not produce this invariant but instead produced a correct and stronger relation x y which implies this condition.
many hola programs contain disjunctive or conditional properties e.g.
if c assert p where the property ponly holds when the condition cholds written c p .
for example for h18 we obtained fj 100f which implies the conditional assertion f6 j .
for h37 pie failed to prove the postcondition if n assert m m n which involves both conditional assertions and strict inequalities.
for this program syminfer inferred equations and inequalities2 which together establish the postcondition.
for programs syminfer either failed to produce invariants programs marked with or discovered invariant that are not strong enough to prove the given assertions programs marked with .
for both h24 and h27 z3 stops responding when checking the inferred results and the run were terminated after minutes.
for h01 we found the invariant x y which is not sufficiently to establish the postcondition y .
for h27 syminfer found no relation involving the variable cto prove the assertion c .
summary these preliminary results show syminfer generates expressive useful and interesting invariants describing the semantics and match documented invariants nla programs discovers difficult invariants capturing precise and informative complexity bounds of programs programs and is competitive with pie hola programs .
we also note that pie ice and idiscovery other cegir based tools reviewed in section vi cannot find any of these high degree nonlinear invariants found by syminfer.
e. threats to validity syminfer s run time is dominated by computing invariants more specifically solving hundred of equations for hundred of unknowns.
the run time of dig can be improved significantly by limiting the search to invariants of a given maximum degree rather than using the default setting.
verifying candidate invariants i.e.
checking implication using the z3 solver is much faster than dig even when multiple checks are performed at different depths.
this shows an advantage of reusing symbolic states when checking new invariants.
2m2 nx m x mn x2 x m x x m n x authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
syminfer encodes all symbolic states to into the z3 verification condition.
this results in complex formulas with large disjunctions that can make z3 timeout.
moreover depending on the program spf might not be able to generate all possible symbolic states.
in such cases syminfer cannot refute candiate invariants and thus may produce unsound results.
however our experience shows that spf by its nature as a symbolic executor turns out to be very effective in producing sufficient symbolic states which effectively remove invalid candidates.
finally we reuse existing analysis tools such as dig and spf which provides a degree of assurance in the correctness of syminfer but our primary means of assuring internal validity was performing both manual and automated smt checking of the invariants computed for all subject programs.
while our evaluation uses a variety of programs from different benchmarks these programs are small and thus do not represent large software projects.
their use does promote comparative evaluation and reproducibility of our results.
we believe using symbolic states will allow for the generation of useful and complex invariants for larger software systems in part because of the rapid advances in symbolic execution and smt solving technologies and syminfer leverages those advances.
vi.
r elated work and future work daikon is a well known dynamic tool that infers candidate invariants under various templates over concrete program states.
the tool comes with a large set of templates which it tests against observed concrete states removing those that fail and return the remaining ones as candidate invariants.
dig is similar to daikon but focuses on numerical invariants and therefore can compute more expressive numerical relations than those supported by daikon s templates.
pie and ice uses cegir to infer invariants to prove a given specification.
to prove a property pie iteratively infers and refined invariants by constructing necessary predicates to separate good states satisfying the property and bad states violating that property.
ice uses a decision learning algorithm to guess inductive invariants over predicates separating good and bad states.
the checker produces good bad and implication counterexamples to help learn more precise invariants.
for efficiency they focus on octagonal predicates and only search for invariants that are boolean combinations of octagonal relations.
in general these techniques focus on invariants that are necessary to prove a given specification and thus the quality of the invariants are dependent target specification.
numinv is a recent cegir tool that discovers invariants for c programs.
the tool also uses dig s algorithms to infer equality and inequality relations.
for verification it instruments invariants into the program and runs the klee testinput generation tool .
klee does use a symbolic state representation internally but this is inaccessible to numinv.
moreover klee is unaware of its use in this context and it recomputes the symbolic state space completely for each verification check which is inefficient.
for the experiments in section v syminfer is comparable to numinv in the qualityof invariants produced but syminfer runs faster in spite of the fact that klee s symbolic execution of c programs is known to be faster than spf s performance on java programs.
we credit this to the benefits of using symbolic states.
similar to syminfer the cegir based idiscovery tool uses spf to check invariants.
however idiscovery does not exploit the internal symbolic state representation of symbolic excution but instead runs spf as a blackbox to check program assertions encoding candidate invariants.
to speed up symbolic execution idiscovery applies several optimizations such as using the green solver to avoid recomputing the symbolic state space for each check.
in contrast syminfer precomputes the full disjunctive smt formula encoding the paths to the interested location once and reuses that formula to check candidate invariants.
for dynamic inference idiscovery uses daikon and thus has limited support for numerical invariants.
for example idiscovery cannot produce the required nonlinear invariants or any relevant inequalities for the programs in figures and .
note that for programs involving nonnumerical variables daikon idiscovery might be able to infer more invariants than syminfer.
syminfer is unlike any of the above in its reliance on symbolic states to bootstrap verify and iteratively refine the invariant generation process.
there are clear opportunities for significantly improving the performance of syminfer and targeting different languages such as c through the use of other symbolic executors.
for example generating symbolic states can be sped up for invariant inference by combining directed symbolic execution to target locations of interest memoized symbolic execution to store symbolic execution trees for future extension and parallel symbolic execution to accelerate the incremental generation of the tree.
moreover we can apply techniques for manipulating symbolic states in symbolic execution to significantly reduce the complexity of the verification conditions sent to the solver.
vii.
c onclusion we present syminfer a method that uses symbolic encodings of program states to efficiently discover rich invariants over numerical variables at arbitrary program locations.
syminfer uses a cegir approach that uses symbolic states to generate candidate invariants and also to verify or refute and iteratively refine those candidates.
key to the success of syminfer is its ability to directly manipulate and reuse rich encodings of large sets of concrete program states.
preliminary results on a set of nontrivial programs show that syminfer is effective in discovering useful invariants to describe precise program semantics characterize the runtime complexity of programs and verify nontrivial correctness properties.
acknowledgment this material is based in part upon work supported by the national science foundation under grant number .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.