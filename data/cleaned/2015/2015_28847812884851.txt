quantifying and mitigating turnover induced knowledge loss case studies of chrome and a project at avaya ypeter c. rigby yyue cai zhu ysamuel m. donadelli xaudris mockus ydepartment of computer science and software engineering concordia university montreal canada xdepartment electrical engineering and computer science university of tennessee knoxville usa rst.last concordia.ca audris avaya.com abstract the utility of source code as of other knowledge artifacts is predicated on the existence of individuals skilled enough to derive value by using or improving it.
developers leaving a software project deprive the project of the knowledge of the decisions they have made.
previous research shows that the survivors and newcomers maintaining abandoned code have reduced productivity and are more likely to make mistakes.
we focus on quantifying the extent of abandoned source les and adapt methods from nancial risk analysis to assess the susceptibility of the project to developer turnover.
in particular we measure the historical loss distribution and nd that projects are susceptible to losses that are more than three times larger than the expected loss.
using historical simulations we nd that projects are susceptible to large losses that are over ve times larger than the expected loss.
we use monte carlo simulations of disaster loss scenarios and nd that simplistic estimates of the truck factor exaggerate the potential for loss.
to mitigate loss from developer turnover we modify cataldo et al.
s coordination requirements matrices.
we nd that we can recommend the correct successor to of the time.
we also nd that having successors reduces the expected loss by as much as .
our approach helps large projects assess the risk of turnover thereby making risk more transparent and manageable.
categories and subject descriptors d. .
k. .
software management software development software maintenance software process keywords quantitative risk management mining software repositories knowledge distribution truck factor successors turnover permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c copyright held by the owner author s .
publication rights licensed to acm.
isbn .
.
.
.
introduction software projects have a variety of risks that range from uncertainty about future technologies and user needs to simple programming errors.
individuals who create software transfer their often tacit knowledge into the inner workings of the system making it di cult for others to maintain.
it is therefore important to evaluate the risk of developers leaving the project.
developer turnover has a wide range of reasons including job dissatisfaction from boredom or conict alternative job opportunities and personal issues .
organizational changes in the business environment and globalization may lead to turnover in the form of outsourcing and o shoring practices .
while new developers may bring insights and enthusiasm the departure of developers negatively a ects both quality and productivity in a software project creating substantial risks .
the aim of this paper is to quantify the risk of developer turnover and investigate ways to mitigate this risk to make projects more resilient.
risk management involves the quanti cation of the impact of a risk and the probability of it materializing.
we measure the impact of turnover via knowledge loss source les abandoned after developers leave .
we adapt techniques from nancial risk management and use historic knowledge loss data to obtain the probability that a certain level of losses will be sustained.
we run simulations to determine alternate turnover scenarios.
in historical simulations we randomly choose the set of developer who leave but keep the number of leavers at historical levels.
in a monte carlo simulation we vary the number of developers leaving the project to simulate disaster or truck factor scenarios.
combining software mining techniques with quantitative risk management we estimate and simulate how at risk risk exposure a software project is to developer turnover and examine ways to reduce the risk by suggesting successors.
we perform two case studies on large software projects because the risks from turnover are trivially assessed on small projects i.e.if a small group of developers leaves the entire project is abandoned.
we chose one open source project and one project in a traditional closed source environment to measure the di erences in their risk pro les and answer three research questions.
.
research questions rq1 loss distributions what is the historical knowledge loss distribution and the size of large unexpected losses?
while turnover in moderate amounts may bring innovation to the project high turnover rates have been associated ieee acm 38th ieee international conference on software engineering with lower quality because of loss of expertise lower productivity because newcomers may not be as productive as the developer they replace and may introduce more defects .
in other domains turnover has been shown to be associated with higher incidence of health problems in a study of mid level managers and executives in the canadian civil service .
furthermore maintaining abandoned code may lead to higher incidence of serious defects because the project survivors are likely to lack the understanding of the design and structure of the abandoned code.
we therefore gauge the rate of turnover in projects.
in particular we calculate the loss distribution expected loss and two measures of unexpectedly large losses knowledge at risk kar and the expected shortfall es .
unexpectedly large losses describe the right tail of the loss distribution.
with most losses being small the expected loss may not appear to be large.
however large unexpected losses such as when a core developer leaves can threaten the success of a project.
we examine the level of risk from the perspective of expected and unexpected knowledge loss and compare the projects to each other.
in particular our risk analysis allows project managers to estimate the number of developers they may need to replace in any quarter i.e.
four month period.
rq2 turnover simulations how susceptible is the project to alternate historical loss and disaster scenarios?
the historical loss distribution describes losses that actually occur.
financial risk assessments required at large banks involve a historical simulation and often a monte carlo simulation of loss scenarios .
we replay the losses sustained each quarter and use strati ed random sampling to select developers to leave.
this historical simulation gives us a sense of how bad the actual loss is compared to how bad it could have been.
some recent studies have evaluated disaster loss scenarios which are known colloquially as the truck factor .
these previous works have only quanti ed how large disaster scenarios can be but not how likely they are to occur.
for risk management the impact loss needs to be weighted by the likelihood of an event.
previous work on disaster scenarios however does not consider the likelihood of the event.
following nancial models we incorporate the most likely disaster scenarios i.e.those that occur at least of the time to enable risk management.
rq3 successors can we mitigate the impact of turnover by suggesting the developer who should take over an abandoned le?
turnover is inevitable for example in a report by the job website payscale the average tenure of a new developer at google and amazon is only slightly more than one year .
it is important to nd ways to mitigate the e ects of high turnover on code ownership by identifying the best candidates to take over the maintenance of abandoned code.
a development team faced with a departing developer can hire a new developer or select an existing developer to maintain abandoned code.
reserving abandoned les for incoming developers would be e ective in keeping existing developers on the code they already own but it may be risky because newcomers may not understand the project let alone the speci c code that was abandoned .
to reduce risk of errors it may be critical to have experienced developers maintain more central code instead of leaving it without an owner or in the hands of newcomers.
we rst investigate which option was chosen in the projects we studied.we then use a modi ed version of cataldo et al.
s coordination requirements matrix to recommend developers who have worked in similar areas to the abandoned le.
we measure how many possible successors exist for each abandoned le in the system and evaluate how well our technique predicts actual succession on abandoned les.
we also determine how much the risk of turnover is reduced by having available successors.
our results quantify for project managers the reduction in risk attained by assigning co developers to risky les.
the remainder of the paper is structured as follows.
in section we describe our data and methods.
in section we introduce quantitative risk management including the historical loss distribution and measures of unexpected loss.
in section we simulate alternative historical losses and disaster or truck factor scenarios.
we assign a probability to each loss thereby allowing teams to plan for higher probability losses instead of unrealistic maximal losses.
in section we mitigate losses from turnover by recommend possible successors based on co change relationships with abandoned les.
we determine how well we can predict successors and if these successors reduce the risk involved in turnover.
in the nal sections we discuss threats to validity and conclude the paper.
.
data and method to study turnover we select two large projects one industrial project and one open source project.
the industrial project is from avaya and has been developed for over twenty years.
we will refer to this project as avaya throughout this paper.
the avaya project is in the domain of core telephony and networking and is sold to small to medium sized businesses.
the code is mostly written in the c language as cost concerns require e ciency of an embedded platform.
the product has over 5m sloc with the development team primarily located in the uk romania and india.
the second project is chrome a google lead project that is open source.
in contrast to the avaya project chrome is a webbrower designed for end users.
chrome development is conducted in public but the practices it uses mirror those used by google internally and many of the developers are google employees.
chrome has been under development since and this study follows it up to the present.
excluding third party tools that are part of the chrome source repository there are 3m locs.
since there are a large number of peripheral contributors on oss projects we de ne the core team using mockus et al.
s measure of the top developers whose combined e ort is of the development work.
we stratify the developers into core and non core to limit the volatility introduced by transient developers.
.
identifying developers on chrome the author and committer of the change are the same and are identi ed by his or her email address.
a single developer may have made commits with multiple email addresses.
to resolve multiple address to a single individual we use canfora et al.
s name aliasing tool.
we added an additional cleaning stage where diacritics are converted into their ascii form as their tool cannot handle these characters e.g.
o is converted to o .
at avaya developers use a company assigned username when they commit changes to the system so a manual check was su cient to correct any variations in duplicate usernames.
1007we need to know when a developer joins and leaves a project.
for oss projects we do not have the o cial records of when a developer joins and leaves a project.
we use developers rst commit and last commit dates to indicate when they join and leave a project respectively.
although avaya keeps records of when developers join and leave the company the records of when they join and leave a project are not kept.
since our results are at the project level we use the same commit data strategy for estimating joining and leaving times for the avaya project.
.
file ownership and abandonment for this paper the amount of knowledge lost when a developer leaves is dependent on what code the developer created or maintained.
we do not factor in non code contribution such as those made by a user experience designer or architect.
determining code ownership and the related concept of developer expertise has received considerable attention in the software engineering literature.
previous studies consider each commit to a software artifact as a unit of developer s ownership and expertise .
further elaboration of ownership is the degree of knowledge model where later commits decrease the expertise of developers with earlier commits .
these measures have a serious shortcoming because the number of commits is not always representative of the knowledge in the system that must be maintained.
for example with a commit based approach the deletion and addition of lines are counted equally.
however the deletion of a line removes knowledge that must be maintained while an addition increases the maintenance burden.
as a result a commit based approach is inaccurate when assessing the amount of source code knowledge that must be maintained when a developer leaves a project.
for example a team could delete the leaving developers module reducing the maintenance burden to zero.
instead of a commit based approach we use a blame based approach.
the blame function present in version control systems determines the person who last changed a line of code.
in this way we are able to follow the ownership trend at a ner granularity of each line of code in the system.
we limit our analysis to source les only for example on avaya we only consider .c and .h les.
we consider a le to be abandoned when of the lines in the le have been abandoned.
we also use the blame based ownership approach to simulate historical based and disaster scenarios.
the simulation methodology are presented in section .
.
definitions we measure turnover at quarterly intervals i.e.in four month periods.
we use the following dependent de nitions of ownership abandonment and knowledge loss .line ownership is calculated using git blame to determine the last person changing a line of code see section .
.
.adeveloper leaves during the quarter of his or her last commit.
we exclude the last year of historic data to avoid categorizing an up to day leave of absence as departure.
.aline of code is abandoned when blame attributes the line to a developer who has left the project.
.a le is abandoned when or more of the lines in a le are abandoned.
we use the threshold toexclude developers with trivial contributions to a le.
note a le that is abandoned in one quarter may be adopted by developers making changes in subsequent quarters.
.the knowledge loss in a quarter is the number of les that are abandoned.
in sections and we describe how we adopt nancial risk models by replacing dollar loses as in writing o bad loans with knowledge loss i.e.
les abandoned by developers leaving in a quarter.
this mapping does not violate the assumptions of the nancial risk models and therefore can be applied to assess risk from knowledge loss.
.
file dependencies and succession when turnover occurs and les are abandoned we want to be able to suggest the most quali ed developer to take over the maintenance of the le.
our simple method involves calculating co changing les using a modi ed version of cataldo et al.
s coordination matrices .
we test whether developers who have changed les that co changed with an abandoned le are likely to take over the maintenance of the abandoned le.
we also quantify the degree to which les that have potential successes reduce overall turnover risk.
the details of our approach is described in section .
.
actual losses and risk measures rq1 what is the historical knowledge loss distribution and the size of large unexpected losses?
risk management involves quantifying the impact or size of a loss and determining the probability that a loss of that size will occur .
to model nancial risks large banks track the losses that they sustain from a set of loans.
overtime they are able to understand the loss distribution which in turn allows them to assess the riskiness of their loan portfolio .
since software development is a knowledge intensive activity we adapt this methodology to measure knowledge loss from developer turnover on large software projects.
using the history of the software projects we calculate the loss distribution as the number of les that become abandoned in a four month period i.e.a quarter.
based on this distribution we can calculate the expected loss and two measures of unexpected large losses the knowledge at risk kar which measures the size of a loss that has a chance of occurring and expected shortfall es which measures the average size of losses that happen less than of the time.
historical knowledge loss distribution in figures and we see the loss distribution as the number of les abandoned in a four month period.
we can see the mean and median loss for avaya are and les and for chrome they are and respectively.
this means for example that for chrome we can expect that les will be abandoned in any quarter.
from the gures it is clear that the number of abandoned les is not normally distributed with the majority of the values cluster around small numbers of abandoned les per quarter.
although the mean is an overestimate of the median loss in risk management we are concerned with how big we can expect our losses to be so we are interested in the right tail of the loss distribution.
risk from unexpected large losses the economic models in the s failed to predict the recession i.e.a .
.
.
file abandonmentdensitymean loss kar esfigure avaya loss distribution .
.
.
.
file abandonmentdensitymean loss kar es figure chrome loss distribution series of large losses as a result economists developed techniques to predict large losses .
as we can see from our loss distributions figure and it is not normally distributed.
so if we naively assume that we will have the mean loss in each quarter we underestimate the size of a large turnover event.
since these large turnover events can have disproportionately high risks e.g.
the project may fail from high knowledge loss if we lose core team members it is critical to understand how often we can expect to have a large loss.
we adapt the most common nancial measures of unexpected large losses to a software knowledge loss setting.
knowledge at risk kar is adapted from value at risk var and is de ned over a con dence interval .
given a con dence level of kar is the size of loss l that actual loss l occurs with a probability of kar inffl2r p l l g it can be thought of percentile of knowledge loss distribution.
in e ect kar is the quantile at in the loss distribution.
unless otherwise mentioned we use kar 95in this work.kar 95can be interpreted as the size of loss that has a chance of occurring in a quarter.
from the loss distributions in figure and we see that the kar 95for avaya is .
this means that in any quarter there is a chance that of the les will become abandoned.
the corresponding kar for chrome is les.
expected shortfall es the main criticism of kar is that it can underestimate the size of the largest losses .
in e ect kar is the maximum loss that would occur at most percent of the time.
expected shortfall is the expected value that would occur at least percent of the time.
formally es can be de ned in terms of kar and expected value e as es e fl l kar g as we can see in the gures the es95or mean of the largest losses that occur at most of the time for avaya and chrome are and les respectively.
the longer the right tail of the loss distribution the larger the unexpected losses.
the es is .
.
and .
times larger than the kar mean and median for avaya.
the es loss is .
.
and .
times larger than the mean median and kar for chrome.
for both projects the es is many times larger than the expected loss indicating a long right tail and a potential for large losses.
previous works on software knowledge loss report losses as percentages of total les or lines .
these works examined small projects but on larger projects even large losses of knowledge can be small compared to the overall size of the project.
for example the es of les on chrome represents only of total number of les in the system.
despite this low percentage it is a daunting task to nd maintainers for recently abandoned les.
as a result we follow the norm in nancial risk management and report the actual losses instead of the percentage of total loss.
in the next section we simulate disaster scenarios and give further examples of why percentages are inappropriate to represent risk from loss.
these simulations also make our results actionable for project managers.
.
simulating loss scenarios rq2 how susceptible is the project to alternate historical loss and disaster scenarios?
we adapt the simulation methodologies used by large banks with the goal of understanding how bad losses could have been .
the loss distribution and resulting knowledge at risk depend on the knowledge distribution of the system i.e.
the le ownership distribution and the speci c developers who leave.
although we have a limited number of quarters for avaya and chrome and respectively we are able to use the hundreds of developers and tens of thousands of les in the underlying le co ownership distribution to estimate the likelihood of extreme events.
through simulation we manipulate these two variables to understand how the knowledge distribution has changed over time historical simulation and how well the current distribution of knowledge withstands disaster scenarios monte carlo simulation .
by using the underlying le co ownership and randomly sampling the groups of developers that leave we are able to assess the risk in a wide range of scenarios.
.
historical simulation for the historical simulation we hold the le co ownership distribution i.e.knowledge distribution and the number of developers who leave constant but vary which developers actually leave.
in this way we understand whether the actual loss was better or worse than what we could expect based on the le co ownership distribution and the number of people who leave.
since the distribution of work on the development team is skewed we stratify developers into core and non core see section .
it is important to stratify developers because di erent types of developers have di erent reasons to leave.
speci cally we do the following .
we use the knowledge distribution of each quarter .we use the number of core developers lc and non core developers lnc who leave for each quarter .we use strati ed random sampling to choose the same number of leavers rnd lc lnc .
strati ed random sampling ensures that we randomly pick the number of core and non core developers who actually left in a quarter.
since more non core developers leave if we use uniform random sampling we would randomly pick an unrealistically large number of core developers as leavers.
this would in ate the risk.
we run simulations for each quarter .we compare the actual knowledge loss in a quarter to the simulated loss in terms of expected loss kar and es in figure and we see the simulated historical losses for avaya and chrome.
the vertical line represents a con dence interval.
the value at the 95th quantile is the simulated kar and the triangle represents the simulated es.
the actual loss is represented by an a cross.
for avaya we see that the actual losses are always within a con dence interval of the simulated random losses indicating that the actual knowledge loss cannot be statistically di erentiated from the randomly simulated losses.
quarters and show a trend toward a higher actual loss than the simulation mean indicating that in these quarters important developers left.
in contrast for chrome the actual loss is always at or below the simulated mean indicating that in all cases developers with lower importance left and in some cases the result is statistically lower e.g.
quarters and .
on chrome it appears that core developers that are likely to cause larger knowledge losses are less likely to leave.
comparing the actual losses to the unexpected losses we see that the most extreme simulated es for avaya and chrome is and les respectively.
this represents a .
and .
times larger loss than the expected actual loss.
compared with the actual es of and the largest simulated es is between .
and .
times larger for avayaand chrome.
the simulations clearly show that the losses could have been much worse than they actually were.
this indicates that the more les a developer owns that are not co owned by others the more that developer has invested in the project and the less likely he or she is to leave.
future work investigating this relationship is necessary.
.
disaster scenario simulation recent works studying turnover have quanti ed disaster loss scenarios through the truck factor the number of developers that must leave e.g.
get hit by a truck or bus before the project becomes unsustainable .
however the truck factor provides only the impact of the worst case loss not its likelihood.
risk analysis has two aspects the impact of a loss and the probability that the loss will occur so we simulate disaster scenarios and illustrate how likely they are to actually occur.
to calculate the truck factor one must consider the number of les that are abandoned when a group of size gdevelopers leave.
for a team of ndevelopers this involves n g calculations.
this is infeasible on large projects and even after adding a stopping condition to the truck factor algorithm we were only able to calculate up to g on chrome .
previous studies of the truck factor have examined small projects .
to calculate the truck factor for a large projects we use a monte carlo simulation.
it not only provides an approximation of the worst possible case but also provides estimates of the likelihood for any particular amount of loss that occurs in the simulation.
we follow these steps .we use the knowledge distribution of the most recent quarter .we vary the group size g of developers who leave from to people .we select groups of developers to leave at random rnd g .
we do runs for each group size.
.using the actual losses in terms of les and developers and the historically simulated losses we determine the likelihood of each disaster scenario to make our results easier to interpret we have added two lines to our disaster scenario simulations in figures and .
the horizontal line represent the historically simulated es.
the vertical line represents the maximum number of developers we would expect to lose per quarter of the time.1we have limited the group size on the x axis to developers because as we will see later losses even at this level are highly unlikely.
since chrome is open source and has many transient developers who contribute little but exaggerate the number leavers we only consider core developers.
for avaya we consider all developers as they are paid to contribute to the project.
risk based on historical developer losses the gures show that per quarter losses above developers and core developers have less than a chance of occurring on avaya and chrome which means in terms of les that 1we calculate developer loss using kar 99on the historical number of developers who leave.
quartersnumber of files abandoned es kar sim ulation mean actual loss figure historical simulation for avaya quartersnumber of files abandoned es kar sim ulation mean actual loss figure historical simulation for chrome number of leaversknowledge loss as abandoned files figure truck factor simulation avaya number of leaversknowledge loss as abandoned files figure truck factor simulation core developers on chrome each gure contains a con dence interval the bounded vertical lines and es the triangle for the disaster simulation.
losses to the right of the additional vertical line have a probability of occurring less than of the time.
the horizontal line represents the simulated historical es le loss.
the range of con dence intervals that it crosscuts indicates the likelihood of developer losses should be planned for.
1011contingencies for a disaster es of and les respectively should be planned.
although we can simulate what would happen with much larger losses of developers i.e.the truck factor these catastrophic losses are usually uncontrollable by developers and project managers.
for example such catastrophes could be represented by outsourcing of an entire project or of google removing funding for chrome.
in contrast banks usually hold reserves for losses that have a probability of occurrence of at least .
if we use the same threshold chrome should ensure that they can deal with losses of or fewer core developers in a quarter and avaya should ensure that they can deal with losses of or fewer developers.
risk based on simulated historical losses the disadvantage of the previous approach is that we use historical developer losses which may underestimate the risk of unseen events.
another approach would be to use the simulated historical le losses that are based on the knowledge distribution to give a range of the number of developers who may have to be replaced.
for chrome in figure the horizontal line represents the historically simulated es.
where the line intersects the con dence interval we can say that a loss of size es will occur less than of the time for core group loss of or fewer developers.
the same loss would occur at least of the time for a loss of or more developers.
as a result provisions in a loss plan for a disaster loss of at least core developers should be made.
losses of up to developers may happen even though as we have seen historically a loss above developers is very unlikely.
the corresponding disaster loss con dence interval for avaya ranges from to developers however losses above developers are unlikely see figure .
as a nal discussion point in this section we again caution against the use of loss percentages.
for example torchiano et al.
suggest that a good truck factor threshold is the number of developers that would be necessary for of the les to be abandoned.
on the largest project that they studied there were developers and if left of the project would be abandoned the likelihood of such as loss was not calculated .
using this percentage on a project like chrome we nd that a minimum of developers must leave the project for of the project to be abandoned.
for avaya to have of its system abandoned the project would need to lose developers.
on large projects this abandonment threshold could be renamed airplane factor reminding managers that they should not put all their core developers on the same plane.
.
successors rq3 can we mitigate the impact of turnover by suggesting the developer who should take over an abandoned le?
in the previous section we have quanti ed the size of loss a project can expect to have with a certain likelihood.
this quanti cation allows teams to plan and prepare appropriately for turnover.
in this section we focus on providing information and suggestions that may help to mitigate developer turnover.
speci cally we look at the level of expertise of actual successors and propose a simple technique to nd potential successors.
finally we determine how much succes2the es for chrome is smaller than in the previous section because we only consider core developers in the disaster scenariosors reduce the risk of turnover by calculating the reductions in the loss distribution if we adjust for the presence of such backup experts who can immediately step in when a developer leaves a project.
some degree of turnover is inevitable and when it happens a development team can either hire a new developer or assign an existing developer to the abandoned les.
to understand which of these options teams choose in practice we ask how much experience does the developer who takes over maintenance have?
there is a large literature on mentoring and integrating new developers into software projects.
for example zhou and mockus examined the impact of development environment on new developers .
bird et al.
looked at the survival rate of new developers.
zhou and mockus examined the amount of time it takes a developer to become productive.
mockus suggested mentors for developers based on past work and canfora et al.
suggested mentors based on the email communication network.
adding a new developer seems an obvious solution to le abandonment.
however on the projects we studied the experts adopted the majority of abandoned les.
in figure we can see that for avaya of developers who take over the maintenance of a le have at least one year and often many more years of experience.
the corresponding number for chrome is and only of les are adopted by newcommers in their rst quarter on the project.
our ndings are consistent with zhou and mockus s developer learning curve.
they nd that although the number of tasks a new developer takes on plateaus at three to months when the centrality i.e.how many les are included in a task and di culty are accounted for developer productivity continues to increase over the entire measurement period of three years.
in our study we see that experienced developers tend to be the ones taking over the maintenance burden of abandoned les.
determining the type of les that newcomers tend to take on would be interesting future work.
.
possible successors how many possible successors are there?
since expert developers tend to take over the maintenance of an abandoned le we want to determine which developer has the most related expertise.
in this work we develop a simple preliminary succession measure.
the measure is based on the intuitive idea that if le a has changed with le b and le a becomes abandoned then the developer who works on le b will likely know something about the functionality of le a. our potential successor measure incorporates the commonly used measures of developer experience and co changes among les .
the successor measure involves calculating the developer to le matrix dev file based on the number of times a developer has changed a le.
we then calculate the le to abandoned le matrix file abandondedfile based on the les that have co changed with each abandoned le.
we multiply the dev file matrix with the file abandondedfile matrix and are left with the dev abandondedfile matrix.
since there are no developers who have changed the abandoned le left on the project the dev abandondedfile matrix represents the number of times each developer has changed a le that has co changed with the abandoned le.
we rank possible successors based by the number of les that they have changed that have co changed with the abandoned le.
avaya1 chrome1 successors experience in y ears log first successor all successorsfigure experience of actual successors avaya1 chrome1 number of successors log figure number of potential successors for an abandoned le the measure can also be seen as incorporating the rst matrix multiplication in cataldo et al.
s coordination requirements measure.
we apply the le matrix multiplication only to abandoned les.
on large projects like chrome it can become very computationally expensive to perform these matrix multiplications.
we eliminated commits that contained over les as hindle and german showed that these commits are misleading because they often represent uninteresting changes such as changing the copyright for all les in the system.
the developer making this massive change is unlikely to understand all the relationships between these les.
we implemented a database approach to multiply matrices and only include those les which co changed with abandoned les making it possible to perform the multiplications on large projects.
the number of les that have at least one potential successor is for avaya and for chrome.
in figure we see the median number of potential successor for abandoned les on the avaya project is and for chrome.
although many les have no successors the distribution is skewed towards higher numbers of potential successors.
at the 75th percentile avaya les have and chrome les have potential successors.
the large number of successors for chrome indicate that some les co change with many other les.
we can conclude that on both projects there is a reasonably good distribution of knowledge because there are a large number of developers who are potential successors for abandoned les.
suggesting hundreds of potential successors may not be helpful so in the next section we use this measure to suggest the top ve successors ranked by the number of les they co changed with the abandoned le.
we evaluate how often our suggested successors modify the abandoned le in the future.
.
suggesting successors can we mitigate the impact of developer turnover by suggesting potential successors?
projects faced with turnover can assign the developer with the most related expertise can hire a new developer or can assign a developer who is available at that time.
we evaluate how well each of these scenarios accurately predicts the person who performs future maintenance.
we use the measure in the previous section to rank potential expert successors by the number of les they have changed that co changed with the abandoned le in the past.
we suggest a new developer who has no co change expertise and less than months of experience on the project.
as a comparison we suggest developers chosen at random to simulate the selection of a developer who happens to be available.
for each abandoned le we suggest potential successors and a new developer who has no co change experience and less than six months of experience.
as a simple control we select available developers at random.
since there is usually only a small number of changes to an abandoned le in the future we consider a suggestion to be correct if at least one of these developers actually works on the le in the future.
suggesting only ve developers narrows the search space and times on avaya and chrome respectively.
the work that is most similar to ours is that of mockus who created a measure to nd mentors and successors for a developer who s job is being moved o shore .
much of the complexity of mockus s measures come from determining who is mentor and who is follower.
in our research this relationship is unnecessary because the le is abandoned and no current developer has modi ed the le.
furthermore mockus considers only the ownership matrix i.e.dev file while we multiply this matrix with the les that have co changed with the abandoned le.
our output suggests who should take over an abandoned le while mockus s output suggests which developer should succeed or train a new developer.
1013to increase the resiliency of the project a combination of these two approaches could be taken where developers who s departure would lead to the largest losses would train the most suitable successors.
when we suggest a successor who actually modi es the abandoned le in the future we consider our suggestion to be correct.
we do not use recall because when a change must be made to an abandoned le only one of many potential successors actually does the modi cation.
in the control case where we randomly suggest ve available developers the suggestion is correct and of the time for avaya and chrome.
in the case where we recommend an expert developer who has co changed related les the suggestion is correct and of the time for avaya and chrome.
when we recommend a new developer i.e.a developer with no co change expertise and less than months of experience on the project our suggestion is correct and of the time for avaya and chrome.
combining the new developer and the expert developer scenarios we make a correct recommendation and of the time for avaya and chrome.
the control case of a random available developer is tied to the size of the project with the smaller avaya project outperforming the larger chrome project.
our expertise measure substantially outperforms the control case.
for avaya where there are fewer new developers than chrome we can see that the expertise measure is more accurate.
the chrome project uses many new developers with of our suggestions leading to a new developer taking over maintenance.
.
successor risk mitigation our successor measure is a simple modi cation of cataldo et al.
s coordination requirement measure.
as a result we can provide a preliminary test of the conjecture that teams that have more collaboration among developers have a reduced risk of knowledge loss from turnover.
to quantify and test the truth of this statement we exclude abandoned les that we correctly predicted a successor from the loss distribution.
these les were not at risk to abandonment because even when the owning developer left there was a successor who had related knowledge on the project who could perform maintenance tasks.
the successor loss distribution shows a reduction in the size of es by and for avaya and chrome compared to the actual loss distribution see figure and in section .
the corresponding reduction in expect loss is and .
for the median loss the reduction is and .
although the unexpected loss sees a moderate reduction in size the median loss sees a substantial reduction.
we suspect that the reason why the improvement is less pronounced in es is large losses occur because a developer hoards a le and does not have any potential successors when he or she leaves.
our preliminary results suggest that reducing the amount of hording can drastically reduce the risk of loss as evident in the di erence between es and median loss.
this result is promising for future work because a simple successor measure based on co changed les can reduce risk of turnover when there are potential successors.
future work is necessary to propose advanced successor suggestion algorithms and to provide managers with a clear understanding of the risk reduction of discouraging hording and encouraging co development and collaboration.
this work could also include measures of how central a le is tothe project and how many many developers know each of the languages that the system is written in .
.
threats to v alidity we have examined only two large projects so it is unclear whether our ndings will generalize to other settings.
we have however introduced a risk assessment methodology that can be applied to other large projects that must keep track of large turnover risks.
we explicitly excluded small projects as they usually depend on a single or small number of developers.
in this case there is no need to quantify the risk as it is already clear that if any of these developers leave the project will fail.
this size limitation is apparent in the previous works on turnover and in particular the truck factor .
our analysis depends on accurate le ownership information.
both projects in our study were migrated from another version control system at some point in their history.
the ownership information is removed when the migration occurs.
the blame function will attribute the entire system to the developer who made the migration commit.
since the attribution is incorrect on these lines of code we exclude them from our analysis.
we also begin our analysis two years after a migration to ensure that we are studying a substantial portion of the codebase.
we consider a le to be abandoned when more than of the lines in the le have no owner.
other works in code ownership have used similar percentages such as bird et al.
.
previous works on developer turnover have considered a le to be abandoned only when all lines are abandoned .
on oss projects we feel that this is a too liberal de nition of ownership as many minor contributors have contributed a few lines to a le but have much less knowledge than a core developer who may have contributed hundreds of lines to the same le.
compared to these previous works our work is more conservative i.e.our loss may be larger which is appropriate when accessing uncommon events like large unexpected losses.
.
conclusions the tight relationship between the author and the authored source code makes software development susceptible to knowledge loss when authors leave the project and abandon their code.
the newcomers who replace them tend to be less productive and more prone to making errors modifying an unfamiliar codebase.
this in conjunction with modern business practices that do not invest in worker tenure and globalization with its tendency to move work to low cost locations result in an environment where developer turnover is so high that it may pose substantial risks for project survival .
risks in software projects are often di cult to quantify and the impact and probability of the risks are left for developers to estimate.
for example a common technique is to give each project risk a ranking on a ten point scale from unlikely to very likely .
in contrast to these rough estimates in this work we have adapted the nancial risk management measures value at risk to a developer turnover context knowledge at risk and quanti ed the risk from turnover through the historical knowledge loss distribution.
we found large unexpected losses to be .
and .
times larger than the expected past losses for avaya and chrome respectively.
1014a historical simulation based on the loss distribution and the number of leaving developers discovered that the losses could be even larger with simulated large losses being .
and .
times larger than the actual expected loss for avaya and chrome respectively.
we ran a monte carlo simulation to examine the likelihood of disaster or truck factor scenarios.
we found that given an unexpectedly large loss it may be necessary to replace from to core developers for chrome and from to developers for avaya.
however the extreme losses suggested by the truck factor simulations were unrealistically high with a likelihood of occurrence of less than .
for example the threshold suggested by torchiano et al.
would require the departure of more than chrome developers within a single quarter.
this truck factor threshold would need to be renamed the airplane factor on large projects.
by modifying cataldo et al.
s coordination requirements matrix we are able to predict the developer with the most related expertise as a successor.
this simple preliminary approach allowed us to correctly predict the successor who would perform maintenance and percent of the time for avaya and chrome.
recalculating the loss distribution to include these successors as co owners we found that having readily available successors on a project reduces the risk of expected loss from turnover by and for chrome and avaya.
obtaining a detailed turnover risk pro le is a rst step in increasing the understanding of knowledge loss risk.
the identi cation of the parts of the code that are most vulnerable to knowledge loss could help newcomers to prioritize their contributions and help mentors with successor training.
it could lead to new approaches that increase the resilience of a project against knowledge losses.
the proposed a ordances created by the ability to objectively and easily identify developers and code that pose high risk can help projects and contributors take actions improving the chances of project survival even in cases of rare adverse events.
.