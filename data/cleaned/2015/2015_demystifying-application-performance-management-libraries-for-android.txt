demystifying application performance management libraries for android y utian tang1 xian zhan1 hao zhou1 xiapu luo1 zhou xu2 y ajin zhou3and qiben y an4 1department of computing the hong kong polytechnic university 2department of computer science and technology wuhan university 3department of computer science and technology zhejiang university 4computer science and engineering michigan state university corresponding author csxluo comp.polyu.edu.hk abstract since the performance issues of apps can influence users experience developers leverage application performance management apm tools to locate the potential performance bottleneck of their apps.
unfortunately most developers do not understand how apms monitor their apps during the runtime and whether these apms have any limitations.
in this paper we demystify apms by inspecting widely used apms that target on android apps.
we first report how these apms implement key functions as well as their limitations.
then we conduct a large scale empirical study on android apps from google play to explore the usage of apms.
this study has some interesting observations about existing apms for android including some apms still use deprecated permissions and approaches so that they may not always work properly some app developers use apms to collect users privacy information.
index t erms application performance management library android empirical study i. i ntroduction android a major mobile operating system has shown its dominance in many mobile computing landscapes such as tablets smartphones as well as vehicle systems.
since the performance issues of apps can influence users experience more and more developers adopt application performance management apm tools to monitor and detect potential problems in their apps .
apms have been used in many applications such as cloud applications web applications and mobile apps.
they can help developers monitor and detect potential performance issues in applications .
unfortunately developers may lack deep understanding of the functionalities of apms as most of them are close sourced.
moreover apms may be used intentionally or unintentionally to collect users private information.
for example most apms allow developers to log customized information in apps which is called as leaving a breadcrumb.
demystifying the design of apms and exploring the usage practices of apms can benefit all stakeholders including apm vendors app developers and app users.
for apm vendors the limitations we found in existing apm libraries can help them improve their products.
for app developers the implementation approaches of common functions as well as their limitations we reported can help them have a better understanding of apm libraries.
for app users theprivacy leaks via apms we discovered from apps can raise their awareness of this issue.
motivation.
existing studies on apms mainly explain how to use the data collected by apms to diagnose or locate the problems in a program .
for instance ahmed et al.
discussed whether apms can detect the performance regressions for web applications e.g.
excessive memory usage high cpu utilization and inefficient database queries through an empirical study on three commercial apms and one opensource apm.
trubiani et al.
proposed an approach to detect performance anti patterns in load testing with kieker apm.
heger et al.
reported the workflow of an apm.
unfortunately they neither conduct a systematic analysis on the functionalities of apms nor reveal the implementation details of apms.
as a result developers may only have a vague idea about these apms.
to fill the gap we demystify the major functionalities of android oriented apms and discuss their limitations.
contribution.
the contributions of this paper are as follows to the best of our knowledge this is the first systematic study on popular apms for android.
we demystify major functionalities common in apms and discuss their limitations.
we conduct a large scale empirical study on android apps from google play to explore how apms are used in apps.
we find that apps can collect sensitive data from users through apms we release our experimental dataset results and other supporting materials .
ii.
d emystifying apm s in this section we describe how the key features common in apms are implemented as well as their limitations.
a. apms under examination criteria for selecting android apms.
we define the following criteria for selecting candidate apms the apm can be used to monitor android apps the apm must support key functions including capturing crashes network diagnosis capturing android not respond anr errors performing time on page top analysis 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
logging tracking viewing memory usage cpu utilization and time consumed.
we manually inspect apms based on our selecting criteria and select apms that satisfy our conditions.
the entire list of selected apms can be found in .
b. key functions in apm capturing crashes.
when a crash occurs an apm captures the uncaught exception and records the execution trace which can be used by developers to learn how the exception is triggered.
if an exception is not captured by any try catch finally blocks it is reported as an uncaught exception which causes the crash of an app.
all selected apms capture such crashes by registering an uncaught exception handler usingthread.setdefaultuncaughtexceptionhandler a customized instance of thread.uncaughtexceptionhandler t o the main thread.
when an uncaught exception occurs the uncaught exception handler can capture the exception.
a limitation in this approach is that using setdefaultuncaughtexceptionhandler can update the uncaughtexceptionhandler with the android framework.
if an app uses two apms only the one last initialized can capture uncaughted exceptions as it overrides the default uncaughtexceptionhandler.
as a result only one apm can capture the crash.
network diagnosis.
apms can be used to diagnose the network bottleneck and monitor network performance.
in general there are two options socket based solution and aspect oriented programming aop based solution.
socket connection monitoring.
apms can track the network requests by monitoring the socket in use.
specifically it can be realized by implementing the socketimplfactory interface and then setting the customized socketimplfactory as the default.
the information about the ip address and port of the target server can be obtained through reflection.
using aop for interception fig.
workflow of aspectj in apm fig.
the structure of a pointcut in aop another method for monitoring and measuring uri requests is using aop .
for example aspectj is used to implement !
!
!
!
!
!
!
!
!
fig.
http requests interception based on aop aop in apms .
the workflow of aspectj in an apm is shown in fig.
.
when a developer builds an app with gradle the apm can hook the transformation process from classes to a dex file by inheriting the transform class .
then the aspectj weaver injects the customized code into the original classes .
aspectj allows developers to use pointcut to implement code injection dynamically.
as shown in fig.
a pointcut declaration contains two elements a method signature comprising the name of the method and method parameters and a pointcut expression determines the method executions to track.
as the example shown in fig.
the pointcut designator call is used to match all method executions whose method signatures are defined in the pointcut expression.
the pointcut designator target can intercept all join points execution of methods .
consequently with all these pointcut designators apms can capture network requests at runtime.
the limitation in the apms with aop based interception is that it relies on the class transform which only supports the transformation from classes todex file with gradle build.
therefore it can only be used in apps built with gradle.
if an app is not built with gradle aop based interception cannot work as expected.
analyzing android not response anr error.
application not responding anr error is another typical error that frequently occurs in apps.
when a user interface ui thread of an app is blocked for a long time the anr error will be triggered.
apms leverage the following approaches to capture the anr errors solution .
apms can implement a watchdog to detect anrs.
the watchdog is a thread which can check the status of main thread in a periodic way.
if the main thread has been frozen for more than a threshold the watchdog will report an anr error.
solution .
as it is known that android is a message driven system system events are scheduled and appended to the message queue by the main thread.
the main thread is also named as the looper thread which is responsible for looping message queue and handling messages in the message queue continuously.
when the looper is blocked anr error android outputs the anr error into a certain trace file data anr traces.txt .
apms can capture anr errors by overriding the logger with the following api looper.getmainlooper .setmessagelogging printer authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
printer because once the anr occurs android records the anr error with default printer and writes to the trace file.
more precisely apms override the printer to capture the anr errors.
compared with solution solution has two defects the watchdog thread has to keep checking the main thread to capture the anr error and it is not easy to set the threshold.
a small value can introduce performance overhead as it frequently checks the main thread.
not to mention that a large threshold can make the watchdog fail to report anr timely.
time on page top analysis.
the time on page analysis aims at computing the time spent during ui display transitions.
in android once choreographer component receives an event i.e.
vertical synchronization from the display system it schedules the rendering work for the next frame .
the callback method doframe is automatically invoked by android when android starts rendering the next frame.
apms apply choreographer.framecallback.doframe to monitor ui display transitions.
the time spent during ui display transitions can be recorded by apms.
the limitation of this top analysis is that choreographer is introduced since api .
therefore it cannot be used for apps using old android framework apis.
logging and tracking.
developers can employ the logging functions provided by apms to collect runtime information for debugging or understanding users execution traces during the runtime.
the information recorded with the built in logging function in apm will be sent back to the server.
similarly developers can also exploit apms to track an event.
developers often use such a api to collect users behaviors such as preferences and execution paths.
memory usage.
collecting memory usage is useful to diagnose the potential memory leakage in an app.
in general there are three approaches for collecting memory usage at runtime using the android api activitymanager.memoryinfo reading the system file proc meminfo and invoking the android api activitymanager.getprocessmemoryinfo .
the method and can provide memory usage of the app.
whereas method allows the inspection of the memory usage of all running processes.
cpu utilization.
to capture the cpu utilization apms obtain the cpu usage by inspecting system files.
these system files include proc cpuinfo proc pid stat proc stat and sys devices system cpu cpu0 .
time consuming.
to compute the time consumed by a code fragment apms mainly use two approaches currenttimemillis and timeunit.millsecond .
both functions are defined in java sdk.
we notice a compatibility defect in the existing apms.
that is the file proc stat cannot be visited since android .
api .
apms cannot collect cpu usage of all active processes with this approach.iii.
e mpirical study we guide our empirical study by answering the following research questions rqs .
rq1.
how prevalent are apms in android apps?
motivation.
we setup this rq to reveal the usage situation of apms that are adopted by android apps fig.
apm usage by app category results.
we randomly select apps from google play.
the size of apps ranges from 100kb to .2gb.
these apps come from categories.
note that we merge all subcategories of game into one.
we find that there are apps that use apms.
the details of these apps categories can be found in fig.
.
from the diagram we can see that developers usually use apms in entertainment and lifestyle apps.
by contrast developers seldom choose apms if apps belongs to lib demo and book reference .
rq2.
will apps collect sensitive data using apms?
motivation.
as apms allow developers to log and collect values of variables at runtime for this rq we aim at checking whether sensitive data will leak through apms.
methodology.
we leverage flowdroid to detect the privacy leaks from sensitive data a.k.a source to statements sending the data outside the application or device a.k.a sink .
we use the sensitive apis defined in existing works as source e.g.
getlatitude getsimserialnumber .
we select the apms logging apis as sinks.
we manually verify that these apis can send the data to apm servers.
to be exact for an apm api we design a demo and log messages with the api.
if messages logged by this api can be received by the apm server we consider api as a sink.
we consider a path from a source to a sink as a leak.
results.
as a result we find apps out of apps collect sensitive data from users with apms.
in total leaks are found in all these apps.
the top ranked sources for these leaks are telephonymanager getdeviceid leaks android.location.locationmanager getlastknownlocation leaks org.apache.http.httpentity getentity leaks and android.location.location getlatitude leaks .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rq3.
what are the limitations in existing apm?
motivation.
in this rq we aim at discussing the limitations in apms which can assist apm vendors to improve their products.
methodology.
we care about two types of defects in apm using deprecated permissions and accessing sensitive data.
first we manually collect permissions required by these apms.
then we reverse engineer all apms to inspect insecure apis.
result.
some apms request permissions that are proven to be deprecated or unnecessary.
these permissions include read logs read phone sta te get task blue tooth system alert window and system overla y window.
specifically the permission read logs and get task are deprecated.
iv .
r ela ted work application performance monitoring.
trubiani et al.
discussed how to use the information collected by apm to diagnose the problem in applications.
ahmed et al.
studied the effectiveness of apms for measuring the runtime performance of web applications.
y ao et al.
discussed how to instrument logs in order to have better monitoring performance.
willnecker et al.
proposed an approach to model the performance of javaee applications.
different from these studies we focus on exploring the functionality of apms and discovering usage patterns of apm rather than discussing the way to use the data collected by apms.
network measurement.
since the android framework provides convenient interfaces for users to intercept and forward network packets many apps are designed to measure the mobile network performance .
li et al.
adopted the network round trip time nrtt as the metric to appraise the accuracy of network measurement apps.
xue et al.
conduct a systematic study of three types of factors including implementation patterns of measurement apps android architecture and network protocols to learn how these factors bias the measurement results of these apps.
measurement and monitoring for apps.
several approaches have been proposed to diagnose performance bottlenecks in apps.
appinsight instruments mobile apps by interposing event handlers to collect information on critical paths that are triggered by user transactions.
lee et al.
proposed a user interaction based mobile application profiling system which can analyze fine grained information including user interaction system behavior and power consumption to perform android app tuning.
androidperf a cross layer profiling system leverages cross layer dynamic taint analysis as well as instrumentation to obtain both the execution information and the performance information about android apps.
diagdroid adopts a dynamic instrumentation approach to capture the data related to ui interactions and diagnose ui performance of apps.
v. c onclusion since developers still use apms as black boxes we conduct the firs study to demystify apms for android.
we reveal theimplementations of key functions commons in apms and their limitations.
moreover we conduct a large scale empirical study on android apps with interesting observations e.g.
limitations and issues in existing apms .
vi.
a cknowledgement we thank the anonymous reviewers for their helpful comments.
this work is supported in part by the hong kong general research fund no.
17e 18e the fundamental research funds for the central universities no.
nsfc and the nsf grant no.
cns .