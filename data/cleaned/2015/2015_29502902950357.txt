python predictive analysis for bug detection zhaogui xu peng liuy xiangyu zhangyz and baowen xu z state key laboratory of novel software technologyydepartment of computer science nanjing university chinaypurdue university usa zgxu smail.nju.edu.cn peng74 xyzhang cs.purdue.edu bwxu nju.edu.cn abstract python is a popular dynamic language that allows quick software development.
however python program analysis engines are largely lacking.
in this paper we present a python predictive analysis.
it rst collects the trace of an execution and then encodes the trace and unexecuted branches to symbolic constraints.
symbolic variables are introduced to denote input values their dynamic types and attribute sets to reason about their variations.
solving the constraints identi es bugs and their triggering inputs.
our evaluation shows that the technique is highly e ective in analyzing real world complex programs with a lot of dynamic features and external library calls due to its sophisticated encoding design based on traces.
it identi es bugs from real world projects with new bugs.
all reported bugs are true positives.
ccs concepts software and its engineering !software testing and debugging keywords python dynamic language debugging predictive analysis .
introduction python is becoming one of the most widely used programming languages due to its exibility usability and strong library support for quick development.
according to ieee spectrum python is one of the four most popular programming languages in .
due to the prevalence of python analyzing python programs becomes as important as analyzing programs in traditional languages such as java and c. however analyzing python programs is much more di cult due to the following zcorresponding authors.reasons.
first of all python is dynamically typed.
variables have no static type declarations and may hold values of different types at runtime.
the signatures of python functions also have no type declarations for the parameters which allows the functions to accept any types of parameters.
secondly everything in python is an object.
particularly functions classes and other kinds of objects are all rst class objects that can be created and passed anywhere.
thirdly object attributes can be dynamically accessed and updated through computed names e.g.
through re ection functions getattr and setattr .
fourthly collections are pervasively used in python.
they are usually heterogeneous so that they may hold any types of values.
finally external function calls are pervasive in python programs.
existing analysis for python and other dynamic languages can be classi ed to three kinds.
static analysis e.g.
abstract interpretation and type inference analyze program statically.
they have limited e ectiveness due to the dynamic features in python.
dynamic analyses focus on the observed executions and hence cannot analyze unexecuted paths.
symbolic and concolic execution engines are developed for dynamic languages such as python javascript and ruby.
these engines explore individual paths in a program.
many of them do not support exploring other aspects of the state space such as type variations and attribute set variations that are very common in dynamic languages due to state explosion and di culties in explicitly encoding these variations.
in this paper we develop a predictive analysis engine for python programs.
predictive analysis is a kind of symbolic analysis driven by concrete executions.
it rst collects the execution trace of a passing run.
it then symbolically encodes the trace and relaxes the parts that the analyst wants to reason about by introducing symbolic variables to denote possible variations e.g.
schedules in a multi threaded program execution .
solving the constraints is equivalent to exploring the executions that have small di erences from the traced execution to nd bugs.
we call these the neighboring executions of the observed execution.
our contributions are summarized as follows.
we develop the rst predictive analysis engine for python programs.
it explores neighboring executions of an observed execution by relaxing the inputs including their types attribute sets and values.
di erent from most predictive analysis that encodes schedule variations and prohibits path changes it encodes input variations and handles the resulting state changes permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
artifact evaluated by fse including path changes.
like other predictive analysis ours is sound never reporting false positives.
we design a novel encoding scheme for python programs and execution traces.
it focuses on handling dynamic features by introducing symbolic variables to represent dynamic types and attributes and explicitly reasoning about their changes and correlations.
as part of the engine we develop a tracing infrastructure for python programs.
it features tracing not only the traditional control ow and data ow information but also the implicit dynamic properties of executed python statements such as object attributes.
we build a prototype and evaluate it on real world python programs.
we have identi ed totally real bugs and of them were never found before.
the analysis time is reasonable.
the essence of our technique.
symbolic concolic analysis explore program state space leveraging concrete and symbolic reasonings.
the entire program state space can be divided into three parts sub space that is not explored e.g.
the concretized values in concolic execution sub space implicitly explored by the solver e.g.
schedule variations in traditional predictive analysis and sub space explicitly explored by the engine not the solver e.g.
path exploration in symbolic execution .
di erent symbolic concolic analysis di er in the distribution of the three sub spaces.
for example traditional symbolic concolic execution engines e.g.
including those for dynamic languages explicitly explore individual program paths.
along each path they leverage the solver to implicitly explore variable values along the path.
explicit exploration substantially simpli es constraint encoding as only one path is encoded at a time.
state variations caused by path variations do not need to be encoded.
however identifying sophisticated exploration strategies and symbolic state checkpointing backtracking are challenging.
implicit exploration can achieve e ciency leveraging the built in demanddriven nature of constraint solving in modern solvers.
its di culties lie in the complexity of constraint encoding.
compared to existing symbolic concolic execution our technique has the following unique features that make it suitable for python.
it encodes values types attribute sets paths and their correlations so that the solver can be leveraged to perform e cient implicit exploration whereas most existing techniques explicitly explore paths and do not reason about type or attribute variations that are critical for dynamic languages.
the user provides initial passing executions to direct our system to the functionalities components in which they want to nd bugs.
for each initial execution our technique encodes its neighboring state space including paths not executed in the initial run.
in other words one request to the solver allows implicit exploration of all the executions in the neighborhood.
this completely avoids the highly demanding explicit path exploration.
modeling for the large number of external functions can be substantially mitigated by trace preprocessing section .
.
.
motivating example in this section we use a simpli ed problematic python program to motivate our approach.
fig.
shows the code snippet simpli ed from the very popular python http library requests .
the test driver function test post invokes the function post at line input url def test post url data ... post2 requests.post url data ... self.assertequal post2.status code ... other functions are omitted requests models.py def encode files files data new fields fields to key val list data or for field val infields if not hasattr val iter or isinstance val str val for vinval ifvis not none new fields.append field v encode multipart formdata new fields urllib3 filepost.py def encode multipart formdata fields body bytesio for fieldname value initer fields fields if isinstance value int data str value if isinstance value unicode writer body .write value else body.write value figure a motivating example.
encode files is an internal function called during execution whose argument data comes from the test input.
unrelated code is omitted for readability.
and checks its return value at line .
the input parameter data can be a dictionary.
suppose the input parameter data is some data .
the function call post at line invokes the function encode files lines transitively through a chain that consists of six function calls omitted for simplicity .
line converts the dictionary data into a list of pairs where each pair represents an entry of the dictionary.
the resultant list fields is .
line iterates over the list and unpacks each pair to field and val.
for the pair some data the unpacked field andval are some and data respectively.
valis wrapped as a list line if it is not iterable i.e.
without the attribute iter or is of the strtype line .
here val is wrapped as a list since it is of strtype.
lines then iterate over val form a pair with field and store the pair into the list new fields .
in this example new fields is .new fields is then passed to the function encode multipart formdata as the parameter fields .
lines iterate over fields and check the value in each pair.
if it is not of the int line or unicode line type e.g.
it is the string data in our example it is written to the body line .
the defect is at line .
the method body.write requires the parameter to implement the bu er interface.
for example the strtype implements the interface while the float type does not.
if body.write takes a oat value e.g.
.
as parameter it will crash.
our approach is able to compute the new input data some .
to trigger such a crash.
the example illustrates a number of the inherent challenges in analyzing python programs.
observe that all variables are dynamically typed such as value at line .
function parameters can also accept di erent types.
type errors are only captured by crashes.
this example is di cult for static analysis as it involves a lot of container related operations e.g.
the operations in encode files which require complex heap abstraction.
this example also im122figure system framework .
poses challenges to symbolic analysis.
for example the bug manifests in a very deep call chain.
the execution has a lot of invocations to external functions which require substantial e orts to model.
in fact the traced run for the example executes more than python statements among them there are about container operations and reection function calls.
there are also external functions calls.
in addition we cannot analyze the function encode multipart formdata in isolation.
in fact the function is also used in a library urllib3 where its use is not buggy since the library performs dynamic checks to ensure the inputs are of the proper types during the function calls.
our solution.
our technique belongs to the category of predictive analysis which starts with the trace of an existing run and predicts a new feasible run.
given the trace collected from the passing run with the input some data our analysis rst models the inputs including their values types and attribute sets as symbolic variables to denote possible input variations then it encodes the executions possibly derived from the trace into constraints next it encodes the bug nding assertions e.g.
the value is not of the type strorbytearray for line which implements the bu er interface lastly it leverages a solver to compute the input that triggers any assertion violation.
in this example we compute the input data as some .
.
the predicted run follows the same path as the observed run to reach line and executes body.write .
which leads to the crash.
our approach fully supports dynamic typing and dynamic attribute updates in python.
the readers may notice that the input contains di erent types attributes in the original run and the predicted run i.e.
some data and some .
and value at line has di erent types attributes in the two runs.
our system introduces auxiliary type attribute symbolic variables to track type attribute information explicitly and supports type attribute checks e.g.
lines and .
in contrast most existing symbolic execution engines do not reason about type attribute variations and hence have di culties nding the bug.
our approach not only encodes the current execution path as in many existing symbolic concolic execution engines but also encodes the unexecuted branches together with the path.
for example lines and were not executed in the original run but our technique encodes them with the original run so that the solver can explore these branches implicitly.
in contrast existing symbolic concolic engines follow some strategy e.g.
depth rst search to explicitly explore the unexecuted branches through many runs.
details will be discussed in section .
.
besides dynamic types and attribute sets our approach also supports other dynamic features such as re ection calls andeval leveraging the traces.
.
system framework in this section we give an overview of the system.
as shown in fig.
it consists of two components the tracing component and the constraint encoding solving component.
the tracing component takes a python program and a test input and produces a trace of the execution.
the tracing procedure consists of three steps.
first the program is run to collect all the involved modules and the string parameters of the eval function invocations which are loaded or constructed at runtime and are unknown at compile time.
this step essentially collects the complete set of executed code.
second we normalize the code collected from the modules and the eval parameters by breaking the complex statements into simple statements.
finally we run the normalized program again to collect the trace.
one prominent challenge in tracing python program execution is to handle a large number of external function calls that are implemented in other languages and have unknown sidee ects.
our tracing component also features an on they side e ect detection technique to handle external functions.
the constraint encoding solving component takes three resources as inputs namely the trace the normalized source code and the input relaxation speci cation1.
our system reports bugs and the corresponding inputs that trigger the bugs.
the constraint system consists of four subcomponents the bug predictor the constraint encoder the event slicer and the smt solver.
the bug predictor subcomponent is a controller that scans the execution trace.
during the procedure it may invoke the other three components.
when it nds a satis able solution meaning a bug it will stop evaluating further.
the constraint encoder mainly performs three actions relaxing the encodings of inputs according to the input speci cation such that the encoding describes a much larger state space than the traced execution encoding the execution trace to constraints aggressively including the unexecuted branches to the constraints whenever encountering a predicate event in the trace .
a trace slicer is used to slice events on which a speci c assertion event i.e.
the slice criterion is dependent.
we provide the constraints of the slice to an smt solver.
if it is satis able we nd a bug and its triggering input.
otherwise our tool does not nd a violation to the assertion and moves on to the next assertion.
.
tracing component similar to existing methods of predictive analysis we trace an execution based on address instructions which are more suitable for constraint encoding than bytecode instructions.
our tracing component follows three steps to collect trace.
it executes the program for the rst time and collects all the involved modules and string parameter values for the exec eval calls.
with the collected modules and string values it normalizes the source code to a simpli ed form with each line only having one simple operation.
after replacing the original modules with the normalized versions it re executes the program and in the meantime collects the execution trace.
.
code normalization the o cial releases of python have a built in tracing api sys.settrace allowing hooking the execution environment 1we put the speci cation design into our technical report for reference 123before executing each source code line through which we can perform a set of queries to the runtime environment making tracing and gathering runtime information very convenient e.g.
querying values types and attributes .
however the api only allows tracing at the level of source code line which is problematic for our purpose as one source code line may contain multiple statements and a long statement may cross multiple lines.
as a result we need to normalize the source code such that each line only contains a simple operation.
we perform the following three kinds of normalization.
linearizing nested expressions.
nested expressions are prevalent in python code which combine multiple operations together e.g.
a.b.f x .
we linearize these nested expressions into a group of simple assignments each containing one simple expression.
eliminating complex constructs.
python has very expressive syntax so that complex semantics can be represented concisely.
while it provides convenience for programmers it creates di culties for analysis.
our system transforms these advanced constructs to a small set of simple constructs.
we list several typical transformations as follows.
x f i for iinlst ifi x for iinlst ifi tmp f i x.append tmp x reduce lambda a b a b lst def v1 a b v2 a b return v2 x reduce v1 lst the rst row presents a concise method to construct a list by applying a function f to the loop index i with the transformed code on the right.
the second row illustrates how we transform a lambda expression.
transforming eval exec .our system also replaces eval exec calls with the corresponding real code collected earlier.
consider the following example.
a.py co x a exec co records ha co b ai ha co c aico x a ifco b a b a elif co c a c a else exec co the left column shows the original code that contains an exec call at line .
the middle column presents the trace records of this line in which b a and c a are the values of variable coin the two records.
the right column shows the corresponding code that our system uses to replace the call.
observe that we use branches to handle the di erent statements induced by the di erent values of co. we also reserve the original exec co in the else branch to ensure soundness.
with the transformed code we now can trace the execution of the original exec call.
.
trace generation after replacing the involved modules with the normalized ones we now re execute the program to gather the execution trace.
tracing python program execution is more challenging than tracing programs in many other languages because the execution of a python statement may have many implicit side e ects such as type changes and attribute set changes.
all these need to be explicitly captured as many bugs are related to these implicit side e ects.
next we rst introduce some notations and then illustrate the tracing rules.v2value 2type x2var 2label l2heaploc value attr a2attrset attr t typeset p type 2trace heid s v a i 2valuestore varjheaploc7!value 2typestore varjheaploc7!type 2attrsetstore value7!attrset fbaset returns the default attribute set of type fbtype bop returns the type for the computation on 1bop .
findex v returns the index of next iteration for a for loop.
figure de nitions related to tracing rules statement s z jxj x op y j basic assignments y x fj attr read y f xjvj attr write if x relop y s1elses2j cmp predicate ifisinst x t s1elses2j isinst predicate ifhasattr x f s1elses2j hasattr predicate y f a1 an jx m a1 an j callsite figure python statements fig.
presents the de nitions related to the tracing rules.
basically vrepresents an arbitrary value.
note that every value in python is essentially an object so the value here means an object arepresents an attribute set which consists of attributes trepresents all the types as well as the class hierarchy of these types 4denotes the subtype relation denotes the value store mapping a variable or a heap location to a value represents a type store mapping a variable or a heap location to a type denotes an attribute set store mapping a value to an attribute set representing the set of attributes of a value or object fbaset represents a function returning the default attribute set for a speci c type fbtype returns the type of a binary operation findex returns the index of the next iteration of a for loop.
the execution of a python program in our system is a procedure of dynamically updatingt and .
trace and events.
we model a few python statements in our presentation shown in fig.
.
some of the symbols are de ned in fig.
.
for example stands for a label that is similar to the source code line number.
observe that we model two speci c predicates the type check isinst and the attribute check hasattr .
the rest is standard.
an execution trace is a sequence of events recorded during the execution.
an event is an execution instance of a statement denoted as a tuple heid s v a iwhere eidrepresents a unique identi er sdenotes the statement v a represents the involved value type and attribute set by the execution of the statement.
note that besides the valuev we also record the type and attribute set of each execution of the statement as they may be changed.
tracing rules.
table represents the tracing rules for a set of commonly used python statements.
the rst four rules specify four typical object creation statements.
more speci cally rule class def represents the tracing of a class de nition statement which creates and initializes a new class object.
it creates a class object o1and associates it withc.
it also creates a method object o2 associated with themattribute of o1.
the attribute m is added to the attribute set of the class object o1.methodtype andclasstype are two built in types in python.
ctype andbtype are symbols generated by our system to denote the types of class c andb.
as shown in the last column the system generates two eventse1ande2wheree1represents the class object creation ande2represents the setup of the method in the class.
124rule func def speci es the rule for a function de nition.
it creates a function object and then assigns it to variable f. the corresponding trace event is straightforward.
rule list alloc represents the tracing for creating a list object.
it rst creates a list object o1assigned to yand then appends two elements to it o10 represents the rst element .
accordingly our system generates three events e1 e2ande3withe1creating the list object and e2ande3setting the elements.
rule class instant represents object creation through class instantiation.
it creates a new object o1and assigns it to y. the attribute set of o1is inherited from the object associated with the class c. rules simple assign bop assign attr read and attr write are standard.
particularly the execution of an attribute write statement may dynamically change the attribute set of the object.
rule for loop speci es the tracing for the next iteration operation of a for loop statement.
the rule only speci es the situation in which the object is a collection e.g.
list tuple .
rule if cmp ifisinst and if hasattr specify the tracing rules of three di erent kinds of branch predicates.
in rule call we record two events one for parameter passing and the other for the call itself.
.
handling external functions function calls to external libraries are prevalent in python programs.
we cannot easily trace the execution of these libraries due to the lack of source code.
however if we do not trace their execution the resulting trace is incomplete especially when these functions have side e ects on heap leading to unsoundness of our later symbolic analysis.
one way is to manually model the external functions.
however this requires tremendous e orts due to the sheer volume of these functions.
hence our strategy is to manually model the commonly used external functions.
for the others which are still in a large number we develop a technique to detect side e ects such that we handle them to avoid unsoundness.
next we focus on discussing side e ect detection.
to detect side e ects we maintain a value store varjheaploc7!value recording the current value of each variable.
the value store is only updated when the python code is executed.
in other words it is not updated by execution of external functions.
when a variable is used in the python code we compare the value from the store with the observed value from store .
if the two are di erent there must be side e ects by some external function call s .
x.f y extfunc x z x.fve f vr f here vr if ve vr !
hz x f i else !
hx f ve ve i !
hz ve ve i !
line of the left column shows an unmodeled external function call which has side e ects on x. when tracing the execution of line we use the rule shown in the right column.
we rst get the current value veof the heap location pointed to by x ffrom the execution environment which is updated by both the python code and the external function and then query the recorded value of x ffrom which is only updated by python code.
if veis equal to we treat it as an attribute read event.
otherwise we concretize both the values of x fandzdue to the invisible side e ects that we cannot model which essentially under approximates thesource code trace x input y c new object o1 if isinstance x int y.f s else y.f z y.f w z.lower hx int aint i hy o1 o1 c ao1 i hif isinst x int i hy f s s str astr i hz y f s str astr i hw z lower i figure an example illustrating the challenges program state by xing the input and output values of the external function.
on the other hand it ensures soundness.
.
constraint encoding our technique is essentially a kind of predictive analysis .
as mentioned in section predictive analysis is based on the observed execution traces and can easily analyze the very long executions similar to the observed traces.
leveraging traces also allows mitigating the problems caused by dynamic features.
while most existing predictive analyses explore di erent schedules of a concurrent execution and prohibit path changes our technique explores the program state space caused by input variations which may cause differences of execution paths and heap states.
such possible di erences are encoded as constraints and an smt solver is leveraged to explore the encoded state space to nd bugs.
our technique is sound meaning that it does not produce false positives2.
now we introduce the main challenges in encoding python programs for predictive analysis.
dynamic typing in python makes the type of a variable path sensitive which means the same variable at the same program point may have di erent types depending on the execution path.
however symbolic variables in constraints are statically typed.
existing static encoding techniques often project a program variable in its ssa form to a symbolic variable in the constraint system.
such a method is no longer applicable.
note that the ssa form does not help in our context because even though the ssa form can express a variable having di erent types at di erent locations by introducing multiple variables for each de nition location it cannot handle that a variable may have di erent types even at the same location.
note that the problem does not exist for symbolic execution or concolic execution as these techniques encode one path at a time.
besides encoding the value of a variable like in most existing work we have to explicitly encode the type and the attribute set of a variable or object in order to reason about such features.
some bugs can only be triggered when the execution goes through a path di erent from the trace.
therefore to predict such kind of bugs we should also include the unexecuted branches into the constraint model.
example.
we use an example in fig.
to illustrate the above challenges.
the left column is the code snippet.
line represents the initialization of xwhich may accept a value of various types e.g.
int and string .
line creates a new object of class c denoted as o1.
line is a type check predicate.
if xis of the int type it writes a string s to the attribute f of o1.
otherwise it writes the integer .
note that the initial attribute set of o1does not contain the attribute f so the execution will dynamically add it to the attribute set of o1.
line reads the attribute and 2we put the proof in our technical report site pypredictor 125table tracing rules for typical statements rule statement execution states events eidand omitted class def class c b def m self x self.x x !
c7!o1 newobject o1 m7!o2 newobject !
c7!classtype o1 m7!methodtype !
o17!fbaset classtype f m g o27!fbaset methodtype t!t i e2 hc m o2 o2 i !
e1 e2 func def def f x return x !
!
!
!
hf o1 o1 i list alloc y !
!
!
e1 hy o1 o1 list fbaset list i e2 hy0 int fbaset int i e3 hy1 int fbaset int i !
e1 e2 e3 class instant y c c is a class !
!
!
!
hy o1 o1 ctype c i simple assign y x !
!
!
hy x y y y i bop assign z x bop y !
bop !
bop !
!
hz x bop y i attr read y x.f y getattr x f !
f !
f !
hy x f i attr write y.f x setattr y f x !
f7!
!
f7!
!
!
!
hy f x i for loop for xiny...i findex !
i !
i !
hx yi i if cmp if x relop y ... r relop !
hrelop x y r bool fbaset bool i if isinst if isinstance x list ...r 4list !
hisinst x list r bool fbaset bool i if hasattr if hasattr x f ... r f !
hhasattr x f r bool fbaset bool i call y f a !
!
b is the formal parameter e1 hb a i e2 hy f a f functype fbaset functype i !
e1 e2 assigns it to z. line calls a method lower ofz.
the bug will occur when the else branch is taken because the value of zis of the int type and does not have the lower method.
however the bug does not manifest itself when the true branch is executed.
from the example we observe that zat line may have di erent types depending on the path and ssa cannot address the problem.
to reason about the predicate at line and the bug at line we need to explicitly encode the types and attribute sets.
assuming the trace is along the true branch to expose the bug we also need to encode the else branch which may not be taken in the observed execution.
.
encoding scheme next we explain our encoding scheme from di erent aspects.
using multiple symbolic variables to denote the value of a python variable.
we use multiple symbolic variables of di erent types to represent the value of a python variable of di erent types.
more speci cally given a python variable x we use a set of symbolic variables in the form of to denote its value of type .
the superscript indicates this is a symbolic variable for value .
for example if xcan be an integer or a string we use two symbolic variables int x and str x to denote its value.
for a statement sinvolvingx both symbolic variables are updated to encode the possible behavior of swhenxhas di erent types.
explicitly reasoning about types.
to encode the dynamic typing behavior we introduce a new symbolic variable x to represent the type of the variable x. the superscript indicates this is a variable for type.
we support equivalence and non equivalence checking and sub typing on the values of these variables.
we encode the subtype relation as a partial order between types which is supported by the solver.
explicitly reasoning about attributes .
we introduce symbolic variable obj to represent the attribute set of anobjectobj.
note that the attribute sets are associated with objects instead of variables following the python memory model.
in particular if xandyare aliases through the assignment y x then the statement x f adds the attribute f to the object that both xandycan reference.
we represent the attribute set as a set in the constraint system and support the membership operation.
encoding rules.
before encoding we rst transform the trace into its single static assignment ssa form so that every variable is de ned exactly once.
we use xito denote the de nition instance of xat trace entry i. we also extend the trace with statements from unexecuted branches see section .
.
as such functions are also introduced to integrate de nitions from two branches of a conditional statement at the join point.
table shows the encoding rules for the typical events.
rule speci es the encoding for the assignment with a constant.
the symbolic value variable zi is asserted to the value v. the symbolic type variable is asserted to type and the object created to represent the value of zi which is acquired by a function obj zi is asserted to have the attribute set a. rule speci es the encoding for a simple assignment.
in the encoding since we introduce a set of symbolic variables of di erent types to denote the value of a program variable of various types for each type we assert the equivalence of the corresponding symbolic value of ziandxj.
this rule does not a ect the attribute set which is associated with the object instead of the variable.
rule encodes the addition operation.
the basic idea is that for each type having the addition operation we encode its behavior.
for simplicity we assume the solver only supports additions for int and string types.
as such the rst two clauses assert integer addition and string concatenation respectively.
the third one encodes additions that are not supported by the solver such that we cannot reason 126table encoding rules.
the events are in the ssa form with the superscript of a variable xrepresenting the id of the event where x is most recently de ned.
obj x represents the object created for variable x. x x and x represent the symbolic variables denoting value type and attribute set for a program variable value x. each type means each possible type of x.type o denotes the type of object o. ssa formed event ei encoded symbolic constraints hzi v v a i zi v zi obj zi a hzi xj i v each type zi xj zi xj hzi xj yk v a iif xj int yk int int zi int xj int yk zi int obj zi aint elif xj str yk str str zi concat str xj str yk zi str obj zi astr else zi v zi obj zi a type obj xj xj obj xj type obj yk yk obj yk hif isinst xj i xj zi ek zt zf ek each type zi zt zi zt ek each type zi zf zi zf hyi xj f iv o2pts xj type o xj o v each type yi o fk yi o fk hyj f xk iv o2pts yj type o yj o each type o fi xk o fi xk o o f f g type o yj o each type o fi o fp o fi o fp o o hif hasattr xj f iw o2pts xj type o xj o f o about their value variations.
we assert the value type attribute set of zito the observed ones.
more importantly we also need to assert the operands xjandykmust hold their observed values to ensure soundness.
rule encodes a type check predicate.
it simply asserts the type of the variable is a subclass of the intended type .
rule speci es the encoding for the function that joins the updates of a variable in the two branches of a predicate ziis equal toztif the predicate ekholds and is equal to zf otherwise where ztandzfare the most recent versions of z inside the branches.
in the encoding all the symbolic value and type variables are updated according to the encoding ofek denoted as ek .
the encoding of object attribute sets is also handled path sensitively similar to functions for variables.
in other words we also join the attribute sets of an object in a path sensitive fashion at a merge point of branches.
details are elided.
rule encodes an object attribute read.
the encoding relies on a pre computed points to set pts xj representing the set of objects that may be pointed to by xj.
we use the anderson algorithm to compute the may points to set on the trace extended with the un executed branches .
intuitively our extended trace can be considered as a program with loop unrolled and dynamic features uncovered.
in the encoding for the object oin the points to set that xj actually points to we assert the equivalence of the values of o fkandyiand the equivalence of their types.
note that the superscript kdenotes the most recent de nition point of o f. function type o represents the type of object o. rule encodes an object attribute write.
for the object opointed to by yj we assert the equivalence of both the values and types of o fiandxk.
besides we assert the new attribute set is the union of the old attribute set and the f .
if the object is not pointed to by yj we assert the value and type and the attribute set of the base object stay the same.
note that the superscript iandpdenote the current and the most recent de nition points of the object attribute respectively.
we use o 0to denote a new de ned version of the symbolic attribute set of o. rule encodes an attribute check.
for any object oin the points to set of xj if the object referred to by xjequals o the attribute f must be in the attribute set of o.handling solver unsupported types.
python supports many more types compared to those supported by the solver.
in our encoding rules we do not specify the details of handling solver unsupported types for space reason.
in fact we treat the values of solver unsupported types as objects denoted by ids.
we only reason about equivalence and nonequivalence of object ids.
this is consistent with existing work of predictive analysis .
.
unexecuted path relaxation to allow reasoning about possible path changes induced by input variations we need to include the unexecuted branches to our constraint system.
the basic idea is to enhance the observed trace to aggressively include statements in unexecuted branches as long as those statements can be fully resolved by static analysis.
we preclude the unresolved branches by asserting the branch outcome as the observed one.
this ensures the soundness of our analysis although it limits the coverage.
next we explain how we determine if an unexecuted statement can be resolved.
assignments.
constant assignments x vcan always be resolved and encoded.
for a simple assignment y x our analysis rst looks for the most recent de nition of x. if it may be de ned in an unresolved branch which was hence not encoded we consider the variable xunresolved.
as a result the assignment and the whole branch are also unresolved.
assignments of binary operations like z x yare handled similarly.
conditionals and loops.
for a conditional statement ifx y s1elses2inside an unexecuted branch we rst try to resolvexandyand thens1ands2.
if any of these cannot be resolved the conditional is not resolved except the following case.
ifxandycan be resolved and one of the branches can be resolved say s1.
we encode s1and assert the branch outcome to be true.
for a loop statement in an unexecuted branch we require the loop bound can be statically resolved as constant.
calls.
for a function call in an unexecuted branch we must ensure it is not a recursive call or an unmodeled external function.
if this is satis ed and the callee can be resolved we say the invocation can be resolved.
if a call statement has multiple possible callees and only some of them can be 127source code trace instruction x y ifa x y ifb y x for iiny t i z y10 x1 y2 ifa0 x4 y2 x5 a x1 x4 b z8 y2 figure unexecuted path relaxation.
resolved we assert the call target falls into the set that can be resolved.
we do not handle try except statements.
if we encounter any such statements in an unexecuted branch the branch is considered unresolved.
example.
consider the example in fig.
.
the left column is the source code and the shaded statements are executed by the observed run.
lines and are not executed.
the right column shows the intermediate ssa form of the trace after we extend it with the unexecuted branches.
note that we are able to resolve and add line as ycan be resolved.
as a result a statement is added at line .
in contrast the branch consisting of lines cannot be resolved as we cannot statically resolve the loop bound yat line .
as such we assert the branch outcome of line to be false.
.
constraint solving for bug detection after the extended trace is fully encoded we further add assertions for bug detection before the constraints are passed to the solver.
while the user can come up various customized bug detection assertions.
in our current system we mainly focus on two kinds of assertions.
subtype assertion.
subtype assertion is used to detect type errors.
more speci cally we assert if the type of a variable may fall out of an acceptable range.
for example suppose the acceptable types of variable xincludeintor str.
we assert x 4int x 4str .
for operations involving multiple variables we check the type combinations of these variables.
for example for a binary operation z x y the python interpreter does not allow the addition of a string and a number.
therefore we assert xis an integer andyis string or vice versa.
attribute assertion.
attribute assertion is used to check if a non existent attribute may be read.
more speci cally for an attribute read y x f let points to set pts x fobj1 objng we check if there exists objt2pts x that satis es there is a feasible path making x objtsatisable and objtdoes not contain the attribute f .
we send all the constraints to the solver.
if the result is sat we nd a bug and its triggering input.
.
evaluation we have implemented a prototype in python.
the system mainly consists of a tracing infrastructure and a constraint encoding and solving component.
as mentioned in earlier sections python programs tend to use a lot of external functions and classes implemented in other languages.
we manually modeled a set of commonly used external functions by rewriting them in python.
we use z3 as the smt solver.
to improve scalability we also implement a dynamic slicer to prune unrelated trace entries for a given assertion.
we make our prototype along with the evaluation environment publically available at .our evaluation aims to address the following questions rq1 how e ective is our approach in detecting potential bugs for real world python projects?
rq2 how e cient is our approach?
can it scale to real world programs and executions?
rq3 how applicable is it to use the test cases provided in the projects as the observed runs?
can our approach detect more bugs by increasing test coverage?
to answer the above research questions we apply our approach to a set of real world python projects as shown in table columns .
these benchmarks are mainly from github.
all of them are highly ranked in popularity and widely used in practice.
to select these benchmarks we went through the ranking of popularity and bug reports and selected those that have the highest ranking and at least one reproducable bug report.
we also considered diversity during selection.
observe that some of them are large.
the largest one has over 84k source lines of python code.
the sum of the source code lines of these projects is about 164k.
these projects fall in the following application domains which are representative for python programs requests andurllib3 very popular http libraries.
fabric and salt well known remote deployment and system administration applications.
flask bottle andweb2py widely used web application development frameworks.
tweepy boto andpraw well known web service apis.
bs4 a very popular html and xml parsing library.
our experiments were conducted on a machine with an intel i5 4210u 4gb ram ubuntu .
and python .
.
.
.
experimental results table shows the experimental results.
for each program we rst run the passing test cases provided as part of the project and then encode these traces together with unexecuted branches to nd bugs.
in table we only report the statistics for those test runs that allow us to identify bugs.
trace and constraints.
column mod presents the number of modules executed which ranges from to .
note that we have excluded some uninteresting modules such as those related to logging and multiprocessing.
columns report the number of instructions that fall into some popular categories namely attribute reads attrr attribute writes attrw predicates pred and calls.
column presents the total number of events in the trace.
observe that many of these executions are long.
the longest execution has over 70k events.
column ap presents the number of events encoded when reaching the buggy assertion point.
recall that our system adds assertions in order to nd bugs section .
.
column exte presents the number of unexecuted statements that are added to the encoding in column .
observe that our technique was able to resolve a lot of unexecuted branches allowing us to explore a large number of neighboring executions of the observed run.
column cons presents the total number of constraints when reaching the assertion of the violation which ranges from to over 135k.
detected defects rq1 .
our system is able to detect a set of bugs for these programs.
the reported bugs are all true positives.
column presents the bug issue ids if available.
the issue ids pre xed with are the new bugs that have not been reported before.
we reported these new defects to the developers through the bug tracker of github 128table statistics of experimental results a benchmarks b trace c constraints d defects e time sec name sloc mod attrr attrw pred calls events ap exte cons.
issue count tracing solving total requests .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
urllib3 .
.
.
.
.
.
fabric .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
salt .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
s22547 .
.
.
.
.
.
.
.
.
s25006 .
.
.
s25006 .
.
.
s25006 .
.
.
ask .
.
.
.
.
.
bottle .
.
.
web2py .
.
.
.
.
.
tweepy .
.
.
.
.
.
boto .
.
.
praw .
.
.
bs4 .
.
.
.
.
.
.
.
.
total orlaunchpad .
most of them have been con rmed and even xed.
id s22547 means that the root cause of the bug is very similar to that of issue .
there are three known bugs that we cannot nd the issue numbers.
instead we provide the commit records.
column presents the number of the detected defects.
note that our approach is e ective identifying defects with known and new.
analysis time rq2 .
columns present the tracing time solving time and total time respectively.
the solving time is the sum of the many queries to the solver regarding the bug identi cation assertions.
from the results we argue that the cost of our approach is reasonable.
it detects most of these defects in a few seconds to a few minutes.
the most time consuming case is issue of flask which took about minutes to process.
further inspection shows that it is due to the long execution trace.
fault detection capability versus test coverage rq3 .
the detection capability of our approach largely depends on the observed runs.
in our experiment we mainly choose the test cases along with the projects as the seed runs.
the reason is that test driven development is pervasive in programming with dynamic languages.
as such there are often many test cases along with python projects.
we randomly choose passing test cases from the testsuites of two benchmarks requests and salt which have the largest number of defects.
we then study how the accumulative number of detected bugs grows with the test coverage.
fig.
a shows the result.
note that here we measurestatement coverage.
the result reveals a close to linear relation between the two.
we hence argue that our approach can detect more defects with more test cases to achieve better coverage.
in some sense these test cases drive the execution to interesting places and our technique reasons about bugs in the neighboring executions.
fig.
b shows the accumulative analysis time of our system.
observe that the growth is steady and the total time is reasonable.
.
defect study to better understand the common patterns of defects in python programs we further examine these reported bugs and classify them into three categories as shown in table .
attribute errors.
of the detected defects cause attributeerror crashes which mean that the execution accesses a nonexistent attribute.
in python programs it is possible that an attribute is added to the object in one path but not in another path.
developers may forget the latter path and access the attribute which does not exist.
more speci cally there are such defects in requests with new defects.
consider the new issue .
preparedrequest.copy invokes the copy method of object self.
cookies which is passed from some high level api e.g.
the instantiation method of class request .
unfortunately some of these apis may not add the copy method to the attribute set.
there are attribute defects in fabric.
for instance in issue the key filename function of the network.py module checks if env.key filename is an a coverage and defects b time overhead figure bug detecting capability along with coverage instance of list type.
if not it will wrap env.key filename into a list.
later on it reads the startswith attribute of each item in the list.
our approach nds that the program will crash with an attributeerror raised when env.key filename is initialized as another iterable type object e.g.
a set .
this is because the program wraps the set object into a list and reads the startswith attribute of the set object which does not exist.
type errors.
of the detected defects cause typeerror crashes which occur when a parameter of an invalid type is passed to a built in function or when a binary operation has unmatched operands.
the type error bug in requests is shown in fig.
and discussed.
the bug insalt occurs if the parameter passed to time.sleep is not of a number type e.g.
int and oat .
unicode errors.
of the reported defects cause unicodeencodeerror orunicodedecodeerror crashes.
unicode errors are very common in python applications especially in web related applications.
the python .x interpreter implicitly casts a byte string to a unicode string during certain operations e.g.
concatenation between a byte string and a unicode string .
however such casting crashes if the input string contains non ascii characters.
speci cally we have found such bugs in requests and of them are new bugs.
in issue requests provides a set of http apis e.g.
get put that support values of di erent types for the parameters headers anddata.
both parameters allow unicode and byte strings.
the program crashes when headers contains a unicode string e.g.
headers u content type ... and data contains a byte string with non ascii characters.
this is because an internal method send output of module httplib.py concatenates them triggering the implicit cast and causing the crash.
we have also found unicode bugs in salt all of which are not reported before.
.
related work our approach belongs to the category of predictive analysis .
existing predictive analyses were originally used in concurrency program analysis such as race detection and atomicity violation detection .
they focus on changing the schedules to explore di erent executions.
di erently our approach is the rst to change inputs to explore di erent executions.
besides our approach allows the exploration of the unexecuted branches while existingtable classi cations of detected defects benchmarks attributeerror typeerror unicodeerror known new known new known new requests urllib3 fabric salt ask bottle web2py tweepy boto praw bs4 total ratio .
.
approaches do not.
our handling of the python dynamic features such as typing and attribute sets is also novel.
several tools have been developed for python in bug detection and symbolic concolic execution .
bug detection tools are mainly based on static analysis and handle defects that do not involve dynamic features.
recent advances in python symbolic concolic execution have shown good potentials.
these techniques gradually explore paths within the search space driven by a path exploration engine.
in contrast we use test cases to drive execution to interesting states and explore bugs in the neighborhood.
our state exploration is done inside the solver not by a path exploration engine.
as such we need to address some new challenges such as encoding a variable in various types handling unexecuted paths and modeling attribute set changes.
type inference for python has also been proposed.
the work is mainly based on abstract interpretation which may have di culty handling dynamic features.
a set of analyses have been proposed for other dynamic languages such as javascript ruby and php .
typedevil detects type inconsistencies through checking if a variable or eld may have multiple types in the same run.
jalangi supports concolic testing for javascript which enables detecting type inconsistencies.
rubydust dynamically infers types to report errors at method boundaries.
zheng et al.
proposed a path sensitive static analysis of php web applications for security vulnerability detection.
.
conclusion in this paper we present a python predictive analysis.
it has two steps to detect bugs in python programs.
the rst step is to collect the execution trace of a passing run.
the second is to encode the collected trace and some unexecuted branches into symbolic constraints.
by solving the constraints we can identify bugs as well as their triggering inputs.
our evaluation shows that our technique is able to detect bugs with unreported before.
all of them are true positives.
.