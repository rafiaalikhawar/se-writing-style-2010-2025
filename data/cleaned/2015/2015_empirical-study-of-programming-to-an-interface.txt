empirical study of programming to an interface beno t v erhaeghe christopher fuhrman latifa guerrouj nicolas anquetil and st phane ducasse berger levrault france dept.
of software engineering and it cole de technologie sup rieure montreal canada univ.
lille cnrs centrale lille inria umr cristal f lille france rmod inria nord europe lille france firstname .
lastname berger levrault.com firstname .
lastname etsmtl.ca firstname .
lastname inria.fr abstract a popular recommendation to programmers in object oriented software is to program to an interface not an implementation pti .
expected benefits include increased simplicity from abstraction decreased dependency on implementations and higher flexibility.
y et interfaces must be immutable excessive class hierarchies can be a form of complexity and speculative generality is a known code smell.
t o advance the empirical knowledge of pti we conducted an empirical investigation that involves java projects on github aiming to measuring the decreased dependency benefits in terms of cochange .
index t erms java interfaces coupling empirical study software repositories cochange github i. i ntroduction object oriented software design has leveraged many important principles from modular design including abstraction e.g.
standardized interfaces and information hiding.
java provides a mechanism for abstraction known as an interface which typically declares one or more abstract methods otherwise unrelated classes can implement the interface by providing implementations for its abstract methods.
like its analog in c sharp it can be a solution to the limitation of single inheritance.
c virtual functions are a similar abstraction.
a well known object oriented heuristic states it is better to program to an interface not an implementation.
in other words programming to an interface pti means that if a client cneeds to use xfor some service it is better for cto use an abstraction ix which could also be the superclass of x providing the service.
this heuristic is based on common sense and experience but empirical evidence is lacking on whether its use is always beneficial.
expected benefits of pti include simplicity flexibility and decreased dependency.
the api of ix will likely have fewer methods than x. it can be published meaning ix should be immutable and client programmers can depend on it.
this allows developers of xto change it within the constraints of its published api.
on the other hand this use of abstractions can have other consequences.
it can add levels to a hierarchy and has been shown as detracting from understandability in certain models .
abstracting a service with an interface when there is but one implementation is a smell called speculative generality .
sometimes interfaces are wrong and cannot remain immutable affecting not only clients but all implementations.
better empirical knowledge of the pti principle could enableautomated recommendation systems for developers regarding the consequences of applying this heuristic.
because of the multiple consequences of the pti principle many approaches could be taken in studying them including controlled experiments with human subjects and natural experiments with data from software artifacts and histories produced by humans.
some aspects of pti e.g.
simplicity might best be studied with a controlled human subject experiment.
y et these experiments have complexities human subjects software developers are in high demand today experiments must be approved by university research boards and human subjects cannot simply forget their experiences once they have participated in an experiment.
thus controlled experiments with real developers are difficult to realize and are constrained to a waterfall process.
although natural experiments have their own limitations the context in which their data are obtained the validation of measures etc.
they can be automated and easily repeatable on large publicly available sets of data.
in this article we present an original natural experiment to find evidence supporting pti with respect to one of its expected benefits decreasing dependencies.
we perform a natural experiment using archival data from histories of popular open source java systems on github.
using a staticanalysis model based on previous work from rufiange and fuhrman we identify relationships between clients of implementations that use or do not use abstractions to access them.
we formulate and test a hypothesis on how likely these two kinds of accesses are to be involved in changes and find that both cases resulted in relatively low frequencies of cochange.
in the next section we present the background on pti.
section iii presents the methodology of our empirical study aiming at measuring benefits of decreased dependencies.
section iv discusses the operationalization details while section v reveals and discusses the results.
we address the threats to validity in section vi while we present the related work in section vii.
finally section viii concludes the paper with a summary of the findings and directions for future work.
ii.
p rogramming to an interface interfaces can be used as abstractions to achieve information hiding .
larman coined this as protected v ariation and argued it is equivalent to the open closed principle 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure clients can access implementations directly arraylist or only through an interface list modules should be both open for extension and adaptation and closed to avoid modification that affect clients .
protected v ariation uses the term interface in a general sense of a stable abstraction and predates the concept of a java interface .
javainterface s however can be easily identified in source code and their intention as design abstractions is generally straightforward.
pti intends for client classes to use an interface abstraction rather than its concrete implementing classes.
in java for example the client of the list interface in figure can use an arraylist directly or it can treat it as an implementation of list without knowing that it s an arraylist .
advantages to this include that the client s code should be simpler since it only sees the methods of list rather than all the methods of arraylist .
there is greater flexibility forclient to later use the linkedlist implementation for performance reasons.
developers of implementations can modify their code without breaking the client.
however interfaces must be immutable otherwise changes will be required in clients and implementations.
instances have to be created and this can only come from calls to constructors in concrete classes implementations .
an instruction in java such as list l new arraylist is called upcasting an essential mechanism in pti.
although it results in dependency on the implementation through the constructor these accesses can be isolated via dependency injection or factories.
however this has been shown to harm understandability .
fowler proposes a related refactoring replace constructor with factory function .
iii.
e xperiment setup as mentioned in the introduction different kinds of experiments could be done to measure how the consequences of pti manifest themselves.
rather than run a controlled experiment with human subjects we present a novel empirical investigation that focuses on analyzing the evolution of easily accessible data from artifacts produced by developers.
the experiment looks at whether structural characteristics of following pti has measurable benefits in terms of decreased dependencies.
following the notion that adhering to pti should isolate clients from dependencies on the implementation they are using we frame our experiment in a context of cochange pairs e.g.
figure model for classifying coupling with interfaces.
clients a and b use interfaces iand jwith implementations w x y and z. this example yields the sets p a w a x b w b x b y andu b z .
geipel and schweitzer .
however we limit our study of pairs to the context of java interfaces where a cochange pair consists of a client and an implementation of a given interface because interfaces are easily identifiable in java source code.
if the reduced dependency benefit of pti holds we expect that client implementation pairs with direct dependency should be linked by cochange significantly more often than those pairs with indirect dependencies .
thus we propose the following research question rq are interface clients that are directly coupled to an implementation more likely subject to cochange than interface clients which are potentially indirectly coupled to implementations?
h0 there is no significant difference between the cochange frequency of directly coupled client implementation pairs and indirectly coupled client implementation pairs.
for the sake of simplicity we perform our analyses at a file level granularity i.e.
.java files rather than methods or variables.
a. dependencies figure shows how clients of an interface can have structural coupling to implementations of the interface e.g.
client b implementation z or how they can be structurally independent of implementations e.g.
client aand implementation w .
since using interfaces without coupling between clients and implementations of the interface is called protected variation we distinguish client implementation pairs as either protected having no direct structural coupling or unprotected having direct structural coupling .
the protected pair set p contains all pairs of clients cand implementations mwherecdepends on an interface iof which mis an implementation and cdoes not structurally depend on m. client a figure could use implementations worxvia a factory or dependency injection resulting in the protected pairs a w and a x .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conversely the unprotected pair set u contains all pairs of clients cand implementations m wherechas some direct structural dependency on mand on an interface iimplemented bym.
client brefers to both jandzmodeled as the unprotected pair b z .
in both sets class cdepends explicitly on the interface i implemented by m. the sets differ only by the fact that c also depends directly on m u or not p .
thus we ignore dependencies between a client of a class where an interface exists that the client does not depend on even if the client only uses methods declared by the interface.
some additional exclusions are applied interfaces and implementations not defined inside the project e.g.
java.util.iterator .
interfaces that do not declare any methods i.e.
tagging ormarking interfaces .
anonymous classes because they don t correspond to unique files .
b. cochange as in previous work cochange is extracted from project change events namely all classes whose changes have been committed by the same author at the same time.
specifically the following were ignored add events as opposed to change as the former do not provide evolvability information for the system .
revisions with over files to reduce the impact of changes that are not related to functional aspects of source code e.g.
updating licence information in all classes.
revisions where interface updates have been committed because interface changes imply implementation and possibly client cochanges.
modern version control systems can contain multiple branches .
to avoid the complexity of analyzing merges to determine unique change events we consider change events on a single deterministic path through the repository.
we start at the head commit of a repository and walk backwards in history always choosing the first parent at merge commits until there are no more commits in the project history.
we define a history set hcontaining directional pairs of classes coming from change events.
since a change event containing classes aandbcould imply a bandb a we add both possibilities to h similar to the approach done by ajienka and capiluppi .
the cochanged protected dependencies ratio cpd is the percentage of protected client implementation pairs that have cochanged and cochanged unprotected dependencies ratio cud is the percentage of unprotected clientimplementation pairs that have cochanged cpd h p p andcud h u u .
iv .
e xperiment opera tionaliza tion a graphql query on github yielded the most popular projects with java source code sorted by the sum of the number of stars and forks.
projects with less thann 109n cudcpd figure box violin plots for ratios of cochanged protected dependencies cpd and cochanged unprotected dependencies cud .
projects where poruare empty are excluded.
java content were excluded leaving projects.
from this we excluded projects that declared no interfaces and projects that had or fewer commits and one project janishar mit deep learning book pdf with a single java file resulting in a total of projects for the study.
v erveinej generated a famix java model of the latest revision of each project.
moose determined the project s interfaces clients and implementations.
protected and unprotected pairs were determined by querying the model.
for cochange information we mined each project by walking the commit history of each project using libgit2 and pharo iceberg filtering commits per the constraints describe above.
we generated pairs of java classes that appear in commits to compute h p u cpd andcud as described above.
data files comma separated value format were generated for each step in the analysis to provide transparency and to allow validation and failure recovery of the steps.
v. r esul ts figure shows the cud andcpd distributions for all projects.
we see that protected cochange pairs have a lower ratio of occurring compared to unprotected cochange pairs.
we calculated the statistical significance of these results using wilcoxon signed rank test with holm adjustment to adjust thep value.
in addition we computed the effect size using the non parametric cliff s delta.
we obtained p .
and d .
small respectively which allowed us to reject our null hypothesis h0.
the effect size is however small.
for most projects the cochange ratio is small under .
this result differs from others where mean cochange probabilities of more than were reported.
we only considered client implementation pairs whereas the former study looked at all structurally coupled pairs.
client implementation pairs appear to be a smaller source of cochange within the scope of a project.
one explanation could be that because clients bind to interfaces which are normally stable elements in a design they are more stable with respect to implementations regardless of how the clients access them.
the medians of the numbers of protected pairs p and unprotected pairs u are .
and respectively showing that most projects have many more protected pairs than unprotected pairs.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vi.
t hrea ts to v alidity regarding internal validity one threat is that cochange history is mined from only the first branch after a merge useful cochange history could be missed on ignored branches.
concerning external validity the results should be applicable to all java projects.
however they are limited to the scope of the sample of popular projects we found on github.
to mitigate this threat we studied a large n sample of open source projects.
the threats of the operational aspects mining online repositories age of pairs sampling of only java open source projects mentioned in related work apply also to this experiment and are not repeated here due to space limitations.
vii.
r ela ted work the relationship of java clients to interfaces and their implementations was explored by rufiange and fuhrman although no empirical results were done.
geipel and schweitzer did an empirical study to look at how structural coupling and cochange were related.
they used project histories from projects under cvs and found empirical evidence that change propagates along paths of dependency.
their results showed that cochange could not be inferred by only looking at dependencies.
ajienka and capiluppi looked at structural coupling and so called logical coupling which they mined using the apriori algorithm from commit histories of open source java projects.
they concluded that not all cochanged pairs of classes are linked by structural dependencies but structurally coupled pairs of classes usually include logical dependencies.
our study is effectively a subset of classes clients interfaces and their implementations in a similar context.
abdeen sahraoui et al.
proposed metrics for assessing interface design including the program to interface principle ptip and examined empirically for one version only of the project no history whether interfaces in real world applications respect the ptip .
they defined a metric called loose program to interface lpti ranging from to where the latter signifies strong adherence to ptip .
with respect to our model lpti i implies that the interface ihas only protected pairs.
saban gu h neuc et al.
did an empirical study examining the impact of the fragile base class problem and found no correlation with change and fault proneness.
they suggest an explanation that the popularity of dependencyinjection which favors avoiding the problem by favoring composition over inheritance.
new implementations created this way would be clients in our model and who likely access directly concrete implementations via delegation modeled as unprotected pairs.
viii.
c onclusion and future work we suggest a novel empirical approach to study the principle known as programming to an interface pti specifically targeting the expected benefits in terms of decreased dependencies.
a class pair model keeps track of cochange in the context of the structural coupling of clients and implementations of agiven interface.
our results on a set of open source java projects show that the directly coupled client implementation unprotected pairs are less likely to be involved in cochanges than their indirectly coupled protected counterparts.
as future work we intend to extend our approach of a natural experiment with finer detail classification of pairs e.g.
microarchitectures factories dependency injection delegation creates coupling and even method to method pairs to better understand the implications of pti.
more research is needed to address the other aspects of pti such as flexibility simplicity protecting internals and even working around single inheritance limitations in java c sharp.
qualitative studies as well as mining studies can investigate those aspects.