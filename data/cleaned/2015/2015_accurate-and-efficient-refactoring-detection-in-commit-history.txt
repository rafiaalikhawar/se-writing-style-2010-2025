accurate and efficient refactoring detection in commit history nikolaos tsantalis matin mansouri laleh m. eshkevari davood mazinanian concordia university montreal quebec canadadanny dig oregon state university corvallis oregon usa abstract refactoring detection algorithms have been crucial to a variety of applications i empirical studies about the evolution of code tests and faults ii tools for library api migration iii improving the comprehension of changes and code reviews etc.
however recent research has questioned the accuracy of the state of the art refactoring detection tools which poses threats to the reliability of theirapplication.moreover previousrefactoringdetectiontoolsare verysensitivetouser providedsimilaritythresholds whichfurther reducestheirpracticalaccuracy.inaddition theirrequirementto build the project versions revisions under analysis makes them inapplicablein many real world scenarios.
to reinvigorate a previously fruitful line of research that has stifled wedesigned implemented andevaluatedrminer atechnique that overcomes the above limitations.
at the heart of rminer is an ast based statement matching algorithm that determines refactoring candidates without requiring user defined thresholds.
to empirically evaluate rminer we created the most comprehensive oracletodatethatusestriangulationtocreateadatasetwithconsiderably reduced bias representing refactorings from 185open source projects.
using this oracle we found that rminer has a precision of and recall of which is a significant improvement over the previous state of the art.
ccsconcepts software and its engineering software evolution keywords refactoring commit git abstractsyntaxtree oracle accuracy introduction refactoring isa key practice in agiledevelopment processes and is well supported by refactoring tools that are standard withallmajorides.refactoringresearchisapproachingnow30 years.a veryactivelineof researchfocusedonrefactoringdetection algorithms that compute a likely set of refactorings that developers applied onthe source code.
other researchers used refactoring detection to empirically study software evolution and to permissionto make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
codecompletion and code review .
however theaccuracyofrefactoringdetectiontoolshasbeen recentlyquestioned.anindependentstudy hasshownthatreffinder one of the most widely used refactoring detection tools had an overall precision of and an overall recall of while a more recent study has shown that ref finder had anoverallaverageprecisionof27 .missingrefactorings falsenegatives isaseriousthreattothegeneralizabilityofempiricalstudies or can cause other dependent tools to carry incomplete operations.
detectingincorrectrefactorings falsepositives isevenmoresevereasitmakestheconclusionsoftheempiricalstudywrong or causes otherdependent tools to apply the wrong operations.
moreover themajorityoftherefactoringdetectiontoolsusesimilaritythresholds andprovideasetofdefaultthresholdvaluesthat areempiricallydeterminedthroughexperimentationona rather small numberofprojects e.g.
oneprojectforumldiff three forref finder andrefactoringcrawler andtenfor refdiff .
the derived threshold values are possibly overfitted to the characteristics of the examined projects and thus cannot be generalenoughtotakeintoaccountallpossiblewaysdevelopers applyrefactoringsinprojectsfromdifferentdomains.asaresult thesethresholdvaluesrequireacalibrationtoalignwiththeparticularrefactoringpracticesappliedinaproject whichistedious.
moreover findinga universal thresholdvaluemightbeinfeasible.
severalresearchersproposedmethodsforderivingthresholdvalues in metric based detection techniques .
however the precision and recall can vary significantly even for the same software system when using different threshold values and softwaresystemsrelyingondifferentarchitecturalstylesandframeworksrequiredifferentthresholdvalues .therefore researchhas shownthatitisverydifficulttoderive universal thresholdvalues that can work well for all projects regardless of their architectural style application domain and development practices.
furthermore most refactoring detection tools take as input two fully built versions of a software system that contain binding informationforallnamedcodeentities linkedacrossalllibrarydependencies.
however a recent study has shown that only of the change history of software systems can be successfully compiled.thisisaseriouslimitationforperforminglongitudinal refactoring detection in the commit history of projects posing a threattotheexternalvalidityofempiricalstudies sinceonlyasmall numberofprojectversionscanbeeffectivelyusedforextracting refactoring datasets.
thus wedesigned implemented andevaluatedrminer anovel techniquethatovercomestheabovelimitations.rminertakesas input two revisions i.e.
a commit and its parent from the commit history ingit based versioncontrolrepositories ofa java project andreturnsalistofrefactoringoperationsappliedbetweenthese acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden n. tsantalis et al.
two revisions.
rminer provides highly accurate efficient andscalablerefactoringdetectioninthecommithistoryofaprojectwithout requiring to build each individual commit.
at the heart of rminer is an ast based statement matching algorithm that does not require user specified thresholds yet it isimmunetothenoiseintroducedbythestatementrestructuring duringrefactoringoperations.itreliesonourtwonoveltechniques abstraction dealswithchangesinstatements asttypeduetorefactoring and argumentization deals with changes in sub expressions withinstatementsduetoparameterization.usingthematchedast statements we designed powerful detection rules for representative refactoring types.
to empirically evaluate rminer we first needed to create a reliable comprehensive and representative oracle.
this is a daunting task that mounts tremendous challenges on its own.
first is the danger of creating an incomplete oracle .
researchers previously created such oracles by inspecting release notes or commit messages .
however only a small percentage of the release notes include refactoring operations and only for a subset of refactorings that affect the backward compatibility of public apis .moreover developersdonotreliablyindicatethepresence of refactoring operations in commit log messages .
second is the danger of creating a biased oracle .
for example researchers created an oracle based on the findings of a single tool i.e.
ref finder configured with a more relaxed similarity thresholdvalueinordertodetectmorerefactoringinstances followedbyremovingfalsepositivesthroughmanualinspection and then evaluated the precision and recall of the same tool configured with a more strict similarity threshold value.
however this might still miss a large number of true instances due to an algorithm designflaw implementationerror orinappropriatethresholdvalue leading to precision and recall that are significantly different than those reported by independent researchers i.e.
precision and recall of and an overall average precision of vs. the authors reported precision and recall of and .
thirdisthedangerofcreatingan artificialoracle .forexample researchers createdanoraclebyaskingstudentstoapplyrefactoringsinopen sourceprojects.these seededrefactorings can beusedtoreliablycomputetherecall sinceallappliedrefactorings are known a priori.
however seeded refactorings are not representative of real refactorings for two reasons i they are artificial i.e.
theydonotcarryhigher levelintents e.g.
facilitateamaintenance task eliminate a code smell improve code understandability and ii theyare isolatedanddonotoverlapwithtypicalmaintenance activities e.g.
other edits in the same commit to fix bugs add new features .asignificantpercentage ofrefactoredprogram entities are also edited or further refactored in the same commit apracticecommonlyreferredas flossrefactoring .not accountingforthisrealcodeevolution significantlyandartificially increases thesignal to noiseratio thus making thedetection less challengingthanin real world scenarios.
toavoidtheaboveproblemswithrefactoringoracles werely on state of the art procedures that use triangulation betweenmultiple sources human expertsandtools todetermine the ground truth.
we started from an award winning publiclyavailable dataset of refactoring instances originating from538 commits from open source github projects.
moreover the refactoring instances from of these commits were confirmed bythedeveloperswhoactuallyperformedtherefactorings i.e.
the commitauthors throughsurveys andfurtherre validatedbyus manually to ensure correctness.
to ensure the completeness of the dataset we executed two tools that analyze repository commits without requiring to build the project namely our rminer and the previousstate of the artrefdiff onall538commitsofthe dataset.thesetoolsusecomplementarydetectionmethods thusare likely to detect a more comprehensive set of refactoring instances.
then we manually validated unique refactoring instances detectedbythetwotools outofwhich3 188weretruepositives.
the validation process took person months to be completed and involveduptothreerefactoringexpertsperinstancetonegotiate agreement.
with this oracle we evaluate the precision and recall of rminerand the previous state of the art tool refdiff.
based on these results we launch a community call to action relatedtorefactoringdetectionandrefactoringoracles.weofferseveralactionableimplicationsandresultsforresearchers toolbuilders anddevelopers.first ouroracleof3 188truerefactoringsfrom538 commits across projects provides an invaluable resource for validating novel refactoring tools and for comparing existing approaches.educatorscanuseourdatasetwhenteachingsoftware engineering to show examples of refactorings in their real life contexts.usingrminer researcherscanreplicateexistingempirical studies and refute or confirm previously held beliefs.
moreover researchers can use rminer to reduce the noise created byrefactorings suchasfile directoryrenaming andsignificantly improvetheaccuracyofothertools.forexample toolsthatidentify bug introducing changes e.g.
the widely used szz can utilize rminer to avoid flagging changes that do not alter the program behavior i.e.
refactorings as bug introducing.
tools that trace requirements to code could use rminer to recover traceabilitylinksthat are broken due to applied refactorings.
practicalaspects suchasrminer sspeedandconsumptionof raw code changes from commits enable novel applications not possiblebefore suchas onlinerefactoringdetectiononpartialinput whenadeveloperinspectsacodedifftoreviewachange ortries to understand code evolution selectively e.g.
using the blame featureonaprogramelementofinterest .as flossrefactoring isprevalent thetraceofcodechangesleftbehindbyrefactorings can mask the changes actually intended by developers .
moreover refactoringsdistractdevelopersduringcodereviews when the changes are inspected with text diff tools commonly usedinides repositoryhostingservices andcodereviewtools .
integratingrminerwiththediffandcodereviewtoolscanraisethe level of abstraction for code changes originating from refactorings thus helpingdevelopers better understand the code evolution.
thispaper makes the following contributions wepresentthe firstrefactoringdetectionalgorithmthatdoes not require any code similarity thresholds to operate.
we implement our detection algorithm into a tool rminer shortforrefactoringminer whichoperatesonversion control commits and provides an api for external use.
wecreatethemostaccurate complete andrepresentativeoracle of refactoring operations to date comprising refactorings authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accurate and efficient refactoring detection in commit history icse may june gothenburg sweden foundin538commitsfrom185open sourceprojects whichwe validatewithmultipletools and experts .
we evaluate rminer and find that it achieves precision and87 recall andtakesonmedian58mstoanalyzeacommit a significant improvement over the previous state of the art.
we release a tool infrastructure to compare the accuracy of multiplerefactoringdetectiontools eitherusingauser defined fixed oracle or a dynamically generated oracle based on tool agreement .
approach rminertakesas inputtworevisions i.e.
acommitand itsparent in the directed acyclic graph that models the commit history in git basedversioncontrolrepositories ofajavaproject andreturnsalistofrefactoringoperationsappliedbetweenthesetworevisions.itsupportsthedetectionof15refactoringtypesfor4differentkindsofcodeelements asshownintable1.thisisarepresentativesetofrefactoringtypes becauseitcoversallstructuralcodeelements i.e.
packages types methods andfields andalsocoverscontrol flows of program statements e.g.
extract and inlinemethod .
table refactorings detected byrminer code element refactorings package changepackage move rename split typemove class rename class extract superclass interface methodextract method inlinemethod pullup method push down method rename method move method extract and move method fieldpullup field push down field move field unlikeotherexistingrefactoringdetectionapproaches suchas ref finder refactoringcrawler and jdevan whichanalyze allfiles intwosnapshots versions ofa javaproject rmineranalyzesonlytheadded deleted andchangedfilesbetween the two revisions.
this makes rminer not only more efficient because it has less code elements to analyze and compare but also more accurate because the number of code element combinations tobecomparedissignificantlyless thusreducingtheprobability of incorrect code element matches.
.
notation we adopt and extend the notation defined by biegel et al.
for representingtheinformationthatweextractfromeachrevisionusing the eclipse jdt abstract syntax tree ast parser.
notice that we configure the parser to create the asts of the added deleted and changed java compilation units in each revision withoutresolvingbindinginformationfromthecompiler andthusthereis no need to build the source code.
consequently all referenced types e.g.
parameters variable fielddeclarations extendedsuperclass implementedinterfaces arestoredastheyappearintheast aswe are not able to obtain their fully qualified names.
for each revision r we extract the following information tdr thesetoftypedeclarations i.e.
classes interfaces enums affected in r. for a child commit this set includes the type declarations inside changed and added java files while for a parent commit this set includes the type declarations inside changedand removed java files.
each element tdof the set is a tuple of theform p n f m wherepistheparentof td nisthename oftd fis the set of fields declared inside td andmis the set of methods declared inside td.
for a top level type declaration p correspondstothepackageofthecompilationunit tdbelongsto while for a nested inner type declaration pcorresponds to the package of the compilation unit tdbelongs to concatenated with the nameof the type declaration tdis nested under.
fr thesetoffieldsinsidethetypedeclarationsof tdr.itcontains tuples of the form c t n wherecis the fully qualified name of the type declaration the field belongs to constructed by concatenating the package name pwiththe type declaration namen tis the type of the field and nis the name of the field.
mr the set of methods inside the type declarations of tdr.i t contains tuples of the form c t n p b wherecis the fully qualified name ofthe type declaration themethod belongs to t is the return type of the method nis the name of the method p is the ordered parameter list of the method and bis the body of the method could be nullif the method is abstract or native .
dr the set of all directories in ras returned by command git ls tree.
each directory is represented by its path p. private static address createaddresses int count address addresses new address for int i i count i try addresses new address .
.
.
ports.incrementandget catch unknownhostexception e e.printstacktrace return addresses mt l vv cd vvvv vvariable identifierttype dvariable declarationlliteral cclass instantiation mmethod invocationvv vv c figure representation of a method body as a tree.
the body of a method is represented as a tree capturing the nesting structure of the code where each node corresponds to a statement similartotherepresentationusedbyflurietal.
.for acompositestatement i.e.
astatementthatcontainsotherstatementswithinitsbody suchas for while do while if switch try catch synchronized block label the node contains the statement s type and the expression s appearing within parenthesis before the statement s body.
for a leaf statement i.e.
a state ment without a body the node contains the statement itself.
inorder to avoid storing ast information into memory for each statement expression we keep its string representation in a prettyprintedformatwhereallredundantwhitespaceandmulti linechar actersareremoved.inaddition weuseanastvisitortoextractall variableidentifiers methodinvocations classinstantiations variable declarations types literals and operators appearing within eachstatement expressionandstoretheminapretty printedformat within the corresponding statement node.
figure shows the tree like representation of the body of method createaddresses along with the information extracted by the ast visitor for two of its statements.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden n. tsantalis et al.
.
statementmatching the matching of the statements between two code fragments is acorefunctionthatweusethroughouttherefactoringdetectionrules described in this paper.
our statement matching algorithm hasbeeninspiredbyflurietal.
inthesensethatwealsomatch the statements in a bottom up fashion starting from the matching of leaf statements and then proceeding to composite statements.
however inoursolution outlinedinalgorithm1 wedonotuse any similarity measure to match the statements and thus we do not require the definition of similarity thresholds.
to reducethe chancesof erroneous matches we follow aconservativeapproach inwhichwematchthestatementsinrounds where each subsequent round has a less strict match condition thanthepreviousround.thus thestatementsmatchedinearlier roundsare safer matches andareexcludedfrombeingmatched inthe nextrounds.
inthis way the nextround whichhasa more relaxed match condition has fewer statement combinations to check.
we match leaf statements in three rounds lines .
in the first round wematchthestatementswithidenticalstringrepresentation andnestingdepth.inthesecondround wematchthestatements withidenticalstringrepresentationregardlessoftheirnestingdepth.
inthelastround wematchthestatementsthatbecomeidentical after replacing the ast nodes being different between the two statements.
we match composite statements in three rounds as well lines using exactly the same match conditions as those usedforleafstatementscombinedwithanadditionalconditionthat requiresatleastonepairoftheirchildrentobematched line10 assumingthatboth composite statements have children.
in all rounds we apply two pre processing techniques on the input statements line in function matchnodes namely abstractionandargumentization to deal with specific changes takingplace inthecodewhenapplyingextract inline andmovemethod refactorings.
abstraction somerefactoringoperations suchasextractand inlinemethod oftenintroduceoreliminate returnstatements whenamethodisextractedorinlined respectively.forexample whenanexpressionisextractedfromagivenmethod itappears as areturnstatement in the extracted method.
to facilitate the matchingofstatementshavingadifferentastnodetype we abstractthestatementsthatwrapexpressions.whenbothstatements being compared follow one of the following formats return expression i.e.
returned expression type var expression i.e.
initializerofavariabledeclaration var expression i.e.
right hand side of an assignment call expression i.e.
singleargumentofamethodinvocation if expression i.e.
condition of a composite statement then they are abstracted to expression before their comparison.
figure2showsanexampleofabstraction wheretheassignment statement dfromthecodebeforerefactoring andthereturnstatement5fromthecodeafterrefactoring areabstractedtoexpressionsnew address .
.
.
ports.incrementandget andnew address host port respectively.
argumentization some refactoring operations may replace expressionswithparameters andviceversa.forexample whenduplicatedcodeisextractedintoacommonmethod allexpressionsalgorithm1 statementmatching input treest1andt2 output setmof matched node pairs sets of unmatched nodesut1 ut2fromt1andt2 respectively 1m emptysetalt2 ut1 emptysetalt2 ut2 emptysetalt2 2l1 t1.leafnodes l2 t2.leafnodes 3condition1 n1 n2 n1.text n2.text n1.depth n2.depth 4condition2 n1 n2 n1.text n2.text 5condition3 n1 n2 replacements n1.text n2.text 6l prime l prime matchnodes l1 l2 condition1 round 7l prime prime l prime prime matchnodes l prime l prime condition2 round 8matchnodes l prime prime l prime prime condition3 round 9c1 t1.compositenodes c2 t2.compositenodes 10condition4 n1 n2 k1 k2 m k1 n1.children k2 n2.children 11condition1 n1 n2 condition1 condition4 12condition2 n1 n2 condition2 condition4 13condition3 n1 n2 condition3 condition4 14c prime c prime matchnodes c1 c2 condition1 round 15c prime prime c prime prime matchnodes c prime c prime condition2 round 16matchnodes c prime prime c prime prime condition3 round 17ut1 t1.nodes mt1 ut2 t2.nodes mt2 1function matchnodes n1 n2 matchcondition 2foreachn1 n1do p emptysetalt2 foreachn2 n2do pn1 pn2 preprocessnodes n1 n2 ifmatchcondition pn1 pn2 then p p n1 n2 end end if p 0then bestmatch findbestmatch p m m bestmatch n1 n1 bestmatch .n1 n2 n2 bestmatch .n2 end 16end 17returnn1 n2 18end being different among the duplicated code fragments are parameterized i.e.
they are replaced with parameters in the extracted method .
the duplicated code fragments are replaced with calls totheextractedmethod whereeachexpressionbeingdifferentis passedasanargument.inmanycases theargumentsmaydiffersubstantially from the corresponding parameter names leadingto a low textual similarity of the code before and after refactoring.
argumentizationis the process ofreplacing parameter names with the corresponding arguments in the code after refactoring.
figure2showsanexampleofargumentization whereparameter nameshostandportarereplacedwitharguments .
.
.
andports.incrementandget respectively in statement .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accurate and efficient refactoring detection in commit history icse may june gothenburg sweden before aftera b c d e f g1 a b c d e f g private static list address createaddresses atomicinteger ports int count list address addresses new arraylist address count for int i i count i addresses .add createaddress .
.
.
ports.incrementandget return addresses protected static address createaddress string host int port try return new address host port catch unknownhostexception e e.printstacktrace return null .
.
.
ports.incrementandget matched statementsreplacement addition abstraction argumentization private static address createaddresses int count address addresses new address for int i i count i try addresses new address .
.
.
ports.incrementandget catch unknownhostexception e e.printstacktrace return addresses figure statement matching for anextract method refactoring in project hazelcast .
the same process is applied to the statements of inlined and moved methods.
in particular when an instance method is moved to a target class we might have a parameter or a source class field access of target type that is removed from the original method or a parameter of source type that is added to the original method.
in the case of removal the removed parameter or field access might bereplacedwith thisreferenceinthemovedmethod whileinthe case of addition thisreference might be replaced with the added parameterin the moved method.
by applying the techniques of abstraction and argumentization theoriginalstatements dand5infigure2aretransformedto new address .
.
.
ports.incrementandget and new address .
.
.
ports.incrementandget r e spectively and thus can be identically matched by replacing static fieldportswithparameter ports.
on the other hand string similarity measures would require a very low threshold to match these statements.
for instance the levenshtein distance commonly used for computing string similarity between the original statementsdand5is44editoperations whichcanbenormalizedto asimilarityof1 .
where65isthelengthofthelongest stringcorresponding tostatement d.the bigramsimilarity usedbychangedistiller betweenstatements dand5 is equal to .
.
it is clear that the string similarity measures usedby the majority of the refactoring detection tools are susceptible to code changes applied by some refactoring operations such as parameterization especially when the arguments differ substan tially from the parameter names.
therefore our pre processing techniquesfacilitatethematchingofstatementswithlowtextual similarity.
function matchnodes finds all possible matching nodes in tree t2foragivennodeintree t1andstoresthematchingnodepairs into setp.
function findbestmatch p line sorts the node pairsinpandselectsthetop sortedone.leafnodepairsaresorted basedon3criteria.first basedonthestringeditdistance of thenodesinascendingorder i.e.
moretextuallysimilarnodepairs rankhigher .second basedontheabsolutedifferenceofthenodes depth in ascending order i.e.
node pairs with more similar depth rankhigher .
third basedon theabsolutedifference ofthenodes index in their parent s list of children in ascending order i.e.
node pairs with more similar position in their parent s list of children rankhigher .compositenodepairsaresortedwithanadditional criterion whichisappliedrightafterthefirstcriterion basedontheratioofthenodes matchedchildrenindescendingorder i.e.
node pairs with more matched children rank higher .
algorithm2 syntax aware replacements of ast nodes input statements s1ands2 output trueif statements can be identically matched after syntax aware replacements otherwise false 1function replacements s1 s2 2ns1 emptysetalt2 ns2 emptysetalt2 r emptysetalt2 3foreacht nodetypes do common t s1.nodest s2.nodest ns1 ns1 s1.nodest common t ns2 ns2 s2.nodest common t 7end 8d distance s1 s2 9foreachns1 ns1do c emptysetalt2 foreachns2 ns2do ifcompatibleforreplacement ns1 ns2 then d prime distance s1.replace ns1 ns2 s2 ifd prime dthen c c ns1 ns2 end end end if c 0then best smallestdistance c d best.distance r best.replacement r r r s1 s1.replace r.ns1 r.ns2 end 26end 27ifs1 s2then returntrue 29else returnfalse 31end function replacements algorithm takes as input two statementsandperformsreplacementsofastnodesuntilthestatements authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden n. tsantalis et al.
... neuralnetconfiguration conf new neuralnetconfiguration.builder .lossfunction lossfunctions.lossfunction.
mcxent .optimizationalgo optimizationalgorithm.
iteration gradient descent .activationfunction softmax .iterations .weightinit weightinit.
xavier .learningrate 1e .nin .nout .layer new org.deeplearning4j.nn.conf.layers.outputlayer .build ...static outputlayer getirislogisticlayerconfig string activationfunction int iterations neuralnetconfiguration conf new neuralnetconfiguration.builder .layer new org.deeplearning4j.nn.conf.layers.outputlayer .nin .nout .activationfunction activationfunction .lossfunction lossfunctions.lossfunction.
mcxent .optimizationalgo optimizationalgorithm.
iteration gradient descent .iterations iterations .weightinit weightinit.
xavier .learningrate 1e .seed 12345l .build replacement addition argumentization outputlayer layer getirislogisticlayerconfig softmax ... softmax a method invocation chains following the fluent interface pattern in project deeplearning4j .
public indexdescriptor indexcreate kernelstatement state int labelid int propertykeyid return schemawriteoperations.indexcreate state labelid propertykeyid public indexdescriptor indexcreate kernelstatement state nodepropertydescriptor descriptor return schemawriteoperations.indexcreate state descriptor b method invocation having two arguments replaced with a single argument in project neo4j .
figure replacement of method invocations.
becometextuallyidentical.thisapproachhastwomainadvantages overexistingmethodsrelyingontextualsimilarity.first thereis noneedtodefineasimilaritythreshold.thereisempiricalevidence that developers interleave refactoring with other types of program mingactivity e.g.
bugfixes featureadditions orotherrefactoring operations .inmanycases thechangescausedbythese different activities may overlap .
some of these changes may evenchangesubstantiallytheoriginalcodebeingpartofarefactor ing operation.
for example a code fragment is originally extracted and then some temporary variables are inlined in the extractedmethod.
the longer the right hand side expressions assigned to thetemporaryvariables themoretextuallydifferenttheoriginalstatementswillbeafterrefactoring.therefore itisimpossibleto define auniversal similarity threshold value that can cover any possiblescenarioofoverlappingchanges.ontheotherhand our approachdoesnotposeanyrestrictiononthereplacementsofast nodes aslongasthesereplacementsaresyntacticallyvalid.second thereplacementsfoundwithintwomatchedstatementscanhelp toinferothereditoperationstakingplaceontherefactoredcode a phenomenon called refactoring masking such as renaming of variables generalization of types and merging of parameters.
on the other hand similarity based approaches lose this kind of valuableinformation.
initially ouralgorithmcomputestheintersectionbetweenthe setsofvariableidentifiers methodinvocations classinstantiations types literals and operators extracted from each statement re spectively inordertoexcludefromreplacementstheastnodesbeing common in both statements and include only those being different between the statements lines .
ast nodes that cover theentirestatement e.g.
amethodinvocationfollowedby ar e also excluded from replacements in order to avoid having an excessivenumberofmatchingstatements.allattemptedreplacements aresyntax aware in the sense that only compatible ast nodes are allowed to be replaced line i.e.
types can be replaced only by types operators can be replaced only by operators while all remainingexpressiontypescanbereplacedbyanyoftheremainingexpressiontypes e.g.
avariablecanbereplacedbyamethodinvocation .
out of all possible replacements for a given node from the first statement that decrease the original edit distance of the inputstatements weselectthereplacementcorrespondingtothe smallestedit distance line .
inthespecialcasewhentwomethodinvocationsareconsidered for replacement function compatibleforreplacement ns1 ns2 examinestheexpressionsusedforinvokingthemethods.ifthese expressionsarechainsofmethodinvocations asthecaseshownin figure 3a commonly known as the fluent interface pattern in api design then we extract the individual method invocations being part of each chain and compute their intersection ignoring any differences in the order of the invocations inside each chain.
if the numberofcommoninvocationsislargerthantheuncommonones then we consider the original method invocations as compatible forreplacement.intheexampleoffigure3a thereare9common invocations two of them are identically matched after applying theargumentizationtechnique andonly1uncommon.noticethat stringsimilaritymeasuresproduceverylowsimilarityvalueforthis case.
for instance the normalized levenshtein similarity between the two statements is .
while the bigram similarity is .
.
handling of changes not supported by algorithm as explainedbefore astnodescoveringtheentirestatement suchas the method invocations shown in figure 3b are excluded from replacements to avoid having an excessive number of matching statements.however theremightbechangesintheirlistofargumentsthatcannotbehandledbyalgorithm2 suchastheinsertion ordeletionofanargument andthereplacementofmultipleargumentswithasingleoneandviceversa.thisisbecausewedesigned the algorithm to perform only one to one ast node replacements and does not support one to many many to one one to zero i.e.
deletion zero to one i.e.
insertion replacements asthiswould increase substantially its computational cost.
to overcome this limitation we allow the replacements of textually different method invocations covering the entire statement as long as they have an identicalinvocationexpression anidenticalmethodname anda non empty intersection of arguments e.g.
argument statein the example of figure 3b .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accurate and efficient refactoring detection in commit history icse may june gothenburg sweden table refactoring detection rules refactoring type rule change method signature m ut1 ut2 matching ma.b mb.b ma m mb m ma.c mb.c ma.n nequalmb.n rename method matomb1 ut1 emptysetalt2 ut2 emptysetalt2 allexactmatches m m ut1 m ut2 locationheuristic ma mb compatiblesignatures ma mb m ut2 locationheuristic ma mb extract ma mx m ut1 locationheuristic ma mb inline mx mb extract method mbfromma m ut1 ut2 matching ma.b mb.b ma ma prime m mb m ma.c mb.c calls ma mb calls ma prime mb m ut2 inline method mbtoma prime m ut1 ut2 matching mb.b ma prime.b ma ma prime m mb m ma prime.c mb.c calls ma mb calls ma prime mb m ut1 change class signature tda tdb tda td tdb td tda.m tdb.m tda.m tdb.m tda.f tdb.f tda.f tdb.f tdatotdb tda.p nequaltdb.p move class tda.n nequaltdb.n rename class move method matomb m ut1 ut2 matching ma.b mb.b ma m mb m ma.c nequalmb.c m ut1 m ut2 tda tda prime td ma tda tdb tdb prime td mb tdb prime importstype tda prime mb.c importstype tdb ma.c subtype ma.c mb.c pull up method subtype mb.c ma.c push down method move field fatofb fa fb fa f fb f fa.c nequalfb.c fa.t fb.t fa.n fb.n tda tda prime td fa tda tdb tdb prime td fb tdb prime importstype tda prime fb.c importstype tdb fa.c subtype fa.c fb.c pull up field subtype fb.c fa.c push down field extract mbfromma m ut1 ut2 matching ma.b mb.b ma ma prime m mb m ma.c nequalmb.c move to mb.c calls ma mb calls ma prime mb m ut2 tda tda prime td ma tda importstype tda prime mb.c extract supertype tda tdb tda tda prime td tdb td subtype type tda prime type tdb tdbfromtda pullup ma mb ma tda mb tdb pullup fa fb fa tda fb tdb extract superclass ma mb ma tda mb tdb identicalsignatures ma mb mb.b null extract interface change package patopb pa pb path pa d path pb d moveclass tda tdb tda.p pa tdb.p pb matching t1 t2 returns a set of matched statement pairs m between the trees t1andt2representing method bodies and two sets of unmatched statements from t1 ut1 and t2 ut2 respectively indexof m td returns the position of minside type declaration tdtypedecl c returns the type declaration of type ctype td returns the qualified name of type declaration td locationheuristic ma mb indexof ma typedecl ma.c indexof mb typedecl mb.c m c m c importstype td t returnstrueiftypedeclaration tddependsontype t compatiblesignatures ma mb ma.p mb.p ma.p mb.p ma.p mb.p ma.p mb.p ma.p mb.p calls ma mb returns true if method macallsmb subtype ca cb returns true if cais a direct or indirect subclass of cbor implements interface cbpath p returns the directory path for package p .
refactoringdetection thedetectionofrefactoringstakesplaceintwophases.thefirst phaseislesscomputationallyexpensive sincethecodeelements arematchedonlybasedontheirsignatures.ourassumptionisthat twocodeelementshavinganidenticalsignatureintworevisions correspond to the same code entity regardless of the changes that mighthaveoccurredwithintheirbodies.thesecondphaseismore computationally expensive since the remaining code elements are matched based on the statements they have in common within theirbodies.inanutshell inthefirstphase ouralgorithmmatches code elements in a top down fashion starting from classes and continuing to methods and fields.
two code elements are matched only if they have an identical signature.
assuming aandbare two revisions of a project twotypedeclarations tdaandtdbhaveanidenticalsignature if tda.p tdb.p tda.n tdb.n two fields faandfbhave an identical signature if fa.c fb.c fa.t fb.t fa.n fb.n two methods maandmbhave an identical signature if ma.c mb.c ma.t mb.t ma.n mb.n ma.p mb.p two directories daanddbare identical if da.p db.p aftertheendofthefirstphase weconsidertheunmatchedcode elementsfromrevision aaspotentiallydeleted andstorethemin setstd f m andd respectively.weconsidertheunmatched code elements from revision baspotentially added and store them in setstd f m andd respectively.
finally we store the pairsofmatchedcodeelementsbetweenrevisions aandbinsets td f m andd respectively.
in the second phase our algorithm matches the remaining code elements i.e.
the potentially deleted code elements with the potentiallyadded ones inabottom upfashion startingfrommethods and continuing to classes to find code elements with signature changesor code elements involved in refactoring operations.examinationorderofrefactoringtypes wedetecttherefactoring types in the order they appear in table by applying the rules showninthesecondcolumnofthetable.theorderofexamination isveryimportantfortheaccuracyofourapproach.weorderthe refactoring types according to their locality of change starting from local refactoring types i.e.
within a single method class and proceeding with global ones i.e.
among different classes or packages .theintuitionbehindthisordercomesfromempiricalevidenceshowing thatsmall and local refactorings are more frequent than big and global ones and thus there is a higher probability that the potentially added deleted code elements resulted from local rather than global refactorings.
whenever a refactoring type is processed we remove the matched code elements from the setsofpotentiallydeleted addedcodeelements andaddthemto the corresponding setsof matchedcode elements.this affectsthe codeelementsexaminedintherefactoringtypesthatfollow thus reducing the noise level and improving accuracy.
best match selection for the refactoring types involving statement matching in their detection rule when a code element i.e.
method has multiple matches we always select the best match.
thereasonisthatthesamepieceofcodecannotbepartofmultiple refactoringoperations.forexample amethodcannotberenamedto multiple methods.
our algorithm sorts the matching method pairs based on criteria which serve as proxies for method similarity at statement level.
first based on the total number of matched statementsindescendingorder i.e.
methodpairswithmorematched statementsrankhigher .second basedonthetotalnumberofexactly matched statements in descending order i.e.
method pairs withmoreidenticalstatementsrankhigher .third basedonthe total edit distance between the matched statements in ascending order i.e.
method pairs with more textually similar statementsrankhigher .fourth basedontheeditdistancebetweenthemethod namesinascendingorder i.e.
methodpairswithmoretextually similarnamesrank higher .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden n. tsantalis et al.
as table shows the refactoring types examined first have more elaborate and strict rules.
this is crucial to avoid early erroneousmatchesthatwouldnegativelyaffecttheaccuracyofthe detected instances for the refactoring types that follow.
for example thelocation heuristic applied in sub rules and4of the change method signature refactoring type ensures that thepositional difference of two matched methods is less or equal tothe absolute difference in the number of methods added to and deleted from a given type declaration.
the intuition behind this heuristicisthatdevelopersdonottendtochangethepositionofan already existing method inside its type declaration when changing its signature.
assuming that only method renames take place ina type declaration the number of potentially added and deleted methodswillbeequal andthusthelocationheuristicwillbesatisfied only for the method pairs having the same position before andafterrefactoring.thisheuristicisparticularlyeffectiveincases of extensive method signature changes in test classes e.g.
see thecaseofextensiveunittestrenamesinprojectcassandra wheredeveloperstendtocopy and modifyolderunitteststocreate new ones and thus several methods share very similar statements with each other.
sub rules 3and4take into account the case where a method with a signature change has a significant portion of its body extracted or inlined respectively.
for instance in the case shown in figure the result of statement matchingbetweenmethods createaddresses beforeandafterrefactoring ism a b g i.e.
m whileut1 c d e f i.e.
ut1 andut2 i.e.
ut2 and thus sub rule failstomatchthemethods.ontheotherhand sub rule 3matches successfullythemethods because m ut2 andthereexistsat least one method extracted from the original createaddresses .
evaluation weempiricallyevaluatetheusefulnessof rminerbyanswering the followingresearch questions rq1 whatistheaccuracyof rminerandhowdoesitcompare to the previous state of the art?
rq2 what is the execution time of rminer and how does it compare to the previous state of the art?
we answer the first research question by computing standard metrics from information retrieval i.e.
precision and recall .
as these metrics require having a reliable oracle we use complementary methods to create the most accurate oracle to date.
moreover we compare the accuracy and running time of rminer against that of the previous state of the art tool refdiff as silva and valente established that refdiff significantly outperforms other widely used refactoring detection tools such as ref finder and refactoringcrawler.
.
oracleconstruction having a correct complete and representative oracle of refactoringsisfundamentalforcomputingprecisionandrecallinareliable manner.
therefore we used a publicly available dataset of refactoring instances comprising commits from open source github hosted projects monitored over a period of two months between june 8thand august 7th .
the authors of manuallyvalidatedallrefactoringinstancesinthedataset.moreover table precision and recall per refactoring type refactoring typerminer refdiff precision recall precision recall inline method .
.
.
.
extract method .
.
.
.
move field .
.
.
.
move class .
.
.
extract interface .
.
push down method .
.
push down field .
change package .
n a n a pull up method .
.
.
pull up field .
.
.
move method .
.
.
.
rename method .
.
.
.
extract superclass .
.
rename class .
.
.
.
extract move method .
.
.
.
overall .
.
.
.
the instances found in of these commits were confirmed by the developers who actually performed the refactorings i.e.
the commit authors through surveys.
we re validated all instances to ensuretheircorrectness.fourteencasesactuallycorrespondedto multiple instances summarized as a single refactoring operation e.g.
arefactoringreportedas method fooextractedfrom barand xother methods corresponds to x separate extract method instances .
we broke down these cases to separate instances by manually finding the summarized code elements.
this dataset can be considered correct since all instances went through rigorous manual validation by multiple authors and in several cases were confirmed by the developers who actually performed them.
it is oneofthemostrepresentativedatasetstodate sinceallinstances arerealrefactoringsfoundin185differentjavaprojects theyare motivatedbyavarietyofreasons andtakeplacealongwith other changes refactorings in the same commit.
however the completenessofthedatasetisnotguaranteed sincethereisnoreported recall for the refactoring detection tool used in .
to ensure the completeness of the dataset we executed two tools that analyze repository commits without requiring to build the project namely rminerandrefdiff onall538commitsofthedataset.these tools use complementary detection methods i.e.
a more conservative threshold free approach based on statement matching vs. a more relaxed threshold based approach based on token similarity thusarelikelytodetectamorecomprehensivesetofrefactoring instances.
for the validation process we created a web application which listed all detected refactorings along with links to the corresponding github commits.
through this web application the validators were able to inspect the change diff provided by github and enter their validation and comments.
in total we manually validated unique refactoring instances detected by the two tools out of which were true positives and were false positives.
the validation process was labor intensive and involved 3validatorsforaperiodof3months i.e.
9person months .togive asenseofthemanualinspectiondifficulty onaverage acommit contained7.89refactoringinstances median .25changed files median and changed lines of code median .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accurate and efficient refactoring detection in commit history icse may june gothenburg sweden .
precision and recall since refdiff does not support the detection of change package refactoring we did not consider the instances detected by rminer as false negatives for refdiff.
moreover to ensure a fair comparison for rminer we considered all classes within a changedpackage as being moved from the original package to the new one andaddedthecorrespondingmoveclassinstancestothose originallydetected by rminer.
table 3shows the precision andrecall of rminerandrefdiff.
notice that rminer has better precision than refdiff in all refactoringtypes exceptforextractsuperclass vs. where refdiffseemstobeextremelyconservativeduetoitslowrecall.
this is a result of rminer following a conservative threshold free approachfordetectingrefactorings whichresultsinhighprecision.
the lowest precision for rminer is observed for change package and move field and .
respectively while it has over precisioninallotherrefactoringtypes.theachilles heelof refdiff in termsofprecision isthedetection of movemethod andmovefieldrefactorings and30 respectively .wefound tworecurringscenarioscausingsuchfalsepositivesforrefdiff.in the firstscenario refdiff missesthe detectionof a class move to another package and consequently reports the methods and fields of that class as being moved from the original class which is assumedtobedeleted toanotherclass whichisassumedtobenewly added.
in the second scenario a subclass extending implementing agivensuperclass interfaceisdeleted andanewsubclassisadded which overrides the superclass interface methods in a similar way.
refdiffreportsthesemethodsasbeingmovedfromthedeletedto the added subclass.
we believe both scenarios occur because refdiff does not examine if there is an import dependency between the source and target class of a candidate move method field refactoring but relies only on code similarity.
since rminer achieves very high precision does refdiff have better recall due to its less conservative threshold based approach?
we found this is true only for refactoring types while for the other7typesrminerhasbetterrecall.inparticular rminerhas anincreasedrecallof37 to81 forinheritance relatedrefactorings i.e.
pull up field push down method extract superclass interface and for move field refactoring while the increaseinrecallformoveclassandpullupmethodrefactorings is smaller and respectively.
in contrast refdiff has only a slightlyincreasedrecallof2 to6 forlocalrefactorings suchas extract inline renamemethodandrenameclass whilethe increase in recall for inter class refactorings such aspushdown field move method and extract and move method is larger and39 respectively.
an inherent advantage of refdiff helping it to achieve higher recall in refactoring types involving code similarity is that it ignores the structure of the code by treating code fragments as bags oftokens.therefore anychangeinthestructureofthecode e.g.
merging splitting of conditionals as in the case found in projectjetty beforeorafter theactualrefactoringwill notaffectits detectionability aslongasthetokensremainthesame.adisadvantageof refdiffisitsinabilitytodealwithchangesinthetokens caused by the refactoring itself e.g.
parameterization of expres sions in extract method refactoring or another overlappingrminerrefdiff figure execution time per commit ms .
refactoring e.g.
local variable renamesinside the bodyof arefactoredmethod .ontheotherhand rminerdealsrobustlywiththis kind of changes by applying statement pre processing techniques such as argumentization and allowing syntax aware replacement ofastnodeswithinmatchedstatements.furtherresearchonhybridmethodsthatcombinetheadvantagesof rminerandrefdiff seems to have great potential.
.
execution time figure4showsthedistributionoftheexecutiontimeof rminer and refdiff for each examined commit collected by executing separatelyeachtoolonthesamemachinewiththefollowingspecifications intelcorei7 2620mcpu .70ghz 16gbddr3memory tb ssd windows os and java .
.
x64.
for each tool we recordedthetimetakenforparsingthesourcecodeoftheexamined and its parent commit and the time taken to detect refactorings usingthe system.nanotime javamethod.onmedian rmineris times faster than refdiff vs. ms .
we also applied the wilcoxon signed rank test on the paired samples of the time execution for each commit which rejected the null hypothesis refdiff execution time is smaller than that of rminer with a p value .2e andthuswecanstatisticallyconcludethatrminerisfaster on our commit sample.
we should note that rminer has outlier commits that were processed in over one second representing of the examined commits.among these commits took between sec between sec between sec and took over sec with the most time consuming commit taking sec.
.
limitations missing context as explained in section rminer analyzes onlytheadded deleted andchangedfilesbetweentworevisions.
however themissingcontext i.e.
theunchangedfiles canmake rminertoreportanincorrectrefactoringtypeforcertainoperations.forexample ifamethodorfieldispulledmultiplelevelsupto theinheritancehierarchyandsomeclassesbetweenthesourceand destinationareunchanged thenrminerwillreportitasamove becauseitcannotdetecttheinheritancerelationshipbetweenthe source and destination classes due to the missing context.
in our oracle thisscenariooccurredonlyonceinprojectcascading where methods were pulled three levels up teznodestats basehadoopnodestats flownodestats cascadingstats but class flownodestats remained unchanged in the commit.
nestedrefactorings rmineriscurrentlyunabletodetectnested refactoringoperations e.g.
extractmethodappliedwithinan extracted method.
anotable exception is thedetectionof extract and move method which is a sequence of two nested refactoring operations.apossiblesolutionistoincluderecursivelythestatements of called methods when performing the statement matching authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden n. tsantalis et al.
process.
in this way it will be possible to reconstruct the sequence of nested refactoring operations regardless of the nesting depth.
unsupported refactorings in this paper we present and evaluate the detection rules for refactoring types while fowler s catalog includes72differenttypes.rmineralreadysupports thedetectionofrefactoringsrelatedtomethodsignaturechanges add removeparameter changereturn parametertype hide unhide method butwedidn tvalidatethedetectedinstancesinourdatasetduetotheirlargenumberandtimeconstraints.moreover therefactoring types taking place within method bodies such as rename variable parameter field extract inline variable and replace magic numberwithconstant canbeinferredbyutilizingtheastnode replacements collected through the statement matching process.
withtheseadditions rminerwillbeabletosupportthemajorityof the mostpopular refactoring types applied by developers .
oracle bias although we did our best effort to reduce bias in the construction of our oracle by incorporating the input of two tools andmanualvalidationsbymultipleauthors wecannotclaimthe oracleisunbiased.wetriedtoincorporatetheinputofsnapshotbased tools such as ref finder but the vast majority of commits failedtobuildduetobrokendependencies.moreover wheneverthe inspectionofacasewaschallenging multipleauthorsperformedan independent validation followed by a thorough discussion.
overall cases were inspected by one validator out of which caseswerealreadyassessedastruepositivesbytheauthorsof by two validators and by three validators.
related work wei gerber and diehl developed the first technique for the detection of local scope and class level refactorings in the commit history of cvs repositories.
their approach uses a clone detection tool ccfinder tocomparethebodiesofthecodeelementsthat are candidates for refactorings.
they manually inspected the commitlogmessagesoftwoopen sourceprojectstofinddocumented refactorings and compute the recall and used random sampling to estimate theprecision oftheir approach.dig etal.
developed atool refactoringcrawler whichfirstperformsafastsyntactic analysis based on techniques from information retrieval tofind refactoring candidates and then a precise semantic analysis basedonsimilarityofcallgraphs tofindtheactualrefactorings.
to compute the recall the authors manually discovered the appliedrefactoringsinthreeprojectsbyinspectingtheirreleasenotes whiletheyinspectedthesourcecodetocomputeprecision.xing andstroulia developedatool jdevan whichdetectsand classifies refactoringsbased on thedesign level changes reported by umldiff .
they evaluated the recall of jdevan on two softwaresystems andfoundthatalldocumentedrefactoringswererecovered.
prete et al.
developed a tool ref finder which detects the largest number of refactoring types of from fowler scatalog .ref finderencodeseachprogramversion usinglogicpredicatesthatdescribecodeelementsandtheircontainmentrelationships aswellasstructuraldependencies andencodes refactorings as logic rules.
prete et al.
created a set of correct refactorings by running ref finder with a low similarity threshold .
andmanuallyverifiedthem.then theycomputedrecall by comparing this set with the results found using a higher threshold .
and computed precision by inspecting a sampled dataset.silvaandvalente developedatool refdiff whichtakesas inputtworevisionsofagitrepositoryandemploysheuristicsbasedon static analysis and code similarity to detect refactoring types.
refdiff represents a source code fragment as a bag of tokens and computesthesimilarityofcodeelementsusingavariationofthe tf idf weighting scheme.
to determine the similarity threshold values the authors applied a calibration process on a randomly selectedsetoftencommitsfromtendifferentopen sourceprojects forwhichtheappliedrefactoringsareknownandhavebeenconfirmedbytheprojectdevelopersthemselves .theyevaluated the accuracy of their tool using an oracle of seeded refactorings applied by graduate students in open source projects.
unlike these previous tools rminer neither requires similarity thresholds that are tedious to calibrate and might not be generalizable nor does it require operating on fully built snapshots of software systems thus it is applicable in many more contexts.
moreover whereas previous tools have been evaluated against projects with a small number of refactoring instances a notable exception is refdiff which was evaluated on projects with 448seededrefactorings ouroracleisordersofmagnitudelarger comprising185projectsand3 188truerefactoringinstances.weuse triangulation between multiple sources to create one of the mostreliable comprehensive and representative oracles to date.
atotallydifferentapproachtodetectrefactoringsinreal time is to continuously monitor code changes inside the ide.
benefactor and witchdoctor detect manual refactorings in progress and offer support for completing the remaining changes whereas codingtracker ghostfactor and reviewfactor inferfullycompletedrefactorings.whilethesetools highlight novel usages of fine grained code changes inside the ide rminer focuses on changes from commits thus it can be more broadly applied as it is not dependent on an ide or text editor.
conclusions inthiswork wepresentedthefirstrefactoringdetectionalgorithm thatdoesnotrelyoncodesimilaritythresholds.weutilizenovel techniques such as abstraction andargumentization to deal with changes taking place on code statements during refactoring.
in addition weapplysyntax awarereplacementof astnodeswhen matching two statements to deal with overlapping refactorings e.g.
variablerenames orchangescausedbyothermaintenance activities e.g.
bugfixing .ourevaluation usingoneofthemost accurate complete and representative refactoring oraclesto date showed that our approach achieves very high precision with a recall that is competitive to the previous state of the art and has very small computation cost on median it takes msto process a commit .
moreover rminer s ability to operate on commitsopensnewavenues empiricalresearcherscancreate refactoringdatasetswithhighprecisionfromtheentirecommithistory of projects and study various software evolution phenomena at a fine grained level bug inducing analysis techniques can improve their accuracy utilizing commit level refactoring information refactoringoperationscanbeautomaticallydocumentedat commit time to provide a more detailed description of the applied changesinthecommitmessage commitdiffvisualizationcan be overlaid with refactoring information to assist code review and evolution comprehension.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accurate and efficient refactoring detection in commit history icse may june gothenburg sweden