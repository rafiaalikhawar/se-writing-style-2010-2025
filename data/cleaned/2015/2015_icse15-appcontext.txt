appcontext differentiating malicious and benign mobile app behaviors using context wei yang xusheng xiaoy benjamin andowz sihan li tao xie william enckz department of computer science university of illinois at urbana champaign urbana il ynec laboratories america princeton nj zdepartment of computer science north carolina state university raleigh nc fweiyang3 sihanli2 taoxie g illinois.edu yxsxiao nec labs.com zfbeandow whenckg ncsu.edu abstract mobile malware attempts to evade detection during app analysis by mimicking security sensitive behaviors of benign apps that provide similar functionality e.g.
sending sms messages and suppressing their payload to reduce the chance of being observed e.g.
executing only its payload at night .
since current approaches focus their analyses on the types of securitysensitive resources being accessed e.g.
network these evasive techniques in malware make differentiating between malicious and benign app behaviors a difficult task during app analysis.
we propose that the malicious and benign behaviors within apps can be differentiated based on the contexts that trigger securitysensitive behaviors i.e.
the events and conditions that cause the security sensitive behaviors to occur.
in this work we introduce appcontext an approach of static program analysis that extracts the contexts of security sensitive behaviors to assist app analysis in differentiating between malicious and benign behaviors.
we implement a prototype of appcontext and evaluate appcontext on malicious apps from various malware datasets and benign apps from the google play store.
appcontext correctly identifies malicious apps with .
precision and recall.
our evaluation results suggest that the maliciousness of a security sensitive behavior is more closely related to the intention of the behavior reflected via contexts than the type of the security sensitive resources that the behavior accesses.
i. i ntroduction the increasing popularity of smartphones has made them a target for malware.
app markets that distribute software i.e.
apps to smartphones leverage both automated and manual app analyses to detect malware e.g.
google bouncer and apple app store .
to improve the effectiveness of app analysis existing research proposes approaches that extract features from apps and compare those features against predefined sets of signatures or patterns of malicious or privacyinfringing behaviors such as method calls permissions and information flows .
similar to pc malware mobile malware has begun taking steps to evade detection by camouflaging as benign apps .
for example an app can hide malicious intentions by using apis that are appropriate for its expected functionality.
as another example an app may present itself as a messaging app that sends sms messages when the user clicks the send button.
however it also sends sms messages containing the user s contact information in the background without notifying the user.
since both of these apps use the same sms apis existing automated tools that consider method calls and information flows are unlikely to distinguish between thesecases.
notably the key difference between these two apps is that the malicious app uses the sms apis under an unexpected context .
a fundamental difference between malicious and benign apps is that their design principles are different.
the principles guiding the design of benign apps are to meet requirements from users.
however two basic principles guide the design of most malware are to trigger the execution of their malicious payload i.e.
the part of malware carrying malicious behaviors frequently to seek maximal benefits evade detection to prolong their lifetime.
guided by these principles mobile malware leverages two major features of mobile platforms as below.
frequent occurrences of imperceptible system events.
unlike traditional software where events typically come from standard user inputs keyboards and mice a large portion of behaviors in mobile apps are driven by events from the mobile system and its sensors .
compared to ui triggered events which rely on the user to perform a specific sequence of ui interactions in a specific app system events are much more frequently triggered.
thus malware often leverages system events to increase the chances of invoking its malicious payloads .
moreover system events can occur when the user is not using the app or the device itself malicious behaviors triggered by system events can easily evade the user s attentions concealing the signs and traces of the malicious behaviors.
informative external environment states.
mobile apps can access numerous attributes of the external environment e.g.
locations and system time .
these attributes often convey useful information about the current states of the environment.
such environment states are frequently exploited by malware to actively control the execution of malicious behaviors.
for example the droiddream malware family suppresses its malicious behaviors during the day and invokes its malicious payload only at night.
since app reviewers or automated tools such as bouncer can analyze apps for only a short period of time and with limited variations of environmental conditions it is very likely that the reviewers and the tools cannot detect the malware when the environmental conditions that trigger the malicious behaviors are not met.
based on the above mentioned fundamental differences between malware and benign apps we propose that the context inwhich a security sensitive behavior occurs is a strong indicator of whether the security sensitive behavior is malicious or benign.
malware executes its malicious payloads only under certain unique contexts to reach a balance between prolonging its life time and increasing the chance of being invoked.
such contexts are unique because a balance can be reached only when malicious behaviors are invoked frequently enough to meet the needs e.g.
a certain number of clicks per day to improve search engine rankings of a website but not too frequently for reviewers users or tools to notice the abnormal behaviors of the app.
on the contrary most of the contexts for benign behaviors are user interactive and thus are exploited less frequently by malware.
expressing contexts in mobile apps is a non trivial task.
in mobile apps various elements could be used to describe the contexts in which security sensitive behaviors occur.
however due to the complex event driven nature of mobile apps expressing the contexts using all the factors determining the invocation of security sensitive behaviors would incur huge overhead in extracting the context information and extra burden in differentiating benign behaviors from malicious ones.
consider the example that a security sensitive behavior can occur only when an app component enters into the lifecycle method that invokes the behavior.
android apps are component based and each component has a lifecycle .
any factor changing the component s state will determine the invocation of the lifecycle method thus determining the invocation of the security sensitive behavior.
since there are a large number of these factors such as messages sent by other components remote procedure calls by other components ui operations of users and system events incorporating all these factors into the definition of context would make the analysis for extracting contexts expensive and bring noisy data in differentiating benign behaviors from malicious ones.
to express contexts concisely and yet capture the essence to reflect intentions we propose an abstraction of the contexts.
such abstraction of the contexts should be detailed enough to reflect the intentions of security sensitive behaviors but not too redundant to include all the low level detailed information about system states.
our context definition is based on the observation that activating conditions e.g.
events triggering the execution of payloads and guarding conditions e.g.
environmental attributes controlling the execution of payloads are the key elements of context information to differentiate malicious behaviors and benign behaviors.
thus we define a context for a security sensitive behavior as a tuple containing an activation event the event that triggers the securitysensitive behavior and a series of context factors environmental attributes controlling the execution of the securitysensitive behavior .
although our context abstraction reduces the burden in inferring context information we still need to address two challenges posed by mobile apps.
first inferring activation events requires the analysis of the entry points of the app.
unlike desktop programs that have only one entry point for a program execution i.e.
the main function a mobileapp usually has multiple entry points due to its event driven nature.
also not all entry points of an app are triggered by external events and some of them are triggered by intercomponent communications iccs within the app.
it is possible that the program execution path from the entry point triggered by an activation event to the invocation of a securitysensitive behavior goes through a chain of components of the app.
existing analysis can identify only the entry point of each component and thus cannot be directly applied to infer activation events.
second computing context factors requires the analysis of control flows from the activation events to the invocations of the security sensitive behaviors.
the iccs in apps complicate the analysis because a conditional statement controlling the execution of iccs may further control the security sensitive behaviors in the target component of iccs.
to address these challenges we propose appcontext an approach that statically analyzes the security sensitive behaviors in an android app.
to extract activation events appcontext chains all iccs within the app and constructs an extended call graph ecg to infer activation events.
to compute context factors appcontext combines the control flows of all components from entry points triggered by activation events to the method calls that trigger security sensitive behaviors in a reduced inter procedure control flow graph ricfg and leverages information flow analysis to identify the environmental attributes that affect the control flows.
to leverage the extracted contexts for differentiating malicious behaviors and benign ones we transform these contexts as features and use machine learning techniques such as support vector machine svm to classify security sensitive behaviors as malware or benign ones.
we use machine learning techniques because the reasoning about the maliciousness of a behavior is vague and subjective by nature.
simply using a static threshold e.g.
the frequency of contexts to differentiate malicious and benign behaviors does not perform well because it is difficult to determine a proper threshold.
for many subtle cases machine learning techniques are desirable to detect malware by taking multiple factors into account and making decisions based on rich data sets statistically.
this paper makes the following main contributions an approach appcontext to detect malware based on the insight that the context of a security sensitive behavior is a strong indicator of the maliciousness of the behavior.
an abstraction to model the contexts of security sensitive behaviors based on the two unique characteristics of malware activation conditions and guarding conditions .
a static analysis technique for context extraction which accurately identifies activation conditions and guarding conditions for security sensitive behaviors.
three evaluations on android apps to demonstrate the effectiveness of appcontext.
ii.
b ackground android component.
android apps are composed of four types of components.
an activity represents a user interface.
a service represents a task being processed in the background.actionreceiver.onreceive date date new date if data.gethours date.gethours contextwrapper.startservice mainservice ... mainservice.oncreate dummymainmethod sendtextactivity .onclick splashactivity.oncreate smsmanager.sendtextmessage long last db.query lastconnecttime long current system.currenttimemillis if current last smsmanager.sendtextmessage db.save lastconnecttime current ... sendtextactivity .run mainservice.b contextwrapper.startservice a part of the moonsms s call graph b code snippet of moonsms s manifest file fig.
motivating example in moonsms app a content provider allows sharing of app specific or system data across apps.
a broadcast receiver is a component that receives broadcasted message objects named as intents.
apps specify which content provider they access by using uniform resource identifiers uri .
content providers may require that apps hold certain permissions to access the providers.
we name the content providers that require permissions as security sensitive content providers.
android permissions.
developers can restrict access to android components by using permissions.
a component protected by a permission can be accessed by only apps that have obtained that permission.
to access sensitive resources in a component an app must request corresponding permissions.
permissions are declared in the android manifest androidmanifest.xml .
at installation time android presents the list of permissions requested by the app.
users can either allow all permissions or give up installing the app.
intent.
a common way for android components to communicate with each other is to send intent messages.
an intent is a message that declares a recipient by an action string or specific component name and optionally includes data.
intents can be event notifications sent by the operating system to apps.
these intents are triggered by system events that can be sent only by the operating system.
permissions may be used to both restrict who may receive an intent sent by an app and restrict who may send intents to a particular app.
we name intents that require permissions to send or receive as security sensitive intents.
sending or receiving a security sensitive intent is a security sensitive behavior.
iii.
a m otivating example to illustrate our approach we use a simplified malware example named moonsms.
moonsms is a repackaged app that carries both benign functionality and injected malicious droiddream payloads.
the benign functionality provides a variety of festive greetings for sms messages.
thus it is rational that moonsms requests the send sms permission.
figure shows that smsmanager.sendtextmessage i.e.
an api method that uses the send sms permission is invokedunder three contexts.
each invocation of this method is a security sensitive behavior of the app.
the first invocation of smsmanager.sendtextmessage occurs when the user clicks the send button in an activity component named sendtextactivity .
when the send button is clicked its onclick event handler spawns a new thread that invokes smsmanager.sendtextmessage .
the second invocation of smsmanager.sendtextmessage occurs when the signal strength of the device changes.
when the signal strength changes the system broadcasts an intent containing the sig str action.
moonsms registers a broadcast receiver component named actionreceiver lines in figure b to receive this intent.
when this intent is broadcasted actionreceiver is activated and its onreceive method begins execution.
actionreceiver s onreceive method starts a service component named mainservice by invoking thestartservice api method when the current time is between pm and am which begins executing mainservice s oncreate lifecycle method.
finally mainservice s oncreate method invokes another method named b which calls smsmanager.sendtextmessage .
the third invocation of smsmanager.sendtextmessage occurs when moonsms is launched.
when the moonsms is launched its main activity component splashactivity lines in figure b begins execution in its oncreate lifecycle method.
splashactivity s oncreate method invokes smsmanager.sendtextmessage when the current time is at least hours after the lastconnecttime is saved in a database.
in the preceding example the first invocation is not malicious because reviewers can analyze the content on the screen and confirm that the security sensitive behavior is expected to occur.
however the second and third invocations cannot be justified by the functionality that moonsms is expected to provide.
by inspecting the behaviors we find that the second and third invocations are malicious because these invocations send sms to a confirmed malicious server.
this example demonstrates that the contexts of securitysensitive behaviors are essential to differentiate between benign and malicious behaviors especially when the benign functionality provided by apps may rationalize the requested permissions and the security sensitive method calls allowed by the requested permissions can also be used by malicious functionality.
appcontext focuses on exposing the contexts of security sensitive behaviors.
we refer back to this example in the rest of the paper to illustrate how appcontext formalizes the abstraction of contexts of security sensitive behaviors and extracts these contexts from app binary code.
iv.
c ontext of security sensitive behavior in this section we formally define the context of a securitysensitive behavior.
we consider a security sensitive behavior as an invocation of a security sensitive method under a certain context.
a security sensitive method is a method that meets at least one of the following three requirements permission protectedmethods.
some methods in the android api require permissions to be invoked.
such methods usually access securitysensitive resources and data the detailed list of the methods is specified in pscout .
the methods that is either a source method or a sink method output channel of an information flow.
an information flow consists of a source from which the security sensitive data may originate and a sink to which the data may be sent the detailed list of sources and sinks are specified in susi .
sources and sinks are not always protected by permission for example fileoutputstream.write is a sink method to write the data to a file but does not require android permissions to be invoked.
a permission protected method may not be a source sink method for example contextwrapper.setwallpaper is protected by permission set wallpaper but is neither a source nor a sink.
reflection methods and dynamic code loading methods .
resolving reflection or dynamic loading methods in static analysis is a known difficult problem with fundamental limitations .
for this reason we do not attempt to resolve these methods but rather treat them as being security sensitive.
in so we are being conservative because these methods may result in invoking other securitysensitive methods.
there are a few methods in the android api allowing apps to load and invoke code at runtime that has also been leveraged by existing malware a detail list is listed on our project website .
our definition of context definition .
includes two important characteristics that determine the invocations of security sensitive method calls activation events definition .
and context factors definition .
.
such definition represents a set of essential elements for decision making in app inspection.
the activation events are the external events that trigger the security sensitive methods .
the external events include ui events events triggered by interactions on apps graphical user interfaces system events events initiated by the systemstate changes such as receiving sms and hardware events events triggered by the interactions on the device interfaces such as pressing the home or back button .
activation events connect security sensitive behaviors to the behaviors initiator in the external environment e.g.
users or system as the events are triggered when the external environment changes or the mobile system reaches a certain state.
to infer activation events of security sensitive method calls we analyze the entry points e.g.
actionreceiver.onreceive andsendtextactivity .onclick in figure a of call graph that contains the security sensitive method calls.
in an android app not all entry points are triggered by activation events and some of entry points can be triggered only by inter component communications.
for example mainservice.oncreate is triggered by startservice in the component actionreceiver .
an analysis needs to trace back a chain of entry point methods executed before the invocation of the security sensitive methods to identify the entry points that can be used to infer activation events.
actionreceiver.onreceive mainservice.oncreate sendtextactivity .onclick splashactivity.oncreate smsmanager.sendtextmessage sendtextactivity .run mainservice.b fig.
ecg of cg shown in figure a to assist the analysis to locate entry points triggered by activation events we first define an extended call graph that connects all the iccs in an app.
definition .
.
anextended call graph ecg n e for an app pis a directed graph in which each node n2n denotes a method in p and each edge e a b 2edenotes either a calling relationship from atoborain one component acallsbin another component b. an entry point of the ecg is a node nethat has no incoming edges i.e.
for each nodes n2n e n ne 2e .
an extended call graph ecg is a call graph with edges representing iccs.
the entry point of ecg can be triggered by activation events.
for example figure shows part of moonsms s ecg.
compared to the corresponding call graph cg shown in figure a the ecg has an icc edge from actionreceiver.onreceive tomainservice.oncreate connecting the component actionreceiver to component mainservice .
ecg enables our approach section v to link the securitysensitive method call smsmanager.sendtextmessage to the entry point actionreceiver.onreceive and the activation event signal strength changes can be further inferred from the entry point.
we next define the activation event.
definition .
.
anactivation event actne nkof a method callnkis the event that triggers the entry point nein an extended call graph ecg n e and there exists a call pathp nen1n2 nksuch that e ne n1 2eand for i k k e ni ni 2e.
activation events are identified by their action types which can be inferred from entry points.
specifically the action types of ui events are their corresponding operation types e.g.
click long click the action types of system events are state changes that trigger the events e.g.
signal strength changes and the action types of hardware events are the component lifecycle phases that the events lead to e.g.
onpause leaving the component onresume re entering the component .
the context factors are environmental attributes that control the execution of security sensitive method calls .
the values of context factors can affect control flows from entry points triggered by activation events to security sensitive method calls.
to precisely describe the control flows in an android app we adopt and simplify the definition of an inter procedure control flow graph icfg from harrold et al.
and define areduced inter procedure control flow graph ricfg .
definition .
.
given an icfg an entry point ne and a method call nk a reduced inter procedure control flow graph ricfg ne nkis a subgraph of icfg that contains all the paths from netonk.for example figure a shows an ricfg ne nkwhere the entry point neisactionreceiver.onreceive in the ecg shown in figure and the security sensitive method call nk issendtextmessage .
apps usually obtain the values of the environmental attributes by using certain java android api methods e.g.
currenttimemillis getinstalledapplications .
we denote such api methods as environment property methods .
we next define control dependence among statements and use control dependence and environment property methods to define context factors.
definition .
.
in a program if a statement nscontrols whether a statement nis executed niscontrol dependent on ns.
definition .
.
given an ricfg ne nkand a set of conditional statements sne nkinricfg ne nkthatnkis control dependent on a context factor fne nk siis an environmental attribute whose value is used in a conditional statement si where si2sne nk.
the context factors are computed by analyzing the information flows data dependence from environment property methods to conditional statements that control the execution of security sensitive method in the ricfg.
based on these definitions we formally define a context definition .
.
acontext cne nkfor method call nkis a tuple consisting of the activation event actne nkand the set of context factorsffne nk sijsi2sne nkgwhere sne nkis the set of conditional statements in ricfg ne nk.
v. a ppcontext we next present appcontext our approach that extracts the values of elements in the context definition defined in section iv.
first appcontext constructs a call graph from an apps binary and performs static analysis to locate its securitysensitive behaviors.
next appcontext identifies activation events by the entry points of the computed call graph and converts the call graph into an ecg by using icc information.
then appcontext constructs ricfgs for each securitysensitive method calls in the ecg and traverses each ricfg to find conditional statement sets.
next appcontext finds context factors whose values are used in conditional statements via information flow analysis and then generates the complete contexts using identified activation events and context factors.
finally appcontext classifies the security sensitive behaviors by using the features of the extracted contexts.
a. locating security sensitive behaviors appcontext locates security sensitive method behaviors by constructing call graphs and locating security sensitive method calls within the call graphs we leverage flowdroid s call graph building please check their paper for details .
security sensitive method calls are divided into three groups by the information used to identify them as illustrated below.
first the permission protected api methods source or sink methods reflection methods and dynamic code loading methods are all identified by using a method signature.
if amethod matches a method signature in this group appcontext extracts and saves the method name permission and the entry points for later analysis.
second the methods that read or write security sensitive content providers are identified by the uris of the content providers.
to access a content provider the uri designating the recipient content provider is passed to a contentresolver class section ii .
only the method calls using the uris of security sensitive content providers are security sensitive.
the list of uris designating security sensitive content providers is provided in pscout .
if the uri parameter of a method is in the uri list appcontext saves the uri permission and the entry points for later analysis.
finally the methods that send or receive security sensitive intents are identified by the intent action strings.
an app can call sendbroadcast orregisterreceiver with intent action strings to send or receive specified intent messages.
the list of intent action strings requiring permissions to send or receive is provided in pscout .
if the intent parameter in the method is in the list appcontext saves the intent action string permission and the entry points for later analysis.
b. identifying activation events as discussed in section iv the activation events are represented by their action types.
action types can be extracted from the app s entry points.
appcontext identifies activation events by analyzing two types of entry points.
for system events handled by intent filters and hardware events their entry points are lifecycle methods .
if the components of the lifecycle methods have intent filters specified for system intent messages the entry points are invoked by system events.
otherwise the entry points are invoked by hardware events.
for both system events captured by event handling methods and ui events their entry points should be event handling methods .
algorithm presents the analysis used to extract activation events for the given security sensitive method calls.
the analysis returns a list of activation events e for each securitysensitive method call.
the analysis takes security sensitive method calls and their corresponding entry points as input.
an entry point belongs to one of two above mentioned categories lifecycle methods and event handling methods.
for the first category of entry points lifecycle methods the analysis first decides whether the activation event could be a system event captured by intent filters line .
if the component that the lifecycle method belongs to has intent filters for each intent filter the attributes in the intent filters are used to represent the activation events of the contexts.
for each activation event appcontext create a tuple and saves activation event along with the method call and the entry point in the tuple to the elist for later analysis line .
the analysis then decides whether the lifecycle method can be invoked by icc calls e.g.
startservice sendbroadcast line .
if there are method calls invoking the lifecycle method the analysis adds icc edges to the cg line and replaces entry points of the icc calls with the original entryalgorithm identifyactivationevent inputs b a set of contexts without context factors and activation events i.e.
tuples consisting of security sensitive method calls and their entry points in call graphs cg the call graph of the whole app a app binary code outputs e a set of contexts without context factors i.e.
tuples consisting of security sensitive method calls their activation events and corresponding entry points ecg the extended call graph of the whole app 1begin 2e foreach b2b do entrypoint getentrypoint b ifislifecyclemethods entrypoint then ifhasintentfilters entrypoint a then system events by intent filters filters getfilters entrypoint a foreach filter2filters do e addfilter b filter end end icc findiccs cg entrypoint ificc6 then adding icc edges cg add icc recursively invoke the algorithm e replaceentrypoint b cg e addall identifyactivationevent e cg a end else hardware events e addlifecycle c end end ifiseventhandler entrypoint then 23e addhandler c end end ecg cg returne 28end points line .
then algorithm is invoked recursively with the augmented cg i.e.
ecg and new entry points to cover all activation events.
the activation events are then saved in the tuples for later analysis line .
if the lifecycle method cannot be invoked from app code then the security sensitive method call is triggered by hardware events.
we use the attributes of the lifecycle methods to represent the activation events and save the activation events in the tuples for later analysis line .
for the second category of entry points event handling methods the analysis uses the attributes of the ui eventhandling methods or system event handling methods to represent the activation events and save the activation events in the tuples for later analysis line .
c. extracting context factors after computing the ecg and activation events for a security sensitive method call appcontext constructs and traverses the ricfgs to extract context factors.
as shown in section iv the ricfgs need to be constructed based on the ecg.
thus for each security sensitive method call appcontext identifies the ecg s entry points that can lead to the invocation of the method.
then appcontext obtains the icfg of the app by connecting the cfg of each node on the ecg.
based on the icfg appcontext constructs the ricfgs actionreceiver.onreceive mainservice.oncreate entry if data.gethours date.gethours startservice mainservice date date new date b mainservice.b smsmanager.sendtextmessage true actionreceiver.onreceive mainservice.oncreate mainservice.b smsmanager .
sendtextmessage a b fig.
an ricfg a and its corresponding ecg subgraph b if data.gethours date.gethours if current last date date new date db.query lastconnecttime system.currenttimemillis conditional stmt information flow environment property method calendar systemtime database context factors smsmanager.sendtextmessage fig.
context factors of moonsms in figure from each entry point to the security sensitive method call.
for each ricfg appcontext traverses the ricfg to identify the conditional statements on which the security sensitive method is control dependent.
finally appcontext saves the set of extracted conditional statements with the security sensitive method call and the corresponding activation events.
figure presents the analysis used to extract context factors.
for each conditional statement extracted in the previous step appcontext tracks the information flow from the environmentproperty methods section iv to the conditional statement.
the sources of the information flows indicate which context factors control the invocation of the security sensitive behaviors.
in the moonsms example the context factors are calendar information system time and database information.
by combining the context factors with corresponding activation events of the security sensitive method calls appcontext generates the complete context tuples.
d. classifying security sensitive behaviors leveraging the extracted contexts to classify securitysensitive behaviors as malicious and benign we formulate the detection of malicious behaviors as a classification problem.
appcontext leverages a supervised learning approach to train a classifier to compute the conditional likelihood of a securitysensitive behavior being malicious versus benign given context features.
specifically appcontext uses a support vector machine svm as the classifier because svm is very resilient to over fitting even with a large number of values.
classification is performed using a set of features.
a feature is a function that associates a training example with a value i.e.
a function evaluates a certain single domain specific criterion for the example.
appcontext leverages the list of features in table i for classifying security sensitive behaviors.
the list consists of the features about the security sensitive behavior itself and the features describing the contexts of the behavior the activation events and the context factors.
withtable i f eature categories for classification features of behavior information permission security sensitive method call features of activation event hardware event system event ui event features of context factors list of environmental attributes this list of features appcontext generates a feature vector for each context of a security sensitive behavior.
table ii shows an example of feature vectors.
for features describing behavior information i.e.
permission method call the feature values are the name of the permission or method.
for methods such as source sink reflection or dynamic loading methods that do not have corresponding permissions i.e.
do not require permissions to be invoked the permission names are predefined strings such as source sink reflection dynloading .
for features describing activation events the feature values are the action types section iv of the events.
for features describing the context factors f1 f2 f the feature values are either the context contains the context factor or the context factor is not part of the context .
vi.
t ool implementation in this section we briefly illustrate implementation details of appcontext.
more information can be found on our project website .
static analysis .
appcontext leverages soot as its underlying static analysis framework.
appcontext uses dexpler to convert dalvik bytecode into the jimple intermediate representation from which soot constructs its call graph.
appcontext also leverages flowdroid a static taint analysis tool based on soot to provide a precise modeling of the android component lifecycles and callback methods.
context extraction .
to extract contexts appcontext uses the permission mappings provided by pscout as input and performs the analysis discussed in section v. since appcontext relies on pscout s mappings the soundness and completeness of the mappings may affect the number of false positives and false negatives produced by appcontext.
vii.
e mpirical evaluations to evaluate the effectiveness of appcontext and using context information to detect malware we have conducted three evaluations.
we seek to answer the following research questions rq1 how effective is appcontext in identifying malware?
how does appcontext compare to the approach without context information in terms of the effectiveness of malware identification?
rq2 how do activation events and context factors in our context definition contribute to the effectiveness of malware identification?
rq3 how accurate is our static analysis in inferring contexts?a.
study subjects our subject apps include android apps in total benign apps malicious apps and open source apps .
to collect malicious apps we randomly select malicious apps from a malware dataset collected by zhou et al.
malicious apps from the virusshare dataset and malicious apps from the contagio dataset .
we also select malicious apps identified by virustotal that were posted on google play in but were later removed by google.
our final malware dataset contains malicious apps.
these malicious apps cover the majority of existing android malware families from to which are rapidly evolving to circumvent detection by various mobile security software.
to collect benign apps we download the top apps for each category from google play as of january .
because flowdroid runs out of memory on large apps to ensure that enough apps can be analyzed without errors for each category we randomly select apps under mb and apps without size restriction from these top apps.
we also exclude the apps identified as malware by virustotal and the apps that cause flowdroid to throw exceptions or timeout.
the final benign dataset contains apps.
to collect open source apps we randomly select apps from f droid .
among these apps we exclude apps that do not have security sensitive behaviors.
our open source dataset contains apps.
we apply appcontext to extract contexts from the subject apps.
appcontext runs on a desktop with .
ghz intel core i7 processor and gb of memory.
we set the timeout of appcontext as minutes and appcontext exceeds the timeout limit for apps which are then excluded from the later study.
for the apps being used as subjects appcontext takes on average seconds to finish the analysis of one app.
b. rq overall effectiveness to answer rq1 we label the extracted contexts from the subject apps and perform a ten fold cross validation to evaluate the overall effectiveness of appcontext.
to make a fair comparison with the existing approaches that do not use context information we apply the supervised learning approach using all the features of appcontext and then apply the same supervised learning approach using the features containing only the behavior information shown in table i i.e.
security sensitive method calls and permissions .
the results are shown in table iii and table iv respectively the second and third rows .
labelling security sensitive method calls.
because there is no ground truth for determining a security sensitive method call as malicious or benign as a best effort solution we systematically label security sensitive method calls as malicious based on the existing malware signatures .
specifically we label a security sensitive method call as malicious if the class package name of the method call matches any class package name that we collected from thetable ii f eature vectors for moon sms example permission method call hardware system ui f1f2f3 f4 f5 f6...f142 send sms sendtextmessage n a sig str n a ... send sms sendtextmessage enterapp n a n a ... send sms sendtextmessage n a n a click ... f3 calendar f4 system time f5 database existing malware signatures.
we label the rest of securitysensitive method calls as benign.
we collect class package names from malware signatures of three sources.
apposcopy includes a list of semantic signatures for existing malware along with a tool to check apps binaries against the signatures.
we run all of the subject apps using a tool that we reproduced based on apposcopy and record the names of the packages and classes that match the signatures.
we use class names in androguard s signature database .
the virustotal service inspects malware by using a number of antivirus software and reports the family that the malware belongs to.
we identify the malware family that each of our malicious apps belongs to using virustotal and we identify the package class names of the malicious payloads from the online technical reports provided by the antivirus software vendors for each malware family.
cross validation.
we use the labeled behaviors i.e.
method calls both as training and test data in a ten fold crossvalidation which is a standard approach for evaluating machine learning techniques.
it works by randomly dividing all data into equally sized buckets training the classifier on of the buckets and classifying the remaining bucket for testing.
this process is repeated times with each of the buckets used exactly once as the testing data.
we report the average precision and recall in table iv.
results.
we evaluate the effectiveness of appcontext in identifying both malicious behaviors and malicious apps.
an app is identified as a malicious app if any of its securitysensitive method calls is identified as malicious.
table iii and table iv show that appcontext the row of complete context has higher precision and recall in both identifying malicious behaviors and identifying malware than the existing approach that does not use context information the row of behavior information .
we next present two major reasons that cause such misidentification.
first appcontext misidentifies a number of securitysensitive method calls triggered by ui events and without context factors.
this result suggests that compared to system events and hardware events ui events have less indication of the maliciousness of a security sensitive method call.
second a few method calls are incorrectly identified as malicious because we mistakenly label similar benign behaviors as malicious.
in malicious payloads a small number of security sensitive method calls may not have malicious intentions such as mediaplayer.pause protected by the wake lock permission in malicious payloads.
however as we label all security sensitive method calls in a malicious payload appcontext incorrectly identifies such benign method calls as malicious.
this result suggests that the identification resultstable iii m alicious security sensitive behaviors identified by appcontext features used p r complete context c .
.
behavior information b .
.
activation events e .
.
context factors f .
.
b e .
.
b f .
.
e f .
.
table iv i dentification of malware by appcontext features used tp fp fn p r complete context c .
.
behavior information b .
.
activation events e .
.
context factors f .
.
b e .
.
b f .
.
e f .
.
tp true positive fp false positive fn false negative p precision r recall can be improved if the training set for the classifier is labeled more accurately.
we also evaluate the effectiveness of appcontext in identifying malicious reflective calls or dynamic code loading method calls.
appcontext shows high precisions and recalls in identifying malicious method calls.
appcontext correctly identifies out of malicious method calls but also misidentifies benign method calls as malicious i.e.
.
precision .
recall .
appcontext correctly identifies out of malicious dynamic code loading method calls but misidentifies benign method calls as malicious i.e.
.
precision .
recall .
for all malicious apps using root exploits which are commonly launched by dynamic code loading only one malicious app i.e.
asroot was not identified by appcontext.
as the detailed behaviors of reflective calls and dynamically loaded code were unobtainable in static analysis such results show the advantage that appcontext can differentiate benign and malicious securitysensitive method calls without knowing the detailed behaviors being triggered.
c. rq2 effectiveness of activation events and context factors rq2 evaluates the effectiveness of both activation events and context factors in identifying malicious app behaviors.
to answer rq2 we use only partial features listed in table i to train the classification model.
we apply the same supervised learning approach used in rq1 with the features being the activation events the row of activation events context factors the row of context factors behavior information and activation events the row of b e behavior information andcontext factors the row of b f and activation events and context factors the row of e f respectively.
the results are shown in table iii and table iv.
results.
we evaluate the effectiveness of activation events by comparing the result of the analysis using activation events the rows of complete context b e and e f to the result of the analysis not using activation events the rows of b f b and f in table iii and table iv.
the comparison shows that adding the features of activation events to the analysis improves both the precision and recall of the identification results.
we find that the improvements are mainly because activation events help effectively identify malicious method calls that have no context factors.
the activation events in some of these malicious method calls are often used by benign apps to update the ui to inform users that certain events have occurred.
for example ums disconnected is used to inform users that the device has been disconnected from usb mass storage sig str is used to inform users that the phone signal strength changes and action power connected is used to inform users that external power has been connected to the device.
because these events are seldom used in benign apps to trigger security sensitive method calls the activation events can effectively differentiate benign and malicious behaviors with no context factors.
we also evaluate the effectiveness of context factors by comparing the results of the analysis using context factors the row of complete context b f and e f with the result of analysis not using context factors the row of b e b and e .
the result shows that the analysis using context factors has relatively higher precisions over for identifying malicious behaviors and around for identifying malware .
we find that the improvement in the precision is mainly because context factors effectively help identify the malicious behaviors whose activation events are ui events.
we also find that context factors can disambiguate the malicious and benign intentions for certain vague cases when security sensitive method calls are protected by commonlyused resources e.g.
internet .
for example we find that some of benign apps and malware will both connect to servers url.openconnection after the apps start and thus the activation events and behaviors for both apps are the same.
however the context factors of malware include data from an intent message intent.getextras and data from the internet url.openstream suggesting that whether the apps connect to the server or not is determined by whoever sends the intent message or the internet data.
such context factors demonstrate the command control nature of certain families of malware.
in addition context factors also reflect controls of securitysensitive method calls in benign apps.
for example we find that a few benign apps and malware obtain device information telephonymanager.getdeviceid etc.
after the apps start.
the difference between two types of apps is that the benign apps invoke getdeviceid only when auto logins are successful i.e.
the context factors for getdeviceid include information from the database or the internet .
but malware directly sends device information to the server i.e no context factors .table v e ffectiveness of context extraction app context verified context time sec finally we further evaluate the effectiveness of contexts by running analysis using features of activation events and context factors the row of e f .
the precision and recall of the analysis are comparable as the precision and recall of the analysis using complete context.
such results suggest that contexts can identify a number of malicious method calls without knowing the detailed behaviors being triggered consistent with the analysis result for behaviors that invoke reflection or dynamic code loading methods.
both results indicate that the maliciousness of a security sensitive method call is more closely related to the behavior s intention reflected via contexts than the type of the security sensitive resources that the behavior accesses.
d. rq3 accuracy of static analysis to evaluate the effectiveness of the extracted contexts we dynamically verify whether the security sensitive method is invoked by triggering the activation events and configuring context factors based on the contexts.
the execution path triggered by the activation events may vary when the context factors are assigned different values.
in this evaluation we use only open source apps as the subjects.
the main reason is that these apps come with source code which can be used to easily infer the correct values of context factors in controlling the execution of the security sensitive method calls.
appcontext is applied on open source apps to extract contexts and the analysis time is logged.
to verify the correctness of context factors we analyze the source code to check whether a security sensitive method call is control dependent on each context factor.
if the control dependence exists we determine the values of the context factors that lead to the execution of the security sensitive method call.
we then configure the external environment based on the inferred values of context factors and trigger the activation events of security sensitive behaviors of these apps.
we use the activity manager through the android debug bridge adb to simulate system events and manually simulate hardware and ui events.
we configure the values of each context factor by changing configuration of emulators.
then we use the profiler of the activity manager to log the executions of the apps.
to monitor the execution traces we start the profiler before firing the activation events and stop the profiler seconds afterwards.
the preceding evaluation process has some limitations.
the profiler cannot trace the invocations of the oncreate orondestoy methods because the profiling must be started after the creation of an app s process and be stopped before the destruction of the app s process.
we also exclude events that cannot be simulated through adb such as error events e.g.
triggering theonerror method in mediaplayer.onerrorlistener and the context factors whose value we cannot manipulate such as data from url connection .results.
table v shows our evaluation results.
among the generated contexts we are able to confirm contexts i.e.
.
accuracy .
six contexts cannot be verified because the activation events could not trigger the security sensitive method calls.
the context factors of all the contexts whose activation events could trigger the security sensitive method calls are accurate.
the average analysis time is seconds which is acceptable for the app reviewing process.
note that the evaluation result is conservative since the inferred values for context factors may not be accurate.
viii.
t hreat to validity threats to external validity .
due to the current limitation in our implementation and testing environment our dataset consisted of randomly selected apps that were smaller than 5mb which may not be representative of the entire market.
we plan to address this limitation in the future and include market apps whose sizes are larger than 5mb to further reduce the threats.
the subjects from malware datasets can be biased by their selection methodologies we chose our malware set from different sources to alleviate the bias in the subject selection.
threats to internal validity .
inaccuracies in labeling behaviors are inevitable due to the lack of ground truth for identifying malicious behaviors.
in addition there may be human errors in collecting statistics and studying the evaluation results.
these threats are mitigated by double checking all manual work and ensuring that the results were agreed upon by at least two authors.
ix.
r elated work contexts of permission uses.
pegasus constructs permission event graphs using static analysis to model the effects of the event system and api semantics and performs model checking to enforce the policies specified by users.
however specifying these policies requires that users have established knowledge about the expected behavior functionality of the app and an understanding of the android platform.
our approach complements pegasus by providing the contexts which can be used to construct pegasus policies.
appintent presents a sequence of gui events that lead to data transmissions and let analysts decide whether the data transmissions are intended.
appintent handles only app behaviors activated by gui events while our approach analyzes a more comprehensive set of contexts e.g.
receivers and background services and can complement their approach to handle data transmissions that are not triggered by sequences of gui manipulations.
asdroid detects stealthy app behaviors by identifying mismatches between api invocations and the text displayed in the guis.
our approach focuses on the events that trigger app behaviors rather than the textual analysis of the guis.
since app behaviors can occur without displaying a gui the textual analysis of guis alone is insufficient to detect all stealthy app behaviors.
droidapiminer identifies malicious apps by performing frequency analysis of api invocations within a set of benign and malicious apps toextract the features of malware and uses machine learning to determine the most relevant features.
our approach focuses on what causes security sensitive api calls to be used rather than the pattern of api calls that are used.
whyper examines whether app descriptions provide any justification for the app s permission uses.
whyper focuses on why apps request permissions while our approach focuses on how apps actually use the requested permissions.
risk ranking and certification of apps.
peng et al.
present the risk information of an app compared to other apps by using probabilistic generative models to calculate risk scoring of the app.
mast triages android apps by analyzing features extracted from the apks.
mast uses machine learning techniques to measure the correlation between features and directs malware analysis resources to the apps that have the greater potential of risks.
kirin performs lightweight certification of apps by identifying dangerous app configurations against a set of security rules.
these approaches leverage various kinds of features or configurations in apps to identify potential risks.
unlike these approaches that present the risk scores or ranking for users our approach analyzes the bytecode of apps to extract the contexts of permission uses.
however our approach can complement risk ranking and certification techniques by providing the extracted permission contexts as another metric for their evaluation.
malware detection.
our approach complements existing malware detection analysis by identifying contexts that indicates the intentions of data uses.
there are various approaches that perform analysis to detect malicious behaviors such as dynamic taint analysis language based information flow static analysis and bayesian classification .
however these approaches are concerned about how privacy sensitive data protected by permissions are used while our approach provides the contexts under which the permissions are triggered.
x. c onclusion we have presented appcontext an approach based on an abstraction that extracts and transforms the context information into a set of essential elements to differentiate benign and malicious behaviors.
in our evaluations appcontext correctly identifies out of malicious apps with .
precision and recall.
our evaluation results suggest that the maliciousness of a security sensitive behavior is more closely related to the behavior s intention reflected via contexts than the type of the security sensitive resources that the behavior accesses.
acknowledgment this material is based upon work supported by the maryland procurement office under contract no.
h98230 c .
this work is also supported in part by nsf grants cns1253346 cns cns cns ccf1349666 ccf ccf and ccf and a google faculty research award.