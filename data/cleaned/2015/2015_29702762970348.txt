migrating cascading style sheets to preprocessors by introducing mixins davood mazinanian nikolaos tsantalis computer science and software engineering concordia university montreal canada d mazina tsantalis cse.concordia.ca abstract cascading style sheets css is the standard language for styling web documents and is extensively used in the industry.
however csslacks constructs that would allow code reuse e.g.
functions .
consequently maintaining csscode is often a cumbersome and error prone task.
preprocessors e.g.
lessandsass have been introduced to fill this gap by extending csswith the missing constructs.
despite the clear maintainability benefits coming from the use of preprocessors there is currently no support for migrating legacy csscode to preprocessors.
in this paper we propose a technique for automatically detecting duplicated style dec larations in csscode that can be migrated to preprocessor functions i.e.
mixins .
our technique can parameterize differences in the style values of duplicated declarations and ensure that the migration will not change the presentation semantics of the web documents.
the evaluation has shown that our technique is able to detect of the mixinsthat professional developers introduced in websites and style sheet libraries and can safely migrate real csscode.
ccs concepts software and its engineering software maintenance tools maintaining software keywords cascading style sheets refactoring duplication migration .
introduction cascading style sheets is one of the three fundamental technologiesinfront endwebdevelopment alongwith html andjavascript whichisusedfordefiningthepresentation of documents written in a markup language e.g.
html .
currently cssis used in more than of top million websites in the alexa ranking and by more than of front end web developers .
recently cssstarted being used in a wider spectrum of application domains includingmobile app ui design e.g.
apache cordova adobe phonegap desktop app styling e.g.
winjs gtk and integrated development environment theming eclipse4 css .
despite its popularity developing and maintaining css code is a cumbersome task .
among others two main reasons for this complexity are the inherent limitations of the language to support reuse and the lack of well documented and empirically validated best practices .
as an example in cssthere is very limited support for constructs that can facilitate the dry don t repeat yourself principle since functions and variables are not supported.
consequently style declarations i.e.
statements in css that define a style like font weight bold are extensively duplicated in csscode.
in a previous work we found that of cssstyle declarations are duplicated in modern web applications.
this extensive duplication can definitely impose high development and maintenance costs.
csspreprocessors have emerged as the de facto solution to complement vanilla cssby adding the missing constructs which are available in traditional programming languages e.g.
variables and functions and thus expedite the development and maintenance of style sheets.
the use of preprocessors is a trend in the industry and leading web companies have already adopted them.
some examples of popular preprocessors are less used by twitter sass google closure style sheets and stylus.
despite the gradual adoption of preprocessors in the web development community thereisstillalargeportionoffront enddevelopers and web designers using solely vanilla css.
an online poll with nearly responses from web developers revealed that of them develop only in vanilla css mostly because they are not aware of preprocessors.
therefore there is a large community of web developers that could benefit from tools helping them to automatically migrate their vanilla csscode to a preprocessor of their preference.
in addition the community of csspreprocessor developers could benefit from tools helping them to utilize more effectively the features offered by the preprocessors.
as a matter of fact in this study we found several cases where professional developers under utilize preprocessors.
this is the first work to investigate the automatic extraction of duplicated style declarations in css into functionlike constructs in csspreprocessors i.e.
mixins enabling thereuseof existing csscode.
using mixinscan also improve the readability of style sheets by assigning descriptive names to them.
according to our previous study developers introduce mixinsmostly for reusing code in style sheets of the mixinswere called more than once in the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
code base of each project but also for breaking long style rules in smaller code fragments or simply improving code readability.
the proposed approach for abstracting duplicated style declarations to mixinsis one of the fundamental requirements for developing a full fledged recommendation system that can help developers to migrate existing css code to preprocessors or even improve the maintainability of a preprocessor code base by eliminating duplication.
this work makes the following contributions we propose a method for detecting opportunities to automatically extract mixinsfrom existing csscode.
the approach is preprocessor agnostic i.e.
it is applicable for allcsspreprocessors supporting the notion of mixins we propose a method for assuring that the presentation semantics of thecsscode are preserved after migration we conduct an empirical study with real websites and style sheet libraries using preprocessors to verify the correctness and effectiveness of our approach.
.
preliminaries .
the css language style sheets let developers apply styles to some elements of one or more target documents e.g.
making all hyperlinks in anhtmlpage blue and under lined .
csshas a very simple syntax as shown in figure .
style declarationselector style propertiesstyle values p font weight bold border bottom solid 1px ccc figure a style rule in css syntax astyle rule i.e.
rule set is a fundamental building block ofcssfiles.
it consists of a selector which defines the elements of the target documents to be styled e.g.
pfor selecting all paragraphs .
inside the body of a style rule there are some style declarations each of which assigns some style value to astyle property e.g.
assign style value bold to property font weight to make the text of the selected elements bold faced .
specificity and cascading incss when two or more different style declarations assign a value to the same property of a dom element in the target document the web browser has to decide which style declaration has a precedence over the others.
in such a case the style declaration belonging to a style rule with a more specificselector wins i.e.
its style value overrides the value of the other declarations .
forinstance selector aselectsallhyperlinkelements while selector p aselects only the hyperlink elements which are children of paragraph elements aandpare both css predefined selectors selecting the a and p tags in target htmldocuments respectively .
thus the style declarations inp awill override the ones in a because the latter is more specific than the former.
on the other hand in the case that two style rules have selectors with the same specificity the order of style rules will decide the winning style declaration i.e.
the style declaration in a style rule appearing later in the cssfile will override the style values of the previous declarations the socalledcascading feature of css .
however developers can use the!important rule e.g.
color red !important toforceadeclarationtoalwaysoverrideotherdeclarationswith the same property regardless of the specificity and location of the style rule it belongs to.
using !important is a bad practice in style sheet development but style sheet developers considerably use it .
as we will see when detecting mixinmigration opportunities the use of !important has implications that should be taken into account.
.
css preprocessors as mentioned before csspreprocessors were introduced to address the limitations associated with css.
preprocessorsareactuallysource to sourcecompilers i.e.
transpilers .
in other words they compile the style sheet written in their syntax to vanilla css allowing the clients to directly use the generated style sheets without requiring any server side processing.
this transpilation can be also performed on demand i.e.
when a user requests to view a web page.
most of the csspreprocessors extend the syntax of css to make easier their adoption by cssdevelopers.
there is a setofcommonfeaturesthatalmostallpopularpreprocessors support.
because of space limitation we cannot describe all these features in this paper the reader may refer to or the documentation of csspreprocessors .
however we need to briefly mention the two main features of css preprocessor languages that can be used for eliminating duplicated style declarations in style sheets extend is a mechanism that enables the reuse of style declarations across style rules.
the extending style rule inherits all style declarations of the extended style rule and can optionally override some of the inherited style declarations in order to change their style values this mechanism is similar to inheritance in the object oriented paradigm.
mixinis a function like construct containing a set of style declarations optionally with parameterized style values.
a mixinis usually called inside the body of a style rule or another mixinby passing style values as arguments for its parameters.
a mixinparameter may have a default value allowing to omit the corresponding argument.
inthecaseofexactlyduplicatedstyledeclarationsacrossdifferent style rules one may use either the extendconstruct or a parameterless mixinfor eliminating duplication.
however our previous study revealed that developers prefer to use parameterless mixinsover the extendconstruct of the analyzed websites exclusively used parameterless mixins whileonly9 usedthe extendconstruct .
thispreferenceto mixinsisprobablyduetothe styling bugs thatmay be caused by the incautious use of the extendconstruct .
indeed the grouping of selectors in css or equivalently the use of the extendconstruct in preprocessors might change theorder dependencies that exist among the style rules and thuschangethepresentationofthetargetdocument i.e.
introduce a styling bug .
additionally mixinsprovide a more powerful reuse mechanism by allowing to parameterize the values of style properties.
therefore in this work we propose an approach for detecting mixinopportunities incsscode that can help developers to easily migrate to a preprocessor of their preference.
.
mixins csspreprocessor mixinsare equivalent to functions in traditional programming languages and usually contain a set of style declarations or other mixincalls.
the values of these declarations can be literals e.g.
color or numeric 673values expressions involving variables or calls to csspreprocessor built in functions.
just like functions mixinscan have one or more parameters which can be used in the place of style declaration values.
figure 2a shows a preprocessor code snippet in lesssyntax containing three style rules namely.s1 .s2and.s3 and a mixindeclaration .m1 which is called in style rules .s1and.s2.
when the piece of preprocessor code shown in figure 2a is transpiled to css the code shown in figure 2b is generated.
as it can be observed the mixincalls are replaced with the style declarations of the called mixin and the parameterized values are replaced with the arguments passed in the corresponding mixincall.
mixin declarationmixin calls .s1 text align center .m1 8pt tahoma 100px .s2 float left .m1 10pt arial 70px .s3 float right font 9pt tahoma .m1 fonts fontn colw font fonts fontn moz columns colw columns colw a preprocessor code .s1 text align center font 8pt tahoma moz columns 100px columns 100px .s2 float left font 10pt arial moz columns 70px columns 70px .s3 float right font 9pt tahoma b genereated css figure mixin example in figure 2a the mixin.m1contains three style declarations assigning values for properties font moz columns andcolumns.
the two latter properties are called vendorspecificproperties and are used to style the same property for different web browsers e.g.
the ones with moz prefix will only work for mozilla firefox.
web browsers usually support this kind of properties before they are fully standardized because the standardization process is time consuming.
as a result developers have to repeat the declaration of the same property with different vendor prefixestoachieveaconsistentpresentationacrossmultipleweb browsers.
indeed we previously found that developers tend to usemixinsfor grouping style declarations associated with vendor specific properties .
.
automatic extraction of mixins our approach for detecting mixinmigration opportunities isbasedoneliminatingduplicationatthelevelofstyle dec larations and consists of four main steps which are explained in the following subsections.
.
grouping declarations for extraction the first step of our approach is to find sets of style rules sharing one or more style declarations styling the same properties.
the tuple an bracketle ts p an bracketri ht wheresis a set of style rules sharing a set of style properties pis considered as a mixin migration opportunity .
for example to reverse engineer the csscode of figure 2b to the preprocessor code of figure 2a we would need to group the declarations corresponding to font columns and moz columns properties from style rules .s1and.s2 and extract these declarations into mixin.m1after parameterizing the property values being different.
in this case s1 .s1 .s2 andp1 font columns moz columns .there are however other mixinmigration opportunities in the code fragment of figure 2b e.g.
s2 .s1 .s2 .s3 andp2 font .
it should be emphasized that for a given property p p the grouped style declarations should have the same importance.
as mentioned using the !important rule makes a declaration to have precedence over other declarations assigning a value to the same property.
as a result the importance of the involved declarations should be kept intact when forming a mixin to make sure that the presentation of target documents will be preserved after migration.
consequently we avoid the grouping of declarations having a different importance i.e.
either all or none of the grouped declarations may use the !important rule .
anaiveapproachforfindingtherepeatedpropertieswould be toexhaustively generateallpossible combinationsofstyl e properties and then examine if they appear together in two or more style rules.
however this would certainly lead to a combinatorial explosion due to the large percentage of duplication in cssfiles.
according to on average of the style declarations in style sheets are duplicated at least once i.e.
they share the same property and value with another style declaration .
for detecting mixinmigration opportunities the constraint that property values should be identical or equivalent is not necessary since mixinsallow the parameterization of differences in the property values.
this results to an even larger percentage of declarations that can be potentially grouped to form a mixin making the exhaustive generation inapplicable.
we managed to overcome this issue by treating the initial problem as a frequent itemset mining problem .
in the dataminingliterature thereareefficientalgorithmsforfindingthesetsof itemsinadatabase i.e.
itemsets thatappear together insor more transactions where sis theminimum support count .
in our approach we treat a style sheet as a transactional database.
each style rule is a transaction and each property corresponding to a style declaration is an item.
therefore a frequent itemset is a set of propertiespthat appear together in a set of style rules s where s s. in our work we set sto two i.e.
the smallest possible value .
we selected this value because we have empirically shown that the median number of times a mixinis called in real world csspreprocessor code is two .
we adopted the fp growth algorithm because it is considered efficient and scalable.
applying the fp growth algorithm to the csscode of figure 2b will result in the output shown in table .
table frequent itemsets of style properties p s p .s1 .s2 moz columns .s1 .s2 columns .s2 .s3 float .s1 .s2 .s3 font .s1 .s2 columns moz columns .s1 .s2 columns font .s1 .s2 moz columns font .s2 .s3 font float .s1 .s2 font columns moz columns each row itemset in table constitutes a separate mixin migration opportunity.
the mixin.m1in figure 2a corresponds to the last itemset of the table and it subsumes the first three itemsets with p which in turn subsume the two first itemsets with p .
.s1 float left will change transform border f00 1px solid .s2 color red border dotted red thin a original csscode .mixin v1 v2 v3 border v1 v2 v3 .s1 float left will change transform .mixin f00 1px solid .s2 color red .mixin dotted red thin b fine grained parameters .mixin values border values .s1 float left will change transform .mixin f00 1px solid .s2 color red .mixin dotted red thin c coarse grained parameter .mixin style border f00 1px style .s1 float left will change transform .mixin solid .s2 color red .mixin dotted d minimal parameters figure alternative ways for extracting a mixin .
detecting differences in style values for a given mixinmigration opportunity an bracketle ts p an bracketri ht we need to check for every property p p if the corresponding style declarations have different i.e.
non equivalent values.
fo r each difference in the property values a parameter should be introduced in the resulting mixin.
however the parameterization of differences can be achieved in several alternative ways.
as an example consider the csscode shown in figure 3a that contains two style rules for selectors .s1 and.s2 respectively.
both selectors style property border which is a well known shorthand property allowing to set the values of several other cssproperties simultaneously such asborder width border style andborder color .
in addition some shorthand properties do not force a specific order for the values of the properties they group.
as a result in selector .s1thebordershorthand styles first the border color with f00 then the border width with1px and finally the border style withsolid while in selector .s2the order is different starting first with border style followed by border color andborder width .
in this particular example and in all the cases involving shorthand properties there are three possible ways to parameterize the differences in property values .
introduce a separate parameter for each pair of different values in the order they appear in the corresponding shorthand property declarations figure 3b .
this approach has two main limitations.
first it may introduce parameters for properties using different kinds of values.
the variables and parameters in csspreprocessors do nothaveatype andthusitispossibletohaveparameters accepting arguments of different value kinds.
however it will be extremely difficult for a developer to understand and reuse a mixinhaving parameters that can take values for semantically different properties e.g.
a property that should be styled with color values and a property that should be styled with dimension values .
second such an approach may lead to mixinswith an unnecessarily long parameterlist whichis considered acode smell since it makes more difficult to call and reuse such mixins.
in a previous work we showed that developers mostly tend to create mixinswith zero or one parameter of themixinshave either one or no parameters .
.
introduceasinglemulti valueparameterforallindividual properties grouped by the corresponding shorthand property figure 3c .
although this approach gives more flexibility to the developer when calling the mixin it is also more error prone because the developer needs to know very well the cssdocumentation regarding the individ ual property values that are mandatory and those that can be omitted i.e.
optional values or the order of the individual property values.
inexperienced cssdeveloperswouldneedtospendtimestudyingthedocumentation in order to properly call a mixinwith such parameters.
.
introduce a parameter for each pair of matching individual properties having non equivalent values in the corresponding shorthand property declarations figure 3d .
in the example shown in figure 3a the matching individual properties between the two selectors are represented with arrows.
the dashed line arrows indicate properties with equivalent values e.g.
the named color redand the hexadecimal color f00are not lexically identical but are alternative representations for the same color .
the solid line arrows indicate properties with non equivalent values that should be parameterized.
this approach has two main advantages over the other approaches.
first it introduces a minimal number of parameters compared to the first approach when some individual properties are styled with identical or equivalent values regardless of the order they appear in the shorthand property declarations .
second it allows to introduce parameters with moresemantically expressive names compared to the second approach since the names of the matching individual properties can be used as parameter names e.g.
style parameter in figure 3d corresponding to the individual property border style .
.
.
inferring individual style properties in our approach we adopted the last parameterization strategy discussed in the previous section due to its advantages over the other two strategies.
to implement this strategy we first need to infer the individual style property isp corresponding to each style value that appears within the style declarations for the set of properties pdeclared in the set of selectors s. anisprepresents the roleof a style value in a style declaration and corresponds to the actual individual style property this value is being assigned to.
table shows the ispsthat are assigned to the values of the border style declarations in the example of figure 3a.
for instance the pair of values corresponding to colors f00andred are both assigned to the same isp which is the individual property border color .
for the style properties that can accept only a single value e.g.
color float theispassigned to their values is the same as the style property name.
for shorthand properties e.g.
border background columns we refer to the css specifications for assigning an ispto each one of their 675table individual style properties isps declaration style value isp border f00 1px solid f00 border color 1px border width solid border style border dotted red thindotted border style red border color thin border width values.
in our implementation we have coded ispsfor multi valued and shorthand cssproperties which account for all major cssproperties used in style sheets.
when comparing two declarations for parameterizing the differences in their values we compare each pair of values corresponding to the same isp.
we follow the same approach used in for examining whether two values are equivalent.
optional omitted values incss some properties can haveoptional values.
for instance the property fontcan accept style values while developers may omit of them.
in the case of omitted values web browsers follow the css specifications to compute them.
in some cases they assign initial i.e.
default values to the omitted values.
in other cases the omitted value is calculated based on another explicitly given value.
following the same approach for every omitted value we actually compute a virtual value and also assign the appropriate ispto it.
this allows parameterizing declarations having an unequal number of style values e.g.
font bold 10pt tahoma andfont 18pt arial .
in this example the first declaration is styling the font weight ispwith the explicitly defined value bold while the second one styles the same ispwith the default value normal.
shorthand vs. individual properties another possible scenario is having some selectors taking advantage of shorthand properties while other selectors are instead declaring separately individual properties.
consider the cssexample shown in figure 4a.
style rule .s1contains four separate style declarations for the individual properties margin top margin right margin bottom andmargin left while style rule .s2contains a single style declaration for the shorthand property margin.
note that thelastvalueinthe margindeclarationisomitted i.e.
there are three values instead of four .
this value corresponds to themargin left isp and based on the cssspecifications it should take the margin right value i.e.
5px when it is omitted.
to enable the detection of mixinmigration opportunities in such cases we are collapsing the sets of individual property declarations that can be grouped into virtual shorthand declarations .
in this way it is possible to find mixinmigration opportunities between selectors either having actual or virtual shorthand declarations and thus the cssexample shown in figure 4a can be migrated to use themixinshown in figure 4b.
.
introducing a mixin in the style sheet in this section we describe an algorithm that takes as input amixinmigration opportunity mo an bracketle ts p an bracketri htto generate amixindeclaration and update the style rules in set sto call the new mixinpassing the appropriate arguments.
in algorithm we use the following helper functions.
function getispswithnonequivalentvalues returnsthe isps which are defined in the style declarations declared inside the style rules in set s corresponding to property pand have non equivalent values.
.s1 ... margin left 5px margin right 5px margin top 3px margin bottom 3px ... .s2 ... margin 2px 5px 1px ... a original css .mixin mtop mbottom margin mtop 5px mbottom 5px .s1 ... .mixin 3px 3px ... .s2 ... .mixin 2px 1px ... b extracted mixin figure mixinfor shorthand individual properties function generatestyledeclarationtemplate generates a style declaration template for property pwith a placeholder i.e.
an unknown value for each ispdefined in the style declarations declared inside the style rules in set s corresponding to property p. the template will essentially contain a mapping of ispsto style values or variables i.e.
mixinparameters after the execution of the algorithm.
finally function getstyledeclaration returns the style declaration corresponding to property pdeclared inside style rules and function getstylevalue returns the style value corresponding to an ispdefined in style declaration d. algorithm algorithm for introducing a mixin input amixinmigration opportunity mo an bracketle ts p an bracketri ht output amixindeclaration m an bracketle tmp md an bracketri ht a mapping of selectors to lists of mixinarguments 1mp the ordered set of mixinparameters 2md the ordered set of mixinstyle declarations 3foreach s sdo 4ma s the list of mixinarguments for s 5end 6foreach p pdo 7differences getispswithnonequivalentvalues p s 8template generatestyledeclarationtemplate p s 9foreach isp template .ispsdo ifisp differences then param newmixinparameter isp mp mp param isp mapsto param map isp to mixinparameter foreach s sdo d getstyledeclaration p s arg getstylevalue isp d ma s ma s arg end end else s s0 get the first style rule in s d getstyledeclaration p s value getstylevalue isp d isp mapsto value map isp to common value end end md md template 28end generating mixin declaration in order to create the mixindeclaration the algorithm generates a style declaration template line for each property pin the set of style properties p. function generatestyledeclarationtemplate goesthroughalldeclarationsstyling pinthesetofstylerules sand finds the union of ispsthat are assigned with values.
this approach can guarantee that all affected ispswill be present in the template even if some style declarations omit the definition of optional values.
next for each ispin the template the algorithm checks if the assigned style values are equivalent or not.
if the values are different the ispis mapped to a new mixinparameter which is also added to the parameter list of the mixindeclaration.
otherwise the 676ispis mapped to the commonly assigned value in all style rules.
finally the resulting template after the mapping of allispsis added to the list of style declarations inside the body of the mixindeclaration.
it should be emphasized that the order of the style declarations inside the mixinfollows the relative order of the style declarations in the original style rules from which they were extracted.
as it will be explained in section .
this is essential for preserving the presentationofthetargetdocuments inthecasewheresome style declarations have order dependencies with each other.
in such a case an ordering that reverses the original order dependencies between the style declarations would affect the values assigned to the isps thus changing the presentation.
adding mixin calls to style rules given the mixinmigration opportunity mo an bracketle ts p an bracketri ht for each one of the style rules in s a call to the generated mixinshould be added.
whenever the assigned style values for a given ispare not equivalent the algorithm goes through all style rules in s and for each style rule sappends to the corresponding list ofmixinarguments ma s the actual value assigned to the ispbys lines .
at implementation level in each style rule sthe style declarations corresponding to the set of properties pare removed and a mixincall with the argument list ma s is added.
.
preserving presentation in refactoring preserving the behavior of the program is very critical.
the refactored program should have exactly the same behavior as the original program before refactoring.
in a similar manner any refactoring or migration operation applied to css code should preserve the presentation of the target documents i.e.
the style values applied to the dom elements after refactoring should be exactly the same as before refactoring .
therefore in the context of css program behavior corresponds to document presentation and any css refactoring migration technique should make sure that document presentation is preserved.
we previously investigated the refactoring of duplicated style declarations directly in cssby grouping selectors which style properties with equivalent values .
we found that in order to preserve the presentation of the target documents the order dependencies between the selectors declared in a cssfile should be preserved after refactoring.
formally an order dependency from selector sicontaining declaration dkto selector sjcontaining declaration dl due to property p denoted as an bracketle tsi dk an bracketri htp an bracketle tsj dl an bracketri ht iff a selectors siandsjselect at least one common element having property pin the target document b declarations dkanddlset a value to property pand have the same importance i.e.
both or none of the declarations use the !imporant rule c declaration dkprecedes dlin the style sheet d selectors siandsjhave the same specificity.
practically if two style rules have selectors with the same specificity which select common dom elements in the target documents and style the same property then the style value initially assigned by the preceding style rule will be eventually overridden by the value assigned by the succeeding style rule.
therefore the relative order of these style rules should be preserved after refactoring in order to obtain the same value for the property styled in both of them.
as a result presentation preservation incsscan be achievedby preserving the order dependencies among all selectors declared in the file.
within the context of mixinmigration the introduction of a new mixindoes not affect the original order of the style rules.
therefore itisnotpossibletobreaktheexistinginterselector order dependencies by introducing a mixin.
however there might exist intra selector order dependencies between style declarations in the style rules where the mixin calls will be added.
consider for instance the csscode shown in figure 5c.
the border bottom declaration in selector.aoverrides the style values which are defined by the borderdeclaration.
the borderdeclaration is a shorthand declaration defining the border for all individual sides of an element top right bottom left .
next the developer overrides with nonethe border styling for the bottom side of the element.
cssdevelopers tend to override more generic style properties e.g .
border with more specific ones e.g.
border bottom because this approach requires less code than defining separately all specific style properties e.g.
border top border right border bottom border left .
html ... body ... span class a test span ... body html a sample html .a ... border bottom none ... .mixin1 .mixin1 border solid 3px red padding 1px b misplaced mixincall .a ... border solid 3px red border bottom none padding 1px ... c original css .a ... border bottom none ... border solid 3px red padding 1px d generated css test e original presentation test f broken presentation figure intra selector order dependencies applying style rule .ato the sample htmlcode shown infigure5awillresulttoawebdocumentrenderedasshown in figure 5e.
let us assume that we extract a mixincontaining the borderdeclaration and we place the mixincall at the end of .a as shown in figure 5b.
the preprocessor will then generate the csscode shown in figure 5d where theborderdeclaration is placed aftertheborder bottom declaration.
this will invert the original overriding relation between the two declarations resulting to the undesired presentation shown in figure 5f i.e.
a styling bug .
therefore placing the mixincall in an incorrect position can actually change the presentation of the target documents.
we define an intra selector order dependency from style declaration ditodj both declared in the same style rule due to individual property isp denoted as an bracketle tdi an bracketri htisp an bracketle tdj an bracketri ht iff a declarations dianddjset a value to individual propertyispand have the same importance i.e.
both or none of the declarations use the !imporant rule b declaration diprecedes djin the style rule.
to ensure that the presentation of the target documents will be preserved we define the following preconditions precondition the addition of a mixincall in a style rule should preserve all order dependencies among the style declarations of the rule.
the problem of finding an appropriate position for calling the extracted mixin minside the body of a style rule can be expressed as a constraint satisfaction problem csp defined as variables the positions of the style declarations involved in order dependencies including m. domains the domain for each variable is the set of values ... n m wherenis the number of style declarations in the original style rule and mis the number of style declarations extracted from the style rule to m. constraints assuming that mcontains style declarations assigning values to the set of individual properties isps an order constraint is created in the form of pos di pos dj for every order dependency an bracketle tdi an bracketri htisp an bracketle tdj an bracketri htwhereisp isps.
in the example of figure 5c there is one order dependency border solid 3px redborder bottom style border bottom none resulting to the constraint pos border pos border bottom .
based on this constraint the call to .mixin1 should be placed at any position before the border bottom declaration to preserve the presentation of the target document in figure 5a.
if there are multiple conflicting order dependencies between the mixincall and declarations of the style rule it might be necessary to reorder some style declarations in ordertocomplywiththesolutionreturnedbythesolver.
on the other hand if the csp is unsatisfiable i.e.
no solution is found the corresponding mixinmigration opportunity is excluded as non presentation preserving.
precondition the ordering of the style declarations inside amixinshould preserve their original order dependencies in the style rules from which they are extracted.
this precondition is checked by extracting the original order dependencies between the style declarations inside mixin m from each style rule where mwill be called.
assuming that mcontains style declarations assigning values to the set of individual properties isps if there exist two style rules si andsj where an order dependency for the same isp isps is reverse i.e.
an bracketle tsi dk an bracketri htisp an bracketle tsi dl an bracketri htvs.
an bracketle tsj dl an bracketri htisp an bracketle tsj dk an bracketri ht then there is an order dependency conflictbetween siand sj and the corresponding mixinmigration opportunity is excluded as non presentation preserving.
.
ev aluation to assess the correctness and usefulness of the proposed technique we designed a study aiming to answer the following research questions rq1 does the proposed technique always detect mixinmigration opportunities that preserve the presentation of the web documents?
rq2 is the proposed technique able to find and extract mixinsthat developers have already introduced in existing csspreprocessor projects?
.
experiment design selection of subjects to be able to answer the aforementioned research questions we need to create a dataset oftable overview of the collected data name less files css files actual mixins style rules declarations detectedopportunitieswebsitesaisandbox.com auroraplatform.com bcemsvt.org brentleemusic.com campnewmoon.ca chainedelespoir.org chunshuitang.com.tw colintoh.com first last always.com florahanitijo.com greatlakeshybrids.com hotel knoblauch.de intertelecom.ua jutta hof.de kko.com med.uio.no naeaapp.com neofuturists.org paulsprangers.com schwimmschule spawala.de summit.webrazzi.com 96librariesbase essence flatui formstone kube schema skeleton turret 307total includes only the mixins which are called at least two times cssfiles which actually contain opportunities for introducingmixinsby grouping style declarations duplicated among different style rules.
we relied on the dataset of our previous study which was used to investigate the practices of csspreprocessor developers by analyzing the code base of websites using two different preprocessors namely lessand sass.
more specifically out of websites in which style sheets were developed using less we selected the preprocessor code base of websites in which at least one mixin declarationwascalledatleasttwotimes sincea mixincalled more than once in the preprocessor code will result in duplicated style declarations in the generated csscode.
our approach should be able to reproduce the original mixins declared in the preprocessor files and possibly recommend othermixinopportunities that the developers might have missed.
we further extended this dataset with the csscode generatedfromthepreprocessorsourcecodeofeightpopular style sheet libraries.
we expect that the selected libraries apply the best practices regarding mixinreuse since they are developed by very experienced developers.
the complete list of the selected websites and libraries along with the number of lessfiles and cssfiles resulting from transpilinglessfiles the number of developer defined mixins the total number of style rules and declarations representing the size of the analyzed cssfiles and the number of migration opportunities detected by our approach for each subjectareshownintable3.
thecollecteddata inaddition to the implemented tools are available on line .
to better demonstrate the size characteristics of the examinedcssfiles we show the distribution of the number of style rules and declarations defined in these files in figure 6a and figure 6b respectively.
the scale of the box plots and 678the underlaid violin plots is logarithmic and the horizontal bars correspond to the median values.
the examined libraries tend to have more style rules and declarations than the examined websites.
figure 6c shows the plots for the number of mixinmigration opportunities detected by our approach per cssfile in the dataset.
as it can be observed the median number of opportunities is and for the libraries and websites respectively.
in order to control for thecssfile size and perform a fair comparison between the number of mixinmigration opportunities in libraries and websites we further normalized the number of opportunities detected in each cssfile by the number of style declarations defined in it.
the normalized medians are .
and .
for the libraries and websites respectively.
this result shows that although the csscode generated by libraries is larger in size than the code generated by the examined websites the libraries tend to have less duplicated style declarations and thus less mixinmigration opportunities than the examined websites.
we can consider this as an indication that the preprocessor code of libraries is better designed.
libraries websites a selectors libraries websites b declarations libraries websites c opportunities figure characteristics of the analyzed css files .
results .
.
rq1 testing presentation preservation motivation the goal of rq1 is to ensure that our technique would never recommend the introduction of a mixin that could change the presentation of the target web documents i.e.
cause a styling bug .
method let us assume that we have two cssfilesc andc the latter resulting from transpiling the preprocessor code after the introduction of a new mixininc and we apply them on the same target documents.
the target documents will have the same presentation iff .
there is a one to one correspondence i.e.
mapping between the style rules defined in candc .
.
the relative order of the mapped style rules is the same in bothcandc i.e.
cascading is preserved .
.
each pair of mapped style rules from candc a selects the same dom elements in the target documents i.e.
specificity is preserved .
b defines exactly the same set of individual style properties.
c assigns equal or equivalent style values to each defined individual property.
conditions and 3a are met by the nature of the transformation because the introduction of a mixindoes not add or remove style rules i.e.
one to one correspondence is met does not change the order of the style rules i.e.
cascading is preserved and does change the selectors specified in the style rules i.e.
specificity is preserved respectivel y.the only conditions that could be violated from an erroneous introduction of a mixinare 3b and 3c.
condition 3b could be violated if the introduced mixincontains declarations for more less or different individual style properties than those that were removed extracted from the style rule calling the mixin.
condition 3c could be violated if the parameterization of the differences in the style values is not correct or if the mixincall is not placed in the appropriate position inside a style rule or if the style declarations are not ordered correctly inside the mixin section .
.
therefore we developed a method to test conditions 3b and 3c that takes as input a cssfilecand amixinmigration opportunity mo applies moon filecto generate the corresponding csspreprocessor code cp then transpiles cpto obtain cssfilec and examines the assertion for every pair of matching style rules s s defined in c andc respectively style map s style map s .
two style rules are considered as matching if they have an identical selector.
function style map takes as input a style rule and extracts a map in which the keys are the individual style properties isps defined in the style rule and each key is mapped to the finalstyle value assigned to the corresponding isp after all possible overrides.
two style maps areequivalent if their key sets are equal and the style values corresponding to each key are equal or equivalent.
two style values are considered equivalent when they are lexically different but constitute alternative representatio ns for the same style value e.g.
red f00 the first is the htmlnamed color representation for red and the second is the hexadecimal representation for the same color .
results in total we detected and applied mixinmigration opportunities and automatically tested them using the aforementioned method.
it should be emphasized that a large portion of these opportunities overlap with each other i.e.
they affect common style rules and declarations and thus it is not possible to apply them sequentially since the application of an opportunity will make infeasible the opportunities it overlaps with.
therefore we applied each one of them separately on the original cssfiles.
we observed several cases where our testing method found styling bugs which were due to our faulty implementation of style value inferencing.
as an example we found cases in which failing to assign correct ispsto style values led to their incorrect parameterization and consequently the resulting preprocessor code was transpiled to a cssfile with different styling semantics than the original cssfile.
for instance when a shorthand property is assigned with the valuenone only one of the ispsis actually assigned with none while the remaining ispsare assigned with default values.
our implementation was not inferring correctly the default values and this caused problems in preserving the presentation of the target documents.
among the detected opportunities there were cases for which precondition had to be examined because there were order dependencies between style declarations extracted in the mixinand declarations remaining in the style rules where the mixinwould be called.
in one case finding a satisfiable solution for positioning the mixincall was not feasible and thus the migration was not performed.
moreover there were cases for which precondition had to be examined.
in all these cases the original order of the declarations inside the extracted mixincould be preserved.
679overall none of the issues found using our testing method was due to a flaw in the approach we proposed for detecting and extracting mixins.
all issues were caused by implementation bugs that were eventually fixed resulting in of the tests being passed.
consequently we can conclude that themixinmigrationopportunitiesproposedbyourapproach are actually safe to apply.
.
.
rq2 detecting mixins defined by developers motivation the goal of rq2 is to investigate whether our technique is able to recommend mixinsthat a human expert i.e.
a developer with expertise in the use of preprocessors would introduce.
method to evaluate this research question we first built anoracleof human written mixinsby extracting all mixins in our preprocessor dataset being called at least two times.
thesemixinsare suitable for testing our approach because theyintroduceduplicatedstyledeclarationsinthestylerule s where they are called after transpiling the preprocessor code to generate csscode.
the mixinscalled only once in the preprocessor code cannot be detected by our approach because they do not introduce duplicated style declarations.
next we transpiled each preprocessor file and applied our technique to detect all mixinmigration opportunities in the resulting cssfiles.
amixinm created by applying the migration opportunitymodetected by our approach matches with a mixinm in the oracle iff .
the set of ispsstyled by mis equal to or is a superset of theispsstyled by m .mis called in at least all the style rules where m is called.
the first condition ensures that mstyles the same set of properties as m .
this condition is relaxed so that mcould style more ispsthanm .
this relaxation is necessary to deal with cases where the preprocessor developer missed the opportunity to include additional style properties being duplicated in the style rules from which m was extracted.
the second condition ensures that mis called in the same style rules where m was called.
this condition is also relaxed so thatmcould be called in more style rules than m .
this relaxation is necessary to deal with cases where the preprocessor developer missed the opportunity to reuse m in additional style rules.
if m is matched by applying the first relaxed condition then m is not aclosedfrequent itemset since there is at least one superset with the same frequency.
results our approach was able to recover out of the 193mixinsin the oracle.
in particular mixinmigration opportunities detected by our approach were exact matches contained additional properties i.e.
supersets with the same frequency were called by additional style rules i.e.
same sets with higher frequency and contained additional properties and were called by additional style rules i.e.
supersets with higher frequency .
the large percentage of inexactly matched mixinmigration opportunities .
actually shows that in most of the cases developers under utilize mixins.
we further manually investigated the oracle mixinsthat our approach could not detect.
in general these mixinsfall into two categories mixins using property interpolation interpolation is anadvancedpreprocessorfeatureallowingtousevariablesto formpropertynames.
itisusefulforstylingdifferentproperties that have the same sub properties e.g.
margin top andpadding top can be interpolated as property top or can take the same values.
figure 7a shows an example of an interpolated property name inside a mixin and the resulting csscode is depicted in figure 7b.
our technique cannot detect such mixinopportunities since it does not support the parameterization of differences in property names.
.inherit property property inherit .s1 .inherit margin .s2 .inherit padding a preprocessor code .s1 margin inherit .s2 padding inherit b genereated css figure example of interpolated property name use of!important in arguments as mentioned before in our approach we avoid the grouping of properties having a different importance.
however the !important rule can be actually used in the arguments of a mixincall to parameterize properties having a different value and importance as shown in the example of figure 8a resulting to the css code shown in figure 8b.
our approach does not support for the moment such advanced parameterization of differences.
.s1 .m red !important .s2 .m blue .m var color var a preprocessor code .s1 color red !important .s2 color blue b genereated css figure example of !important use in arguments .
limitations the success of a recommendation system is associated with the relevance of the recommendations to its users often measured in terms of precision and recall.
assuming that the mixinsintroduced by developers e.g.
the oracle used in rq2 constitute the gold standard our approach can achieve very high recall with a small number of undetected actualmixins i.e.
false negatives but it generates a large number of mixinopportunities and some of them might be considered irrelevant by the developers i.e.
false positives .
although it is not possible to determine the actual number of false positives without asking the developers opinion about the recommendations it is certain that the developers would like to inspect the smallest possible list of mixin opportunities that contains most of the relevant ones.
therefore we investigated whether it is possible to reduce the number of generated mixinopportunities i.e.
recommendations without jeopardizing recall.
to achieve this we filtered out the mixinopportunities having a number of style declarations or parameters above certain thresholds.
the threshold values were automatically derived from the box plot upper adjacent values for the oracle used in rq2.
all data points above the upper adjacent value of the box plots are outliers that correspond to abnormal mixinsintroduced by developers.
indeed defining thresholds based on box plot outliers is a statistical approach that has been also used in metric based rules for detecting design flaws in object oriented systems .
table shows the number ofmixinopportunities obtained using different filters along with the number of recovered mixinsfrom the oracle.
the results show that it is possible to recover close to of the oraclemixinswithlessthanhalfoftheoriginalopportunities by applying appropriate threshold based filters.
.
threats to validity while the proposed approach for detecting mixinopportunities is preprocessor agnostic our actual implementatio n 680table threshold based filtering of opportunities filter opp.
recovered recall i none .
ii declarations .
iii parameters .
iv ii iii .
for the introduction of mixinscurrently supports only the lesspreprocessor.
this is because the source code transformations required to introduce a mixinare specific to the abstract syntactic structure ofthetargetedpreprocessor.
we selected to support less because it is slightly more popular among the developers however the implemented tool is extensible enough to support any preprocessor.
in addition we have already shown that code written in sass another popular preprocessor has very similar characteristics with code written in less.
thus examining projects developed inlessdoes not limit the generalizability of our study.
nevertheless we used lessfiles collected from a wide range of web systems including libraries and websites to mitigate the threat to the external validity of our study.
the ultimate approach for testing presentation preservation would be to compare the target documents before and after applying migration transformations as they are rendered in the browser.
however a visual comparison would be time consuming and error prone.
additionally the stateof the art automatic techniques are computationally intensive e.g.
differentiating screen captures of web pages using image processing methods .
we instead considered all possible presentation changes a mixincan impose on a style sheet and developed a lightweight static analysi s method based on preconditions derived from cssspecifications.
this approach was able to reveal several styling bugs due to our faulty implementation showing that the method is promising in testing whether presentation is preserved.
.
related work maintenance of cascading style sheets cssmaintenance is a rather unexplored research area despite the fact that cssis extensively used in the industry .
previous works proposed approaches for finding dead code in cssfiles in order to reduce their size and thus the effort required for their maintenance.
mesbah and mirshokrae devised a hybrid approach to detect unused style rules in css files using dynamic and static analysis .
having the same goal genev es et al.
proposed a technique based on tree logics.
similarly hague et al.
used tree rewriting techniques for removing redundant cssrules.
finally bosch et al.
explored the possibility of cssrefactoring to remove unused style rules and declarations by statically extracting the relationships between cssstyle rules.
keller and nussbaumer introduced metrics for measuring the abstractness of cssfiles and explored ways to make cssfiles reusable for different target documents.
gharachorlu investigated code smells in csscode and proposed a statistical model for predicting them.
liang et al.
designed a tool for tracking the visual impact of code changes in cssacross a website.
previous studies also investigated the presence of duplication in web systems either in the content and structure of htmlpages or their client or server side scripts.
we conducted the first study on cssduplication investigating the possibility of refactoring cssfiles to remove duplication by groupingstyle rules that share equivalent declarations i.e.
declarations that result to the same presentation.
the proposed approach in eliminates duplications occurring between style declarations with no differences in style values directly in vanilla css whileinthiswork weproposedatechnique formigrating csscode to take advantage of preprocessor mixins which allows the parameterization of differences in style values.
moreover in contrast to this work we did not use a testing approach in for assuring that the presentation semantics of style sheets will be preserved after transformations.
migration of legacy systems there are numerous works in the literature proposing migration techniques for legacy systems in order to improve their maintainability.
several researchers developed techniques for migrating procedural code to the object oriented paradigm such as automatic or semi automatic translators from c to c eiffel or java .
migration is also performed when there is a lack of human resources for maintaining existing software systems written in an extinct language e.g.
migrating lisp to java .
other works proposed approaches for detecting opportunitiestouseconstructsintroducedinanewerversion of a programming language.
for java there are techniques for introducing parameterized classes from non generic ones the enumerated type and lambda expressions .
migration of web systems some of the studies that investigated the duplication in the content or structure of web pages proposed techniques for migrating duplicated static web pages to dynamic server side web applications .
mao et al.
proposed an approach for the automatic migrationof htmlpageshavingtable basedstructurestothe style based structure by using clone detection tools to find duplicated code across different css files.
their approach can support only exact duplications which are removed by creating a single css file for different web pages.
our work is the first one that supports the migration of existing css code to preprocessors and evaluates the correctness and efficacy of the detected mixinmigration opportunities.
.
conclusions and future work in summary the main conclusions and lessons learned are .
our approach facilitates the automatic migration of css code to preprocessors by safely extracting duplicated style declarations from csscode to preprocessor mixins.
.
our approach is able to recover the vast majority of themixinsthat professional developers introduced in websites and style sheet libraries.
.
we found that developers mostly under utilize mixins i.e.
they could reuse the mixinsin more style rules and orcouldeliminatemoreduplicatedstyledeclarations by extracting them into the mixins .
.
by applying appropriate threshold based filters it is possible to drastically reduce the number of detected mixin opportunities without affecting significantly the recall.
as future work we are planning to develop a ranking mechanism in order to help developers prioritize the mixin opportunities based on their expected benefit on maintainability.
we also plan to evaluate our recommendation system with actual web developers and find ways to further eliminate recommendations that are irrelevant to them e.g.
mixinscontaining semantically unrelated style properties that a developer would not normally group together.
.