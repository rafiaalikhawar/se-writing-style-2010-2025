automated tagging of software projects using bytecode and dependencies santiago vargas baldrich universidad nacional de colombia svargasb unal.edu.comario linares v asquez the college of william and mary mlinarev cs.wm.edudenys poshyvanyk the college of william and mary denys cs.wm.edu abstract several open and closed source repositories group software systems and libraries to allow members of particular organizations or the open source community to take advantage of them.
however to make this possible it is necessary to have effective ways of searching and browsing the repositories.
software tagging is the process of assigning terms i.e.
tags or labels to software assets in order to describe features and internal details making the task of understanding software easier and potentially browsing and searching through a repository more effective.
we present sally an automatic software tagging approach that is able to produce meaningful tags for maven based software projects by analyzing their bytecode and dependency relations without any special requirements from developers.
we compared tags generated by sally to the ones in two widely used online repositories and the tags generated by a state of the art categorization approach.
the results suggest that sally is able to generate expressive tags without relying on machine learningbased models.
i. i ntroduction several open and closed source software repositories are available for developers to take advantage of preexisting software assets that address particular needs that their projects may have.
however in order to be able to take advantage of a repository there should be ways for efficiently locating assets in it .
assigning tags orcategories to projects that describe features of the projects such as application domain programming language operating system etc.
is a commonly used approach for improving the browsing searching and retrieval processes in large repositories.
categories represent high level concepts that help group similar assets together and apply to a wide range of them e.g.
testing framework bytecode analysis etc.
while tags represent more specific concepts that often relate directly to implementation details e.g.
xml grammar servlet java etc.
.
the assignation of tags and categories could be performed manually for example by asking developers to categorize their projects upon uploading them to a repository by selecting from a predefined list of categories or by allowing them to enter free text.
however both cases could lead to misclassification or the developer can just avoid the category selection.
the categorization task could be delegated to repository administrators or curators however the size and rapid pace at which repositories keep growing can render this manual approach impractical.
automatic software categorization tagging has progressively gained importance because of the benefits that can span from its use.
research progress has been made onvarious approaches and methods that rely on machine learning techniques for classification.
most of these approaches utilize identifiers extracted from source code assuming there is full access to the repository .
this situation is not common in closed source environments it is known that many companies often work under high security practices to protect organizational secrets which restricts the access to source code thus limiting applications of such a categorization model that relies on sensitive information to work.
also some libraries are published as jar files without the source code as in the case of some maven based projects.
to address this concern a number of approaches relying on application programming interface api calls and identifiers extracted from bytecode have been proposed and evaluated .
in software categorization the category labels are mostly created manually by domain experts or selected from a set of previously defined categories .
these approaches rely mostly on supervised learning thus the approaches require a previously categorized set of projects to be used as training data.
supervised categorization assumes that the set of predefined categories is sufficient to classify any new project that enters the repository although that may not necessarily be the case.
also a predefined set of categories is limited by the knowledge of available domain experts or by the decisions made by repository administrators.
in some cases category labels are created automatically by analyzing the information in hosted projects .
this automatic generation of category labels has the advantage of relying only on information mined from the source code thus decoupling category names from specific knowledge of the available domain experts.
however closed source repositories can not be categorized using approaches relying on source code since the source code may not always be available as in the case of projects in maven repositories.
with those issues in mind we developed sally a novel multi label and unsupervised approach for automatic tagging of closed source projects in particular maven based software.
by extracting identifiers from bytecode and harnessing the dependency relations between projects sally is able to produce a set of expressive tags and present them in a useful way to users.
additionally it is is capable of dealing with common problems that previous work on automatic software categorization have faced.
in particular sally has the following contributions over competitive approaches sally does not need access to source code in order to work.
this makes the approach a feasible alterna tive for closed source and organizational repositories where access to information is restricted due to security reasons tags are not predefined but rather obtained from identifiers and project dependencies.
this way we reduce the possibility of missclasification that could be derived from predefined tags besides generating tags based on identifiers and dependency relations sally is able to produce a measure of how relevant is a tag for a given project by relying on filtering process based on tags from stackoverflow sally is able to provide descriptive information about the projects in a repository.
additionally by mining information from widely used sources definitions for the presented labels can be obtained by extracting information from dependency relations among projects sally is able to produce tags that not only describe projects by themselves but the context on which they are used.
ii.
r elated work most of the previous work on software categorization has predominantly relied on machine learning algorithms and mainly differ in the way how and which features are extracted and the specific classification algorithm employed.
source code comments readme files online repository profiles and api calls have been used as input for feature extraction.
besides source code ugurel et al.
include comments and readme files finding that comments can have a negative effect on the classification for some languages.
kawaguchi et al.
extract identifiers only from source code arguing that the use of design documents build scripts or other software artifacts is not convenient because although these artifacts can contain highly abstracted information their quality can vary greatly from project to project thus affecting the categorization results.
later on tian et al.
present an approach that also takes into account comments in source code and has a more strict filtering scheme for identifiers .
in the authors ignore source code and make use of api calls for feature extraction acknowledging the cases in which the availability of source code cannot be counted on.
by using their approach closed source and organizational software repositories can be subject to automatic software categorization.
more recently bytecode was used in conjunction with online software profiles to extract data from projects and construct and unsupervised categorization model based on a dirichlet process clustering algorithm .
approaches that make use of inputs different to source code are relevant since it is known that several companies work under highly restricted environments to protect organizational secrets a practice that limits access to source code.
software tags and online profiles have been used to perform tasks such as finding similar applications given a query and perform hierarchical categorization of software projects .
al kofahi et al.
explore automatic tagging using fuzzy sets theory and propose tagrec a tag recommendation tool that also uses evolutionary information extracted from the systems history.for classification most of the approaches use textual categorization which considers software projects as documents.
after extracting identifiers ugurel et al.
use expected entropy loss to select the most important features support vector machines are used to categorize projects by programming language and application topic.
in the authors use decision trees for categorization with a reported error rate of less than .
to deal with the need of predefined categories required to use decision trees and in general any supervised learning algorithm the authors propose the use of lsa as a way to obtain similarities between software systems and to use this information for classification.
their work is extended in where mudablue is proposed after obtaining similarities between projects mudablue uses cluster analysis to find sets of related software systems.
tian et al.
propose in a similar approach that uses lda as a way to obtain topics and also applies cluster analysis to determine the software clusters.
in the authors use decision trees naive bayes and support vector machines svm for classification finding the svm approach to be the most effective.
wang et al.
also propose in an approach based on similarity of software systems and clustering using these similarities to build a taxonomy for projects from freecode.
iii.
o urapproach sally is composed of four main steps depicted in figure .
first identifiers are extracted from bytecode and filtered using a scheme that leverages tags from stackoverflow .
in parallel dependency relations between projects are analyzed in order to obtain metrics that serve as input in the tagging process.
the filtered identifiers and dependency metrics are then used to generate primary and secondary tags for each of the projects.
the final step is to produce a tag cloud that gives visual clues about how relevant each tag is for the projects they have been assigned to as well as easy access to the definition of the concept described by the tag.
a. identifier extraction and filtering extraction the asm bytecode manipulation framework is used to obtain class names class fields method names and method arguments from bytecode .
to prepare the obtained identifiers for further computations they are splitted by camel case and stemmed using apache lucene .
filtering the first part of the filtering process removes identifiers that appear in more than of the projects identifiers comprised of less than three characters to keep important concepts such as xml pom rss and stop words.
then identifiers are filtered by using tags from stackoverflow so a popular q a site where programmers with a wide range of experience share knowledge by asking and answering questions.
it means that identifiers that are not in the tags list from so are discarded.
tags in the so site represent concepts related to software development computer science programming languages algorithms etc.
that allow to group similar questions together and are maintained by the community which makes them a diverse and curated set of categories concepts and terms that we consider to be valid descriptors for the projects to be tagged.
in the same way a tag on a question in so can give a reader an idea about the subject of the question identifier 1identifier ... .
identifiers .
dependencies .
primary tagstag 1tag 2tag ... .
secondary tagstag n .
tag cloud0.
bytecode .
definition sourcesfig.
the sally approach for automatic tagging of software we expect it to give information about the software projects it is assigned to.
b. resolving dependencies software reuse can be seen as the inclusion adaptation of previously developed software artifacts into new projects with the intent of using their functionality this inclusion creates a dependency relation between projects.
more formally it is considered that a project udepends on a project vwhen there is at least one method invocation object instantiation or inheritance relation from classes in uto classes in v. we refer to these cases that create dependencies as dependency calls .
if projects are modeled as nodes and dependency relations as edges a dependency graph can be obtained from a repository.
furthermore a weighted graph can be obtained if each edge is labeled with the number of dependency calls between the projects connected by it.
the dependency resolution process uses depfind to find dependency relations between projects and creates a weighted dependency graph from the repository.
finally a dependency metric for each pair of connected vertices is computed the metric is defined as duv dc u v pi n i 1dc u i where dc x y is the number of dependency calls made from project xtoyandnis the number of projects xdepends on.
c. assigning tags to projects for each project a set of tags is found and assigned to it.
each tag is defined as a tuple name relevance where name is the name of the tag and relevance is a value between and that describes how relevant is the tag for the particular project.
for example if we were examining the project junit we would expect to have tags whose names are related to testing with high relevance measures.
sally uses identifiers and dependencies extracted from bytecode to identify two types of tags primary andsecondary .
primary tags these tags stem from the analysis of a particular project by itself i.e.
only taking into account the identifiers extracted from the bytecode and ignoring dependencies.
to obtain the primary categories gensim is used tocompute tf idf values for the identifiers which are then used to obtain relevance measures for each one of the terms.
the relevance measure is calculated as tfid f ti pm k 1tfid f tk where tfid f ti is the tf idf value for identifier iandm is the number of identifiers obtained from the project.
finally identifiers are sorted in descending order by relevance and their roots recall that identifiers are stemmed after being extracted become the primary tags.
secondary tags the secondary tags of a project are the primary tags of its direct dependencies1with their relevance measures scaled using the dependency measure that was previously computed.
the secondary tags are also sorted in descending order by their relevance values.
the number of tags that are obtained for each project can be customized either by the number of required tags or by establishing a relevance threshold e.g.
only tags with a relevance measure .
d. displaying tags definition depending on the background and programming experience of repository users it is possible that tags generated by sally could be perceived as irrelevant.
to deal with this given a tag sally is able to obtain definitions from various information sources.
currently so wikipedia wiktionary andtechtarget are the supported sources for concept definition.
having an automatic way to obtain these definitions aids repository users and developers to get a better understanding of the tags.
however the main reason for developing the definition module is that although the selected identifiers are related to the application domains of projects they are not necessarily enough to describe them this is because using identifiers as tags can present low level information about projects e.g.
frameworks communication protocols related programming languages technologies etc.
in order for a user to find the concepts that describe what a project s application domain is it is necessary to go beyond the details embedded in the identifiers by relating them to more general concepts.
future work will be devoted to automatic definition of concepts.
our current implementation links tags to definitions we expect definitions to be the bridge between identifiers and the complex concepts that serve to describe the application domains of software projects.
e. tag cloud output in order to visually present the obtained information in a useful way sally s user interface presents the extracted tags and their relevance measures as a tag cloud where the size of each tag is directly related to the relevance of the tag for the project that is being visualized.
the intention behind this decision is to provide visual aid to users in finding the most relevant tags for a particular project i.e.
although all extracted tags are related to a project in one way or another there are some of them that are more relevant than the others.
1a deeper exploration of the dependency graph i.e.
using transitive dependencies was tried but for most of the projects results were not satisfactory.
.
.42primary tagsemulated .51enable .
encode .11engine .
english .
enhanced .41enter .51entities .01primary tagsopacity .51open .54option .11order .21ordinal .01orient .41origin .51orphans .01outer .
emulated open0.
x x0.54secondary tagsemulated .29open .12enable ... opacity ...encode ...option ... engine ... order ...english ... ... ...fig.
propagation of primary tags f .
sally the application sally is composed by two main components one is responsible for core functionality and the other is in charge of making the information obtained by the core component available to users.
all modules in charge of information extraction i.e.
identifier extraction filtering dependency resolution category generation definition mining were developed as a java maven project that makes use of python and bash scripts.
the web application was developed using the meteor javascript platform and all information is stored in a mongodb database.
sally is currently available at iv.
e xperiment s ally vs .
source forge and mvnr epository we compared sally to the categorization tagging approaches of two widely used online resources for browsing java projects published as jar files sourceforge an open source repository and mvnrepository a search engine for maven projects.
maven projects from the net.sourceforge groupid were selected randomly using mvnrepository and all transitive dependencies were resolved to obtain a set of jar files for the evaluation.
sourceforge is an open source project hosting site with over .
million registered users and is one of the most widely used alternatives by developers to publish their projects.
after creating a project a developer is presented with options to manually add tags to describe its features and also to choose from a predefined set of topics that serve as categories.
mvnrepository is a search tool for maven projects.
by providing only a groupid or artifactid users can get the ga v coordinates i.e.
groupid artifactid andversion of matching projects.
the site also displays information such as related books and the content of the description tag in the pom file if available .
projects in mvnrepository are labeled with both tags and categories tags are extracted from text in the pom file and the categories are assigned manually.
to distinguish categories from tags in the following section the same convention from mvnrepository is used categories are presented with initial capital letters and tags are shown in lower case.
a. experiment setup our goal was to compare the tags generated by sally to those from sourceforge and mvnrepository in terms of their availability whether the approaches have tags for all of theprojects in the corpus and how descriptive how good are the terms at describing the application domains and purpose of the projects they are assigned to they are.
therefore the following research questions were addressed in this experiment rq1 how do the tags generated by sally and the ones assigned by developers in sourceforge compare in terms of their descriptiveness?
rq2 how do the tags generated by sally and the ones assigned by mvnrepository compare in terms of their descriptiveness?
rq3 how do sally sourceforge and mvnrepository compare in terms of the availability of tags?
in order to answer rqs categories and tags were manually obtained from the sourceforge and mvnrepository and sally was used to generate five primary and five secondary tags for each project.
one of the authors manually compared the categories tags assigned by each approach.
b. results rq sally vs. sourceforge of the analyzed projects were present in sourceforge.
categories in sourceforge are selected manually by developers which allows them to have some control over the indexing of their projects on the site.
however this allows also for ambiguous categorizations and assignation of categories that do not correspond to the real purpose or domain application of projects.
also since the set of categories is predefined there are categories in the site that are too broad to give useful information e.g.
software development framework libraries etc.
.
it is important to keep in mind that sourceforge is not commonly used to host libraries that depend on each other as the maven central repository does it is rather oriented towards hosting standalone applications or self contained libraries.
this is evidenced by two particular facts.
firstly even though all the projects declared as dependencies in the pom file that was used to form the corpus belonged to thenet.sourceforge groupid a large amount of transitive dependencies were not available in sourceforge.
this subject is mentioned in depth in the discussion of rq .
secondly since maven software projects are generally divided into modules that have particular functions inside the project by using the sourceforge categorization scheme e.g.
ignoring these modules all modules get classified under the same category although this is not necessarily correct and could lead to overly broad categories for projects.
we identified projects out of the projects from the repository present in sourceforge as being categorized under an overly broad category.
for out of these projects sally was able to produce more specific tags than those given by sourceforge.
in most of the cases where developers assigned appropriate and specific categories sally was able to generate tags closely related to them.
however for standalone applications that are categorized under a specialized category in a manual fashion we can not say that sally produces better tags because there are high level concepts that can not be abstracted only by looking at information obtained from bytecode.table i number of projects without categories per approach.
sally mvnrepository sourceforge primary secondary categories tags categories .
.
.
.
.
rq sally vs. mvnrepository mvnrepository assigns tags to projects by extracting information from their pom file2.
unlike sourceforge mvnrepository is focused solely on maven projects this allows us to do a better comparison with sally .
manual examination showed that in most cases sally is able to generate tags that are at least as descriptive as those generated by mvnrepository.
for out of the analyzed projects at least one of the tags generated by sally exactly matched one or more tags from mvnrepository.
additionally there are projects for which mvnrepository does not have any tag assigned but sally does.
moreover there is only one project for which mvnrepository has a tag and sally does not javax.inject .jar and the assigned tag is javax which is filtered by sally because we do not consider file names to be valid tags e.g.
project activation.jar can not have a tag named activation .
when available tags assigned by mvnrepository were mostly considered appropriate for the projects they were assigned to.
however since these tags depend on the description tag from the pom file while the ones generated bysally do not in the majority of cases sally was able to produce more descriptive tags for maven projects than mvnrepository .
rq availability of categories tags in order to measure category availability we counted the number of projects that were indexed on the sites but had no categories or tags assigned.
table i depicts these stats.
the number of projects that were not tagged by sally is minimal as compared to the number of projects without categories or tags assigned by the other approaches.
this is a direct consequence of the fact that sally does not have special requirements for developers such as manually categorizing or describing their projects.
since both sourceforge and mvnrepository need a certain set of conditions to be met in order to be able to categorize a project i.e.
manual categorization for sourceforge and a descriptive pom file for mvnrepository we can conclude thatthe availability of categories of sally is superior than those of sourceforge and mvnrepository .
c. summary of experiment we compared sally to two popular online tools with different categorization schemes and found that both sourceforge and mvnrepository have weaknesses that our proposed approach does not.
the success of the categorization made by sourceforge strongly depends on developers carefully choosing categories for their projects.
on the other hand the success of the categorization scheme applied by mvnrepository depends on developers adding a description of their projects on the pom files neither of the requirements can be guaranteed to be fulfilled at all times.
results obtained from this experiment 2we do not include categories in the comparison because we do not have information about how they are assigned to projectstable ii computed tags for project stringtemplate .
sally mvnrepository sourceforge test .
token .
template engines missing templates .
ast .
expr .
grammar .
region .
gen .
group .
antlr .
show that sally can produce competitive results without the need for any special requirements from developers.
as an example table ii shows a summary of the tags generated by sally for project stringtemplate .
which is described as follows stringtemplate is a java template engine for generating source code web pages emails or any other formatted text output.
stringtemplate is particularly good at code generators multiple site skins and internationalization localization.
stringtemplate also powers antlr.
the example shows how both primary and secondary categories found bysally contain terms associated to regular expressions and grammars which directly relate to the application domain of the project under analysis.
mvnrepository has a relevant category as well however it does not present any automatically generated tags.
the project is not available in sourceforge.
comparing tags generated by sally to those from mvnrepository and sourceforge it is apparent that sally can produce competitive and in many cases superior results in terms of descriptiveness of generated tags.
v. e xperiment e valuating sally vs .
mudab lue with professional developers mudablue is an unsupervised categorization approach for software projects based on latent semantic analysis lsa .
we consider it as a good baseline for comparison given the fact that both sally and mudablue are unsupervised thus both approaches do not need a set of predefined categories tags.
the mudablue approach works by extracting and filtering identifiers obtained from source code and building an termdocument matrix from them.
lsa is applied and cosine similarity metrics are used to cluster identifiers and software projects together.
a. empirical study to compare sally and mudablue we conducted a survey in which professional developers were asked to rate the expressiveness andcompleteness of the categories tags presented by both approaches for randomly selected projects from the same corpus as experiment .
we refer to the expressiveness of a set of categories as the measure of how good is the set at describing the application domain of the software project it is assigned to and completeness refers to whether the set of categories is able to fully describe the projects application domain.
research questions rq4 how do the tags generated by sally compare to the tags generated by mudablue in terms of completeness?
1evaluations sally mudablue a expressiveness 4evaluations b completeness fig.
amount of evaluations per rating for both approaches rq5 how do the tags generated by sally compare to the tags generated by mudablue in terms of expressiveness?
both rqs directly aim at comparing the categories tags generated by the approaches.
to answer them we asked developers to rate using a point likert scale where represents the lowest possible score for completeness expressiveness and the highest ten terms generated by mudablue and ten terms generated by sally for each of the projects.
the tags obtained from sally correspond to five primary tags and five secondary tags.
when no secondary tags were available ten primary tags were extracted.
all tags were presented to developers without the relevance measure to avoid negative effects on the validity of the study.
b. results figures 3a and 3b depict the ratings given by developers to the categories tags presented by both approaches.
it can be seen that sally obtained the lowest score possible for both expressiveness and completeness on close to of the evaluations while mudablue obtained it on approximately of them.
sally obtained a score greater or equal to on for expressiveness and for completeness versus and for mudablue.
finally sally obtained top scores on .
and while mudablue was below .
in general developers perceived the tags by sally to be superior to the category names generated by mudablue regarding both expressiveness and completeness.vi.
c onclusion we proposed sally and automated tagging approach for generating useful tags for software projects by analyzing information obtained from bytecode which makes it also applicable to closed source repositories.
additionally sally makes use of information obtained not only from projects by themselves but from their dependencies which allows to produce tags that describe the projects as well as the context in which they are used.
sally is able to work without the need for predefined tags nor any special requirements from developers making it an attractive approach for automatically tagging software projects in large repositories.
in addition to the approach we developed a web based application that presents the generated tags in an intuitive way that provides information about how each tag is relevant for a given project.