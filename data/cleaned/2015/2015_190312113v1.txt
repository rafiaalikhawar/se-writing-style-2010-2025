arxiv .12113v1 mar 2019counterexample guidedapproachtofinding numericalinvariants t hanhvunguyen university ofnebraska lincoln usatimos antonopoulos yale university usa andrew ruef university ofmaryland usamichaelhicks university of maryland usa abstract numericalinvariants e.g.
relationshipsamongnumerica lvariables inaprogram represent a usefulclassofpropertiestoanaly zeprograms.
generalpolynomialinvariantsrepresentmorecompl exnumerical relations but they are o f ten required in many scient ific and engineering applications.
we present numinv a toolthat implements a counterexample guided invariant generation c egir technique to automatically discover numerical invariants which are polynomial equality and inequality relations among num erical variables.
t his cegir technique infers candidate invari ants from program traces and then checks them against the program source code using the klee test input generation tool.
if th e invariants areincorrectkleereturnscounterexampletraces which help the dynamic inference obtain be t ter results.
existing c egir approaches o f ten require sound invariants however numinvsacrifices soundness and produces results that klee cannot refu te within certain time bounds.
t his design and the use of klee as a verifier allow numinvto discover useful and important numerical invariants formany challenging programs.
preliminary results show that numinvgenerates required invariants for understanding and verifying correctness of pr ograms involving complex arithmetic.
we also show that numinvdiscovers polynomial invariants thatcaptureprecisecomplexity bounds ofprogramsusedtobenchmarkexistingstaticcomplexityan alysis techniques.
finally weshowthat numinvperformscompetitively comparingtostateof theart numerical invariant analysis t ools.
ccs concepts so f tware and its engineering so f tware verification and validation so f tware verification automatedstaticanalys is dynamicanalysis keywords dynamic and static invariant analyses counterexample gu ided algorithms numerical domains program and correctness an alyses test inputgeneration acmreference format t hanhvunguyen timosantonopoulos andrewruef andmichaelhicks.
.
counterexample guided approach tofinding numerical invariants .
in proceedings of 11th joint meeting of the european so f twareengineering conferenceandthe acmsigsoft s ymposium onthefoundationsofso f twareengineering paderborn germ any september esec fse pages.
esec fse paderborn germany .
... .
introduction t he automated discovery of program invariants relations among variablesthatareguaranteedtoholdatcertainlocationso faprogram isanimportantresearchareainprogramanalysisandverific ation.
generated invariants can be used to prove correctness asser tions reasonaboutresourceusage establishsecuritypropertie s provide formaldocumentation and more .
a particularly useful class of invariants are numerical invariants whichinvolve relations amongnumerical programvariable s. withinthisclassofinvariants nonlinearpolynomial relations e.g.
x y.alt2 x q y.alt r arise in many scientific engineering and safety and security critical applications.1for example the commercial analyzer astr ee which has been applied to verify the absence of errors in the airbus a340 a380 avionic systems implementstheellipsoidabstractdomain torepresent andanalyze a class of quadratic inequality invariants.
complexi ty analysis which aims to determine a program s performance chara cteristics perhaps to identify possible securi ty problems alsomakes use ofpolynomial invariants e.g.
o n2 2m wheren mare some program inputs.
in addition such polynomialinvariantshavebeenfoundusefulintheanalysisofh ybrid systems and in fact are required for implementatio ns of common mathematical functions such as mult div square sqrt andmod.
numerical invariants can be discovered via static and dynam ic program analyses.
a static analysis can reason about all pro gram pathssoundly but ible for relatively simple forms of invariants .
dynamic ana lyses limit their a t tention to only some of a program s paths and as a resultcano f tenbemoreefficient and producemoreexpressive i nvariants but provide no guarantee that those invariants ar e correct .
recently several systems such as pie i ce andguess and check have been developed that take a hybrid approach use a dynamic analysis to infer candidate invariantsbut then confirm these invariants are correct for all inputs usingastaticverifier .
wheninvariantsareincorrecttheverifierreturns counterexample traces which the dynamic inference en gine canusetoinfer moreaccurateinvariants.
t his iterative pro cessis calledcounterexampleguidedinvariantgeneration cegir .
while the cegir approach is promising existing tools have some practical limitations.
one limitation is that they find invariants strong enough to prove a particular programmer provi ded 1we refer to nonlinear polynomial relations such as x q y.alt r x y.alt2simply as polynomial relations .esec fse september4 paderborn germany than hvu nguyen timos antonopoulos andrew ruef and michael hick s intcohendiv intx inty assert x y intq intr x while r y inta intb y while r b a a b b r r b q q a return q traces x y.alt a b q r ... ... figure1 anintegerdivisionprogramandexampletracevalues at location l1on inputs x y.alt and x y.alt .
amongotherinvariants twokeyloopinvariantsdiscovered atl1areb y.altaandx q y.alt r with the latter also found as the postconditionat l2.
postcondition where the quality of the generated invariant s depends on the strength of the postcondition.
as such they are not well suited for automated analyses on code that lacks such fo rmal specifications.
another limitation is that these tools e mploy asoundstatic verifier which aims todefinitively prove that an invariant holds.
whilethisisagoodgoal itturnsouttobeasi gnificantrestrictiononthequalityoftheinvariantsthatcanul timately beinferred it can bequitechallenging todo when invariant s are nonlinear polynomials and involve many program variables.
for example consider theprograminfigure which implements cohen s algorithm for integer division .
two important lo op invariants at l1 areb y.altaandx q y.alt r as they both point directly to the correctness of the algorithm.2neither pie nor ice can infer these invariants bothtoolstimeout .
inthispaperwepresentanewcegiralgorithmcalled numinv that overcomes these limitations.
it has two main component s. first it uses algorithms from dig to dynamically in fer expressivepolynomialequalityinvariantsandlinearineq ualityrelations from traces at specified program locations.
second it uses klee a symbolic executor to check candidate invariant s and producecounterexampleswhentheyfailtohold.
tochecktha tan invariant pholds at location l numinvtransforms the input programsothat lisguardedbytheconditional p. ifkleeisableto reachlthenpmust not be an invariant and so it outputsa counterexampleconsistingoftherelevant inputvaluesatthatl ocation.
ontheotherhand ifkleeneverreachesthatlocationpriort otiming out then numinvaccepts the invariant as correct.
although thistechniqueisunsound klee byitsnatureasasymbolice xecutor turns out to be very effective in discovering counterexa mples torefuteinvalid candidates.
for the example in figure numinvis able to find the critical equalitiesmentionedabove alongwithmanyotherusefulin equalities.
t hese invariants help understand the precise semanti cs of 2x q y.alt rdescribes the intended behavior of integer division the di videndx equals the divisor y.alttimes the quotient qplusthe remainder r.the program and verify its correctness properties.
moreove r by instrumenting the program with a counter variable numinvcan even infer program running times as a function of the inputs.
for example numinvis able to infer the precise running time of the programinfigure5 page7 whichhasatricky triple neste dloop.
we evaluated numinvby using it to infer invariants on more than90benchmarkprogramstakenfromthenla andhola suitesforprogramverificationandfromexamplesinthelite rature on complexity bound analysis .
our results show that numinvgenerates sufficientlystronginvariants toverifycorrectn ess and to understand the semantics of nla programs contai ning nontrivial arithmetic and polynomial relations.
we als o find thatnuminvdiscovers highly precise invariants describing nontrivial complexity bounds for programs used to benchm ark static complexityanalysis techniques in fact for progr ams numinvobtains more informative bounds than what were given in the literature .
we note that both ice and pie cannot find any oftheseinvariants producedby numinv even when weexplicitly tellthese toolsthatthey shoulda t tempt toverify theseinva riants.
finally on the hola programs we compare numinvdirectly with pie.
we find it performs competitively in cases it s inferredinvariantsmatchpie s arestronger oraremoredes criptive.
t hus although numinvcan potentially return unsound invariants our experience shows that it is practical and effective in removinginvalidcandidatesandinhandlingdifficultprograms with complex invariants.
we believe that numinvstrikes a practical balance between correctness and expressive power allowin g it to discover complex yet interesting and useful invariants ou t of the reach of thecurrentstateof theart.
overview numinvgeneratesinvariantsusingthetechniqueof counterexampleguided invariant generation cegir .
at a high level cegir consists of two components a dynamicanalysis that infers candidate invariants fromexecutiontraces anda staticverifier tocheckcandidatesagainsttheprogramcode.
ifacandidateinvariant i sspurious theverifieralsoprovidescounterexamples cexs .
tracesfrom thesecexs arerecycled torepeat theprocess hopefullypro ducing accurateresults.
t hesestepsofinferringandcheckingrepe atuntil no new cexs or true invariants are found.
t he cegir approach is basically exploiting the observationthat inferring a so und solution directly is o f ten harder than checking a cheaply genera ted candidatesolution.
otherpromisingcegiralgorithms e.g.
theice pieand guessand check tools havebeendevelopedinrecentyearsthattakethe same approach though they refer to it differentl y. in particular they refer to cegir as a data driven orblack box approach wherethedynamicanalysisiscalledthe studentorlearner and the static verifier is called the teacherororacle.
t hese approaches have been able to prove correctness of specificatio ns by inferringinductiveloopinvariants orsufficientandneces sarypreconditions.
someoftheseworks iceandpie areverificatio noriented i.e.
they infer invariants to specificallyprove a giv en assertion.
inthisapproach thecomputationofthese helper in variantscounterexample guidedapproach tofinding numerical invariants esec fse september4 paderborn germany strictlydependsonthegiven assertions e.g.
iftheinten dedassertionistruethentheinferredinvariantcanbejust true.
wereview these worksin moredetail insection6.
numinvhasdifferent goalsandtakes adifferent approach.
our goals are both discovery and verification and our approach i s to find the strongest possible invariant at any arbitrarily giv en location.
when given an undocumented program numinvcan discoverinterestingpropertiesandprovideformalspecificat ions.
for example numinvcanrevealastrongerpostconditionthantheuser might think to write down and the user doesn t have to write down any postconditions at all.
moreover when given a speci fic assertion the resulting invariant from numinvcan help prove it e.g.
iftheinvariantmatchesorisstrongerthantheasser tion .
empirically numinvcan frequently infer invariants that are at least as strongas thepostcondition and frequently stronger.
.1numinv numinvinferscandidateinvariantsusingthealgorithmsfromdig which produce equality and inequality relations from t races.
tocheck invariants numinvinvokes klee a symbolic executorthatis abletosynthesize testcases forfailing tests.
klee as a verifier .
numinvgenerates candidate invariants at program location lof interest e.g.
at the start of loops or at the end of functions .
to check whether a property pholds at a locationl numinvasks klee to determine the reachability of the locationlwhen guarded by p. for example to check whether therelation x q y.alt ris aninvariant at somelocation l numinv modifies theprogramas follows ... if !
x qy r save x y q r cex traces abort ... klee then runs this program systematically exploring the s pace of possible inputs.
if during this process location lis reached then the relation does not hold so a cex consisting of the val ues of the relevant input variables is saved for subsequent infe rence.
ontheotherhand kleemaybeabletoexploreallprogrampath s and thus verify that indeed that invariant pholds.
or if this is infeasible numinvterminates kleea f tersometimeout.
t he use of klee as the verifier is a key feature of numinv.
because programs o f ten contain a very large number of possibl e paths klee rarely explores all of them.
however in our expe rience section if it does not quickly find a counterexample for pthenpvery likely holds.
t his is true even when pis a nonlinear polynomial relation.
as such klee serves as a practical improvement over existing theorem provers and constraint sol vers for which reasoning over general polynomial arithmetic is a significant challenge.
inferring polynomial equalities and linear inequalities.
numinv uses two cegir algorithms to find candidate numerical relati ons pat program locations of interest.
t he first algorithm finds polynomialequalities .
todothis foreachprogramlocation l numinvproduces a template equation c1t1 c2t2 cntn .
t his equation contains nunknown coefficients ciandntermsti with one termfor each possiblecombinationof relevant program vari ables up to some degree d.numinvcalls klee on the program to systematically obtain many possible valuations of relevant va riables atl.eachdistinctobservedvaluation whichwecalla trace issubstituted into the template to form an instantiated equation .
a f ter obtainingatleast ntraces numinvsolvesthe ciusingtheresulting setofequations.
substitutingthesolutionsbackintothet emplate we canextract candidate invariants.
at this point numinventers a cegir loop that tests the candidate invariants by using kle e as described above.
any spurious invariants are dropped an d the corresponding cex traces are used to infer new candidates a s describedabove untilno additional trueinvariants are foun d. numinv s second algorithm tries to infer linear inequalities in the form of octagons which are inequalities over two variables containing eight edges.
it refines the bounds on the candidat e invariants using a divide and conquer algorithm.
once again numinvestimates and obtains an initial set of traces.
it enumerate s allpossibleoctagonalinequalityformsinvolvingoneandt wovariables and uses klee to check inequalities under these forms a re within certain ranges .
it then narrows this range iteratively seeking tighter lower and upperbounds.
finally from the obtained equality and inequality invaria nts numinvremoves any invariants that are logical implications of other invariants.
for instance we suppress the invariant x2 y.alt2 if another invariant x y.altis also found because the la t ter implies the former.
we check possible implications using an smt solv er checkingwhetherthenegationoftheimplicationisunsati sfiable .
.
example recalltheprogram cohendiv infigure1 whichtakesasinputtwo integersx y.altand returns the integer qas the quotient of xand y.alt.
given this program and locations of interest l1andl2 numinv automaticallydiscovers thefollowing loop invariants a tl1 x q y.alt r b y.alta y.alt b b r r x a b2 a y.alt and thefollowing postcondition invariants at l2 x q y.alt r1 q r r x r y.alt r t hese equality and inequality relations are sufficiently stro ng tounderstand the function s semantics and verify thecorre ctness ofcohendiv.
morespecifically the nonlinear equation x q y.alt r describes the precise behavior of integer division the div idendx equalsthedivisor y.alttimesthequotient qplustheremainder r. t he other inequalities also provide useful information for deb ugging.
forexample theseinvariantsreveal several requiredprop ertiesof the remainder rsuch asris non negative r is at most the dividend r x but is strictly less than the divisor r y.alt .
inaddition theseinvariantscanhelpproveassertionsift heyexist in the program.
for example if we want to assert and prove the postcondition stating that the returned quotient is non ne gativeesec fse september4 paderborn germany than hvu nguyen timos antonopoulos andrew ruef and michael hick s q thenwecaneasilydosobecausethediscoveredinvariant s atl2implyq .
as mentioned above ice and pie generate invariants to prove specific assertions.
t hus given a program with no specific ass ertion they will not provide anything useful.
even when asked to verify a specific assertion e.g.
x q y.alt ror other simpler invariants above found by numinv these tools fail to prove them pie doesnotconvergeandicefailstogenerateinvariantstopro vethe givenassertions .
wedonothavetheimplementationofthe guessand check algorithm in to runon this example however this work does not support inequalities and thus would not genera te theinequalityinvariants shown.
inferring polynomial equalities we now discuss numinv s cegir algorithm for generating polynomial equalities among program variables.
t his algorithm i ntegrates the equation solving technique in dig with klee to find invariants.
.
terms templates and equation solving numinvinfers polynomial equalities by searching for solutions to instantiations of a template equation having the form c1t1 c2t2 cntn whereciarereal valuedand tiareterms.
terms consist of monomials over program variables.
more specifica lly given a set vof variables and a degree d numinvcreates a set of nterms consisting of monomials up to degree dfromv.
for instance the n terms r y.alt a r y.alt ra y.alta r2 y.alt2 a2 consist of all monomialsup todegree over thevariables r y.alt a .
numinvseekstosolvethe ciinthetemplateequationby instantiatingthetiwith values observed from traces.
for our example instantiating thetemplatewith thetrace r y.alt a 6would yield the equation c1 3c2 36cn .
if there are nterms we need at least ndistinct valuations of the variables in v. given the at least nequations that result a f ter instantiation we solve fortheci substitutingtheirsolutionsintothetemplatetoproduce equationsover the combinations of variables in v. .
algorithm figure2showsthecegiralgorithmforfindingpolynomialequ alities.
given a program p location l and a degree d numinvautomatically computes all equalities with degree up to dover the numerical variables at l. insection5 wediscuss ouruseofa single parameter that automatically adjusts the degree ddepending ontheprogram .
t he first steps are to identify the variables at the program location of interest and then to construct the terms and templ ate as described above.
t hen in the first loop we use klee to obtain traces to instantiate the template and thereby produce equationsoverthecoefficientsassociatedwiththegeneratedter ms. to obtain traces we simply ask klee to find cexs producing trace s reaching l morespecifically thelocationguardedby falseatl .
to avoid ge t ting old inputs weexplicitly ask kleeto returno nly new inputs by adding assertions that the input variables ar e not any of theobserved ones .
a f terproducingenough equations we 3numinvalsofoundthisassertionandotherpostconditions at l2 butdiscardedthem becausethey areimplied byother discoveredinvariantsand arethus redundant.input a program p a location l a degree d output polynomial equalities overthevariablesat luptodegree d vars extractvars p l terms createterms vars d template createtemplate terms inps traces eqts invs while eqts terms do cexinps verify p l false inps ifcexinps then ifinps then return false unreachable else return notenoughtraces inps inps cexinps traces exec p l cexinps eqts eqts instantiate template traces sols solve eqts candidates extracteqts sols terms whilecandidates nequal do cexinps verify p l candidates inps foreachcandidate candidates do ifcandidate .stat nequalfalsetheninvs.add candidate ifcexinps thenbreak inps inps cexinps traces exec p l cexinps eqts eqts instantiate template traces sols solve eqts candidates extracteqts sols terms candidates candidates invs returninvs figure2 cegiralgorithmfor findingequalities.
solvethemusinganoff the shelflinearequationsolverand extract resultsrepresenting candidateequalityrelations among t erms.
next thealgorithmentersasecondloopthatiterativelyve rifies candidateinvariantsandobtainscextraces allowingthei nference algorithmtodiscardspuriousresultsandgeneratenew inva riants.
numinvacceptsacandidateinvariantaslongaskleecannotfind acexforitwithinthetimeoutperiod.
werepeatthestepsofv erifyingcandidateinvariants obtainingcexs andinferringne wresults untilwecan no longer findcexs ornew results.
note that unlike the popular cegar counterexample guided abstract refinement technique in static analysis that u sually startswithaweakinvariantandgraduallystrengthensit numinv s cegir algorithm starts with a strong invariant i.e.
false and iteratively weakens it.
t his is because the algorithm dynamica lly infers invariants using observed traces.
we start with few t races andthuslikelygeneratetoostrongorspuriousinvariants.
wethen accumulatemoretracestorefutespuriousresultsandcreat emore general invariants thatsatisfy allobtainedtraces.
we also note that an interesting property of nonlinear polyn omial equalities is that they can represent a form of disjunctive invariants.
for example x2 indicates that x x .
in section .
we exploit this useful property to find multiple c omplexityboundsofa program.counterexample guidedapproach tofinding numerical invariants esec fse september4 paderborn germany .
example we demonstrate this technique by finding the equalities b y.alta andx q y.alt ratlocation l1inthecohendiv program infigure1 when using degree d .
for the six variables a b q r x y.alt atl1 together with d wecreate28terms a ... y.alt2 .numinvusesthesetermstoform thetemplate c1 c2a ...c28 y.alt2 0with28unknowncoefficients ci.
next inthefirstloop numinvuseskleetoobtaintracessuchas thosegiveninfigure1toform atleast 28equations.
fromt hisset of initial equations numinvsolves and extractsseven equalities.
nownuminventersthesecondloop.
initeration kleecannotfindcexsfortwoofthesecandidates x q y.alt r b y.alta which are actually true invariants and save these as invariants.
klee finds cexs for the other five 4andnuminvforms new equations fromthecexs.
next numinvcombinestheoldandnew equations to obtain another seven candidates two of which are the alre ady savedones becausewealsousetheoldequations .
initerat ion klee obtains cexs for the other five candidates.
with the help of the new cex equations numinvnow infers three candidates two of which are the saved ones.
in iteration numinvuses klee tofindcexsdisprovingtheremainingcandidateandagainuse sthe newcexstoinfernewcandidates.
t histime numinvonlyfindsthe twosaved invariants x q y.alt r b y.altaand thusstops.
inferring octagonal inequalities a b c d e figure a a set of points in 2d and its approximation usingthe b polyhedral c octagonal d zone and e inte rval regions.
t hese shapes are represented by the conjunctions of inequalities of the forms c1 v.alt1 c2 v.alt2 c v.alt1 v.alt2 c v.alt1 v.alt2 c and v.alt c respectively.
numinv ssecondalgorithmaimstoinferlinearinequalitiesamong programvariables essentiallybya t temptingtofindaconvex polyhedron in a multi dimensional space that contains all obser ved trace points.
figure illustrates several examples of poly gons in two dimensional space.
figure 3a shows a set of points creat ed from input traces.
figures 3b 3c 3d and 3e approximatethe area enclosingthesepointsusingthepolygonal octagonal zon e andinterval shapes that are represented by conjunctions of inequalities of different forms as shown in figure .
t hese forms of relation s are sorted in decreasing order of expressive power and compu tational cost.
for example interval inequalities are less ex pressive than zone inequalities and computing an interval i.e.
th e upper andlowerboundofavariable costsmuchlessthancomputing the convex hullof azone.
numinvinfers octagonal inequalities.
t hese can be computed efficiently linear time complexity and are also relatively expressive e.g.
represent zone and interval inequalities as illu strated in t hesespuriousresultso f tenhavemanytermsandlargecoefficie nts e.g.
thesimplest of these sevenis r y.alt2 x y.alt2 72r y.alt 72x y.alt 8190q 1397r 1397x .function findupperbound term minv maxv p l ifminv maxvthenreturn maxv else ifmaxv minv 1then cexinps verify p l term minv ifcexinps then return minv else return maxv else midv maxv minv cexinps verify p l term midv ifcexinps then maxv midv else disproved traces exec p l cexinps minv max instantiate term traces returnfindupperbound term minv maxv p l figure4 cegiralgorithmfor finding inequalities.
figure3 .
t hus thecomputationofoctagonalinequalitiesa lsoproduceszoneandinterval inequalitiesforfree.
bybalancing computational cost with expressive power octagonal relations a re especially useful in practice for detecting bugs in flight contr ol so f tware and performing array bound and memory leak checks .
.
terms t heedgesofaninferredoctagonarerepresentedbyaconjunct ion ofeight inequalities oftheform a1 v.alt1 a2 v.alt2 k where v.alt1 v.alt2are variables a1 a2 arecoefficients and kis a real valued constant.
for example from the traces in figure we could i nfer octagonal inequalities such as r and r y.alt at locationl1.
numinvinfers octagonalinequalities bytrying to prove invariantst kfor some constant k. here tis a term involving two variables so that t kis an octagonal constraint e.g.
tcould be x y.altorx y.alt.
moreprecisely weconsiderallpossibletermsfor n variables wecreate n2variablepairs from aset of nvariables and obtain8octagonalterms v.alt1 v.alt2 v.alt1 v.alt2 foreach pair v.alt1 v.alt2.
for each such term we a t tempt to prove its upper bound k1and lower bound k2 if they exist using thealgorithmdescribed next.
.
algorithm one idea for inferring inequalities would be to iteratively refine conjectured bounds using cexs but this can take a long time.
for example tofindtheinvariant x wecanfirstinfer x 1from tracessuchas x .
wecanthendisprovethiscandidatewith cexs such as x and weaken the relation to x which canalsobedisprovedandweakened.
t hiskeepsgoinguntilweg et thecexx whichwouldallowustoobtainandprove x .
evenworsethantakingalongtimetoreachthebound k thisbruteforceapproachdoesnotterminatewhen xhasnoconstant bound.
as such weusea divide and conquer style search instead.
findingupperand lower bounds.
we use the cegir algorithm showninfigure4tocomputeapreciseintegralupperbound kofaesec fse september4 paderborn germany than hvu nguyen timos antonopoulos andrew ruef and michael hick s termt.
similartoabinarysearch thisalgorithmcomputes kfrom agivenintervalbyrepeatedlydividinganintervalintohal vesthat could contain k. we start with the interval where maxv minv our experience is that inequalities are most useful with small constants so by default we set maxv .
next we check t midvwheremidv maxv minv .
if this inequality is true then kis at most midvand thus we reduce the search to the interval .
otherwise we obtain counterexample traces showing that t midvand reduce the search to whereminv isthelargesttracevalueobserved fort.
t hus this approach gradually strengthens the guess of kby repeatedlyreducingtheinterval containing it.
wealsousethesameapproachtofindthelowerboundofaterm tbycomputingtheupperboundof t. t hisispossiblebecausethe semantics and results of all computations are reversed when we consider t. for example the max over the traces t with respect to tis and t midvindicates the lower bound of t is at least midv.
t healgorithmterminatesandgivesapreciseupperboundvalu e whentranges over the integers.
t he algorithm stops when minv andmaxvare the same because we no longer can reduce the intervals or when their difference is one because we cannot co mpute the exact midv .
currently numinvdoes not support realvalued bounds.
however we believe that this algorithm can b e extended to handle the case when tranges over the reals.
more specifically we can approximate the results by using only wh ole numbersorvaluesuptocertaindecimalplaces.
t hissacrifice sprecisionbutpreservessoundnessandtermination e.g.
thei nvariant isx .123butweobtain x .
which is alsoan invariant but less precise.
.
example recalltheprogram cohendiv fromfigure1.
suppose numinvwishes to find inequality invariants at l1 within .
it first uses kleetocheckcandidaterelations r y.alt r y.alt r y.alt ...and removes those that klee refutes.
t he remaining relations have upperboundsless thanorequalto10.
for each remaining inequality candidate numinviterates to find tighter upper bounds.
for example suppose we wish to find ksuch that r y.alt k. sincer y.alt the algorithm sets midv 2whichis0andthustriestocheck r y.alt .
t his succeeds.
however this turns out to be weaker than necessary.
in the next iteration numinvtightens the bound to and checks r y.alt .
t his time klee returns a cex showing that r y.alt .
in iteration numinvrelaxes the boundto and kleecannot refute r y.alt .
in iteration numinvguesses and checks in whichcasekleecanfindcexsstatingthat r y.alt .
atthispoint numinvaccepts the tightest bound r y.alt found in iteration .
t heprocessforfindingthelowerboundsissimilarasdescr ibed above.
experimental results numinvis implemented in python and uses the linear equation solverinthesagemathematicalenvironment .
numinvtakes asinputsacprogram alistoflocations andinterestednum ericalvariables at these locations and it returns relations amon g these variables attheconsidered locations.
as mentioned numinvuses dig s algorithms to infer invariants and calls the symbolic execution tool klee to check results and obtain counterexamples f or refinement.
t hefinal stepthatremoves redundant invariants u ses thez3solver tocheck smt formulas.
wegeneratenumericalinvariantsoftwoforms nonlinearpo lynomialequationsandoctagonalinequalities.
foroctagona linvariants numinvby default considers the bounds within the range .
for equalities numinvby default sets a single parameter so that it can generate invariants without a priori knowledge of specific degrees.
numinvautomatically adjusts the maximum degree so thatthe number of generated terms does not exceed .
forexample numinvconsidersequalitiesuptodegree5 foraprogramwithfourvariablesandequalitiesuptodegree 2for a program with twelve variables.
we acknowledge that inferr ing theseparameterconstantsrobustlyandautomaticallyisim portant future work.
t hese constants can be chosen by the numinvuser wechosevaluesbasedonourexperience.
notethatthedivide and conquerapproachtoinferringinequalities infigure4is qu iteuseful if the user decides to increase the bounds for range the number of iterations is log rather than if we use a brute force algorithm but for range it islog not200 using bruteforce .
experiments.
weevaluateandcompare numinvtootherinvariant analysis systems by considering three experiments.
t he fi rst experiment in section .
determines if numinvcan discover invariantsrepresentingprecisesemanticsandcorrectnessp roperties ofprogramshavingcomplexarithmetic.
t hesecondexperimen tin section .
explores the use of numinv s invariants to represent precise program complexity bounds.
t he last experiment in se ction5.
compares numinv s performancewith thestateof theart cegir toolpie.
t he experiments reportedbelow were performe d ona linux system witha coreintel i7 cpuand 32gb of ram.
.
analyzingprogram correctness programs.
in this experiment we focus on generating invariantsthatcapturesemanticsandcorrectnesspropertiesofp rograms with nonlinear polynomial invariants.
for this task we eva luate numinvonthenla testsuiteconsisting ofprograms involvingcomplexarithmetic.
t hesuite shownintable1 consists of27 programsfromvarioussourcescollectedpreviouslybyrodr guezcarbonellandkapur .
t heseprogramsarerelatively small onaveragetwoloopsof20linesofcodeeach.
however theyim plement nontrivial mathematical algorithms involving genera l polynomial properties and are o f ten used to benchmark numerical i nvariant analysis methods .
to the best of our knowledge n la contains the largest number of numerical algorithms with no nlinear polynomialinvariants.
eachprograminnlacomeswithdocumentedorannotatedcorrectness assertions requiring polynomial invariants mos tly loop invariants having nonlinear polynomialequalities.
forev aluation purposes we consider invariants at the annotated location s and comparethem tothedocumentedinvariants.counterexample guidedapproach tofinding numerical invariants esec fse september4 paderborn germany table1 resultsfor27nlaprograms.
check numinv generates sufficientlystrong resultstoprove known invariants.
prog desc locs v t d invs time s correct cohendiv div .
check divbin div .
check manna intdiv .
check hard intdiv .
check sqrt1 sqrroot .
check dijkstra sqrroot .
check freire1 sqrroot freire2 cubicroot cohencu cubicsum .
check egcd1 gcd .
check egcd2 gcd egcd3 gcd prodbin gcd lcm .
check prod4br gcd lcm .
check knuth product .
check fermat1 product .
check fermat2 divisor .
check lcm1 divisor .
check lcm2 divisor .
check geo1 geoseries .
check geo2 geoseries .
check geo3 geoseries .
check ps2 pow sum .
check ps3 pow sum .
check ps4 pow sum .
check ps5 pow sum .
check ps6 pow sum .
check results.table summarizes the results and reports the medians across runs.
column locsgives the number of locations in the programs where we consider invariants.
column invsreportsthenumberof equalityand inequalityinvariants disc overed bynuminv.
column v t dshows the number of distinct variables terms andthehighestpolynomialdegreeinthoseinv ariants.
columntimereportsthetimeinsecondstogeneratetheseresults including thetime toremove redundant results.
column correct indicateswhethertheseinvariantsmatchedorwerestronge nough toprove imply thedocumentedinvariants.
numinvfoundinvariantsthatmatchedorweresufficientlystrong toprovethedocumentedinvariantsof23 27programsinnla.
for theseprograms wediscoveredresultsmatchedthedocument edinvariantsexactlyaswri t teninmostcases.
numinvalsoachievedinvariants thatarelogicallyequivalenttothedocumentedon es.
for example sqrt1hastwodocumentedequalities2 a t a s our results gave a t t2 2t 4s which is equivalent to a sby substituting twith 2a .
in many cases numinv also found undocumented invariants e.g.
most of the discovered octagonal inequalities in the cohendiv program in figure are undocumented.
for dijkstra numinv found the documented invariant describing the semantics of a loop comput ation but also discovered an undocumented loop invariant h3 12hnq 16npq hq2 4pq2 12hqr 16pqr.
manual analysis shows that this strange relation is correct and captures det ailed dependencies amongvariablesintheloop.
t hus numinv sstrongvoidtriple intn intm intn assert n m n inti j k intt while i n loop j t while j m loop j k i t while k n k t loop i k i figure5 anexampleprogramthathasmuliplepolynomial complexitybounds.
invariants can help with understanding both whatthe program does and also howthe program works.
in section .
we further exploitsuchcomplex invariants toanalyze programcomplex ity.
fortheseprograms theruntimeforfindingequalityinvaria nts is dominated by solving equations because we are solving hun dredsofequationswithhundredsofunknownseachtime.
t heru n time significantly improves if we restrict the search to inva riants uptoa certaingiven degree.
forexample numinvtook2stofind the invariants in sqrt1using degree but it took 20s to find the same invariants using the parameter which queries numinvfor all invariants up to degree in this program.
for egcd1 therunning timeis also cutbymorethanhalf if weonlyfocuso n quadratic invariants.
for inequality invariants the runn ing time isdominatedbycheckingbecausewerapidlyguesstheboundv aluesandcheckthemwithklee.moreover numinvhastoperform this guessandcheck computationforoctagonalconstrain tsover allpossiblepairs ofvariables.
wewerenotabletofindinvariants for4 27programs.
numinv was able to infer results matching the documented invariant s for freire1andfreire2 but klee cannot run on these programs becausetheycontainfloatingpointoperations.
for egcd2andegcd3 theunderlyingsageequationsolverstoppedrespondingfor more thanhalfofthe11runs thoughweobservedallcorrectresul tsfor the runs during which the solver worked .
t hese problems migh t occur because the solver has to consider hundreds of equatio ns withvery largecoefficients forhundreds of unknowns.
wearei nvestigating and reportingthese problemstothesage develo pers.
.
analyzingcomputational complexity weusenuminvtodiscoverinvariantscapturingaprogram scomputationalcomplexity e.g.
o n3 wherenis some input.
figure shows the program triplewith three nested loops adapted from the program in figure of gulwani et al.
.
t he complexity of thisprogram i.e.
thetotalnumberofiterationsofallthr eeloopsat locationl appears to be o nmn at first glance.
additional analysis yields a more precise bound of o n mn n because theesec fse september4 paderborn germany than hvu nguyen timos antonopoulos andrew ruef and michael hick s number of iterations of the innermost loop is bounded by ninstead ofnmnand it furthermoredirectlyaffects the running time of theoutermostloop .
whengiventhisprogram numinvdiscoversaninterestingand unexpectedpostconditionatlocation laboutthecountervariable t which is a ghost variableintroducedtocountloopiteratio ns n2mt nm2t nmnt m2nt nmt2 mnt2 nmt nnt 2mnt nt2 mt2 nt2 t3 nt t2 .
at first glance this quartic degree equality with term s looksincomprehensibleandquitedifferentthantheexpecte dbound o n mn n oreveno mnn .however solvingthisequationfor t i.e.
findingtheroots yieldsthreesolutions t t n m andt n m n n .
careful analysis reveals that these results actuallydescribe threedistinctand exactboundsof this pr ogram t when n t n m when n n t n m n n whenn n. t hus numinvcanfindnumerical invariants thatrepresent preciseprogramcomplexity.
moreimportantly theobtainedre lations candescribeexpressiveandnontrivial disjunctive invariants which capturedifferent possiblecomplexityboundsofa program.
programs.
we apply numinvto find complexity invariants on programs adapted from .
t hese programs shown in table2 aresmall buttheyhave nontrivialstructuressuchas nested loopsand represent examples drawnfrom microso f t s product ion code .
for these programs we introduce the counter vari able tandobtainrelations among tand othervariables suchasinputs at theprogramexit locations.
results.table2showsthemedianresultsacross11runsandhas similarformatasthatoftable1.
forcolumn bound acheckmark denotes that numinvgenerates invariants representing a similar boundtotheonereportedintherespectivepaper.
adoublech eckmark check check denotesthat numinvobtainsmoreinformativebounds than reportedresults.
a checkmark with anasterisk check denotes that theprogram was modifiedslightly toassist theanalysis .
as can be seen numinvproduced very promising results that capture the precise complexity bounds for these programs.
f or programs numinvdiscovered expected or even more informative bounds than reported results in the respective paper s. for many programs numinvgenerated equalityinvariants representing tight bounds which can be combined with the discovered o ctagonalinequalitiestoproduceexpectedbounds.
forexamp le for popl09fig34 numinvobtained that the number of iterations tis eithernorm.
in addition numinvfinds inequalities expressing thattis larger than both nandm suggesting that tis equal to max n m whichistheboundalsoobtainedin .
t hus inequalities though appearing much weaker compared to the obtaine d equalities playanimportantroletoachieve preciseprogr amanalysis.
interestingly in some cases numinvproduced results that are more informative than the ones given in the respective paper s. 5wedisablenondeterministicfunctionsintheseprogramsbe causecurrently numinv assumesdeterministic programs.table results for computing programs complexities.
check numinv generates the expected bounds.
check check numinv obtains more informative bounds than reported results.
check program wasslightly modifiedtoassistthe analysis.
prog v t d invs time s bound cav09fig1a .
check cav09fig1d .
check cav09fig2d .
check cav09fig3a .
check cav09fig5b .
check pldi09ex6 .
check pldi09fig2 triple .
check check pldi09fig41 .
check pldi09fig42 .
check pldi09fig43 .
check pldi09fig44 .
pldi09fig45 .
check popl09fig21 .
check check popl09fig22 .
check check popl09fig34 .
check popl09fig41 .
check popl09fig42 .
check check popl09fig43 .
check popl09fig44 .
check t hisisparticularlythecasefortheprogram tripleanalyzedearlier becausethethreedistinctboundsproducedby numinvarestrictly lessthanthebound n mn ngivenin .
wenotethatinmost othercaseswhere numinvobtainedabe t terbound thedifferences were notas apparent as they were for triple.
we performed some adaptations in certain programs to assist the bound analysis.
for cav09fig5b we considered the invariant obtained as one close to the expected bound.
for popl09fig41 weinsertedanassertstatementthat m 0atthebeginning ofthe program.
finally for pldi09fig45 for the number of iterations t we obtained the three solutions t n m t m ort which implythecorrectupperbound max n m m .
finally numinvobtainedinvariantsthatarenotstrongenough toshowtheexpectedboundfor pldi09fig44.
however wewould haveobtainedthisboundifwehadintroducedavariable ora term representing thequotientfromthedivisionof twoothervar iables in the program.
in our experiments when inserting such a var iable weobtainedboundsthatweretighterthantheonespres ented in .
suchcasessuggestapossibleextensionto numinvforpredictinguseful terms.
.
comparing topie numinvautomaticallygeneratesinvariantsforaprogramlocation withoutanygivenassertionsorpostconditions.
otherstat e of theartcegirtoolssuch as pie generate invariants ina goal dir ected manner driven by supplied postconditions.
in this experim ent we compare numinvwith pie s guided inference with postconditions.
t his experiment used the hola benchmark programs adapted by the developers of pie .
t hese programs shown in t able are short loc each c programs already annotate d withpostconditions.counterexample guidedapproach tofinding numerical invariants esec fse september4 paderborn germany table results for the hola benchmarks .
check made invariantsfrompie.
check check madestrongerinvariantsthanpie.
anasterisk indicatesthatverifyingtheinvariantrequired additional investigation.
failed to make any invariants no running timereportedinthat case.
benchmark pietime s numinv time s correct .
.
check check .
.
check .
.
check check .
na .
.
check check .
.
check na .
check .
.
check check na .
check .
na .
na .
na na .
check .
.
check check .
.
check .
.
check .
.
check check .
.
check check na .
check .
.
check check .
.
check .
.
check .
.
check check .
na na .
check .
.
check .
.
check .
na .
na .
na .
.
check .
na na .
check .
.
check check .
.
check na .
check na .
check check .
.
check .
.
check .
.
check .
.
check check .
.
check check .
.
check .
.
check .
.
check .
na we first ran pie on each program and recorded pie s running timeinseconds.
t hen weremoved thepostconditionand ran numinv asking it to generate invariants at the location in the program where the postcondition was.
if numinvwas able to generate invariants we compared those invariants to the postc ondition.
iftheinvariants that numinvgenerated wereatleastpreciseenough toestablish thegiven postcondition then numinvearned a checkmark check .
if the invariants were more precise then numinvearnedadoublecheckmark check check .
fortheprogramsthat numinvcould not generate invariants then the analysis is assigne d thesymbol .
t he resultsare intable3.
for36 46programs numinvfoundinvariantsthatwereatleast as strong as the postconditions in the pie programs.
for the r emaining programs numinvfailed to producethe necessary invariants.
for of the programs where numinvproduced invariants numinvwas able to generate stronger invariants.
for example forprogram17 thetargetpostconditionwas k ngiven a precondition n andnuminvproduced among other invariants that k n3 n which implies that for all n k n. for programs having the check or check check numinvfound stronger invariants that imply the given postcondition but require additional human effort to reason about.
for program the given postconditionis a i.e.
ais odd.numinvfound theinvariantsx y.alt x y.alt u1 a a x y.alt and2u1 x y.alt .
t hissetofconstraintsimpliesthat x y.alt u1 anda x y.alt which indicates that ais indeed odd.
butthefirstinvariant inthis set produced by numinv also points to another relation among those variables namely that at least one of xand y.altis equal to and thus we marked this example with a double checkmark and additionallyannotated it withanasterisk.
anotherinterestingcaseiswithprogram8thatcontainsapo stcondition x y.alt which has a disjunctive form of strict inequalities that numinvdoes not support.
instead of generating this numinvreturns astronger relation x y.alt which impliesthis postconditionand therefore proves it.
summary.
t hese experiments show that numinvis effective in producing expressive and useful invariants.
t he nla experim ent in section .
shows that numinvdiscovers necessary invariants to understand the semantics and check correctness properti es of nla programs containing nontrivial arithmetic.
t he co mplexityexperiment insection5.
indicates that numinvdiscovers useful invariants that capture challenging complexity bou nds for 19programsusedtobenchmarkstaticcomplexityanalyse s. we alsonotethattherecent cegirtoolsiceandpiecannot findan y of these nonlinear polynomial invariants produced by numinvin these experiments even when we explicitly tell these tools that they should a t tempt to verify these invariants.
finally the hola experiment insection5.
showsthat numinvcompeteswell with pie and in programs discovers invariants that match or are moreinformative thanpie s. .
t hreats to validity asmentionedearlier numinvcanreturn unsoundresultsbecause kleecannotfullyverifyprogramswithcomplexpolynomialp roperties.
we can recover soundness by using a true verifier inst ead e.g.
weareconsidering theverificationtoolscpachecker and ultimate automizer which performed well in the recent svcomp2017 .
however ourexperienceshowsthatkleeiseffe ctiveinfindingcounterexamplesdisprovinginvalidresults andthus results that klee cannot disprove have high likelihood of be ingesec fse september4 paderborn germany than hvu nguyen timos antonopoulos andrew ruef and michael hick s correct.
kleeisalsopracticalbecauseitcanconsiderchal lenging invariants that arenot understandabletomany soundverifie rs.
klee does not fullysupportfloating point arithmetic and thu s numinvislimitedtofindinginvariantsoverintegralvariables.
kl ee is also language dependent thus numinvconsiders only c programs.
weareextending numinvwithadditionalverificationbackends that supportricher semantics e.g.
arithmetic over t hereals and other languages e.g.
jpf forjava programs .
dig s algorithms focus on specialized classes of numerical invariants thus numinvis unlikelytofindinvariants ofother unrelatedforms.
however ourresultsshowthat numinvcano f tengenerateinvariants thatarelogicallyequivalentorsufficient lystrong toprove otherforms ofcomplex invariants e.g.
disjuncti ve ones.
although our benchmark programs have nontrivial structure s e.g.
nestedloops withcomplexarithmeticandhavebeenu sedto evaluatemoderninvariantgenerationsystems theseprogr amsare smallanddonotrepresentreal worldapplicationscontain inghundreds of thousands of lines of code.
nonetheless we believe that cegir is a promising approach to build invariant analysis to ols thatcanscaleandhandlelargerandmorecomplexcodebases.
t his isbecausedynamic analysis allowsforinferring expressiv e invariants efficiently fromtraces andstaticcheckers such askleeh ave becomemorepowerfuland practicalinrecent years.
related work wereviewrelatedinvariantgenerationtechniquesusingpu restatic analysis dynamic analysis and cegirapproaches.
static invariant generation.
abstract interpretation computesaninvariant thatover approximates reachablepr ogram states.
t his method starts from a weak invariant representin g an initial approximation and iteratively strengthens the inv ariant by analyzingthestructureoftheprogramuntilreachingafixed point.
over approximation can lead to imprecise information and p roduce false positive errors.
t hus major research directions in this area focusonfinding abstractdomains thataresufficientlyexpressivetoretainimportantinformationfromtheprograms.
for example theworkin focusonthesix edged zonerelation s and theeight edge octagonrelations shownin figure .
rodr guez carbonell et al.
use abstract interpretation to generate nonlinear polynomial equalities.
t hey first obse rve that a set of polynomial invariants forms the algebraic stru cture of an ideal then compute the invariants using gr obner basis and operations over the ideals based on the structure of the pro gram until reaching a fixed point.
t he work only analyzes programs with assignments and loop guards that are expressible as pol ynomial equalities.
in addition this technique does not find in equalities and doesnotsupportprograms withnested loops.
dynamicinvariantgeneration.
t hepopulartooldaikon infers candidate invariants from traces and templates.
daikon comeswithalargelistofinvarianttemplatesandteststhem against programtraces.
templatesthatareviolatedinanyofthetes truns are removed and the remainders are presented as the possible invariants.
for numerical relations daikon can find linear re lationsover at most three variables and has a small number of fixed non linear polynomial templates such as x y.alt2.
in general the tool has limitedsupportforinequalities and disjunctive invar iants.
cegirapproaches.
sharmaetal.
presenta guess and check technique for inferring equality invariants.
t his techniqu e is the standardcegirapproach andthe guess componentinferse qualitiesusingthesimilarequationsolvingtechniqueindig.
t h usfor equality thistechniquehasthesametheoreticalpoweras numinv.
t he check component uses the z3 smt solver and in this context itisinterestingtonotethevariousdifferencesinrun ningtime caused by the different choices made in the la t ter and our imple mentation and specifically the use of klee instead of z3.
t his guess and check approach is limited to equality relations and as mentioned in section .
it is not trivial to extend to findin g inequalityinvariants.
t he pie precondition inference engine tool can generatebothpreconditionsandloopinvariants toautomaticall yverify given assertions.
given an assertion q the goal is to produce a predicate formula sufficiently strong to ensure the assertio n. to do this pie iteratively learns and refines a set of features predicates over inputs such as x that are sufficiently strong to separate good traces satisfying qand bad traces violating q. t hese predicates form the required precondition that proves the assertion.
t henoveltyofpieisthatitdoesnotrelyonafixedc lass ofpredicatesandcanconstructnecessarypredicatesdurin gtheinference process.
nonetheless the tool cannot provide inva riants for arbitrary locations in the program especially if no add itional assertions are given.
more specifically on the cohendiv example infigure pie didnot converge toaninvariant.
t he ice implication counter example learning model i s alsoacegirapproachthatgeneratesinductiveinvariantst oprove given assertions.
t he student usesadecisionlearning alg orithm toguesscandidateinvariantsexpressedoverpredicates w hichseparate the good and bad traces.
t he teacher uses the boogie ve rifier to check and provide good bad and novel implication co unterexamplestohelpthestudentinfermorepreciseinductiv einvariants.
for efficiency they restrict a t tention to the octagon do main andsearch onlyforpredicatesthatarearbitrarybooleanco mbinationsofoctagonalinequalities.
similartopie iceinfers onlynecessary invariants to prove assertions.
even when provided w ith assertions such as the postconditions of the program cohendiv in figure ice fails to prove them.
we note that part of the reas on mightbebecauseicedoesnotsupportarithmeticoperations such as divisionand modulo.
conclusion wepresent numinv a cegir basedtoolthatdiscovers numerical invariantsatarbitraryprogramlocations.
numinvusesadynamic analysistoinferinvariantsandthetest inputgeneration toolklee toverify them.
for invalid invariants kleereturns counte rexample traces that are then used to help the inference algorithm discardinvalidresultsandtofindnewinvariants.
t heuseofklee allowsnuminvtoworkonprogramswithnontrivialarithmeticand discover useful and complex invariants.
preliminary exper imentscounterexample guidedapproach tofinding numerical invariants esec fse september4 paderborn germany show that numinvo f ten outperforms state of the art cegir systemsindiscoveringinvariantsrequiredtounderstandanda nalyze semantics correctness and complexitypropertiesof prog rams.