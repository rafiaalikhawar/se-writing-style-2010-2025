development history granularity transformations k van mu slu luke swart yuriy brun michael d. ernst university of washington university of massachusetts seattle wa amherst ma kivanc lukeswart mernst cs.washington.edu brun cs.umass.edu abstract development histories can simplify some software engineering tasks but different tasks require different history granularities.
for example a history that includes every edit that resulted in compiling code is needed when searching for the cause of a regression whereas a history that contains only changes relevant to a feature is needed for understanding the evolution of the feature.
unfortunately today both manual and automated history generation result in a single granularity history.
this paper introduces the concept of multi grained development history views and the architecture of codebase manipulation a tool that automatically records a fine grained history and manages its granularity by applying granularity transformations.
i. i ntroduction most software development uses version control to enable collaboration and to create a development history.
the version control history is useful for many tasks such as localizing changes that caused regression failures identifying developers responsible for specific code and manually examining recent changes.
however each of these tasks is best performed at a different granularity of history.
for example finding the cause of a regression failure is best performed on a history of all points during development at which the code compiled studying fine grained change patterns or backtracking requires the finest possible granularity and understanding how a bug was fixed requires seeing one snapshot before the bug repair began and one snapshot after the repair completed.
unfortunately today s approaches generate inflexible histories each of which works well for only a subset of software engineering tasks.
manually managed histories tend to be too coarse grained while automatically recorded histories are too fine grained.
specifically manually managed histories coarse granularity causes them to omit many points during development at which the code compiled necessary for localizing the cause of a regression.
it is virtually impossible to manually create the fine grained history necessary for studying change patterns and backtracking .
and a manually managed history is unlikely to contain the snapshots right before and after a repair.
manually managed histories are suboptimal for development tasks not just because they fail to include important moments during development but also because manual version control checkpoints often tangle changes made for multiple development tasks such as fixing a bug and refactoring code.
by contrast automatically managed approaches record all developer actions and lead to fine grained histories that are well suited to studying developer behavior but poorly suited to manual examination and for analyses that rely on semantic checkpoints.
even if a history can be created at an ideal granularity for a specific task no single way of recording the history can satisfy all tasks because different development tasks require different granularities.
additionally development taskssometimes require the development history to be restructured.
for example one way to understand a bug fix is to reordering the history to move away any unrelated changes that were performed during the fix so the developer can focus on the relevant changes.
we argue that since different development tasks require accessing the development history at different granularities and that the histories produced using today s methods are inflexible and offer no tools to change history granularity a new approach is needed.
we posit that the development history should not be restricted to a single granularity.
instead the history should be recorded automatically in a way that allows its granularity to be transformed into the one best suited for the particular development task at hand.
to that end we designed codebase manipulation to mitigate the inflexibility of current development histories by automatically recording a finegrained development history and providing the developer with tools to manipulate the granularity and the order of the history.
codebase manipulation allows the developer to change the history granularity repeatedly and all its history manipulations are reversible.
this supports development tasks that require the developer to view the history at multiple granularities.
this paper presents a set of primitive manipulation transformations that can be combined to manage history granularity.
we demonstrate powerful granularity transformations that can be composed of these primitives and design an architecture for a tool that automatically records and manages development history granularity.
the three history transforming primitives from which all necessary transformations can be composed are collapse for combining several edits into a single edit expand for splitting a previously collapsed edit into its parts and move for reordering edits.
these primitives are sufficient for example to transform a fine grained development history into granularities such as all file level changes all compilable code and all collocated edits.
in turn this supports activities such as finding the cause of a regression and separating distinct development tasks into separate revisions.
the rest of the paper is organized as follows.
section ii formally defines codebase manipulation concepts and primitive transformations.
section iii shows that powerful granularity transformations can be composed of these primitives.
section iv proposes an architecture for a codebase manipulation implementation.
finally section v places our work in the context of related research and section vi summarizes our contributions.
ii.
d efinitions our goal is to improve the usability of development histories by automatically recording a fine grained version control history and by providing automated granularity transformations to makethe history available at multiple granularities.
to that end we design codebase manipulation.
to aid in understanding codebase manipulation s high level granularity transformations we first explain how codebase manipulation represents the development history and how codebase manipulation s primitives operate on that history.
this section defines the representation and primitives and section iii specifies the high level granularity transformation algorithms.
for brevity the definitions ignore file creation and deletion they can be extended to handle these actions.
definition snapshot .a snapshot sis a single developer s view of a program at a point in time including the current contents of unsaved editor buffers.
unsaved editor buffers have priority if a file on disk differs from the editor buffer for that file the snapshot contains the contents of the editor buffer.
an edit can either be atomic or compound.
an atomic edit encodes replacement of one chunk of text in a file by another chunk either the original or the final chunk of text may be empty.
a compound edit is a sequence of edits each of which is either atomic or compound.
a development history is an edit that can be applied to the empty snapshot .
two development histories are views of each other if when applied to they produce the same snapshot.
definition edit .an edit may be atomic orcompound .
atomic edit .letsbe the set of all snapshots.
an atomic edit is a tuple r filepath offset length text .
we treat ras a function r s!s.r s is the same as sexcept that in r s thelength characters in sin the file filepath starting at position offset are replaced by text.
compound edit .let sbe the set of all snapshots.
for alln a compound edit is a sequence of edits e he1 e2 eni.
we treat eas a function e s!ssuch that e s en en e2 e1 s .
for example the atomic edit e1 foo.txt public adds the word public at the beginning of foo.txt .
after that the atomic edit e2 foo.txt rivate replaces ublic with rivate constructing the word private and after that the atomic edit e3 foo.txt deletes the word private .
example compound edits are he1 e2 e3iandhe1 he2 e3ii.
definition applicability .letsbe the set of all snapshots.
an atomic edit r filepath offset length text is applicable to a snapshot s2sif the file filepath has at least offset length characters.
a compound edit e he1 e2 eniis applicable to a snapshot s2sife1 e2 encan be applied in sequence tos.
more formally eis applicable to siffe1is applicable tos e2is applicable to e1 s .
.
.
and enis applicable to en en e2 e1 s .
if an edit eis not applicable to a snapshot s e s is undefined.
definition development history .a development history is a compound edit that is applicable to the empty snapshot .
definition development history view .leth h0be two development histories.
we call h0a view of h and ha view ofh0 iff h h0 .
1other definitions for the atomic edit are possible.
for example instead of using character offsets to indicate where to change the text an atomic edit could specify the surrounding text.there are three history manipulation primitives collapse expand and move .
collapse replaces a sequence of edits by a compound edit that consists of that sequence.
expand is the reverse of collapse it replaces a non top level compound edit by the sequence of its component parts.
move moves the location of an edit within the history.
these three primitives are sufficient to express all of codebase manipulation s high level granularity transformations.
definition collapse .for all compound edits e e0 ei ei ej ej collapse e i j returns e0 ei hei eji ej .
for example collapse e0 e1 e2 e0 e1 e2 andcollapse e0 e1 e2 e3 e4 e5 fh0 1i h3 5ig e0 e1 e2 e3 e4 e5 .
definition expand .for all compound edits e e0 ei ei ei where eiis a compound edit ei1 ei2 ei3 eilast expand e i returns e0 ei ei1 ei2 ei3 eilast ei .
definition move .for all development histories h he0 e1 ei ei ej i move h i j returns he0 e1 ei e0 i e0 j e0 i ej iif the resulting sequence of edits is applicable to an empty snapshot otherwise it returns hunmodified.
the edits between the reordered edits ei e0 j might need to be modified to ensure that the resulting history reaches the same snapshot.
the operational transform defines how two adjacent edits should modified to have their positions swapped.
definition granularity transformation .lethbe the set of all development histories.
a granularity transformation is a function g h!hthat applies a series of collapse expand and move transformations.
in other words gis a sequence of history manipulation primitives.
granularity transformations may be parameterized.
that is their domain may be h p where p is a set of parameters such as starting and ending edits in the history to which the transformation should apply.
for simplicity of exposition this paper gives algorithms for development histories with a single linear branch of development.
our work generalizes to multiple developers working concurrently and to using branches.
iii.
d evelopment history granularity transformations this section describes powerful granularity transformations that can be composed of the three primitive transformations collapse expand and move.
using the algorithms described in this section a developer who wishes to find the cause of a regression failure can convert an automatically recorded history into one consisting of every compilable edit then use history bisection on that ideal granularity history.
to manually inspect how a code element has evolved e.g.
which developer added a class and which other developers helped repair bugs related to the class the developer can convert the history into one that groups together changes based on the files they affect.
finally to better understand a set of changes made over time to a part of a class the developer can group all collocated edits together.
we first define two fundamental granularity transformations collapse bygroup and reorder bygroup and thenshow how these two transformations can be serve as a basis for other transformations.
both collapse bygroup and reorder bygroup are composed entirely of the primitives defined in section ii.
these transformations allow regrouping and reordering edits.
to direct these transformations the the group name interface specifies relationships between edits.
an implementation of this interface map each edit in a history to a name string edits that are related map to the same name.
for example an implementation of group name can return a single name for all edits related to a feature all edits to the same file or all edits by the same developer.
if an edit is compound and composed of edits with different names group name throws the multiplegroups exception which could prompt the algorithm using group name to for example consider these edits individually fail or use an alternate method to classify the compound edit.
some group name implementations may be project specific e.g.
the same feature example while others are general e.g.
the same file or same developer examples .
group name input history hand edit einh output the name of the group to which the edit belongs throws a multiplegroups exception if eis compound and the edits making up ebelong to more than one group.
in all algorithms that follow that use group name an implicit preprocessing step is to recursively expand edits for which g roup name throws the multiplegroups exception.
the collapse bygroup algorithm collapse s consecutive edits with the same name without reordering the history.
an implementation of the group name interface specifies which consecutive edits should be c ollapse d. collapse bygroup input history h two edit indices start and endinh and an implementation of g roup name output a view of hconsisting ofhe0 estart ea eb eg ew eend i where ea hestart estart eai eb hea ebi eg heb eci .
.
.
ew hez eendi for all e2fea eb eg ewg for all e e02 e group name e group name e0 and group name ea group name ea group name eb group name eb .
.
.
group name ez group name ez .
thereorder bygroup algorithm enables history reordering.
an implementation of the group name interface specifies which edits should be m oved to be together.
reorder bygroup input history h two edit indices start and endinh and an implementation of g roup name output a view of hproduced only by moveing edits in h such that for all start i j end group name ei group name ej for all i k j group name ek g roup name ei .
reorder bygroup andcollapse bygroup are powerful and enable expressing interesting history transformations including producing the following histories compilable code.
a compilable code history consists only of edits that produce compiling snapshots.
this history view is useful for analyses such as history bisection of test failures that only apply to compilable code and benefit from havingaccess to every compilable snapshot that occurred during development.
group compilable collapse s consecutive edits of a history into a compilable code history.
by default group compilable has a preprocessing step of recursively expand ing all edits but this step is optional.
without preprocessing group compilable can preserve a custom history granularity and select only the edits in the history s current granularity that produce compiling snapshots.
group compilable input history h two edit indices start and end inh and a procedure compile whose input is a snapshot and output is true if that snapshot compiles and false otherwise output a view of hproduced only by collapse ing consecutive edits in h such that the view consists of he0 estart ea eb eg ew eend i where snapshotshe0 estart eai he0 estart ea ebi .
.
.
he0 estart ea eb eg ewi all c ompile and for all e2fea eb eg ewg there does not exist an edit e2 e such that the snapshot he0 ei compile s. file level.
a file level change history reorders all of each file s edits to be adjacent in the history and keeps the edits to different files separate.
this history view is useful for manual inspection and analyses that are limited to individual files.
many version control systems already provide diff commands that allow developers to view all the changes made to a single file and other commands to view the history of a single file e.g.
git log filename .group files rewrites a history into a file level change history.
group files input history h and two edit indices start andendinh output a view of h transformed by reorder bygroup where the implementation of group name returns the file s in which the edit was made.
collocated edit.
a sequence of consecutive edits in a history is collocated if each edit in the sequence touches at least one character that is either touched by or is adjacent to a character touched by a previous edit in the sequence see definition .
such a sequence represents a series of edits in the same place in the codebase.
for example if a developer types a line of text at the start in a file edits parts of that line types another line right after the first makes more edits to the first line and then moves on either to a distant part of the file or to another file the creation of and edits to the first two lines would all be considered collocated.
if the developer later returned to edit the first two lines after making the changes elsewhere these new edits would not be collocated with the original ones.
group collocated rewrites a history into a collocated edit change history which collapse s together maximal sequences of collocated edits definition .
the preprocessing step of recursively expand ing all edits is optional.
this history view is useful when a developer wants to manually examine a set of changes related to a particular piece of code or partially rollback some changes to a piece of code.
definition first maximal sequence of collocated edits .
for all sequences of edits e0 e1 e2 ez the first maximal sequence of collocated edits ise0 ek such that kis the largest value such that either k 0or for all i k there exists j isuch that eitouches at least one character touched by ej.definition grouping of maximal collocated edits .
for all sequences of edits e0 e1 e2 ez the grouping of maximal collocated edits isea eb eg ew he0 eai hea ebi hey ezi such that he0 eaiis the first maximal sequence of collocated edits of e0 e1 e2 ez hea ebiis the first maximal sequence of collocated edits of ea ea ez .
.
.
and hey eziis the first sequence of collocated edits of ey ey ez.
group collocated input history h and two edit indices start andendinh output a view of hconsisting of he0 estart ea eb eg ew eend i where ea eb eg ew is the grouping of maximal collocated edits of estart estart eend.
iv.
c odebase manipulation architecture this section describes an architecture for a codebase manipulation implementation for the eclipse ide.
codebase manipulation automatically records a fine grained development history and enables the developer to modify the granularity of that history and access the resulting history as a typical version control repository.
codebase manipulation removes the burden of manual development history creation improves existing historical analyses and simplifies the implementation of new historical analyses.
our codebase manipulation design aims to satisfy the following requirements although evaluating that our design meets the requirements is outside of the scope of this paper complete history codebase manipulation records every developer action including ones that the developer undoes and the resultant code changes.
easy to use history codebase manipulation s history views are easy to use by the developer and by automated analysis tools.
unobtrusive recording codebase manipulation does not interfere with existing development tools.
it neither slows down the developer s ide nor affects manually managed version control histories.
codebase manipulation automatically records the finegrained history into a git repository.
each developer action even ones that do not alter the source code results in a commit with the log message storing information on the action itself.
do do this codebase manipulation is built on top of solstice an eclipse plug in that enables codebase replication and facilitates ide interactions figure .
solstice maintains a copy of the developer s code in parallel to the developer s work detects all code changes and provides codebase manipulation with observer patterns for the changes.
codebase manipulation satisfies the complete history requirement by detecting every developer action within eclipse via the eclipse s api and recording all such actions and every textual change to the source code.
codebase manipulation satisfies the easy to use requirement by providing a history manipulation framework to automatically transform the recorded development history into coarser granularities.
the converted histories are themselves git repositories which can be inspected manually and interface with automated tools.
future work will evaluate how well codebase manipulation satisfies this requirement.
create fine grained history developer s ide developer actions ide develo per editssolstice fine grained his torys1 s2 s3 ... sn s4history manipulation framework ...file level changes ...compilable code ... codebase manipulationfig.
codebase manipulation architecture.
codebase manipulation blue extends solstice black to automatically maintain the finegrained development history which the manipulation framework transforms into views of other granularities.
finally codebase manipulation satisfies the unobtrusiverecording requirement by storing its fine grained git repository in a unique folder on the filesystem.
the developer may continue to use any version control system including git to create a manual history in parallel and tools can access both the codebase and the manual history.
we believe git to be fast enough for codebase manipulation s overhead to be negligible.
future work will evaluate how well codebase manipulation satisfies this requirement.
codebase manipulation architecture limitations.
codebase manipulation is susceptible to solstice s design limitations.
solstice detects source code changes through the ide api if the source code is changed outside the ide codebase manipulation will not record these changes immediately.
developers rarely edit outside of their preferred ide but to mitigate this limitation each time the ide is opened codebase manipulation checks for any changes to the source code that may have taken place and creates an edit containing these external changes.
codebase manipulation could avoid this limitation by using os level file system listeners to detect changes to the source code.
however this approach would prevent codebase manipulation from detecting changes that are not written to the file system such as unsaved changes in editor buffers.
future work will investigate how these external edits affect information retrieval.
additionally solstice detects some developer actions initiated via tools as typing actions and therefore codebase manipulation records them as such.
for example codebase manipulation records eclipse refactorings as a series of text replace operations to the source code.
thus codebase manipulation is complete in its recording but inherits solstice s limitations in recognizing how some actions are initiated.
improvements to solstice would be immediately reflected in codebase manipulation.
v. r elated work the typical way to create development histories is by using version control systems vcss such as subversion mercurial and git .
unlike codebase manipulation these systems are manual and the history they provide has a fixed typically coarse granularity.
developers may change the filesystem state to earlier snapshots in the history and may compare the differences between two snapshots but cannot easily alter the history to suit particular development tasks.vcss require the developer to manually create each snapshot.
developers frequently forget to create snapshots or simply do not know the best time to to so.
as a result the development history is often coarse grained or incomplete.
for example a single edit may include changes relevant to multiple development tasks and changes developers make but overwrite before creating a snapshot are lost.
this makes vcs histories suboptimal for many analyses or manual inspection.
codebase manipulation addresses these limitations by automatically recording the history of alledits and providing the framework for rewriting this history into custom granularities better suited for development tasks.
some vcss allow limited history rewriting .
for example git rebase can collapse expand move and remove edits .
however these tools are complex prevent collaboration because rewriting a shared history prevents subsequent sharing and are irreversible and lead to further history information loss.
by contrast codebase manipulation history transformations are high level which hides all internal complexity reversible and keep intact the recorded history s integrity to enable collaboration.
fine grained version control can simplify merging and improve collaboration .
development histories can also be created automatically by recording developer actions.
fluorite stores fine grained edits to visualize replay and query the development history and implements finegrained selective undo .
built on fluorite azurite studies developers backtracking patterns and also enables selective undo .
azurite also introduces change summarization with collapse levels changes can be displayed at the raw fine grained level parsable by the compiler level method level and type level.
users reported wanting to see changes at higher levels than the fine granularity e.g.
at the level of the method so these collapse levels similar to views presented in this paper are likely to be useful in practice.
changing between these levels is similar to change summarization and tools that summarize changes or select which changes belong to the same summary e.g.
semantic version history slicing are complementary to codebase manipulation which enacts collapsing expanding or moving changes.
additionally choice calculus can be used to map features to implementation elements which again can select which changes codebase manipulation should collapse.
codingspectator and codingtracker record and use the fine grained development history to study refactoring practices development practices and fine grained change patterns .
storyteller vcs uses the fine grained history to transfer knowledge from an experienced developer to an inexperienced one .
ide maintains a fine grained development history to improve development by analyzing fine grained code changes.
each of these tools focuses on particular development tasks or research goals.
as a result these automatically recorded fine grained histories are inflexible and only suitable for the tasks that require their particular granularity.
by contrast codebase manipulation is applicable to many tasks because it records a flexible history whose granularity can be transformed to match each particular task.
to aid understanding how a history should be rewritten heuristics can detect related changes to help identify which changes in a large edit may need to be untangled.
these heuristics include historical code change patterns andchange couplings data dependencies and code metrics .
these approaches focus on detangling large edits which is a problem of manually recorded histories.
meanwhile change distilling can difference changes made in parallel on projects sharing code which can suggest edit patterns.
codebase manipulation provides access to overwritten changes potentially improving the effectiveness of these tools.
visualization is also an important part of history understanding and many repository hosting services e.g.
github and bitbucket include visualization tools.
azurite visualizes edits on a timeline at different collapse levels and research has argued that visualizations of changes relevant to bug fixes are useful for understanding the state of development .
development histories simplify some software engineering tasks.
for example git s annotate and blame commands can help understand the context of an earlier change and test bisection and delta debugging can help find the cause of a regression failure.
however the history s granularity affects the effectiveness of these tools.
codebase manipulation is complementary to these tools and can improve their effectiveness by transforming the granularity into one most suitable for the task.
further because codebase manipulation automatically records every developer edit it can create richer history views of more granularities than is possible with manually created histories further improving tool effectiveness.
mining software repositories research uses development histories to understand development practices to localize bugs and to help collaborative teams work together .
however performing analyses on manually recorded histories may lead to incorrect conclusions .
a history created by recording the edits at each save operation can be used to visualize the development and create development summaries and to study the evolution of students projects .
these repositories are finer grained and more complete than manually created ones and research on such repositories has for example identified a correlation between static analysis warnings and test failures .
the histories created by codebase manipulation are finer grained richer in terms of containing information about developer actions and more complete as they include edits a developer may overwrite before saving a file.
this potentially creates better data sets for mining software repositories research.
vi.
c ontributions development histories are necessary for software engineering tasks but their inflexible granularity hinders their utility.
we have presented codebase manipulation to automatically record a fine grained history of all developer actions and to provide high level history transformations to rewrite the history s granularity to make it more suitable for specific tasks.
we have identified collapse expand and move as three primitive transformations that can be combined to construct powerful high level history transformations and shown how two such transformations collapse bygroup and reorder bygroup can be used to create histories of many useful granularities.
finally we have designed a codebase manipulation architecture that enable it to record a complete history of development produce easy to use history views at multiple granularities and function unobtrusively without affective the developer s workflow.
overall codebase manipulation shows promise for automating version control and improving the utility of development histories.