arxiv .09099v1 feb 2019mitigatingpower sidechannels duringcompilation jingbowang university ofsouthern california losangeles california usachunghasung university of southern california losangeles california usachaowang university of southern california losangeles california usa abstract the code generation modules inside modern compilers such as gcc and llvm which use a limited number of cpu registers to store a large number of program variables may introduces idechannelleakseveninsoftwareequippedwithstate of the artcountermeasures.
we propose a program analysis and transformat ion based method to eliminate this side channel.
our method has a type basedtechniquefordetectingleaks whichleverages datalogbased declarative analysis and domain specific optimizati ons to achieve high efficiency and accuracy.italsohas a mitigation technique for the compiler s backend more specifically the regi ster allocation modules to ensure that potentially leaky inter mediate computationresultsarealwaysstoredindifferentcpuregis tersor spilled to memory with isolation.
we have implemented and ev aluatedourmethodinllvmforthex86instructionsetarchitec ture.
ourexperimentsoncryptographicsoftwareshowthatthemet hod is effective inremoving the sidechannel while being efficient i.e.
ourmitigatedcodeismorecompactandrunsfasterthancodem itigated using state of the art techniques.
acmreference format jingbowang chunghasung andchaowang.
.mitigatingpowerside channels during compilation.
in proceedings of acm conference conference .acm newyork ny usa 13pages.
introduction cryptographyisanintegralpartofmanysecurityprotocols which in turn are used by numerous applications.
however despite the strongtheoreticalguarantee cryptosystemsinpracticea revulnerable to side channel attacks when non functional properti es such as timing power and electromagnetic radiation are exploit ed to gain information aboutsensitive data .
for example if the power consumption of a device run ninganencryptionalgorithmdependsonthesecretkey stat istical techniques such as differential power analysis dpa can be u sed toperformattacks reliably .
although there are techniques for mitigating power side cha nnels they focusexclusively onthe boolean level e.g.
by targeting circuits in cryptographic hardware or s oftwarecodethathasbeenconvertedtobit levelrepresentati ons .
thislimitstheuseofsuchtechniquesinrealcompilers asa result none of them was able to fit into modern compilers such as gcc andllvmtodirectlyhandlethe word level intermediaterepresentation ir .inaddition codetransformationsincompiler smayadd new side channels even if the input program is equipped with state of the art countermeasures.
specifically compilerstendtousealimitednumberofthecp u s registers to store a potentially large number of intermedi ate computation results of a program.
and when two masked and hence de sensitizedvaluesareputintothesameregister itispo ssiblefor themaskingcountermeasure to be removed accidentally.
we will conference july washington dc usa .user specified input annotation variable to register map llvm bitcode programpinfo.datalog type checking domain specific optimization detectionllvm backend modification register allocation mitigationleakage free assembly figure1 overviewof oursecurecompilation method show as part of this work that even provably secure techni ques suchashigh ordermasking isvulnerabletosuchlea ks.indeed wehavefoundleaksinthecompiledcodeproducedbyllv m for both x86 and mips arm platforms regardless of whether t he inputprogram is equippedwithhigh order masking.
tosolvetheproblem weproposeasecurecompilationmethod with two main contributions.first we introducea type inf erence systemtosoundlyandquicklydetectpowerside channellea ks.by soundly we mean that the system is conservative and guarant ees not to miss real leaks.
by quickly we mean that it relies only on syntactic information of the program and thus can be orders ofmagnitudefasterthanformalverification .second weproposeamitigationtechniqueforthecompiler sbackendmodu lesto ensurethat foreachpairofintermediatevariablesthatma ycause side channel leaks the two values are always stored in diffe rent registers ormemorylocations.
figure shows an overview of our method which takes a programpas input and returns the mitigated code as output.
it has twomajorsteps.first soundtypeinference isusedtodetec tleaks by assigning each variable a distribution type.
user only provides an initial annotation of input variables i.e.
public e.g.
plaintext secret e.g.
key or random e.g.
mask while the types of other variables are inferred automatically.
based on the inferre d types wecheck foreach pair v.alt1 v.alt2 ofvariables toseewhether thevaluesmaybestoredinthesameregisterandcauseleaks.ifthep airis foundtobeleaky weconstrainthecompiler sbackend regis terallocationmodulestoensurethat v.alt1and v.alt2areassignedtodifferent registers orspilledtomemory.
ourmethoddiffers fromexisting approachesinseveral aspec ts.
first it specifically targets power side channel leaks cau sed by reuseofcpuregistersincompilers whichhavebeenlargely overlookedby prior work.
second it leverages datalog togethe r with a number of domain specific optimizations to achieve high e fficiency and accuracy during leak detection where type infer ence rulesaredesignedspecificallytocaptureregisterreusere latedleaks.
third mitigation in the backend is systematic and leverage s the existing production quality modules in llvm to ensure that the compiledcodeis securebyconstruction.
unlike existing techniques that require a prioritranslation of theinputprogramtoabooleanrepresentation ourmethodwo rks directly on the word level ir and thus fits naturally into mod ernconference july2017 washington dc usa jingbo wang chungha sung andchaowang compilers.foreachprogramvariable theamountofleakisq uantifiedusingthewell known hammingweight hw and hamming distance hd leakagemodels .correlationbetween these modelsandleaksonrealdeviceshasbeenconfirmedinpriorwo rks seesection2 .weshallalsoshow via experiments thatle akstargeted by our method exist even in program equipped with highorder masking .
todetectleaksquickly werelyontypeinference whichmod els theinputprogramusingasetofdatalogfactsandcodifiesthe type inferencealgorithminasetofdatalogrules.then anoff th e shelf datalogsolverisusedtodeducenewfacts.here adomain sp ecific optimization for example is to leverage the compiler s ba ckend modules to extract a map from variables to registers and util ize the map to reduce the computational overhead e.g.
by check ing pairs of some instead of all variables forleaks.
our mitigation in the compiler s backend is systematic it e nsuresthatallleaksdetectedbytypeinference areeliminat ed.this is accomplished by constraining register allocation modul es and then propagating the effect to subsequent modules without h avingtoimplementanynew backendmodulefromscratch.ourmit igation is also efficient in that we add a number of optimizatio ns toensure thatthemitigated codeis compactand has lowrunti me overhead.whileourimplementationfocusesonx86 thetech nique itself isgeneral enough thatitmaybeappliedtootherinstr uction set architectures isas such as armand mips as well.
we have evaluated our method on a set of cryptographic softwarebenchmarks includingimplementationsofwell known cipherssuchasaesandmac keccak.thesebenchmarkprogram s are all protected by masking countermeasures but still we detectedregisterreuserelatedleaksinthellvmcompiledcod e.the code produced by our mitigation also based on llvm is alway s leakfree.intermsofperformance ourmethodsignificantly outperformedcompetingapproachessuchashigh order maskingint hat our mitigated code not only is more compact and secure but al so runs significantly faster than code mitigated by high order masking techniques .
to summarize wemake thefollowingcontributions we show that register reuse introduces side channel leaks even insoftwarealready protectedbymasking.
weproposeadatalogbasedtypeinferencesystemtosoundly and quicklydetect theseside channel leaks.
weproposea mitigationtechniqueforthecompiler s backend modulestosystematicallyremove theleaks.
we implement themethod in llvm and show its effectiveness ona set of cryptographicsoftware.
the remainder of thepaperis organized as follows.first we illustrate the problem and the technical challenges associat ed with solvingit insection2.then wereview thebackgroundinclu ding thethreatmodelandleakagemodelinsection3.next wepres ent our method for leak detection in section and leak mitigatio n in section followed by domain specific optimizations in sec tion .
we present our experimental results in section review the relatedwork insection8 and give ourconclusions insection9 .
motivation we use examples to illustrate why register reuse may lead to sidechannel leaks and thechallenges forremoving them.
quotesingle.vartxt quotesingle.var public quotesingle.varkey quotesingle.var secret and quotesingle.vart quotesingle.var is hw sensitive uint32 xor uint32 txt uint32 key uint32 t txt key returnt random variable quotesingle.varmask1 quotesingle.var splits quotesingle.varkey quotesingle.var to secure shares ma sk1 mk uint64 secxor uint32 txt uint32 key uint32 mask1 uint32 mk mask1 key mask1 key uint32 t txt mk txt mask1 key return mask1 t quotesingle.varmask1 quotesingle.var splits quotesingle.varkey quotesingle.var to shares mask1 mk a priori quotesingle.varmask2 quotesingle.var splits the result to shares mask2 t3 before ret urn uint64 secxor2 uint32 txt uint32 mk unit32 mask1 unit32 mask2 uint32 t1 txt mk txt mask1 key uint32 t2 t1 mask2 txt mask1 key mask2 unit32 t3 t2 mask1 txt mask1 key mask2 mask1 return mask2 t3 name approach hw sensitive hd sensitive xor no masking secxor first order masking secxor2 specializedhardware masking figure implementations of an xor computation in the presenceof hwand hdpower side channelleaks.
.
the hw andhd leaks considertheprogram xor infigure2 whichtakesthepublic txt andthesecret keyasinputandreturnstheexclusive orofthemas output.since logical and bits in a cmos circuit correspon d to different leakage currents they affect the power consumptio n of thedevice suchleakswereconfirmedbypriorworks andsummarizedinthehammingweight hw model.inprogram xor variable thasapowerside channel leak becauseitsregister valuedepends onthesecret key.
theleak may bemitigated by masking as shown in programsecxor .theidea is tosplit a secret to nrandomizedshares beforeusingthem unlesstheattackerhasall nshares itistheoretically impossible to deduce the secret.
in first order masking the secretkeymay be split to mask1 mk wheremask1is a random variable mk mask1 keyis the bit wise exclusive or of mask1 andkey and thus mask1 mk key.
we say that mkismaskedand thusleakfreebecauseitisstatisticallyindependent ofthevalueof thekey ifmask1hasauniformrandomdistributionthensois mk.
therefore when mkis aggregated over time as in side channel attacks theresultreveals no informationof key.
unfortunately therecanbeleaksin secxor whenthevariables sharearegisterandthuscreatesecond ordercorrelation.
forexample thex86assemblycodeof mk mask1 keyismov mask1 edx xor key edx meaning the values stored in edxaremask1and mask1 key respectively.
since bit flips in the register also affect the leakage current they lead to side channel leaks.
this i s capturedbythehammingdistance hd powermodel hd mask1 mask1 key hw mask1 mask1 key hw key whichreveals key.consider for example where keyis 0001bandmask1is 1111bin binary.if aregister stores mask1 1111b firstandupdatesitsvalue asmask1 key 1110b the transition of the register bit flip is 0001b which is same as the keyvalue.
in embedded systems specialized hardware such a s physicallyunclonablefunction puf andtruerandomnumbe rgenerator trng may produce keyandmask1and map them to the memory address space thus these variables are considered leak free.
specialized hardware may also directly produce the ma sked shares mask1 mk withoutproducingtheunmasked keyinthefirst place.
this more secure approach is shown in program secxor2 mitigating power sidechannelsduring compilation confere nce july2017 washington dc usa where masked shares are used to compute the result txt key which is alsomasked butby mask2instead of mask1.
insidesecxor2 carehas beengiven torandomizetheintermediate results by mask2first before de randomize them by mask1.
thus the cpu s registers never hold any unmasked result.
ho wever therecanstillbehdleaks forexample whenthesamer egisterholdsthefollowingpairsatconsecutivetimesteps mask1 mk mask1 t1 and mask2 t3 .
.
identifyingthehd leaks toidentifytheseleaks weneedtodevelopascalablemethod .while therearetechniquesfordetectingflawsinvariousmasking i mplementations none of them were scalable enough for use in real compilers and no ne of them targetedthehdleaks causedbyregister reuse.
ourwo rk bridges thegap.
first wecheckiftherearesensitive unmaskedvaluesstor edin a cpu s register.
here maskmeans that a value is made statistically independent of the secret using randomization.
we say that avalueis hw sensitive if statistically itstilldependsonthesecret.
forexample infigure2 keyishw sensitivewhereas mk mask1 key has been masked.
if there were nk mask1 key it wouldbe called hw sensitive becausethemasking is not perfect.
second we check if there is any pair of values v.alt1 v.alt2 that when stored in the same register may cause an hd leak.
that is hd v.alt1 v.alt2 hw v.alt1 v.alt2 may statisticallydepend onthesecret.
for example infigure mkandmask1form ahd sensitive pair.
formal verification.
in general deciding whether a variable is hw sensitive or a pair of variables is hd sensitive is np hard since it corresponds to model counting .
this is illustrated bytable1 whichshowsthetruthtableofbooleanfunctions t1 t2 andt3in terms of secret variable kand random variables m1 m2 andm3.first there is no hw leak because regardless of whether k 0or1 thereisa50 chanceof t1andt2being1anda25 chance oft3being1.thiscanbeconfirmedbycountingthenumberof1 s in thetopand bottomhalves of thetable.
when two values t1 t2 are stored in the same register however the bit flip may depend on the secret.
as shown in the col umnhd t1 t2 of the table when k the bit is never flipped whereas when k the bit is always flipped.
the existence of hd leak for t1 t2 can be decided by model counting over the function ft1 t2 k m1 m2 m3 the number of solutions is for k 0but8 8for k .incontrast thereis no hdleak for t2 t3 becausethenumberofsatisfyingassignments solutions i salways regardless ofwhether k ork .
type inference.
since model counting is expensive e.g.
taking hours or longer even for small programs it is not suitable fo r a compiler.thus wedevelopafast sound andstatictypeinf erence system to identify the hd sensitive pairs in a program.
by fa st we mean that our method relies on syntactic information of th e program or theplatform e.g.
mapping from variables to phy sical registers .
by sound we mean that our method is conservativ e it may introduce false alarms and thus may mitigate unnecessa rily butit never misses real leaks.
specifically weassigneachvariableoneofthreetypes rud sid orukd details in section .
briefly rudmeans random uniform distribution sidmeans secret independent distribution and ukdtable1 truthtableshowing that thereisnohwleakin t1 t2 t3but thereisanhdleakwhen t1 t2sharearegister.
km1m2m3 t1 t2 t3 hd t1 t2 hd t2 t3 m1 m2t1 kt2 m3 t1 t2 t2 t3 ukdrudrudrud rud rud sid ukd sid our datalogbased typeinference rules can infer it as sidinstead of ukd meansunknowndistribution.therefore avariablemayhave aleak onlyif itis the ukdtype.
intable1 forexample given t1 m1 m2 wherem1andm2 arerandom rud itiseasytoseethat t1isalsorandom rud .for t3 t2 m3 wheret2 m3arerud however t3 may not always berandom butwecanstillprovethat t3issid thatis t3isstatistically independent of k. this type of syntactical inference is fast becauseit doesnot rely onany semantic information although in general itisnotasaccurateasthemodelcountingbasedapp roach.
nevertheless suchinaccuracydoesnotaffectthesoundness ofour mitigation.
furthermore we rely on a datalog based declarative analysi s framework toimplementand refinethetype inferencerules whichcaninfer hd t2 t3 assidinsteadof ukd.we alsoleveragedomain specificoptimizations suchaspreco mputing certaindatalogfactsandusingcompiler sbackendinforma tion to reducecostand improve accuracy.
.
mitigatingthehd leaks toremovetheleaks weconstraintheregisterallocational gorithm usingourinferredtypes.wefocusonllvmandx86 butthemet hod is applicable to mips and arm as well.
to confirm this we inspected the assembly code produced by llvm for the example t1 t2 t3 in table and found hd leaks on all three architectures.
for x86 in particular the assembly code is shown in figure a which uses eaxtostoreallintermediatevariables and thus has a leak inhd t1 t2 .
figure 3b shows our mitigated code where the hd sensitive variables t1andt2arestoredindifferent registers.here t1resides in eax and memory rbp whereas t2resides in ecx and memory rbp .thestackandavalueof eaxareshowninfi gure3c bothbeforeand after mitigation when theleak mayoc cur at lines .
since the value of kis used only once in the example i.e.
for computing t2 overwriting its value stored in the original memory location rbp does not affect subsequent execut ion.
ifkwere to beused later our methodwouldhave madea copy in memoryand directuses of ktothat memorylocation.
register allocation in real compilers is a highly optimized process.
thus care must be given to maintain correctness and pe rformance.
for example the naive approach of assigning all h dsensitivevariablestodifferentregistersdoesnotworkbec ausetheconference july2017 washington dc usa jingbo wang chungha sung andchaowang assembly for table1 movl edi rbp movl esi rbp movl edx rbp movl ecx rbp movl rbp eax xorl rbp eax movl eax rbp xorl rbp eax movl eax rbp andl rbp eax movl eax rbp popq rbp a before mitigation1 assembly for table1 movl edi rbp movl esi rbp movl edx rbp movl ecx rbp movl rbp eax xorl rbp eax movl eax rbp xorl eax rbp movl rbp ecx andl rbp ecx movl ecx rbp movl rbp eax popq rbp b aftermitigation stack ... m1 m2 m3 key m1 m2 ... rbp rbp rbp rbp rbp eax m1 m2 after executing line 8stack ... key m1 m2 ... rbp rbp eax m1 m2 key before mitigation after executing line stack ... m1 m2 key m1 m2 ... rbp rbp eax m1 m2 after mitigation after executing line hd key leak hd c diagramforstackandregister eax figure3 theassemblycodebefore andaftermitigation.
number of registers is small x86 has general purpose regi sters whilemipshas24 whilethenumberofsensitivevariablesis often large meaning many variables mustbe spilledtomemory.
theinstructionsetarchitecturealsoaddconstraints.inx for example eax is related to ah and al and thus cannot be assignedindependently.furthermore binaryoperationssuc hasxor may require that the result and one operand must share the sam e registerormemorylocation.therefore for mk mask1 key itmeans that either mkandmask1share a register which causes a leak in hd mk mask1 hw key ormkandkeyshare a register which causes a leak in hw key itself.
thus while modifying the backend multiplesubmodulesmust beconstrained together to en sure thedesired register and memory isolation see section5 .
.
leaks in high order masking here aquestioniswhetherthehdleakcanbehandledbysecon dorder masking which involves two variables .
the answer is no because even with high order masking techniques such as bar the etal.
thecompiledcodemaystillhavehdleaksintro duced by register reuse.
we confirmed this through experiments wh ere thecodecompiledbyllvmforhigh ordermaskedprogramsfro m bartheet al.
was found tocontainhdleaks.
figure illustrates this problem on a second order arithme tic masking of themultiplicationof txt public and key secret ina finitefield.here thesymbol denotesmultiplication.whilethere are a lot of details at a high level the program relies on the same idea ofsecret sharing random variables are used to split the secretkeytothreeshares beforethesesharesparticipateinthecomputation.
the result is a masked triplet res0 res1 res2 such that res0 res1 res2 key txt.
the x86 assembly code in figure has leaks because the same register edx stores both mask0 mask1andmask0 mask1 1uint8 secondordermaskingmultiply uint8 txt uint8 key intmask0 mask1 mask2 mask3 mask4 mask5 mask6 random intt1 mask0 mask1 key intt2 mask2 mask3 txt intt3 mask4 mask0 mask3 mask1 mask2 intt4 mask5 mask0 t2 t1 mask2 intt5 mask6 mask1 t2 t1 mask3 res0 mask0 mask2 mask4 mask5 res1 mask1 mask3 t3 mask6 res2 t1 t2 t4 t5 return res0 res1 res2 movzbl rbp edx mask0 is loaded to edx movzbl rbp esi mask1 is loaded to esi xorl esi edx mask0 mask1 is stored to edx edx1 movzbl rbp esi key is loaded to esi xorl esi edx mask0 mask1 key is stored to edx edx2 movb dl al movb al rbp figure4 second ordermaskingofmultiplicationinafinite field and thellvm generatedx86assemblycodeof line3.
key.
let the two values be denoted edx 1and edx we have hd edx edx2 hw key .similarleaksexistinthellvm generated assemblycodeof this program forarmand mips as well butwe omitthem forbrevity.
preliminaries we define the threat model and then review the leakage models usedforquantifying thepower sidechannel.
.
the threat model we assume the attacker has access to the software code but no t the secret data and the attacker s goal is to gain informati on of thesecretdata.theattackermaymeasurethepowerconsumpt ion of a device that executes the software at the granularity of each machineinstruction.asetofmeasurement tracesisaggrega tedto perform statistical analysis e.g.
as in dpa attacks.
in mi tigation our goal is to eliminate the statistical dependence between secret dataand the aggregated measurement data.
letpbetheprogramunderattackandthetriplet x k r bethe input sets x kandrconsist of public secret andrandom mask variables respectively.let x k1 k2 andrbevaluationsoftheseinputvariables.then t p x k1 r denotes attimestep t thepower consumptionofadevice executing punder input x k1andr.similarly t p x k2 r denotes the power consumptionof the device executing punderinput x k2andr.betweensteps tandt one instructionin pis executed.
wesayphas aleak ifthereare t x k1andk2suchthatthedistributionof t p x k1 r differsfromthatof t p x k2 r .letrandom variables in rbe uniformly distributed in the domain r and lettheprobabilityof each r rbepr r we expect t x k1 k2.
summationdisplay.
r r t p x k1 r pr r summationdisplay.
r r t p x k2 r pr r forefficiency reasons inthiswork weidentify sufficientconditionsunderwhichformula1isimplied.towardthisend wefocus ontheleaks ofindividual variables and pairs ofvariables inpinsteadofthesum t ifweremoveallindividualleaks theleak free propertyover thesum t p x k r is implied.
.
the leakage model in the hamming weight hw model the leakage associ ated with a register value which corresponds to an intermed iatemitigating power sidechannelsduring compilation confere nce july2017 washington dc usa variable in the program depends on the number of bits.
let the valuebed summationtext.1n i 0di2iwhered0istheleastsignificantbit dn 1is the mostsignificant bit and each bit di where i n is either or1.thehammingweight of dishw d summationtext.1n i 0di.
in the hamming distance hd model the leakage dependsnotonlyonthecurrentregistervalue dbutalsoareference valued .
letd summationtext.1n i 0d i2i.
we define the hamming distance betweendandd ashd d d summationtext.1n i 0di d i whichisequalto hw d d thehamming weight of the bit wise xor of dand d .anotherinterpretationistoregard hw d asaspecialcaseof hd d d where allbitsin thereference value d areset to0.
the widely used hw hd models have been confirmed on various devices .
the correlation between po wer variance andnumberof1 bitsmaybeexplainedusingthe leakage currentof a cmos transistor which is the foundation of modern computing devices.
broadly speaking a cmos transistor has two kinds of leakage currents staticanddynamic.
static leakage current exists all the time but the volume depends on whether the transistor is on or off i.e.
a logical .
dynamic leakage cur rent occurs only when a transistor is switched or flip .
wh ile staticleakagecurrentiscapturedbythehwmodel dynamicl eakage current is capturedbythehdmodel fordetails refer tom angard .
.
the datadependency we consider two dependency relations syntactical andstatistical .
syntactical dependency is defined over the program structur e a functionf k ... syntacticallydependsonthevariable k denoted dsyn f k ifkappears in the expression of f that is kis in the supportof f denoted k supp f .
statistical dependency is concerned with scenarios where r andomvariablesareinvolved.forexample when f k r k r the probability of fbeing logical always is not dependent on k. however when f k r k r whereris a random uniform distribution in the probability of fbeing logical is whenkis but when kis .
in the latter case we say that f is statisticallydependent on k denoteddsta f k .
the relative strengths of the dependency relations are as fo llows dsyn f k d sta f k i.e.
iffis syntactically independent of k it is statistically independent of k. in this work we rely ondsynto inferdstaduring type inference since the detectionof hdleaks must bebothfast and sound.
type based static leak detection weuseatypesystemthatstartsfromtheinputannotation inpublic insecretandinrandom and computes a distribution type for all variables.
the type indicates whether a variable may statis tically depend onthesecret input.
.
the typehierarchy the distributiontype of variable v.alt denoted type v.alt may be one of thefollowingkinds rud which stands for random uniform distribution means v.altis either a random input m inrandomor perfectlyrandomized by m e.g.
v.alt k m. sid whichstandsfor secretindependentdistribution means that while not rud v.altis statistically independent of the secret variablein insecret.
ukd which stands for unknown distribution indicates that we are not abletoprove that v.altisrudorsidand thushave toassumethat v.altmayhave a leak.
the three types form a hierarchy ukdis the least desired becauseitmeansthataleakmayexist.
sidisbetter althoughitmay notberud wecanstillprovethatitis statisticallyindependent of thesecret i.e.
noleak.
rudisthemostdesiredbecausethevariable notonlyis statisticallyindependent ofthesecret same as insid butalsocan beused likea random input e.g.
to mask other ukd variables.for leak mitigationpurposes it is always sound totreat anrudvariable as sid or ansidvariable as ukd althoughit may forceinstructionstobeunnecessarily mitigated.
in practice we want to infer as many sidandrudvariables as possible.
for example if k insecret m inrandomandkm k m thentype k ukdandtype km rud.
ifx inpublic andxkm x km thentype xkm sidbecause although xmay have any distribution since kmisrud xkmis statistically independent ofthesecret.
weprefer rudoversid when both are applicableto a variable x1 because if x1is xor ed with a ukdvariablex2 we can easily provethat x x1 x2isrudusinglocalinference aslongas x1is rudandx2isnotrandomizedbythesameinputvariable.however ifx1islabelednotas rudbutassid localinference rulesmaynot bepowerfulenough toprovethat xisrudorevensid as aresult wehave totreat xasukd leak which is less accurate.
.
datalogbased analysis in the remainder of this section we present type inference f or individualvariables first and thenfor hd sensitive pairs.
weusedatalogtoimplementthetypeinference.here progra m informationiscapturedbyasetofrelationscalledthe facts which include the annotation of input in inpublic sid insecret ukd andinrandom rud .theinferencealgorithmiscodifiedinasetof relations called the rules which are steps for deducing types.
for example when z x mandmisrud zis alsorudregardless of the actual expression that defines x as long as m nelementsupp x .this canbeexpressed as aninference rule.
aftergeneratingboththefactsandtherules wecombinethe m toformadatalogprogram andsolveitusinganoff the shelf datalogengine.
inside theengine therules areappliedtothef actsto generatenew facts types theiterativeprocedurecontin ues until thesetof facts reaches a fixedpoint.
sinceourtypeinferenceisperformedonthellvmir therear e only a few instruction types to consider.
for ease of present ation we assume that a variable v.altis defined by either a unary operator ora binaryoperator n aryoperatormay behandled similarly .
v.alt uop v.alt1 whereuopis a unary operator such as the boolean orbit wise negation.
v.alt bop v.alt1 v.alt2 wherebopis a binary operator such as boolean or bit wise and finite field multiplication .
for v.alt uop v.alt1 we have type v.alt type v.alt1 meaning v.altand v.alt1have the same type.
for v.alt bop v.alt1 v.alt2 the type depends on ifbopisxor iftype v.alt1 andtype v.alt2 aresidorrud and thesets of inputvariables uponwhich v.alt1and v.alt2depend.conference july2017 washington dc usa jingbo wang chungha sung andchaowang .
basic typeinference rules priortodefiningtherulesfor bop wedefinetworelatedfunctions unqanddom inadditionto supp v.alt whichisthesetofinputvariables uponwhich v.altdepends syntactically.
d e.sc f.sc i.sc n.sc i.sc t.sc i.sc o.sc n.sc .
.
unq v inrandomis a function that returns for each variable v.alt v a subset of mask variablesdefinedas follows if v.alt inrandom unq v.alt v.alt butif v.alt in inrandom unq v.alt if v.alt uop v.alt1 unq v.alt unq v.alt1 and if v.alt bop v.alt1 v.alt2 unq v.alt unq v.alt1 unq v.alt2 supp v.alt1 supp v.alt2 .
given the data flow graph of all instructions involved in com puting v.altand aninput variable m unq v.alt theremustexist a unique pathfrom mto v.altinthegraph.iftherearemorepaths ornopath mwouldnothave appeared in unq v.alt .
d e.sc f.sc i.sc n.sc i.sc t.sc i.sc o.sc n.sc .
.
dom v inrandomis a function that returns for each variable v.alt v a subset of mask variablesdefinedas follows if v.alt inrandom dom v.alt v.alt butif v.alt in inrandom thendom v.alt if v.alt uop v.alt1 dom v.alt dom v.alt1 and if v.alt bop v.alt1 v.alt2 whereoperator bop xor thendom v.alt dom v.alt1 dom v.alt2 unq v.alt elsedom v.alt .
given the data flow graph of all instructions involved in com puting v.altandaninputvariable m dom v.alt theremustexistaunique pathfrom mto v.alt alongwhichallbinaryoperatorsare xor ifthere aremoresuchpaths ornosuchpath mwouldnothaveappeared indom v.alt .
following the definitions of supp unqanddom it is straightforward toarriveat thebasic inference rules rule1dom v.alt nequal type v.alt rud rule2supp v.alt insecret type v.alt nequalrud type v.alt sid here rule1saysif v.alt m expr wheremisarandominputand expris not masked by m then v.althas random uniform distribution.
this is due tothe propertyof xor.
rule2says if v.altis syntactically independent of variables in insecret it has a secret independent distribution provided thatitis not rud.
.
inference rules to improve accuracy with the two basic rules only any variable not assigned rudor sidwillbetreatedas ukd whichistooconservative.
forexample v.alt k m xwherek insecret m inrandomandx inpublic is actually sid.this isbecause k misrandom andthe othercomponent x issecretindependent.unfortunately thetwo basicrulescannotinferthat v.altissid.thefollowingrulesareadded tosolvethis problem.
rule3a v.alt bop v.alt1 v.alt2 supp v.alt1 supp v.alt2 bop nelement xor gmul type v.alt1 rud type v.alt2 sid type v.alt sid rule3b v.alt bop v.alt1 v.alt2 supp v.alt1 supp v.alt2 bop nelement xor gmul type v.alt1 sid type v.alt2 rud type v.alt sidtheserulesmeanthat forany bop ifoneoperandis rud the other operand is sid and they share no input then v.althas a secretindependentdistribution sid .gmuldenotesmultiplication in a finite field.
here supp v.alt1 supp v.alt2 is need otherwise thecommoninputmaycauseproblem.forexample if v.alt1 m k and v.alt2 m x then v.alt v.alt1 v.alt2 m k xhas a leak becauseif k v.alt butifk v.alt m x. rule4 v.alt bop v.alt1 v.alt2 supp v.alt1 supp v.alt2 type v.alt1 sid type v.alt2 sid type v.alt sid similarly rule4may elevate a variable v.altfromukdtosid e.g.
as in v.alt k m x1 x2 wherex1andx2arebothsid.again thecondition supp v.alt1 supp v.alt2 inrule4is neededbecause otherwise theremaybecasessuchas v.alt k m x1 x2 m whichisequivalentto v.alt k m x1 x2 andthushasaleak.
figure shows the other inference rules used in our system.
since theserules areself explanatory weomittheproofs.
.
detectinghd sensitive pairs based on the variable types we compute hd sensitive pairs.
for eachpair v.alt1 v.alt2 wecheckif hd v.alt1 v.alt2 resultsinaleakwhen v.alt1 and v.alt2share aregister.
there aretwoscenarios v.alt1 expr1 v.alt2 expr2 meaning v.alt1and v.alt2are defined in twoinstructions.
v.alt1 bop v.alt2 v.alt3 where the result v.alt1and one operand v.alt2 arestoredin thesameregister.
inthetwo instruction case wecheck hw expr1 expr2 usingxorrelated inference rules.
for example if v.alt1 k mand v.alt2 m sincemappears in the supports of both expressions k m m isukd.suchleakwillbedenoted sen hdd v.alt1 v.alt2 wheredstands for double .
in thesingle instruction case we check hw bop v.alt2 v.alt3 v.alt2 basedontheoperatortype.when bop wehave v.alt2 v.alt3 v.alt2 v.alt2 v.alt3 whenbop wehave v.alt2 v.alt3 v.alt2 v.alt2 v.alt3 when bop xor we have v.alt2 v.alt3 v.alt2 v.alt3 and when bop gmul the result of v.alt2 v.alt3 v.alt2is v.alt2 v.alt3 if v.alt2 v.alt3 nequal0x01 andis v.alt2 0x01 otherwise.sincethetypeinference procedureis agnostictotheresultof v.alt2 v.alt3 thetypeof v.alt2 v.alt3 v.alt2depends on the types of v.alt3and v.alt2 that is type v.alt2 ukd type v.alt3 ukd type v.alt2 v.alt3 v.alt2 ukd.
if there is a leak it will be denotedsen hds v.alt1 v.alt2 .
thereasonwhyhdleaksaredividedto sen hddandsen hds isbecausethey havetobemitigateddifferently.
whenthelea kinvolves two instructions it may be mitigated by constrainin g the register allocation algorithm such that v.alt1and v.alt2no longer can share a register.
in contrast when the leak involves a singl e instruction it cannot be mitigated in this manner because in x for example all binary instructions requirethe result to s hare the sameregister ormemorylocationwithoneoftheoperands.th us mitigating the sen hdsrequires that we rewrite the instruction itself.
we also define a relation share v.alt1 v.alt2 meaning v.alt1and v.alt2indeedmaysharearegister anduseittofilterthehd sensitiv epairs as showninthetwo rulesbelow.
share v.alt1 v.alt2 type v.alt1 v.alt2 ukd v.alt1 expr1 v.alt2 expr2 sen hdd v.alt1 v.alt2 share v.alt1 v.alt2 type v.alt1 v.alt2 ukd v.alt1 bop v.alt2 v.alt3 sen hds v.alt1 v.alt2 mitigating power sidechannelsduring compilation confere nce july2017 washington dc usa rule5a v.alt bop v.alt1 v.alt2 dom v.alt1 supp v.alt2 type v.alt1 rud dom v.alt1 dom v.alt2 supp v.alt1 supp v.alt2 type v.alt sidrule5b v.alt bop v.alt1 v.alt2 dom v.alt2 supp v.alt1 type v.alt2 rud dom v.alt1 dom v.alt2 supp v.alt1 supp v.alt2 type v.alt sid rule6 v.alt bop v.alt1 v.alt2 bop nelement xor gmul dom v.alt1 supp v.alt2 nequal dom v.alt2 supp v.alt1 nequal type v.alt1 rud type v.alt2 rud type v.alt sid rule7a v.alt bop v.alt1 v.alt2 bop gmul type v.alt1 rud type v.alt2 sid dom v.alt1 supp v.alt2 nequal type v.alt sidrule7b v.alt bop v.alt1 v.alt2 bop gmul type v.alt1 sid type v.alt2 rud dom v.alt2 supp v.alt1 nequal type v.alt sid rule8 v.alt bop v.alt1 v.alt2 bop gmul dom v.alt1 dom v.alt2 nequal dom v.alt2 dom v.alt1 nequal type v.alt1 rud type v.alt2 rud type v.alt sid figure5 theremaining inferencerulesusedin ourtypesyst em inaddition to rule1 .
backend information section6.
isrequiredtodefinether elation fornow assume v.alt1 v.alt2 share v.alt1 v.alt2 true.
mitigation duringcode generation we mitigate leaks by usingthe twotypes of hd sensitive pair s as constraints duringregister allocation.
register allocation.
the classic approach especially for static compilation is based on graphcoloring whereas dynamic compilation may use faster algorithms such as lossy graph coloring orlinearscan .weapplymitigationonbothgraphcoloringand llvm s basicregister allocationalgorithms.for ease of comprehension weusegraphcoloringtoillustrateourcons traints.
ingraphcoloring eachvariablecorrespondstoanodeandea ch edgecorrespondstoan interference betweentwovariables i.e.
they may be in use at the same time and thus cannot occupy the same register.assigningvariablesto kregistersissimilartocoloringthe graph with kcolors.
to be efficient variables may be grouped to clusters or virtual registers before they are assigned to physical registers colors .
in this case each virtual register vreg as opposed to each variable corresponds to a node in the graph an d multiplevirtualregisters may bemappedtoonephysical reg ister.
.
handling sen hd dpairs for each sen hdd v.alt1 v.alt2 where v.alt1and v.alt2are defined in two instructions we add the following constraints.
first v.alt1and v.alt2are not to bemapped to the same virtual register.
second virtua l registersvreg1andvreg2 for v.alt1and v.alt2 are not to be mapped to the samephysicalregister.towardthisend weconstrainthebe havior of twobackend modules registercoalescer andregisterallocator .
ourconstrainton registercoalescer statesthat v.altre afii10069.ital1and v.altre afii10069.ital2 whichcorrespondto v.alt1and v.alt2 mustnevercoalesce althougheach ofthemmaystillcoalescewithothervirtualregisters.asf orregisterallocator ourconstraintisontheformulationofthegraph.for each hd sensitive pair weaddanew interference edgetoindicate that v.altre afii10069.ital1and v.altre afii10069.ital2mustbeassigned different colors.
duringgraphcoloring thesenewedgesaretreatedthesamea s allotheredges.therefore ourconstraintsareaddedtothe register allocator and its impact is propagated automatically to all subsequentmodules regardless ofthearchitecture x86 mipsor arm .
when variables cannot fit in the registers some will be spilledto memory andallreferencetothemwillbedirectedtomemory.
due to the constraints we added there may be more spilled variab les butspilling is handled transparently bytheexisting algor ithms in llvm.thisisanadvantageofourapproach itidentifiesaway toconstrain the behavior of existing modules in llvm without the needtorewriting any ofthem from scratch.
.
handling sen hdspairs foreachsen hds v.alt1 v.alt2 pair where v.alt1and v.alt2appearinthesame instruction we additionally constrain the dag combiner module to rewrite the instruction before constraining the registe r allocationmodules.toseewhy consider mk m k which compiles to movl rbp ecx rbp m random xorl rbp ecx rbp k secret here rbp and rbp arememorylocationsfor mandk respectively.
although mandmkarerud no leak when stored in ecx thetransitionfrom mtomk hw m mk k has a leak.
toremove theleak wemustrewrite theinstruction movl rbp ecx rbp m xorl ecx rbp rbp k and then mk whilemstillresides in ecx both kandmkresideinthememory rbp .
there is no leak because ecx only stores m rud and hw m m .
furthermore the solution is efficient in that no additional memory is needed.
if kwere to be used subsequently wewouldcopy ktoanothermemorylocationandre directeduses ofktothatlocation.
example.
figure6showsarealprogram where sisanarray storing sensitive data while m1 m8 are random masks.
the compiled code left has leaks whereas the mitigated code rig ht is leak free.
the reason why the original code left has leaks i s because prior to line eax stores m1 m5 whereas after line eaxstores s m1 m5 thus bit flipsin eaxisreflected inhw eax1 eax2 s which is thesensitive data.
during register allocation a virtual register vreg1would correspondtom1 m5whilevreg2wouldcorrespondto s m1 m5.duetoaconstraintfromthis sen hdspair ourmethodwould preventvreg1andvreg2fromcoalescing orsharingaphysicalregister.
after rewriting vreg2shares the same memory location as s whilevreg1remainsunchanged.thus m1 m5isstored in aland s m1 m5isspilledtomemory whichremoves theleak.
domain specific optimizations while themethod presented so far has all thefunctionality it can bemadefaster bydomain specific optimizations.conference july2017 washington dc usa jingbo wang chungha sung andchaowang 1voidremask uint8 t s uint8 t m1 uint8 t m2 uint8 t m3 u int8 t m4 uint8 t m5 uint8 t m6 uint8 t m7 uint8 t m8 inti for i i i s s m1 m5 s s m2 m6 s s m3 m7 s s m4 m8 before mitigation movslq rbp rdx movq rbp rcx movzbl rcx rdx edi movzbl rbp esi movzbl rbp eax xorl esi eax xorl edi eax movb al rcx rdx after mitigation movslq rbp rdx movq rbp rcx movzbl rbp esi movzbl rbp eax xorl esi eax xorb al rcx rdx figure6 codesnippetfrom thebytemaskedaes .
.
leveraging thebackend information to detect hd leaks that likely occur we focus on pairs of vari ables that may share a register as opposed to arbitrary pairs of variables.
for example if the live ranges of two variables o verlap theywillnever sharearegister andweshouldnotcheckthem for hd leaks.
such information is readily available in the compi ler s backend modules e.g.
in graph coloringbased register all ocation variables associatedwithany interference edgecannotsharearegister.
thus we define share v.alt1 v.alt2 meaning v.alt1and v.alt2may share a register.
after inferring the variable types as rud sid orukd we useshare v.alt1 v.alt2 to filter the variable pairs subjected to checking forsen hddandsen hdsleaks seesection4.
.wewillshow in experiments that such backend information allows us to dram aticallyshrink thenumberof hd sensitive pairs.
.
pre computing datalogfacts bydefault onlyinputannotationandbasicdata flow def u se are encoded as datalog facts whereas the rest has to be deduced b y inference rules.
however datalogis not themost efficient wa y of computingsets suchas supp v.alt unq v.alt anddom v.alt orperforming set operationssuch as m1 supp v.alt .
incontrast itislineartime tocomputesetssuchas supp v.alt unq v.alt anddom v.alt explicitly.thus wechoosetoprecomputethem inadvanceandencodetheresultsasdatalogfacts.inthisca se precomputationresults are used to jump start datalog based typ e inference.wewillshow throughexperiments thattheoptimi zation can leadtofaster typeinference thanthedefaultimplement ation.
.
efficient encoding ofdatalogrelations there are different encoding schemes for datalog.
for exampl e if in i0 ... i3 andsupp v1 i1 i2 andsupp v2 i0 i1 i3 .
one way is to encode the sets is using a relation supp v in wherevare variables and inareinputs supp v1 i1 supp v1 i2 supp v1 supp v2 i0 supp v2 i1 supp v2 i3 supp v2 while the size of suppis v in each set needs up to in predicates and set operationneeds in 2predicates.table statisticsof the benchmarkprograms.
namedescription locprogram variables inpublic insecret inrandom internal p1aes shift rows p2messerges boolean p3goubinboolean p4secmultopt wires 1 p5secmult wires 1 p6secmultlinear wires 1 p7cprr13 lut wires 1 p8cprr13 optlut wires 1 p9cprr13 1 wires 1 p10ks transitions 1 p11ks wires p12keccakf 1turn p13keccakf 2turn p14keccakf 3turn p15keccakf 7turn p16keccakf 11turn p17keccakf 15turn p18keccakf 19turn p19keccakf 24turn p20aes wires 1 anotherwayistoencodethesetsisusingarelation supp v 2in where 2inis thepower set set of allsubsetsof in supp v.alt1 b0110 supp v1 supp v.alt2 b1011 supp v2 while the size of suppis v in each set needs one predicate and set operationneeds 2predicates a bit wise operation .when in is small the second approach is more compact but as in increases thetablesizeof suppincreases exponentially.
therefore weproposeanencoding calledsegmentedbitset representation idx bitset whereidx irefers tothe i th segment and bitsetidenotes thebits inthe i th segment.
supp v1 b01 supp v1 b10 supp v1 supp v2 b10 supp v2 b11 supp v2 in practice when the bitsetsize is bounded e.g.
to the table size remains small while the number of predicates increases moderately.
this encoding scheme is actually a generalization of the previous two.
when the size of bitsetdecreases to and the number of segments increases to in it degenerates to the first approach.
when the size of bitsetincreases to in and the number ofsegments decrease to1 itdegenerates tothesecond appro ach.
experiments we have implemented our method in llvm .
.
it leverages the z datalogengine inz3 toinfertypes and thenconstrains backend modules using the inferred hd leaks.
while t he mitigation part is implemented specifically for x86 in llvm this approachcanalso beimplemented forotherplatforms.
we conducted experiments on a number of cryptographic softwarebenchmarks.table2showsthestatistics includingth ename ashortdescription thenumberoflinesofcode loc andth enumberofprogramvariables whicharedividedfurthertoinput andinternalvariables.allbenchmarksarefrompublicdomain an dallof themaremasked.theprogramsp1 p3 inparticular areprot ected by booleanmasking that previously has been verified .
theother programs from bartheetal.
are masked multip lication maskeds box maskedaes andvariousmas ked mac keccakfunctions .
our experiments were designed to answer three questions is ourdatalog based typesystem effective indetecting hdle aks?
arethedomain specificoptimizationseffectiveinreduc ingthe computational overhead?
does the mitigated code have go odmitigating power sidechannelsduring compilation confere nce july2017 washington dc usa table resultsof type basedhd leakdetection.
name detectiontimehdleaks detected details of theinferred types sen hddsen hdsrudsid ukd p1 .061s none none p2 .105s none none p3 .099s none p4 .208s none p5 .216s none p6 .276s p7 .213s p8 .147s p9 .266s p10 .550s none none p11 .447s p12 .619s none p13 .102s none p14 .998s none p15 .999s none p16 .801s none p17 .120s none p18 2m1.540s none p19 3m22.415s none p20 16m12.320s performance after compilation in terms of boththe codesiz e and theexecutionspeed?
in all the experiments we used a computer with .
ghz cpu and 8gb ram and set thetimeout t o to120minutes.
.
leak detection results table3showstheresults wherecolumns1 2showthebenchma rk nameanddetectiontimeandcolumns3 4showthenumberofhd leaks detected.
the leaks are further divided into sen hdd twoinstruction and sen hds single instruction .
columns show more details of the type inference including the number of rud sidandukdvariables respectively.
while the time taken to complete type inference is not negligible e.g.
minutes for th e larger programs itisreasonablebecauseweperformamuchdeeperp rogram analysis than mere compilation.
to put it into perspect ive theheavy weightformalverificationapproachesoftentake hours .
as for the number of leaks detected although the benchmark programsareallmasked duringnormalcompilation newhdl eaks were still introduced as a result of register reuse.
for exam ple in p20 which is a masked aes we detected sen hdsleaks after analyzing more than 60k intermediate variables.
overal l we detectedhdleaks in17outofthe20programs.furthermore of these programs have both sen hddandsen hdsleaks while theremaining 11have only sen hdsleaks.
results in columns of table indicate the inferred types of program variables.
despite the large number of variables in a program ourtypeinferencemethoddidanexcellentjobinqu ickly proving that the vast majority of them are rudorsid no leak even for the few ukdvariables after the backend information is used the number of actual hd leaks detected by our method is small.
.
effectiveness of optimizations toquantifytheimpactofouroptimizations wemeasuredthe performanceofourmethodwithandwithoutthem.table4showsth e significantdifferences inanalysistime columns2 andde tected hdleaks columns4 .overall theoptimizedversioncomp leted allbenchmarkswhereastheunoptimizedonlycompletedhalf .for p12 in particular the optimized version section was 631x faster.
in unoptimized version since the memory requireme nt increases as the in goes up p12 ran out of memory and started using virtualmemory which resultedin theslow down.table resultsof quantifyingimpactof optimizations.
namedetectiontime withoutbackend info withbackend info w ooptimization w optimization sen hddsen hdssen hddsen hds p1 .865s .061s p2 .782s .105s p3 .721s .099s p4 .102s .208s p5 .206s .216s p6 .113s .276s p7 .832s .213s p8 .306s .147s p9 .053s .266s p10 10m1.513s .550s p11 15m51.969s .447s p12 t o .619s p13 t o .102s p14 t o .998s p15 t o .999s p16 t o .801s p17 t o .120s p18 t o 2m1s p19 t o 3m22s p20 t o 16m13s table results of ourhd leakmitigation.
namecode sizeoverhead byte runtimeoverhead us virtualregister original mitigated original mitigated sensitive non sensitive p3 .
p4 .
.
p5 .
.
.
.
p6 .
.
.
p7 .
.
.
.
p8 .
.
.
p9 .
.
.
p11 .
.
.
.
p12 .
.
.
.
p13 .
.
.
.
p14 .
.
.
.
p15 .
.
.
.
p16 .
.
.
.
p17 .
.
.
.
p18 .
.
.
.
p19 .
.
.
.
p20 .
.
.
.
leveragingthebackendinformationalsodrasticallyreduc edthe number of detected leaks.
this is because otherwise we hav e to beconservativeandassumeanytwovariablesmaysharearegi ster whichcauses alotoffalseleaks inx86platform.inp12 fore xample using thebackend informationresultedin 260xfewer le aks.
.
leak mitigationresults wecomparedthesizeand executionspeedofthellvm compiled code with and without our mitigation.
the results are shown in table including the number of bytes in the assembly code an d the execution time.
columns show more details the numbe r of virtual registers marked as sensitive and non sensitive respectively.
theresultsshowthatourmitigationhaslittleperformance overhead.
first the code sizes are almost the same.
for p8 the mi tigated code is even smaller because while switching the stor age fromregistertomemoryduringourhandlingofthe sen hdspairs subsequentmemorystoresmaybeavoided.second theexecut ion speedsarealsosimilar.overall themitigatedcodeis8 slower but in some cases e.g.
p4 and p6 the mitigated code is faste r becauseofourmemoryrelated rewriting.
themainreasonwhyourmitigationhaslittleperformanceov erheadisbecause asshowninthelasttwocolumnsoftable5 co mpared to the total number of virtual registers the number of sensitive ones is extremely small.
p17 keccakf 15turn for e xample hasonly5sensitivevirtualregisters outofthe9 917intot al.thus ourmitigationonlyhastomodifyasmallpercentageofthein structions which doesnot leadtosignificant overhead.conference july2017 washington dc usa jingbo wang chungha sung andchaowang table comparison with order dmaskingtechniques .
name codesize byte runtime us hw leak hd leak sen hddsen hds p4 ours .
no no none none p4 d .
no yes none p4 d .
no yes none p4 d .
no yes none p4 d .
no yes none p5 ours .
no no none none p5 d .
no yes none p5 d .
no yes none p5 d .
no yes none p5 d .
no yes none p6 ours .
no no none none p6 d .
no yes none p6 d .
no yes none p6 d .
no yes none p6 d .
no yes none p7 ours .
no no none none p7 d .
no yes none p7 d .
no yes none p7 d .
no yes none p7 d .
no yes none p8 ours .
no no none none p8 d .
no yes none p8 d .
no yes none p8 d .
no yes none p8 d .
no yes none p9 ours .
no no none none p9 d .
no yes none p9 d .
no yes none p9 d .
no yes none p9 d .
no yes none .
comparison tohigh order masking on the surface hd leaks seem to bea typeof second order leak s which involves two values.
for people familiar with high or der masking anaturalquestioniswhetherthehdleakscanbe mitigated using high order masking techniques.
to answer the q uestion weconductedtwoexperiments.first wecheckedifhdl eaks exist in programs equippedwith high order masking.
second we compared the size and execution speed of the code protected b y either high order masking orourmitigation.
table shows the results on benchmarks p4 p9 which come from bartheet al.
and thushave versions protectedby d order masking where d 2to5.whileinitiallywealso expectedtosee no hd leaks in these versions the results surprised us.
as sh own in thelast two columns hdleaks were detected in all these hi ghordermaskingprotectedprograms.acloserlookshowsthatt hese leaks are all of the sen hdstype meaning they are duetorestrictionofthex86isa anybinaryoperationhastostoretheresu ltand oneoftheoperandsinthesameplace andbydefault thatpla ceis a general purposeregister.
measured by the compiled code size and speed our method which is already more secure than high order masking is mo re efficient.
in p9 for example our mitigated code has 3k bytes i n sizeandrunsin0.45us whereasthehigh ordermaskingprot ected code has 9k to 41k bytes for d to and runs in .15us to .40us.
.
threat to validity we rely on the hw hd models and thus our results are valid only when these models are valid.
although they have be en widelyadoptedandvalidated furtherva lidation is always needed but it is out of the scope of this work.
we assume the attacker can only measure the power consumption but notother informationsuch asdata busortiming.
if suchinf ormationbecomesavailable ourmitigationmay no longer besecu re.
sincewefocusoncryptographicsoftware whichtendstohav e simple program structure and language constructs there ha s not beenaneedtousemoresophisticatedpoints toanalysistha nwhatis providedbyllvm.our analysis is intra procedural for c ryptographicbenchmarks wecanactuallyinlineallfunctionsto forma monolithic program before conducting the analysis.
nevert heless going forward theseare someoftheissues thatwill beaddre ssed tobroadenthescopeofourtool.
related work broadlyspeaking existingmethodsfordetectingpowersid echannels fall into three categories static analysis formal ve rification and hybrid approach.
static analysis relies on compile tim e informationtocheckifmaskingschemes areimplementedcorrectl y .
they are faster than formal verification whic h often relies on sat smt solvers or model counting .
howeve r formal verification is more accurate than static analysis.
t he hybridapproach aimstocombinethetwotypesoftechnique sto obtain the best of both worlds.
however none of these method s focused on the leaks caused by register reuse inside a compil er which is ourmaincontribution.
specifically althoughourtypebasedmethodfordetectings idechannel leaks is inspired by several prior works it is significantly different from theirs.
forexample themost recent method proposedby zhang et al.
interleaves type infe rence with a model counting procedure with the goal of detecting hw leakscausedbyerrorsinmaskingimplementations however they donot detecthdleaks caused byregister reuse nor remove the se leaks.
their method does not use datalog or any of the domainspecificoptimizationswehave proposed.
barthe et al.
proposed a relational technique to check th e correctness of masked implementations.
although the techn ique covers high order masking when applied to a pair of variabl es it hastoconsiderallpossiblewaysinwhichsecond orderleak smay occur as opposed to the specific type of leak involved in regi ster reuse.
thus their mitigation would have been too expensive in terms of the code size and the execution speed.
furthermore as wehave shownin experiments it doesnot seem to beeffective i n preventing leaks causedbyregister reuse.
anotherdifferencebetweenourmethodandexistingmethodsi s ourfocusonanalyzingtheword levelrepresentationofapr ogram as opposedto a bit level representation.
while turning a pr ogram intoapurelyboolean circuit like representation isfea sible itdoesnotfitintothestandardflow ofcompilers.ass uch implementing theapproach incompilersis notstraightforw ard.
the practical security against side channel leakages via m asking can be evaluated using the isw model and subsequent extensions withtransitions.however theydonotco nsider leaks that arespecificto register useinmoderncompilers su chas gccandllvm.theydonotconsiderconstraintsimposedbythe instructionset architectureeither.furthermore they ne ed todouble the masking order to deal with leaks with transitions but stilldonoteliminate leaks introducedbycompilation.
itisknownthatthesecurityguaranteeofsoftwarecounterm easures may become invalid after compilation .
in this context barthe et al.
showed that the compilation process could maintain the constant time property for timing s idechannel leaks while our work addresses potential leaks thr ough powersidechannels.
marc also investigated potential vulnerabilities in power side channel countermeasures during co mpiler optimizations butdidnotprovideasystematicmethodform itigatingthem.mitigating power sidechannelsduring compilation confere nce july2017 washington dc usa beyondpowersidechannels therearetechniquesforanalyz ing othertypesofsidechannels usinglogicalreasoning abstractinterpretation symbolicexecution anddynamic analysis .asformitigation therearetech niques thatinsertmaskingandothercountermeasureseitherthrou ghcompilers or through program synthesis tools .
however these techniques focus exclusively on eliminatin g the leaks appearedintheinputprogram.noneofthempaidattent ion totheleaks introducedbyregister reuseduring thecompila tion.
conclusions wehavepresented amethodformitigatingatypeofside chan nel leakscausedbyregisterreuseincompilers.themethodreli esona typeinference systemtodetectleaks andleverages thetyp einformationtorestrictthecompiler sbackendtoguaranteethat register allocationissecure.wehaveimplementedthemethodinllvm for x86 and evaluated it on cryptographic software benchmarks.
our experiments demonstrate that the method is effective in miti gating leaks and the mitigated program has low performance over head.specifically itoutperformsstate of the arthigh ordermasking techniques in terms of both the code size and the executio n speed.conference july2017 washington dc usa jingbo wang chungha sung andchaowang