memfix static analysis based repair of memory deallocation errors for c junhee lee korea university republic of korea junhee lee korea.ac.krseongjoon hong korea university republic of korea seongjoon korea.ac.krhakjoo oh korea university republic of korea hakjoo oh korea.ac.kr abstract we present memfix an automated technique for fixing memory deallocation errors in c programs.
memfix aims to fix memory leak double free and use after free errors which occur when developers fail to properly deallocate memory objects.
memfix attempts to fix these errors by finding a set of free statements that correctly deallocate all allocated objects without causing double frees and use after frees.
the key insight behind memfix is that finding such a set of deallocation statements corresponds to solving an exact cover problem derived from a variant of typestate static analysis.
we formally present the technique and experimentally show that memfix is able to fix real errors found in open source programs.
because memfix is based on a sound static analysis the generated patches guarantee to fix the original error without introducing new errors.
ccs concepts software and its engineering software verification and validation software testing and debugging keywords program repair program analysis debugging acm reference format junhee lee seongjoon hong and hakjoo oh.
.
memfix static analysisbased repair of memory deallocation errors for c. in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction in programming languages like c and c memory deallocation errors occur when dynamically allocated objects are not deallocated properly.
because these languages entrust memory management to the first and second authors contributed equally to this work.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
the number of commits that mention memory leak double free use after free and buffer integer overflow.
repo.
commits ml df uaf total overflow linux php git openssl developers all unused objects must be manually identified and deallocated.
unfortunately this manual memory management likely ends up with three types of common errors a programmer may forget to deallocate an object memory leak may deallocate an object more than once double free or may deallocate an object too early even before it is used use after free .
memory leak ml double free df and use after free uaf are one of the most troubling errors in c programs.
for example they are prevalent in popular open source software projects even more common than buffer and integer overflow.
each of those errors must be carefully examined and fixed because otherwise they become significant sources of security vulnerabilities memory leak cwe may cause a denial of service attack and double free cwe and use after free cwe may allow an unprivileged user to execute arbitrary code.
for example vulnerabilities cve cve and cve2017 recently found in linux kernel are due to ml df and uaf respectively.
however manually fixing memory deallocation errors is timeconsuming and error prone even for experienced developers.
correctly fixing a memory leak for example requires a developer to examine not only the leaky path but also every single path from the source to target because inserting a deallocation statement in one path may introduce double free or use after free errors in other paths.
as a result it is common in practice for human written patches only to introduce new errors and the original error gets fixed after multiple rounds of incorrect patches e.g.
see section .
.
in this paper we present memfix an automated technique for fixing memory deallocation errors in c programs.
given a buggy program memfix aims to repair the program by finding a set of deallocation statements that correctly deallocate all allocated memory objects without causing double frees and use after frees.
we show that finding such a set of deallocation statements is essentially to solve an exact cover problem that can be derived by a static analysis.
the static analysis is a variant of type state analysis which tracks possible deallocation statements for each object.
finding an exact cover is a well known np complete problem for whichesec fse november lake buena vista fl usa junhee lee seongjoon hong and hakjoo oh we use an off the shelf sat solver.
because memfix is based on a sound static analysis the memfix generated patches are guaranteed to correctly fix the target error without introducing new errors that are absent in the original program.
the experimental results demonstrate that memfix is able to fix various errors in open source c programs.
we evaluated memfix with three different benchmark sets juliet test suite gnu coreutils and a set of model programs that contain real errors found in popular c repositories.
for juliet test suite memfix was able to fix all errors related to memory leak double free and use afterfree.
for coreutils memfix automatically repaired all deallocation errors in out of programs.
for model programs from opensource repositories memfix was able to generate patches for cases.
we show that these results represent a significant advance over the state of the art by comparing memfix with leakfix a recently developed tool for fixing memory leaks in c programs.
contributions.
this paper makes the following contributions we present memfix a unified algorithm for fixing memoryleak double free and use after free errors in c programs.
the key technical novelty is the use of static analysis to derive an exact cover problem whose solution corresponds to a correct patch for memory deallocation errors.
we provide experimental evaluation of memfix with three benchmark sets of open source c programs.
we compare its performance with the state of the art tool leakfix .
we make the tool and benchmarks publicly available.
.
in particular we provide a new benchmark set comprising test programs loc which was abstracted from real errors reported in open source c repositories.
overview in this section we motivate and illustrate memfix with examples.
.
motivating example figure illustrates how a double free error found in linux kernel gets fixed by a developer and memfix .
the original buggy code in figure a is eventually fixed in figure d through three rounds of patches taking months in total.
figure e shows the patch generated by memfix .
we simplified code for presentation.
original code.
the original code in figure a has two doublefree errors.
at lines buffers inandoutare allocated used and deallocated.
at lines and inandoutare re allocated with increased size.
double frees would occur when these buffers fail to get re allocated.
for example when malloc fails and returns null at line the program control is transferred to the error handling code at line where free is called on outthat is already deallocated at line .
similarly when malloc at line fails inis deallocated twice at lines and .
first patch.
figure b shows the initial patch made by a developer.2to prevent double frees the developer nullified the buffers at lines and .
as a result when inoroutfail to get re allocated they are assigned null so that the subsequent calls to free are safe.
is a correct fix although it is not ideal.
it is not ideal because the fix just avoids the errors without eliminating their root causes.
that is the double free patterns are still present in figure b along the path buffer inis deallocated twice.
similarly along the path free is called on outconsecutively.
to avoid double frees along those paths the developer simply nullified the buffers in between the consecutive free s instead of removing the problematic patterns.
second patch.
indeed the developer got confused in understanding the code and thought that a double free is still present in the code.3to fix this imaginary bug s he moved free out at line to line right before the re allocation of out.
this is a more desirable place for free out as it eliminates the double free pattern for out making the code simpler to understand.
however this change introduced a new memory leak error.
note that when buffer infails to get allocated at line outis nullified line so the object that outpoints to is no longer reachable.
third patch.
this memory leak was reported by another developer and the original developer patched the code once again as shown in figure d .4to fix the leak the developer moved free out at line back to its original place line .
also the developer nullified outat line to prevent the imaginary double free that s he thinks was introduced by the first patch.
the resulting code is error free.
however it became even more redundant and confusable than the first patch in figure b .
patch by memfix .figure e shows the fix made by memfix .
to fix the double free errors in the original code figure a memfix eliminated their root causes with two simple changes it removed free in from line and moved free out from line to .
the idea is to deallocate buffers right before they get reallocated which is the simplest patch for the original code.
the generated patch is instructive for a developer to better understand how the problem can be fixed.
furthermore because memfix is sound and formally ensures that the generated patch is correct it frees the developer from the error prone task of manually verifying the correctness of the patch.
.
overview of memfix we illustrate the algorithm of memfix using a simple example in figure .
the code in figure a has a double free error which occurs along the lines .
at line an object denoted o1 is allocated and stored in pointer p. at line both q andprefer to the same object o1 that is later deallocated twice at lines and causing a double free.
our technique fixes this error by moving free p at line to line as shown in figure b .
memfix works with two key ideas we use a static analysis that collects patch candidates for each allocated object and we reduce the problem of finding a correct patch into an exact cover problem over allocated objects.
we explain these steps below.
static analysis for collecting patch candidates.
we first analyze the code to collect patch candidates.
the control flow graph and analysis results at each node are presented in figure .
the repair of memory deallocation errors esec fse november lake buena vista fl usa 1in malloc 2out malloc ... use in out 4free out 5free in 7in malloc 8if in null goto err 13out malloc 14if out null free in goto err ... use in out 20err free in free out return 1in malloc 2out malloc ... 4free out 5free in 7in malloc 8if in null out null goto err 13out malloc 14if out null free in in null goto err ... 20err free in free out return 1in malloc 2out malloc ... 5free in 7in malloc 8if in null out null goto err 12free out 13out malloc 14if out null free in in null goto err ... 20err free in free out return 1in malloc 2out malloc ... 4free out 5free in 6out null 7in malloc 8if in null out null goto err 13out malloc 14if out null free in in null goto err ... 20err free in free out return 1in malloc 2out malloc ... 5free in 7in malloc 8if in null goto err 12free out 13out malloc 14if out null goto err ... 20err free in free out return a original code b first patch .
c second patch .
d third patch .
e fix by memfix double free correct memory leak correct correct figure a original buggy code.
b d a series of patches made by a developer.
e fix by our technique.
1p malloc o1 2if ... q malloc o2 6else q p ... q use q 9free q 10free p double free1p malloc 2if ... q malloc free p 6else q p ... q 9free q a buggy code b fixed code figure example for illustrating our technique.
analysis is a variant of typestate analysis which maintains points to and patch information for each allocated object as a tuple of the following form5 o must mustnot patch patchnot where ois an object represented by its allocation site must is a set of pointers that must point to o mustnot is a set of pointers that definitely do not point to o patch is a set of patches that are guaranteed to safely deallocate the object and patchnot is a set of potentially unsafe patches.
we call the tuple an object state .
for 5in this overview we simplified the object representation for brevity.
see section .
for the complete representation.example the analysis computes the following tuple after line o1 p p at the first line an object o1is allocated and pointer ppoints to that object.
a patch is a pair n e of a program location n and a pointer expression e which denotes a deallocation statement free e at line n. for example the safe patch p in the object state above indicates that we can deallocate the object o1by inserting free p after line .
right now mustnot andpatchnot are empty.
at line a new object o2 is allocated and the existing object states get updated as follows o2 q q o1 p q p p the first tuple denotes the new object allocated at line the allocation site is o2 qpoints to o2 and we can safely deallocate o2 at line via free q .
note that allocating object o2may change the state of object o1 since qdefinitely no longer point to o1 we add q to the mustnot set of o1.
also patch ofo1includes p as well as p because it is safe to deallocate o1at line or via free p .
next consider the false branch line where the analysis maintains the information for object o1as follows o1 p q p p q because of the copy statement q p both qandppoint to o1.
the object can be deallocated with either free p orfree q after the statement line .esec fse november lake buena vista fl usa junhee lee seongjoon hong and hakjoo oh p malloc o1 p p q malloc o2 q q o1 p q p p q p o1 p q p p q ... q 1 o2 q q q 2 o1 p q p p p 3 o1 p q p q p p q figure static analysis for collecting patch candidates at the join point before we analyze line the analysis results from both branches i.e.
and are combined o2 q q o1 p q p p o1 p q p p q note that our analysis is disjunctive and maintains object states separately for each different branch unless the resulting states are the same.
the second and last tuples denote the states of the object o1that follow the true and false branches respectively.
with the states in as input the analysis produces the following states as output after line 1 o2 q q q 2 o1 p q p p p 3 o1 p q p q p p q because qis used at line the existing patches for the objects that can be referenced by qare no longer safe i.e.
potential useafter free .
thus we remove the patch candidates from the states and declare them as unsafe.
for example consider the first state in i.e.
o2 q q whose object can be referenced by q. we remove q from patch topatchnot .
also we indicate that a new patch q is safe after line yielding 1in .
similarly 3 in is obtained by removing the existing patches and adding new patches p and q since qpoints to o1.
note that however the existing patches of the second tuple in remain the same because in this case qdefinitely does not point to o1and therefore the corresponding object cannot be used.
the analysis finishes with the object states in .
all deallocation statements in the original code are ignored during analysis.
finding correct patches by solving exact cover problem.
once we collect all object states as well as their patch candidates we try to find a set of patches that correctly deallocate all object states i.e.
no memory leaks while not introducing double frees and use after frees.
we find the correct patches by reducing the problem into an exact cover problem as follows.
from the analysis results in we first collect the safe and unsafe patches across all object states safe p p p q unsafe p q p q .
candidate patches are those in safe but not in unsafe cand safe unsafe p p q .
these are possible patches that do not cause use after free errors.
however using all of them may cause double frees.
we have to finda subset of the candidate patches that does not introduce doublefrees while deallocating all object states which corresponds to solving an exact cover problem represented by the following incidence matrix 1 2 3 p p q the matrix has one row for each element of cand and one column for each state in .
the entry in row cand column is if patch cis a safe patch for state i.e.
cis included in patch of and otherwise.
for example 1contains q inpatch so the entry in row q and column 1is .
then we aim to select rows such that each column is contained in exactly one selected row.
in the example p q is the solution as highlighed above that covers all states hence no memory leaks and each state is covered by at most one patch no double frees .
the exact cover problem is np complete .
we solve the problem by encoding it as boolean satisfiability and leveraging an off the shelf sat solver .memfix is able to fix the bug iff the boolean formula is satisfiable.
applying the generated patch p q to the original buggy code is easy.
we first remove all deallocation statements from the code in figure a and then insert free p after line and free q after line resulting in the code in figure b .
the memfix algorithm now we formally present memfix .
section .
defines a core language.
section .
describes the first step of memfix the patchcollecting static analysis.
the second step choosing a set of correct patches by solving an exact cover problem is described in section .
.
.
language we formalize memfix on top of a simple pointer language.
let p be a program to repair.
we represent the program by a control flow graph c ce cx where cdenotes the set of program points c cdenotes the control flow of the program c1 c2 meaning that c1is a predecessor node of c2 ceis the entry node andcxis the exit node of the program.
the entry and exit nodes are unique.
each program point is associated with a command defined by the following grammar cmd set p e alloc p free p p x x e p nullstatic analysis based repair of memory deallocation errors esec fse november lake buena vista fl usa a pointer expression p is either a variable x or its dereference x .
an expression is a pointer expression or null.
a command is an assignment set p e an allocation statement alloc p or a deallocation statement free p .alloc p creates a new object pointed to by p.free p deallocates the object that ppoints to.
let varbe the finite set of program variables in p. let allocsite c be the finite set of allocation sites i.e.
nodes whose associated commands are allocation statements in p. we write cmd c for the command associated with c. for simplicity we describe our algorithm with the simple language.
extending the algorithm to support other c features such as procedure calls and structures introduces no new foundational ideas.
.
collecting patches via static analysis the first step of memfix is to analyze the program to collect patch candidates.
the analysis is a variant of typestate analysis which aims to identify the set of possible patches for each allocated object.
we assume the basic knowledge of the abstract interpretation framework .
.
.
abstract domain.
our analysis is flow sensitive and disjunctive that is it computes a set of object states for each program point.
the abstract domain dof the analysis is defined as a function from program points to sets of reachable object states d c p s .
an object state s sdescribes an abstract object and is represented by a tuple of the form o may must mustnot patch patchnot where o allocsite is the allocation site of the object may ap is a set of access paths that may point to the object must apis a set of access paths that must point to the object mustnot ap is a set of access paths that definitely does not point to the object patch c apis a set of patches that can safely deallocate the object and patchnot c apis a set of potentially unsafe patches.
apdenotes the set of pointer access paths that can be generated for the given program.
for the language in section .
apis equivalent to the set of pointer expressions p i.e.
ap x x x var which is finite.
when pointer expressions are unbounded we approximate apto be finite by limiting the length of the access paths .
apatch is a pair c p c ap consisting of a program point cand an access path p. a patch c p represents a deallocation statement free p positioned right after the program point c. our abstract domain is similar to that of the typestate analysis by fink et al.
.
both analyses represent an abstract object with the must and must not point to sets.
key difference however is that we further distinguish object states with safe and unsafe patches as opposed to the typestate of the object used by fink et al.
.
during analysis the following invariants are maintained in any object state may includes must but excludes mustnot i.e.
may must may mustnot and patch andpatchnot are disjoint i.e.
patch patchnot .
.
.
abstract semantics.
the abstract semantics is defined as the least fixed point lfpf dof the semantics function f d d f x c.fc g c cx c where x dandfc p s p s denotes the abstract semantics of the command associated with the program point c fc s s ifcmd c set lv e s c x x c x ifcmd c alloc x s ifcmd c free lv we will define s shortly.
note that a new object state is created from an allocation statement the allocation site is the current program point c the object is definitely pointed to by x and the only safe patch available is c x .
note also that the analysis ignores deallocation statements which has the effect of removing them from the program prior to the analysis.
the set s is defined with two transfer functions cand c s s s c c s .
the transfer functions c s sand c s supdate the patch and points to sets of an object state respectively.
manipulating the patch information i.e.
c is new but handling the must and must not access paths i.e.
c is common in typestate analysis e.g.
.
we first define the transfer function cbelow.
given an object state at the program point c s o may must mustnot patch patchnot cupdates the patch information as follows c s o may must mustnot patch patchnot patch g patchnot ocan be used at c patch g patchnot ois not used at c patchnot patchnot u patch ocan be used at c patchnot u d ois not used at c where the sets g u and dare defined below.
gis the set of patches that are newly generated at c g c p p must .
when an access path pdefinitely points to the object we can use the access path to deallocate the object by inserting free p atc.
thus patch always includes g. if the object o is not used at c patch preserves patch but when ocan be used at c patch does not include patch because the existing patches patch might cause use after free errors and no longer guarantee the safety.
finally we exclude patchnot from the resulting sets in order to ensure the invariant that patch andpatchnot are disjoint.
uis the set of patches that we cannot guarantee the safety u c p p may must .
these patches may be unsafe because pmay point to the object at runtime.
thus we include them in patchnot .
dis the set of patches that potentially cause double frees d patch g which should be included in patchnot .
we detect doublefrees by checking whether the generated patch c p g already exists in the current safe patches patch .
if so the deallocation free p atccan be executed more than once causing a double free.
when the object is used at c we alsoesec fse november lake buena vista fl usa junhee lee seongjoon hong and hakjoo oh add the set of patches that may cause use after frees i.e.
patch .
note that patch is a superset of d. next we define the transfer function cthat updates the pointsto sets.
we assume that may point to may alias and must alias analyses are available through the following functions mayptsto c ap p allocsite given a program point cand an access path p mayptsto c p returns the set of abstract objects that pmay point to at c. mayalias c ap p ap given candp it returns the set of access paths that may be aliased with patc.
mustalias c ap p ap given candp it returns the set of access paths that are definitely aliased with patc.
we prepare these functions by running standard pointer and alias analyses before the main analysis.
below we assume mayalias andmustalias are lifted to receive sets as argument e.g.
mayalias c x y mayalias c x mayalias c y .
given an object state s o may must mustnot patch patchnot atc cupdates may must and mustnot as follows c s o may must mustnot patch patchnot where may is defined as follows may p ap o mayptsto c p mustnot .
it includes the access paths that may point to the object from which mustnot is removed to ensure the object invariant.
the sets must andmustnot are defined depending on the type of statements.
for example when cmd c alloc x must andmustnot are must mustalias c must mayalias c x x mustnot mustalias c mustnot mayalias c x x x because xrefers to a new object after the allocation we remove all the access paths that are reachable from x i.e.mayalias c x x from must andmustnot .
in addition mustnot includes xsince we know that xdefinitely does not point to the old object.
other cases are defined similarly.
.
solving exact cover problem the second step of memfix is to establish and solve an exact cover problem.
the static analysis computes safe and unsafe patches separately for each object.
however a patch that is safe for an object may be unsafe for others.
thus memfix aims to choose a set of patches that are simultaneously safe for all allocated objects.
memfix does so by solving an exact cover problem derived from the static analysis.
we first describe the basic method section .
.
which captures the key idea behind our approach but works correctly with an assumption on the input program.
we will explain the assumption and how to discharge it in section .
.
.
.
.
basic method.
letr sbe the set of reachable states available at the exit node of the program according to the static analysis i.e.
r lfpf cx .
then we define safe unsafe and candidatepatches as follows safer patch patch r unsafer patchnot patchnot r cand r safer unsafer safercontains the patches that are guaranteed to safely deallocate some object.
unsaferis the set of patches that may be unsafe for some object.
excluding unsaferfrom safer we obtain the set of candidate patches that we can use in repairing the program.
letm cand r p r be the function from candidate patches to the reachable states that can be safely deallocated by the corresponding patches m c o may must mustnot patch patchnot r c patch for example mdescribes the incidence matrix in section .
.
then the problem of finding correct patches is defined as follows.
definition .
the correct patch problem .
find a subset c cand rof candidate patches such that ccovers the reachable states r i.e.
r s c cm c and the chosen subsets in m c where c c are pairwise disjoint i.e.
m c1 m c2 for all c1 c2 c. the first condition means that all allocated objects must be deallocated i.e.
no memory leaks .
the second one means that every allocated object is deallocated no more than once i.e.
no double frees .
we guarantee the absence of use after frees as well because the patches that may cause use after free are all collected in unsafer and already excluded from cand r. note that this is an instance of the exact cover problem a wellknown np complete problem .
we solve the exact cover problem by encoding it as boolean satisfiability and leveraging an offthe shelf sat solver.
let r r1 .
.
.
rm be the set of reachable object states and cand r c1 .
.
.
cn be the set of candidate patches for r. let c cand rbe the solution of the patch problem definition .
.
we introduce boolean variables si i n and tij i n j m to encode the solution of the patch problem and the function m si ci c tij rj m ci .
that is siis true iff the patch candidate ci cand is included in the solution c and tijis true iff the object state rj ris deallocated by the patch ci.
then we can encode the two conditions in definition .
by boolean constraints 1and 2 1 m j 1n i 1tij si 2 m j 1n i1 1n i2 i1 i2 ti1j si1 ti2j si2 the formula 1encodes the first condition of definition .
for any reachable object rj some patch ciin the solution must deallocate the object.
the formula 2encodes the second condition for any reachable object rj two different patches ci1andci2in the solution do not deallocate the object rjat the same time.
finding a satisfying assignment of 1 2 which assigns truth values to variables si static analysis based repair of memory deallocation errors esec fse november lake buena vista fl usa determines the solution c.memfix succeeds to repair the input program iff 1 2is satisfiable.
note that in our approach patches in the solution calways deallocate mutually exclusive concrete objects.
this property is ensured by uin the patch transfer phase which collects patches that are uncertain to free an object.
the property is sufficient to ensure the safety of a generated patch although we do not guarantee that abstract object states always represent mutually exclusive concrete objects.
.
.
ensuring safety during patch generation.
now we explain the assumption behind the basic method and how to address it.
consider the code p malloc p malloc where two objects o1 ando2are allocated and pointed to by pand p respectively.
our method finds out that the object o1can be deallocated by free p ando2byfree p at the end of the code.
thus the method generates one of the following two fixes p malloc p malloc free p free p p malloc p malloc free p free p however the second one is not safe because the object pointed to by pis deallocated by free p and then dereferenced by the subsequent deallocation free p causing a use after free.
note that this type of use after free is caused by the inserted patches not by the ordinary uses present in the original code for which the our method guarantees the safety .
we can simply address this problem by assuming that the input program is written in a way that a temporary variable is introduced whenever a pointer expression is dereferenced.
for example we assume that the code above has been transformed to the following before we apply our algorithm p malloc p malloc tmp p where variable tmpis created to store the value of the pointer expression p. then we can avoid the problem of the basic method by generating patches whose pointer expressions are always program variables e.g.
p malloc p malloc tmp p free p free tmp this does not cause use after free errors as no pointers are dereferenced by the deallocation statements inserted by our algorithm.
another way of addressing the problem without introducing temporary variables is to extend the previous algorithm to consider the additional constraint that a patch should not use an object that was previously deallocated by other patches.
let rc sbe the set of reachable states available at the node c i.e.
rc lfpf c .
we write rfors c crc.
the function m cand r p r is defined in the same way but with the new r m c a may must mustnot patch patchnot r c patch we define u cand r p r which is the function that maps candidate patches to reachable objects that may be used by the pointer expressions of the patches u c x and u c x o may must mustnot patch patchnot rc o mayptsto c x x mustnot a patch of the form c x does not use any object state.
a patch c x may access the objects that xmay point to at c. in order for a patch to be safe i.e.
no use after free the patch should not use an object that was previously deallocated by anotherpatch.
to ensure this for any pair c1 c2 c cof selected patches mandushould be disjoint i.e.
m c1 u c2 .
the extended patch problem is defined as follows.
definition .
the extended patch problem .
find a subset c cand rof candidate patches such that ccovers the reachable states rcxat the exit node i.e.
rcx s c cm c and the chosen subsets in m c where c c are pairwise disjoint i.e.
m c1 m c2 for all c1 c2 c. the subsets in m c c cand u c c care disjoint i.e.
m c1 u c2 for all c1 c2 c. the last condition can be easily encoded by a boolean formula in a similar way described above.
our implementation solves the extended patch problem and does not introduce temporary variables.
evaluation in this section we experimentally evaluate memfix .
the main objective is to evaluate the ability of memfix in fixing memory deallocation errors in practice.
we also compare memfix with the existing tool leakfix for fixing memory leaks.
all experiments were done on a linux machine with intel core i5 and 8gb ram.
.
implementation we implemented a prototype of memfix on top of sparrow6 which provides a general framework for performing abstract interpretation of c programs.
we instantiated the framework with the abstract domain and semantics function described in section .
our focus is on faithfully implementing the analysis and algorithm in section rather than on optimizing its performance.
we discuss the detail and assumption of the current implementation below.
although we presented the algorithm for the simple language in section .
our implementation supports most of the features of the c programming language including procedure calls structures pointer arithmetics etc.
the current implementation of the patchgenerating static analysis section .
performs a fully contextsensitive except for recursion using the call strings method .
as pre analysis we use a standard context insensitive and flowsensitive may points to and may alias analysis and a context and flow sensitive must alias analysis .
our implementation supports the general class of pointer access paths in c programs including structure fields and a chain of pointer dereferences.
however because the number access paths can be infinite in the presence of dynamic arrays and inductive data structures e.g.
linked list we approximate them using a pre determined bound on their length.
the current bound is the maximum length of the longest pointer access path in the given program.
our implementation supports the c standard memory allocators malloc andcalloc except for realloc .
to support the full semantics of realloc a patch must introduce a conditional deallocation statement which is beyond the scope of the current algorithm.
we also encoded some memory allocators in our benchmarks such as strdup for the evaluation.
we implemented the algorithm to choose an optimal patch when multiple patches are available.
it is easy to modify our algorithm november lake buena vista fl usa junhee lee seongjoon hong and hakjoo oh to find a patch that is optimal according to some criteria.
for example suppose we would like to find a set of patches such that the number of inserted deallocation statements is minimal and objects are deallocated as early as possible.
to find such an optimal solution we use a partial max sat solver with the soft constraints and .
in particular we deallocate objects as early as possible by maximizing the number of object states that are deallocated by patches.
.
benchmarks we evaluated memfix with three benchmark sets juliet test suite for c gnu coreutils7 and a set of model programs abstracted from popular open source c repositories.
the first two benchmark sets are well known for evaluation of program analysis tools .
the last one was created by us with the goal of evaluating software repair tools for memory deallocation errors.
we make this benchmark set publicly available with our tool so that it can be objectively used in the future.
all reported locs are counted without comment and blank lines.
juliet test suite.
juliet test suite consists of small but diverse programs that contain cwe vulnerabilities.
we used a subset of the collection comprising testcases relevant to memory leak cwe double free cwe and use after free cwe .
for each error type e.g.
memory leak the benchmark set contains a variety of vulnerability patterns that differ in syntax and semantics.
testcases for each cwe were categorized by their functional variants that describe flaw types of cwe.
for example int malloc means a memory block allocated to integer pointer leaks.
among the functional variants we did not consider semantically redundant testcases such as ones that are only different in types e.g.
char malloc int malloc .
we also excluded the testcases for realloc .
coreutils.
among the total programs in the coreutils .
package we chose programs that use dynamic memory allocation have the main function and do not use realloc .
open source repositories.
we collected real memory deallocation errors from popular open source c repositories.
the benchmarks consist of a set of model programs of loc abstracted from the most recent error fixing commits in github open source c repositories.
for each commit we created a model program that captures the key reason of the memory deallocation errors.
we did our best to preserve the original features of the program e.g.
pointer arithmetic data structures and function pointers so that the parts of the program related to the errors remain intact in the model programs.
therefore although the model programs are small compared to the original fixing the errors in them is nontrivial.
we chose five c repositories which have at least memory deallocation error commits including at least double free and use after free fix commits.
we collected error fixing commits for each repository from the end of year in reverse commits from memory leak and from double free and use after free.
.
results evaluation results on juliet test suite.
cwe id functional variants bugs memfix leakfix 401int malloc struct malloc 415free int free struct 416malloc free int malloc free struct return freed ptr total table evaluation on gnu coreutils.
memfix leakfix programs loc al.
ins.
sec ins.
sec yes .
.
users .
.
unexpand .
.
tee .
.
mktemp .
.
tsort .
.
paste .
.
date .
.
cut .
.
nl .
.
pinky .
.
cat .
.
ln .
.
printf .
.
stdbuf .
.
wc .
.
shred .
.
cp .
.
install .
.
who .
.
tr .
.
expr .
.
stat .
.
dd .
.
juliet test suite.
table shows the results on juliet test suite.
we provided the buggy versions of the programs to memfix as input and manually checked the correctness of patches.
to evaluate leakfix we removed all free statements from the programs generating memory leaks and checked whether leakfix can patch the buggy programs.
the results show that memfix succeeds to patch all testcases while leakfix is able to fix among .
both tools took less than a minute to generate the patches for each testcase.
gnu coreutils.
table shows the results on programs from coreutils.
for evaluation we made those programs buggy by removing all free statements.
the goal of the evaluation here is to see whether memfix and leakfix can automatically repair the memory leaks without causing other types of errors.
in this setstatic analysis based repair of memory deallocation errors esec fse november lake buena vista fl usa table evaluation on open source c repositories repo.ml df uaf total fix pgm.
fix pgm.
fix pgm.
fix pgm.
binutils git openssh openssl tmux total of experiments we manually replaced x strdup by semanticallyequivalent code using malloc in order for leakfix to understand.
al.
reports the number of target allocation sites in the programs.
ins.
is the number of free statements inserted by the tools when the repair process is successful.
we report a program is fixed if all the target allocation sites are adequately deallocated by a generated patch.
we manually checked the correctness of the generated patches.
the results show that memfix can repair out of programs.
leakfix generated patches for programs of which programs were fixed partially i.e.
some errors remain .
open source c repositories.
table shows the results on the model programs constructed from open source repositories.
for the total of model programs where one program contains a single error memfix was able to of them.
for memory leak ml memfix succeeded to fix on average.
for doublefree and use after free memfix was able to generate patches for .
and .
of the errors.
the public version of leakfix was unstable to handle these programs and we failed to objectively compare memfix with leakfix on this benchmark.
for example leakfix often produced obviously incorrect patches e.g.
freeing a variable twice when aliased pointers are used extensively.
we found that these open source programs frequently use lowlevel c features and therefore fixing memory deallocation errors in them is much more challenging than the benchmark programs in juliet test suite or coreutils.
for example the model programs collected from git often store memory objects in arrays or linked lists and extensively use reallocation i.e.
realloc to process a set of strings e.g.
directories .
since the current version of memfix cannot effectively handle such features the portion of successful patches is relatively low in git.
openssh usually uses primitive allocators and deallocator to manage allocated objects except for key related objects.
openssh manages memory of key structures conditional to key types which requires tracking the type flags of allocated objects to precisely collect patch candidates.
allocators of openssl are quite complex since they allocate memory according to types behaviors of allocators e.g.
allocation of fields or not of openssl depends on its type.
tmux a terminal multiplexer manages its allocated objects by red black tree data structure.
consequently we failed to track must points to access paths for patch candidates.
.
limitations memfix has a number of limitations as well.
we identify them and discuss how to overcome the limitations below.1int foo struct st p int q if p flag q malloc else q p f return q 7int main struct st p int q p.f malloc q foo p use q free q free p.f double free 1int main p malloc n for i i n i p .f malloc use p .f if ... return leak for i i n i free p .f return a double free b memory leak figure errors that memfix cannot fix.
one limitation of memfix is that it can only fix an error by inserting or removing deallocation statements.
in experiments with open source repositories we found that some memory deallocation errors in the wild require other fixing strategies such as inserting conditional statements temporary variables or changing passing pointers e.g.
dst src to newly allocated object e.g.
dst strdup src .
a common failure point is when a new conditional statement is required to fix the error.
for example consider the program in figure a simplified from git.
to fix the double free error at line without causing memory leak we have to deallocate qat line only when the flag p flag is true.
that is we need to modify free q at line into if p flag free q by introducing a conditional statement.
another situation where memfix fails is when deallocation statements exist implicitly in code.
for example the following code shows one example of use after free error which cannot be fixed bymemfix found in git.
p alloc q p p realloc p sz use q p alloc q strdup p p realloc p sz use q in this code qpoints to the object allocated at the first statement but this object may be deallocated by realloc statement and useafter free may occur at use q .
however this code cannot be fixed by inserting or deleting free statements since free statement does not exist explicitly.
the developer fixed this code by allocating a new object and passing it to qinstead of the existing object which can be deallocated by the realloc statement.
another limitation comes from the pointer analysis.
for example figure b shows an example program where memfix cannot fix the memory leak error at line .
to fix the error the pointer analysis needs to be able to separately consider the array elements.
however as the pointer analysis employed by memfix abstracts all array elements as a single abstract location memfix cannot analyze the code precisely.
we also found that the context insensitive maypointer information is not precise enough to generate patches in practice.esec fse november lake buena vista fl usa junhee lee seongjoon hong and hakjoo oh finally the scalability of static analysis should be improved.
we plan to adopt advanced analysis techniques e.g.
accumulated in the static analysis community over the last decades.
related work a large amount of work on automatic program repair has been done over the last decade e.g.
.
we classify the existing work into special purpose and general purpose techniques and compare them with memfix .
we also discuss techniques for automatic memory management.
special purpose program repair techniques.
memfix belongs to the family of techniques that focus on fixing specific classes of errors.
existing techniques aim to automatically fix memory leak buffer overflow integer overflow null pointer exceptions error handling bugs race errors etc.
to our knowledge memfix is the first technique that is able to fix memory deallocation errors i.e.
memory leak double free and use after free in a unified fashion.
in particular existing techniques for fixing and diagnosing memory leaks cannot fix double frees or use after frees.
gao et al.
present a technique called leakfix that automatically fixes memory leak errors in c programs.
leakfix uses pointer and dataflow analyses to safely insert a free statement into a program point where the allocated object can be deallocated only once without being used subsequently.
sonobe et al.
present a typebased technique for fixing memory leaks in imperative programs.
the technique is based on the type system using fractional ownerships which guarantees that well typed programs do not have memory deallocation errors at runtime.
the idea is to run the existing type inference algorithm and annotate the input program with type casts which express how ownerships of pointers should be converted.
for each implicit type cast in the resulting program a free statement is introduced to make the type conversion explicit.
yan et al.
present a technique that combines static and dynamic analysis to avoid memory leaks.
these techniques are only able to insert deallocation statements and therefore limited to fixing memory leaks.
leakpoint and leakchaser are essentially localization tools and cannot fix errors automatically.
by contrast memfix is designed to fix memory deallocation errors in general with a novel algorithm that solves the exact cover problem induced by a static analysis.
general purpose program repair techniques.
the general test based approaches e.g.
to automatic program repair is not adequate for fixing memory deallocation errors.
these approaches work with a set of testcases some of which expose the error in the program and aim to find a patched program that behaves correctly on all inputs in the test suite.
these techniques can be classified into generate andvalidate and semantics based techniques.
generate and validate approaches repeatedly search for candidate patches within a pre defined search space until a program that can be validated against the test suite is found.
semantics based approaches use symbolic execution to derive contraints on the correct patch and synthesize the patch by using program synthesis or constraint solving.
although remarkable progress has been made it is hard to fix memory deallocation errors with a test based technique.
besides their inherent overfitting problem the safety condition for memory deallocation i.e.
no memory leaks double frees and use after frees cannot be completely specified with input output testcases.
a few techniques enhance the test based approaches by using for example program verification metamorphic testing and contracts .
although these techniques mitigate the overfitting problem or relieves the burden of writing testcases it is still nontrivial to provide a complete specification for proving the absence of memory deallocation errors.
in this work we present a static analysis based approach where the correctness conditions are automatically generated by a static analysis.
automatic memory management techniques.
several techniques have been proposed to optimize memory usage in automatic memory management systems which also inserts deallocation statements in a program.
however their goal is to optimize performance rather than fixing memory deallocation errors.
aiken et al.
introduced explicit region operations i.e.
region allocation and deallocation and presented an algorithm to improve efficiency of a region based memory management system by inserting allocation and deallocation statements.
however this technique works only on region type annotated programs.
shaham et al.
presented a static analysis to verify safety of free inserted java programs which can verify the safety of list manipulating programs but requires manual insertion of deallocation statements.
compile time object deallocation techniques insert freestatement in java bytecode programs at compile time to reduce overhead of garbage collection.
however these techniques insert free only at unreachable points and cannot free all objects.
dillig et al.
presented an automated resource management technique to optimize resource usage in java.
this technique analyzes and approximates lifetimes of objects and inserts static and dynamic disposal statements.
conclusion debugging memory deallocation errors is a taxing and error prone task.
in this paper we presented memfix a new technique for automatically debugging memory leak double free and use afterfree errors in c programs.
experimental results show that memfix is able to repair various errors from open source programs.
notably memfix is based on a sound static analysis which provides several fundamental benefits.
first it sheds light on the connection between the problem of finding correct patches for memorydeallocation errors and the exact cover problem.
second it formally guarantees the correctness of the patches the memfix generated patches eliminate the target error without introducing new errors.
as future work we plan to push this direction towards deploying the technology in practical development setting.
acknowledgement.
this work was supported by samsung research funding incubation center of samsung electronics under project number srfc it1701 .
this research was also supported by basic science research program through the national research foundation of korea nrf funded by the ministry of science ict future planning nrf 2016r1c1b2014062 .static analysis based repair of memory deallocation errors esec fse november lake buena vista fl usa