template guided concolic testing via online learning sooyoung cha korea university republic of korea sooyoungcha korea.ac.krseonho lee korea university republic of korea seonho lee korea.ac.krhakjoo oh korea university republic of korea hakjoo oh korea.ac.kr abstract we present template guided concolic testing a new technique for effectivelyreducingthesearchspaceinconcolic testing.addressing the path explosion problem has been a significant challenge inconcolictesting.diversesearchheuristicshavebeenproposed to mitigate this problem but using search heuristics alone is not sufficienttosubstantiallyimprovecodecoverageforreal worldprograms.thegoalofthispaperistocomplementexistingtechniques and achieve higher coverage by exploiting templates in concolic testing.
in our approach a template is a partially symbolized input vector whose job is to reduce the search space.
however choosing a right set of templates is nontrivial and significantly affectsthe final performance of our approach.
we present an algorithmthat automatically learns useful templates online based on datacollected from previous runs of concolic testing.
the experimental results with open source programs show that our technique achievesgreaterbranchcoverageandfindsbugsmoreeffectively than conventional concolic testing.
ccs concepts software and its engineering software testing and debugging keywords concolic testing online learning acm reference format sooyoungcha seonholee andhakjoooh.
.template guidedconcolic testing via online learning.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm newyork ny usa 11pages.
introduction concolic testing is a popular software testing method that effectively and systematically achieves high code coverage and finds bugs.
the key idea of concolic testing is to simultaneously execute a program concretely and symbolically where new test casesaresystematicallygeneratedbysymbolicexecutionenhanced corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
in diverse application domains such as operating systems firmware and binary code among many others.
a major open challenge in concolic testing is how to effectively explore the search space.
as the number of execution paths in a realistic program grows exponential concolic testing must be able to favor and explore the paths that are most likely to benefit the finaltesting results.however guiding concolictesting effectively isnontrivialandmanydifferentapproaches existwiththegoalof mitigating the path explosion problem e.g.
path pruning search heuristics and so on.
inthispaper wepresenttemplate guidedconcolictesting anew technique for adaptively reducing the search space of concolic testing.thekeyideaistoguideconcolictestingwithtemplates whichrestricttheinputspacebyselectivelygeneratingsymbolicvariables.
unlike conventional concolic testing that tracks all input values symbolically our technique treats a set of selected input values as symbolic and fixes unselected inputs with particular concreteinputs thereby reducing the original search space.
a challenge however is choosing input values to track symbolically and replacingtheremaininginputswithappropriatevalues.toaddressthis challenge we develop an algorithm that performs concolic testing while automatically generating using and refining templates.
the algorithm is based on two key ideas.
first by using the sequential pattern mining we generate the candidate templates from a set ofeffectivetest cases wherethetest casescontributetoimproving codecoverageandarecollectedwhileconventionalconcolictesting is performed.
second we use an algorithm that learns effective templates from the candidates during concolic testing.
our algo rithm iteratively ranks the candidates based on the effectiveness of templates that were evaluated in the previous runs.
our technique is orthogonal to the existing techniques and can be fruitfully combined with them in particular with the state of the art search heuristics.
experimental results show that our approach outperforms conventional concolic testing in term of branch coverage and bugfinding.
we have implemented our approach in crest and compared our technique with conventional concolic testing for open source c programs of medium size up to 165k loc .
for all benchmarks our technique achieves significantly higher branch coveragecomparedtoconventionalconcolictesting.forexample forvim .
wehaveperformedbothtechniquesfor70hours where our technique exclusively covered branches that conventional concolic testing failed to reach.
our technique also succeeded in findingrealbugsthatcanbetriggeredinthelatestversionsofthree open source c programs sed .
grep .
and gawk .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france sooyoung cha seonho lee and hakjoo oh this paper makes the following contributions we present template guided concolic testing a new technique for reducing the input space by selectively generating symbolic values without any prior domain knowledge.
we present an online learning algorithm to select useful templates from previous runs of concolic testing.
we extensively compare our technique with conventional concolictestingonopen sourcecprograms.wemakeour tool called contest and data publicly available.
overview in this section we illustrate our approach with an example.
.
motivating example fig.1showsacodesnippetsimplifiedfrom tree .
.
wherewe assumethatthebodyof strncmpisnotavailable.function ftakesas input two arrays of characters namely input1andinput2 where the size of each array is .
the program execution is determined by the contents of these arrays.
at line xflagis set to if the firsttwocharactersof input1are and x .atline9 duflag is set to if input2contains the string du .
thus the error location line12 isreachablewhenthefunctionisexecutedwith the following inputs input1 x input2 d u where means an arbitrary character.
the goal of concolic testing istogeneratesuchinputsthatdriveprogramexecutiontohitthe error location.
however conventional concolic testing is unlikely to trigger theerrorduetothehugesearchspace.inordertoreachtheerror location the program execution must hit lines and .
to do so concolic testing initially runs the program with random inputs while simultaneously executing the program with the symbolic inputs input1 1 2 3 4input2 5 6 7 8 duringtheexecution constraintsonthesymbolicvariables 1 ... 8 arecollectedandusedtogeneratethenextinput.forexample when the initial execution follows the true branches of the conditional statementsatline4andthefalsebranchesofthestatementsatlines and the following constraints are collected 1 2 x 5 nequal .
negating for example the last conjunct will produce input thatmakes the program execution to exercise the true branch of the firstconditionalstatementatline7.then assumingthatthenew input does not satisfy the second condition at line the following path condition will be newly generated 1 2 x 5 6 nequal negatingthelastconjunctagain concolictestingsucceedstoreach theprogramlocationrightbeforetheconditionalstatementatline8.
atthispoint however itstillneedstoexplorealargesearchspaceto generate inputs that satisfy the condition !strncmp ... as the body ofstrncmp is not available and therefore symbolic variables 1concolictesting charinput2 2intxflag duflag 4if input1 input1 x 5xflag if input2 input2 8if !strncmp du input2 9duflag 11if xflag duflag error figure motivating example 7and 8areunconstrained.hence thelasttwocharacters du mustbegeneratedbychance wheretheprobabilityistoolowgiven that there already exists multiple more precisely paths from the entry of the program to line .
our template guided concolic testing aims to reduce the search space effectively and automatically.
during concolic testing our techniqueadaptivelygenerates templates whichareusedtorestrict theinputspacebyselectivelyintroducingsymbolicvariables.for example when it is applied to the program in fig.
our technique automaticallyproducesthefollowingtemplateforrestrictingthe search space input1 x input2 7 8 thatis allinputvaluesexceptforthelasttwoarefixedbyconcrete values so that concolic testing no longer needlessly attempts to explore execution paths that cannot reach line .
in other words ourtechniqueisabletoenforcethenecessaryconditiontoreachthe error location enabling concolic testing to focus on generating the inputs d and u for 7and 8 respectively.
with this template concolic testing is able to generate the error triggering input more effectively upto9timesfasterthantheconventionalmethodfor the example program.
.
template guided concolic testing with online learning fig.2illustratesourtechniqueforperformingconcolictestingwhile automaticallygeneratingtemplatesonline.ourtechniqueisableto generate effective templates without any prior domain knowledge.
thealgorithmrepeatsthefollowingfiveproceduresuntilagiven testing budget is exhausted.
.
.
conventionalconcolic testing.
we firstperformconventional concolic testing without template to generate a set of effectivetestcases.wesayatestcaseiseffectiveifitenablestoexercise previously uncovered branches during concolic testing.
we run concolictestingforacertainamountoftimeandcollecteffective authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
template guided concolic testing via online learning ase september montpellier france !
!
!
figure overview of our technique test cases.
for example when we run concolic testing on the example program in fig.
1for fewminutes we could collect more than effective test cases such as the following input1 x input2 p input1 r l input2 s y .
.
sequential pattern mining.
once a dataset of effective test cases is collected we try to capture common patterns in those inputvectors.specifically weaimtoextractapartialsequenceof charactersthatfrequentlyappearintheeffectivetestcases.todo so we use a recent algorithm for sequential pattern mining whichfindsoutthefollowingfourpatternsfrom40 000testcases collected during the previous phase p1 x p2 s p3 x p4 forexample pattern p1saysthateffectivetestcasesarelikelyto involve characters x and in order.
.
.
pattern ranking.
after generating the candidate patterns via sequential pattern mining we choose the top kpatterns that are most likely to maximize unique branch coverage the coverage is calculated as the number of branches that conventional concolic testing has not discovered.
in our example to quickly cover the uniquebranch e.g.
thetruebranchatline8infigure1 pattern p3 in figure 2is required.
however pinpointing the effective pattern among the candidates is nontrivial as running the algorithm on real world programs usually discovers thousands of patterns.
even worse onlyasmallfractionofthecandidatepatternsiseffectivefor increasing branch coverage.
we address this challenge by ranking candidatepatternsbasedontheeffectivenessofsimilarpatternsthat wereevaluatedinthepreviousruns.weaccumulatesetsofgood and bad patterns during the algorithm and use them to estimate the effectiveness of the newly generated patterns.
for the example program we choose p3andp2whenk .
.
.
patterntotemplate.
thenextstepistotransformpatterns to templates.
note that a pattern is simply an ordered sequence ofmeaningfulinputvalues e.g.characters tobeatemplate weneed to decide the position of each value contained in a given pattern.
to do so we first collect the test cases containing the patternand thenidentify thepositionswhere thetemplate values appear most frequently.
for instance suppose that the concrete value x appearedthe most atthe secondindex inthe test cases.
then we replace the symbolic value 2at the second index in input2with the value x .
by applying this rule to patterns p3andp2 whichwereselectedinthepreviousphase weobtainthe following two templates input1 x 3 4input2 7 8 input1 2 3 4input2 5 s 8 in the rest of this paper we also represent a template by a set of concrete values and their positions.
for example the first template can be represented as follows x .
.
.
concolic testing with template.
the final step is to run concolictestingwiththegeneratedtemplates t1andt2 .forexample whenusingthetemplate t1 weonlygeneratefoursymbolic values 3 4 7 8 andreplacetherestwithconcretevaluesin the template t1.
note that the concrete values are not arbitrary but are effectivelyguiding the concolic testingto reach theerror location e.g.
truebranchatline11infigure byforcingtheprogram execution to follow the specific path taking all true branches of the conditional statements at lines and .
afterperformingconcolictestingwiththetemplatesforacertain amount of time we evaluate the qualities of the generated templatesintermsofthenumberofuniquebranches.asaresult we classify the corresponding patterns into good and bad patterns in figure which will be used by the ranking algorithm in the nextiterationofthealgorithm.astheentireprocedureisgoingon ouralgorithmaccumulatestheevaluationdataandthereforethe ranking algorithmis able topick more effective patternsbased on the increased knowledge.
template guided concolic testing algorithm 1presentsourtemplate guidedconcolictesting.wefirst describe conventional concolic testing and then explain how to modify it to our algorithm.
.
conventional concolic testing withoutline6 algorithm 1becomesconventionalconcolictesting whichtakesaprogram pandreturnscoveredbranchesaswellas the set of generated input vectors.
at line the sets of covered branches band generated input vectors vare initialized.
at line vdenotestheinitialconcreteinputvector whichisassumedto begivenforeachprogram.atline4 thealgorithminitializesthe symbolic input vector s angbracketleft 1 ... v angbracketright where each idenotes a fresh symbol representing the i th input.
at line the program p is concolically executed pisexecuted with theconcrete input v while it is at the same time executed symbolically with s. once the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france sooyoung cha seonho lee and hakjoo oh algorithm template guided concolic testing input programpand template t output covered branches and generated input vectors procedure concolictesting p t b v v initial concrete input vector s initial symbolic input vector form 1t ondo v s instantiate v t instantiate s t concolicexecution p v s b b branches ifeffectiveinput v then v v v end if repeat i choose a branch from 1 n untilsat logicalandtext.
j i j i v model logicalandtext.
j i j i end for return b v end procedure executionterminates the concolicexecution functionreturnsthe current path condition a constraint on the symbolic variables 1 ... v .thepathconditionisasequenceofexercisedbranches in the program and is used to generate the next concrete input vector at lines .
at line a branch iis chosen from and negated line14 .ifthechosenbranch iisnotcontradictablewith respect to the current path sat logicalandtext.
j i j i the next input vector is obtainedby solving the negatedconstraint line .
the algorithm repeats the above procedure until the testing budget n is exhausted.
in experiments we set n .
.
concolic testing with template our algorithm differs from conventional concolic testing in that some input values are fixed according to the given template.
a template tis a set of pairs of indices and values t i0 v1 ... im vm .
intuitively a pair i v tindicates that the i th input of vand sis fixed by the concrete value v so that concolic testing should notsymbolicallytrackthoseinputsin t.weassumethatforevery i v t iis unique and i v .
thetemplateisinstantiatedatline6.beforerunningtheprogram both concrete and symbolic input vectors are modified where the instantiate function replaces a given vector aaccording to the template tas follows instantiate a t angbracketleftv1 ... v a angbracketright whereviisthevalue vinthetemplateif i v t.otherwise if i v nelementt viis not changed i.e.
vi ai.
that is given a vector aandatemplate t instantiate a t replacesthe i thelementof aby the value in t. as a result concolic execution of pat line 7generatesconstraintsonlyforasubsetoftheoriginalsymbolic variables 1 ... v .
we assume that the modelfunction at line produces arbitrary values for unconstrained symbols.
our template guided concolic testing poses a significant challenge.
that is the effectiveness of our approach depends on thealgorithm template guided concolic testing with online learning input programp output the number of covered branches initialization angbracketleftb tb good bad angbracketright angbracketleft angbracketright repeat step exploration with conventional concolic testing v fori 1to 1do bi vi concolictesting p angbracketleftb v angbracketright angbracketleftb bi v vi angbracketright end for step mining patterns in collected input vectors cand sequentialpatternmining v step ranking patterns ranked patternranking cand good bad step exploitation with templates whileranked nequal do p pick the highest rank from ranked ranked ranked p t patterntotemplate p v bt fori 1to 2do bi vi concolictesting p t bt bt bi end for tb tb bt check whether pattern pis good or bad if bt b 3then good good p else if bt b 1then bad bad p end if end while untiltimeout return b tb given template t. for example when t the algorithm becomestheordinary concolictestingthattracks allinputvariables symbolically which often suffers from the path explosion problem.
on the other hand when the template is too specific e.g.
t v0 v1 ... v vv in the extreme the algorithm becomesmore likerandom testing and is likely to lose the benefitofconcolictesting.themaincontributionofthispaperis thetechniquethatinterleavesconventionalandtemplate guided concolic testing in a way that automatically generates effective templates and maximizes the final code coverage in the long run.
template guided concolic testing with online learning inthissection wepresentouralgorithm algorithm forperforming template guided concolic testing while automatically generating effective templates online.
algorithm 2consists of four main stages conventional concolic testing sequential pattern mining authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
template guided concolic testing via online learning ase september montpellier france ranking andtemplate guidedconcolictesting.atline2 thealgorithm begins with initializing data.
the sets bandtbrepresent branchescoveredbyconventionalconcolictestingandtemplateguidedconcolictesting respectively.thesets goodandbaddenote the effective and ineffective input patterns respectively.
thealgorithmhasthreehyperparameters 1 2 and 3 .the first parameter 1is used at line and determines the number conventional concolic executions in the first phase.
the second parameter 2 which is used at line denotes the number of concolic executions with each template.
the last parameter 3 representsthethresholdvalueforthepattern ptobeagoodpattern i.e.
included in the set good .
in experiments we set 1 2 3 .
in this work we tuned these hyperparameters manually by trial and error and found that the performance of algorithm 2depends on them substantially.
an interestingfuture direction would be finding optimal hyperparameters automatically during the algorithm.
.
exploration without templates thefirstphaseofthealgorithm lines5 istorunconcolictesting withouttemplate i.e.
t toexploreandcollectdiverseinput vectors that are effective in increasing branch coverage.
atline5 theset vofinputvectorsisinitiallyempty.atlines6 concolictesting algorithm isrunfor 1times.whenconcolic testingfinishes thesets biandviofcoveredbranchesand effective inputvectors respectively arereturned.we sayinputvectorsare effective i.e.
effectiveinput at line of algorithm if they satisfy thefollowingtwoconditions.first theinputvectorsshouldbeable to increase branch coverage after the initial of the budget n forconcolictesting isexhausted.forexample whenbudget nis 000programexecutions weignoreinputsgeneratedduringthe first executions.
this is because branch coverage gets easilyincreased in the early stage of concolic testing no matter what initial input vectors are used.
second the input vectors should contribute to discovering branches that are new compared to previous programexecutions.collecting effectiveinputsonlyiscrucialbecauseblindlycollectingallinputscancauseseriousperformance degradation in the next stage sequential pattern mining.
.
mining patterns the second step of the algorithm is to mine common patterns from the collected set of effective input vectors line .
we observed that each effective input vector is likely to have meaningful subsequencesthatultimatelycontributetoimprovingbranchcoverage.
the goal ofthis stage is to quicklyextract such subsequences that arecommontomanyofthecollectedinputsandusethemasthe candidates to reduce the search space.
fortunately for this purpose we can use off the shelf techniques called sequential pattern mining in the data mining community which can do the desiredtask efficiently.
numerous pattern mining algorithms have been proposed in the literature .
we used a state of the art algorithm clofast whichavoidsgeneratingredundantpatterns.
clofast also outperformsthe existingalgorithms interms ofcomputation time and memory consumption .
for example when clofast takes effective inputs collected from sed .
i t generates candidate patterns in five minutes.
in algorithm algorithm patternranking input candidate patterns cand good patterns good bad patterns bad output learned patterns ranked procedure patternranking cand good bad initialize pattop patmid angbracketleft angbracketright angbracketleft angbracketright ranked step reflection whilecand nequal do p pop cand cand cand p ifmatch p good match p bad then pattop pattop p else if match p good match p bad then patmid patmid p end if end while pattop pattop patmid step diversification while ranked kdo p pop pattop pattop pattop p ifdiverse p ranked then ranked ranked p end if end while returnranked end procedure thealgorithmismodeledbythe sequentialpatternmining function which takes a set of input vectors and returns a set of common patterns.
.
ranking patterns thethird stepisto rankthecandidate patternsaccordingto their estimated effectiveness line .
we designed a ranking function patternranking whichchoosesthetop kpatternsfromthecandidates generated by the pattern mining algorithm.
in experiments we setkto .
at line in algorithm patternranking takes threepatternsets patternstorank cand goodpatterns good andbadpatterns bad .then itreturnsthetop kpatterns ranked that are most likely to cover new branches in the future.
the key ideas behind our ranking algorithm algorithm i st o reflecttheexperiencewiththepatternsevaluatedintheprevious runs and try as many diverse patterns as possible.
hence the main loop of the algorithm consists of the two phases reflection and diversification.
initially we rank the candidates candby sorting thembasedonthefrequencyofeachcandidatecalculatedbythe sequential pattern mining algorithm in ascending order.
the hypothesisisthatthepatternswithhigh frequenciesareunlikelyto discover new branches.
at lines pattopandpatmidare initially empty vectors and rankedis an empty set.
in the first stage reflection we transform each pattern pin candinto n grams and check whether any n grams in the pattern pare included in any patterns in good or bad pattern sets line .
to do so we define a function ngramwhich takes a pattern andreturnsasetofn gramsforthepattern wherethenumbern authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france sooyoung cha seonho lee and hakjoo oh ishalfofthelength p n ceilingleftbig p ceilingrightbig .forexample whenthepattern pisastring s b ngram p returnsthethree2 grams s b .
then we classify the patterns using predicate matchdefined as follows match p p ngram p .
uniondisplay.
p prime pngram p prime matchtakesapattern p andasetofpatterns p andreturnstrue iffanyofthen gramsof pisincludedintheunionofn gramsofthe patternsin p.weperform matchwithboth goodandbad.when match p good andmatch p bad are true and false respectively thepattern pisincludedin pattop aclasswithhighpriority line .intuitively thepattern pgetshighpriorityifitdoesnothave any of the features having bad patterns badwhile the pattern p contains at least one feature of good patterns.
at line when theresultsof match p good andmatch p bad arebothfalse the patternpisappendedto patmid aclasshavingmiddlepriority line .
the patterns in the class patmiddo not include at least the featuresofthebadpatterns.otherwise thepattern pisremoved from the candidate group of top kpatterns.
inthesecondstep diversification weaimtodiversifythepatterns by filtering out similar patterns in pattop.
to diversify the patterns we use the following function diverse p p ngram p notsubseteql uniondisplay.
p prime pngram p prime diversereturnstrueiff ngram p asetofn gramsgeneratedbythe patternp is not a subset of the union of all n gram sets generated by each pattern p primein the given pattern set p. at line we pop a pattern p. then we add the pattern pinto the set rankedonly whendiverse p ranked returnstrue line22 .intuitively thisstep makes each pattern in rankedhave at least one unique n gram.
.
exploitation with templates thelaststepofthealgorithmistoexploitthepatternslearnedfrom thepreviousphase.however thepatternsin rankedcannotbeused immediately.
because a pattern is just a sequence of characters we need to determine the appropriate position of each character.
to transformapatternintoatemplate thealgorithmusesthefunction patterntotemplate whichtakesapatternandasetofinputvectors and creates a template for the pattern.
we generate the template in two steps.
first we only collect the input vectors containingthe pattern among the input vectors vaccumulated in step of algorithm2.second foreachcharacterinthepattern wecompute the position where the character appears most frequently.
theresulting template is used to perform template guided concolic testing.
atline19ofalgorithm wefirstpickapattern pwiththehighest priority from the set ranked.
then we transform the pattern p intothetemplate tbyusingpatterntotemplate line21 .usingthe template we perform concolictesting p t for 2times lines .aswementionedbefore weset 2 becauseweexperimentally observed that a good template usually was able to cover new brancheswithin20trials.wheneverwerun concolictesting p t we accumulate the branches covered by each template tin the setbt.
at lines we evaluate the quality of the template t in terms of the number of uniquely covered branches where thetable benchmark programs program total branches loc input type source vim .
165k unsigned char gawk .
.
30k unsigned char grep .
15k char sed .
9k unsigned char tree .
.
4k char table2 branchcoveragesachievedbybaselineconcolictesting on original and modified benchmarks vim .
grep .
sed .
org modify org modify org modify cfds cgs random gen number is counted as the size of the difference set between the bt andbsets.
when the number is greater than the threshold 3 we add the pattern pcorresponding to the template tto the set good.
when the number is less than or equal to one we add the patternptotheset bad.notethattorankthecandidatepatternsin thenextiterations weonlyusethepatterns whicharedefinitely determinedtobegoodorbad.thealgorithmrepeatstheprocedure untilthetimebudgetisexhausted.then itreturnsthetotalnumber of covered branches b tb line .
as the outer loop of algorithm is repeated we gradually accumulate thelearned knowledge namely goodandbadsets the formerrepresentstheknowledgeforeffectivelyreducingthesearch spacewhilethelattermustbeavoided.byiterativelyupdatingthese sets our algorithm guides concolic testing towards maximizing branch coverage.
evaluation inthissection weexperimentallyevaluateourapproach.weimplemented our approach in a tool called contest on the top of crest apubliclyavailableconcolictestingtoolforcprograms.
we have conducted the experiments to address the following research questions effectiveness of our approach how well does our approach perform compared to conventional concolic testing?
efficacyof onlinelearning isonlinelearningcrucialfor generating effective templates?
learned patterns what lessons do the learned patterns provide about search space reduction?
.
settings .
.
benchmarks.
we have used open source c programs in table1 vim gawk grep sedandtree.allbenchmarkscamefrom thepriorworksonconcolictesting withslightmodificationsontheannotationsforthreebenchmarks vim grepandsed .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
template guided concolic testing via online learning ase september montpellier france duringthiswork wefoundthatthe performanceofconcolictesting varies significantly depending on how benchmark programs are annotated and tried to annotate the programs in ways thatmaximize the performance of the baseline concolic testing.
for example since vimis a text editor program it is natural to take inputs of type unsigned char .
but the previous version ofvimwasannotatedwiththe crest unsigned short function which needlessly generates inputs from the larger space .
we replaced it with crest unsigned char .
forsedandgrep w e alsochangedtheannotationstomakethemmorenatural.forexample the original annotations of sedforced concolic testing to execute the program with the option f always turned on.
we fixedthisissuebysymbolizingtheargumentsofthemainfunction.
the modified programs are available with our tool contest.
table2shows that the baseline concolic testing performs much betteronthemodifiedprograms.wecomparedtheperformance oftheconventionalconcolictestingontheoriginalandmodified programswithvarioussearchheuristics.thetablereportsthenumber of branches covered over runs of concolic testing where a singlerunconsistsof4 000programexecutions i.e.
n 4000inalgorithm1 .overall theperformanceofconcolictestingisimproved significantly with the modifications.
for example concolic testing withthecgsheuristic forvim .7covered13 526branches on the modified benchmark while the same method managed tocover branches only on the original one.
in summary we modifiedthebenchmarkprogramstomakethebaselineconcolic testing much stronger.
wedidnotusethefoursmallprograms whichwereusedin cdaudio floppy kbfiltrandreplace.thisisbecausethe conventional concolic testing already achieves high code coverage onthoseprograms asthesizesofthesebenchmarksareverysmall e.g.
replace is of .5kloc .
.
.
searchheuristics.
inevaluation weconsideredfoursearch heuristics cgs context guided search cfds control flow directed search random branch search and gen generational search .
we chose them because our technique requires search heuristics to be nondeterministic in order to generate diverse input patterns in the first step of algorithm .
we did not use deterministic techniques such as dfs depth first search andparadyse .foreachbenchmarkprogram weappliedour technique on top of the search heuristic that performs best.
for example weusedcgsfor vimandgrep andcfdsfortheremaining three programs.
.
.
othersettings.
weusedthesameevaluationsettingsfor bothconventionalandtemplate guidedconcolictesting.first all experiments were conducted on a machine with two intel xeon processorse5 2630and192gbram.second weperformedconcolictestingonallthebenchmarks using10coresinparallel.third the initial input was fixed for each benchmark.
for vim the largest benchmark weallocated70hoursfortestingbudgetand7hours for the four smaller programs.
we set n in algorithm .
.
effectiveness of our approach weevaluatedour techniqueandconventionalconcolictestingon5 benchmarks in terms of branch coverage and bug detection.
ylp ryhuhg udqfkhv 7lph k hq 5dqgrp figure3 accumulatedbranchcoverageachievedbyconventional concolic testing and our technique on vim .
table3 thenumberofuniquelycoveredbranchesandtrials template guided approach baseline unique branch trials unique branch trials vim grep tree sed gawk .
.
branch coverage.
figure3shows that our approach tcgs increases branch coverage significantly compared to conventionalconcolictestingon vim .
.thecgsheuristicisarobust baselinethatcovers806morebranchescomparedtotherandom heuristic the second best of conventional concolic testing.
nev ertheless tcgs our template guidedconcolic testing ontop of the cgs heuristic covered branches covering more branchesthan cgs.moreimportantly table 3showsthat t cgs exclusively covered branches that cgsfails to reach over hours using cores in parallel.
the results show that our techniqueenablesconcolictestingtoachievesignificantperformance gains in practice by effectively reducing the search space.
figure4showsthatourapproachalsoachieveshigherbranch coverage than conventional concolic testing on the remaining 4benchmarks.
for example ours tcgs covered branches forgrep whilecgscovered only branches during the same time period 7h .
our approach succeeded to cover the branches that conventional testing fails to reach on all benchmarks.
table reportsthenumberofuniquebranchesandtrials.theformerdenotes the number of branches only covered by each approach.
for grepandtree and branches were exclusively covered by t cgsandt cfds respectively.
the latter is the total number of trials that each approach has performed concolic testing during the same time budget for each benchmark as we mentioned above authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france sooyoung cha seonho lee and hakjoo oh juhs ryhuhg udqfkhv 7lph k hq 5dqgrp wuhh ryhuhg udqfkhv 7lph k hq 5dqgrp vhg ryhuhg udqfkhv 7lph k hq 5dqgrp jdzn ryhuhg udqfkhv 7lph k hq 5dqgrp figure accumulated branch coverage achieved by conventional concolic testing and our technique on benchmarks a single trial consists of program executions n in algorithm .
becauseourapproachinvolvesadditionalruntimeoverhead e.g.
sequentialpatternmining itisnaturalforourapproachtohave fewer runs of concolic testing than conventional approach within thesametimebudget.table 3showsthatthenumberoftrialsby baselineisusuallygreaterthanthenumberoftrialsbyourtemplateguidedconcolic testing.forexample for vim the largestprogram inourbenchmarks thebaseline cgs ranconcolictesting2 timesfor70hours whileourtechnique t cgs performedit2 times.oneinterestingpointisthatfor grep thenumberoftrials for our technique is greater than that for conventional concolic testing.
this is because the benefit of reducing the search space e.g.
constraint solving time in grepis greater than the overhead e.g.
pattern mining time caused by our approach.
.
.
bug finding.
during experiments we have found five bugsinsed grep andgawk whichareexploitableeveninthelatest versions of the programs.
table 4shows the bug triggering inputs andphenomenonswhentheprogramsareexecutedwiththeinputs.table bugs in benchmarks phenomenons bug triggering inputs version sed memory exhaustion h g d .
latest sed infinite file write h w x d .
latest grep segmentation fault .
latest grep non terminating ?
.
latest gawk memory exhaustion 6672467e2 e7 .
latest thetwoerror triggeringinputsfor sedcouldconsumeallofour linuxmachine smemoryandharddisk respectively.thetemplate used for generating the former input is as follows n n d .
the template guides concolic testing to find thebugeffectively byconcretizing4ofthe6 charactersrequiredto authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
template guided concolic testing via online learning ase september montpellier france table top good and bad patterns tree .
.
sed .
good patterns bad patterns good patterns bad patterns gd gs n n n n 1d 1d 1n n r uf.
n n n fi fx fg fn causethebug.in grep thesegmentationfaultoccurredwhenwe ran the program with the input we found grep file.
in particular the input 6672467e2 e7 found by our approach ingawkcauses a lot of memory to be consumed.
one interesting pointisthatthelatestversionof gawkhasalreadyperformedtheexceptionhandlingonsuchperformancebugs.forexample whenwe append a string to the original input 6672467e2 e7 an error handlingmessage cannotallocatememory isprintedandthe program is terminated.
however the input we found corresponds tothecornercaseoftheerrorhandlingcode anditconsumesmorethan100gbofmemoryonourlinuxmachine.whileourtechnique generatedthefivebug triggeringinputsintable conventional concolictestingmanagedtogeneratethetwoinputsfor sedonly within the same time budget.
.
efficacy of online learning we have compared the performance of our pattern ranking algorithm algorithm and a naive algorithm that randomly selects patterns on sed .
.
to do so for the first iterations of the outerloopofalgorithm wecomparedthequalitiesofthepatterns selectedbythetwoalgorithms wherethequalitiesarequantifiedby the number of uniquely covered branches that the cfds heuristic the baseline for sed failed to reach.
figure5showsthatouralgorithmoutperformsthenaivealgorithm in two aspects.
first our algorithm succeeds in selecting 33effectivepatterns representedbystarsinthefigure whilethe naive algorithm manages to pick effective ones represented by circles for the given budget.
as online learning progresses our algorithm gradually increases the number of times that it picks up effective patterns during thelast iterations iterations our algorithmsuccessfullyselectedabout55 oftheoveralleffective patterns.
second the average and maximum performance of the patternsselectedbyourlearningalgorithmarehigherthanones achieved by the naive algorithm the best pattern chosen by our algorithm contributed to covering unique branches.
on theotherhand thebestoneofthenaivealgorithmonlymanagedto cover unique branches.
the average performance of effective patterns selected by ours and random selection algorithm is and respectively.asaresult whenthetotalbudgetisexhausted our learningandnaiveapproachescovered1 707and1 644branches respectively.
in summary online learning is essential for solving the problem of selecting good patterns.
blindly reducing the search space without learning can be inferior even to conventional concolic testing.
vhg hduqlqj 5dqgrp8qltxho ryhuhg udqfkhv whudwlrqv figure comparison with online learning algorithm and random algorithm .
learned patterns wediscussgoodandbadpatternschosenduringonlinelearning interms ofincreasing uniquebranchcoverage.table 5showsthe top good and bad patterns on tree .
.
andsed .
.
the formerrepresentsthetop5goodpatternswiththehighestnumber ofuniquebranchesthatconventionalconcolictestingfailstoreach and the latter is patterns that do not cover any of the unique branches.
fortree .
.
goodandbadpatternsarehardlydistinguishable.exceptforthethirdpattern everyrowshowssimilargoodand badpatterns.inparticular thesecondpatternsareexactlythesame.
thisexplainswhyourrankingalgorithm algorithm shouldconservativelyremovetheunreliablepatterns recallthatweremove candidatesifit containsbothgoodandbadfeatures.
ontheother hands for sed .
good and bad patterns are quite distinctive.
however it is still very difficult for humans to predict which set of thetwopatternsetscaneffectivelyreducethesearchspace.that is manually selecting a set of good patterns is highly tricky which is something that machines can do better than humans.
.
threats to validity benchmarks weused5benchmarkprogramswhichwere widely used from prior work on concolic testing .
however thebenchmarks acceptingstringsasinput may not be sufficient to evaluate the performance of our technique and conventional concolic testing in general.
a budget for concolictesting w es e t nin algorithm 1to the same value used in prior work .
however theperformanceofourtechniqueandconventionalconcolic testing may vary depending on the value.
related work amongexistingworksonmitigatingthepath explosionproblem in concolic testing we discusstwo mainapproachesthatarecloselyrelatedtoourapproach search authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france sooyoung cha seonho lee and hakjoo oh heuristicsandsearch spacereduction.wealsodiscussrecentworks that improve software testing with learning .
searchheuristics .our technique is orthogonal to the existing works for search heuristics .
to achieve the goal of maximizing code coverage search heuristics focus on selecting oneofthecandidate branchesinthepath whereasourtechnique reducesthenumberofthecandidatesbyusingtemplate.aheuristic selectsthebranchesthataremostlikelytomaximizecodecoverage according to its own criterion.
for example the cfds heuristic selectsabranchclosesttoanyofuncoveredbranchesnearbythe current execution path.
the cgs heuristic selects a branch by performing the breath first search on execution tree while excludingbrancheswiththesame contexts fromthebranchselection.
thecontextofeachbranchiscalculatedasasequenceofpreceding branches.
the generational heuristic first selects all the branches once in the current path and measures the coverage gain for each branch selection.
then the heuristic selects the branch withthehighestgainasthenext generationbranch.ourtechnique can be used in combination with these search heuristics.
search space reduction .our work can be seen as a new approachforreducingthesearchspace .dase document assisted symbolic execution is a technique that allows symbolicexecutiontoexercisecorefunctionalitiesoftheprogramby extractinginputconstraintsfromprogramdocuments e.g.
manual pages .
our technique is different from dase as we do not require any prior domain knowledge i.e.
documents .
jaffar et al.
aim to prune the execution paths guaranteed to not trigger a bug by using interpolation.
boonstoppel et al.
proposed the technique read write set analysis for pruning the number of execution paths thatproducethesameeffects.bugraraetal.
introducedthetechniquetodiscardthepathsthataresimilartopreviouslyexecuted paths.
our technique differs from these works in that we apply onlinelearningtoadaptivelyreducethesearchspaceofconcolic testing.
learning based software testing .at a high level our work belongstothetechniquesthatcombinesoftwaretestingwithmachinelearning .learn fuzz aimstogenerate inputgrammars e.g.
pdfobject forfuzzingbyusingcharacterlevel recurrent neural networks.skyfire aims tolearn a probabilistic context sensitive grammar from the existing samples to generate seed inputs for fuzzing.
qbe learns the kinds of gui actionstodetectcrashesorincreaseactivitycoverageinandroid guitestingviaq learning.retecs employsreinforcement learning toautomatically prioritize test casesthat are likely todetectbugsincontinuousintegration ci .lastly paradyse aims to automatically learn search heuristics for concolic testing.
in this work weuseonlinelearningtoselectgoodtemplates effectively reducing the search space of concolic testing.
conclusion coping with the path explostion problem continues to be the longstanding challengein concolictesting.
inthis paper we presented anewapproach whichmitigatesthepath explosionproblembyreducing the search space using templates.
in our approach concolic testing uses a set of templates to exploit common input patternsthatimprovecoverageeffectively wherethetemplatesareautomatically generated through online learning algorithm based on the feedbackfrompastrunsofconcolictesting.experimentalresults demonstrate that our template guided concolic testing with online learning outperforms conventional concolic testing significantly in both branch coverage and bug finding.