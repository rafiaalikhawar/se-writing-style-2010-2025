tra violi a dynamic analysis for detecting data structure traversals rohan padhye and koushik sen eecs department university of california berkeley usa rohanpadhye ksen cs.berkeley.edu abstract traversal is one of the most fundamental operations on data structures in which an algorithm systematically visits some or all of the data items of a data structure.
we propose a dynamic analysis technique called t ra violi for detecting data structure traversals.
we introduce the concept of acyclic execution contexts which enables precise detection of traversals of arrays and linked data structures such as lists and trees in the presence of both loops and recursion.
we describe how the information reported by t ra violi can be used for visualizing datastructure traversals manually generating performance regression tests and for discovering performance bugs caused by redundant traversals.
we evaluate t ra violi on five real world javascript programs.
in our experiments t ra violi produced fewer than false positives.
we were able to construct performance tests for .
of the reported true traversals.
t ra violi also found two asymptotic performance bugs in widely used javascript frameworks d3 and express.
i. i ntroduction data structures form the building blocks of almost all programs.
as programs grow large the implementations of their data structures and of the code modules that use these data structures also become complex.
researchers have developed several tools to identify to visualize and to reason about data structures using static or dynamic program analysis techniques .
most of these tools focus on discovering a concise representation orabstraction of data structures in program memory at one or more programlocations during program execution.
we focus on understanding where and how data structures aretraversed in a program.
traversal is perhaps one of the most fundamental operations on data structures in which an algorithm systematically visits some or all of the data items of a data structure .
the running time of program functions that perform traversals usually increases with the increase in the size of the input data structures.
thus a proper understanding of how a program traverses its data structures is crucial for characterizing the program s performance.
we propose a dynamic analysis technique called t ra violi to detect data structure traversals in a program.
the technique works by analyzing read events generated by an execution of the program.
t ra violi reports a data structure traversal if it finds that the program reads distinct memory locations at a single program location and those memory locations either belong to the same object or belong to different objects connected by a series of pointers.
a key contribution of thiswork is the notion of acyclic execution contexts aecs which enables precise detection of traversals in the presence of loops and recursion with very few false positives.
we describe three applications of t ra violi and aecs.
first we show how we can construct an access graph to help visualize data structure traversals found in a program.
second we show how we can use t ra violi to aid in manually constructing performance regression tests.
finally we show how t ra violi can be used to detect redundant traversal bugs.
a key advantage of t ra violi is that it can detect a traversal even if a program is executed on a small unit test the program does not need to execute a program location many times to detect a traversal.
another key advantage of t ra violi is that it can detect a traversal even if the traversal involves recursive function calls and loop iterations.
we have implemented t ra violi for javascript and made it publicly available at we applied t ra violi to popular javascript projects.
in our experimental evaluation we found that t ra violi reported false positives only of the time.
in .
of reported true traversals we managed to create a performance regression test.
tra violi discovered two previously unknown performance bugs due to redundant traversals in widely used javascript frameworks d3and express which have been confirmed by the respective project s developers.
ii.
o verview we propose a technique to identify functions that traverse input data structures and whose running time could be arbitrarily increased by increasing the size of the input data structure.
we call such functions traversing functions .
in the rest of the section we present a series of examples written in javascript to motivate the definition of a traversing function and informally describe our approach for identifying such functions using dynamic program analysis.
section iii formalizes these ideas concretely.
a. traversing functions consider the function sum in figure .
the function iterates over an input array of objects arr and computes the sum of the val field of the objects it contains.
the function is an example of a simple data structure traversing function.
the running time of the function can be increased by increasing the size of the input array.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sum values in records in array 2function sum arr var result record i for i i arr.length i record arr result record.val return result fig.
.
a function that traverses an array.
compute the length of linked list 2function len list var count while list !
null count list list.next return count fig.
.
a function that traverses a linked list.
although in this example we could easily identify the input to the function i.e.
the array arr this may be nontrivial for complex functions where inputs could be passed via global or static variables.
we define read footprint to precisely capture the set of inputs to a function.
a memory location is the address of a piece of memory which stores a program value that can be read by a program.
a memory location is often denoted in a program by a variable an element of an array or a field of an object.
the read footprint of a function consists of all memory locations that are read by an execution of the function without any prior write to them by the execution.
such memory locations could be treated as the input to the function.
for example the read footprint of the sum function consists of the array arr all its elements accessed via arr the length field of the array accessed via arr.length and the field val of the objects stored in the array accessed via record.val .
in contrast the memorylocations denoted by the variables i record and result are not part of the read footprint because in any execution of sum sum first writes them before reading them.
given the definition of a read footprint we can define a traversing function as follows we say that a function is a traversing function if the size of its read footprint can be arbitrarily increased by providing suitable inputs possibly of larger size.
if a function is a traversing function then we say that the function contains a traversal .
the function sum in figure contains a traversal because the size of the read footprint increases if the size of the input array arr is increased.
the function len in figure is another example of a traversing function.
the read footprint of the len function consists of the memory location denoted by list and the memory locations denoted by the next field of all objects reachable from list by following the next field zero or more times.
the read footprint of this function can be increased by increasing the size of the list passed as an argument.
in contrast the function addpair in figure is not a traversing function.
the function addpair adds the values of the first two elements of the input array.
while this1 add values from a pair of array elements.
2function addpair arr var rx arr var ry arr return rx.val r y .
v a l fig.
.
a non traversing function.
function also reads multiple elements of arr it is not a traversing function because the size of its read footprint is always bounded regardless of the size of the input array or the values it contains.
b. detecting traversing functions the problem of determining if a function contains a traversal is undecidable in general.
however in many cases one can determine whether a function has a traversal either by analyzing the source code or by analyzing an execution of the function.
we propose a dynamic analysis technique called t ra violi to determine if a function contains a traversal.
t ra violi works by checking a set of conditions on an execution of the function if the conditions are satisfied then we say that the function contains a possible traversal.
our technique is approximate in the sense that it can give both false positives and negatives.
however we have identified a set of conditions which if satisfied often accurately indicate the presence of a traversal.
a key feature of t ra violi is that we do not need to invoke the function on an input having a large read footprint tra violi can detect a traversal by analyzing the execution of the function on a small test input.
tra violi uses program instrumentation to generate a trace ofevents corresponding to reads and writes of memorylocations.
in the following discussion whenever an execution of a function reads a memory location that the function execution has not written before we call it an input read event .a n input read event contains the address of the memory location being read the value being read and the program location where the read is performed by the function.
t ra violi determines the input read events during each function execution and analyzes them to determine if the function has a traversal.
from executions of sum and len in figures and respectively one can observe that different memory locations are read at the same program location sum reads the elements of the array arr at line and len reads the next field of the list objects at line .
this observation suggests that a traversal should satisfy the following two conditions c1.
at least two input read events at some program location lscriptaccess different memory locations and c2.
the memory locations involved in the input read events either belong to the same object or belong to different objects connected by a series of pointers.
note that addpair in figure does not satisfy the first condition because the two elements of the array are read at different program locations lines and respectively.
the above two conditions result in a false positive for the function third in figure .
the function third calls ntwice and line accesses next field of objects connected by a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
get the third element of a linked list 2function third list var node n list node n node return node.data 7function n node return node.next fig.
.
another example of a non traversing function.
check if a linked list contains a value 2function contains list x if list null return false else if list.data x return true else var tail list.next return contains tail x fig.
.
a recursive function containing a traversal.
pointer.
thus both conditions are satisfied.
however third does not contain a traversal since its read footprint is bounded to at most two linked list nodes.
the imprecision stems from the first condition which requires two input read events to occur at similar execution points where two execution points are deemed similar if they have the same program locations.
this notion of similarity of two execution points is too coarsegrained.
we can alleviate this problem if we say two execution points are similar if they are executing the same programlocation and have identical call stacks.
we capture such a state of execution in a concept called execution contexts.
definition .
the execution context of an event with respect to an execution of a function fis a sequence f1 lscript1 f2 lscript2 ... fn lscriptn where f1is the function f for eachisuch that i n lscriptiis the program location within function fiwherefi 1is invoked in the current execution and the function fnis currently executing the programlocation lscriptnto generate the input read event.
for example in an execution of the function third in figure the two input read events at line have the execution contexts third n and third n with respect to the execution of the function third .
unless otherwise specified we always refer to execution contexts with respect to the execution of the function being analyzed for traversals.
in order to remove the false positive for third we refine the first condition for traversal as follows c1.
at least two input read events at some execution context access different memory locations.
the revised condition gives no false positive for any of the previous examples.
unfortunately this revision which uses a fine grained notion of similarity of execution points introduces false negatives it fails to detect data structure traversals via recursive functions such as the function contains defined in figure .
alternately add and subtract from items.
2function alt obj return p obj.items true 5function p node flag total if node !
null var value node.data return flag ?
q node flag total value q node flag total value else return total function q node flag total var tail n node return p t a i l !f l a g total function n node return node.next fig.
.
mutually recursive functions containing a traversal.
in the function contains a recursive traversal occurs at line but its execution does not meet condition c1 because the execution contexts of the input read events at this program location are different.
in particular the execution context is contains for the first input readevent contains contains for the second input read event contains contains contains for the third input read event and so on.
such execution contexts become more complicated for more complex functions involving mutual recursion such as the function alt in figure .
the function alt traverses the linked list rooted at obj.items and alternately adds and subtracts values of its nodes to the total.
the boolean flag passed to function pat line decides which operation to perform and this flag is toggled by the function qat line .
here pand qare mutually recursive and the traversal of the linked list occurs at line after qcalls nat line .
the first time program control reaches line the execution context is alt p q n the secondtime a different branch is taken in p and thus the context is alt p q p q n and so on.
in t ra violi a key observation we make is that despite the differences in the execution contexts of the input readevents involved in a traversal the contexts are equivalent modulo recursion i.e.
after removing any cycles .
such reduced execution contexts which we define next are called acyclic execution contexts aec and they are constructed as follows.
for an execution context f1 lscript1 f2 lscript2 ... fn lscriptn we first construct an execution context graph consisting of a node for each unique function fiand a special node end.
moreover let start denote the node corresponding to f1.
for every consecutive pair fi lscripti fi lscripti in the execution context we add a directed edge from fitofi 1with label lscripti and weight i. additionally we add an edge from fntoend with label lscriptnand weight n. for the example in figure the execution context graph for the second input read event at line is shown in figure where the edges are labeled by the program locations lscriptand weights w. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
alt pq n end start lscript w lscript w lscript w lscript w lscript w lscript w fig.
.
execution context graph for the execution context alt p q p q n .
example execution contexts aec fig.
third n third n line third n third n fig.
len len line len len fig.
contains contains line contains contains contains fig.
alt p q n alt p q n line alt p q p q n alt p q n table i execution contexts and aec s for first two read events .
definition .
the acyclic execution context aec of an execution context is the sequence f1 lscript1 f2 lscript2 ... fk lscriptk such that f1 lscript1 f2...fk lscriptk fk 1is the shortest weighted path from start toend in its execution context graph.
for the graph in figure the acyclic execution context is alt p q n .
as the edge weights correspond to the position of the edge in the sequence multiple edges between two nodes are disambiguated by choosing the edge corresponding to the least recent function invocation.
two distinct execution contexts that have the same aec are the recursive analog of distinct iterations of a single loop.
unlike execution contexts that can grow unboundedly aecs are bounded because the number of permutations of distinct functions in a program is finite.
we found aecs to be a useful abstraction for clustering execution contexts of input readevents involved in a traversal such an abstraction helps us to merge execution points involved in a traversal in a precise way irrespective of whether the traversal involves recursive calls or loop iterations.
table i lists for some example functions and programlocations column the execution contexts column and corresponding aecs column for the first two input readevents when the functions are provided an input linked list containing at least two nodes.
the first row shows that the aecs for input read events at line in the function third are distinct since third does not contain a traversal.
the last three rows show that for the functions len contains and alt multiple input read events at the given locations have a common aec therefore they are traversing functions.
we can now refine the conditions that a traversing function should satisfy in terms of aecs as follows c1.
at least two input read events having same the aecs access different memory locations and c2.
the memory locations involved in the input read events either belong to the same object or belong to different objects connected by a series of pointers.
we call the aec of such input read events a traversal point .
in general a traversing function may contain more than one traversal point.iii.
f ormal description tra violi identifies the traversing functions in a program by analyzing an execution of the program.
t ra violi first instruments the program under analysis to generate runtime events.
the instrumented program is executed with a suitable set of inputs to generate a trace of runtime events.
from the generated trace t ra violi determines the input read events for every function execution.
t ra violi then analyzes each sequence of input read events to detect traversals.
we next describe each of these steps formally.
a. events and traces tra violi tracks reads and writes of every memory location during an execution of a program.
in a program a memorylocation can be denoted by a local variable a global variable a field of an object or an element of an array.
a memorylocation is represented by a pair obj fld where obj is the address of an object or array and fldis the name of a field or index of an array element .
local variables are treated as fields of special activation record objects corresponding to the stack frames in which they are allocated.
global variables are treated as fields of a special globals object.
tra violi instruments a program to generate the following four kinds of events r ead angbracketleft lscript obj fld val angbracketrightdenotes the read of a memorylocation obj fld at program location lscript.
the result of the read val can be a scalar or the address of another object.
w rite angbracketleft lscript obj fld val angbracketrightdenotes the write of a memorylocation obj fld at program location lscript.
here val is the new value that is written to the memory location.
at function calls write events are generated for each argument passed to the function where each formal parameter is treated as a local variable.
c all angbracketleft lscript f a angbracketrightis an event corresponding to the invocation of function fat the program location i.e.
call site lscript.
here ais a freshly generated unique identifier for the newly created activation record object for this function invocation.
r et angbracketleft lscript a angbracketrightis an event corresponding to a function returning to its caller.
here lscriptis the program location of the return instruction and ais the identifier of the current activation record which is about to be destroyed.
note that each unique value of aappears in exactly one call and one return event in the program execution.
the execution of an instrumented program generates a trace of events.
we identify the execution of a function started by the event c all angbracketleft lscript f a angbracketrightby the activation record identifier a. for a function execution denoted by a we use trace a to denote the sequence of events generated by the function execution including the call and return events that start and end the execution of the function respectively.
if a function f prime is invoked during the execution of a function fwith activation recorda and if this invocation creates an activation record a prime then trace a prime is a subsequence of trace a .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. read traces and read footprints to compute the read footprint of a function execution we need to determine the set of memory locations that are read before being written during the execution.
we define the readtrace of a function execution a denoted by rtrace a as the largest set of events eisuch that ei read angbracketleft obj fld angbracketright ei trace a j ej write angbracketleft obj fld angbracketright trace a j i the third condition ensures that if there is a write to the memory location obj fld in the trace then it must occur afterei.
then the read footprint of a function execution a denoted by fp a is computed as fp a obj fld val read angbracketleft obj fld val angbracketright rtrace a c. traversing functions we can now provide a formal definition of traversing functions in terms of read footprints.
let fxdenote the execution of a function fwith input x wherexrepresents the state of the entire program memory before such an execution including the state of any arguments passed to fas parameters.
definition .
a function fis a traversing function if and only if the following condition holds x1 fx1halts x2 fp fx2 fp fx1 determining if an arbitrary function is a traversing function is undecidable in general.
we therefore detect potential traversals using the method described in section ii.
d. detecting traversals for every function execution aand for each event ein trace a we compute the execution context of ewith respect toa denoted by ec a e as follows ifeis the first event of trace a and is of the form call angbracketleft lscript f a angbracketright then ec a e epsilon1 i.e.
the empty sequence.
ifeis not the first event of trace a and is generated at program location lscript and if the latest call event beforeewithout a matching return event before eis e prime call angbracketleft lscript prime f prime a prime angbracketright then ec a e ec a e prime .
f prime lscript wheres.
f lscript is the sequence obtained by appending the pair f lscript to the sequence s. this is a formal version of definition given in section ii b. once we have computed the execution context of an event with respect to a function execution we determine its acyclic execution context as per definition .
let us denote the acyclic execution context of an event ewith respect to a function execution aby aec a e .
next we define a reachability relationa squiggleright between objects accessed in function execution a such that o1a squigglerightonholds if and only if there exists a sequence o1 f1 o2 o2 f2 o3 ... on fn val such that each element of the sequence is in the read footprint fp a .
this relation is reflexive and transitive.we can now formalize the conditions we check to detect if an execution aof function fcontains a traversal if there exist two input read events ei read angbracketleft lscript obji fldi vali angbracketrightand ej read angbracketleft lscript objj fldj valj angbracketrightsuch that ei ej rtrace a obji fldi negationslash objj fldj aec a ei aec a ej objia squigglerightobjjorobjja squigglerightobji then we mark the function fas a traversing function and the aec as a traversal point.
there may be more than one acyclic execution context marked as a traversal point for a functionfacross one or more of the function s executions.
iv .
a pplica tions a. access graphs for visualization tra violi can discover traversal points in functions that traverse input data structures.
in order to identify the data structure being traversed and to visualize the traversal across one or more aecs we develop the concept of access paths and access graphs.
a memory location in a read footprint which we call an input memory location can be reached from a program variable via a series of one or more fields or array indices called anaccess path.
an access path in a function execution is a finite non empty sequence of the form v.k1.k2 kn where n vis a variable name and each kiis either a field name or an array index.
access paths are defined recursively as follows the access path vrepresents the value of the variable vbefore the function execution starts and the access path .k represents the value stored in the field or array index k of the object whose access path is .
for example the set of input memory locations read by the function third in figure can be represented by the access paths list list.next list.next.next and list.next.next.data .
more than one access path may refer to the same memory location.
since traversing functions have read footprints that are unbounded we found it useful to represent the unbounded set of access paths involved in a data structure traversal using a finite graph called an access graph .
figure lists access graphs for various examples used in this paper.
in an access graph nodes represent a set of values which may be scalars or object addresses.
there are two types of nodes variable nodes and aec nodes.
a variable node with label vrepresents the value stored in variable vat the beginning of the function execution.
an aec node with label represents the values read by an input read event at aec .
there is an edge with labelkfrom any node nto an aec node if the field kof an object denoted by the n node is read in an input read event at the aec .
if more than one field of objects represented by node nare read at the aec then the edge from the nnode to the node is labeled with .
this happens when multiple elements of an array or multiple fields of an object are read at the aec .
according to this definition variable nodes do not have incoming edges.
moreover all aec nodes are reachable from at least one variable node.
an aec node is colored grey if the corresponding aec is a traversal point.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a access graph for third list third n next third n next third data b access graph for contains x contains listnext contains datanext data c access graph for alt obj alt items alt p q n next alt p datanext data d access graph for len list len nextnext e access graph for addpair arr addpair addpair addpair val addpair val f access graph for sum arr sum sum val fig.
.
access graphs for various examples presented in the paper.
an access graph concisely captures the access paths of all input memory locations read at each aec.
in particular a path in the graph from a variable node vto an aec node corresponds to an access path that begins with vand is followed by the sequence of edge labels along the path in the access graph.
for example in fig.
8a the access path of an input memory location read at aec third islist.next.next.data .
in fig.
8b the access graph contains a cycle.
therefore the access paths of the input memory locations read at aec contains are list.data list.next.data list.next.next.data and so on.
in this manner an access graph provides a bounded representation of an unbounded number of access paths.
figures 8b 8c and 8d represent access graphs of three functions that traverse linked lists in different ways but the access graphs provide similar abstractions because in each case the input lists are traversed via the next field at a single aec.
figures 8e and 8f depict access graphs for functions that read array elements.
in addpair array elements are read at two distinct aecs therefore the graph contains two branches starting from arr.
on the other hand sum traverses the array and this is captured by the wild card that labels the edge from arr to the aec sum .
the access paths that reach this aec are arr.
which indicate that more than one field or in this case more than one array index of the variable arr is read at the aec sum .
similarly the access paths that are read at aec sum are arr.
.val which represent the val fields of the elements contained in the array arr.we can use access graphs to determine access paths that identify the data structure being traversed.
we call such an access path the root of the data structure.
the roots are determined by identifying the shortest access path corresponding to access graph nodes nsuch that there is an edge from nto a grey node and there is no grey node along the path .
for example the root of the data structure traversed in fig.
8b is simply list while in fig.
8c the data structure being traversed is obj.items .
b. performance test generation large software projects such as the chrome browser use sophisticated frameworks to continuously perform performance regression testing where the application is benchmarked at different versions in the development history performance bugs are discovered by identifying code changes that cause statistically significant deviations in the measurements.
unfortunately performance regression testing is not as widely used as functional testing.
while there exist several code coverage tools for measuring completeness of functional tests there is a lack of tool support to identify code modules that should be the focus of performance tests.
previous research suggests that hard to detect performance bugs are often exposed when applications are executed with large scale inputs and or with special input values .
our technique can be used to identify the former case.
if functional unit tests for an application are available we can use tra violi to find functions that traverse input data structures and assist developers in constructing performance unit tests that force long traversals of the input data structures.
we next illustrate the process of creating a performance unit test from a functional unit test using t ra violi .
consider the function alt in fig.
and a unit test in fig.
.
the unit test alttest first invokes the function makerange at lines and to create sample objects containing lists with the first few natural numbers.
lines and contain calls to alt and assertions to ensure that the result matches the expected total.
if this unit test is provided to t ra violi the following report is generated data structure obj.
items in function alt traversal point alt p q n absolute aecs for traversal events .
alttest alt p q n .
alttest alt p q n values last writ ten at these a bsolute aecs .
alttest makerange .
alttest makerange traversal point alt p ... trimmed ... tra violi detects two traversal points for the data structure obj.items in the function alt corresponding to the programlocations that access node.next and node.data .
note that the traversals are identified when analyzing the executions of the function alt and not alttest as the linked list is not an external input to the latter therefore the aecs identifying the traversal point are with respect to the execution of alt.
tra violi collects and reports three types of information for each traversal point in function f. first a traversal point authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
creates a linked list with numbers ..n function makerange n var node rangelist null for var i n i i node data i next rangelist rangelist node return rangelist test the alt function function alttest var o1 items makerange var o2 items makerange assert alt o1 assert alt o2 fig.
.
unit test for the alt function from fig.
.
execute alt over a large linked list.
2var benchmark new benchmark.suite 3var bigobj items makerange 4benchmark.add alt perf function return alt bigobj .run fig.
.
performance test for the alt function from fig.
.
counter keeps track of the maximum number of times fhas executed .
in our example the longest traversal corresponds to the second invocation of alt where the traversal point alt p q n is observed six times therefore the report annotates this aec with .
second every event eis associated with an absolute aec which is equivalent to an aec with respect to a top level entry function such as main in some languages or a configurable harness function from the test framework.
these aecs are listed under the header absolute aecs for traversal events in the report the example shown above lists aecs with respect to the harness alttest .
this information aids in determining how traversing functions are invoked by client code or test cases.
third for all input memory locations m read at an event e we associate an event e primeat which mwas last written to before e. when reporting traversals t ra violi lists the absolute aecs of such write events for memorylocations involved in traversals under the header values last written at .
in example shown above the memorylocations read at the first traversal point are the next fields of the linked list nodes therefore the report lists the two distinct absolute aecs by which these fields were populated before the traversal.
this information aids in identifying the point of construction or last modification of elements of a data structure that is subsequently traversed.
in general the relationship between reads and writes in a traversal is many to many datastructure elements that were last modified at distinct locations may be traversed at the same absolute aec while a datastructure whose elements are populated at a single absolute aec may be subsequently traversed at multiple aecs.
in our experiments we found that this report provided useful information to track where and how data structures were constructed and provided as inputs to traversing functions.
if the goal of a developer is to write a performance unit test exercising a traversal point they can use this information to write a test that will increase the value of the traversal does list contain everything in arr ?
2function containsall list arr for var i i arr.length i var item arr if contains list item false return false return true fig.
.
a function that redundantly traverses a list.
point counter by several orders of magnitude.
fig.
shows a sample performance test for the running example using the benchmark.js api .
to verify that this test does indeed have a large read footprint we can run it through tra violi to generate a report that will annotate the aec alt p q n with .
c. detecting redundant traversal bugs tra violi can also be used to detect redundant traversals such as the traversal in the function containsall shown in figure .
the function containsall takes as input a linked list list and an array arr and returns true if an only if all items in the array are also present in the list by repeatedly invoking the contains function defined in figure .
the list is traversed multiple times without any change to its data this is a case of redundant traversal.
if the list contains nelements and the array is of length m then the worst case complexity of containsall iso mn .
such instances are often indicative of performance bugs and can be fixed by using different data structures such as hashed sets or caching.
t ra violi found two such instances in popular javascript projects which were acknowledged by their developers as performance issues.
in order to determine if a traversal in a function is redundant we need to analyze the sequence of concrete memory locations i.e.
actual memory addresses read at a traversal point of the function.
if the sequence contains repeated contiguous subsequences then we know that the memory locations in these contiguous subsequences are traversed repeatedly.
we then say the function has a redundant traversal.
formally if the sequence of memory locations read at a traversal point can be partitioned into the contiguous subsequences 1 2 ... k wherek 2and for each i j k either iis a prefix of jor jis a prefix of i then the sequence of memorylocations indicate a possibly redundant traversal.
for example if a bandcare concrete memory locations then the sequence of reads abcaba can be partitioned into repeating contiguous subsequences abc ab a indicating redundant traversals.
on the other hand the sequence abcacab is partitioned as abc ac ab and does not indicate a redundant traversal because acis not a prefix of aband vice versa.
consider the execution of containsall on an input linked list list containing the elements and an array arr containing .
the report generated by t ra violi when analyzing this execution indicates the presence of a potentially redundant traversal and includes the lengths of the repeating subsequences observed at the aec corresponding to the redundant traversal as follows authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
data structure list in function containsall traversal point containsall contains redundant subsequences absolute aecs for traversal events ... trimmed ... in general a redundant traversal can be detected by a memory location sequence as short as aba oraab therefore tra violi can detect redundant traversals from functional unit tests alone.
moreover t ra violi can detect redundant traversals in functions that use recursion such as the example in figure which could not be detected using previous approaches .
v. e v alua tion we have implemented t ra violi using the jalangi framework for instrumenting javascript programs.
we evaluate tra violi on a set of five open source javascript projects.
the projects were chosen because they are widely used they have comprehensive unit tests that can be launched from commandline using node.js and they represent a variety of scenarios where data structure performance may be important.
the projects include d3 collection a data structure library used in the popular d3 visualization toolkit immutable js an immutable data structure library developed by facebook d3 hierarchy which provides algorithms for visualizing hierarchical data sets express a server side web framework and mathjs an extensive math library.
we analyze the matrix module of mathjs .
the source code of t ra violi has been made publicly available at along with the scripts to reproduce the experiments described in this section.
table ii provides an overview of experiments performed on a macbook pro with an intel core i7 4770hq processor and 16gb ram running os x .
and node.js v4.
.
.
all listed run times are in seconds.
column lists the candidate projects column lists the number of unit tests in their test suites column reports the running time of the corresponding test suites and column reports the running time of the instrumented test suites including the time to instrument the source files project dependencies and the time to generate events.
column lists the number of events that are generated and subsequently analyzed.
columns report the time required to analyze these events the number of function executions analyzed for traversals and the number of unique functions for which access graphs are generated.
although we compute the read trace for all function executions we exclude analysis of functions from the project s dependencies or test suites.
columns report the results of traversal detection the number of traversing functions the number of distinct access paths identified as roots of data structures cf.
section iv a and the number of distinct aecs marked as traversal points.
columns repeat this information for redundant traversals cf.
section iv c .
for each candidate project the instrumented tests as well as the analysis of traces completed within few minutes.
we evaluate the quality of the traversals reported by answering four research questions rq1.
do the traversals reported by tra violi contain false positives?
rq2.
can we generate performance tests for the traversals reported by tra violi ?
rq3.
do the redundant traversals reported by tra violi contain false positives?
rq4.
do the redundant traversals reported by tra violi correspond to performance issues?
methodology we answer rq1 and rq2 by manually evaluating a subset of the traversals reported by t ra violi .f o r each candidate project we randomly sample up to access paths reported as roots of data structures being traversed and randomly pick one reported traversal point for each access path.
if a reported traversal point does not correspond to a traversing function within the library we classify it as a false positive .
in all other cases the traversal point lies within a traversing function as per definition and is thus a true positive.
we attempt to generate performance tests for these functions such that the counter of the aec corresponding to the traversal point increases by a factor of see section iv b .
however this is sometimes not possible.
a traversing function may be private to the library to which it belongs and this library may use domain specific constraints to ensure that the function receives inputs of only a bounded size.
we classify such cases as restricted traversals.
in such instances we cannot write a performance test using only the external public api and indeed this is acceptable since single restricted traversals cannot become a performance bottleneck.
similarly we answer rq3 and rq4 by manually evaluating a random subset of the traversal points that are reported asredundant .
if the reported traversal point was not really redundant we mark it as a false positive .
if the traversal was redundant but the input was bounded in size we mark it as a restricted traversal.
we classify the remaining cases as either bugs when the implementation performs more work than an optimal algorithm or necessary redundancies when the optimal algorithm necessarily requires repeated traversals of a data structure e.g.
matrix multiplication .
rq1 of the traversal points that were randomly sampled across all candidate projects we found only two false positives one in immutable js and another in express .
inimmutable js an array data structure was incorrectly reported to be traversed.
the false positive resulted from a related traversal of a hash map that mapped strings to integer values the resulting integers were used as indices to access a single element of different arrays.
the array accesses occurred within the same loop that traversed the hash map and in at least two iterations a common array was accessed at the same aec therefore the conditions that t ra violi checks for detecting traversals were satisfied.
in express one traversal point was in the test suite itself in a function that was supplied as a callback parameter to express .
since the traversal was not really part of express we marked this as a false positive.
rq2 of the true traversals in our sample we found three instances of restricted traversals all three belonged toimmutable js .
the corresponding traversing functions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
applicationtest suite instrumented tests analysis all traversals redundant traversals test casesrun.
timerun.
timeevents loggedrun.
timefunction invocationsunique func.unique func.unique rootsunique aecsunique func.unique rootsunique aecs d3 collection .
.
.
immutable js .
.
.
d3 hierarchy .
.
.
mathjs matrix .
.
.
express .
.
.
table ii overview of experiments conducted to ev alua te tra violi .a ll times are in seconds .
application false positivesrestricted traversalsperf.
tests generatedtotal d3 collection immutable js d3 hierarchy mathjs matrix express total table iii ev alua tion of sampled tra versal points .
application false positivesrestricted traversalsnecessary redundanciesperf.
bugstotal d3 collection immutable js d3 hierarchy mathjs matrix express total table iv ev alua tion of sampled redundant tra versal points .
perform traversals of input arrays.
however these functions are only used to traverse arrays contained in nodes of a bitpartitioned vector trie.
each node in such a trie can have up to a maximum of child nodes.
these child nodes are stored in an array whose traversal was reported by t ra violi .
the array traversal counter can never exceed .
we summarize the results of the evaluation of rq1 and rq2 in table iii.
the false positive rate in our evaluation was .
for the true positives we could construct performance tests in .
of the cases.
rq3 from the reported redundant traversals we sampled data structures and one corresponding traversal point from both immutablejs and mathjs .d3 hierarchy and express contained fewer than reports of redundant traversals and we analyzed all of those cases.
no redundant traversal was reported for d3 collection .
we manually analyzed a total of redundant traversals.
all false positives were in immutable js .
the sequence of memory locations read at the reported traversal points did contain repeated contiguous subsequences but this was specific to the particular inputs in the test suites.
the corresponding traversing functions do not perform redundant computations in general.
rq4 of the sampled redundant traversals that were true positives we found to be restricted traversals.
for example the implementation of maps in immutable js uses arraymap with linear time lookup only when the number of elements is less than for larger maps the implementation switches to using hash tables with constant time lookup.
in express one reported redundant traversal was restricted because thetraversing function can only ever be invoked internally with a list of http methods e.g.
get post of which only are supported therefore this function does not lead to performance issues.
in mathjs all reported redundant traversals belonged to algorithms that required repeated traversals such as matrix multiplication and thus were not classified as bugs.
two of the reported redundant traversals were real performance bugs they were confirmed by the developers.
in d3 hierarchy tra violi found a bug in the implementation of binary tree maps which are a visualization of hierarchical data as rectangles that are repeatedly partitioned into two sets.
the implementation partitions an array of numbers by computing an index such that the sums of the left and right sub arrays are approximately equal.
this process is recursively repeated for each partition resulting in a binary tree.
we detected from a simple unit test that the algorithm to find the index to partition the array performed redundant traversals at each step to compute the sums of the subarrays.
we were able to show that in the worst case the implementation had complexity o n2 .
we reported and fixed this bug see by computing the sums of all prefixes of the input array aheadof time and using a binary search to find the partition index at each step.
the fixed implementation is o nlogn in the worst case and provides about a speed up for a binary tree map with nodes.
the second bug was found in express .
when an express application is configured to support murl patterns with n handlers using a particular api the list of url patterns is redundantly traversed once per handler to construct a regular expression that combines all patterns.
as regex compilation is expensive this implementation may lead to longer start up times for some applications.
we reported this as a performance issue which was subsequently acknowledged by the developers see table iv summarizes the evaluation of redundant traversals.
.
of the reports were false positives.
.
of the true positives were restricted and .
were benign.
t ra violi found two real performance bugs that have been confirmed by the developers.
vi.
d iscussion human effort the performance tests for the traversals sampled in our experiments were manually constructed by one of the authors who required less than two hours per project i.e.
up to tests despite having no prior experience with the projects internal source code or external api.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
completeness tra violi uses dynamic analysis therefore it can only detect and report traversals if they occur during program execution.
we cannot precisely evaluate t ra violi for false negatives because it is not possible to statically determine all traversal points and it is not feasible to manually evaluate all candidate acyclic execution contexts.
our technique also does not consider write only traversals such as program functions that construct data structures from primitive values e.g.
parsing source code into an abstract syntax tree .
threats to validity due to the manual effort required we only evaluated a randomly sampled subset of the reported traversals the results are therefore subject to sampling error.
further our experiments indicate that the distribution of false positives restricted traversals and necessary redundancies is not uniform therefore our results may not generalize to project domains outside of those we considered for evaluation.
however we are encouraged by the fact that we could easily construct performance tests for arbitrary projects as well as discover asymptotic performance bugs in two of them.
vii.
r ela ted work redundant computation bugs clarity uses static analysis to detect program functions in which an o n traversal occurs o m times redundantly.
as our analysis is dynamic we can determine if repeated traversals are redundant at a finer granularity.
for example if a binary search tree is repeatedly queried for different values we do not report a redundancy if at least two traversals follow different paths in the tree.
clarity conservatively assumes all conditional branches to be equally likely and thus cannot make such fine grained distinctions automatically.
clarity therefore uses source level annotations to recognize operations on standard java collections that have sub linear average time complexity.
however clarity s static analysis is a sound over approximation while our dynamic analysis is subject to false negatives.
toddler uses dynamic analysis to detect similar memory access patterns at the same execution context.
it detects redundancies by analyzing the execution of long running performance tests and extracting similarities in memory accesses across loop iterations.
our use of aecs and object connectivity allow us to detect traversals from as little as two iterations and therefore we can detect redundant traversals using unit tests alone.
moreover acyclic execution contexts enable the detection of recursive data structure traversals which is not supported by either of these tools.
memoizeit uses dynamic analysis to detect functions whose computation can be memoized this includes a special case of redundant traversals where the repeating subsequences are exactly equal.
memoizeit can therefore detect the type of bug we found in express but not the bug we found in d3 hierarchy .
performance test generation speedgun generates performance regression tests for multi threaded programs to identify code changes that influence the amount of synchronization required.
perfplotter uses symbolic execution to generate distributions of a program s performance underdifferent inputs.
wise uses symbolic execution to automatically generate tests that exercise worst case behavior.
these techniques aim to automatically generate test programs or inputs that exercise special performance characteristics.
our goal is not to automate test generation but to identify program functions that traverse data structures and to aid developers in writing performance tests that exercise these traversals.
data structure analysis a number of techniques have been developed to analyze data structures using dynamic analysis.
heapviz summarizes relationships between java collections to provide a concise visualization of the heap.
mg generates representations of dynamically evolving data structures.
pheng and v erbrugge measure the number of data structures created and modified over time in java programs.
laika detects data structures in executing binaries using bayesian unsupervised learning.
dsi identifies pointer based data structures in c programs.
raman and august detect recursive data structures and profile structural modifications in order to measure their stability.
similarly several static analysis techniques aim to discover abstract representations of data structures used in a program and this body of work usually falls into the category of shape analysis .
sophisticated frameworks can be used to prove complex data structure invariants .
in all these techniques the central theme has been identifying the type of data structures or their representation in program memory and not on identifying functions that traverse these data structures to perform work.
execution contexts and aecs in dynamic analysis execution indexing allows uniquely identifying a point in a program execution.
such execution indices are too finegrained for t ra violi .
the problem of reasoning about an unbounded number of calling contexts in recursive programs is well known in the field of static analysis .
our approach of constructing aecs by removing cycles in execution contexts is similar to the approach employed by whaley and lam for context sensitive pointer analysis where connected components in the call graph are collapsed to a single node.
a subtle difference is that we retain the sequence of functions on paths from the entry of a connected component to its exit therefore the resulting aec is a valid sequence of call sites that can be used for stack trace debugging.
access graphs access graphs were first used in a static liveness analysis to represent an unbounded set of heapmemory locations that may be live at a program point.
our access graphs are similar in that a node can represent a regular pattern of access paths.
however we distinguish nodes based on aecs rather than program locations as in the original formulation therefore our access graphs are context sensitive.
acknowledgment we would like to thank caroline lemieux for her valuable comments on the paper.
this research is supported in part by an okawa foundation research grant and nsf grants ccf1409872 and ccf .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.