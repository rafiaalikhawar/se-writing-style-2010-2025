symbolic execution of programs with heap inputs pietro braione giovanni denaro mauro pezz university of milano bicocca universit della svizzera italiana usi viale sarca via giuseppe buffi milano italy lugano switzerland braione denaro disco.unimib.it pezzem usi.ch abstract symbolic analysis is a core component of many automatic testgenerationandprogramverificationapproaches.
toverify complex software systems test and analysis techniques shall deal with the many aspects of the target systems at different granularity levels.
in particular testing software programs that make extensive use of heap data structures at unit and integration levels requires generating suitable input data structures in the heap.
this is a main challenge for symbolic testing and analysis techniques that work well when dealing with numeric inputs but do not satisfactorily cope with heap data structures yet.
in this paper we propose a language hex to specify invariants of partially initialized data structures and a decision procedure that supports the incremental evaluation of structural properties in hex.
used in combination with the symbolic execution of heap manipulating programs hex prevents the exploration of invalid states thus improving the efficiency of program testing and analysis and avoiding false alarms that negatively impact on verification activities .
the experimental data confirm that hex is an effective and efficient solution to the problem of testing and analyzing heap manipulating programs and outperforms the alternative approaches that have been proposed so far.
categories and subject descriptors d. .
testing and debugging symbolic execution keywords symbolic execution lazy initialization data structure invariants .
introduction many approaches for automatic test case generation and program verification exploit symbolic execution which consists of executing a program with symbolic values to com pute the execution conditions of program paths path conditions .
path conditions are used to both generate test cases that execute the specific paths and verify programs against code assertions on those paths.
symbolic execution handles well programs with numeric input values like integers and reals but does not cope well with heap data structures thus limiting the efficacy of program testing and verification approaches.
many popular embodiments of symbolic execution can analyze complete programs with numeric inputs but experience limitations when testing software programs that make extensive use of heap data structures at the unit integration and subsystem levels .
for example intra and interclass object oriented testing challenges symbolic execution with objects that depend on parameters and state variables of structured data types in the heap.
the few attempts to extend symbolic execution to analyze object oriented programs deal with dynamic heap structures by enriching the path conditions with assumptions on the objects in the initial heap.
such assumptions identify the heap configurations that determine the execution of the different paths .
for example when analyzing a program that accesses the first node of an input list symbolic execution distinguishes the case of an empty list which causes an exception from the case of a non empty list which results in accessing the first item of the list.
the mainstream approach referred to as lazy initialization consists in the brute force enumeration of all heap objects that can bind to the structured inputs accessed by the program for example either the empty or the non empty list.
when symbolic execution accesses for the first time a reference to an input object it systematically enumerates all the possibl e input objects that can bind to that reference and identifies an alternative path condition for each binding.
the brute force enumeration of the input objects may identify many invalid heap configurations that violate properties of the data structures in the heap.
possible properties include data type invariants class contracts implicit program assumptions and method preconditions.
symbolic execution approaches that overlook the structural properties can engage in the extensive exploration of invalid program executions that depend on inputs that contradict the properties thus diverging and raising false alarms.
for example let us consider the class nodetraversal of the google closure compiler1that takes as input a parse tree encoded as an object of type node.
objects of type noderefer to a linked list of children nodes which can to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c circlecopyrt2015 acm.
... .
602recursively refer to other generations of nodes.
the software system maintains the implicit property that the nodes of any parse tree form indeed a tree shaped data structure.
symbolically executing class nodetraversal with the lazy initialization approach enumerates many non tree shaped parse trees thus leading to exploring several invalid program traces rooted in the symbolic states that include these invalid parse trees.
the enormous amount of invalid traces mayexceedbyordersofmagnitudethenumberofvalidones and thus analyzing the invalid traces wastes most of the verification budget.
for example symbolically executing to generate test cases class nodetraversal with lazy initialization and a time budget of hours led to the exploration of millions of invalid traces that is invocations of the cla ss with invalid inputs without producing any valid test case we report more details in section .
with reference to the buggy version of class nodetraversal reported by just et al.
in the invalid traces led to many false alarms that is invalid tests cases that incorrectly reveal the bug.
the readers should notice that we refer to unit testing where the input values are not filtered by the compiler api.
system testing exercises the compiler apis that builds only valid parse trees but it is infeasible to build a symbolic unit test generator that affords the cost of symbolically analyzing all the compiler software to generate test cases for a single class.
the problem of representing and reasoning about heap data structures with rich structural constraints is widely studied in the context of logic based automated verification of heap manipulating programs .
the different proposals compete on their ability to handle specific kinds of data structures for instance lists or trees.
conversely the symbolic execution community has payed little attention to this problem so far.
there exist only few preliminary proposals to reason about the properties of heap data structures in the context of symbolic execution .
these approaches either re evaluate the consistency of the whole heap structure after every new assumption or enumerate in advance the sets of valid structures.
the experimental data reported in section indicate that none of the existing approaches provides a satisfactory solution to the problem.
inthispaper wepresentanovelapproachforsymbolically executing programs that take as input both numeric values and heap data structures and require rich representation constraints over these inputs.
we thus provide a new tool to effectively generate test cases and verify software programs by means of symbolic execution.
the core of the approach is a language and a corresponding decision procedure jointly referred to as heap exploration logic hex .
the language specifies the properties of the data structures as structural constraints in a way that enables to check the constraints against the incremental assumptions on the input objects that emerge during symbolic execution.
symbolic execution augmented with hex evaluates the constraints incrementally as the heap is progressively refined by symbolic execution with advantages on both precision and scalability.
this radically differs from previous approaches.
we evaluated hex in terms of both analysis speedup and effectiveness in supporting the automatic generation of test cases for software programs and compared the results with competing approaches based on structural properties encoded as executable methods of the data structures and based on bounded unbounded heap reach ability provers .
we estimated the relative analysis speedup referring to a set of recursive data structures lists trees etc.
to investigate the different aspects of the application domains in breath.
we evaluated the effectiveness of test case generation referring to a set of third party java components with structured input data to gain empirical evidence of the applicability of the approach in practical software engineering contexts.
in previous work we introduced lics a framework that allowed us to experiment the preliminary ideas on a case study .
in this paper we explicitly introduce and define hex and present an extensive evaluation which indicates that hex improves on the state of the art approaches.
the new results provide evidence that hex outperforms previous approaches along different dimensions of precision and performance.
the paper is organized as follows.
section overviews lazy initialization to make the paper self contained.
section presents hex and the decision procedure based on hex that we propose in this paper.
section presents the techniques considered in the experiment.
section discusses the results and the empirical comparison of the different approaches.
section surveys the related work and section summarizesthemaincontributionofthepaperandindicates future research directions.
.
lazy initialization symbolic execution supports test case generation and program analysis by identifying the execution conditions of the paths that we want to cover in testing and verify in analysis.
the execution conditions also known as path conditions are symbolic expressions where symbols represent the input values.
when dealing with programs that refer to heap data structures like the getlist program in figure that we use as working example in the paper symbols may represent structured objects for instance a list that contains a given number of generic objects.
current symbolic executors handle accesses to heap data structures by means of a technique commonly referred to as lazy initialization .
lazy initialization enumerates all the different structures of the heap objects that can bind to the