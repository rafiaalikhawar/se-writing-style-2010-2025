see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation testing multithreaded programs via thread speed control conf erence paper oct ober .
.
citations 17reads author s including yanyan jiang nanjing univ ersity publica tions citations see profile chang x u nanjing univ ersity publica tions citations see profile xiao xing ma nanjing univ ersity publica tions citations see profile jian l u sichuan univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y chang x u on july .
the user has r equest ed enhanc ement of the do wnlo aded file.testing multithreaded programs via thread speed control dongjie chen state key lab for novel software technology nanjing university nanjing china midwinter1993 gmail.comyanyan jiang state key lab for novel software technology nanjing university nanjing china jyy nju.edu.cnchang xu state key lab for novel software technology nanjing university nanjing china changxu nju.edu.cn xiaoxing ma state key lab for novel software technology nanjing university nanjing china xxm nju.edu.cnjian lu state key lab for novel software technology nanjing university nanjing china lj nju.edu.cn abstract a multithreaded program s interleaving space is discrete and astronomically large making effectively sampling thread schedules for manifesting concurrency bugs a challenging task.
observing that concurrency bugs can be manifested by adjusting thread relative speeds this paper presents the new concept of speed space in which each vector denotes a family of thread schedules.
a multithreaded program s speed space is approximately continuous easy to sample and preserves certain categories of concurrency bugs.
we discuss the design implementation and evaluation of our speed controlled scheduler for exploring adversarial abnormal schedules.
the experimental results confirm that our technique is effective in sampling diverse schedules.
our implementation also found previously unknown concurrency bugs in real world multithreaded programs.
ccs concepts software and its engineering software testing and debugging keywords concurrency testing interleaving space sampling race detection acm reference format dongjie chen yanyan jiang chang xu xiaoxing ma and jian lu.
.
testing multithreaded programs via thread speed control.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
yanyan jiang jyy nju.edu.cn and chang xu changxu nju.edu.cn are the corresponding authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
introduction multithreaded programs are prevalent but also error prone.
concurrency bugs have caused serious real world consequences e.g.
the northeast blackout and mismatched nasdaq facebook share prices .
unlike sequential bugs the manifestation of concurrency bugs depends not only on inputs but also on thread schedules in an interleaving space which is exponential of a program s execution trace length.
this makes finding concurrency bugs difficult they usually can only be triggered by specific schedules with certain event orderings.
an exhaustive exploration of the interleaving space e.g.
by model checking to find buggy schedules is usually infeasible for large real world programs.
rather one often samples schedules randomly by heuristics or in a bounded interleaving space .
however these approaches waste resources in exercising many schedules with the same fixed event orderings leaving concurrency bugs undetected within limited testing budgets.
in this paper we present an alternative representation of the interleaving space named speed space which is approximately continuous easy to sample and preserves certain categories of concurrency bugs.
the speed space helps us exercise adversarial abnormal schedules more easily and develop effective testing techniques.
our testing technique based on a speed controlled scheduler is motivated by the following key observations events usually happen in a particular order under a native scheduler because threads run with almost the same execution speeds which by its nature leaves many concurrency bugs not manifested.
events leading to many concurrency bugs in real systems are coarsely interleaved .
therefore concurrency bugs can be manifested by a coarse grained scheduler.
interleaving space sampling and predictive analysis complement each other.
they can be combined to yield an effective testing technique for multithreaded programs.
the first observation suggests that to effectively sample schedules in an interleaving space event orderings enforced by a native scheduler should be intentionally reversed.
this is achieved by projecting the discrete interleaving space with loss to an approximately continuous speed space in figure 1b in which each vectoresec fse november lake buena vista fl usa d. chen y. jiang c. xu x. ma and j. lu ...t1 .
.
.t1 .
.
.t2 .
.
.t3t2 ...t3 a interleaving space t1t2t3 b speed space t1t2t3 c sample schedules systematically t1t2t3 d extend with trace based analysis figure testing multithreaded programs via thread speed control an overview.
denotes a set of schedules whose threads run in certain relative speeds.
this projection not only reduces the space but also makes sampling adversarial abnormal schedules easier in figure 1c .
the second observation also known as the coarse interleaving hypothesis implies that the projected speed space can be sampled in a coarse grained level for manifesting concurrency bugs.
we found that the speed space can be further reduced by only considering function call schedules instead of read write event schedules while still being capable of manifesting concurrency bugs.
the final observation indicates that the bug finding capability of interleaving space sampling can be further enhanced by applying predictive analyses in figure 1d .
a predictive analysis explores a larger set of schedules usually defined by a causal model in the interleaving space given a seed schedule.
feeding such an analysis with diverse seeds sampled schedules in the interleaving space helped us reveal long time hidden concurrency bugs in realworld programs.
in summary we test a multithreaded program by sampling in its reduced speed space and applying a predictive analysis in figure .
these ideas are implemented as a prototype tool schnauzer built upon llvm .
the experiments show that our sampling technique manifested schedules with more happens before races in most benchmarks varying from to172 .schnauzer also found previously unknown concurrency bugs in cherokee web server and transmission client .
the contributions of this paper are listed as follows we introduced the speed space an alternative reduced representation of a multithreaded program s interleaving space.
it is easier to reverse event orderings and sample schedules in this approximately continuous space.
we proposed an algorithm to systematically sample the speed space for diverse thread schedules.
we discovered that speed space sampling can be made more practical by leveraging the coarse interleaving hypothesis and predictive analyses.
we implemented the ideas as a prototype tool and evaluated it with previously unknown concurrency bugs found in real world open source multithreaded programs.
this paper is laid out as follows.
section introduces the background and motivation.
section defines the speed space and elaborates on how to sample schedules systematically in the speed space.section gives an overview of our prototype tool and implementation followed by the evaluation in section .
section describes related work and section concludes this paper.
background and motivation .
testing multithreaded programs concurrency bugs are notoriously hard to detect because they may only be triggered by specific schedules while the interleaving space of a multithreaded program contains an astronomical number of schedules.
ideally a multithreaded program should be exhaustively tested e.g.
using model checking techniques that enumerate all possible program states and schedules to find buggy schedules.
windowing techniques and bounding techniques are widely used to check a portion of schedules for making model checking more practically applicable.
the former attempts to divide the execution into a sequence of fixed size windows and perform analysis on each window separately whereas the latter bounds the state space to explore.
random testing techniques are also proposed tosample a small portion of schedules in the interleaving space.
for example pct probabilistic concurrency testing can detect concurrency bugs of bug depth d i.e.
the minimum number of specific event orderings sufficient to find the bug with probability at least nkd 1for a multithreaded program consisting of nthreads andkexecution steps.
.
motivating example consider a concurrency bug in the transmission client 1as illustrated in figure .
the operating system s native scheduler almost definitely schedules the request sent by the verify thread before the main thread because verifydone is usually invoked at the beginning of the execution while sessionclose is called at the end forming the event ordering in figure 2a.
in some occasions figure 2b which were previously unknown to the developers verifydone can be scheduled earlier than sessionclose yielding a use after free on tor.
to manifest this bug three event orderings are required the main thread must be scheduled to send requests the bug was previously unknown .
it was first found by the technique described in this paper.
2the visual convention is that a blue box denotes the thread name and a yellow box denotes an event.
events in a thread chronologically happen in the top down order.
a black arrow between events e1ande2denotes that e1happened before e2.testing multithreaded programs via thread speed control esec fse november lake buena vista fl usa main event verify async sessionclose eventclose session verifydone tor member ... sessionclose free tor async verifydone a typical event orderings under a native scheduler main event verify async sessionclose eventclose session sessionclose free tor verifydone tor member ...async verifydone b the buggy schedule with a use after free on tor figure the motivating example of a concurrency bug in transmission client earlier than the verify thread and the use after free must happen before eventclose otherwise the program will be terminated.
unfortunately state of the art testing techniques may be ineffective in detecting such complex concurrency bugs.
for pct the fact that the bug depth d 3implies that one expects to find the bug within seemingly promising o nk2 runs.
however since kis large for an execution trace in our experiment kis approximately two million it may need trillions of runs to strike the delicate prioritychanging points.
model checking also becomes intractable for these practical programs with long traces.
limiting the checked trace in a small window solves the tractability issue but still misses the bug because verifydone near the beginning of an execution and sessionclose near the end of an execution are distant in the trace under the native scheduler.
even worse since there is no data race in the schedule both the free and use operation happen in the same thread race directed techniques cannot capture the bug.
.
the need for an alternative representation of the interleaving space finding these buggy schedules in the huge interleaving space is a challenge.
the most straightforward approach to exploring the interleaving space is to traverse its state transition tree in which a node udenotes a program state and an edge u v indicates that vis the state obtained by a thread executing one step from u as shown figure 1a.
the state tree is the basis of many stateful or stateless model checking techniques .
on the other hand both pct and the delay bound scheduler ingeniously transform the state tree in which each node may have several children into a binary tree .
for most of the execution steps these two techniques simply let the current running thread proceed and perform context switches or preemptions at certain program points.
this transformation helps sample schedules in the interleaving space more easily a path trace can be encoded as a bit string and more effectively .
both techniques take samples in a small subspace in which the number of ones in the bit string is constrained.
such a small subspace denotes schedules consisting of just a few context switches and leverages the fact that many practical concurrency bugs can be manifested in such a condition.
realizing the power of interleaving space transformation one also raises a question can we transform the interleaving space toanapproximately continuous space that is even easier to effectively sample?
this paper gives a positive answer by trying to control each thread s execution speed .
in the motivating example if we slow down the verify thread themain thread will send sessionclose request later and then the event thread will reclaim memory in sessionclose .
furthermore if one lets the main thread run slower than the event thread it stands a good chance that the main thread will exit after the event thread.
at the moment the verifydone function is invoked the use after free bug is triggered.
this paper presents an approach to manifesting concurrency bugs by systematically sampling a hypercube figure 1b containing threads relative speed vectors.
defining and sampling the speed space .
notations and definitions a multithreaded program pconsists of a set of concurrent threads t t1 .
.
.
tn .
threads are executed by a schedulersby repeatedly choosing a thread to perform a series of thread local computations and an operation on a shared object a shared memory variable or a lock variable .
each operation on a shared object is associated with an event eof the following types read t x write t x for thread taccessing the shared memory variable x. lock t l unlock t l for thread tperforming a synchronization operation on the lock variable l fork t u join t u for thread tforking joining a thread u nop for nothing when thread tis blocked while being chosen to execute3.
we use e.op read write lock unlock fork join e.t t ande.xto denote the operation type the thread and the variable associated with an event e. chronologically concatenating all events in a program execution yields an execution trace a sequence of events e1 .
.
.em .
we denote events in that are performed by thread tas t and use i j ei ei .
.
.
ej to denote a substring of .
the schedule of a trace sched is defined as the sequence of thread identifiers in sched e1.t e2.t .
.
.
em.t .
3we introduce nop for an easier description of the semantics in a speed controlled scheduler.esec fse november lake buena vista fl usa d. chen y. jiang c. xu x. ma and j. lu the interleaving space of a multithreaded program is the set of all execution traces schedules.
for a program with nthreads andmevents to execute there are at most mnexecution traces i.e.
o mn .
we observed that concurrency bugs are triggered by particular event orderings however one usually has little knowledge of which events may relate to concurrency bugs.
furthermore given a prefix of an execution trace it is intractable to predict the subsequent events in .
these observations make sampling of challenging even if we have collected a set of traces in testing the criterion for guiding the selection of the next schedule is unclear and therefore existing techniques are mostly supported by heuristics .
we design our alternative representation of such that schedules are easy to generate while buggy schedules are still preserved.
.
the speed space the idea that concurrency bugs are triggered by specific event orderings inspired us to control the relative speed between threads to manifest them.
for a multithreaded program pofnthreads a speed vector denotes that thread tiis assigned with aspeed of i .
a speed vector represents schedules that pis executed by a speed controlled scheduler under which the relative speed between any pair of ti tj tis i jin a unit time interval an epoch .
for a sufficiently large epoch size l as the trace becomes longer we have lim l k k l ti k k l tj i j for any k l. thread speed control can be implemented by dividing the program execution into slices by measuring real time cpu cycles or lamport s logical clock .
a speed controlled scheduler enforces epoch based thread executions ti teither executes all operations in a slice or is blocked and executes nop events .
the ratio of slices received by tiandtjis roughly i jin an epoch a period of time .
the idea of slicing the program execution in an epoch is first used to make a multithreaded program deterministic aka.
deterministic multithreading in which slices are executed under deterministic rules .
the similar technique can be used to execute punder any given speed vector .
for example speed vector may result in schedules t1 t2 t1 t3 t3 or t1 t3 t2 t3 t1 .
both exactly match .
in practice t1 t2 may slightly differ from i j however as long as threads roughly run at their designated speeds the purpose of manifesting diverse thread schedules for testing multithreaded programs can be fulfilled.
we also explicitly require i 0because allowing i 0permanently blocks tiand leads to undefined ratios.
we use to represent an extreme value near i .
analogous to the interleaving space the speed space contains all possible speed vectors i.e.
n. the rationale of introducing the speed space is discussed as follows.
.
discussions the speed space an alternative representation of the interleaving space is an approximately continuous space thus is easy to sample in which each vector corresponds to a particular speed controlled thread scheduler andpreserves certain categories of concurrency bugs thus is useful in testing .
we discuss these features as follow.
.
.
an approximately continuous space.
as mentioned in section .
the interleaving space of a multithreaded program is usually represented by a tree a path from the root to a leaf denotes the schedule sched of a program execution .
as for the motivating example one thread in main event verify is chosen to execute for one step at each schedule point as shown in figure 1a.
this interleaving space is precise and complete contains all possible schedules but its discrete nature makes it difficult to sample.
on the other hand the speed space is much easier to sample one just picks up a value in the hypercube figure 1b of the speed space and executing punder with a speed controlled scheduler produces a trace .
various probability distributions can be easily defined over a hypercube compared with a discrete tree.
for example we can sample schedules where particular threads run excessively fast slowly to yield many extreme case schedules.
effectively sampling of the speed space for testing multithreaded programs is later discussed in section .
.
note that different execution traces 1 2 may correspond to the same speed vector as long as the threads run in a similar relative speed.
furthermore there may be which no speed vector could manifest.
this is intentional because we would like to constrain threads execution speeds at a coarse grained level each thread is controlled by a numeric value and the interleaving space is reduced for easier sampling.
.
.
speed vectors as schedulers.
a speed vector corresponds to ascheduler with particular speeds priorities assigned to threads for threads tiandtj they run approximately at a relative speed of i j. therefore the speed space defines a family of schedulers to manifest a diverse range of schedules.
many existing schedulers are related to speed vectors a native fair scheduler .
the native operating system s scheduler snfsattempts to guarantee the fairness between threads.
if not otherwise specified each thread executes for an equal amount of cpu time in an epoch.
snfsexecutes threads with the speed vector n .
.
.
n fornthreads.
the pct scheduler for concurrency bug manifestation .spct assigns each thread with a random priority and chooses a thread with the highest priority to execute.
at some priority changing points it changes an executing thread s priority to a lower value.
to state briefly spctexecutes threads with speed vector .
.
.
i .
.
.
initially and then changes it to .
.
.
concurrency bugs in the speed space.
the most important property of the speed space is that it guarantees to preserve many categories of concurrency bugs.
most non deadlock concurrency bugs in practice are either an atomicity violation in which two events that should happen atomically in a thread are interrupted or an order violation in which the orderings between two events executed by different threads aretesting multithreaded programs via thread speed control esec fse november lake buena vista fl usa t1 t2 t3 t4 figure a bug example consisting of an a b a atomicity violation pattern red and two event orderings blue .
this bug has a depth of d 4and is preserved in the speed space.
inversed .
an order violation can be manifested by specifying the speeds of two threads where one thread runs faster than the other.
an atomicity violation can also be manifested by setting correct speed vectors.
suppose that the atomicity of events aand bin thread timay be violated by another event cin thread tj.
to trigger the violation we should ensure that a i c j b i where eis the number of events performed in e.tbefore e. in other words if these two threads execution speeds satisfy a c i j b c the atomicity violation can be manifested.
an example of concurrency bug patterns being preserved in the speed space is shown in figure which resembles the event ordering in the previously unknown bug we found in the motivating example figure 2b .
such bugs can be easily manifested by speed controlled schedulers under correctly set speed vectors but are extremely difficult to be manifested by existing techniques.
more specifically the speed space can preserve a more general a b a atomicity violation case with a bug depth of d n where a thread pair perform three a b a events and each of the other threads enforces one additional event in a particular order.
therefore though the speed space is a lossy reduction of the interleaving space effectively sampling it has the potential of manifesting real world concurrency bugs .
.
systematic sampling of the speed space we propose an algorithm for sampling the speed space which is inspired by the idea of exponential backoff in computer networking one waits for .
.
.
2kunits of times before the next attempt to obtain the exclusive access of a contented resource.
similarly we systematically enumerate all thread pairs ti tj and try all possible backoffs between tiandtj as described in algorithm .
threads tiandtjare called the basis which are systematically controlled using the following speed vectors i k and j v k .
.
.
i 1and j v k .
.
.
.algorithm systematic speed control input program pand threads t var speed vector var v k .
.
.
speeds to assign 1for ti tj t tandi jdo for v1 v2 k vdo 3 random speed vector i j v1 v2 execute with speed t1t2t3 figure sampled speed vectors red marks under the basis of t1 t2 in the speed space .
the speed of t3is fixed to be 3 which is randomly chosen in the dashed blue line .
the speeds of other threads are set uniformly at random in .
in other words the speed value iis set to either maximum or minimum k while jenumerates all speed values of k. the speed space sampling algorithm is better geometrically explained in the hypercube of n fixing the basis tiandtj yields a sub cube of dimension n 2which is sampled uniformly at random.
considering a multithreaded program with t t1 t2 t3 and t1 t2 are set as the basis sampled points are shown in figure .
for points 1 2 are always on the boundary of the t1 t2plane and 3is sampled uniformly at random illustrated by the blue dashed segment in the figure .
in the more general case where the basis is not fixed all six surfaces of the cube are sampled in a similar way.
such a sampling algorithm enables us to exercise various kinds of corner case schedules resulting in the manifestation of concurrency bugs oftentimes missed in thread executions under a native scheduler snfsis just a single point in the diagonal line4.
on the other hand for each pair of basis threads ti tj a broad spectrum of i jare exercised k k .
.
.
.
.
.
2k plus other threads having a diverse range of running speeds.
we intentionally do not sample i j because it is the default behavior ofsnfs.
4all speed vectors in the form of are equivalent.
however algorithm never samples two equivalent speed vectors.esec fse november lake buena vista fl usa d. chen y. jiang c. xu x. ma and j. lu algorithm speed controlled scheduler input t set of total threads input speed vector var w waiting list var l number of total events to execute in an interval 1procedure execute with speed for each interval do parallel for ti tdo schedule i t w signal wake up all threads in w 7procedure schedule i i d ifd l ithen w w ti wait for signal else execute tifor one step schedule i s d schnauzer in this section we describe our prototype tool schnauzer5 which combines the speed controlled scheduler and trace based analysis to test multithreaded programs effectively.
schnauzer consists of three components a speed space sampling module a speed controlled scheduler for executing program pwith a speed vector to obtain an execution trace and a trace based analyzer for predicting bugs anomalies based on .
.
the speed controlled scheduler the speed controlled scheduler sscsis described in algorithm .
procedure execute with speed is called with speed vector to schedule threads in t. it divides a program s execution into intervals with a predefined length l which denotes the expected number of events to be executed in an interval.
in each interval the procedure schedule coordinates the execution of all threads.
schedule maintains d a thread local counter of the number of events that thave already executed in this interval.
when thread thas drained its quota d l t tis added to a waiting list denoted by w and is blocked until the next interval.
note that we execute a thread tregardless of whether it is blocked.
if tis blocked e.g.
waiting for a mutex lock or pending on a condition variable executing tyields an nop event.
since we require that i 0for all i i.e.
threads have positive speeds there must be at least one thread executing a non nop event in an interval i.e.
the process does not stall.
.
trace based analysis given an execution trace trace based analyses predict the existence of potential concurrency bug patterns in other execution traces.
for example data race6is one of the most common causes of real world 5available at 6two consecutive events e1ande2in where e1.x e2.xandwrite e1.op e2.op .concurrency bugs .
even if an execution trace does not have two consecutive racing events trace based analyses may predict the existence of such anomalies.
to predict data races in a multithreaded program one may use thehappens before relation hb .
two events ei hbejif either of the following conditions holds assuming that eiandejare the i th and j th events in respectively i jandei.t ej.t i.e.
eihappened before ejin the same thread i jandeiandejare synchronization operations performed on the same variable eiandejare transitively dependent using the above two rules.
a pair of events ei ej is a happens before race if ei.x ej.x ei.t ej.t at least one is a write and they are not ordered in hb.
happens before race detectors are often simple but limited due to their overly conservative hb relation construction which forms extra happens before relations.
causally precedes cp soundly relaxes the causal model in order to improve the detection power.
under the relaxed model it does not establish hb relations between critical sections that have no conflicting accesses.
predictive trace analysis pta soundly reorders events in an execution trace by smt satisfiability modulo theories solvers which can predict concurrency faults unseen in the input trace.
though both cp and pta can predict potential concurrent bugs in a family of schedules not only in the successful prediction of a particular concurrency bug pattern heavily depends on the quality of the input execution trace .
we found that our speedcontrolled scheduler which excels in exercising adversarial abnormal schedules is orthogonal to trace based analyses.
in this way we combine these two techniques we first sample a series of diverse thread schedules and then these schedules are further checked against concurrent bug patterns using a happens before race detector.
.
implementation we described in section that the speed controlled scheduler controls execution speeds of threads at a fine grained level it restricts the number of events a thread can execute in an interval.
in practice such a fine grained control incurs large and unnecessary overhead.
a recent research showed that most real world concurrency bugs can be manifested by a coarsely interleaved scheduler.
the coarse interleaving hypothesis motivated us to conduct speed control at a coarse grained level to reduce the overhead and diverse schedules can still be sampled.
therefore in our schnauzer implementation thread tireceives an upper limit on the number of function calls proportional to iin an interval.
we also found that a master worker pattern is widely used in real world programs where a main thread usually creates worker threads to perform similar tasks.
this observation implies that there is no need to exhaustively enumerate all thread pairs ti tj as basis in algorithm .
enumerating the basis in a small set of ts tconsisting of the master thread and a few workers suffices for effectively sampling of the interleaving space.
we implemented schnauzer on top of llvm .schnauzer instruments llvm ir instructions to trace read andwrite events testing multithreaded programs via thread speed control esec fse november lake buena vista fl usa table real world multithreaded programs with previously known bugs used in the evaluation.
program description loc thread aget file downloading 2k cherokee web server 80k httpd web server 290k mysql relational database 390k transmission bit torrent client 87k pbzip2 parallel compression 2k and inserts a callback to the schnauzer before each function is called for speed control.
this mechanism also produces a log of synchronization operations which is obtained by logging function calls into the pthread library.
a speed controller thread maintains the running status statistics and quota of each application thread including a dynamically created one .
hbdata races are detected by maintaining and comparing a pair of memory access events vector clocks.
evaluation the evaluation of our scs scheduler focuses on answering the following two research questions rq1 can scs sample diverse schedules of multithreaded programs in limited testing budgets?
rq2 isschnauzer effective in testing multithreaded programs?
both questions are difficult to answer directly.
therefore we take an indirect approach that adopts bug related quantitative metrics to compare scs with pct.
the first question is answered by using quantitative indicators of the testing thoroughness on a set of popular open source projects that are mature and widely deployed which have also been extensively tested and studied in the previous work whether previously known concurrency bugs can be successfully manifested the number of statement pairs s1 s2that are unordered by happens before hb if these known bugs are fixed.
the second question is answered by applying schnauzer both the speed controlled scheduler and a happens before race detector to the same set of programs to find whether it can reveal previously unknown concurrency bugs that require complex schedules to trigger.
.
experimental setup .
.
subjects.
the multithreaded programs used in the evaluation are shown in table .
we evaluated the scs scheduler on a set of real world multithreaded programs of varying complexity used by previous work .
each subject contains a known concurrency bug and a patch for fixing it.
.
.
quantitative measure of schedule diversity.
we use the number of happens before race statement s in the programs execution traces to reflect the degree of schedule diversity.
a pair of program statements s1 s2 is a happens before race in an execution trace if and only if there exist events e1 e2 such that table happens before races detected by scs and pct.
program data racesimprovementscs pct aget cherokee httpd mysql transmission pbzip2 e1ande2are produced by executing s1ands2 respectively.
e1 e2 is a happens before race both events accessed the same shared variable i.e.
e1.x e2.x at least one is a write i.e.
write e1.op e2.op and e1 hbe2 e2 hbe1 .
if a technique sampled more happens before race statement pairs s1 s2 we consider that the technique is more effective in generating diverse schedules.
this is because even if s1ands2 may simultaneously happen under a particular thread schedule these two statements may not even appear in other schedules or there may exist synchronization operations in between to make the events being ordered in hb.
intuitively closer the events produced bys1ands2are scheduled larger the chance they are forming a happens before race .
section .
presents more discussions on this quantitative measure.
.
.
experimental setup.
we compared scs with pct the state of the art interleaving space sampling technique with probability bug finding guarantee.
for each program we supplied it with a simple test input that simulates a daily use case of the program.
we used apache ab to send the same set of requests to httpd and cherokee both serving simple static contents aget and transmission downloaded an online file of 1gb size pbzip2 decompressed a file of 1m size mysql executed a script that drives two threads to simultaneously insert data into a table.
in the experiments we assume that all subject programs receive a similar amount of testing resource budgets.
therefore we choose ts tto be the main master thread and two worker threads therefore ts and exhaustively numerate all basis thread combinations in ts.
choosing a fixed set of tsis effective in testing because all evaluated programs follow the master worker concurrency pattern and an existing study shows that most concurrency bugs can be manifested within three threads.
the back off parameter is set to k 7for an approximately maximum speed difference in the speed controlled scheduler relative speeds range from 2to1 .
we limit kto a small constant because a relative speed is an exponential of k and a large kwould deprive a slow thread of being executed.
there are ts 2k distinct speed vectors sampled for each evaluated subject program and this value equals 42in our experimental setting.
for pct we set the bug depth d 3as recommended in the authors originalesec fse november lake buena vista fl usa d. chen y. jiang c. xu x. ma and j. lu .
.
scs pct0 .
.
scs pct a aget scs pct0 scs pct b cherokee scs pct0 scs pct c httpd scs pct0 scs pct d mysql scs pct0 scs pct e transmission scs pct0 scs pct f pbzip2 figure distinct race statement pairs found by scs and pct.
the left plot blue red of each subject displays the number of distinct race statement pairs in a round of program executions for scs executions are scheduled under different speed vectors for pct priority changes at random points .
the right plot green yellow of each subject displays the medium of cumulated distinct race statement pairs shaded area denoting the 25th 75th percentile.
paper and sample the same amount of schedules random runs for a fair comparison.
in answering rq1 we first run each subject program with a previously known concurrency bug and assertions to detect it under the sampled speed vectors to see if all concurrency bugs can be manifested.
then for the quantitative evaluation we patch all known concurrency bugs to avoid early program crashes and run both scs and pct to collect race statement pair statistics.
in answering rq2 we used the latest versions of the subject programs in which all known concurrency bugs were fixed and run each program under the sampled speed vectors.
we examinethe crash or data race reports to find if there is previously unknown bugs in the latest versions.
all experiments were conducted on a desktop with a quad core .40ghz intel core i7 processor and 16gb memory running ubuntu linux .
.
in answering rq1 both scs and pct were executed for10independent testing rounds and statistical data is collected.
in answering rq2 we only run each subject program once to simulate a typical in house testing scenario.
.
experimental results .
.
answering rq1 schedule diversity .
first all known concurrency bugs can be successfully manifested by scs assertions aretesting multithreaded programs via thread speed control esec fse november lake buena vista fl usa t1 t2 while x lock t1 l read t1 x unlock t1 l lock t2 l write t2 x unlock t2 l lock t2 l unlock t2 l figure a typical thread schedule found by a speedcontrolled scheduler but not by pct.
violated in running all subjects.
the overall quantitative experimental results are shown in table .
the number of distinct race statement pairs s1 s2 in all rounds found by scs and pct are displayed in columns and respectively.
summarizing the results scs found .
more pairs of unique race statements compared with pct.
excluding aget which adopts a trivial concurrency pattern therefore scs and pct found the same set of race statement pairs scs outperforms pct on cherokee mysql transmission and pbzip2 .
though it found less pairs than pct on httpd it still has a better overall result.
the detailed statistics of race statement pairs rses are shown in figure .
in each figure the horizontal axis denotes the number of program runs and the vertical axis denotes the number of distinct rses.
in each of the testing rounds traces 1 2 .
.
.
42are obtained.
the left sub figure blue red of each subject displays the number of distinct rses in a randomly chosen testing round of pct and scs in which a point i n denotes that a technique found ndistinct rses in i. the right sub figure green yellow of each subject displays the distribution of cumulated rses in which a point i n denotes that a technique found ndistinct rses in execution traces 1 2 .
.
.
i. the shaded area shows the 25th 75th percentile over the rounds of our experiment.
the right sub figures green yellow plots show that scs detected more data races for programs as the growth of sampled schedules except for aget and httpd.
aget is a small scale application with a simple concurrency pattern.
both scs and pct detected the same set of data races which we believe are all possible happensbefore races in the program.
for httpd though scs detected less rses the third quantile indicates that scs is capable of detecting almost the same data races as pct in many testing rounds.
for the remaining subjects scs has a better trend in detecting data races as more schedules are sampled particularly on cherokee mysql and transmission.
figure shows a typical schedule from pbzip2 sampled by scs but not by pct.
if one attempts to sample this schedule by pct one should first set t2with a higher priority otherwise t1will always spin on variable x. after t2writes x it must be changed to a lower priority thus letting t1exit the loop and acquire the lock l. however we see that the priority changing point for t2is delicate if the priority of t2is not changed immediately it will run main worker thd exit true while !thd ended free thd while !thd exit thd ended true use thd figure illustration of a previously unknown bug in the cherokee web server.
the event ordering in red triggers a concurrent use after free bug.
continuously resulting the hb edge represented by the red line.
scs can sample this schedule more easily if t1runs faster than t2 t2will write xwhen t1is spinning and then t1may acquire the lock earlier than t2because it runs faster.
.
.
answering rq2 testing effectiveness .
to our surprise applyingschnauzer to the latest versions of the subjects found previously unknown concurrency bugs schnauzer directly crashed the transmission client and found a rarely occurring race in cherokee web server.
in total we found three previously unknown bugs in the evaluated subjects and that all bugs were buried a long time before schnauzer revealed them.
for example in cherokee the bug was traced back to the .
version even before the project was migrated to github.
the two bugs in transmission including the motivating example are similar but in different components of the program.
the triggering of these two bugs are discussed in section .
the manifestation of the concurrency bug in cherokee is shown in figure .
under a typical native fair scheduler the main thread tends to wait for theworker thread to exit before the main thread reclaims memory resources.
however in rare cases an atomicity violation between line and line of the worker thread can be manifested resulting in a concurrent use after free bug.
we also proposed a fixing suggestion to its developers.
we believe that other concurrency testing work also extensively tested these subjects including transmission and cherokee under various settings.
however our speed controlled scheduler is the first to find the bugs.
therefore we believe that speed space sampling is promising in effectively testing real world multithreaded programs.
.
threats to validity a key external threat to validity is that data races may not reflect the diversity of a schedule.
furthermore a pair of racing events e1 e2 unordered in hbmay not imply that these two events could concurrently happen the soundness of a hbrace detector only holds for the first pair of unordered events as for all subsequent racing events may not even happen.
for instance in figure read t1 x and write t2 x are detected as a hbrace however these twoesec fse november lake buena vista fl usa d. chen y. jiang c. xu x. ma and j. lu statements could never be executed in parallel and thus is not a data race because t1spins on xin between.
nevertheless suppose that a pair of events e1 e2 unordered by hbcan be detected by scs but not pct it implies that either of the following two conditions holds e1ande2do not simultaneously occur in all execution traces sampled by pct or e1ande2are always ordered by hbin all execution traces sampled by pct.
in other words scs has found a particular schedule that both e1ande2are manifested and they are made closer and thus not ordered by hb .
consequently even if the race detector may not be sound we believe that the technique that can find more distinct race statements is more effective in sampling diverse schedules of multithreaded programs.
related work much prior work has focused on effectively exercising sampling buggy schedules in the interleaving space for testing a multithreaded program.
we categorize these techniques into model checking random sampling or heuristic sampling.
we also discuss trace based analyses in this section.
model checking .
the goal of model checking is to prove or disprove that all schedules in the interleaving space satisfy a certain correctness criterion.
model checking is intractable due to the exponential interleaving space and techniques have been proposed to soundly reduce the search space to be checked .
despite these efforts conducting full model checking on large real world multithreaded programs are still considered impractical.
therefore bounded model checking in which only a subset of the interleaving space is checked becomes a natural solution.
based on the fact that many concurrency bugs can be manifested by simple thread interleaving e.g.
by permuting a few events in a few threads delay bounding and preemption bounding strike a nice balance between resource cost and testing effectiveness.
the speed space presented in this paper is also a lossy reduction of the interleaving space.
compared with the reduced interleaving space of a delay bounded or preemption bounded scheduler the speed space is approximately continuous and thus is easier for us to sample.
in particular by sampling extremely valued vectors in the space adversarial abnormal schedules can be manifested by a speed controlled scheduler.
random sampling .
randomly manipulating thread schedule to sample the interleaving space for manifesting concurrency bugs is usually lightweight and applicable in practice.
random sampling techniques may insert random sleeps execution delays or thread suspensions at synchronization points or reverse thread priorities at random program points.
random samples may be effective in testing with probabilistic bug triggering guarantee .
however there may also be specific event orderings e.g.
the thread schedule to trigger the bug in figure whose manifestation is of an extremely low probability.
this is partly due to the discrete nature of the interleaving space and it is a challenge in designing probability distributions for effective sampling of schedules that may relate to concurrency bugs.the speed space offers new opportunities for designing effective random sampling techniques toward adversarial abnormal schedules.
our speed space sampling algorithm algorithm is based on the uniform distribution sampling in a hypercube.
heuristic sampling .
heuristics facilitate effective interleaving space sampling techniques.
concurrency coverage criteria concurrency bug patterns and commutativity of event orderings helped the sampler avoid wasting time manifesting schedules which are less likely to be buggy.
our speed space sampling algorithm also adopts heuristics to find adversarial abnormal schedules.
particularly we systematically exercise all thread basis pairs and uniformly sample schedules at random in the n 2dimension space for diverse schedules which attempts to avoid sampling similar schedules.
trace based analysis .
a trace based analysis takes an execution trace as its input and verifies a certain property against a family of schedulesf i.e.
checking if there is f such that holds.fis usually a causal model of events under a particular memory model while can be a detector of data races atomicity violations or other types of concurrency bugs .
interleaving space sampling algorithms e.g.
delay bounded sampling preemption bounded sampling and algorithm are orthogonal to trace based analyses.
a trace based analysis can successfully predict a concurrency bug only if bug related events are manifested and usually close enough in the execution trace.
effective sampling algorithms can help trace based analysis detect more subtle concurrency bugs.
conclusion this paper presents the definition sampling algorithm and application in data race detection of the speed space an alternative representation of a multithreaded program s interleaving space.
by systematically sampling speed vectors in the speed space and executing a multithreaded program under a speed controlled scheduler adversarial abnormal schedules can be manifested for detecting concurrency bugs.
the evaluation of our prototype schnauzer shows promising results in effective testing of multithreaded programs with previously unknown concurrency bugs in real world programs being detected.