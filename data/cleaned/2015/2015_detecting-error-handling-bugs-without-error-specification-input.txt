detecting error handling bugs without error specification input zhouyang jia shanshan li tingting yu xiangke liao j iw a n g xiaodong liu and yunhuai liu college of computer science national university of defense technology changsha china jiazhouyang shanshanli xkliao wj liuxiaodong nudt.edu.cn department of computer science university of kentucky lexington usa tyu cs.uky.edu big data research center peking university beijing china yunhuai.liu pku.edu.cn abstract most software systems frequently encounter errors when interacting with their environments.
when errors occur error handling code must execute flawlessly to facilitate system recovery.
implementing correct error handling is repetitive but non trivial and developers often inadvertently introduce bugs into error handling code.
existing tools require correct error specifications to detect error handling bugs.
manually generating error specifications is error prone and tedious while automatically mining error specifications is hard to achieve a satisfying accuracy.
in this paper we propose eh miner an o v e la n d practical tool that can automatically detect error handling bugs without the need for error specifications.
given a function eh miner mines its error handling rules when the function is frequently checked by an equivalent condition and handled by the same action.
we applied eh miner to applications across software domains.
eh miner mined error handling rules with the precision of .
and the recall of .
.
we reported bugs to developers and bugs had been confirmed and fixed at the time of writing.
we further applied eh miner to linux kernel and reported bugs for kernel .
of which had been confirmed or fixed.
index t erms error handling library function specification i. i ntroduction most software applications interact with their environments through libraries.
these libraries provide various application programming interface api functions for applications.
a reliable application must be designed to behave gracefully even under api function failure conditions such as network packet loss malformed input memory allocation failure etc.
when any error occurs the failing api function usually notifies its caller about the error after which the caller decides how the error should be handled.
incorrect handling of errors can lead to serious problems e.g.
system crashes or data loss and software developers often make mistakes and inadvertently introduce bugs into error handling code .
incorrect error handling had been identified as one of the top ten sources of security issues .
this work was supported in part by national key r d program of china no.
2017yfb1001802 nsfc no.
and nsf grant ccf1652149 and ccf high end generic chips and basic software under grants no.
2017zx01038104 china scholarship council.many researchers have proposed tools to detect errorhandling bugs.
some of them use static analysis to check whether failures are properly handled in error paths .
the process of these tools can be roughly split into two steps.
the first step is to manually input or mine error specifications that indicate whether or not an api function may fail and if so how the function communicates with its caller.
second they check whether or not the error is properly handled in the caller if not they report a bug.
on the other hand some tools use dynamic fault injection to check whether the program handles api failures correctly .
these works also require the error specifications as input initially.
they simulate api failures according to the error specifications and check the response of the program.
the bug detection abilities of both static and dynamic tools depend heavily on the accuracy of error specifications.
manually generating error specifications is error prone and tedious especially for low level languages such as c c .
c does not provide exception handling mechanisms while c contains far fewer try blocks than projects developed in the other languages .
to remedy this situation previous works tried to automate the process of error specification mining .
among these kang et al .
studied the characteristics of error paths and proposed apex which collects error paths and infers error specifications with precision of and recall of .
this precision is not accurate enough since inferring error specifications is only the first step to detect errorhandling bugs.
incorrect error specifications will negatively affect the following analysis.
acharya et al .
designed a tool that mines error specifications automatically.
this tool achieves precision but the recall is very limited it only mined error specifications of library functions from both posix and x11 libraries.
in light of the above we propose eh miner an o v e l and practical tool to automatically detect error handling bugs without the need for error specification input.
given an api function eh miner mines its error handling rules when the function is frequently checked by an equivalent condition and handled by the same action.
to achieve this we propose a potential error handling peh model which describes 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the potential error handling behaviors in programs.
in the peh model an error handling behavior contains three basic elements a library function call a check condition and a handling function call.
eh miner extracts peh instances from a code repository then normalizes these instances for ease of comparison.
finally eh miner mines error handling rules from the normalized instances.
taking chroot as an example developers frequently check whether or not the return value of chroot is if it is an error message is printed.
the existing tools need the knowledge that chroot returns on success and on error then check whether the error is well handled in the error path i.e.
the path after the branch condition that the return value is .
by contrast eh miner can mine the error handling rule that chroot should be logged when returning without inferring the semantics of .
in eh miner the rule is recorded as a peh instance chroot ... chroot ... log ... .
there are three advantages for mining error handling rules compared with mining error specifications in existing tools higher accuracy.
eh miner does not have to infer the semantics of api return values.
this feature enables ehminer to improve precision based on the state ofthe art tool.
better scalability.
eh miner uses light weighted constraint solving instead of heavy analysis such as symbolic execution.
the experiment shows that eh miner is about times faster than the state of the art tool.
easier to repair.
eh miner can obtain error handling actions besides error specifications which helps to repair the detected bugs.
with the assistance of this knowledge we manually generate and report patches.
to evaluate eh miner we select software domains that are widely used in the open source community and choose c c applications from these domains.
we first use the cross validation technique to tune the parameters in ehminer then evaluate the precision and recall under the optimal thresholds.
second we evaluate the effectiveness of eh miner for detecting real world bugs.
eh miner reports bugs and the precision is .
at the confidence level.
we report bugs and of them are confirmed by developers.
we further apply eh miner to linux kernel and report kernel bugs of which are confirmed.
finally we compare eh miner with the state of the art tools and find eh miner outperforms the existing tools in terms of precision recall and efficiency.
in summary the contributions of this paper are as follows we design and implement eh miner a tool that can automatically detect error handling bugs without error specification input.
we conduct an empirical study on check conditions and error handling actions which guide the design of eh miner .
ineh miner we propose several novel techniques including using the peh model to describe error handling behaviors converting the judgment of check condition equivalence into a satisfiability problem automatically example mysql .
.
sql mysqld.cc if chroot path sql print error chroot s strerror errno unireg abort mysqld abort exit example opensmtpd .
.2p1 smtpd ca.c if chroot path chroot fatal ca chroot example httpd .
.
modules arch unix mod unixd.c if chroot ap unixd config.chroot dir !
rv errno ap log error ... can t chroot to s ... return rv example postfix .
.
src util chroot uid.c if chroot root dir msg fatal chroot s m root dir example cherokee .
.
cherokee source interpreter.c re chroot src chroot.buf if re log error ... src chroot.buf exit fig.
.
error handling examples of chroot .
recognizing error handling actions and a two step mining method to mine error handling rules.
we apply eh miner to applications across software domains.
eh miner mines error handling rules with precision of .
and recall of .
.
we reported bugs and of them were confirmed by developers.
we further applied eh miner to linux kernel and reported kernel bugs of which were confirmed.
ii.
m otiv ation and definition in this section we present a real world example that motivated us to design and implement eh miner .
figure shows five different applications invoking the api function chroot .
according to the man page documentation for chroot w e know that upon successful completion a value of is returned otherwise a value of is returned.
guided by the man document all these five applications handle errors in a similar way checking whether the return value is and if so printing error messages.
to find error handling bugs of chroot the existing solutions first need to either input e.g.
errdoc epex or mine e.g.
apex lfi the error specification that means success and means error .
only after this is accomplished can they check whether the error is properly handled when is returned.
however manually inputting error specifications is tedious and sometimes even error prone for libraries with limited domain knowledge.
on the other hand mining error specifications automatically is hard to get a satisfying accuracy even in the state of the art tool.
in this paper we propose a novel approach that does not require error specifications as input.
given an api function if developers frequently use an equivalent check condition and the same error handling action we consider this to be an error handling rule for this api function.
this insight is naturally useful for mining error handling rules as developers usually perform similar actions in error paths e.g.
printing error messages or exiting the program whereas in normal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
paths developers perform different actions according to the program specific functionalities.
as illustrated in figure all the check conditions are equivalent checking whether the return value is and followed by the same action printing an error message .
thus we obtain the rule that chroot should be logged when returning .
challenges.
there are two main challenges for mining error handling rules.
first to determine the check conditions that appear frequently e.g.
whether the return value is we need to judge the equivalence of check conditions.
this is a difficult task as two check conditions can be written in various forms but still have the same meaning.
for example if chroot and if chroot !
are equivalent both check whether the return value of chroot is since chroot can only return or but semantically different.
second we need to recognize error handling actions e.g.
printing an error message after the check conditions.
achieving this is non trivial since the implementations of an error handling action may take various forms across different applications.
taking the print action as an example when printing an error message most applications implement custom logging functions instead of using the library function printf directly.
for example all applications in figure use custom logging functions.
to overcome these challenges we study the source code of real world projects and summarize the characteristics of equivalence between check conditions as well as the characteristics of error handling actions.
guided by these characteristics we employ two normalization methods to judge the equivalence of check conditions and recognize error handling actions.
definition.
to clearly describe error handling behaviors like the examples in figure we summarize the following three elements and combine these elements into the potential error handling model.
library function call lc a call statement that invokes a library function.
check condition cc a boolean expression that is the condition of a branch statement e.g.
iforswitch and the branch statement is flow dependent on an lc.
handling function call hc a call statement that is control dependent on a branch statement and the branch statement is flow dependent on an lc.
potential error handling model peh a tuple m lc cc hc .
iii.
c haracteristics study as outlined in section ii there are two main challenges in obtaining error handling rules.
one is the judgment of equivalence between check conditions the other is the recognition of error handling actions.
we studied the real world applications and summarized some characteristics that help to overcome these challenges.
we select five mature opensource applications from different software domains in order to provide sufficient generality for our investigations.
all target applications are active and widely used written in c c and have long development history.
the applications include19 mysqlgitemacsxbmcwiresharktotalcross appl.syntax semantics pragmatics not equivalent fig.
.
distribution of different equivalence levels.
mysql .
.
database git .
.
version control emacs25.
text editor xbmc .
video player and wireshark2.
.
packet analyzer .
a. characteristics of equivalence between check conditions developers can use various forms to implement check conditions that perform exactly the same behavior.
it is nontrivial to determine whether two check conditions are equivalent.
to study the equivalence between check conditions we manually selected pairs of check conditions in each of the five applications i.e.
pairs in total .
for each pair we first randomly selected a library function used in the studied application then randomly selected two call sites of this function.
to study the equivalence across different applications we further selected pairs of cross application check conditions i.e.
the two call sites are from different applications .
to judge the equivalence between check conditions the most intuitive method is to compare conditions as strings.
this method requires the conditions to be equivalent at the syntactic level.
most equivalent conditions however do not meet this requirement.
a practical tool should be capable of judging the equivalence at the semantic level.
moreover the conditions with different semantics might still have the same behavior in certain contexts.
we regard this level of equivalence as pragmatic level.
therefore we classify the condition equivalence into three levels and investigate their distributions syntactic level .
two check conditions are exactly the same except for some blanks and comments e.g.
foo and foo are equivalent in syntax.
semantic level .
given the same input two check conditions will choose the same branch e.g.
both foo !
and foo will choose true branch when foo returns non zero.
pragmatic level .
two check conditions have different semantics e.g.
foo and foo !
.
but they are still equivalent under the specific context e.g.
the return value of foo is limited to .
for example in figure the check conditions of chroot in example and are equivalent at the syntactic level.
example and are equivalent at the semantic level while example and are equivalent at the pragmatic level.
we studied the distribution of these equivalence levels.
the results are illustrated in figure .
taking mysql as an example and of check conditions are equivalent at the syntactic semantic and pragmatic levels respectively authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mysqlgitemacsxbmcwireshark totalreturn log exit goto close break free continue delete fig.
.
distribution of different error handling actions.
while of them are not equivalent.
the average distribution across the five applications is .
.
.
and .
moreover in cross application samples the percentage of pragmatic equivalence increases from .
to .
the percentages of semantic and pragmatic equivalence are and in cross application samples.
it is important to judge the equivalence beyond the syntactic level.
b. characteristics of error handling actions as developers usually use custom functions to handle errors it is difficult to directly compare error handling actions across different applications.
all projects shown in figure use custom logging functions e.g.
sqlprint error in mysql andaplogerror in httpd.
to study the existing actions we randomly selected error handling code snippets in each of the five applications i.e.
in total and found nine kinds of error handling actions via manual analysis.
according to how the actions are implemented these actions can be classified into two categories unconditional branch statements and custom error handling functions.
the former is implemented by keywords in c c language while the latter is implemented by custom functions.
unconditional branch statements.
four kinds of actions are implemented by unconditional branch statements return break continue andgoto.
among these the return action is most frequently used in the error handling code snippets.
as outlined in figure on average of error handling code snippets use return statements.
the goto action is another important error handling mechanism in c c applications which is used in of snippets on average.
in addition thebreak and continue actions are used to handle errors in loops such as for statements and while statements.
in general these kinds of error handling actions can be recognized by simply searching the keywords.
custom error handling functions.
five kinds of actions are implemented by custom error handling functions log exit close delete andfree .
among these the logaction prints error messages to any target including console file or socket.
the exit action exits the application immediately by wrapping the functions such as exit orabort .
figure shows and of error handling code snippets on average perform logandexit actions respectively.
in addition the close anddelete actions refer to closing or deleting a file or directory.
these two actions are found in and of total snippets respectively.
the final action free is used to free memory and appears in error handling code snippets.peh instancesnormalized peh instances error handling rulesstep judge check condition equivalence step mine frequent instancesstep recognize error handling actionsstep extract peh instances bug reports code repository eh miner tool fig.
.
overview of eh miner .
there are nine common used error handling actions which can be classified as unconditional branch statements return goto break continue and custom error handling functions log exit close delete free .
iv .
eh miner design in this section we present the detailed design of eh miner .
as shown in figure eh miner takes source code as input and generates error handling rules for library functions.
it then detects violations of these rules and identifies them as errorhandling bugs.
in eh miner the first step is to extract peh instances which transfer the source code into structured data.
eh miner then judges the equivalence of check conditions across peh instances and recognizes error handling actions of each instance.
for ease of comparison eh miner normalizes these instances according to the equivalence of check conditions and the type of error handling actions.
finally eh miner mines error handling rules from the normalized peh instances.
a. extracting peh instances eh miner extracts peh instances according to the algorithm described in algorithm .
for each function definition eh miner scans its source code and collects all call statements line .
for each call statement eh miner checks whether or not it is calling a library function line and if so regards the call statement as an lc library function call line .
from the lc eh miner searches forwards to collect all branch statements line and chooses the ones that are flow dependent on lc.
conditions of the chosen branch statements will be regarded as cc check condition line and .
eh miner then explores all branch paths of the chosen branch statements to find call statements and unconditional branch statements line .
for each call statement eh miner records the statement as an hc handling function call line and adds a new peh instance lc cc hc tom line and .
for each unconditional branch statement eh miner regards it as a special handling function call and adds a new peh instance lc cc return goto break continue tom line and .
finally eh miner returns m which is the set of peh instances of the input function definition line .
for example the first code snippet in figure calls a library function foo followed by two check conditions one authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm peh instances extraction algorithm.
require function definition f ensure instances set m m m lc cc hc m scan f s source code and get all call statements foreach call statement finfdo iffcalls a library function then letlc f from lc scan forwards and get all branch statements foreach branch statements bsafter lcdo ifbsis flow dependent on lcthen letcc condition of bs search paths of bs and get calls and unconditional branches.
foreach call statement f primedo lethc f prime letm lc cc hc add mtom end for foreach unconditional branch statement do letm lc cc return goto break continue add mtom end for end if end for end if end for return m is checking for a return value while the other is checking for a pointer argument.
each check condition has one handling function call.
therefore eh miner extracts two peh instances m1andm2.
in addition to the above eh miner also needs to properly deal with the following situations a else branch when a function is called in the else branch of anifstatement eh miner negates the check condition for example the second code snippet in figure generates m3.
forswitch statements eh miner records the switch case label together with the conditional expression.
b non reaching definition a library function call will be ignored when its return value is reassigned.
for example in the third code snippet in figure since the return value of foois reassigned by rv a accordingly rv foo ptr is considered a nonreaching definition for rvin if rv and will be ignored.
c nested branches two check conditions will be jointed when their branch statements are nested.
for the fourth code snippet in figure if rv !
is located in the else branch of if rv thus the check condition of exit will be !
rv rv !
.
this code snippet finally generates m4andm5.
b. judging equivalence of check conditions for each pair of identified peh instances eh miner judges the equivalence of their check conditions.
according to section iii a there are three levels of equivalence between check conditions syntactic level semantic level and pragmatic level.
in this part we will outline the procedure for judging equivalence of these levels.
rv foo ptr if rv log if ptr null return rv foo ptr if rv ... else log rv foo ptr rv a if rv exit rv foo ptr if rv log else if rv !
exit rv foo ptr rv log rv foo ptr ptr null return rv foo ptr !
rv return rv foo ptr rv log rv foo ptr !
rv rv!
exit fig.
.
mapping of code snippets and peh instances.
syntactic equivalence.
it is easy to judge the syntactic equivalence between check conditions.
the most intuitive approach is to compare two check conditions as strings.
semantic equivalence.
compared with the syntactic level this equivalence level is much more powerful.
we convert the judgment of this equivalence into a satisfiability problem as described in the following theorem.
theorem .
given two check conditions xandy xand yare semantically equivalent if the expression x y x y is not satisfiable.
proof.
if x y x y is not satisfiable then both x y and x y are not satisfiable.
if x y is not satisfiable then there is no case that satisfies xbut does not satisfy y. that is to say every case that satisfies xwill also satisfy y namely y x. similarly if x y is not satisfiable then x y. ify xandx y then xandyare equivalent.
for example suppose there are two equivalent check conditions xandy where xis rv !
and yis rv rv .eh miner calculates the satisfiability of x y and x y through a satisfiability modulo theories smt solver and finds that both of them are not satisfiable thus x y x y is not satisfiable.
therefore x andyare equivalent.
pragmatic equivalence.
given two check conditions rv and rv !
they are not equivalent according to theorem but have the same behavior when rvis the return value of chroot i.e.
belongs to .
to solve this problem we have to obtain the return value ranges of library functions.
eh miner only analyzes constant error returns.
according to in the libraries on standard linux systems the non constant return values are used only to indicate success conditions e.g.
the number of bytes read .
for each library function we first find all its return statements from each return statement we recursively search backwards along the use define chain to find the definitions of the returned variables then record all the integer definitions as the return value range.
taking chroot as an example the range expression of its return value will be ret ret .
with the return value ranges ravailable we have the following theorem.
theorem .
given two check conditions xandy xandy are pragmatically equivalent if the expression x y x y r rv1 r rv2 ... r rvn is not satisfiable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
where rv1 r v2 ... rv nare return value variables in xand y and r rvi i is the range expression of rvi.
proof.
if the above expression is not satisfiable then both i and ii below are not satisfiable.
x y r rv1 r rv2 ... r rvn i x y r rv1 r rv2 ... r rvn ii if i is not satisfiable the satisfiability of x y has two cases a x y is not satisfiable in which case y x theorem b x y is satisfiable in which case let sdenote the cases that satisfy xbut do not satisfy y. since i is not satisfiable s r rv1 r rv2 ... r rvn must not be satisfiable s is a subset of x y .
that is to say the cases in sare impossible since they are contradictory to the ranges of return values.
thus sis empty and every case that satisfies xwill also satisfy y in short y x. similarly if ii is not satisfiable then x y. ify xandx y then xandyare equivalent.
name normalization.
when the check conditions have different variables we can apply neither theorem nor directly to judge their equivalence.
for example given two check conditions xandy where xis rc and yis err!
the satisfiability of rcanderrcan not be judged.
to solve this problem eh miner normalizes the variables.
besides the exception handling mechanism there are three common ways for library functions to communicate errors with their callers.
the first is return values e.g.
chroot returns when failing.
the second is global variables e.g.
errno in libcis widely used to record the error code.
the third is pointer arguments for example in glib many functions use pointer arguments to pass errors e.g.
g xxx ... gerror error communicates errors with its caller through the argument error .
in light of the above we only analyze three kinds of variables i.e.
return values global variables and pointer arguments while other variables will be ignored.
ineh miner global variables are used directly since their names are the same even in different applications.
return values are renamed to the function names with a attached for example rvwill be renamed to chroot 0when rv chroot .
pointer arguments are renamed to the function name with an index attached for example for function call foo x y xandywill be renamed to foo 1andfoo 2respectively.
moreover when a check condition contains a function call the call will be regarded as a return value e.g.
chroot will be normalized to chroot .
after name normalization eh miner applies theorem or theorem if the library source code is not available to judge the equivalence of the check conditions.
for ease of comparison all check conditions are partitioned into clusters and check conditions in the same cluster are equivalent.
ehminer normalizes the peh instances by replacing their check conditions with the cluster ids.c.
recognizing error handling actions eh miner needs to recognize the error handling action from each identified peh instance.
in solving this problem existing tools only deal with three most common error handling actions log return andexit and require users to input logging functions.
we propose a more practical technique that can not only deal with more error handling actions but also automate the recognition process.
recalling the characteristics outlined in section iii b there are nine error handling actions that can be classified into two categories.
for actions in the first category i.e.
unconditional branch statements we search those statements mechanically.
for actions in the second category i.e.
custom error handling functions we use two heuristic rules a the custom error handling function always wraps certain library functions.
taking action log as an example its custom error handling functions always wrap functions such as printf write andsend .
this is not surprising since the custom function has to implement the functionality of the action eventually.
b there is a call chain from the custom error handling function to the wrapped library function and each function in the call chain contains certain keywords.
for example in mysql the custom logging function sqlprint error calls library function fprintf through the call chain sqlprint error error logprint print buffer tofile fprintf .
each function in the chain contains keywords such as print error or log that refer to printing error messages.
for each action act we empirically define its wrapped standard library function set sfact e.g.
printf write send ... for action log and its keyword set kw act e.g.
print log fatal ... for action log .
given an error handling function eh miner builds its call graph then applies depth first search on the call graph.
if the function invokes a third part library eh miner also builds the call graph of the third part library function.
each path pof the call graph may perform one errorhandling action.
eh miner determines that pperforms actif a pends up with a standard library function in sfact b every node in pcontains at least one keyword in kw act.ehminer collects the actions of all paths.
for ease of comparison eh miner normalizes the peh instances by replacing their handling function calls with errorhandling actions if any .
when a handling function call performs multiple actions eh miner will split the instance into multiple separated ones that share the same library function call and check condition but have different actions.
d. mining error handling rules eh miner mines error handling rules by using the normalized peh instances.
each rule contains three elements a library function a check condition and an error handling action.
for a library function eh miner first selects its check conditions that appear frequently then determines the corresponding error handling actions for each check condition.
mining check conditions.
in some applications developers use wrapper functions that wrap library functions and add authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
certain error handling code.
while other applications may use the wrapped library functions directly.
mixing the usage of library functions and wrapper functions may cause inaccuracy in cross application mining.
to avoid this we propose a twostep method to mine the check conditions intra application mining step.
for a library function f we refer to the number of its invocations in application pasn p f .
for a check condition coff we refer to the number of its appearance in pasm p f c .w es a y an application psupports cifm p f c n p f th intra where th intra is a pre defined threshold.
this formula indicates that the application psupports cwhen cfrequently appears after f. inter application mining step.
letp f denote the number of applications that invoke f and q f c denote the number of applications that support c. a check condition cwill be chosen if q f c p f th inter where th inter is a pre defined threshold.
this formula indicates that a check condition will be selected if most applications support it.
mining error handling actions.
in this step eh miner determines the error handling actions.
eh miner counts the number of every action used after above check conditions and chooses the actions satisfying both the following rules a the number of the action is the largest among all actions b the number of the action is at least one standard deviation larger than the average number of all actions.
with reference to the error handling rules available ehminer scans the source code again to detect violations of these rules.
eh miner however may report tens of thousands of violations when applying the rules directly.
in this regard ehminer further ranks the violations.
for a library function f w e refer to the number of its total call sites as cfand the number of its violations as vf.
let rfdenote vf cf.
violations of fwith smaller rfare more likely to be true positives.
v. i mplementation we implement eh miner using clang front end analysis llvm ir data flow analysis z3 smt solving and sqlite3 data management .
to extract peh instances we implement a standalone clang tool and leverage the use define chain in llvm ir.
the extracting step of ehminer is written in c while all other steps are written in python.
to judge the equivalence of the check conditions we apply z3 to solve the satisfiability problem.
the intermediate results across different steps are stored in a sqlite3 database.
to build the code repository we carefully select software domains that are widely used in the open source community.
for each software domain we choose the mature applications that are open source written in c c and have a long development history.
most of these applications are configurable and have a range of optional features.
to analyze the libraries used by the optional features we enable as many features as possible rather than using the default configuration when building.
in total we choose applications that are successfully built which include .2m lines of code loc and source files.
we get the data by using cloc tool the loc number excludes the lines of blank comment or code in header files.
these applications depend on hundreds of libraries which are all automatically analyzed by eh miner .
in the interests of saving space the applications and libraries will not be listed here1.
all our analysis was conducted on bit ubuntu .
with .
ghz intel i5 and gb ddr3.
eh miner spent ten hours in total and generated 536k peh instances.
vi.
e xperimental results in this section we evaluate eh miner by answering the following research questions rqs .
rq1 what are the precision and recall of eh miner ?
rq2 can eh miner find real world bugs effectively?
rq3 does eh miner outperform the state of the art tools?
a. precision and recall of eh miner eh miner requires two parameters to be pre defined i.e.
th intra andth inter .
these parameters may obviously affect the precision p and the recall r o f eh miner .
in this part we first tune the parameters then evaluate pandrunder the optimal parameters.
experiment setup.
we use cross validation to tune the parameters so that the parameters can generalize well to any dataset.
each of the applications is randomly assigned to one of the two sets a training set and a test set.
this process is independently repeated times so we have training sets and corresponding test sets.
we carefully tune the parameters to fit the training sets then evaluate the averaged p andrin the test sets.
it is hard to evaluate pandrof errorhandling bugs due to lack of the ground truth.
being similar to the existing works we evaluate pandrof the reported error handling rules.
we studied all posix functions used by all applications and manually generated their error specifications recorded in z3 format serving as oracles for confirming the reported rules.
a rule will be regarded as correct if its check condition is equivalent to or is a subset of the error condition of the error specification.
the equivalence judgement is performed by the z3 solver similar to the process in section iv b. suppose the expected number of error handling rules is n. letmdenote the number of reported rules and m primedenote the number of correct rules.
the precision is the ratio of m prime to m while the recall is the ratio of m prime to n .f o r eh miner the expected number of rules is the number of correct rules which appear at least one time in any application.
moreover we prefer an overall metric that considers both pandrfor the ease of comparison.
the most common practice is to calculate fscore which is the harmonic mean of pandr.
for static tools of bug detection however pis much more important than r. brittany et al .
conducted interviews with developers to ascertain why software developers do not use 1please refer to our project homepage for the target applications source code and bug reports involved in this paper.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
different metrics of reported error handling rules.
static analysis tools to find bugs and found that false positives constitute the most significant barrier.
with this in mind we used the weighted harmonic mean of pandr f prime score w1 w2 w1 p recision w2 recall where w1andw2are the weights of pandr respectively.
the weights of precision and recall are subjective for different users thus eh miner provides user interfaces to change these parameters while the default values of w1andw2are .
and .
respectively.
optimal thresholds.
we apply eh miner to the training sets and evaluate the rules that are related to posix functions.
we iterate the parameters th intra andth inter from to with a step length of .
.
the results of averaged p andrare shown in figure .
it is clear that pincreases with the corresponding increase in the thresholds while r is reduced as the thresholds increase.
the averaged pranges from .
to while the averaged rranges from .
to .
we normalize both pandrby using min max normalization so that each metric contributes approximately proportionately tof prime score .
as the two thresholds are increased f prime score initially increases and subsequently decreases.
when th intra equals to .
and th inter equals to .
eh miner achieves its highest averaged f prime score in the training sets while the averaged pandrare .
and .
respectively.
the precision and recall.
we apply eh miner to the test sets by using .
.
as the optimal parameters.
the averaged pandrof the test sets are .
and .
while the standard deviation of pandrare .
and .
.
the results indicate that eh miner can achieve a higher precision compared with and a much higher recall compared with .
meanwhile the recall and the precision are similar to and respectively.
in section vi c we will compare these tools in detail.
b. real world bugs reported by eh miner in this part we evaluate the effectiveness of eh miner through its ability of detecting real world bugs.
bugs in applications.
we apply eh miner to all applications.
eh miner found error handling rules for posix functions and for other third party libraries .
with these rules available eh miner found violations which are from library functions.
we sampled and analyzed the violations until the confidence interval is less than or equal to at confidence level.
we skipped the violations that we can not determine the correctness and finally sampled 380table i number of confirmed or fixed bugs .
application bug application bug application bug amarok ayttm balsa bftpd bitkeeper bluefish citadel claws mail cubrid darktable ettercap fossil gftp gimp httpd lftp mariadb monetdb mplayer mutt netsniff ng pidgin vlc w3m xbmc xplico the application is regularly checked by coverity or fortify.
violations of which are true positives and are false positives.
at confidence level the precision is .
with a confidence interval of .
i.e.
.
we found the true positive violations can be classified into two types.
type a violations indicates that the library functions are not checked at all.
violations in this type are definitely bugs which may cause serious results like crash or data loss.
type b violations means developers have checked the library functions and performed normal actions in normal paths while the error paths are ignored.
this type of violation may not lead to a crash in most test cases but we still believe these violations should be fixed conservatively to make the program more robust.
the false positive cases are mainly caused by the following reasons i the error handling rule is wrong.
for example the function ferror should not fail but eh miner reports errorhandling bugs for ferror .
ii the library function is checked by another way.
for example the return value of notify init in library libnotify is normally checked before calling other libnotify functions e.g.
notify notification new .
thebalsa program however calls notify isinitted before calling other libnotify functions to make sure notify init is successfully initialized.
in this situation eh miner reports a false positive about notify init.
iii the error handling code is located in complex context and eh miner fails to detect.
we are now in the process of reporting the type abugs to the developers due to their importance.
so far we have submitted patches for bugs according to the ranking rf defined in section iv d and patches for bugs have been confirmed or fixed by developers at the time of writing.
on the other hand seven patches were rejected.
among them five were regarded as unnecessary since developers believe that the bugs will never happen.
one patch was rejected since it will result in another bug.
for the last rejected patch the developer believes the whole system will down when the bug happens and it is useless to fix the bug in an application.
in table i we list all the bugs which have been confirmed or fixed by developers.
case study.
in this part we study a real world bug detected by eh miner the monetdb database server daemon monetdbd will crash if a wrong host was set to the configuration item listenaddr .
if a user set a wrong host to listenaddr and started the server the host will be sent directly authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to the library function gethostbyname .
in this situation gethostbyname will fail and return a null pointer.
further use of the return value will cause a null pointer dereference.
monetdbd will abort if this bug is triggered thus developers fixed the bug once it was reported and labelled it as a critical bug.
to detect this bug eh miner found that gethostbyname is used in different applications of which have checked whether or not its return value is null if so performed the return action.
therefore eh miner got the error handling rule that when gethostbyname returns null its caller function should return .
finally eh miner scanned the source code again to detect violations of this rule.
bugs in linux kernel.
we further apply eh miner to linux kernel to evaluate the effectiveness of eh miner on a different dataset.
the error handling rules of api functions can not be used since kernel does not use any library.
as ehminer performs cross project mining each kernel subsystem will be regarded as a separated project e.g.
fs ext4 and we have projects in the kernel dataset.
eh miner gets error handling rules and violations of the rules for kernel functions.
we randomly inspect violations of which are true positives while are false positives.
at confidence level the precision is .
with a confidence interval of .
i.e.
.
as before we are now in the process of reporting the type akernel bugs to developers.
so far we had reported bugs from kernel functions and each function may have multiple bug instances and bugs had been confirmed or fixed by developers at the time of writing.
among these bugs were fixed by using our patches bugs are under discussing about how to improve the patches patches are rejected even though the bugs are confirmed since developers believe the whole functions are buggy while our patches do not help.
on the other hand bugs are rejected.
one reason is that there is no serious consequence even the function fails.
for example developers ignore the errors of i2cnew dummy instances since i2c devices are not really used.
another reason is that the error has been well handled in other way.
for example when kmem cache create fails instances kernel panic happens if the function is invoked with argument slab panic.
c. comparison of different methods in this section we compare eh miner with the existing tools of detecting error handling bugs.
lfi is a dynamic analyzing tool while eh miner is a static one.
dynamic tools can achieve much higher accuracy compared with static tools but they are unable to find bugs that have not been executed.
therefore eh miner is complementary to lfi.
epex and errdoc are static tools but require users to provide error specifications as input while eh miner requires no such input.
some commercial tools are widely used in practice e.g.
coverity and fortify .
eh miner reported bugs that were fixed by developers at the first time.
these bugs are from projects while projects containing bugs have been regularly checked by coverity or fortify as shown in table i. the fact that none of these bugs were detected by these tools demonstrates that eh miner can detect bugs that the state of the art tools miss.
the closest works to eh miner is apex and acharya et al .
which are static tools and mine error specifications automatically.
we choose and as the baseline methods.
experiment setup.
we compare these tools through three metrics the precision the recall and the efficiency.
apex and acharya et al .
manually evaluated both the precision of bugs and the precision of error specifications.
the precision of bugs however might be biased since the authors might have limited domain knowledge and simply regard violations of correct rules as true positives.
this assumption will lead to overestimation.
for example all rejected bugs in section vi b are violations of correct rules but they are not true positives.
in this regard we use pandrof error specifications since the standard of the library functions can serve as an oracle.
eh miner mines error handling rules instead of error specifications.
for the ease of comparison let idenote the expected number of functions covered by error specifications or errorhandling rules.
let jdenote the number of functions that covered by reported error specifications or error handling rules and j primedenote the number of functions that covered by correct error specifications or correct error handling rules.
the precision is the ratio of j prime to j while the recall is the ratio of j prime to i .
for functions covered by multiple rules we calculate the proportion of correct rules.
for example if a function is covered by three rules one correct rule and two wrong rules the number of function covered by correct rules is .
.
comparing above metrics directly may also cause bias since eh miner learns from more applications.
to remedy this we apply eh miner to applications which are used by apex .
for space reason we do not list these applications.
as for acharya et al .
the authors did not provide their application list and the tool is not available so it is hard to compare with eh miner by using the same dataset.
comparison with .
under optimal parameters ehminer mines error handling rules for posix library covering functions.
among them rules of .
functions are correct some functions are covered by both correct and wrong rules while the expected number of functions is posix functions that appear in any of the programs .
thus the precision and recall are and respectively.
as shown in table ii eh miner learns from fewer applications while the precision is similar to .
acharya et al .
reported that their tool spent one hour on postfix which has 111k lines of code.
the efficiency is about nine hours per million lines of code mloc .
according to section v the efficiency of eh miner is .
hours per mloc.
acharya et al .
mine api error check from error traces when the check conditions are equivalent in the syntactic level.
in our study the syntactically equivalent cases only account for figure .
additionally they assume that there is an explicit return exit statement in an error trace.
our study authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii comparison of different tools .
appl.
precision recall efficiency acharya et al .
h mloc apex .
h mloc eh miner .
h mloc the authors did not report the recall.
shows that these two statements only account for figure .
as a result found error specifications of functions for both posix and x11 libraries.
while eh miner found rules of .
functions for posix library only in spite of learning from fewer applications.
comparison with .
acharya et al .
is the prior work of apex which claims that apex outperforms thus we regard apex as the state of the art tool.
the precision and recall of apex are and respectively.
apex spent .
hours on five applications clama v pidgin grep gnutls and coreutils which have .5m lines of code in total.
the efficiency is about .
hours per mloc.
eh miner is about times faster than apex.
though eh miner uses a constraint solver the number of variables in each constraint is very limited only from two check conditions and eh miner will not suffer the path explosion problem.
apex first distinguishes error paths and non error paths then analyzes the conditions of error paths and mines error specifications like for foo is an error return value .
in contrast to apex eh miner does not need to know whether means error or not but directly mines rules like foo should be logged when returning .
this feature enables eh miner to improve the precision by i.e.
.
on the other hand the features of judging equivalence of check conditions and recognizing error handling actions improve the recall from to .
vii.
d iscussion exception handling mechanism.
there are two common practices to handle errors in software.
the first practice is to use explicit exception handling mechanism i.e.
try catch block which are built in features in many languages like java and python.
this mechanism has fixed syntax structure and has been well studied by many existing works.
while ehminer is designed as a complement tool to the existing works.
eh miner focuses on the second practice i.e.
function returncheck which is wide used in low level languages such as c c .
c does not provide exception handling mechanisms while c projects contain far fewer try blocks than projects developed in the other languages.
alternative error handling method.
sometimes developers may can use an alternative method to handle an error of an api.
for example in balsa developers do not check the return value of the api notify init.
instead they use notify isinitted to ensure libnotify is successfully initialized by notify init.
another example is open andstat.
the developers use stat to check the state of a file that is going to be opened by open .
when stat returns success openwill succeed in most cases.
eh miner however can not cope with this relationship and reports two false positive cases.
to remedy this situation we will need to study the relationship between api functions further.
impact oriented bug detection.
eh miner can find bugs that cause severe results like crash or abort.
these results however have different impacts.
for example in monetdb an error handling bug of gethostbyname causes a crash and the bug is classified as a critical bug.
on the other hand in fossil a bug of fopen crashes a component mkversion .
the developer however believes this bug is not important since mkversion is a one off utility used during the build process and is called only by makefile.
eh miner can not avoid the low impact bugs as yet.
viii.
t hreats to validity threats to external validity.
the first threat to external validity is the representativeness of the programs.
in the implementation of eh miner we choose as many as possible software domains and representative programs from those domains to build dataset.
the programs use apis from various libraries thus eh miner can mine error handling rules of the apis.
the dataset however may not be generalized to other datasets e.g.
the linux kernel do not use libraries.
to control this threat we evaluate eh miner on a different dataset linux kernel.
the second threat to external validity is the limitations of error handling actions.
in section iii we summarize nine actions from five programs.
there might be another action that is not used by any of the five programs thus our action set may not be generalized to other programs.
the impact the this threat is limited.
we mine error handling rules from frequent actions others will be ignored anyway.
threats to internal validity.
beyond the factors in peh model there are two other factors that can impact errorhandling rules context and argument which pose threats to internal validity.
a the context of error handling actions is the first threat.
the choice of error handling actions might be determined by some application specific contexts besides check conditions.
for example the break andcontinue actions should be only used in loops the delete andclose actions should be used when dealing with files or directories thereturn action usually will not be used when the caller function returns void.
b the second threat is argument.
taking fopen as an example fopen has two arguments file name and operation mode.
whenever the file name is tainted by any form of input fopen becomes more likely to fail.
for example the invocation fopen input file r prime is more likely to fail than fopen etc passwd r prime since the input file may be a file that does not exist.
as for the second argument r is more likely to fail than w .
given a non existent file fopen fails when reading and creates a new file when writing.
we leave the contexts and arguments in future work.
threats to construct validity.
a common practice to evaluate static tools is using precision and recall.
for ehminer however it is hard to measure its recall since lack of ground truth of false negative.
measuring precision is also authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
non trivial since the results should be inspected by developers manually.
in this regard we use the precision and recall of error handling rules instead of the precision and recall of errorhandling bugs to evaluate eh miner.
a violation of a right error handling rule does not have to be a bug e.g.
developers may use an alternative way to handling the error.
ix.
r elated works error handling bugs.
existing works of detecting errorhandling bugs can be classified into two kinds i.e.
static approaches and dynamic approaches.
many works use static analysis techniques for detecting bugs.
tian et al.
conducted empirical study on error handling bugs and proposed errdoc a tool that can automatically detect categorize and fix error handling bugs.
jana et al.
designed epex which uses under constrained symbolic execution to explore error paths and detect error handling bugs.
lawall et al.
built a static bug finding tool for finding error handling bugs in ssl.
rubio gonzlez et al.
proposed an inter procedural static analysis that tracks errors as they propagate through file system code.
gunawi et al.
developed a static analysis technique that analyzes how file systems and storage device drivers propagate error codes.
as error conditions rarely hold feeding regular input thus the error handling code rarely gets to run and error handling bugs are hard to test.
to fill this gap researchers have used dynamic fault injection to execute error handling code by simulating failures.
marinescu et al.
proposed a dynamic analysis technique and developed a fault injection tool.
they simulate api failures according to the error specifications and check the response of the test program.
jia et al.
designed and implemented smartlog an intention aware log automation tool to place log statements for error prone functions.
both static and dynamic works depend heavily on correct error specifications while eh miner can detect error handling bugs without error specifications.
exception handling bugs.
there is a long line of research focuses on exception handling mechanisms which are builtin features in many languages like java and python.
many researchers study the characteristics of exception handling bugs.
ebert et al .
conducted a survey of developers and an analysis of exception handling bugs from the repositories of eclipse and tomcat.
oliveira et al .
presented an empirical study on the relationship between the usage of android abstractions and uncaught exceptions.
filho et al .
presented an in depth study of the adequacy of the aspectj language for modularizing exception handling code.
jakobus et al .
contrasted exception handling code across languages from open source projects.
some works are aimed to detect and repair exception handling bugs.
barbosa et al .
presented a tool to recommend repairs of exception handling violations with aware of the global context.
guet al .
expanded the intrinsic capability of runtime error resilience in software systems to recovery unexpected errors at runtime.
yan et al .
proposed a slicebased statistical fault localization approach to improve faultlocalization effectiveness.
weimer et al .
presented a data flow analysis for finding a certain class of exceptionhandling bugs in java programs.
jia et al .
designed a tool that can automatically detect and pinpoint the root causes of the problems caused by ungraceful exits.
these works focus on exception handling mechanisms like try catch statements.
while eh miner detects bugs for error handling of function return which is widely used in languages like c c .
api specifications.
another line of research related to ehminer is api specifications mining.
some works are aimed to automatically mine error specifications.
defreez et al .
proposed a path based embedding method to determine function synonyms and predicted the functions that should be executed when an error occurs.
this method however can not predict error conditions.
kang et al .
studied the characteristics of error paths and proposed apex which can automatically infer error specifications for c api functions.
acharya et al .
automatically inferred error handling specifications of apis by mining static traces of their runtime behaviors.
rubio gonzlez et al .
examined mismatches between documented and actual error codes and revealed undocumented error code instances.
magiel et al .
focused on a specified embedded system and presented a fault model accompanied by an analysis tool.
several prior research projects have mined different types of specifications from source code to help software developers.
nguyen et al .
mined large scale repositories of existing open source software to derive potential preconditions for api methods.
zhong etal.
and tan et al .
tried to infer api specifications from user manuals and comments.
acharya et al .
proposed a framework to automatically extract usage scenarios among user specified apis as partial orders.
engler et al .
demonstrated techniques that automatically extract programing rules from the source code.
eh miner is closer to works of mining error specifications and .
compared with these works eh miner has three advantages higher accuracy better scalability and easier to repair.
x. c onclusions the existing methods of detecting error handling bugs are limited by the need for correct error specifications input.
this prerequisite is hard to satisfy since manually generating error specifications is error prone and tedious while mining error specifications automatically is often inaccurate.
to fill the gap we designed and implemented eh miner a tool that can automatically detect error handling bugs without requiring error specifications as input.
we applied eh miner to mature applications.
it was found that eh miner mined errorhandling rules with precision of .
and recall of .
.
we reported bugs mined by eh miner of these had been confirmed and fixed by developers.
we also reported bugs linux kernel .
of which were confirmed or fixed by developers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.