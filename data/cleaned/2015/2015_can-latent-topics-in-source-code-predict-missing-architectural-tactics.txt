can latent topics in source code predict missing architectural tactics?
raghuram gopalakrishnan palak sharma mehdi mirakhorli matthias galster rochester institute of technology usa university of canterbury new zealand rg8772 ps2671 mxmvse rit.edu mgalster ieee.org abstract architectural tactics such as heartbeat resource pooling and scheduling provide solutions to satisfy reliability security performance and other critical characteristics of a software system.
current design practices advocate rigorous up front analysis of the systems quality concerns to identify tactics and where in the code they should be used.
in this paper we explore a bottom up approach to recommend architectural tactics based on latent topics discovered in the source code of projects.
we present a recommender system developed by building predictor models which capture relationships between topical concepts in source code and the use of specific architectural tactics in that code.
based on an extensive analysis of over open source systems we identify significant correlations between latent topics in source code and the usage of architectural tactics.
we use this information to construct a predictor for generating tactic recommendations.
our approach is validated through a series of experiments which demonstrate the ability to generate packagelevel tactic recommendations.
we provide further validation via two large scale studies of apache hive and hadoop to illustrate that our recommender system predicts tactics that are actually implemented by developers in later releases.
index t erms architectural design and implementation tactic recommender emergent design i. i ntroduction the success of software intensive systems heavily depends on the extent to which quality concerns such as reliability availability security and performance are addressed.
software architects therefore utilize a rich set of proven architectural patterns and tactics that help satisfy specific quality concerns.
architectural patterns e.g.
layers pipe and filter blackboard or publish subscribe schemes determine the overall structure and behavior of a software system and are typically selected early during development.
while applying a pattern is a strategic decision towards creating a solution to satisfy multiple system requirements architectural tactics are design decisions that improve individual and specific quality concerns .
therefore a pattern usually implements multiple tactics but tactics can be used independent from patterns .
tactics play an integral role in shaping the high level design of software since they describe reusable techniques and concrete solutions for satisfying a wide range of quality concerns .
for example reliability tactics provide solutions for fault mitigation detection and recovery.
performance tactics provide solutions for resource contention optimizing response time and throughput.
security tactics provide solutions for authorization authentication non repudiation and other suchfactors .
tactics are found in the implementation of many performance centric and safety critical systems .
for instance the airbus flight control system uses reliability tactics such as redundancy with voting heartbeat and checkpointing to provide solutions for fault mitigation detection and recovery.
similarly the google chromium uses performance tactics such as resource pooling and scheduling to optimize response time and latency .
ideally relevant architectural tactics are identified in early phases of the design and then implemented alongside functional features.
however in practice this is not always the case.
architectural solutions often evolve during the development process .
for example our analysis of the source code of thewavelet enterprise management portal emp showed that the initial release included a module for editing a customer s personal information including their social security number credit limit and bank information.
however no audit trail a tactic to achieve secure payment was implemented until release .
incremental and iterative development and the practice of delivering the simplest functionality first can lead to systems which are at least initially not as secure reliable or responsive as we would like them to be.
in this paper we partially address this problem and explore how to use latent topics in the source code to identify packages in which architectural tactics could be usefully deployed.
most software systems are composed of sets of interacting packages modules etc.
which are related to a common goal and common topics.
for example a set of classes in object oriented source code dealing with online purchases might be described in terms of credit card transactions user authentication invoicing shipping and inventory management.
our recommender system identifies tactics based on such topics.
it uses machine learning and text mining algorithms to mine the source code of open source projects and identify the latent source code topics which are correlated with architectural tactics.
then it uses this association to train an inference algorithm and build a recommender system that generates tactic recommendation for software packages one of the fundamental assumptions of our work is that underlying topics in source code are correlated with the use of architectural tactics.
for instance it is likely that architectural tactics such as check pointing with roll back orauthentication might be found in classes associated with credit card handling.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g8 g28 g17 g26 g1 g11 g27 g32 g29 g15 g17 g1 g10 g17 g28 g27 g30 g21 g31 g27 g29 g21 g17 g30 g13 g28 g15 g22 g25 g22 g25 g20 g1 g5 g15 g30 g15 g34 g1 g8 g25 g17 g18 g32 g18 g17 g1 g4 g26 g25 g30 g18 g32 g30 g31 g15 g23 g1 g13 g26 g27 g22 g16 g35 g10 g28 g26 g19 g22 g23 g18 g29 g1 g19 g26 g28 g1 g13 g15 g16 g30 g22 g16 g29 g12 g14 g15 g31 g21 g15 g1 g3 g24 g14 g30 g30 g21 g18 g21 g17 g29 g3 g27 g26 g31 g17 g35 g31 g2 g26 g14 g24 g36 g30 g21 g30 g3 g4 g5 g14 g8 g5 g16 g2 g7 g9 g4 g14 g7 g6 g1 g3 g11 g12 g8 g5 g13 g1 g2 g7 g10 g11 g15 g4 g9 g1 g3 g24 g14 g30 g30 g21 g18 g21 g17 g16 g1 g12 g14 g15 g31 g21 g15 g14 g24 g1 g4 g21 g24 g17 g30 g12 g27 g28 g21 g15 g2 g26 g14 g24 g36 g30 g21 g30 g13 g27 g29 g23 g21 g26 g19 g1 g9 g29 g27 g22 g17 g15 g31 g13 g15 g16 g30 g22 g16 g1 g10 g28 g26 g19 g22 g23 g18 g28 g13 g26 g27 g22 g16 g1 g10 g28 g26 g19 g22 g23 g18 g28 g13 g15 g16 g30 g22 g16 g1 g27 g28 g18 g17 g22 g16 g30 g26 g28 g9 g29 g17 g16 g21 g15 g31 g21 g33 g17 g1 g25 g27 g16 g17 g24 g9 g29 g17 g16 g21 g15 g31 g17 g16 g1 g31 g14 g15 g31 g21 g15 g30 g1 g14 g26 g16 g1 g31 g20 g17 g21 g29 g1 g24 g27 g15 g14 g31 g21 g27 g26 g30 g9 g14 g29 g31 g21 g14 g24 g1 g28 g29 g27 g18 g21 g24 g17 g1 g27 g18 g1 g28 g29 g27 g22 g17 g15 g31 g10 g21 g15 g29 g18 g1 g36 i g37 g34 g1 g13 g28 g15 g22 g25 g22 g25 g20 g1 g38 g1 g6 g32 g27 g18 g28 g22 g24 g18 g25 g30 g15 g30 g22 g26 g25 g10 g21 g15 g29 g18 g1 g36 ii g37 g34 g1 g2 g27 g27 g23 g22 g16 g15 g30 g22 g26 g25 g3 g27 g16 g17 g1 g3 g29 g14 g34 g24 g17 g29 g35 g2 g23 g20 g26 g28 g22 g30 g21 g24 g1 g12 g18 g23 g18 g16 g30 g22 g26 g25 g40 g7 g7 g37 g1 g3 g45 g39 g46 g37 g1 g10 g4 g37 g1 g6 g10 g41 g35 g13 g31 g25 g22 g25 g20 g35 g14 g15 g28 g33 g22 g25 g20 g1 g13 g26 g27 g22 g16 g1 g2 g25 g15 g23 g33 g29 g22 g29 g40 g12 g38 g46 g42 g37 g1 g43 g42 g42 g37 g1 g43 g46 g42 g37 g1 g44 g42 g42 g41 g8 g25 g19 g18 g28 g18 g25 g16 g18 g1 g9 g26 g17 g18 g23 g29 g1 g30 g26 g1 g3 g31 g22 g23 g17 g1 g15 g1 g11 g18 g16 g26 g24 g24 g18 g25 g17 g18 g28 g1 g12 g33 g29 g30 g18 g24 g7 g18 g25 g18 g28 g15 g30 g22 g25 g20 g1 g11 g18 g16 g26 g24 g24 g18 g25 g17 g15 g30 g22 g26 g25 g29 g7 g17 g34 g1 g3 g27 g29 g28 g32 g30 g12 g14 g15 g31 g21 g15 g1 g5 g26 g30 g31 g14 g26 g15 g17 g30 g1 g14 g26 g16 g1 g12 g20 g17 g21 g29 g1 g3 g27 g26 g31 g17 g35 g31 g32 g14 g24 g1 g18 g21 g24 g17 g30 fig.
.
overview of the research process.
similarly the heartbeat tactic might be observed frequently in classes implementing socket based communication channels.
while many such associations are intuitive to the best of our knowledge there are no previous attempts to analyze them in a systematic way nor to develop techniques for utilizing this information to recommend areas of code in which tactics should be placed.
this approach fits well into the emergent and evolutionary design models that are prevalent today.
in this paper we examine the following two research questions as the first step toward building a tactic recommender system rq1 can latent topics in the source code be used to predict the usage of architectural tactics?
an underlying assumption to study this rq is that there is a significant amount of collective wisdom embedded in the code of open source systems.
while we do not expect each and every system to be implemented in an ideal way we expect sufficient evidence of proven architectural solutions to extract meaningful relationships between the use of architectural tactics and a wide variety of topics in source code.
the results of our study show that in case of nine tactics studied in the paper there is a strong correlation between latent topics discovered from source code and usage of architectural tactics.
this result led to the design of a recommender system.
in order to assess the usefulness of that recommender system we therefore defined a second research question.
rq2 can a tactic recommender system based on latent topics in source code generate useful recommendations?
to evaluate how useful the generated recommendations are we compare these recommendations with the actual decisions made by developers to implement an architectural tactic.
we did this by comparing different versions of two open source software systems where one version did not implementa tactic but a later version fully implemented the tactic.
we found that tactics recommended by our approach were indeed implemented in later versions of the open source software systems that we studied.
the contribution of our work is two fold an in depth analysis of the relationship between topics in source code and tactics implemented in that code through building inference models.
development and evaluation of a novel tactic recommender system trained through analyzing the relationships between topics and tactics from source code of over open source system.
while we only investigate nine architectural tactics in this paper the results of our work highlight the feasibility of building a recommender system based on the relationship between topics in the source code and the use of architectural tactics by developers.
the focus on predicting where to place new tactics differs from our prior work in which we developed a tactic recommender for identifying existing tactic implementations in code .
ii.
o verview of research process the work presented in this paper has two phases figure phase i training and experimentation built a training dataset for the recommender system conducted experiments to identify appropriate inference algorithms and evaluated the accuracy of the inference algorithms predictions of missing tactics in source code.
this phase focused on answering research question rq1.
phase ii application focused on how the recommender system can be used experiments were conducted which generated and assessed recommendations for two industrial scale systems.
in this phase we investigated the research question rq2.
the details of each phase are described in the following.
a. phase i training and experimentation training and experimentation requires several components authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the code crawler mines source code from open source repositories.
the tactic classifier identifies architectural tactics across open source projects and labels the source files implementing these tactics.
this classification algorithm has been shown in our prior work to perform well for the task of detecting the tactics independent of projects underlying programming languages .
it outperformed the other algorithms and retrieved most of the tactical code snippets .
a context analysis identifies tactic instances and their associated contextual source files e.g.
files interacting with the tactical files and packages which will be used to learn clues about what source code topics are correlated with a tactic.
topic analysis uses the identified tactic instances and their contextual source files and a map reduce based version of the latent dirichlet allocation lda algorithm to discover dominant topics associated with each tactic context.
from this list of topics we remove the tactic related topics so latent domain concepts could emerge.
finally we model each tactic instance as a combination of the identified topics.
this model is called the topic profile for the tactic.
the topic profiles established across open source projects are used as training data for our machine learning algorithms to predict tactics.
in this phase of work several experiments identified which machine learning algorithms were suitable to build our recommender system.
furthermore since we used topic modeling our recommender system is largely dependent on heuristics to determine the parameters for the lda algorithm.
therefore we trained and tested the inference algorithms used to build the recommender system with different sets of profile sizes.
section iii describes each of the components required in phase i to obtain the training data.
section iv describes the inference algorithms used to address rq1 and section iv b reports the experiments conducted to compare and tune the inference algorithms and select an appropriate one.
b. phase ii application after the training data is generated and an inference algorithm is selected and tuned the recommender system can be used on the source code of new systems.
ideally the recommender system will be integrated into a programming ide.
the tactic recommendation process would be initiated when a developer activates the recommender engine and provides the source code of an active project within her his ide.
this project is automatically parsed and analyzed to create a partial topical profile.
furthermore the list of existing tactics will be identified so they can be removed from the recommendation list.
in this paper as a feasibility study we generate recommendations at the package level which can be representative of architectural building block.
first a topical profile is generated for each package.
then these profiles are fed into the trainedinference model which will generate a topic distribution for each of the given packages and use this model to recommend a tactic.
section v presents two case studies where the recommender system was applied to different versions of the same system and the generated recommendations were compared with decisions made by the developers in later versions.
iii.
c rea ting topic profiles for tactics atopic profile is a matrix that describes the relationship between topics identified in source code and tactics discovered from the open source project.
the profile was constructed by i establishing an ultralarge scale repository of open source projects and downloading their source code section iii a ii classifying the source code files into tactical or non tactical section iii b iii identifying tactic instances and their adoption context in each project section iii c iv performing topic analysis over tactic instances and their contextual source files to identify topics and pre processing the topics to remove tactic related topics so that latent domain concepts could emerge section iii d and section iii e and finally v modeling each tactic instance as a mixture of the identified topics section iii f .
g17 g3 g17 g4 g17 g5 g17 g6 g17 g7 g17 g8 g17 g9 g17 g10 g17 g11 g17 g3 g2 g34 g17 g27 g7 g10 g3 g5 g9 g5 g29 g29 g29 g29 g6 g10 g3 g8 g5 g6 g29 g29 g29 g29 g29 g7 g9 g3 g8 g5 g7 g29 g29 g29 g29 g7 g10 g3 g9 g9 g7 g29 g29 g29 g29 g29 g29 g29 g29 g31 g29 g7 g9 g3 g9 g4 g6 g29 g29 g29 g29 g29 g29 g16 g30 g28 g22 g24 g25 g21 g1 g14 g13 g17 g28 g29 g24 g19 g31 g1 g25 g21 g18 g30 g27 g21 g20 g1 g22 g30 g28 g26 g1 g18 g29 g29 g25 g33 g24 g27 g23 g1 g15 g13 g12 g1 g17 g18 g19 g32 g24 g19 g31 g11 g16 g26 g20 g28 g18 g1 g12 g18 g17 g27 g22 g17 g15 g22 g16 g30 g11 g27 g17 g20 g26 g1 g14 g24 g15 g20 g21 g11 g27 g26 g19 g18 g22 g2 g26 g20 g16 g15 g26 g20 g23 g22 g31 g13 g18 g16 g27 g24 g18 g1 g13 g18 g25 g25 g20 g23 g22 fig.
.
subset of the profiles documenting the topics and associated tactics.
a. establishing an ultra large scale repository the code crawler establishes an ultra large scale repository of software projects extracted from online open source repositories.
the current version of our repository contains projects extracted from github google code sourceforge apache and java.net.
code crawler utilizes different code crawling applications to retrieve projects from these repositories.
to extract the projects from github we make use of ghtorrent1to extract data and events in github in the form of mongodb data dumps.
the dumps include meta data about projects such as users comments on commits programming languages pull requests follower following relations etc.
we also used sourcerer an automated crawling parsing and fingerprinting application.
sourcerer has been used to extract projects from google code sourceforge apache and java.net.
this repository contains versioned source code across multiple releases documentation if available project metadata and a coarse grained structural analyses of each project.
we retrieved the entire collection of open source systems from these code repositories.
after extracting projects from the above repositories we performed a data cleaning removing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
redundant empty or very small projects i.e.
projects that have less than source files .
furthermore all duplicate forked projects have been identified and removed from this dataset.
b. tactic classifier each of the downloaded files for a project in the repository was analyzed to determine which if any tactics it implemented.
as it was infeasible to manually evaluate each file we used a classification algorithm we had previously developed to detect architectural tactics from source code.
these tactics were audit trail authentication check pointing heartbeat load balancing role base access control rbac resource pooling scheduling and secure session .
these tactics were selected as they are prevalent across many safety and or performance critical systems and satisfy a range of security performance and reliability concerns .
the tactic classifier includes three phases preparation training and classifying .
in the preparation phase standard information retrieval techniques are used to prepare the data for training and classification purposes.
for example all source code is preprocessed by splitting source code variable names into primitive parts removing stop words and stemming words to their root forms.
in the training phase a set of textual descriptions of the tactics were processed to produce a set of weighted indicator terms that are considered representative of each tactic type.
for example a term such aspriority is found more commonly in code related to the scheduling tactic than in other parts of the code and therefore receives a higher weight for that tactic.
finally during the classification phase the indicator terms learned in the training phase are used to compute the likelihood that a given source file is associated with a given tactic.
each source file is assigned a score for each tactic and source files scoring over a pre defined threshold tcl are labeled as being associated with the relevant tactic.
in this way it is possible for a source file to be associated with more than one tactic.
as the tactic classifier had previously been trained to detect the nine tactics used in this study training was not repeated for this paper.
instead the source code in our repository was classified using the indicator terms learned from previous training sessions .
to compensate for the fact that we could not manually evaluate each tactic we set high classification thresholds.
based on our previous experiments reported elsewhere the classification threshold tcl of .
obtains a set of tactic related files with a high degree of confidence.
c. context analysis implementation of a tactic often spreads across more than one source file.
consequently domain topics that motivate an architectural tactic are often not fully presented in the tactical file itself but also appear in neighboring files i.e.
files which use tactical files or are used by tactical files .
therefore we need to identify the whole context in which a tactic is implemented.
latent domain topics are then identified based on that context.
the context analysis is comprised oftwo steps first we identify complete tactic instances whose implementation spreads across multiple tactical files.
second we consider the full technical context of an implemented tactic instance.
the full technical context might include both tactical and non tactical files the tactic classifier identifies a list of files which are related to a tactic.
however many of these tactical files may work together to implement a single tactic instance.
for instance two tactical files involved in implementing the heartbeat tactic one file that monitors a process and another file that is monitored and sends back heartbeats to the monitor comprise one instance of the heartbeat tactic in the code.
therefore multiple instances of the heartbeat tactic can be implemented in a project to detect the failure of different processes i.e with different source files implementing monitor and sender .
to identify tactic instances we cluster tactical files using algorithm .
this algorithm is similar to kmeans clustering but instead of using a similarity score between the clustered items i.e.
tactical files we use the existence of method calls between the tactical files to move them into the same clusters i.e.
if tactical files call the same method they are put in the same cluster .
this creates clusters that contain tactical files which interact with each other.
there might be cases in which the technical context can be observed in both a tactical file and the neighboring files which have direct method calls to the tactical file.
for example source files which use the authentication function describe the technical context rather than the files which implement authentication.
therefore some latent topics in source code may appear in non tactical files in the wider context of tactical files.
to identify the context source files classified as tactical or non tactical are grouped into clusters.
each cluster then defines an instance i.e.
a full implementation plus additional neighboring files.
to discover this full context in which a tactic instance is implemented we use algorithm to discover the full context in which each tactic instance is implemented.
for each cluster of tactical files this algorithm identifies the source files that have direct method calls to the tactic instance i.e.
tactical files in a cluster .
then it groups all the files in the tactic instance i.e.
in the cluster together with these neighboring files.
the context analysis component in figure implements these two algorithms in order to identify the the context for a tactic instance.
this component statically analyzes all projects in our repository and generates new corpus data that contains the contents of the tactical files themselves and their neighboring files.
based on that corpus data we identify latent topics in source code during topic analysis see section iii d .
d. topic analysis our approach utilizes latent dirichlet allocation lda to discover the latent topics from the new corpus data generated in the previous step.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm pseudocode to identify tactic instances procedure tactic clustering input classificationlist f1 f2 ... f n f source file output clusters c1 c2 ... c k c cluster of tactical files l lf f ...n sets of cluster labels for f initialize ci fi for alli ..n initialize l fi ci for alli ..n for each fi classificationlist do find which clusters have method calls with a tactical file merge them for each cj clusters do ifdependency fi cj true then mergelist cj updateclusters mergelist clusters update l fi returnclusters returns tactic fragments in form of clusters algorithm pseudocode to capture context procedure context data cluster t output context c1 c2 ... c k the new corpus data find all neighbors of f nbr f x f methodcall f x for each instance t i t do for each source file f tido context i f add content of tactical files in tactic instance for each source file s nbr f do context i s add content of neighboring files returncontext to be used by topic analysis topics extracted by the lda algorithm form two distinct likelihood distribution models.
one models the topics discovered from a corpus indicating how likely a word is to be assigned to a specific topic.
the second models each document as a probability distribution indicating how likely it is that a document expresses each of the discovered topics.
in our work given a corpus of documents the contextual source files from algorithm the lda algorithm identifies a set of topics based on word co occurrences and defines a specific combination of these topics for each tactic instance in our training corpus.
these likelihood distributions are used to build the tactic recommender system that predicts and locates tactics in software packages.
e. tactic related topics removal because the purpose of our work is to predict where tactics should be placed and not simply to detect where tactics are currently implemented our approach is designed to focus on topics related to general domain concepts such as credit cards invoicing saving files network communication and even underlying data structures but not on tactic related topics.
we therefore implemented an additional pre processing step to remove tactic related topics from the the list of topics generated in the previous step.
topics generated by lda are groups of related words.
we remove every topic which has terms in common with the tactic indicator terms generating by our tactic classifier section iii b .
the indicator terms describe the terms that occur in tactic implementation and have been used to detect tactics in the source code.
removing every topics that has at least one term in common with the tactic indicator terms could lead to the unnecessary removal of topics and therefore negatively impact the training of the inference algorithms.
however using such restrict approach we could obtain a confidence that any residual topics relatedto actual tactics had been removed.
as a result we were able to create a set of profiles for training purposes which more closely simulated the case in which no tactic had yet been implemented.
f .
construction of topic profiles once latent topic profiles for each tactic instance were identified a topic by tactic matrix was generated m mi j p twhere prepresents the number of topics and tthe number of identified tactic clusters.
a small excerpt of this file is depicted in figure .
these profiles were then processed to remove tactic relate topics and the resulting profiles simulated a set of virgin profiles in which tactics had not yet been implemented.
next the profiles were converted from a set of topic distribution into a binary distribution.
the binary profiles were created by comparing the similarity of each corpus tactic instance to the mean of the topic distributions for that corpus.
mi j braceleftbigg ifmi j t otherwise where tis the total number of topics in topic profiles and mi jis the likelihood of topic jdescribing tactic instance i. in next section we use these binary profiles to train a set of inference algorithms and test whether viable tactic recommendation can be generated based on the discovered latent topics from the source code of projects.
iv .
b uilding a recommender system contextual topics for each tactic exhibit various kinds of associations which can be leveraged to develop a tactic recommender system.
to determine if topics in source code are effective predictors of tactics we used the topic profiles to train several machine learning algorithms and evaluated their accuracy in predicting whether a certain tactic should be implemented in the source code of a project.
in the following section we first briefly describe these inference algorithms and how they can be used in a recommender system.
we then present a series of experiments used to select and tune the most appropriate algorithm for a recommender system.
a. inference algorithms from existing machine learning algorithms we chose the decision tree j48 random forest logistic regression and artificial neural network which are commonly used in literature to build recommender systems .
decision tree dt decision trees have been widely used to build recommender systems .
a decision tree can form a predictive model which maps a software package to a predicted tactical value based on the topics observed in the package.
each node in the decision tree corresponds to a topic from profiles and each arc from a parent to a child node represents a possible value or a set of values of that topic.
this value is driven from the distribution mode generated using lda.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
random f orest rf one decision tree only takes advantage of limited information learned from project profiles and topics.
therefore for many new projects and new topics a decision tree may produce no predicting result at all.
many researchers have utilized a random forest rf algorithm to create multiple recommender systems and combine their predictions .
each tree of the forest depends on independent random profiles.
similarly our approach uses different information from training profiles and topics to construct a random forest to avoid this situation.
logistic regression lr in order to determine if the topics identified by lda from the source code were effective predictors of missing tactics we used them as predictors in logistic regression equations to classify whether a certain tactic should be implemented in a software package or not.
logistic regression is a standard classification technique in the experimental sciences.
it is also frequently used in software engineering for tasks such as predicting error prone components in software systems .
neural network nn the goal of neural network learning is to automatically transform our features topics to new sets of complex features that contain more information to distinguish between classes in a training data.
we used a layer feed forward neural network architecture in our work which consists of artificial neurons in hidden layers in the output layer and multiple in the input layer based on the number of inputs in training data.
these network parameters were selected by trial and error as used by other researchers .
the network is trained using stochastic gradient descent sgd with adagrad which is effective for both dense and sparse topics feature extraction.
sgd updates weights associated with each artificial neuron after each training sample until minimum error is achieved.
however the sgd impact is dependent on the use of an appropriate learning rate.
to accomplish this adagrad adapts the learning rate as per the frequency of training parameters.
for more frequent parameters the update in learning rate is smaller empowering the network to extract sparse and non frequent topics.
b. algorithm selection and tuning to identify the most appropriate machine learning algorithm we performed a series of experiments.
furthermore we investigated the impact of the number of topics on the prediction accuracy of the machine learning algorithms.
table i number of topics remained in each profile tactic modified topics audit authenticate checkpoint heartbeat loadbalancing pooling rbac scheduler session experiment design to identify the best performing algorithm we built four different recommender systems and adopted a standard fold cross validation technique frequently used to evaluate recommender systems to predict or recommend already known tactics in our dataset.
we systematically divided the topic profiles into nrandom folds with minor adjustments to ensure that each fold did not share any profile from projects in another folds.
for each run of the experiment nine folds were used for training and one for testing.
for each project in the test set a tactic was predicted using the recommender system trained by the profiles in the remaining nine folds.
this process was repeated ten times until each fold had been tested and a complete set of recommendations had been generated.
all experiments described in this paper share a common experimental design so that results can be compared across experiments.
for the purpose of training different inference algorithms we created a balanced dataset of tactical and non tactical profiles.
for each tactical file and its neighboring files we created a design profile describing the latent topics associate with the tactic instance.
we also randomly selected the same number of non tactical files and created the design profiles for them following the process described previously.
experiment v arying profile size one of the key parameters of the lda algorithm is the number of topics that should be extracted from the corpus there is no heuristic to identify the number of topics and needs to be explored based on applications of lda.
the fold cross validation experiment was repeated four times with initial profile sizes of n and .
these profiles were generated to identify how many topics should be discovered from each projects to achieve a reasonable accuracy level.
as described previously section iii e we removed the tactical topics from each profile so the latent domain topics could emerge.
table i shows the number of topics used in our training profiles after this removal step.
results are reported in the average recall and precision graphs shown in figure .
precision measures the fraction of retrieved files that are relevant and is computed as p recision relevantrecs generatedrecs generatedrecs recall relevantrecs generatedrecs relevantrecs precision measures the fraction of the generated tactic recommendations which were correct recall measures the fraction of known tactics that were correctly recommended.
figure a illustrates average recall of each algorithm for different numbers of topics and across all architectural tactics.
similarly figure b illustrates average precision for each algorithm.
while the increase in number of topics resulted in a change in both average precision and recall for each algorithm this change is not statistically significant.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g34 g31 g34 g34 g46 g35 g34 g31 g34 g34 g46 g36 g34 g31 g34 g34 g46 g37 g34 g31 g34 g34 g46 g38 g34 g31 g34 g34 g46 g39 g34 g31 g34 g34 g46 g40 g34 g31 g34 g34 g46 g41 g34 g31 g34 g34 g46 g42 g34 g31 g34 g34 g46 g43 g34 g31 g34 g34 g46 g35 g34 g34 g31 g34 g34 g46 g39 g34 g35 g34 g34 g35 g39 g34 g36 g34 g34 g2 g17 g5 g14 g2 g7 g5 g1 g13 g14 g5 g4 g8 g3 g16 g8 g12 g11 g1 g1 g14 g5 g3 g2 g10 g10 g13 g14 g12 g6 g8 g10 g5 g1 g15 g8 g18 g5 g14 g19 g26 g21 g27 g25 g1 g6 g27 g28 g22 g29 g30 g10 g27 g23 g24 g29 g30 g24 g20 g1 g14 g22 g23 g28 g22 g29 g29 g24 g27 g26 g9 g38 g42 g11 g11 a average recall across nine tactics.
g34 g31 g34 g34 g46 g35 g34 g31 g34 g34 g46 g36 g34 g31 g34 g34 g46 g37 g34 g31 g34 g34 g46 g38 g34 g31 g34 g34 g46 g39 g34 g31 g34 g34 g46 g40 g34 g31 g34 g34 g46 g41 g34 g31 g34 g34 g46 g42 g34 g31 g34 g34 g46 g43 g34 g31 g34 g34 g46 g35 g34 g34 g31 g34 g34 g46 g39 g34 g35 g34 g34 g35 g39 g34 g36 g34 g34 g2 g17 g5 g14 g2 g7 g5 g1 g13 g14 g5 g4 g8 g3 g16 g8 g12 g11 g1 g13 g14 g5 g3 g8 g15 g8 g12 g11 g13 g14 g12 g6 g8 g10 g5 g1 g15 g8 g18 g5 g14 g19 g26 g21 g27 g25 g1 g6 g27 g28 g22 g29 g30 g10 g27 g23 g24 g29 g30 g24 g20 g1 g14 g22 g23 g28 g22 g29 g29 g24 g27 g26 g9 g38 g42 g11 g11 b average precision across nine tactics.
fig.
.
impact of profile size on generating tactic recommendations.
experiment comparison of inference algorithms the second experiment compared the accuracy of each inference algorithm to select one to build our tactic recommendersystem.
because it is not feasible to achieve identical recallvalues across all runs of the algorithms the f 1score computes the harmonic mean of recall and precision and can be used tocompare results across experiments f 1score p recision recall p recision recall table ii reports the f1score obtained by each inference model.
we conducted a non parametric mann whitney utest to compare the performance of these machine learningalgorithms.
among all the recommender systems the predic tive model generated using lr performed the weakest.
thedifference in the obtained f 1score was significantly less than the other models p value .
the results obtained by rf washigher than the both dc and nn however this difference wasnot statistically significant.
the gray cells in table ii depictswhich inference model performed the best among four.
table ii f1score for the comparison of inference algorithms tactic rf lr dc nn audit .
.
.
.
checkpoint .
.
.
.
authenticate .
.
.
.
heartbeat .
.
.
.
load balancing .
.
.
.
pooling .
.
.
.
rbac .
.
.
.
scheduler .
.
.
.
session .
.
.
.
c. analysis of results as reported in figure recall values for the different machine learning algorithms ranged from .
to .
in dicating that in general our recommender system was ableto recommend a high percentage of known tactics.
precisionscores ranged from .
to .
for all algorithms meaningthat the the recommender system was capable of correctlyrejecting many non relevant cases for each tactic.
experiment on varying profile size suggested that increasing the number of topics from to and willnot have significant increase in the accuracy of the inferencealgorithms.
we have only observed minor changes when thenumber of topics increased from to .
considering thatrf algorithm performed the best in fold cross validationexperiments we choose the rf algorithm with topics tobuild a recommender system and apply it to real case studies.in the next section we describe how tactic recommendersystem can be applied in practice and if it would generateuseful recommendations.
v. a pplica tion of the recommender system two case studies to show the practical usefulness of our approach for complex software systems we used it in two case studies togenerate tactic recommendations for the apache hadoop andhive projects which were not part of the training dataset.hadoop supports distributed processing of large datasets acrosscomputer clusters.
it includes over classes and provides functionality to detect and handle failures to deliver high availability even in the event that underlying clusters fail.apache hive developed by facebook has over classesand is a data warehouse infrastructure built to work withhadoop providing data summarization query and analysisservices.
we chose these projects because their architecturaldocumentations were available and were available in differentversions which allowed us to study the implementation oftactics over time.
a. tactical decisions in hadoop and hive in short we compared the generated recommendations for a version of these systems without a tactic with actual tactical decision made by the developers in subsequent versions.
thisinvolved manually identifying two versions of each project ve r s i o n i timplements an architectural tactic t ve r s i o n i n t a prior version of iwhere tactic tdid not exist nvaries for each tactic to identify these versions we took the following steps we used the tactic classifier to automatically analyze each version of the projects and to classify source files of each version as tactical or non tactical in order to identify versions that implement a tactic t. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii architecture changes in hive v ersions with and without tactics g3 g4 g5 g13 g8 g5 g1 g4 g5 g9 g4 g7 g6 g2 g4 g13 g8 g12 g11 g4 g10 g6 g2 g35 g18 g23 g34 g1 g46 g40 g51 g40 g46 g41 g46 g40 g52 g40 g46 g27 g19 g34 g15 g33 g34 g29 g32 g19 g15 g35 g18 g23 g34 g1 g34 g15 g17 g34 g23 g17 g1 g37 g15 g33 g1 g15 g18 g18 g19 g18 g1 g34 g29 g1 g34 g32 g15 g17 g25 g1 g35 g33 g19 g32 g1 g7 g10 g1 g15 g28 g18 g1 g30 g19 g32 g20 g29 g32 g27 g1 g27 g19 g34 g15 g18 g15 g34 g15 g1 g29 g30 g19 g32 g15 g34 g23 g29 g28 g33 g40 g31 g26 g39 g1 g33 g19 g32 g36 g23 g17 g19 g8 g5 g2 g10 g1 g23 g33 g1 g35 g33 g19 g18 g1 g34 g29 g1 g15 g35 g34 g22 g19 g28 g34 g23 g17 g15 g34 g19 g1 g17 g26 g23 g19 g28 g34 g33 g40 g24 g18 g16 g17 g14 g33 g19 g33 g1 g12 g23 g27 g30 g26 g19 g1 g15 g35 g34 g22 g19 g28 g34 g23 g17 g15 g34 g23 g29 g28 g1 g44 g1 g12 g19 g17 g35 g32 g23 g34 g38 g1 g8 g15 g38 g19 g32 g1 g42 g12 g2 g12 g8 g43 g1 g20 g29 g32 g1 g30 g32 g29 g34 g19 g17 g34 g23 g28 g21 g1 g17 g29 g27 g27 g35 g28 g23 g17 g15 g34 g23 g29 g28 g1 g29 g20 g1 g24 g18 g16 g17 g1 g18 g32 g23 g36 g19 g32 g1 g44 g1 g33 g19 g32 g36 g19 g32 g48 g40 g31 g26 g4 g22 g19 g17 g25 g30 g29 g23 g28 g34 g23 g28 g21 g1 g22 g15 g33 g1 g16 g19 g19 g28 g1 g15 g18 g18 g19 g18 g1 g34 g29 g1 g34 g22 g19 g1 g24 g29 g16 g1 g27 g29 g28 g23 g34 g29 g32 g1 g30 g32 g29 g17 g19 g33 g33 g1 g34 g29 g1 g26 g29 g21 g1 g33 g34 g15 g34 g35 g33 g1 g15 g28 g18 g1 g26 g29 g17 g15 g34 g19 g1 g34 g15 g33 g25 g1 g20 g15 g23 g26 g35 g32 g19 g33 g40 g27 g19 g34 g15 g33 g34 g29 g32 g19 g13 g15 g17 g34 g23 g17 g1 g23 g33 g1 g35 g33 g19 g18 g1 g34 g29 g1 g33 g34 g29 g32 g19 g1 g15 g28 g18 g1 g20 g19 g34 g17 g22 g1 g15 g21 g21 g32 g19 g21 g15 g34 g19 g18 g1 g33 g34 g15 g34 g33 g1 g8 g29 g15 g18 g16 g15 g26 g15 g28 g17 g23 g28 g21 g46 g40 g47 g48 g40 g46 g41 g46 g40 g47 g50 g40 g1 g46 g17 g29 g27 g27 g29 g28 g8 g29 g15 g18 g16 g15 g26 g15 g28 g17 g23 g28 g21 g1 g23 g33 g1 g35 g33 g19 g18 g1 g34 g29 g1 g27 g15 g28 g15 g21 g19 g1 g27 g35 g26 g34 g23 g30 g26 g19 g1 g6 g23 g36 g19 g12 g19 g32 g36 g19 g32 g48 g1 g22 g29 g33 g34 g33 g27 g19 g34 g15 g33 g34 g29 g32 g19 g39 g1 g24 g18 g16 g17 g10 g29 g29 g26 g23 g28 g21 g1 g23 g33 g1 g15 g18 g29 g30 g34 g19 g18 g1 g34 g29 g1 g19 g28 g22 g15 g28 g17 g19 g1 g30 g19 g32 g20 g29 g32 g27 g15 g28 g17 g19 g1 g29 g20 g1 g34 g22 g19 g1 g33 g38 g33 g34 g19 g27 g31 g26 g39 g17 g29 g27 g27 g29 g28 g10 g29 g29 g26 g23 g28 g21 g1 g34 g29 g1 g23 g27 g30 g26 g19 g27 g19 g28 g34 g1 g15 g1 g27 g19 g27 g29 g32 g38 g1 g27 g15 g28 g15 g21 g19 g32 g1 g20 g29 g32 g1 g9 g11 g4 g6 g19 g15 g32 g34 g16 g19 g15 g34 g46 g40 g47 g48 g40 g46 g41 g48 g40 g47 g40 g46 g31 g26 g39 g17 g29 g27 g27 g29 g28 g39 g1 g27 g19 g34 g15 g33 g34 g29 g32 g19 g13 g22 g23 g33 g1 g34 g15 g17 g34 g23 g17 g1 g23 g33 g1 g35 g33 g19 g18 g1 g34 g29 g1 g27 g29 g28 g23 g34 g29 g32 g1 g34 g22 g19 g1 g17 g26 g23 g19 g28 g34 g1 g17 g29 g28 g28 g19 g17 g34 g23 g29 g28 g1 g34 g29 g1 g34 g22 g19 g1 g33 g19 g32 g36 g19 g32 g40 g6 g23 g36 g19 g12 g19 g32 g36 g19 g32 g1 g21 g19 g28 g19 g32 g15 g34 g19 g33 g1 g17 g29 g29 g25 g23 g19 g33 g1 g15 g28 g18 g1 g36 g15 g26 g23 g18 g15 g34 g19 g1 g34 g22 g19 g1 g17 g26 g23 g19 g28 g34 g1 g17 g29 g29 g25 g23 g19 g1 g20 g29 g32 g1 g15 g26 g26 g1 g34 g22 g19 g1 g6 g13 g13 g10 g1 g32 g19 g31 g35 g19 g33 g34 g33 g40 g11 g3 g2 g4 g46 g40 g51 g40 g46 g1 g41 g1 g47 g40 g46 g40 g46 g31 g26 g39 g17 g29 g27 g27 g29 g28 g39 g1 g27 g19 g34 g15 g33 g34 g29 g32 g19 g2 g17 g17 g19 g33 g33 g1 g17 g29 g28 g34 g32 g29 g26 g1 g37 g15 g33 g1 g35 g33 g19 g18 g1 g34 g29 g1 g18 g19 g34 g19 g32 g27 g23 g28 g19 g1 g23 g20 g1 g34 g22 g19 g1 g35 g33 g19 g32 g1 g22 g15 g33 g1 g15 g17 g17 g19 g33 g33 g1 g34 g29 g1 g34 g22 g19 g1 g30 g32 g29 g17 g19 g33 g33 g19 g18 g1 g20 g23 g26 g19 g40 g12 g17 g22 g19 g18 g35 g26 g23 g28 g21 g47 g40 g46 g40 g46 g1 g41 g1 g48 g40 g46 g40 g46 g17 g29 g27 g27 g29 g28 g39 g1 g31 g26 g39 g1 g33 g19 g32 g36 g23 g17 g19 g12 g17 g22 g19 g18 g35 g26 g23 g28 g21 g1 g37 g15 g33 g1 g23 g27 g30 g26 g19 g27 g19 g28 g34 g19 g18 g1 g34 g29 g1 g23 g27 g30 g32 g29 g36 g19 g1 g34 g22 g19 g1 g30 g19 g32 g20 g29 g32 g27 g15 g28 g17 g19 g1 g29 g20 g1 g31 g35 g19 g32 g23 g19 g33 g40 g4 g22 g19 g17 g25 g30 g29 g23 g28 g34 g46 g40 g52 g40 g46 g1 g41 g1 g47 g40 g46 g40 g46 g10 g29 g29 g26 g23 g28 g21 g46 g40 g49 g40 g46 g1 g41 g1 g46 g40 g47 g47 g40 g46 g2 g35 g34 g22 g19 g28 g34 g23 g17 g15 g34 g19 g46 g40 g51 g40 g46 g1 g41 g1 g46 g40 g47 g50 g40 g46 g12 g19 g33 g33 g23 g29 g28 g1 g46 g40 g47 g49 g40 g47 g41 g47 g40 g48 g40 g46 g33 g19 g32 g36 g23 g17 g19 g39 g24 g18 g16 g17 g39 g1 g17 g29 g27 g27 g29 g28 g39 g1 g31 g26 we manually checked the tactical code of each version to ensure we correctly tag each version as tactical or non tactical with regards to a tactic t. further confidence was obtained by a detailed review of the project development documentation release notes and issue tracking systems.
tactical files were linked to packages to which they belong see also section v b .
this allows us to report information about whether or not a package includes the implementation of a tactic e.g.
if a file in a package implements a tactic then the package was labeled as implementing that tactic .
tables iii and iv list the tactical and non tactical versions of apache hive and hadoop with the components in which the tactic was implemented as well as the rationale for adopting each tactic.
b. creating new topic profile for studied systems recommendations are generated at the package level using the existing package structure of hadoop and hive.
therefore topic profiles are created at package level.
typically the packages are a hierarchy of folders and the appropriate level of granularity of packages and folders is project specific.
for hive we used the package structure which is used by the original developers as discussed in hive s architecture .
for hadoop we also used the package structure according to its documentation.
in contrast to hive hadoop uses a finer granularity level to describe their code structure .
each package was automatically parsed to group the content of source files within the packages into a single corpus of text for a package.
unimportant terms were removed i.e.
stop words and words were stemmed to their root forms.
this corpus was fed into lda to infer topics for the packages.
inference was done based on the distribution of topics in the 2the data used in this study can be found at design.se.rit.edu recsys .table iv architecture changes in hadoop v ersions with and without tactics g3 g4 g5 g13 g8 g5 g1 g4 g5 g9 g4 g7 g6 g2 g4 g13 g8 g12 g11 g4 g10 g6 g2 g37 g20 g25 g36 g46 g42 g47 g50 g42 g46 g44 g46 g42 g47 g51 g42 g46 g20 g22 g35 g1 g1 g1 g8 g29 g32 g28 g21 g29 g21 g30 g36 g21 g20 g1 g17 g37 g20 g25 g36 g1 g28 g31 g23 g23 g25 g30 g23 g1 g36 g31 g1 g17 g28 g28 g31 g39 g1 g29 g31 g30 g25 g36 g31 g34 g25 g30 g23 g1 g17 g30 g20 g1 g34 g21 g19 g31 g30 g35 g36 g34 g37 g19 g36 g25 g31 g30 g1 g31 g22 g1 g1 g37 g35 g21 g34 g1 g17 g19 g36 g25 g38 g25 g36 g25 g21 g35 g42 g24 g20 g22 g35 g4 g24 g21 g19 g27 g25 g30 g23 g1 g36 g24 g21 g1 g20 g17 g36 g17 g1 g17 g19 g19 g21 g35 g35 g1 g31 g30 g1 g5 g17 g36 g17 g11 g31 g20 g21 g35 g42 g22 g35 g8 g30 g19 g31 g34 g32 g31 g34 g17 g36 g21 g20 g1 g39 g21 g18 g1 g17 g37 g36 g24 g21 g30 g36 g25 g19 g17 g36 g25 g31 g30 g1 g22 g31 g34 g1 g36 g24 g21 g1 g20 g21 g22 g17 g37 g28 g36 g1 g35 g21 g34 g38 g28 g21 g36 g35 g42 g35 g21 g19 g37 g34 g25 g36 g40 g2 g37 g36 g24 g21 g30 g36 g25 g19 g17 g36 g25 g31 g30 g1 g22 g31 g34 g1 g19 g28 g25 g21 g30 g36 g1 g17 g19 g19 g21 g35 g35 g1 g36 g31 g1 g7 g5 g6 g14 g1 g35 g40 g35 g36 g21 g29 g42 g29 g17 g32 g34 g21 g20 g2 g20 g20 g21 g20 g1 g26 g31 g18 g44 g28 g21 g38 g21 g28 g1 g35 g21 g19 g37 g34 g25 g36 g40 g1 g36 g31 g1 g10 g17 g32 g13 g21 g20 g37 g19 g21 g42 g25 g32 g19 g4 g31 g28 g28 g21 g19 g36 g21 g20 g1 g17 g37 g36 g24 g21 g30 g36 g25 g19 g17 g36 g25 g31 g30 g1 g34 g21 g28 g17 g36 g21 g20 g1 g29 g21 g36 g34 g25 g19 g35 g1 g22 g31 g34 g1 g13 g12 g4 g42 g24 g20 g22 g35 g1 g2 g20 g20 g21 g20 g1 g19 g24 g21 g19 g27 g32 g31 g25 g30 g36 g1 g36 g31 g1 g21 g30 g35 g37 g34 g21 g1 g34 g21 g19 g31 g38 g21 g34 g40 g1 g17 g30 g20 g1 g1 g37 g32 g20 g17 g36 g21 g35 g1 g22 g34 g31 g29 g1 g35 g36 g17 g30 g20 g1 g18 g40 g1 g30 g31 g20 g21 g42 g22 g35 g15 g24 g25 g35 g1 g36 g17 g19 g36 g25 g19 g1 g25 g35 g1 g25 g30 g19 g28 g37 g20 g21 g20 g1 g17 g35 g1 g32 g17 g34 g36 g1 g31 g22 g1 g22 g25 g28 g21 g1 g17 g34 g19 g24 g25 g21 g38 g25 g30 g23 g1 g22 g21 g17 g36 g37 g34 g21 g42 g24 g20 g22 g35 g29 g21 g36 g34 g25 g19 g29 g17 g32 g34 g21 g20 g37 g19 g21 g24 g20 g22 g35 g1 g24 g20 g22 g35 g1 g35 g21 g19 g37 g34 g25 g36 g40 g1 g25 g32 g19 g4 g17 g32 g36 g37 g34 g25 g30 g23 g1 g1 g17 g37 g36 g24 g21 g30 g36 g25 g19 g17 g36 g25 g31 g30 g43 g17 g37 g36 g24 g31 g34 g25 g41 g17 g36 g25 g31 g30 g1 g35 g36 g17 g36 g37 g35 g1 g29 g21 g36 g34 g25 g19 g35 g42 g29 g17 g32 g34 g21 g20 g8 g29 g32 g34 g31 g38 g25 g35 g21 g20 g1 g35 g19 g24 g21 g20 g37 g28 g25 g30 g23 g1 g22 g31 g34 g1 g25 g29 g32 g34 g31 g38 g25 g30 g23 g1 g36 g24 g21 g1 g36 g25 g29 g21 g1 g34 g21 g33 g37 g25 g34 g21 g20 g1 g22 g31 g34 g1 g17 g35 g35 g25 g23 g25 g30 g25 g30 g23 g1 g36 g17 g35 g27 g35 g1 g18 g40 g1 g4 g17 g32 g17 g19 g25 g36 g40 g14 g19 g24 g21 g20 g37 g28 g21 g34 g42 g25 g32 g19 g14 g19 g24 g21 g20 g37 g28 g25 g30 g23 g1 g25 g29 g32 g28 g21 g29 g21 g30 g36 g17 g36 g25 g31 g30 g1 g36 g31 g1 g22 g17 g19 g25 g28 g25 g17 g36 g21 g1 g20 g17 g36 g17 g1 g30 g31 g20 g21 g1 g34 g21 g19 g31 g38 g21 g34 g40 g42 g24 g20 g22 g35 g1 g14 g21 g35 g35 g25 g31 g30 g35 g1 g17 g34 g21 g1 g37 g35 g21 g20 g1 g36 g31 g1 g29 g17 g30 g17 g23 g21 g1 g17 g19 g19 g21 g35 g35 g1 g36 g31 g1 g36 g24 g21 g1 g20 g17 g36 g17 g1 g22 g25 g28 g21 g35 g42 g35 g21 g19 g37 g34 g25 g36 g40 g1 g8 g29 g32 g28 g21 g29 g21 g30 g36 g21 g20 g1 g35 g21 g35 g35 g25 g31 g30 g1 g29 g17 g30 g17 g23 g21 g29 g21 g30 g36 g1 g22 g31 g34 g1 g35 g25 g30 g23 g28 g21 g1 g35 g25 g23 g30 g44 g31 g30 g1 g22 g31 g34 g1 g7 g17 g20 g31 g31 g32 g1 g39 g21 g18 g1 g16 g8 g1 g17 g30 g20 g1 g7 g17 g20 g31 g31 g32 g1 g13 g12 g4 g24 g20 g22 g35 g29 g17 g32 g34 g21 g20 g1 g13 g3 g2 g4 g46 g42 g48 g46 g42 g48 g44 g46 g42 g48 g47 g42 g46 g2 g32 g32 g28 g25 g21 g20 g1 g13 g31 g28 g21 g1 g18 g17 g35 g21 g20 g1 g17 g37 g36 g24 g21 g30 g36 g25 g19 g17 g36 g25 g31 g30 g1 g31 g30 g1 g20 g17 g36 g17 g1 g18 g28 g31 g19 g27 g35 g1 g36 g31 g1 g21 g30 g22 g31 g34 g19 g21 g1 g17 g19 g19 g21 g35 g35 g1 g19 g31 g30 g36 g34 g31 g28 g42 g14 g19 g24 g21 g20 g37 g28 g25 g30 g23 g46 g42 g47 g52 g42 g46 g44 g46 g42 g48 g48 g42 g46 g14 g21 g35 g35 g25 g31 g30 g46 g42 g48 g46 g42 g48 g44 g46 g42 g48 g49 g42 g50 g7 g21 g17 g34 g36 g18 g21 g17 g36 g46 g42 g48 g46 g42 g46 g44 g46 g42 g48 g47 g42 g46 g8 g29 g32 g34 g31 g38 g25 g35 g21 g20 g1 g24 g21 g17 g34 g36 g18 g21 g17 g36 g1 g36 g17 g19 g36 g25 g19 g1 g36 g31 g1 g34 g21 g20 g37 g19 g21 g1 g18 g28 g31 g19 g27 g1 g34 g21 g32 g31 g34 g36 g1 g23 g21 g30 g21 g34 g17 g36 g25 g31 g30 g1 g36 g25 g29 g21 g42 g2 g37 g36 g24 g21 g30 g36 g25 g19 g17 g36 g21 g1 g46 g42 g48 g46 g42 g46 g44 g46 g42 g48 g47 g42 g46 g4 g24 g21 g19 g27 g32 g31 g25 g30 g36 g1 g46 g42 g48 g46 g42 g48 g44 g46 g42 g48 g49 g42 g46 g9 g31 g17 g20 g3 g17 g28 g17 g30 g19 g25 g30 g23 g1 g46 g42 g48 g46 g42 g48 g44 g46 g42 g48 g49 g42 g46 g7 g25 g23 g24 g1 g4 g12 g16 g1 g28 g31 g17 g20 g1 g39 g17 g35 g1 g34 g21 g35 g31 g28 g38 g21 g20 g1 g18 g40 g1 g25 g29 g32 g28 g21 g29 g21 g30 g36 g25 g30 g23 g1 g28 g31 g17 g20 g1 g18 g17 g28 g17 g30 g19 g25 g30 g23 g42 g12 g31 g31 g28 g25 g30 g23 g46 g42 g47 g50 g42 g46 g44 g46 g42 g47 g51 g42 g46 g4 g31 g30 g30 g21 g19 g36 g25 g31 g30 g1 g32 g31 g31 g28 g25 g30 g23 g1 g25 g35 g1 g25 g29 g32 g28 g21 g29 g21 g30 g36 g21 g20 g1 g36 g31 g1 g23 g21 g36 g1 g36 g24 g21 g1 g19 g28 g25 g21 g30 g36 g1 g19 g31 g30 g30 g21 g19 g36 g25 g31 g30 g1 g35 g36 g17 g36 g37 g35 g42 topic profiles as obtained from the training set see section iii d .
c. comparing generated recommendations with tactics adopted by developers recommendations were generated using our approach for all the packages in ve r s i o n i n t. recommended tactics were then compared with the design decisions made by the developers in ve r s i o n i t. to perform this comparison we matched the packages of ve r s i o n i tto the packages of ve r s i o n i n t. in many cases a direct match was possible.
in the few cases developers where re organized the packages structure we manually identified the files from ve r s i o n i tthat related to ve r s i o n i n t. this allowed us to identify which packages in ve r s i o n i n tbecame tactical in ve r s i o n i t. the results of how accurate tactics are predicted are reported in the confusion matrix of tables v and vi which provide a visual representation of recommendation results and depicts true and false positives as well as true and false negatives.
true positives are the corresponding cell of yes row and yes column indicating the predicted value matched actual value.
the matrix shows for example in case of hive there were packages involved in version .
.
out of these packages packages needed audit trail tactics and in version .
developers added this tactic.
our approach correctly recommended the audit trail tactic to one of these packages.
furthermore our approach recommended audit for two out of non tactical packages resulting in a false positive notification to the developers.
the last three rows of these two tables report recall precision and specificity the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v confusion ma trix showing results from genera ting recommenda tion for different versions of apache hive project g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g32 g30 g32 g31 g39 g32 g32 g32 g30 g32 g34 g32 g32 g36 g30 g31 g35 g30 g32 g31 g30 g32 g39 g30 g32 g33 g30 g31 g31 g31 g32 g31 g31 g32 g31 g30 g31 g31 g33 g31 g32 g33 g30 g32 g32 g7 g20 g20 g18 g16 g19 g14 g29 g26 g32 g26 g29 g27 g29 g26 g30 g30 g26 g29 g8 g3 g2 g4 g29 g26 g34 g26 g29 g27 g30 g26 g29 g26 g29 g9 g11 g15 g13 g12 g25 g18 g13 g22 g30 g26 g29 g26 g29 g27 g31 g26 g29 g26 g29 g9 g13 g23 g23 g16 g20 g19 g30 g32 g26 g30 g26 g29 g27 g30 g33 g26 g29 g26 g29 g3 g17 g8 g12 g20 g2 g25 g12 g16 g24 g1 g29 g26 g34 g27 g29 g26 g35 g2 g25 g24 g15 g13 g19 g24 g16 g11 g10 g24 g13 g1 g29 g26 g34 g27 g29 g26 g30 g33 g26 g29 g4 g15 g13 g11 g17 g21 g20 g16 g19 g24 g1 g29 g26 g34 g27 g29 g26 g35 g5 g13 g10 g22 g24 g3 g13 g10 g24 g30 g26 g29 g26 g29 g27 g31 g26 g29 g26 g29 g6 g20 g10 g12 g3 g10 g18 g10 g19 g11 g16 g19 g14 g29 g26 g30 g31 g26 g29 g27 g29 g26 g30 g33 g26 g29 g6 g18 g12 g10 g14 g13 g14 g10 g14 g21 g23 g39 g30 g26 g39 g31 g42 g39 g30 g26 g34 g38 g42 g31 g30 g30 g26 g30 g30 g42 g39 g32 g26 g33 g31 g42 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g36 g36 g26 g36 g37 g42 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g30 g26 g30 g30 g42 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g33 g33 g26 g33 g33 g42 g35 g30 g26 g30 g30 g42 g4 g19 g12 g10 g14 g20 g14 g17 g16 g5 g12 g10 g9 g15 g15 g37 g35 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g33 g33 g26 g33 g33 g42 g33 g33 g26 g33 g33 g42 g31 g30 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g36 g36 g26 g36 g37 g42 g8 g12 g20 g25 g1 g7 g9 g10 g21 g14 g10 g9 g15 g24 g1 g3 g17 g25 g1 g3 g17 g16 g27 g7 g9 g10 g21 g14 g10 g9 g15 g4 g19 g12 g11 g14 g10 g21 g12 g11 g2 g10 g21 g22 g9 g15 table vi confusion ma trix showing results from genera ting recommenda tion for different versions of apache hadoop project g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g3 g17 g8 g12 g20 g32 g32 g31 g31 g38 g31 g31 g32 g38 g34 g33 g31 g31 g33 g31 g31 g32 g32 g31 g33 g31 g31 g33 g35 g31 g33 g32 g30 g30 g31 g30 g35 g30 g32 g31 g31 g31 g31 g31 g31 g31 g31 g31 g31 g31 g31 g31 g30 g30 g26 g30 g30 g42 g6 g18 g12 g10 g14 g13 g14 g10 g14 g21 g23 g39 g35 g26 g36 g35 g42 g36 g32 g26 g30 g37 g42 g38 g37 g26 g35 g30 g42 g39 g36 g26 g38 g38 g42 g39 g36 g26 g38 g38 g42 g39 g35 g26 g36 g35 g42 g39 g36 g26 g38 g38 g42 g39 g37 g26 g32 g32 g42 g35 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g5 g12 g10 g9 g15 g15 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g31 g30 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g4 g19 g12 g10 g14 g20 g14 g17 g16 g35 g30 g26 g30 g30 g42 g33 g31 g26 g32 g35 g42 g33 g33 g26 g33 g33 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g35 g30 g26 g30 g30 g42 g8 g13 g23 g23 g16 g20 g19 g29 g26 g31 g29 g26 g31 g27 g29 g26 g31 g32 g26 g33 g3 g17 g8 g12 g20 g1 g25 g12 g16 g24 g29 g26 g30 g33 g26 g29 g27 g29 g26 g30 g34 g26 g29 g1 g25 g24 g15 g13 g19 g24 g16 g11 g10 g24 g13 g29 g26 g31 g29 g26 g31 g27 g29 g26 g31 g30 g26 g29 g3 g15 g13 g11 g17 g21 g20 g16 g19 g24 g29 g26 g31 g29 g26 g31 g27 g9 g26 g29 g26 g31 g32 g4 g13 g10 g22 g24 g2 g13 g10 g24 g29 g26 g31 g29 g26 g31 g27 g29 g26 g31 g30 g26 g29 g5 g20 g10 g12 g2 g10 g18 g10 g19 g11 g16 g19 g14 g29 g26 g31 g29 g26 g31 g27 g9 g26 g29 g26 g31 g32 g26 g29 g6 g20 g20 g18 g16 g19 g14 g29 g26 g30 g33 g27 g29 g26 g30 g34 g7 g2 g1 g3 g29 g26 g31 g29 g26 g31 g27 g29 g26 g31 g30 g26 g29 g8 g11 g15 g13 g12 g25 g18 g13 g22 g29 g26 g30 g35 g26 g29 g27 g29 g26 g31 g31 g26 g29 g4 g19 g12 g11 g14 g10 g21 g12 g11 g2 g10 g21 g22 g9 g15 g8 g12 g20 g25 g1 g7 g9 g10 g21 g14 g10 g9 g15 g24 g1 g3 g17 g25 g1 g3 g17 g16 g27 g7 g9 g10 g21 g14 g10 g9 g15 fraction of unrelated and unclassified files achieved in each case study.
specificity is computed as specificity nonrelevantrecs tru e ne ga t i ve s f alsep ositives d. comparison with a random approach the performance of our tactic recommender system has been compared with the random prediction of tactics for each case study.
we use matthews correlation coefficient mcc which is used in machine learning as a measure of evaluating prediction quality and reflects the correlation coefficient between the observed and predicted tactic recommendations mcc returns a value between and .
a coefficient of represents a perfect tactic recommendation means that the recommendation is no better than random recommendation and indicates total disagreement between recommendation and observation.
figure reports the mcc value obtained for our two case studies.
these values should be compared with zero which is the mcc value for random recommendations.
in hadoop all tactics recommended by our system performed better than the random approach.
the mann whitney u test indicates that the differences are statistically significant p value .
in hive recommendations generated for all the tactics except scheduling were better than a random approach.
our approach did not recommend the scheduling tactic to any of the hive packages achieving recall and precision of zero.
mcc tp tn fp fn radicalbig tp fp fp fn tn fp tn fn vi.
d iscussion a. answers to research questions and key findings in the introduction we outlined our goals of the study rq1 can latent topics in code predict the usage of tactics?
as shown in section iii we were able to a identify latent topics in source code and b link topics in source code to instances of implemented tactics so thatlatent topics in source code can be used to predict the usage of architectural tactics.
key finding there is a clear association between latent topics in source code and tactics implemented or not implemented in source code.
rq2 can a recommender system generate useful recommendations?
as shown in section v the recommender system was able to recommend appropriate tactics.
the results show the feasibility of developing a tactic recommender system trained using the data collected from a large number of open source systems to recommend a missing tactic for a given project.
key finding a tactic recommender system based on latent topics in source code generates recommendations which are similar to actual design decisions made by developers.
g4 g1 g7 g8 g4 g1 g9 g5 g4 g1 g10 g13 g4 g1 g6 g10 g5 g1 g4 g4 g4 g1 g12 g8 g4 g1 g12 g4 g4 g1 g4 g4 g4 g1 g10 g12 g4 g1 g10 g13 g4 g1 g8 g8 g4 g1 g9 g8 g4 g1 g8 g11 g4 g1 g8 g11 g4 g1 g8 g10 g4 g1 g8 g11 g4 g1 g8 g11 g4 g1 g11 g4 g4 g1 g4 g4 g4 g1 g5 g4 g4 g1 g6 g4 g4 g1 g7 g4 g4 g1 g8 g4 g4 g1 g9 g4 g4 g1 g10 g4 g4 g1 g11 g4 g4 g1 g12 g4 g4 g1 g13 g4 g5 g1 g4 g4 g2 g3 g4 g1 g2 g5 g6 g7 g7 g8 fig.
.
mcc values for each tactic comparing generated recommendations with random recommendations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. threats to v alidity and limitations there are several threats to the validity of this work.
internal validity first the training set for the recommender system was created using two data mining techniques the tactic classifier and lda neither of which is precise.
tactic inclusion errors i.e.
false positives were reduced by setting the threshold value for the tactic detector quite high so that only files detected with high degrees of confidence were selected.
lda was configured manually however experiments were conducted in order to find the ideal number of topics.
external validity a second threat to validity was the construction of inference algorithms and the generalizability of the recommender system.
this risk was at least partially mitigated through the use of classic n fold cross validation to evaluate the models and demonstrate generalizability.
another limitation of our approach itself is that it only includes nine tactics.
however these nine tactics were selected based on their relevance for building reliable software systems.
our approach could be expanded to cover additional tactics.
however this would require performing additional training based on source code that implements other tactics.
the case studies used for evaluation hive and hadoop both belong to the same domain which might impact the generalization of the result on different domain datasets.
construct validity finally the way tactic related topics were removed from the topic profiles in order to simulate pre tactic conditions is another threat.
if residual tactic related topics were left in the profiles then the inference model might have been trained on the vestiges of the tactics as opposed to the contextual topics found for each tactic.
we mitigated this risk by being overly zealous about the removal of tactic related topics and removing any topic that shared a term that our tactic detector had even vaguely associated with a given tactic.
furthermore we validated the efficacy of our recommender system by applying it against the versions of hive and hadoop case studies that did not implement tactics.
the results were compared with the actual decisions made by the developers in the next releases.
since the examined version did not contain a tactic our obtained results can provide higher confidence that tactic recommender provides useful recommendations.
vii.
r ela ted work this paper focused on recommending the use of architectural tactics in projects and packages.
prior work on tactic recommendation has taken a top down or requirementscentric view where architectural tactics or patterns are recommended to address specific quality concerns.
other similar top down approaches advocate a rigorous analysis of the quality requirements or quality concerns for a system or a more systematic approach to making design decisions .
in contrast our approach is driven by a study of thousands of software projects and focuses on suggesting ways to refactor existing code in order to integrate architectural tactics into an emergent design.
in a preliminary work we investigated the relationship between source code topics andtactics in erp products.
the study included over open source projects and provided empirical evidence that source code topics can predict tactics.
however this work was not systematically evaluated.
in contrast this paper uses rigorous empirical design and evaluation to investigate this issue using over open source systems.
furthermore we conduct validations using two large scale industrial systems.
refactoring existing code to improve the underlying architecture and design can mitigate the problem of architectural erosion or as a normal part of the incremental design process .
numerous authors and practitioners have described refactoring techniques however these approaches tend to focus on more general tasks such as promoting methods to classes.
.
our approach focuses on refactoring for architectural reasons by identifying areas of the code which could be improved through the introduction of proven architectural tactics.
recommender systems have been studied extensively originally within the context of e commerce systems where numerous algorithms have been developed to model user preferences and create predictions.
these algorithms vary greatly depending on the type of data they use to create the recommendations.
for example some use content information about the items collaborative data of other users ratings knowledge rules of the domain or newer highly efficient algorithms such as those based on matrix factorization .
in recent years there has been significant emphasis on the use of recommender systems to support a variety of software engineering tasks such as bug triage requirements elicitation source code reuse example recommendation and expertise discovery .
however there is little work that combines the use of recommender systems with architectural refactoring.
one exception is the work by terra et al.
who proposed a recommender system for identifying architectural violations and then suggesting steps for removing them .
finally our own prior work has focused on detecting existing tactics however the work in this paper focuses on the more difficult task of predicting packages in which tactics could be usefully employed.
viii.
c onclusions this paper has presented a first of its kind technique for recommending the placement of architectural tactics within source code packages.
in contrast to previous approaches which focus on making architectural decisions to address known quality concerns our novel approach recommends architectural tactics because a package contains a mix of topics that have previously been associated with the use of that tactic.
the results from the inference algorithms and folds crossvalidations show that clear associations exist and that these can be used to make useful tactic recommendations.
ix.
a cknowledgments this work was partially funded by the us national science foundation under grant numbers ccf and cns1629810.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.