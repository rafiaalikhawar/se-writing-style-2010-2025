theimpact ofregularexpression denialofservice redos in practice an empirical study at the ecosystemscale james c. davis virginiatech usa davisjam vt.educhristya.coghlan virginiatech usa ccogs vt.edu franciscoservant virginiatech usa fservant vt.edudongyoonlee virginiatech usa dongyoon vt.edu abstract regularexpressions regexes areapopularandpowerfulmeans of automatically manipulating text.
regexes are also an understudied denial of service vector redos .
if a regex has super linear worst case complexity an attacker may be able to trigger this complexity exhaustingthevictim scpuresourcesandcausingdenial ofservice.existing researchhas shown how to detect thesesuperlinear regexes and practitioners have identified super linear regex anti patternheuristics that mayleadto such complexity.
inthispaper weempiricallystudythreemajoraspectsofredos thathavehithertobeenunexplored theincidenceofsuper linear regexesinpractice howtheycanbeprevented andhowtheycanbe repaired.intheecosystemsoftwoofthemostpopularprogramming languages javascript and python we detected thousands of super linearregexesaffectingover10 000modulesacrossdiverse application domains.
we also found that the conventional wisdom for super linear regex anti patterns has few false negatives but many false positives these anti patterns appear to be necessary butnotsufficient signalsofsuper linearbehavior.finally wefound thatwhenfacedwithasuper linearregex developersfavorrevising itovertruncatinginputordevelopingacustomparser regardless ofwhethertheyhadbeenshownexamplesofallthreefixstrategies.
thesefindingsmotivatefurtherresearchintoredos sincemany modulesarevulnerabletoitandexistingmechanismstoavoidit are insufficient.
we believe that redosvulnerabilities are a larger threatinpracticethanmighthave been guessed.
some people when confronted with a problem think i know i ll use regularexpressions.
now theyhavetwo problems.
jamiezawinski ccs concepts softwareanditsengineering empiricalsoftwarevalidation software libraries and repositories security and privacy denial of service attacks permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
regular expressions redos catastrophicbacktracking empirical software engineering miningsoftware repositories acmreference format james c. davis christy a. coghlan francisco servant and dongyoon lee.
.theimpactofregularexpressiondenialofservice redos in practice anempiricalstudyat theecosystemscale.in proceedingsofthe 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 4 lake buena vista fl usa.
acm new york ny usa 11pages.
introduction regularexpressions regexes areapopularandpowerfulmeansof automatically manipulating text.
they have been applied in a large variety of application domains e.g.
data validation data scraping andsyntaxhighlighting andareastandardtopicinpractical programming texts .
unfortunately inmostpopularprogramminglanguages regexes also form an understudied denial of service vector regular expressiondenialofservice redos .forexample in2016redos led to an outage at stackoverflow and rendered vulnerable any websites built with the popular express.js framework .
redos attacks are possible because many popular languages including javascript v8 node.js python java c c mono php perl and ruby rely on a regex engine with worst case superlinearbehavior slbehavior .whentheseregexenginesevaluate super linear regexes sl regexes against malign input the evaluation takes polynomial or exponential time in the length of the input andthehigh complexityevaluationoverloadstheserverand denies service to otherclients.
redos attacks were first proposed by crosby in .
in the years since then we have seen advances in detecting sl regexes aswellastheintroductionoflanguagelevel and engine level defenses against sl behavior.
others have provided conventional wisdom about sl regex antipatterns i.e.
heuristicstoidentifyformsofaregexthatareexpected tobeparticularlyrisky .missing however isanempirical assessmentoftheincidenceofslregexesinpractice.simplyput we do not know whether redos is a parlour trick or a security vulnerabilitycommon enough to meritfurther research.
christy a. coghlan isnowemployed by google inc. esec fse november4 lake buena vista fl usa j.c.davis c.a.coghlan f.servant andd.lee in this paper we perform the first large scale empirical study to understand the extent of sl regexes in practice as well as the mechanisms that could be used to identify and repair them.
we analyzetheecosystemsoftwoofthemostpopularprogramming languages to understand the incidence of sl regexes.
our study coversthenode.js javascript andpythoncorelibraries aswell as over of the modules in the npm andpypi moduleregistries.wealsostudyreportsofredosintheseregistries to understandthe fixes that developers providefor sl regexes.
we found that sl regexes are rather common they appear in the core node.js and python libraries as well as in thousands of modules in the npm and pypi registries including popular moduleswithmillionsofdownloadspermonth.wefoundover4 uniqueslregexesacrossnpmandpypi coveringawiderangeof application domains.
furthermore nearly of these regexes are high risk because they have exponential complexity.
we disclosed tomaintainersthepresenceofslregexesin284modules ofwhich have been repaired so far.
we found that developers repair sl regexesusingoneofthreetechniques trimmingtheinput revising the regex or replacing it with alternate logic.
among these techniques revising the regex was the most common regardless of whether developers were previously aware ofthe others.
this paper providesthe following contributions we provide an empirical understanding of the extent .
seriousness .
and distribution across application domains .
oftheincidenceofslregexesintwoprominentsoftwareecosystems node.js andpython.
we provide an empirical understanding of the effectiveness of the conventional wisdom regarding sl regex anti patterns .
.
we provide an empirical understanding of the strategies that developers use to fixsl regexes .
background in this section we review the behavior of sl regexes their applicationto redos andexisting techniques to addressthem.
.
super linear sl regexengines regex enginesaccept a regexdescribinga language andan input tobetestedformembershipinthislanguage.atthecoreofmost regexenginesisabacktracking basedsearchalgorithmliketheone describedbyspencer .abacktrackingregexengine constructs a non deterministic finite automaton nfa from the regex and thensimulatesthenfaontheinput .thestateofthenfais represented by a tuple its current vertex in the graph and its currentoffsetintheinput.tosimulatenon determinism whenever theenginemakesachoiceitpushesthecurrentnfastateontoa stackofdecisionpoints.ifamismatchoccurs theenginebacktracks to a previous decision point to try another choice.
this process continues until the engine finds a match or exhausts the set of decisionpoints.sinceeachstepofannfaevaluationtakesconstant time thecomplexityofanevaluationcorrespondstothenumber ofstates that are explored.
a backtracking regex engine may have large worst case complexityifitdoesnottakecaretoavoidredundantstateexploration1.
1slfeatureslikebackreferencesareanothersourceofslworst casecomplexity.sl behavioras a result of these featuresis out of the scopeof thiswork.
a railroaddiagram .
ws o 1path n states below ws o paths n states below ws o ws o ws o paths n states below ws o b nfa execution diagram excerpt .
figure diagramsfor s ?
s on maligninput.
to illustrate suppose that two choices from a decision point reach thesamenfastate.sincefromthisstateafixedsetofstateswill be explored this mutual state need be explored only once .
however ifnomatchisfoundthenanincautiousenginewillexploreittwice oncefromeachpathfromthedecisionpointtothe mutual state.
in the extreme this canlead to super linear behavior slbehavior whentheevaluationcomplexity i.e.
thetotalnumber of explored states is polynomial or exponential in the input length.
sl behaviorisalsoknownas catastrophic backtracking.
slbehaviorwillonlyoccurwhenabacktrackingregexengine evaluates an sl regexonamalign input .amaligninput hasthree components aprefixstring apumpstring andasuffixstring2.the prefixbringsthenfatoasetofstatesfromwhichredundantexploration becomes possible ambiguous states .
each repetition of thepumpyields a decision point whose complete exploration containsredundantstates.afinal suffixensuresthattheregexwillnot matchthe input forcing the regexengine to explore polynomially orexponentially manyredundant states duringbacktracking.
.
example anslregexin python core for a detailed example of an sl regex consider the regex represented in figure 1a.
we discovered this regex in the python core librarydifflib cve .maligninputforthisregexconsists of the empty prefix a pump of any whitespace and a suffix of any non whitespace .
onthis maligninput abacktracking regexengine willperform ano n2 doubly nested traversal of the input as illustrated infigure 1b.wheninthefirstwhitespacevertexws eachofthe npumpsisadecisionpoint thenfachooseswhethertoremainor to advance to the second whitespace vertex ws by skipping the optional vertex.whenthesuffixcausesamismatch theregex engine tries the other choice.
as a result the nfa will reach the ws vertex ntimes and each move willoccur ata different nfa state same vertex different offset .
when the nfa advances at offseti it willredundantly explore states ws o i through ws o n since these are also explored after the nfa advances at earlier offsets.
thus the engine will visit each of the ws o i statesonce andeachofthe ws o j statesjtimes foratotal of n ... n o n2 visitedstates.
.
usingslbehavior forredos backtracking regex engines can be used as a denial of service vector.
regular expression denial of service redos attacks use an sl 2malign input maycontainmultiple pairs of prefixes and pumps.
247the impactofredosin practice esec fse november4 lake buena vista fl usa regexquerytoconsumethecpuofaserver reducingthenumberof clientsitcanservice .redosattackshavefourrequirements.
first the victim must use a backtracking regex engine.
second thevictimmustuseanslregex.
third thevictimmustevaluate malign user input against this regex without any resource limitations e.g.
a timeout .
fourth the victim must be running on the server side.
if all four conditions are met an attacker carries out a redos exploit by sending malign input to the victim to be evaluatedagainstitsslregex triggeringslbehaviorthatwastes server resources reducing the cpuavailable to otherclients.
.
mechanisms to preventslbehavior the practitioner community has explored three approaches to preventing sl behavior abortive backtracking disallowing backtrackingaltogether andavoidingsl regex anti patterns.
abortive backtracking.
somemainstreamlanguagesdefenddevelopers against sl regex engine behavior.
the .net framework addedoptionalregextimeoutsin2012 andthephpandperl enginesthrowexceptions if they perceive toomuchbacktracking.
non backtracking engines.
a more radical approach is to use thelinear timeregexevaluationalgorithmdevelopedbythompson thoughthisrequiresdeviatingfromtheperl compatible regularexpressions pcre standardsupportedbymanylanguages3.
thisapproach waspopularizedbycoxin2007 andhas since been adoptedbyrust andgo .
avoidinganti patterns.
severaloftheprofessionalreferencetexts on regexes suggest sl regex anti patterns developers should avoid nested quantifiers star height and more generallyshould watchoutwhen... partsofthe can match the same text .
although this advice is vague avoiding sl regexes is the only cross language technique available to practitioners.
timeouts and linear time engines are luxuries not availableeverywhere sopractitionersmustbereadytoaddressthe worst case behaviorofthe regexesintheircodebases.
research questions our goal in this study is to understand redos vulnerabilities in practice across three themes their incidence in practice how they canbeprevented andhowtheycanbefixed.inparticular wefocus ourinvestigationonstudyingslregexes whichcanbeexploitedto cause redos.
we ask seven research questions along these themes.
first we study the incidence of sl regexes in practice to understandtowhatextentredosisaseriousvulnerabilityaffectingmany differentkindsofsoftwareprojects.theanswertothisinvestigation willhelpusunderstandthe importanceofredosvulnerabilities.
second we study whether sl regex anti patterns do in fact signal sl regexes.
as we discussed in .
avoiding sl regex antipatterns is the only cross language mechanism used in practice to prevent redos but this approach is not yet evidence based.
in this investigation we checkthe validity ofthis conventional wisdom.
third westudyhowredosvulnerabilitiesarefixedinpractice.
alackofunderstandingoftherightstrategiestofixslregexesisa seriousgapintheresearchliterature.webridgethisgapbystudying 3inparticular alinear timeengineprecludesgeneralsupportforfundamentallysuperlinearfeatureslike backreferences and lookaround assertions.howdevelopersarefixingredosvulnerabilitiesinpractice.this empiricalunderstandingwillallowotherdeveloperstoreusethe wisdomoftheexpertsthatarealreadyfixingredosvulnerabilities.
theme1 understandingtheincidenceofredosinpractice.
rq1 howprevalentare sl regexesinpractice?
rq2 howstrongly vulnerable are the sl regexes?
rq3 whichapplicationdomainsdo sl regexesaffect?
theme2 preventingredos.
rq4 dosl regex anti patternssignal sl regexes?
theme3 fixing redos.
rq5 howhave developers fixedredosvulnerabilities?
rq6 howwoulddevelopersfixredosvulnerabilitiesiftheyknew allofthe currently appliedapproaches?
rq7 howeffective are the fixes that developers adopt?
theme1 understandingthe incidenceofredosinpractice .
rq1 howprevalent areslregexesin practice?
to date there have been a small number of reports of sl regexes leadingtoredosinthewild whichwediscussindepthin .how many more remain undiscovered?
in this section we present the firstsystematic study ofthe incidence of sl regexesinpractice.
.
.
methodology.
inbrief thisishow wemeasuredtheincidenceofslregexesinthewild.weusedstaticanalysistoextract all the regexes used in the node.js and python core libraries as well as more thanhalf of the modules in the npm javascript and pypi python registries.
we applied sl regex detectors to filter for potentially slregexes andconcludedwithadynamicvalidation phaseto prove that aregex wasactually vulnerable.
software.
wechose javascript asourprimarylanguageofinterest for two reasons.
first as others have observed redosvulnerabilities injavascript are particularly impactful because javascript frameworks use a single threaded event based architecture.aredosattackonanode.jsserverimmediatelyreduces the throughput to zero.
second javascript has a huge developer base there are more open source libraries for javascript than any otherlanguage.
the registryof javascriptmodules npm has over modules more than double the size of the next closestregistry java maven .togaugethegenerality ofour results wealsostudied python anotherpopularscriptinglanguage whosepypi registry contains modules.
the source code in software ecosystems can be divided into the languagecore platform 3rd partylibraries andapplications .
whileapplicationsaredifficulttoenumerate inmodernecosystems thelanguagecoreand3rd partylibrariesaregenerallyopen source and3rd partylibrariesareconvenientlyorganizedinaregistrythat tracksmetadatalikewhere tofindthemodule s sourcecode.
as a result westudiedtheincidenceofslregexesineachlanguage s core libraries and3rd partymoduleslistedinthe registries.
for each language s core we tested each supported version.
for 3rd partylibraries weexaminedthemasterbranchofeverymodule listedinthenpmandpypiregistriesthathadaurlonwhichwe could run git clone .
we chose not to use the packaged version of 248esec fse november4 lake buena vista fl usa j.c.davis c.a.coghlan f.servant andd.lee modules provided by the registries because these are sometimes packed minified or otherwise obfuscated in ways that complicate analysis attribution andvulnerabilityreporting.
extractingregexes.
aftercloningeachmodule westaticallyextracted its regexes.
we cloned the latest master branch with no historytominimizetheimpactonthevcshostingservice.then we scanned it for source code based on file extensions .jsor.py .
we built an abstract syntax tree ast from each source file using babylon for javascript files and the python ast api for python files.
walking the asts we identified every regex declaration and extractedthepattern skippinganyusesofdynamicpatterns.excluding these dynamic patterns means our results provide lower bounds onthe number ofsl regexes.
identifyingslregexes.
afterextractingtheregexesusedineach moduleunderstudy wecreatedamappingfromuniquepatternsto the modulesusing them.we then analyzedtheseunique patterns.
our sl regex identification process has a static detection phase andadynamic validationphase.forthe static detection phase we queried all three of the sl regex detectors developed in previous work rxxr2 regex static analysis andrexploiter .
these detectors use different algorithms to report whether or not a regex may exhibit super linear behavior and if so will recommend malign input to trigger it.
our static phase collects each detector s opinionand producesasummary.
thedetectors mostfrequently regex static analysis mayconsumeexcessivetimeormemoryin makingtheirdecision sowelimitedthedetectorsto5minutesand 1gbofmemoryoneachregexanddiscardedunansweredqueries.
thesesl regexdetectorsare researchprototypes so theydonot support allregex features norguarantee correctness.
our dynamic validation phase uses this summary to test the accuracyofeachdetector spredictionfortheregexengineofthe languageofinterest.thedetectorsfollowdifferentalgorithmsbased on assumptions about the implementation of the regex engine and theseassumptionsmayormaynotholdineachlanguageofinterest.
to validate a detector s predicted malign input our validator tests this malign input on the possibly sl regex in small node.js and pythonapplicationswe created.
thisishowweidentified slregexes .topermitdifferentiating regexesbytheirdegreeofvulnerability .
wemeasuredhow long each regex took to match a sequence of malign inputs with varyingnumbersofpumps.webeganwithonepumpandfollowed ageometricsequencewithafactorof1.
roundingup.wetested 100inputs thelastwith85 615pumps andmarkedtheregexsuperlinear if the regex match took more than seconds on a match as this is far longer than a linear time regex match would take.
we stopped at pumps for two reasons.
first this number wassufficienttocausesuper linearcomplexitytomanifestwithout beingattributabletotheoverheadsofenormousstrings.second this manypumpsresultsinmaligninputs100k 1mcharacterslong long enoughtobecomepotentiallyexpensiveforattackerstoexploit.we distributed this analysis and ran multiple tests on each machine in parallel dedicatingonecoretoeachtestwith taskset toremove computationalinterference between co locatedtests.table1 resultsofoursearchforslregexesinthenpmand pypi module registries.
troublingly of unique regexes were sl regexes affecting over10 modules.
registry total modulesscanned modulesunique regexessl regexesaffected modules npm pypi .
.
results.
wefoundthatslregexesaresurprisinglycommon inpractice.
the node.js and python core libraries bothcontained sl regexes and about of all unique regexes in both npm andpypiwereslregexes.inall ofnpmmodulesand1 ofpypi modulescontainedat leastone sl regex.
language core.
we found one sl regex in the core libraries of node.js server sidejavascript .thecurrentlysupportedversions of node.js are v4 v6 v8 and v9.
we scanned the core libraries lib ofeachoftheseversions.inv4weidentifiedanddisclosed two sl regexes used to parse unix and windows file paths.
these regexes had been removed for performance reasons in v6 so the other versions of node were not affected.
this vulnerability was publishedas cve andfixedbythe node.js core team.
wefoundthreeslregexesinthecorelibrariesofpython.the currently supported versions of python are v2 and v3.
we scanned the core libraries libs ofeach oftheseversions.
bothversions shared two sl regexes one in popliband one in difflib.
we identified an additional vulnerability in the v2.
.
fpformat library.
thesevulnerabilitieswerepublishedascve 1060andcve2018 we authoredthe patches.
third party modules.
table1summarizes the results of our registry analysis.
we were able to clone of npm modules and58 ofpypi 750modules .inthissampleofeachregistrywe foundthatabout1 ofthe uniqueregexeswereslregexes innpm and704inpypi .
figure2summarizes two different distributions in the npm and pypidatasetsusingcumulativedistributionfunctions cdfs .the dotted lines show the distribution of the number of unique regexes ineachmodule.wecanseethatmorethan30 ofnpmandpypi modules use at least one regex and that npm modules tend to contain more unique regexes than pypi modules do.
the solid lines show the distribution of the number of modules each sl regex appears in in the npm registry some sl regexes appear in hundreds or thousands of modules while in the pypi registry the most ubiquitous sl regexesare only usedinabout50 modules.
to give a sense of how impactful these sl regexes might be for eachmoduleweobtainedthepopularity registrydownloads month andcomputedtheprojectsizebasedonthesourcefileswescanned usingcloc .
modules with sl regexes are indicated in black in figure npm and figure pypi .
in both registries larger modules are more likely to contain sl regexes and sl regexes are slightly more common inmoduleswithlower download rates.
249the impactofredosin practice esec fse november4 lake buena vista fl usa figure2 thisfigureshowstwocdfs.thedottedlinesindicate the distribution of the number of unique regexes used in modules while the solid lines show the distribution of the number of modules affected by sl regexes.
note the log scaleon thex axis.
figure3 npmmodulesbysizeandpopularity log log .the 018moduleswithslregexesareinblack.notethe trivial packages on theleft side .
figure4 pypimodulesbysizeandpopularity log log .the moduleswith sl regexes are inblack.
.
rq2 howstrongly vulnerable arethesl regexes?
from a developer perspective sl regexeswhose super linear behaviormanifestsonshortermaligninputsareofgreaterconcern thanthoseonlyaffectedbylongermaligninputs.longermalign inputs could be prevented by other parts of the software stack e.g.
table this table shows the degree of vulnerabilities in the npm and pypi datasets.
the polynomial vulnerabilities are further broken down by the degree of the polynomial b which we rounded to the nearest integer.
this excluded someregexeswhosepolynomialdegreeroundeddownto1.
degree of vulnerabilitynpm 589vulns pypi vulns exponential o 2n polynomial o n2 polynomial o n3 polynomial o n4 polynomial o nb limitsonhttpheaders whileshortmaligninputsmayonlybe preventedbymodificationsto the vulnerable software itself.
in thissectionwe refineour definition ofsl regexes differentiating between exponential andpolynomial vulnerabilities.
.
.
methodology.
whilethedegreeofvulnerabilityofansl regexmight be predictedbystaticanalysis weare notconfident of the accuracy of such a prediction since it is not tied to a particularregexengineimplementation.thus weusedcurvefitting to differentiate between exponential and polynomial sl regexes.
asdiscussedin .
ourdynamicvalidationstepteststhematch time of the appropriate regex engine javascript v8 or python on a sequence of malign inputs with a geometrically increasing numberofpumps.
we measuredthetimethat it took tocomputeeach match.wethenfitthetimetakenfordifferentnumbersofpumps against both exponential f x abx and polynomial power law f x axb curvesandwechosethecurvethatprovidedthebetter fit byr2value.
when the malign inputs from the different sl regex detectorsresultedindifferentcurves weusedthesteepest deadliest curve.
as in .
.
we distributed the work across multiple machines.
as result the multiplicative factors of the curves a are not comparable but the basesorexponents b are.
thisanalysisallowsustocreateahierarchyofvulnerabilities.
exponential sl regexes are more vulnerable than polynomial sl regexes because the number of pumps length of malign input requiredtoachievenoticeabledelaysissmaller.forthesamereason among polynomial sl regexes those with larger bvalues are more vulnerable than those with smaller bvalues.
the curve type and thebvalues influence the degree of vulnerability more strongly thantheavalues.
.
.
results.
a breakdown of the regexes by their degree of vulnerability is in table .
exponential sl regexes were rare in both registries only of the sl regexes from npm and of thosefrompypiwereexponential.themajorityoftheslregexes in both registries were polynomial tending to o n2 ando n3 .
thisfindinghasimplicationsforslregexdetectorsaswellasfor software developers.
for detecting sl regexes.
therxxr2redos detector only looksforexponentialslregexes.sotoodotwooftheslregexantipatterns of conventional wisdom star height and qad discussed in 5.
.theseapproachestodetectingslregexeswillthusmiss about90 ofsl regexes.
250esec fse november4 lake buena vista fl usa j.c.davis c.a.coghlan f.servant andd.lee table proposed common semantic meanings for regexes.
the examples are automatically labeled sl regexes from our npm dataset.
the last two columns are the number of regexeslabeledwitheachsemanticmeaninginournpmand pypidatasets.
meaning example npm pypi errormessages no such file .
.
file names .json html href .
.css ?v .
?
?
url .
naming convention source code function.
?
.
?
s s user agentstrings chrome ?
.
whitespace n s number d d .
d email s s .
w classificationrate forworkingwithregexes.
thesuper linearbehaviorofpolynomialregexestypicallymanifestsformaligninputsontheorderof manyhundredsorthousandsofcharacterslong.suchstringsare oftenlongerthananylegitimatestrings asisthecaseforstrings withmany ofthe semantic meanings listedin table 4. .
thus rejectingtoo longstringsbeforetestingthemagainstaregexwould beacheapandeffectivedefenseapproachandshouldbeconsidered as abestpracticewhen writing regexes.
.
rq3 which applicationdomains do sl regexesaffect?
regexesareusedinavarietyofapplicationdomains.fromourown experienceinwritingregexes andfromamanualanalysisof400 regexusesinnpmmodules wepositthatdevelopersoftenwrite regexes with one of the semantic meanings listed in table .
these semanticmeaningsmaybeofinterestinsomeapplicationdomains but not others.
for example we imagine that identifying source codeornamingconventionsisthedomainoflintersandcompilers thatwebserversaremoreinterestedinidentifyinghtmlanduseragentstrings andthatserversorscriptsmaybepreparedtochange theirbehaviorbasedonthe errormessagesthat they encounter.
.
.
methodology.
in this section we describe our techniques toautomaticallycategorizeregexesintothesesemanticgroups.we began by manually labeling the semantic meaning of regex usage examples based on inspection of the regex itself as well as howitwasusedintheproject s inwhichwefoundit.although someoftheregexesweencounteredwereobscureandtheirpurpose couldonlybeidentifiedbylookingforcommentsandotherclues in the surrounding source code it became clear to us that many regexes with the semantic meanings listed in table 3could be automatically classified.
there were unique regexes among these400examples andwefoundthattheduplicatedregexeswere always used with the same semantic meaning in different modules.
we developed an automatic labeling scheme that uses a combinationofparsingand meta regexes tolabelregexesbasedon the proposed semantic meanings.
for example here is a simplified versionofourmeta regextolabelregexesasdescribingwhitespace ?
s n t ?
thissimplifiedregexlooksforastring regexpattern containing only whitespace characters as well as meta characters that might be used to anchor the pattern and or to encode varying quantitiesofwhitespace etc.
.
we iteratively improved our regex labeler.
in each iteration we labeledarandomlyselectedsubsetof10 000regexesfrom our npm regex dataset.
we manually examined of the regexes assignedtoeachsemanticmeaning.oneormorerepresentativesof anymis labeledregexeswereaddedtoatestsuite andtheiteration was complete once the regex labeler correctly identified all the regexesinthe suite.
thisprocessresultedinapreciseregexlabelerforregexesthat are reasonably specific.
as you might expect based on how we derived it our labeler works well for easy to classify regexes that restrict the inputto something close to the expectedlanguage.
werefinedourlabelerthrough17iterations.attheconclusion ofthisprocessourtestsuitecontained358regexes andwewere reasonably confident in its precision.
we then applied it to our npm and pypi datasets.
irrespective of whether our list of semantic meaningsforregexesiscomplete itservesthegoalofstudyinghow differentdomainsmaybeaffectedbyredos.
weleavethesearch for acomplete listofregex semantic meaningsto future work.
.
.
results.
first assummarizedintable wefoundregexes inallofthesedomainsinbothnpmandpypi.second somesemantic meanings are more prone to being expressed with sl regexes than others.ascanbeseeninfigure developersshouldbecautious whenwritingregexesforemails user agentstrings sourcecode andhtml.
figure percent of sl regexes from the npm and pypi datasets within eachsemantic meaning.
theme2 preventing redos though we used detectors to identify sl regexes in .
.
these detectors are academic prototypes not ready for use in production.
on the other hand software developers already have conventional wisdomaboutwhatmakesaregexsuper linear.ifthisconventional wisdom is accurate then publicizing it may be an effective path to preventing redosbyidentifying andeliminating sl regexes.
251the impactofredosin practice esec fse november4 lake buena vista fl usa .
rq4 doslregexanti patterns signal sl regexes?
in 2we mentioned several sl regex anti patterns avoid nested quantifiers andavoidregexeswithambiguity.inthissectionwe testtwoaspectsofthisconventionalwisdom.first weevaluatethe extenttowhichtheseslregexanti patternsappear inslregexes are these anti patterns a necessary condition for sl behavior?
second we measure the extent to which these anti patterns also appearinsaferegexes todeterminewhethertheseanti patterns are asufficient condition for sl behavior.
.
.
methodology.
three sl regex anti patterns.
we know ofthreeslregexanti patterns.in .4weintroducedthetwosl regexanti patternsdiscussedinreferencetextsonregexes.thefirst star height isdiscussedin many places including .the second is rather more vague watch out when... parts of the can match the same text .
we identified two distinct ways that such ambiguity arose in our sl regex corpora yielding three totalanti patterns.
the first anti pattern is star height i.e.
nested quantifiers.
thisleadstoslbehaviorwhenthesamestringcanbeconsumedby an inner quantifier or the outer one as is the case for the string a in the regex a .
in this case the star height of two results in two choices for each pump with worst case exponential behavior on a mismatch.
this anti pattern is commonly used in practice throughthe safe regex tool .
the second anti pattern is a form of ambiguity that we call quantified overlapping disjunction qod .
an example of this anti pattern is w d .
here we have a quantified disjunction ... ... whose two nodes overlap in the digits .
onapumpstringofadigittherearetwochoicesofwhichgroup to use withworst case exponential behavioronamismatch.
the third anti pattern is another form of ambiguity that we callquantifiedoverlappingadjacency qoa .wegaveadetailed example of this anti pattern in .
s .
s .
the two quantified s nodes overlap and are adjacent because one can be reachedfromtheotherbyskippingtheoptionaloctothorpe.this anti patternhas worst case polynomialbehavioronamismatch.
testingfortheanti patterns.
weimplementedtestsforthepresenceoftheseanti patternsusingthe regexp tree regexastgenerator .tomeasure starheight wetraversetheastandmaintain acounterforeachlayerofnestedquantifier andrangeswhere theupper boundis atleast .
to detect qodwe search the ast for quantified disjunctions.
when we find them we enumerate the unicoderangesofeachmemberofthedisjunctionandtestforoverlap.todetect qoawesearchtheastforquantifiednodes.from eachnodewewalkforwardlookingforareachablequantifiedadjacent node withan overlapping set ofcharacters stopping at the earliestof aquantifiedoverlappingnode qoa anon overlapping non optionalnode noqoa ortheendofthenodes noqoa .for qodandqoaourprototypeonlyconsidersnodescontainingindividualquantifiedcharacters e.g.
d or .
not ab .in 4thesafe regex tool is implemented incorrectly so we used our own implementation.
wehaveprovided a patchto the authorof safe regex .
5groupswith lower quantifications do not readilyexhibitsuper linear behavior.table utility of the sl regex anti patterns as measured by our tools.
for each anti pattern we present the number of sl regexes that had this pattern in each ecosystem and then the false positive rate.
for the false positive rate we rely on the sl regex detectors .
.
as ground truth.
for example in npm of the sl regexes had star height but94 oftheregexeswithstarheight 1werelinear time.
as some regexes have multiple anti patterns the final row eliminates double counting.
antipatternnumber of sl regexes false positiverate npm pypi npm pypi starheight qod qoa totals keeping with the conventional wisdom none ofour tests includes acheckfor amismatch triggering suffix.
.
.
results.
the resultsofapplying our anti pattern teststo ournpmandpypiregexdatasetsareshownintable .whilewe found at least one anti patternin most of the sl regexes we also found many false positives anti patterns in safe regexes.
columns2and3showthattheconventionalwisdomofslregex anti patterns appears to supply the necessary conditions for sl behavior.
our tools found these anti patterns in over of the sl regexesinbothecosystems.amongtheslregexes the polynomial qoaanti patternwasmorecommonthanthe exponential others agreeing with our earlier finding that polynomial sl regexes are more common than exponential sl regexes .
not all sl regexeswere labeled.wemanuallyinspected arandomsampleof of the unlabeled npm sl regexes and confirmed that of them containedoneor more ofthese anti patterns using constructions toocomplex for our currentanti patterntest toolsto detect.
however theseanti patternsareclearlynotsufficienttomake an sl regex.
our tools exhibit high false positive rates as columns 4and5show onlyasmallfractionoftheregexeswiththeseantipatterns were sl regexesineitherecosystem.
theme3 fixing redos .
rq5 howhavedevelopersfixedredos vulnerabilities?
here we provide the first characterization of the fix approaches developershavetakenwhenaddressingredosvulnerabilities.this study tells us which fix strategies developers currently use setting thestageforafollow upstudy .
ofwhichfixstrategiesdevelopersprefer.inaddition understandingthefixapproachesdevelopers generally take is a first step towards several promising research directions.
for example researchers interested in automatically repairingredosvulnerabilitieswillbenefitfromknowingwhich types ofpatchesdevelopers mightbe willing to apply.
.
.
methodology.
we were interested in thorough reports describing sl regexes and how developers fixed them.
we thus searched for redos in security databases using the keywords catastrophic backtracking redos and regular expression denial 252esec fse november4 lake buena vista fl usa j.c.davis c.a.coghlan f.servant andd.lee table examples of the fix strategies for an sl regex we reported in django cve .
this regex detects an email according to both the source code and our regex labeler .
.thedeveloperschosetofixthisredosvulnerability usingthealgorithm described in replace .
example original s s .
s trim if input.length throwerror else test withexisting regex revise .
replace custom parser exactly one must occur at neitherendofthestring theremustbea .
to the right ofthe but not immediately so.
ofservice .wesearchedboththecvedatabase andthesnyk.io database .
we used any reports with two properties the reportusedthedefinitionofredosgivenin .
and thevulnerability wasfixedandthe report includedalink.
foreachvulnerabilityreport wemanuallycategorizedthefix strategythedeveloperstook.ifafixusedmorethanonestrategy e.g.
bothtrimandrevise wecounteditundereachoftheused strategies.
.
.
results.
redos reports.
we identified unique historic redos reports condition across the cve and snyk.io databases.theearliestreportwasfrom2007andthemostrecent from2018.
ofthesereportsincludedfixes condition .threeof these reports were unique to the cve database were unique to the snyk.iodatabase and7appearedinboth databases.
fix strategies.
three fixstrategies were typicalinthesereports.
trim leave the regex alone but limit the size of the input to bound the amount ofbacktracking.
revise changethe regex.
replace replace the regex with an alternative strategy e.g.
writing acustomparser orusing alibrary.
table5gives an example of each fix strategy.
only the revise strategy was discussed in any of the reference texts on regexes we reviewed .
table6summarizes the results from this study as well as the subsequentstudiesonnewfixes .
and onfixcorrectness .
.
inthefirstrow wecanseethatdevelopersinthehistoricdataset commonly trimmed revised or replaced each more than20 of the time.
.
rq6 howwould developersfix redos vulnerabilities if theyknewall ofthe currently appliedapproaches?
in 6.1we described the three common fix strategies developers used in the historic redos reports.
however we do not know whetherthesedeveloperskneweverystrategy andthuswecannot be sure that they preferred one strategy over another.
next we describethefixstrategiestakenbydeveloperswhowerefullyaware ofallofthe strategies.
6snyk.io s database tracks vulnerabilities in popular module registries including npm and pypi.table6 fixapproachestakentoaddressslregexes inboth the historic and new datasets.
examples of each approach are given in table .
some of the new fixes used more than onestrategy.
trim revise replace total historicfix approach unsafe fixes newfix approach unsafe fixes .
.
methodology.
tolearnwhatfixstrategiesdeveloperswould take ifthey knew alloftheoptions we neededtoconvince asizable group of developers to fix sl regexes.
because we felt that the maintainers of popular modules would be more likely to fix problems therein we examined the use of sl regexes in all npm and pypi modules downloaded more than times per month cf.
figures 3and4for the effect of this filter .
we filtered these modules for those whose sl regex es were clearly a redos vector based on a manual inspection and contacted the maintainers of thosemodulesbyemail.
inourdisclosures weincludedadescriptionofthevulnerability theslregex es andthefilesinwhichtheylay thedegreeof vulnerability .
foreachregex eachmaligninput withprefix pump andsuffix and thelengthofanattackstringleadingto a10 secondtimeoutonadesktop classmachine.tofacilitateour experiment we also included a description of the three fix strategiesweobservedinthehistoricdata withlinksto twopatchesfor each.
.
.
results.
after applying our two stage filter we disclosed vulnerabilities across both ecosystems to the module maintainers.
of our disclosures have resulted in fixes so far.
prominentprojects that applied fixesbased onour reportsinclude the hapi and django web frameworks and the mongodb database.
the fix strategies the maintainers chose are shown in table .
comparedtothehistoricfixstrategies developersexposedtoexamples of all three fix strategies still preferred revise to trim.
the use of revise rose from to while the use of trim fell from to .
the use of replace remained around .
clearly these developerspreferredrevisewhentheyconsideredallthreechoices.
.
rq7 howeffectivearethefixesthat developersadopt?
any one of fixstrategies intable 5can go awry.
to trim developersmustsolveagoldilocksproblem trimtooshortandvalidinput will be rejected trim too long and the vulnerability will remain.
to revise developersmustcraftalinear timeregexthatmatchesa languagecloseenoughtotheoriginalthattheirapiscontinueto work.
lastly to replace developers must write a parser for the inputthat matches an equivalentorrelatedlanguage.
in this study we examine the correctness of developers fixes.
.
.
methodology.
here is our fix safety classification scheme.
we called a trimfix unsafe if the maximum allowed input length can still trigger a noticeable slowdown.
we compared the input limit to the lengths of malign inputs derived using the sl regex identification procedure from .
.
we calleda revisefixunsafeif 253the impactofredosin practice esec fse november4 lake buena vista fl usa it was labeled vulnerable by our sl regex identification procedure.
we called a replace fix unsafe if the replacement logic was superlinearincomplexitybasedonmanual inspection.
.
.
results.
our findings forthe effectivenessof the historic and new fixes are summarized in table .
several of the historic fixes were incorrect.
the new fixes were uniformly correct nearly alldevelopersaskedus to reviewtheir fixes before publishingtheir changes .
trim.1ofthe8historictrimfixeswasunsafe.theinitialchoiceof lengthlimitwastoogenerousandtheregexremainedvulnerablefor two years before this was discovered and the length limit lowered.
revise.2ofthe18historicfixesresultedinarevised butstillsl regex.
one ofthese was replaced before our study.
as a testament totheeffectivenessofourapproach wediscoveredtheotherin .
and disclosed it in .2before performing this portion of our study.
replace.
we manually inspected the fixes that used the replace strategy to gauge their complexity.
all appeared sound relying on one ormore linearscans ofthe input.
testing their fixes.
regardlessofthefixstrategy developersdid not usually include test cases for their changes.
in the historic dataset of the fixes included tests.
in the new dataset of the fixes includedtests.
discussion and recommendations webelieveitisclearfromourfindingsthatredosisnotaniche concern but a potentially common security vulnerability.
given the number variety and ubiquity of sl regexes that we found we believe that developers should not be left to theirowndevices.
makeregexengineslesspronetoslbehavior.
wesuggestthat languagedevelopersworkwithregexenginedeveloperstoprovide applicationdeveloperswithreasonableguaranteesabouttheworstcase performance of their regexes.
this guarantee might be on the computational complexity of the operation as rust and go offer though developers have access7.
the guarantee might instead be about the total amount of backtracking experienced as in perl and php or aboutthetotalamountoftimethatmightbespentinaregexquery as the .netframework optionallysupports .
degrees of vulnerability.
differentiating between exponential andpolynomialslregexesgivesdevelopersinsightintovalidfix approaches.
trimming is a possible fix strategy for polynomial sl regexes but not for exponential ones.
but make no mistake polynomialvulnerabilitiescanbejustasdisastrous.thereislittle difference in the cost for attackers to send malign inputs of charactersor10 solongastheyaccomplishtheiraimofdenying service to legitimate users.
experiences fixing sl regexes.
in addition to the fixes from module maintainers we submitted fixes when maintainers asked usforhelp.ourownexperiencesmayilluminatesomeofthefactors that developers will consider when selecting a fix strategy though we believe this tooisapromisingdirection for future research.
7in our npm and pypi datasets however these features are rarely used.
of theuniquenpmregexes and58 800oftheuniquepypiregexes useonly linear timefeatures.the fix strategy we selected trim revise replace with overlaps depended on both whether the sl regex was exponential or polynomial and how identifiable the language of the regex was.
when a regex was exponential or was polynomial with a large degree thevulnerabilitywouldmanifestonshortmaligninput.we fixedthesebyrevising aidedbyvisualizationsfromthe regexper tool tounderstandtheoriginallanguageandstudythesource of the sl behavior.
when the sl behavior was less severe e.g.
quadratic weconsideredbothreviseandtrim.whenwecould discern the language described by the regex we favored revise but whentheregex slanguage was unclearor many regexes were appliedtothesameinput e.g.
parsingauseragentstring trim wasanattractivealternative.wefeltanaversiontoreplacebecause itfelt overly verbose.
libraries.
weweresurprisedbythevarietyofregexeswefound withthesamesemanticmeaning .
.surelywedonotneed6 different regexesto parse urls nor different regexesto parse emails especially not when hundreds of these variations exhibit sl behavior.
we therefore recommend developers make greater use of libraries for parsingcommon constructs like those with the semanticmeaningsindicatedwitha intable .alongtheselines it would also be helpful if rfcs included linear time regexes to parse key fields andprotocols.
conventionalwisdom.
ourfindingsin .
givenuance totheconventionalwisdomonslregexanti patterns.thoughstar height qod andqoawerepresentinnearlyallslregexesinour datasets theywerealsopresentintentimesasmanylinear time regexes as measured by our tools.
this finding speaks to the value of using sl regex detectors.
however the anti patterns do give insightintotherootcauseofanslregex andcanbeusedwiththe revise fixstrategy.
why might sl regexes be more pollutive in npm than in pypi?we thought the difference between the npm and pypi sl regex module appearances curves solid lines in figure was striking.whymightthemostubiquitousslregexespolluteonly50 modules in pypi but hundreds in npm?
we think the multi module appearancesofslregexesinnpmcanbeattributedtothreecauses.
copy pasting useful regexes from places like stackoverflow.
we foundseveralexamplesofslemailregexesoriginatingonstackoverflow.seeforexampletheexponentialslregexof which has1900upvotes.astudyoftheregexesonstackoverflowandtheir intersectionwithourecosystem scaledatasetswouldbeinteresting follow up work.
software bundling because of disincentives in thejavascriptcommunitytohavingmanyexplicitdependencies.in one case we identified modules whose npm artifacts contained thesourceofanothermodulewithanslregex.
manyjavascript libraries wish to be context agnostic and excerpt core node.js libraries toensure thatthey arealways available.forexample one oftheslpath parsingregexesfromnodev4appearedinover2 npmmodules.
threats to validity constructvalidity.
onethreatisthatweusedautomatedslregex detectors to identify sl regexes.
our study may thus be affected by 254esec fse november4 lake buena vista fl usa j.c.davis c.a.coghlan f.servant andd.lee incorrectly labeledregexes.weaddressfalsepositivesbydynamically confirming the report from the sl regex detectors .
.
.
falsenegativesarealsopossible wereportonlytheslregexesthat canbedetectedbyexistingtechniques e.g.
noneofthemconsiders theuseofinherentlysuper linearfeatureslikebackreferences .this meansthattheslregexesweidentifiedrepresenta lowerbound on the number ofsuch regexesinpractice.
another threat is that we do not identify all the possible applicationdomainsinwhichregexescouldbeapplied.ourgoalin studyingrq3wastounderstandwhetherslregexesappearacross applicationdomains andwhetherdifferentapplicationdomainsare affected differently bythem.
our precise but otherwise potentially incomplete set of application domains still allowed us to answer thesequestionsinthe affirmative.
finally anslregexisonlyoneofthecriteriaforaredosattack 2.
.wefocusedonidentifyingredosvulnerabilities anddidnot confirmthattheyareexploitable wedidnotperformtaintanalysis to confirm that malign input could reach these regexes nor did we attempttodifferentiatebetweenmodulesintendedfortheserver sidevs.
the clientside.
internalvalidity.
wedevelopedseveralnovelanalysestoanswer our research questions.
incorrect implementations of the regex semantic meaning labeler .
and the anti pattern tests .
wouldskewourfindings.toaddressthethreattoourregexlabeler we validated its precision over iterations.
our anti pattern tests identified the use of anti patterns in over of the sl regexes indicating agreement with the sl regex detectors in our ensemble andagreeingwiththeintuitionthatanti patternsareanecessary condition for super linear behavior.
external validity.
a threat to external validity concerns whether ourfindingswillholdforotherecosystemsandscenarios.weaddressed this threat by studying two popular programming languageswithlargeecosystems.asthegeneralthemeofourfindings was consistent across these ecosystems we expect our results to generalize to otherecosystems as well.
related work hereisabriefhistoryofredos.crosbyfirstsuggestedthatregexes with large complexity could be a denial of service vector as a precursor to his influential work with wallach on algorithmic complexityattacks .thefirstcvereportofredosappearedin2007 cve and thenotionwas popularizedbyowasp and checkmarx in .
two primitive sl regex detectors were releasedintheearly2010s microsoft s sdl regex fuzzer toolusedinputfuzzingtotrytotriggersuper linearbehavior whilesubstack s safe regex usedthestarheightanti pattern .thesedetectors were followed by a succession of more rigorous academic works on sl regex detection kirrage rathnayake and thielecke andrathnayakeandthielecke developed rxxr2in2013 weideman et al.
released regex static analysis in andwustholzetal.published rexploiter in2017 .ourwork takes the logical next step we measured the extent to which sl regexesoccurinreal worldsoftwareandexaminedtheadoption andeffectiveness ofrepairs.
8concurrentworkfromshenetal.demonstratesanslregexdetectorbasedongenetic searchalgorithms .in terms of ecosystem scale redos analyses the closest work to oursisindustrial notacademic.in2014 liftsecurity.ioperformed an ecosystem scale study of sl regexes in npm .
they relied onsafe regex to scan modules and only identified sl regexesaffecting120modules.theirmuchsmallerincidencerateis notsurprising safe regex sstarheightheuristicwillnotcapture thousandsofpolynomialsl regexes .
staicu and pradel recently demonstrated mappings from sl regexes innpm modulesto redosvulnerabilities inhundreds of popular websites suggestingthat the myriad sl regexes we foundindicatemanyotherredosvulnerabilities.
aninterestinglineofworkfromvandermerwe weideman and berglund proposes automatic regex revising techniques to replace sl regexes with equivalent safe ones .
this work is not yet fullydevelopedbutpromisestoprovidedeveloperswithauseful tool to address sl regexes.
we note that these authors restricted themselves to revisions that would match the exact same language whiledevelopersrarelydidsointhefixeswestudied.wesuggest combiningthisautomaticrevisionapproachwithanunderstanding of semantic meanings .
and anti patterns .
as a promising direction for future research.
moregenerally thestudyofregexesfromasoftwareengineering perspectivewaspioneeredbychapmanandstolee.theystudied theuseofregexesinasmallsampleofpythonapplications and ourstudyofmodulesandcorelibrariescomplementstheirwork.
withwang theyhavealsoexploredpossiblefactorsaffectingregex comprehension .lastly wangandstoleerecentlyfoundthat regexesexhibitpoortestcoverage whichmaycontributeto the incidence ofsl regexeswe report.
reproducibility anartifactcontainingourregexdatasetsandouranalysiscodeis available at .
conclusion we believe nearly every practicing software developer has used regularexpressions.asitturnsout manydevelopershavealsowrittensuper linearregexesandintroducedperformanceorsecurity concerns in foundthousands of super linearregexes in our analyses of the node.js javascript and python ecosystems affectingover10 000modulesaswellasthecorelibrariesofnode.js andpython.
wehavefoundthatredosisnotanicheconcern butrathera commonsecurityvulnerability.assuch itmeritssignificantadditional investment from researchersand practitioners.muchwork remains intheshortterm togaugedeveloperawarenessandimprove educational resources and in the long term to implement andevaluate effective prevention andresolutionmechanisms.