grt an automated test generator using orchestrated program analysis lei ma cyrille arthoy cheng zhangx hiroyuki sato johannes gmeinerzand rudolf ramlerz university of tokyo japan fmalei schukog satolab.itc.u tokyo.ac.jp yaist itri japan c.artho aist.go.jp xuniversity of waterloo canada c16zhang uwaterloo.ca zsoftware competence center hagenberg austria fjohannes.gmeiner rudolf.ramler g scch.at abstract while being highly automated and easy to use existing techniques of random testing suffer from low code coverage and defect detection ability for practical software applications.
most tools use a pure black box approach which does not use knowledge specific to the software under test.
mining and leveraging the information of the software under test can be promising to guide random testing to overcome such limitations.
guided random testing grt implements this idea.
grt performs static analysis on software under test to extract relevant knowledge and further combines the information extracted at run time to guide the whole test generation procedure.
grt is highly configurable with each of its six program analysis components implemented as a pluggable module whose parameters can be adjusted.
besides generating test cases grt also automatically creates a test coverage report.
we show our experience in grt tool development and demonstrate its practical usage using two concrete application scenarios.
keywords automatic test generation random testing bug detection static analysis dynamic analysis i. i ntroduction unit testing is an important quality assurance technique in software development but manually crafting unit test cases is labor intensive.
in general unit testing consists of three steps creating test inputs executing tests and checking test outputs .
an easy to use test generation tool can be valuable if it automates one or more of these steps and has reasonable test effectiveness e. g. high code coverage defect detection ability to assist the development of practical software systems.
in unit testing of object oriented programs the methods in the software under test sut are the basic entities.
to exercise the target behavior of a method under test mut m test inputs type compatible with the parameter types are needed to execute m. starting with primitive values which are the fundamental elements of object states object oriented testing techniques construct test input objects incrementally.
the primitive values are used as parameters to invoke constructors and methods to create more complex object states.
the sequence of method calls is further expanded to produce more diverse object states so that desirable inputs can be generated for the mut.
in the end the generated test cases usually consist of three parts initial primitive or constant values method sequences and assertions .
as generating assertions amounts to the classic test oracle problem which requires extra information of expected behavior most automatic testing techniques focus on finding better initial values and creating useful method sequences.however a large number of software systems cannot be tested exhaustively due to the enormous state space of possible initial values and combinations of method calls.
random testing automatically generates test sequences to execute different paths in an mut.
however random testing techniques are known to suffer from low code coverage on real world applications.
to improve random testing feedback directed random testing frt incrementally builds more and longer test sequences by randomly selecting an mut and reusing previously generated method sequences that return objects as input to execute the mut until a time limit is hit.
unfortunately frt still suffers low code coverage in some cases .
in this paper we present a fully automatic test generator called grt which generates test cases with high code coverage .
grt shares the common idea of frt by leveraging the feedback of method execution but it addresses several issues of random testing and frt through an orchestration of static and dynamic program analyses.
grt only requires the sut and the necessary dependency libraries to work no extra information such as program specifications previous test cases or code bases is needed.
as a tool for unit testing grt provides the following advantages grt combines information from static and dynamic analysis to guide test generation.
this enables grt to generate useful unit test cases with high code coverage for real world programs.
grt is fully automatic and requires no extra information other than the sut and its dependency libraries to generate test cases.
a user just needs to start grt and waits for the test generation process to complete.
grt is well modularized in that all of its components are pluggable under the basic frt framework.
each component can be easily improved or replaced.
the modularity of grt s architecture makes it highly flexible and adaptable.
grt can serve as platform to facilitate further research in software testing.
ii.
grt g uided random testing during our design of grt we identified several common concerns that potentially influence the testing effectiveness of frt selection of initial values.
although random testing produces test inputs randomly in general to compose usefulsuccessful sequencerun time phase impurity fuzzingstatic phase fig.
.
the workflow overview of guided random testing grt which combines information from static analysis with run time guidance.
complex objects suitable initial values especially primitive values are required as the basis for input object construction.
selection of mut.
to achieve higher code coverage muts with uncovered code are natural targets for generating new test cases.
run time coverage information can be used to steer the process of test generation towards muts whose code is not well covered.
selection of methods to generate input data.
objectoriented testing executes methods and usually requires objects as input arguments.
the selection of the right methods to generate valid sequences that return objects is a central and difficult problem in random testing.
we identify two main aspects of method selection properties of methods.
the main properties of a method are characterized by the method signature including the return type and parameter types.
in object oriented programs high level super types instead of exact subtypes are often used to declare parameters for the purpose of design flexibility i. e. to allow run time substitution of objects with compatible types .
considering both static and dynamic type information can capture properties of methods more accurately.
moreover the purity of methods whether they have side effects or not in changing program states is an important method property relevant to test generation.
dependencies of methods.
it is usually infeasible to consider all applicable methods muts and their dependent methods in test generation because this wastes testing effort on methods that are not the targets.
however if the pool of methods to choose from is limited e. g. only the muts necessary objects of certain types cannot be created by frt making all the muts depending on such objects unable to be tested.
thus the pool of available methods needs to be chosen appropriately.
dependencies among methods can be explored to identify relevant methods.
composition of method sequences.
frt generates new method sequences based on concatenation of existing sequences.
existing tools mostly compose sequences by selecting a sequence returning an object with compatible type at random but a well designed strategy can optimize this task by considering several factors related to the cost effectiveness of testing such as the time required to execute a sequence and the likelihood to cover more unexecuted code.to address these issues and also keep the technique open to further enhancement we propose the architecture of grt as shown in fig.
first grt performs static analysis on the muts to extract information.
second tests are generated at run time guided by dynamic analysis.
the run time phase is based on the original framework of feedback directed random testing with grt components plugged into each step.
specifically grt has six collaborative components which are orchestrated so that program information either static or dynamic is extracted by some components at specific steps and passed to others to facilicate their tasks.
the rest of this section describes details of the design and implementation of each grt s component.
constant mining enriches the initial set of primitive values by extracting constants from the sut through static analysis.
the mined constant values are useful to create more diverse objects to cover more branches.
we implement constant mining as an abstract interpreter based on the asm interpreter framework .
it analyzes the java bytecode of each class under test cut and performs constant propagation and folding.
since constant mining analyzes java bytecode rather than source code it is able to work even if the source code of the sut is unavailable.
to be scalable constant mining manages the extracted constants in two levels namely global level andlocal level .
at the global level constants are prioritized so that those used frequently by many classes are more likely to be used for test input generation.
at the local level when generating test cases for an mut constants mined from the mut s declaring class i. e. the cut are preferable as they are often more relevant to the mut and thus effective to cover specific branches.
impurity boosts the effect of constant mining through input fuzzing by favoring methods that can change object states.
meanwhile the input fuzzing can be enhanced with constants extracted by constant mining.
for primitive numeric values we adopt a gaussian distribution with the assumption that the extracted constants from constant mining are already close to satisfying some branch conditions.
the deviation of the gaussian distribution and the ratio to perform fuzzing are provided as parameters that can be adjusted according to sut specific features.
string values are fuzzed by randomly inserting replacing or removing a character and taking a substring of a given string.
it is challenging to fuzz non primitive objects as it requires to identify methods that mutate the object states.
to this end we perform purity analysis to determine whether an mut has side effects and prefer methods with side effects.
when a nonprimitive object is selected as input and requires fuzzing we use the corresponding impure methods to mutate the object before passing it to the mut.
the current grt implements impurity based on the reim reiminfer framework because of its scalability and robustness.
reim reiminfer analyzes the reference purity information of an sut and infers side effects of all methods.
this framework does not require an expensive complete analysis of the program.
its algorithm infers method purity using the type system.
elephant brain manages all the objects stored in the object pool by using exact run time type.
the type information is obtained by analyzing objects returned by the execution of the method sequences through reflection.
we store a method sequence into the object pool by using the exact type of the returned object as key.
when an mut requires an input with declared static type t we search in the object pool for sequences that return object with compatible type of t. we perform random selection to use exact type match or subtype match with a user defined ratio default .
elephant brain can find objects that cannot be generated using static type information alone so it equips other components such as impurity and detective with additional exact type information to improve their effectiveness.
detective constructs objects that are needed to test muts but cannot be found in the main object pool.
detective performs static analysis on muts to find their input and output type dependencies and constructs the missing input objects on demand at run time.
when an input object of type tis needed detective first randomly constructs an object with typetor subtypes of t iftrepresents an interface or an abstract class .
then it analyzes all methods of tthat can return the corresponding objects and recursively finds methods returning objects that are type compatible with parameters of the previous methods.
after finding all relevant methods detective executes them in a topological order the method that does not depend on return values of other methods is executed first.
if an object of the required type tis successfully generated it is stored in the main object pool for further use.
other generated objects are kept in a secondary object pool for further fast querying.
using the secondary object pool avoids polluting the main object pool with many irrelevant objects.
orienteering estimates the execution cost of each method sequence by analyzing its execution time and length of the sequence i. e. the number of method invocation statements .
we calculate a weight for each sequence based on these two kinds of information.
the weight is so defined that less costly method sequences have higher probability of being selected while expensive method sequences that generate interesting new objects are also included.
orienteering accelerates the overall test generation process of grt.
bloodhound intelligently selects muts that are not well covered.
by covering more code of an mut more program states can be reached which potentially creates objects to further improve testing effectiveness.
bloodhound records coverage information of the target muts calculates a weight for each of them and randomly selects the next mut based on the weight.
in most cases it is prohibitively expensive to monitor code coverage after the execution of each singlemethod sequence.
in addition always selecting mut with low code coverage is problematic since they can contain branches that are too difficult to cover.
to solve these issues bloodhound recalculates the coverage weight of each mut periodically and balances the selection of muts with low code coverage and those selected less often.
bloodhound adapts the robust coverage evaluation tool jacoco to monitor code coverage.
jacoco does not support online coverage profiling so we modify jacoco so that each covered code fragment and branch of the executed method sequence are stored for further analysis.
when test generation starts bloodhound loads and instruments the cut with the probes to collect code coverage information.
if the corresponding part of the code is executed the probes in that executed code fragment will be marked as covered by the executed test case.
iii.
u sage scenarios as grt is designed to be an automatic test generator which does not require any user intervention after being launched the current implemention is a command line tool without graphical user interface.
this section demonstrates two main usage scenarios of grt detecting defects in the current version of a program and generating regression tests for future program versions.
a. defect detection the first usage scenario is using grt to generate test cases to find defects in the current version of a program.
there are only three steps to follow prepare the program to be tested.
specifically the user first builds the program and puts the built classes .class files of the sut into a directory sut dir .
then the user needs to place all libraries necessary to build the program and the program source code optional into directories lib dir and src dir respectively.
run grt to generate test cases using the command below java jar grt.jar sut dir n mptest sutlibpaths lib dir n mptest sut src path src dir n timelimit time budget n output tests fail grt also provides a shell script template that allows the user to directly execute grt with slight adjustments on the parameters.
after grt completes test generation it outputs junit test cases that have failed.
for the failed test cases the user needs to perform manual analysis to check whether they detect real bugs in the sut or they are false positives.
for non trivial programs grt may generate many failed tests making it difficult to manually analyze all of them.
we recommend the following steps of manual analysis 1by default grt uses exceptions and the predefined contracts of the base classjava.lang.object e. g. the reflexivity property of equals as the test oracle .
filter out test cases that are obviously caused by issues that are known to be less relevant to real defects.
these issues include deprecated methods.
methods may be marked as deprecated if they contain or expose design flaws.
such methods are usually removed from the program in the future.
tests involving such code often reveal previously known issues.
the failed test cases may be considered as true positives but as the code tends to be removed soon the possible defects may not be fixed.
ignoring these issues allows the user to focus on unknown flaws.
internal packages.
some packages are specific to the given reference implementation and not supposed to be used by others.
possibly unsafe api uses found by test cases are therefore irrelevant.
stack overflows in containers.
container classes such as those in the java collections apache collections and guava usually allow recursive nesting of data.
for example a test case can insert a list l1into another list l2 followed by an insertion of l2intol1.
as a result operations such as list iteration or a call to method tostring will never terminate on the list objects.
compare the failure stack traces of the failed test cases and classify similar failed tests with similar stack traces as one issue for further analysis.
for the remaining classified failed tests check whether they reveal true defects by analyzing the program code and relevant documentation if available .
b. regression test generation the second usage scenario is using grt to generate regression test cases to help developers capture defects introduced by program changes.
this scenario consists of four steps preparation the program to be tested is identical to that of the first scenario after compilation the source files compiled files and necessary libraries have to be placed in their respective directories.
run grt to generate test cases using the command below java jar grt.jar sut dir n mptest sutlibpaths lib dir n mptest sut src path src dir n timelimit time budget n output tests pass note that the command sets the option output tests topass instead of fail .
it is critical because grt is used to output all passed test cases rather than failed ones as regression tests that capture the behavior of the current version of the sut.
although all the generated test cases have passed during test generation some of them may still fail in future executions when being used as regression tests on the same program due to non deterministic behavior.
to mitigate this problem grt provides a test cleaner that removes such flaky tests iteratively.
2it is possible to make iteration robust against infinite recursion but a fix entails keeping track of previously visited object instances during iteration.
this requires an amount of memory that is linear to the size of the collection which worsens the problem in most cases.
when program changes occur the user can run the generated test cases as normal junit test cases to detect regression in the new program version.
iv.
e xperience the design and implementation of grt have lasted for more than a year.
during this period we gained valuable experience in using grt on real world programs.
we applied grt to over open source projects.
the results show its scalability and effectiveness in achieving high code coverage .
we also used grt to detect real bugs by generating test cases for well developed and maintained programs.
the test cases successfully detected previously unknown bugs that are confirmed by developers.
for example in the apache commons codec project grt generates the simple test case as below 1public void test throws throwable doublemetaphone var0 new doublemetaphone boolean var3 var0.isdoublemetaphoneequal false after the test case failed our manual analysis revealed that the failure was caused by the incorrect implementation of encoding empty strings or other special strings .
in the method isdoublemetaphoneequal in class doublemetaphone a string is first encoded and then compared by invoking method equals .
however some strings e. g. the empty string are encoded as null causing a null pointer exception during the comparison of equality.
another example is a test case generated by grt on apache commons compress.
the test case reveals a bug ofchangeset by adding the input data and invoking deletedir which leads to an exception.
randoop cannot detect the bug because bytearrayinputstream is not a class in the sut and none of its methods is present in the method pool of randoop making it impossible to create an instance of the class i. e. var5 .
in grt the detective component starts with changeset and finds missing objects transitively so grt can identify the need for an instance of java.io.bytearrayinputstream .
1public void test throws throwable changeset var0 new changeset sevenzarchiveentry var1 new sevenzarchiveentry byte var3 new byte byte byte java.io.bytearrayinputstream var5 new java.io.bytearrayinputstream var3 tararchiveinputstream var6 new tararchiveinputstream java.io.inputstream var5 var0.add archiveentry var1 java.io.inputstream var6 var0.deletedir 0x7875 zip extra field uid gid we used grt to detect defects collected by the defects4j framework .
the purpose of defects4j is to facilitate controlled study in software testing.
for each bug defects4j has a fixed version a buggy version and a patch.
the fixed version is converted into the buggy version by applying the patch which simulates the situation of introducing a bug during program changes.
we used grt to generate regression test cases for the fixed correct version of each pair of program versions applied the patch and ran the regression test cases to check whether they could reveal the introduced bug inthe buggy version.
in this setting of regression testing grt detects out of real bugs from four studied subject programs .
grt also participated in the third round of the sbst java unit testing tool contest in which test cases were generated on a per class basis instead of complete programs .
among all the seven participating tools grt obtained the highest score in terms of code coverage mutation score and execution time.
while the detailed scores indicate that grt still has room for improvement the combined result of all participating tools is better than individual tools the overall result demonstrates the effectiveness and efficiency of grt.
v. r elated work while a large body of work on automated testing exists this section only discusses publicly accessible tools that are closely related to grt.
random test generators most mainstream random test generators create input objects as method sequences whose returning objects can be used as inputs for further test generation.
jcrasher adopts top down input object construction by using a parameter graph to analyze method dependencies and to create test sequences.
eclat and randoop perform feedback directed random test generation to incrementally construct complex objects from primitive types in a bottom up style.
grt adopts the basic framework of feedback directed random testing and addresses several common issues to improve test effectiveness.
some tools combine external knowledge and random testing to improve code coverage and bug detection ability.
mseqgen mines client code bases to extract frequently used sequence patterns to assist test generation.
ocat captures input object states by running developer written test cases and directly using these objects as input for random test generation.
similar to ocat palus trains a method sequence model from existing test cases and uses the derived model to guide test generation at run time.
grt also performs program analysis and uses the analysis results to guide test generation at run time.
grt differentiates from previous work in that grt is fully automated and requires no additional sources of information e. g. existing test cases and code bases other than the sut itself.
systematic test generators symbolic execution represents input as symbolic values and uses abstract semantics for execution to collect the path constraints.
the constraints are solved by constraint solvers to derive input object states that satisfy corresponding branch conditions.
symbolic pathfinder is a representative test generator based on symbolic execution.
there are also tools combining random testing and symbolic execution including dart cute and jcute pex and dsc .
bounded exhaustive testing is an alternative systematic approach.
it exhaustively generates method sequences up to a small bound of sequence length and is implemented in tools such as testera korat and symstra .
the technique implemented by grt is orthogonal to systematic approaches and the combination of both kinds of techniques is an important direction of our future work.
evolutionary test generators evolutionary test generators e. g. etoc testful start with randomly generated test sequences and use evolutionary algorithms to evolve and search for test sequences that optimize certain fitness functions e. g. branch coverage mutation score .
evosuite represents the current state of the art evolutionary test generator which goes beyond traditional techniques by adopting a hybrid approach to generate and optimize the whole test suites.
evosuite is shown to be effective in achieving high coverage on real world software .
evosuite is also used to study the impact of constant seeding strategies in search based software testing .
compared with evosuite grt currently does not include some optimizations that could further improve efficacy of test generation.
using a basic framework with lower complexity guided random testing vs. evolutionary testing grt usually requires less time for test generation which is desirable when testing resources are limited.
we believe that some components of grt could also be adapted to evolutionary test generators for further enhancement.
vi.
d iscussion the original motivation of developing grt is to improve feedback directed random testing by addressing a number of key issues that limit the test code coverage.
as the basic framework of frt is quite general grt is highly flexible.
constant mining can be extended to mine constant values from other sources of information such as existing test cases execution traces and even documentation.
impurity can be replaced with other side effect analyses for example to know which variables may be changed by a method in addition to whether or not the method is pure.
similarly other components can be improved with more advanced program analysis techniques.
the overall result can be used to demonstrate the usefulness of new techniques or combinations of existing techniques in the context of test generation.
as an automatic test generator grt can be directly used to generate test cases for different purposes.
first grt itself can be considered as a representative random testing tool similar to randoop for software testing research.
for example it can be the baseline in evaluation.
moreover test cases generated by grt can be useful to drive dynamic analysis or produce dynamic information such as code coverage and runtime states to facilitate related software engineering research including model inference fault localization program repair etc.
more information on grt s usage including the detailed descriptions of parameters and the complete set of experimental results its video demonstration and reproduction package are available at vii.
a cknowledgments this work was supported by the seut project from the university of tokyo kaken hi grants and the austrian ministry for transport innovation and technology the federal ministry of science research and economy and the province of upper austria in the frame of the comet center scch .