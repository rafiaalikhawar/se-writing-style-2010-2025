reflection aware static analysis of android apps li li tegawend f .
bissyand damien octeau jacques klein snt university of luxembourg luxembourg cse pennsylvania state university usa li.li tegawende.bissyande jacques.klein uni.lu octeau cse.psu.edu abstract we demonstrate the bene ts of droidra a tool for taming re ection in android apps.
droidra rst statically extracts re ection related object values from a given android app.
then it leverages the extracted values to boost the app in a way that re ective calls are no longer a challenge for existing static analyzers.
this is achieved through a bytecode instrumentation approach where re ective calls are supplemented with explicit traditional java method calls which can be followed by state of the art analyzers which do not handle re ection.
instrumented apps can thus be completely analyzed by existing static analyzers which are no longer required to be modi ed to support re ection aware analysis.
the video demo of droidra can be found at ccs concepts software and its engineering !software notations and tools keywords android static analysis re ection droidra .
introduction many static programming languages support the use of re ection to allow a program to introspect its own behaviors at runtime.
as an example re ection is frequently leveraged by java testers to access private elds and methods in order to ensure a high coverage rate.
actually re ection has been taken as an advanced feature because it enables a program to perform sophisticated operations which would otherwise be impossible.
android apps which are essentially written through java have also extended the ability of leveraging re ection mechanism and many of them indeed leverage this feature to achieve advanced functionality e.g.
to access inaccessible apis we will show more legitimate usages in the next section .unfortunately re ection has also been leveraged by bad guys to perform malicious behaviors in an attempt to bypass the detection of static analyzers.
indeed many static analyzers of android apps have already been proposed in the community such as call graph building and program slicing which are not yet re ection aware and thus will inherently yield false negatives.
furthermore existing re ection aware java based static analyzers cannot be simply adapted to tackle android apps.
as an example tamiflex a well known re ection taming tool that is designed and implemented for java apps cannot be applied to android apps.
to the best of our knowledge except our previous work there is only one work presented by barros et al.
who proposes a solution for re ection analysis of android apps.
however that approach analyzes the source code of android apps only which is di cult to obtain for most market apps and requires additional developer e orts to annotate certain code properties.
last but not the least it does not provide a way to directly bene t existing static analyzers regarding its extracted re ection results.
our objective in this work is thus to bridge the gap between exploiting the capabilities of state of the art analysis tools and allowing them to perform whole program analysis on apps with re ective calls in a non invasive means .
this is done by taming re ection in android apps in which we present a tool called droidra to statically retrieve all re ection relevant values to resolve re ective calls and add instrumentation code with corresponding java standard method calls.
droidra is dedicated to support researchers and analysts to perform re ection aware static analysis of android apps.
it is fully automated and is written in java which takes as input an android app and outputs two artifacts a summary of re ection usages json format and a new version of android app where its re ective calls have been tamed for static analysis.
as indicated in our research track paper we have made available online our full implementation as an open source project along with the benchmarks and scripts we leveraged at the rest of this paper is organized as follows section introduces some background information on re ection usages in android apps.
then in section we detail the design and implementation of our tool droidra along with a summary of its evaluations.
after that we show some related works in section and then conclude this paper in section .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
example providing genericity 2class collectionclass 3object collectiondata 4public xmltocollectionprocessor str s class c 5collectionclass c 6class c1 class .
forname java .
util .
list 7if c1 c this .
collectiondata new arraylist class c2 class .
forname java .
util .
set if c2 c this .
collectiondata new hashset example maintaining backward compatibility 16try class .
forname android .
speech .tts .
texttospeech catch exception ex deal with exception example accessing hidden internal api android .os.
servicemanager is a hidden class .
24class c class .
forname android .os.
servicemanager 25method m c. getmethod getservice new class string .
class 26object o m. invoke obj new string phone 27ibinder binder ibinder o itelephony is an internal class .
the original code is called through reflection .
30itelephony .
stub .
asinterface binder listing re ection usage in real android apps.
.
reflection in android apps re ection usages.
essentially android apps are written in java for which the re ection mechanism introduced by java language is also extended.
our previous work has shown that re ection is frequently used by android developers to provide genericity e.g.
using re ection to implement generic functions.
example in listing illustrates a real example on how re ection is leveraged to achieve this kind of functionality where a collection object is initialized re ectively maintain backward compatibility e.g.
ensuring apps that are developed with latest features to be still executable on old devices where the latest features are not yet available.
example in listing illustrates a real example which depends on re ection to check whether the running android device supports text to speech feature or not reinforce app security e.g.
separating the core functionality of a given app to an independent library which can then be loaded dynamically through re ection when a speci c rule is reached and access inaccessible apis.
in the android framework base there are two types of apis that are inaccessible by third party apps including internal and hidden apis.
those inaccessible apis will not be released to the android sdk namely android.jar that will be used by developers to implement android apps.
however those apis will be shipped into running android devices through framework.jar that will be used to replace android.jar at runtime to support the execution of android apps.
within this release model inaccessible apis can be accessed by third party apps through re ection although they are not available in the developing environment the nal app will work ne in android devices.
example in listing illustrates a real example showing how inaccessible apis are leveraged.
patterns of re ective calls.
as a means to build a clear picture on how re ection is used by developers so as to tame re ection for static analysis approaches we have investigatedthe sequences of re ective method calls on randomly selected apps and summarized their common usage patterns.
figure illustrates the nal patterns on the usage of re ective method calls we build which is capable to model the most typical usages of re ective calls.
this pattern shows how the re ection mechanism allows to access methods elds dynamically.
re ective methods or elds can be leveraged directly if they are statically declared solid arrows .
otherwise they have to used after an initialization of their classes dotted arrows .
obtain classinitialize classobtain methods fields from classclass c class.forname str class c loadclass str c.newinstance c.getconstructor class .
newinstance obj access the class s methods fieldsmethod m c.getmethod field f c.getdeclaredfield m.invoke obj obj f.get obj f.set obj obj figure abstract pattern of re ection usage and some possible examples.
re ection in malicious vs. benign apps.
given the potential of using re ection to hide malicious operations which could not be statically detected we investigate whether re ection usage can constitute in discriminating between malicious and benign apps.
we build a basic machine learning classi cation scheme with re ective calls as the unique feature set e.g.
invoke is considered as a feature .
for the experiments we use randomforest ensemble learning algorithm and build our ground truth by leveraging virustotal scanning results1on the randomly selected apps.
fold cross validation experiments2yield a performance of .
for f measure the harmonic mean of precision and recall.
although such a high performance can be favored by our experimental settings it nonetheless suggests that re ective calls may constitute a discriminate feature between malware and goodware.
.
droidra in this section we detail the design and implementation of our tool droidra.
figure overviews the working process of droidra which contains three phases jimple preprocessing phase re ection analysis phase and booster phase.
in the following of this section we detail the implementation of these three phases respectively.
.
phase as the rst phase droidra transforms a given android app to appropriate jimple code in order to support further re ection analysis.
jimple is selected because it is presented as a address representation that has been designed to simplify analysis and transformation of java bytecode .
at beginning of this phase droidra extracts dex les i.e.
the actual app code from android apps cf.
step .
.
we consider an app ato be malicious if any of the anti virus products from virustotal has agged it as malicious.
otherwise ais a benign app.
2to address the imbalance dataset problem only out of the apps are malicious we perform oversampling using smote 757boosterjimple .jimple a .jimple b .jimple .
soot dexpler .
entry point construction .jimple b .
preprocessing .
rewritingjimpleclasses.dex .
extract dex files phase .jimple .jimple b coal solver refl.json .jimple .jimple c .
code instrumentation .
reflection analysisphase 1phase .jimple .jimple d coal basedreflection model .
improvingfigure overview of droidra.
md5 b0eea79daa92d90d8d3dd1a644b7edaacom.miralcestudios.cjsiebl .apk androidmanifest.xml classes.dex the default dex file meta inf res assets obmhwzogztvvvhcbd.dat zip archive meta inf classes.dex to be dynamically loaded dex file dousn zip archive meta inf classes.dex to be dynamically loaded dex file figure a real world example showing the distribution of dex les in an android app.
there are two types of dex les existing in android apps.
figure illustrates an example containing both of these two types.
the rst type is the default dex le namely classes.dex which lives in the top level of a given android app3and applies to every android app.
the rst type is the to be dynamically loaded dex le also named as classes.dex as shown in figure which is usually hidden in zip les.
the name of those zip les will likely be further obfuscated in order to bypass the detection of potential analyzers.
as an example there is a le named obmhwzogztvvvhcbd.dat under the assets directory of app com.miralcestudios.cjsiebl which is actually a carrier of a classes.dex le.
the second type of dex les could be eventually accessed through the well known dynamic code loading dcl mechanism.
thus it is essential to take them into consideration in order to support whole program analysis.
however dcl is yet another challenge for static analysis as some wouldbe loaded classes may not exist statically at all e.g.
they can be downloaded from a server at runtime.
droidra focuses on dynamically loaded code that is included in the apk le and that can be accessed statically.
3the format of an android app is actually a compressed zip archive.after extracting all the dex les in step .
droidra transforms all of them into jimple code through a tool we released previously called dexpler which now has been integrated into soot .
soot is a framework for analyzing and transforming java android apps which has already been widely used to analyze instrument optimize and visualize java android apps.
finally similar to other static approaches droidra also needs to start its analysis from a single entry point method.
unfortunately android apps do not have a well de ned entry point method like main in traditional java apps.
but instead they have multiple entry points where each component as an essential unit that android apps are made up of could be a potential entry point.
to mitigate this droidra constructs a single entry point method based on all the aforementioned jimple code following the successful experiences that we have learned from our previous work .
given an android app droidra arti cially assembles adummy main method taking into account all components and their lifecycle methods e.g.
onstart and callback methods e.g.
onclick .
this dummy main method will eventually support static analysis approaches to build an inter component controlow graph and consequently to support whole program analysis of android apps.
.
phase we now detail the second phase of droidra.
our re ection analysis is implemented on top of coal and coal solver .
coal is a composite constant propagation language that is dedicated to specify constant propagation problems.
coal solver is an inter procedural context sensitive ow sensitive analyzing engine that performs composite constant propagation to solve coal modeled constant propagation problems.
as an example paramharver leverages coal and coal solver to harvest parameter values propagated in an inter procedural manner of a given set of android apis.
in phase we rst build a coal based re ection model and then send it to an improved coal solver along with the analyzed jimple code.
as the output the re ection analysis result will be presented in a json le named re .json which 7581telephonymanager telephonymanager default 2string imei telephonymanager .
getdeviceid 3class c class .
forname de.
ecspride .
reflectiveclass 4object o c. newinstance 5method m c. getmethod setime i string .
class 6m.
invoke o imei 7method m2 c. getmethod getimei 8string s string m2.
invoke o 9smsmanager sms smsmanager .
getdefault 10sms.
sendtextmessage null s null null listing code excerpt of de.ecspride.mainactivity from droidbench s reflection3.apk .
then can be leveraged by other static analysis approaches to support re ection aware analysis.
coal based re ection model.
listing illustrates a part of our coal based re ection analysis model where class method is modeled.
for class method we de ne two string elds for it.
field declaringclass method is used to represent the class type that a given re ective call belongs to.
filed name method is used to represent the name of the re ective call.
based on the method name and its declaring class name we are able to uniquely identify the re ectively called method.
improvements to the coal solver.
although coal is design to be as generic as possible it cannot be directly applied to model and tackle the re ection problem that droidra intends to solve.
we thus contribute several improvements to the coal solver to enable the analysis of re ective calls.
our rst improvement is on the coal language itself we slightly extend it to be able to represent the query of values of objects on which instance method calls are made.
the second improvement is on the propagating of values of array objects.
given an array object we mark it as containing all element values.
with this limited improvement our result may not be precise in theory.
however for our targeted method getconstructors that we consider typically only have a few elements our improvement is able to ensure that the propagation of constructors is precise enough in practice.
finally we have contributed various optimizations to improve the overall performance of the coal solver.
.
phase now in the last phase we detail how droidra instruments jimple code towards supporting re ection aware static analysis where re ective calls have been conservatively4 augmented with appropriate standard java calls.
let us take listing as an example to better explain the idea of phase where the code snippet is extracted from an app of droidbench named re ection3.apk .
droidbench is a set of hand crafted android apps for which all leaks are known in advance.
these leaks are used as ground truth to evaluate how well static and dynamic security tools such as iccta and copperdroid detect data leaks.
the re ection3 benchmark app has used re ective calls which is known to be problematic for many tools including flowdroid and iccta .
in this example class reflectiveclass is rst retrieved line and initialized line .
then method setimei is re ectively retrieved and invoked 4we keep the re ective calls to conserve their initial runtime behaviors while standard calls are injected in the call graph to allow static exploration.
class c class .
forname de.
ecspride .
reflectiveclass object o c. newinstance if check o new reflectiveclass m. invoke o imei if check o. setimei imei string s string m2.
invoke o if check s string o. getimei listing the boosting results of our motivating example.
indicates the line it appears is newly injected.
to store the device id into eld imei lines .
after that another re ective method called getimei is retrieved and invoked to obtain back the device id into the current context lines so that it can be eventually sent outside the device via sms to a hard coded phone number line .
phase takes as input the output of phase listing shows the results reported by droidra in phase which contain re ection related target values for two re ective methods i.e.
invoke that we are interested in and that we have explicitly con gured in the coal model cf.
the query keyword at line in listing .
listing shows the instrumentation results of our example snippet.
given a re ectively accessed class droidra explicitly initializes it by calling its construct method lines which will also be retrieved by our re ection analysis.
for re ective method calls droidra will inject code to simulate them in a traditional manner.
as an example the statement m.invoke o imei line has been augmented with o.setimei imei where ois an instance of re ectiveclass that droidra has initialized previously.
we note the readers that we have introduced a method called check whose implementation will be excluded for static analysis.
however for runtime execution check will always return false keeping the newly injected code from being executed while for sound static analysis it allows the path to be explored.
.
summary of evaluation we have evaluated droidra in four aspects.
at rst we compute the coverage of re ection calls that droidra identi es and inspects.
experiments on randomly selected apps show that droidra is able to correctly resolve .
of the targets.
second we compare droidra with a state ofthe art approach proposed by barros et al.
hereinafter we refer to it as the checker framework on open sourced apps which are actually used by barros previously in their experiments.
the results show that droidra is able to resolve more re ective methods constructors e.g.
more constructors on f droid apps that are previously used by barros though it does not need the source code of analyzed apps and additional developers e orts as what checker framework needs.
third we check whether droidra is capable to support existing static analyzers to build sounder call graphs of android apps.
to this end we select soot static analyzer to perform our experiments.
in the same apps that we have leveraged in our rst evaluation aspect for each app 5the unresolved targets are mainly due to limitations of static analysis where runtime values cannot be resolved and limitations of the coal solver where arrays of objects cannot be fully propagate at the moment.
other approaches like primo can be leveraged to facilitate the resolution of those unresolved targets.
7591class java .
lang .
reflect .
method class declaringclass method string name method mod gen java .
lang .
class java .
lang .
reflect .
method getdeclaredmethod java .
lang .
string java .
lang .
class replace declaringclass method replace name method mod gen java .
lang .
class java .
lang .
reflect .
method getmethod java .
lang .
string java .
lang .
class replace declaringclass method replace name method query java .
lang .
reflect .
method java .
lang .
object invoke java .
lang .
object java .
lang .
object type java .
lang .
reflect .
method listing the coal based re ection analysis model for class java.lang.re ect.method .
similar speci cations apply for all other re ection classes.
mod keyword describes how the method modi es the state of the program.
genkeyword depicts that the method will generate a new object of type method.
query keyword speci es the point that we would like to obtain the values.
indexes such as 1and 0indicate the reference to the instance on which the method call is made.
as an example statement replace declaringclass method at line indicates that the name of the class object on which the method is called is used as the eld declaringclass method of the generated object.
1de.
ecspride .
mainactivity void oncreate android .os.
bundle r8 virtualinvoke r6.
java .
lang .
reflect .
method java .
lang .
object invoke java .
lang .
object java .
lang .
object r19 r7 value path values declaringclass method de.
ecspride .
reflectiveclass name method getimei 5de.
ecspride .
mainactivity void oncreate android .os.
bundle virtualinvoke r21.
java .
lang .
reflect .
method java .
lang .
object invoke java .
lang .
object java .
lang .
object r19 r1 value path values declaringclass method de.
ecspride .
reflectiveclass name method setimei listing the re ection analysis results for the example code shown in listing .
droidra improves by .
and .
the number of edges in the constructed call graph with spark and cha respectively.
in the last evaluation aspect we evaluate whether existing static analyzers can yield re ection aware results or not based on the instrumented app generated by droidra.
to this end we select iccta static analyzer to conduct our experiments.
we launch iccta on both benchmark apps where the re ective calls are known in advance and on realworld apps.
our experimental results show that in both cases iccta is able to report re ection aware results thanks to droidra which would otherwise be impossible.
.
related work to the best of our knowledge we are the rst one that automatically solve the re ection analysis of android apps for boosting static analysis approaches.
research on static analysis of android apps have shown strong limitations on taming re ections many of them have even explicitly acknowledge such limitations the closest work to ours was concurrently proposed by barros et al.
within their checker framework .
however their work di ers from ours in several ways their approach focuses on checking information ows from developer s perspective who has to add annotations in the analyzed source code.
their approach performs intra procedural type inferences while ours is inter procedural and context sensitive.
while both of our approaches perform re ection analysis our approach goes one step further to also boost android apps which can directly bene t other static analysis approaches in an non invasive manner.
re ection by itself has been investigated by several worksfor java applications.
for example livshits et al.
leverages points to analysis to estimate the target value of re ective calls.
bodden et al.
present a dynamic approach namely tamiflex to support static analysis in the presence of re ections in java programs.
although android apps are written in java tamiflex cannot be simply adapted to analyze android apps .
using instrumentation to strengthen the static analysis of java android apps is not new .
as examples stoller et al.
and artho et al.
merge multi process apps into a single one through instrumentation for easing other approaches like software model checking.
iccta instruments android apps to bridge the icc gaps and thus to enable inter component static analysis.
appsealer instruments android apps to detect and inject vulnerabilityspeci c patches so as to prevent at runtime the component hijacking attacks.
.
conclusion to handle re ection for static analysis is an essential step towards whole program analysis.
unfortunately re ection in android apps has not been fully investigated by the community.
to bridge this gap we thus designed and implemented a tool called droidra which statically extracts the target object values of re ective methods e.g.
the name of a re ective call or the declaring class name of a re ectively accessed eld in an attempt to have a better understanding on how re ection is leveraged in a given app.
we then present a booster module which leverages the previously extracted values to instrument a given app by representing re ective calls with traditional java calls.
the instrumented app results 760in a non invasive approach where existing static analysis approaches without any modi cation can now be directly bene ted to yield re ection aware results.
.