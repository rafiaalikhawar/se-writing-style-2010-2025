mining constraints for event based monitoring in systems of systems thomas krismayer rick rabisery and paul gr nbacherz christian doppler laboratory mevss institute for software systems engineering johannes kepler university linz austria thomas.krismayer jku.at yrick.rabiser jku.at zpaul.gruenbacher jku.at abstract the full behavior of software intensive systems of systems sos emerges during operation only.
runtime monitoring approaches have thus been proposed to detect deviations from the expected behavior.
they commonly rely on temporal logic or domain specific languages to formally define requirements which are then checked by analyzing the stream of monitored events and event data.
some approaches also allow developers to generate constraints from declarative specifications of the expected behavior.
however independent of the approach deep domain knowledge is required to specify the desired behavior.
this knowledge is often not accessible in sos environments with multiple development teams independently working on different heterogeneous systems.
in this new ideas paper we thus describe an approach that automatically mines constraints for runtime monitoring from event logs recorded in sos.
our approach builds on ideas from specification mining process mining and machine learning to mine different types of constraints on event occurrence event timing and event data.
the approach further presents the mined constraints to users in an existing constraint language and it ranks the constraints using different criteria.
we demonstrate the feasibility of our approach by applying it to event logs from a real world industrial sos.
index terms constraint mining event based monitoring systems of systems.
i. i ntroduction complex software intensive systems are often described as systems of systems comprising heterogeneous architectural elements.
as the behavior of sos fully emerges during operation only runtime monitoring is needed to detect deviations from the requirements.
different research communities have been developing monitoring approaches for various kinds of systems and diverse types of checks in many of these approaches the requirements are formally expressed using a form of temporal logic or as constraints in a domainspecific language dsl .
the requirements are then checked continuously at runtime by analyzing the monitored stream of events and event data or post hoc by analyzing persisted event logs.
for instance in our earlier work we introduced reminds a tool supported monitoring approach for sos.
our approach similar to other approaches relying on the declarative specification of the expected behavior e. g. assumes that engineers manually define constraints based on their domain knowledge.
due to the size complexity and heterogeneity of industrial sos however the required knowledge is often only partly documented.
further the continuousand independent evolution of systems in the sos requires to frequently define new and update existing constraints.
we are thus developing an approach to automatically extract constraint candidates from event logs recorded from different systems monitored in the sos.
specifically our approach uses rich event logs containing the type of events their source in the sos and data associated with events e. g. values from machine sensors or configuration parameters .
building on techniques from the field of specification mining process mining and machine learning our approach aims at finding reappearing structures patterns and rules in these rich event logs to then suggest constraints to developers who can easily include them in their monitoring infrastructure.
specifically we claim the following contributions our approach i automatically mines both temporal constraints and value constraints from rich event logs recorded from multiple systems in an sos ii it computes a set of constraint candidates including a representation for users in a dsl and iii it ranks the constraint candidates using different criteria to ease their selection by users.
this new ideas paper describes our constraint mining approach and presents a preliminary evaluation using event logs from a real world sos from the automation software domain.
we outline the next steps in further developing and evaluating our approach.
ii.
b ackground and related work event based monitoring approaches analyze the stream of events produced by a complex system to check its compliance to requirements or properties.
the monitored events are commonly stored in event logs for later analyses.
an event log consists of event sequences each representing one run of a system.
they contain multiple events of different types which are typically sorted by their timestamps.
an event sequence can be seen as an instance of a particular event sequence type which has specific start and end event types.
the information stored in event logs has implications on the types of constraints that can be mined see for example the catalog by autili et al.
simple event logs only comprise the events together with their timestamps.
they allow mining temporal constraints on the occurrence order and timing of events .
in rich event logs data elements of different types e. g. string or number are additionally recorded for the events.
often the .
c ieeease urbana champaign il usa technical research new ideas826 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
data elements are further grouped hierarchically.
this allows mining value constraints on specific data elements in the event log.
for instance the value of data elements may need to remain constant it may need to lie above or below a specified threshold or within a given range.
the additional information in rich event logs can also help to distinguish if an event sequence can be regarded as valid or if unexpected behavior was monitored.
this allows to use machine learning techniques to mine additional data constraints based on classifiers trained using the event data from multiple valid and invalid event logs.
existing specification mining techniques aim at extracting temporal constraints from event logs and represent them as automatons e. g. linear temporal logic rules e. g. or markov chains e. g. .
these techniques can be split into static algorithms e. g. which extract rules from analyzing source code and dynamic specification mining algorithms e. g. which use method call traces or log files as input.
dynamic algorithms analyze traces based on available operations to find patterns.
for example this has been done in the context of web pages .
similarly process mining approaches discover temporal patterns in event traces logs to monitor and improve processes in different application domains.
dynamic analysis is also used to find value constraints for variables in programs .
value constraints have also been extracted in the area of product line engineering using classifiers trained on multiple configurations of systems .
several existing approaches aim at discovering both temporal and value constraints for instance the approaches by lo and maoz and lorenzoli et al.
use dynamic analysis of method calls and values of program variables e. g. method parameters to mine constraints for program analysis and testing.
our approach also aims at mining temporal and value constraints but additionally considers constraints on the timing of events.
in contrast to existing specification mining techniques our approach processes events recorded with a monitoring tool.
further after being presented and approved by users the mined constraints are used for system monitoring.
iii.
r unning example to illustrate and evaluate our approach we use events monitored from a real world automation sos from our industry partner primetals technologies one of the world s leading engineering and plant building companies in the metallurgical industry.
their plant automation sos tracks and optimizes different stages of the metallurgical production process.
different independently developed automation systems are distributed within a plant and size up to several million lines of code.
the correct interplay between these software and hardware systems is crucial to guarantee continuous uninterrupted production and high quality products.
hence it s essential to ensure that the sos complies with its requirements.
however the full behavior of the sos emerges only at runtime when the involved systems interact with each other with the hardware and withthird party and legacy systems.
engineers thus need to capture events and data to monitor important requirements at runtime.
one system in our industry partner s sos is the optimizer supporting the cutting of steel slabs to minimize scrap and maximize the steel quality.
event logs for this system contain the following two event sequence types sequence type listed below represents a typical run of the optimizer.
it starts with a system requesting an optimization a and feeding data b andc .
the optimizer then calculates the optimization result d feeds the result to the cutting system and notifies other systems in the sos e f andg .
a controller.requestoptimization b optimizer.feeddata start c optimizer.feeddata finished d optimizer.calculateresult e cutting.feedoptimizationresult f tracking.updatesetpoints g tracking.notifylisteners sequence type represents a shorter version of the optimization run in which data is already available and the optimizer starts x writes calculated optimization data to a database y and then finishes z .
x optimizer.optimizestart y optimizer.writeoptimizationdata z optimizer.optimizefinished in the remainder of the paper we will use the symbols a g andx z to denote these event names when explaining our approach.
all these events have associated data elements e. g. dis related with a data element containing the calculations the optimizer performed on how to cut the steel slabs.
iv.
a pproach our approach aims at finding constraints based on structures and patterns reappearing in rich event logs.
it applies techniques from specification mining process mining and machine learning .
we build on r eminds which can record rich event logs in industrial sos and uses a dsl to specify and check temporal and value constraints.
reminds records the origin of each event i. e. the system in the sos emitting it.
using domain knowledge engineers can also define the start and end events of different system tasks.
this allows us to split the events monitored from the sos by system and event sequence thus creating individual event logs for all runs of all systems in the sos.
as a result each event log used in our algorithm contains exactly one event sequence i. e. the events produced by one sub system during one run.
our constraint mining approach takes these rich event logs as input and automatically performs the following four steps also depicted in figure .
a. creating sequence type trees the first step aims at finding the most frequent event sequences for each event sequence type following ideas from the field of process mining .
a tree with nodes containing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure .
four step approach for mining and ranking constraint candidates.
event types is built for each event sequence type contained in the recorded event logs.
the branches of the trees represent one specific order of events that appeared in at least one event sequence.
figure shows an example of a sequence type tree created from the event types a to g cf.
section iii .
there are six different branches all starting and ending with the same events a and e .
when processing one event sequence our approach increases the counter for each event in the respective branch or adds a new branch with counter if the tree does not yet cover the observed sequence.
for example adding another event sequence a b c d e to the tree shown in figure would increase the counter for these five events in the left most branch by one leading to for a for b and for c d and e. however when instead the sequence a b xy would be added only the counters for a and b would be increased and a new branch for x y would be created as child of b with the counter for both x and y .
after this first step our approach can already propose temporal constraints based on the events from the branch with the highest counter of each sequence type tree.
one example from our experiments is the constraint ranked highest in table ii.
it represents the branch with the highest count in figure a b c d e .
we thus assume that these events represent normal behavior while the other branches are exceptions.
however even event sequences occurring only once could represent normal behavior.
our approach thus suggests different constraint candidates based on the frequency analysis.
automatons built from extracting and merging behavioral patterns lose information on the frequenciesa g e e c d e b d c e f c d e c d e figure .
example sequence type tree produced in step of our approach see section iii for the real names of the events from the industrial sos .
of specific event sequence thus making it impossible to determine the most common sequence needed for proposing temporal constraints.
we thus use sequence trees as a simple way of distinguishing and counting different event sequences.
a downside of these trees compared to automatons is their higher use of memory.
however we only store the event types and counters in the tree to keep memory as low as possible.
b. creating mappings to feature vectors in the second step our approach creates a mapping to a feature vector based on the sequence type trees.
for this purpose we first extract the data elements e. g. data element values sources and timestamps for all event sequences in the most common branch of the sequence type tree i. e. the tree branch with most sequences associated.
furthermore our approach generates new data elements containing the time difference between the events based on their timestamps.
this is done independently for each sequence type tree.
the approach then maps all event sequences from other branches containing the same order of events as the main sequence to a feature vector.
however we ignore data elements from any of these additional events.
the reason for using sequences with additional events is that in an sos multiple systems work in parallel and events from other systems might occur at the same time.
one example for this can be seen in figure where the branch a b c d e is most common.
however the algorithm also transforms the sequences a b fc d e containing an additional f into feature vectors but ignores the event f and the data elements associated with it.
during the mapping our algorithm aims to find data elements that contain the same value in all valid event logs.
these constant data elements are assumed to remain unchanged for valid runs and are thus extracted as constraint candidates.
for example in table i the data element d.excocc indicating that an exception occurred is constant for all traces and is therefore extracted as a constraint specifying that excocc has to be false ford.
an example of a constraint extracted authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i example fields of feature vectors produced in step .
d.thread d.process d.excocc e.process time 0 time 1 t 243 tr 2 v14 false tr 2 v14 t 239 tr 2 v14 false tr 2 v14 t 243 tr 2 v14 false tr 2 v14 t 239 tr 2 v14 false tr 2 v14 in this step during our experiments is the second constraint shown in table ii.
additionally our algorithm detects constraints affecting multiple data elements from different events that need to have the same value in one event log equal data elements .
for instance the event data element d.process containing the version of the software equals the value of e.process in all feature vectors cf.
table i .
it is therefore assumed that these two data elements will also share a value for all future logs and a constraint can be suggested to check this assumption.
an example of a constraint extracted in this step during our experiments is the third constraint in table ii.
c. learning constraints in the third step we use the machine learning tool suite weka to train a decision tree using the j48 algorithm and a rule based classifier using the jrip algorithm from the feature vectors representing the event logs created in the second step.
the model that was learned i. e. the output from these classifiers is analyzed and used to identify both valid or invalid event data element values for nominal attributes and thresholds for numeric values which are then turned into constraints similar to related techniques from the area of product line engineering as described in section ii.
the class for all vectors is set to valid for event logs without defects and to invalid for event logs containing defects i. e. unexpected behavior .
event logs recorded by the monitoring tool could be marked as invalid by system users reporting unintended system behavior after crashes or by detecting unusually long delays in system execution.
for the rule based classifiers we can parse the rules and transform all conditions that lead to a valid classification as well as negations of conditions that lead to an invalid classification into constraints.
we can also transform the branches of the decision trees into constraints that lead to a valid classification.
branches of the decision tree that are classified as invalid can be ignored as their branching criterion is the negation of the path leading to a valid leaf.
both the rules and the branching criteria can be checks for a constant data element e. g. b runid or for a threshold e. g. d runid .
additionally the rules can contain the basis for extracting intervals cf.
section ii if one rule contains both an upper and a lower bound for a value e. g. time 1 and time 1 .
an example for a decision tree can be seen in figure .
in this part of the tree three different criteria need to be fulfilled to reach a leaf that is classified as valid d runid ... d.runid time 0 inv alid e.runid valid invalid 127inv alid figure .
part of a decision tree time 0 and e runid .
these three conditions can be extracted as individual constraints.
two examples extracted in this step are the fourth and fifth constraints in table ii.
d. ranking constraints in the final step the extracted constraints are ranked such that the constraints that are more likely to be accepted by users get a higher priority.
the ranking is based on different scores for each constraint using the type of constraint and the number of the valid and invalid event logs for which the constraint is fulfilled for.
constraints satisfied for valid and violated by invalid event logs are given a higher score.
our algorithm also ranks temporal constraints higher than value constraints as temporal constraints directly reflect the actual most common sequence of events representing system processes machine cycles for the respective sequence type.
they therefore have a high probability of being accepted as true constraints.
however this might not be applicable for other systems and might have to be changed when adapting the algorithm for other scenarios.
furthermore constraints that are fulfilled by less than a defined threshold percentage of the valid event logs e. g. in our case are ignored.
e. implementation we have been implementing our four step approach using java and the weka tool api.
rich event logs are produced by r eminds as text files and event data is represented using json each step of our constraint mining approach is represented by an individual java package the earlier steps of the approach can be performed independently e. g. if no class value is available as needed to perform step and the individual steps can be easily exchanged or adapted.
we currently produce a textual output of the ranked list of mined constraints.
v. p reliminary evaluation we conducted experiments using rich event logs from a real world automation sos of our industry partner cf.
section iii to demonstrate the feasibility of our approach.
we also collected feedback on the mined and ranked constraints from experienced engineers of our industry partner.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii example constraints mined and ranked by our approach based on rich event logs from the industrial sos.
rank constraint scores 1if event controller.requestoptimization occurs events optimizer.feeddata start optimizer.feeddata finished optimizer.calculateresult cutting.feedoptimizationresult occur consecutivelytemporal constraint if event controller.requestoptimization occurs data general process trackingcore value constraint 3if event controller.requestoptimization occurs data general .
process cutting.feedoptimizationresult .
general .
process value constraint if event optimizer.feeddata finished occurs data general process trackingcore value constraint 5if event optimizer.feeddata start occurs time until event optimizer.feeddata finished .
secondsvalue constraint a. experimental setup we recorded the event logs using a simulator provided by our industry partner that executes the actual steel casting automation software but simulates the plant hardware based on real plant data recorded earlier.
we instrumented the sos with probes created by engineers of our industry partner using reminds .
the event logs used for our experiments contained a total of sequences of the two different sequence types a g and xz described in section iii.
to test our approach we modified the sequences in the rich event logs by automatically seeding random differences i. e. for each of the event sequences both the original version and a second randomly altered version are used resulting in a total of sequences.
our modifications included changing the value of individual data elements and changing the time between two events.
for each event log our algorithm randomly selected and applied one of these change types to create the altered version.
event sequences with differences were considered as inv alid for the purpose of this evaluation while event sequences without changes were considered as v alid.
b. results we describe the results of our preliminary evaluation following the four steps of our approach creating sequence type trees.
step resulted in two sequence type trees one of which is depicted in figure .
due to the cyclic behavior of the optimizer system in both trees one branch clearly represents the most common event sequence of and of event logs respectively allowing to suggest the first constraint for each sequence type.
mapping to feature vectors.
in the second step our approach mapped the event logs that fit to the most common branch of each sequence type tree to feature vectors.
the resulting feature vectors include the event data extracted from the event logs and the time between the events.
examples of partial feature vectors can be be seen in table i. in this step a total of value constraints could be mined and suggested.
learning constraints.
the third step created a decision tree using j48 and a rule set using jrip for each event sequence type and analyzed these two prediction models.
from these analyses our approach could learn and suggest a total of constraints for the two sequence types.ranking constraints.
in the last step our algorithm ranked all yielded constraints by type and frequency of violation.
table ii shows examples of constraints and the scores calculated to rank them cf.
section iv d .
overall constraints were automatically mined using our approach for the first sequence and for the second sequence.
we showed the highest ranked constraints of the more common sequence to engineers from our industry partner and they regarded of these mined constraints as useful for inclusion in the monitoring infrastructure.
considering that our approach works fully automatic and considering the limited size of the event logs we used in our preliminary evaluation these results are promising indicating the feasibility of our approach.
further as confirmed by our industry partner even mining only a few constraints automatically is a huge benefit compared to manual definition of constraints.
c. threats to validity our preliminary results demonstrate the basic feasibility of our approach.
even though we used rather small event logs from just one system and randomly modified these logs to produce invalid logs we regard them as representative for larger logs we have seen so far in the sos of our industry partner with regard to cyclic behavior and the structure of event data.
regarding the scalability of our approach we yet have to conduct larger experiments.
we further have to apply our approach to other systems to investigate its generalizability.
a threat regarding the learning part step of our approach is that when using our approach in practice it might not always be possible to obtain rich event logs that contain a class label valid vs. invalid e. g. if no runs with unintended behavior occurred or this is not known.
however there are several possible ways to deal with this issue one solution is to mine constraints based on the distribution of the observed values e. g. define an interval based on the lowest and highest value encountered or define a set of valid nominal values including the most commonly observed value s .
our approach however is also useful even when skipping the learning part altogether and only using the constraints extracted in the first two steps.
vi.
c onclusion and future work we presented an approach for automatically mining constraints from rich event logs recorded by a monitoring tool in an sos.
our approach builds on ideas from specification authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mining process mining and machine learning.
it combines and enhances existing algorithms to use them in the field of event based monitoring.
while our approach uses rich event logs to mine candidates for temporal and value constraints it can also mine certain constraints based on simple event logs.
our algorithm represents an automated solution for a real world industry problem definition and maintenance of constraints.
using examples from a real world industrial automation sos we demonstrated that our approach is capable of extracting constraints expressed in an existing dsl.
of mined constraints were regarded as useful by engineers of our industry partner.
in our future work we will apply our approach to other systems and conduct experiments with larger event logs and different systems to test its generalizability.
furthermore we will implement end user tools allowing engineers to configure our approach and to select the ranked constraint candidates and automatically activate them in a monitoring tool.
also we plan to extend our approach allowing users to provide additional information e. g. domain knowledge about known cycles and issues to the mining and learning algorithms to mine more constraints and even other types of constraints.