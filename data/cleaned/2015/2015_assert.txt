see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation assert use in github projects conf erence paper may .
ic se.
.
citations 47reads author s including premk umar de vanbu univ ersity of calif ornia davis publica tions citations see profile ab lio est eves cale g rio de oliv eira ibm publica tion citations see profile vladimir filk ov univ ersity of calif ornia davis publica tions citations see profile baishakhi r ay columbia univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y ab lio est eves cale g rio de oliv eira on januar y .
the user has r equest ed enhanc ement of the do wnlo aded file.assert use in github projects casey casalnuovo prem devanbu abilio oliveira vladimir filkov baishakhi ray computer science dept.
univ.
of california davis ccasal ptdevanbu vfilkov abioliveira bairay ucdavis.edu abstract asserts have long been a strongly recommended if non functional adjunct to programs.
they certainly don t add any user evident feature value and it can take quite some skill effort to devise and add useful asserts.
however they are believed to add considerable value to the developer.
certainly they can help with automated verification but even in the absence of that claimed advantages include improved understandability maintainability easier fault localization and diagnosis all eventually leading to better software quality.
we focus on this latter claim and use a large dataset of asserts in c and c programs to explore the connection between asserts and defect occurrence.
our data suggests a connection methods with asserts do have significantly fewer defects.
this indicates that asserts do play an important role in software quality we therefore explored further the factors that play a role in assertion placement specifically process factors such as developer experience and ownership and product factors particularly interprocedural factors exploring how the placement of assertions in methods are influenced by local global network properties of the callgraph.
finally we also conduct a differential analysis of assertion use across different application domains.
i. i ntroduction the idea of assertions which can be automatically checked at runtime dates back some years .
most popular programming languages including c c java python all provide support for assertions and run time checking some languages even consider assertions and assertion based programming as central to their design e.g.
eiffel turing .
assertions are widely taught in undergraduate curricula and it is reasonable to assume that the majority of practicing programmers are well aware of their use and advantages.
run time checking is certainly not the only use of assertions the use of assertions in program verification also has a distinguished history dating back to floyd in the 1960s .
while the technology of automated verification has made tremendous strides hoare laments that assertions in practice are not often used in the context of automated verification.
however the formerly stated purpose of assertions viz.
for run time checking is in fact often exploited by programmers in the trenches.
steve mcconnell the author of many popular programming cook books for software practitioners heartily advocates the use of assertions to give programs a death wish .
this is in order to promote the timely and highly visible failure of a program should it reach a state in which there are some inconsistent or invalid data values clearly in evidence.
such an immediate and self evident failure would be far easier to diagnose than a delayed failure obscured by more widespread data corruption.
in addition to supporting debugging and fault localization asserts are also thought to promote readability.
for example the intended purpose and function of a loop arguably becomes far more evident in the presence of an assertion indicating the termination condition or an invariant assertion.
thus besides aiding fault localization during intensive coding sessions assertions may also help programmers better understand code and avoid constructing faulty code in the first place.
so it is quite reasonable to advocate for the use of assertions on the basis of the above two arguments assertions will make for more informed programmers who make fewer mistakes and help isolate errors quickly even if mistakes were made.
all the above discussion admittedly is largely of a theoretical nature.
do these theories hold up in practice?
the central concern of this paper is a study of the practical use of assertions .
we collect a large corpus of the most popular cand c software projects on github and using this corpus we conduct a series of empirical analyses and make the following contributions assertions are widely used in popular candc projects.
of the projects contain more than a minimal presence of assertions and this subset of projects contain in total 35m lines of code.
in these projects we find that .
of methods contain assertions.
we find that adding asserts has a small but significant effect on reducing the density of bugs and that as the number of developers in a method increases adding more asserts can reduce the occurrence of new bugs.
asserts tend to be added to methods by developers with a higher ownership of that method.
additionally developers with more experience in a method are more likely to add asserts.
in the structure of the call graph network methods with asserts are more likely to take on the role of hubs a network role that gathers dispenses information from to other nodes.
we compared the number of asserts in projects with different application domains but found that domain did not significantly affect the number of asserts used.
ii.
r esearch goals we sought to understand how assertions are used in practice in particular the process outcomes that are associated with the use or disuse of assertions.
we begin with the oft stated goal of assertions here articulated eloquently in the python wiki1 assertions are a systematic way to check that the internal state of a program is as the programmer expected with the goal of catching bugs.
in particular they re good for false assumptions that were made while writing the code or abuse of an interface by another programmer.
in addition they can act as in line documentation to some extent by making the programmer s assumptions obvious.
the strong implication that assertions are a way to improve quality outcomes is unmistakable.
this leads directly to our first research concern rq1.
how does assertion use relate to defect occurrence?
in examining the last sentence of the quote above we can see that it clearly speaks to the documentary or communicative value proposition of asserts whereby they are used to communicate important assumptions to other developers that may be examining the same code perhaps with a view to making modifications.
because of this we might reasonably expect that assertions are associated with process aspects of asserts specially the process aspects that relate tocollaboration .
collaborative and human process aspects have long been a concern in empirical software engineering.
previous2research has explored the effect of factors like ownership experience and number of developers on software quality.
given the communicative value of asserts it would be interesting to investigate whether collaborative aspects of software relate to assertion use.
fortunately modern version control systems afford the reliable and straightforward measurement of process properties such as ownership and experience.
rq2.
how does assertion use relate to the collaborative aspects of software engineering such as ownership experience and number of committers?
while process factors the how of software are important for assertion placement one can certainly expect that the product also matters programmers decisions on where to place asserts will almost certainly be influenced by what software they are building and which element of it they are working on.
there are certainly a great many properties of software and software elements relating to size complexity coupling cohesion etc.
but a comprehensive examination of all is beyond the scope of our work.
in this paper we focus on one specific aspect of assertion placement inter procedural aspects that relate to assertion placement.
in particular we focus on call graphs.
call graphs are a useful abstraction that capture the modular dependencies in programs.
in our study all the projects are candc based.
since c is an object oriented language it is not always feasible to statically determine accurate call graph of c programs due to oo properties like inheritance and polymorphism.
so we focus on ccall graphs nodes are cfunctions and a directed edge from function f1tof2exists iff1explicitly calls f2.
static tools can build call graphs by analyzing source code but these are clearly approximations when calls through function pointers are present.
nevertheless call graphs are widely used for various empirical studies .
they have also been extensively used in architecture recovery .
2there are numerous other papers we just cite a few representatives.we begin here with the hypothesis that the placement of assertions within methods relates to the role the method plays in the overall system and that this role is captured in the architecture of the call graph .
while this is indeed a strong assumption the prior use of call graphs for architecture recovery provides some justification.
the more important or central a method we expect the more likely it is that developers will be inclined to place asserts therein.
the field of network science has produced a variety of algebraic approaches to obtain numerical measures of centrality of roles played by nodes in a network.
these measures include local measures such as in degree and out degree and global measures such as betweenness centrality kleinberg s hubandauthority measures etc.3by determining the association between nodes importance in a call graph with outcomes of interest one can gain intuitions about which aspects of the network position of a node are most strongly associated with the given outcome.
for example nodes with high centrality in biological networks are related to organism survival .
similarly in sociology high centrality corresponds to higher social capital .
these types of measures have also been applied before to software dependency graphs thus it reasonable to effect that such measures may well prove strongly associated with assertion placement.
rq3.
what aspects of network position of a method in a call graph are associated with assertion placement?
finally as mentioned earlier the application domain of a software system may be expected to be related to assertion use.
we have recently categorized github projects into six general and disjoint domains including databases libraries etc.
as code in these different categories may be substantially different it is reasonable to expect that the code development process including debugging may be different across these domains.
while there we did not find a relationship between code quality and application domain in our prior work assert use might be related to the domain.
thus we ask rq4.
does the domain of application of a project relate to assertion use?
iii.
r elated work assertions have a long history and have been a durable subject of great interest specially in the area of tools and methods to a generate assertions e.g.
daikon b assertion checking and c verification4 .
assertions have also influenced language design notably eiffel which introduced the notion of design by contract .
our goal in this work is an empirical analysis of assertion use in a large program corpus so we confine our related work discussion to work on empirical analysis of assertion use.
these empirical studies fall into two broad categories descriptive studies of the kinds of assertions in practical use and the studies of quality impact of assertion use.
3we have used kleinberg s hubs and authorities successfully earlier for finding methods relevant to a given method as they are well suited to software call graphs they provide helpful ways to identifying nodes that play an important role in the global flow of dependencies within a directed graph 4the literature is extensive only a few representative works are citeda.
studies of assertion usage there have been several studies on the general usage of assertions and contracts in open source and proprietary systems.
chalin performed two studies to understand assert usage.
first was a survey of developers concerning assertion usage and how errors within invariants themselves should be reported.
he found that of the developers used asserts in their coding at least occasionally .
this was then expanded upon in a study in eiffel projects with projects from open source eiffel libraries and proprietary software.
he found about half the asserts were preconditions followed by postconditions at and about .
were invariants.
just over a third were null checks.
as a percentage of lines of code assertions made up .
of the libraries .
of the open source projects and .
of the proprietary software.
jones et al.
studied java eiffel and c projects that consciously made extensive use of asserts .
they found that the number of asserts scaled with project size and that assertions changed much less frequently than the other code.
they also reported only minor differences between the use of preconditions postconditions and object invariants though preconditions tended to be more complex than postconditions.
our work is complementary we studied usage of assertions in popular open source c c projects with no specific commitment to assertion usage as opposed to carefully choosing projects with high code assertions usage.
our interest is to study how regular developers use assertions in a daily basis.
also as opposed to jones et al.
we noticed volatile nature of assertions with significant number of deleted or modified assertion .
of total added assertions are deleted or modified .
researchers have also compared automatically generated assertions with those that developers write.
polikarpova et al.
did a small study comparing daikon generated assertions with developer written assertions in classes.
they found that while daikon generated more valid assertions than those written by developers it could not recreate all the assertions written by developers.
additionally about a third of the generated assertions where not correct or not relevant .
schiller et al.
studied microsoft code contracts in c projects in order to understand how to help developers use them more effectively and also used daikon to automatically generate assertions for these projects.
they found most developer written assertions were null check preconditions and that daikon generated many more potential postconditions than the developers wrote.
b. quality impact of assertion use do asserts and contracts help developers identify the source of a fault once an assertion identifies an invalid system state?
early work explored using syntactic mutations to identify less testable code regions where internal invalid states might not be observable in the output and then adding asserts in such regions .
several later studies all used syntactic mutations to introduce new errors and examined how well asserts could detect and isolate the faults.
shrestha et al.
found significant improvement in assertions detecting the mutatederrors over the basic runtime error detection in java using jml a java assertion library.
the runtime error detection found only of the faults but the assertions found another of the faults missed by the basic runtime checker .
briand et al.
compared the ability to identify the source of a mutated fault with and without assertions using the of number of methods between where the error was detected and the line responsible as a metric of diagnosability.
they found adding assertions improved the diagnosability significantly .
baudry et al.
found significant increases with diagnosability when adding assertions as well but also found a upper bound on improving diagnosability by just adding more asserts that that the quality of asserts was more important .
our study differs in that looks at bugs at a higher granularity and is not concerned with diagnosability.
we also focus on actual bugs and not bugs induced by mutation and our sample size is much larger than any of these studies.
additionally there a study comparing asserts and n version programming abilities to detect errors .
they compared the additions of assertions by graduate students with and version voting to determine the effectiveness of each in error detection.
they found both method identified similar if different numbers of faults but that the assertions were better able to pinpointing the errors and providing useful information.
muller et al.
used app and jcontract extensions that add assertions to c and java in two experiments with computer science graduate students to see how assertions affected the quality of output and the effort of the programmers.
they looked at instances where programmers were extending existing code and writing new code.
they found some evidence that the assertions decreased programmer effort in extending existing code but the reverse was true in new code.
they also found that the assertions increased method reuse and that they slightly improved reliability however the small size of the experiment limited the significance of their results and its generalizability.
most closely related to our work was a small a case study by kudrjavets et al.
on two microsoft projects comparing the density of asserts with the density of bugs in the files.
they found a small negative correlation between assert density and fault density where as the density of asserts increases the fault density decreases .
we extended this study and confirmed their findings.
iv.
m ethodology a. study subjects to understand usage patterns and code quality effects of asserts in a representative set of projects we decided to use the most popular github projects written primarily in c c or both.
among these we excluded projects where fewer than asserts were ever added.
this left 69projects with distinct authors with distinct files and methods with project histories that dated back as far as .
table i shows a summary of the projects we used in this paper including linux gcc mongodb opencv php src git numpy etc.
while assertions have appeared in about .
of methods overall the assertions appear farmore frequently in c methods with about a rate of .
in comparison to a rate of only in the cmethods.
c c overall project details projects authors kloc files methods assert methods period all commitstotal assertion bugfix commitstotal assertion table i study subjects.
total represents number of commits with atleast one added lines.
assertion represents total number of commits with atleast one assertion in the added lines.
b. data collection retrieving project evolution history for all projects above we retrieved the full history all non merge commits along with their commit logs author information commit dates and associated patches.
most of the data collection was done in may .
we used the command git log u1 w where the option u1 downloads commit patches and woutputs method names for which the code has been added.
we then removed commits not affecting candc source and header files.
next we marked files either testorsource file depending on the presence of the keyword test within the file names.
we disregard all the test files from our analysis because use of assertion in test context is very different from the present scope of the paper.
we further identified bug fix commits made to individual projects by searching their commit logs for these error related keywords error bug fix issue mistake incorrect fault defect and flaw using a heuristic similar to that developed by mockus and v otta .
we implemented an assert classifier that collects assert specific statistics from commit patches by searching for the keyword assert .
we ignored the case of this word and included it also when it was a substring of a larger method name in order to not only capture the standard cassert function but also various developer created macros and assert functions specific to individual projects.
for example project gcc frequently use functions like gcc assert or dbug assert as opposed to standard assert statements.
additionally we first removed source code comments from the patches.5finally we collected the number of assertion added and deleted per commit per project by parsing the added and deleted lines respectively from each commit patch.
to evaluate the precision of the assert classifier we selected random segments of commit patches that were marked as containing asserts.
no more than three commits were taken from each project to minimize project specific bias.
we then manually checked the actual number of asserts added and 5we disregarded the context of changes that represent unchanged source code since we were only interested in evolutionary aspect of assertion.removed in each segment.
if an exact match was found that instance was marked as correctly labeled otherwise it was marked incorrectly labeled.
the initial precision was around which we improved by eliminating asserts in comments and headers.
after the improvements our final classifier had a precision of across all projects.
of the mislabeled ones manual examination showed that two cases out of the hundred were not asserts and three cases were ambiguous.
collecting process statistics to see the number of asserts added and deleted to a method over its lifetime we sum the asserts added in each method on a per commit basis using the text parser described above.
we similarly find the total lines and removed per method as well as calculate the total number of commits and committers to each method.
we collect these statistics both for the methods themselves and for the individual developers who contributed to each method.
retrieving the call graph to investigate where asserts are used w.r.t.
a project s overall structure we gathered methodlevel call graphs for different cprojects from their repository versions at data gathering time.
we did not attempt call graph derivation for c programs due to complications arising from virtual function dispatch.
first using llvm s clang tool7 the front end for the llvm compiler we parsed csource files to collect the names of all methods present in each.
we adapted the printfunctionnames pass that comes with the llvm distribution to implement this step.
second for each of the projects we built a cscope8 database for all cfiles containing project specific symbols and their dependencies including method level caller callee relationships.
such databases can be used to browse source code of very large projects like linux gcc etc.
third we combined the results from the two steps above for each method found by clang we queried the corresponding cscope database to retrieve caller callee information associated with it.
in particular for a queried method option 2was used to find methods called by it and option 3was used to find methods calling it.
we merged the caller and callees for each method to build a method level call graph.
we further estimated the size in terms of sloc of each method.
this was necessary because size can be a confound in our network analysis step.
for example large methods may make many calls to other methods and thus can have higher out degree.
therefore network measures such as node degree betweenness and hubs authorities may correlate with method size.
to address the effect of this potential confound first we removed the commented code from method body.
then we measured size of the methods using ctags9which retrieves the line number of different elements in cfiles.
we extracted the line numbers of methods structures define statements and typedefs for each file sorted them based on line number 6one of the two false positives was a comment that slipped through the filtering and the other was a define statement that specified assertion behavior but was not itself an assert.
the three ambiguous cases were functions related to asserts or potential asserts implemented in non standard ways.
estimated the size in loc of each method by subtracting its starting line number from the line number of the next marked element.
obviously this is only a rough estimate so we randomly selected or methods from each of the projects to obtain total samples and manually checked if the approximated loc was within a margin of error of lines.
in cases this was true and in none of the observed error cases was the estimate extremely different from the actual size.
therefore this estimate is an appropriate measure for roughly distinguishing between different sized methods.
c. statistical methods we use statistical tests and statistical regression modeling to reject hypotheses and answer our research questions in the r statistical environment .
to test for a difference in the means between two populations we use the non parametric wilcoxon mann whitney test for unpaired samples and the mann whitney paired test for paired samples.
we interpret the results using p values indicating the likelihood of a hypothesis being true by chance and supplement those with the cohen s d effect size values .
boxplots are used to visualize different populations.
regression models are in general used to describe the effects of a set of predictors on a response or outcome variable.
in this paper we use multiple linear regression and generalized linear regression to model the effect of the number of asserts per method commit on outcomes e.g.
defects related to software projects.
our data presents special challenges most of our predictors are counts of asserts developers and defects and an overwhelming number of commits to methods has neither asserts nor defects i.e.
the number of zero values overwhelms the non zero values.
fitting a single multiple regression model on the entire data carries the implicit assumption that both the zero defect zero assert and non zero defect assert data come from the same distribution which may not be valid.
where necessary e.g.
when modeling defects as outcomes we deal with this issue by using hurdle regression models in which there are two separate models.
the first models overcoming a hurdle the effect of passing from a defect count to a count the second models the effect of going from one non zero count to another non zero count.
typically the two models use nonlinear multiple regression with different linking functions.
the hurdle model is usually as in our case a logistic regression the count is a poisson or negative binomial regression10 .
following the regression modeling we use analysis of variance anov a to establish the magnitude of the significant effects in the models.
we get that by observing the reduction in the residual deviance associated with the variable s effect.
we log transform dependent non count variables as it stabilizes the variance and usually improves the model fit .
to check for multi collinearity we use the variance inflation factor vif of each dependent variable in all of the models with a threshold of5 .
we filter and remove outliers in the data where noted.
10neg.
binomial compared to poisson regression produces narrower confidence intervals on over dispersed data with smaller number of observationsv.
r esults we organize our result reports by the research questions discussed earlier in section ii.
we begin with rq1 studying the effect of assertion use on defects.
rq1.
how does assertion use relate to defect occurrence?
as reported in numerous earlier studies any study of defect occurrence is always confounded by several factors most critically by the size of the module under investigation .
size has generally been found to be strongly associated with defect occurrence as one would reasonably have expected we can also reasonably expect that size will be strongly associated with assert occurrence.
another oft found confounding factor in defect modeling is the number of committers previous research reports a too many cooks phenomenon leading to quality issues arising from increased numbers of contributors.
thus here we model total defects in methods as a function of total asserts with size and developer count as controls.
we use hurdle regression modeling which entails two separate models hurdle and count see methodology and is appropriate in our case as adding the first assert is a hurdle to overcome different than adding the second third etc.
for the hurdle model we use a logistic regression generalized multiple regression with a binomial variance function to model the binary outcome of having an assert or not having one in a method total lines of code added and number of developers are controls.
each row in this model represents a project method or other container like structure union and enum .
we do this on the full data set of methods and containers left after filtering extreme points.
that corresponds to asking is there an effect of adding an assert on there being or not a defect in the method s history?
with the hurdle overcome the second or count model considers only those methods whose histories include at least one defect repair and which have at least one assert added.
in it we regresses defect counts on assert counts controlling for lines added and the number of contributors.
it corresponds to the question looking only at the methods with non zero asserts added and non zero defects reported what if any is the effect of adding an assert on the number of bugs?
we use quasi poisson regression with a log linking function to model the counts.
in both models we log transformed the lines of code added variable as it exhibited a log linear distribution and is not strictly a count variable.
the modeling results are presented in table ii.
the left column contains the hurdle model coefficients and the right contains the count model coefficients.
we note that the effect of asserts on defects is negative in both models in alignment with popular belief that the effect of asserts is salutary viz.
towards diminishing defect occurrence.
the effect size is small but highly significant in the hurdle model accounting as per the anov a analysis for about of the deviance of the developers variable and of that of the total data.
the effects of the controls are much larger as expected.
the effect of asserts on bugs in the count model is almost insignificant and the magnitude of the effect is negligible overall.
both models together indicate that adding the first assert to a file has a significant and sizable effect on bugs but after the first on average for all developers adding additional asserts has no appreciable difference.
the variance inflation factor was well controlled in both models.
we further examined the smaller data set of methods with non zero asserts and non zero defects to study how the presence of asserts in a method relates to defects when there are more or fewer developers to that method.
to that end we split the data into two parts around the median number of developers per method and then applied the count model from the right side of table ii to each.
the results are in table iii.
they show that interestingly adding asserts has a significant mitigating effect on defects when more developers are involved.
in fact even adding more lines of code seems not to be a risk for having defects in this case suggesting a salutary effect of assert use on defects perhaps asserts are a particularly useful aid for communication when many perhaps less experienced minor contributors are involved we plan to pursue this in future research.
on the other hand asserts seem not to matter when fewer developers commit to a method.
the anov a analyses indicate that the size of the effect of asserts on defects is small compared to that of number of developers but is magnified for the group with higher number of developers per method.
again the vif of the model variables are below .
dependent variable total bug as binary total bug logistic glm quasipoisson link log hurdle model count model log t a loc .
.
.
.
developers .
.
.
.
total asserts .
.
.
.
constant .
.
.
.
observations log likelihood .
akaike inf.
crit.
.
note p .
p .
p .
anov a for hurdle model df deviance resid.
df resid.
dev null .
log t a loc .
.
dev .
.
total asserts .
.
anov a for count model df deviance resid.
df resid.
dev null .
log t a loc .
.
dev .
.
total asserts .
.
table ii bug analysis model.
t a loc stands for total added lines of code .
the count model is for the dataset total asserts total bug case study building on the quantitative study above we present some case studies of asserts being added in bug fixing commits in our dataset.
we chose cases from two projects linux and mysql.
we manually examined and commits that had been marked as bug fix commits and have addeddependent variable total bug more fewer developers developers log t a loc .
.
.
.
dev .
.
.
.
total asserts .
.
.
.
constant .
.
.
.
observations note p .
p .
p .
anov a for more developer model df deviance resid.
df resid.
dev null .
log t a loc .
.
dev .
.
total asserts .
.
anov a for fewer developer model df deviance resid.
df resid.
dev null .
log t a loc .
.
dev .
.
total asserts .
.
table iii model explaining behavior of assertions and total bugs in methods touched by higher lower numbers of developers.
asserts from each project respectively.
we chose these two projects because both are popular well established both extensively use assertions and both are from relatively different domains.
by reading the bug fix commits bug reports from mysql bug database11 our examined linux commit messages did not regularly document bug ids and the associated patch we manually determined whether the assert was supporting the bug fix.
out of commits that we manually examined we could relate of them where asserts were added to support bug fixes.
in rest of the cases there was either a mislabeling of commits or we could not relate assertions directly to the bug sometimes the commits were too large or addressed multiple issues which made the assert s relation to a bug fix unclear.
table iv shows several examples of bugfix commits where assertions are used in conjunction with bug fixes to help prevent future errors.
in example there were invalid memory reads caused by reading past the end of a buffer.
the error was fixed but the assert was also added to make sure that future reads do not read from unallocated memory see the commented lines in the table marked in blue .
the second example is of an assert checking the system state.
this commit was working on a group of related bugs where the sql command load data infile was causing problems either hanging or leading to missing data if the operation was performed after a delete.
part of the fix included restarting the transaction during the end of a bulk insert and the assert is added into to make sure that resetting is successfully completes.
here the assert does not check for the existence of the old error but helps to protect against new errors occurring.
finally the third example uses an improbable condition assert.
the original bug was caused because the code was not checking for all possible values of flagcount cuted fields in the code.
this which was fixed by enumerating all of them in a switch statement.
the assert added to check for memory error author alexey kopytov date file sql net serv.cc log fix bug allocate an extra safety byte to network buffer for when uint3korr reads the last bytes in the buffer.
my real read net net ulong complen the following uint3korr may read bytes so make sure we don t read unallocated or uninitialized memory.
the right hand expression must match the size of the buffer allocated in net realloc .
dbug assert net where b net header size sizeof uint32 net max packet net header size comp header size example assert added to check system state successful restart in this case .
author tomas poseidon.ndb.mysql.com date file sql ha ndbcluster.cc int ha ndbcluster end bulk insert if execute no commit this trans !
no uncommitted rows execute failure my errno error ndb err trans if m transaction on ... else ... int res trans restart dbug assert res example assert added to prevent impossible condition.
author tatiana a. nurnberg date file sql field conv.cc log summary fix for bug where check field ignore was treated as check field error for null set field to null field field if field table in use count cuted fields check field warn ... switch field table in use count cuted fields case check field warn ... case check field ignore ... case check field error for null ... dbug assert impossible table iv examples of asserts added to assist with bug fixes from mysql.
the ellipsis indicates code changes omitted for space reasons.
the lines started with indicates added lines and started with indicate deleted lines in a commit patch.
a majority of asserts in mysql use the macro dbug assert a part of its dbug package.
the asserted statements are marked in red.
usage mysql linux memory pointer concurrency comparison to null impossible condition bounds and range checks system state planned asserts table v different usage of asserts for fixing bugs.
assert added at the end to handle a default case where the flag is some value outside the expected set.
if this set were expanded or changed in the future without this region of code being updated the assert would assist in catching the error.
these examples clearly show how asserts actually help to prevent future bugs.
in order to gain a sense of what types of asserts were being added we further classified the asserts into seven categories as shown in table v. this includes checks on memory and pointer validity in the assert clause checking concurrency related artifacts like semaphore mutex locks etc.
checking for null conditions asserting an impossible condition the system should never reach example in table iv checks on array bounds variables range validity ensuring valid system state bychecking the value of system flags example and planned asserts where comments showed locations where developers wanted to add more asserts in the future.
as each bug fix commit may contain several asserts and each assert may fall into multiple categories the categories are not disjoint.
for instance a zero comparison assert may also be checking system state.
beyond the system state checks we found null checks to be most common which agrees with other similar studies of asserts and contracts in general .
rq2.
how does assertion use relate to the collaborative human aspects of software engineering such as ownership and experience?
asserts are conceptually difficult requiring a fair bit of effort and knowledge to craft and add to the appropriate location.
we can expect that developers adding asserts have a high degree of commitment to the specific code types and values as well as an algorithmic conceptual understanding of the underlying logic.
thus we might expect that developers adding asserts to a method mhave a greater degree of ownership of it than ones who just simply add code.
we can also expect that those adding asserts to mhave acquired some degree of skill oradded asserts didn t add asserts0.
.
.
.
.
.0ownership of developersownershipfig.
developer ownership in methods to which they added asserts is greater.
outliers removed.
experience with method m. these are related but not identical aspects in a very actively changed method one might gain a lot of experience without gaining a high degree of ownership by the same token in a small method one can gain high ownership without much experience.
we therefore investigate the relationship of both to assertion addition separately.
we calculate ownership for each developer method pair.
thus if there are a total of commits to method m and developer dmade of them then d s ownership of mis .
.
this measure of ownership has previously been used at the level of files we extend it to the method level.
we calculated ownership for all developers in a project and all methods to which they committed.
now we separate the developers for each method minto two sub populations those that added asserts tom and those that did not.
we compare the ownership of each sub population.
the results are in figure .
we note first that there is no size confound here ownership is normalized.
clearly assert adding developers are associated with higher ownership the clear visual impression is confirmed by a wilcoxon mann whitney test p value .
an effect size test cohen s d suggests that the effect is small .
this supports our hypothesis that users who have greater commitment on a method will be more inclined to take the step adding asserts to it.
users not as engaged with the method will have less motivation to successfully implement an assert and open source developers appear to follow this trend.
however one issue to note is that many methods have been changed only by a single developer and therefore these methods have complete ownership .
.
this will be more common when considering method ownership vs e.g.
file ownership due to the smaller granularity.
re this analysis after removing methods with ownership .
yields the same outcomes.
next we examine the effect of experience .
while ownership is a proportion or fraction between and experience is a cumulative measure which generally increases monotonically with time as a developer engages in more and more activity.
we measure the experience of a developer with respect to a method mas the number of commits she has made to m. added asserts didn t add asserts2468experience of developersmedian experience log scale fig.
considering comiitters to each method the experience of those who added asserts is greater than those who did other work.
outliers removed.
while this is prima facie a reasonable metric it is potentially fraught with a size confound.
clearly a larger method mwill have more commits and so potentially more people working on it will make commits thus gaining more experience with m larger methods naturally will also tend to have more asserts.
thus a naive examination might find a spurious connection between experience and asserts arising from the size confound.
to avoid this we compare the experience of developers on a method by method basis we compare the experience of developers who add assertions and those who don t for each method .
first we find the set of developers d m who committed to a given method m. we partition dintoda m the developers who added asserts and dn m the developers who did not add asserts.
if either partition is empty for a given method m it is excluded from the rest of this study.
now for each method where both partitions are non empty we calculate developer experience as the number of commits made by each developer.
for each method m we then calculate the median experience ofda m and of dn m .
we then get a pair of median experiences for method m one for the developers who added asserts and one for those who didn t. this pair can be compared without fear of a size confound because size is implicitly controlled.
the results are seen in figure .
the plots shows a notable difference.
a two sample mann whitney paired test confirms this effect with very low p values .
a cohen s d effect size test shows the effect to be medium .
rq3.
what aspects of network position of a method in a call graph are associated with assertion placement?
this part of our work was primarily an exploratory study.
our goal was to evaluate whether the network centrality of a method had any association with assertion placement.
a wide variety of ways exist to measure different properties of network positions we tried a variety of them.
in essence we were testing a set of hypothesis as to the associations of these network centrality measures with assertion placement.
for the ones that showed a significant association we corrected theproject methods with assert p value beanstalkd .
ccv .54e cjdns .10e firmware .
gcc gumbo parser .87e jq .79e julia .46e libuv .10e luvit .
php src .
python for android twemproxy .67e xbmc .59e a wmw nonparametric test to compare normalized hub score between methods with and without assertions.
the p values are associated with a one sided test that methods with asserts have higher hub score than those without.dependent variable use assert as binary logistic loc .
.
hub score .
.
as.numeric project .
.
constant .
.
observations log likelihood .
akaike inf.
crit.
.
b a logistic binomial regression model confirms with statistical significance that methods with assertion have more hub score while controlling for loc and project.
here project is treated as dummy variable.
table vi callgraph centrality vs. assertion usage p values to account for multiple hypothesis testing and bound the family wise error rate.
we gathered call graphs of several project after gathering it as described in section iv b .
note that this analysis is done on the most rescent version of the projects.
we had projects in total that were primarily written in c for which we were able to gather call graphs as explained earlier c call graphs are complicated by run time despatch which is not always statically derivable .
we further removed the projects that had only assert call in the entire project.
this removed projects leaving us with large projects that together include about of all the methods from the full set of projects.
to understand assertion usage w.r.t.
project architecture we performed the experiment in two ways.
first for each project call graph we measured in degree out degree betweenness centrality authority and hub scores metrics in all of each node i.e.
method.
the in degree and out degree of a method mare counts of calls into and calls from m. betweenness centrality of a node mis a proportionate measure of the number of geodesics passing on which mlies it relates to the mediating role played by a method the higher the betweenness the more different of call chains the method could potentially be involved in.
hub and authority are mutually re inforcing measures of information sourcing and aggregation .
hubs essentially represent methods which are important aggregators and dispensers of information to other methods authorities are methods to and from which hubs despatch and collect information.
hubs and authorities are recursively defined and mutually re inforcing the more authorities a hub calls the more hub by it is the more an authority is called from hubs the more authoritative it becomes.
several measures out degree betweenness centrality and hub score are strongly correlated with size.
larger methods call more methods and thus have higher out degree higher out degree leads to higher betweenness centrality and hubscore.
in degree on the other hand is unrelated to size.
we therefore normalize all the size correlated measures by dividing them by lines of code.
for each project we then partition the methods into two groups based on whether they use an assertstatement or not.
finally we compare the normalized network metrics of the two groups using the unpaired wilcoxon mannwhitney test.
in this exploration the only measure that we found consistently related to assertions in most projects was the hub score.
table via shows the result of the wilcoxonmann whitney test for the normalized hub score.
in most of the projects methods with asserts have high hub score with statistical significance.
for only two projects python for android andluvit were the results not significant.
while the former showed the opposite trend i.e.
methods with assertion have significantly low hub score luvit results remained insignificant in the opposite direction as well.
since we tested hypothesis per project very conservatively all low p values could be multiplied by the bonferoni correction all significant ones clearly remain so.
we performed similar tests for other network properties.
in only five projects methods with assertions have greater authority and in three projects they have lower authority the rest were not statistically significant.
nothing could thus be inferred about the association of assertion usage with authoritativeness in a call graph.
similar inconclusive results were found for in degree out degree and betweenness measures.
to confirm that developers use asserts primarily in the hub methods we further performed a logistic regression on the dataset see table vib .
each row in the logistic regression corresponds to a method per project.
the dependent variable is use assert a binary variable indicating whether a method is using at least one assertion.
the control variables are lines of code hub score and project project is treated as a categorical variable dummy encoded .
the highly significant positive coefficient for hub score affirms that methods with asserts are associated with high hub scores.
to further understand why developers choose to use asserts in hub methods we manually investigated the functionalities of several methods that use asserts and also have high hub scores.
one example to describe this relationship is the encrypthandshake method in file cryptoauth.c which appears in the project cjdns an ipv6 network encryption tool.
this method is used to encrypt packets beforesending them over the network thus belonging to the core functionality of the project.
this method is called by another three methods sendmessage decrypthandshake and cryptoauth encrypthandshake the first two are important methods in the project with high authority and hub scores respectively.
for example sendmessage has 5thhighest authority score in cjdns .
encrypthandshake in turn calls other distinct methods.
thus encrypthandshake turns out to be an important aggregator and dispenser of information in this context.
encrypthandshake in turn uses asserts five times to check the validity of encrypted keys.
for example assert true !bits memcmp wrapper herip6 calculatedip6 is used to make sure they didn t memcpy in an invalid key as commented by the developer.
dependent variable total added assertion intercept .
.
total added lines .
.
total developers .
.
project age .
.
codeanalyzer .
.
database .
.
framework .
.
library .
.
middleware .
.
observations log likelihood .
.
.
akaike inf.
crit.
.
p .
p .
p .
table vii number of assertion added to a project does not depend on the project s application domain.
domains are coded with dummy coding with application domain as reference.
thus all the other domains are compared w.r.t.
application domain.
rq4.
does the domain of application of a project relate to assertion use?
in our recent work on code defects in the github corpus we categorized projects based on their application domain into six general groups applications code analyzer database framework library and middleware.
to investigate whether the use of asserts depended in anyway on the application domain we used negative binomial regression due to the smaller sample size see methodology with the domain as a factor while controlling for the total number of lines developers and age of the project.
we filtered out of our projects in which there were only or developers or which had or more asserts added to control for outliers leaving us observations.
out of those and were in the respective domains above.
the application domains were encoded as categorical variables using dummy coding with the application domain as the reference category.
the results are shown in table vii.
we observe that at this level of coarse modeling only the total number of lines is a significant positive predictor for the number of asserts as expected.
while the coefficients in front of the domain variables range from negative to positive none of them are significant.
we concludethat there is no appreciable effect of the application domain on the asserts added when controlling for code length age and number of developers.
as with the other models variance inflation was well controlled.
vi.
t hreats to validity several threats should be acknowledged.
bug identification we used commit messages rather than bug databases to identify bugs.
while this entails some risks of false positives and or false negatives as also do commit links to bug databases we felt compelled to adopt this approach since we wanted to focus on bug fix commits both during interactive development as well as on reported bugs.
call graph we use cscope to generate call graphs which is not infallible when methods with identical names are present in different files cscope cannot distinguish them.
we ameliorate this by looking at a method from both callee and caller perspective.
however with large samples and reasonable network centrality measures such as hub we expect that call graph fidelity is not a major concern.
in addition we only examined call graphs for c the results may not apply for c .
assert identification our detection of asserts is based on a string matching heuristic.
besides the standard c assert macro some projects have custom defined macros which we worked to unearth and thus detect.
however our detection has some issues as outlined earlier in section iv.
we submit that the large sample results we have obtained are robust enough to ameliorate concerns arising from the fidelity of our assert and bug detection methods.
general comments it s entirely possible that developers in open source and commercial settings use asserts differently in general ownership can be enforced by fiat in commercial software not so in open source.
this might lead to differences in the use and effect of asserts.
our results may not generalize beyond open source.
our classification of domains is not objective and others may disagree with it.
conclusions while assertions promise great value for automated verification in practice developers use them often sparingly mostly to quickly detect report invalid system states.
even in this limited context our data suggests that the addition of asserts is associated with reduced defects the data also suggests that asserts help with maintaining the quality of code even as additional developers contribute code.
the data also suggests that developers add asserts to methods they have prior knowledge of and of which they have greater ownership.
our work essentially supports the common folklore concerning asserts they do have a salutary effect on software quality and appear to play a positive role in collaborative software development when many programmers are working on the same method.
in future studies we wish to see if asserts make finding and fixing real bugs and not just bugs introduced retrospectively by researchers easier.
additionally we wish to group asserts into different categories to better understand their use and ultimately to be able to identify and create useful asserts in relevant locations.