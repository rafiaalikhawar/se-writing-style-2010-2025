static dom event dependency analysis for testing web applications chungha sung markus kusano virginia tech blacksburg va usanishant sinha ibm research bangalore indiachao wang univ.
of southern california los angeles ca usa abstract the number and complexity of javascript based web applicat ions are rapidly increasing but methods and tools for automatic ally testing them are lagging behind primarily due to the difficulty i n analyzing the subtle interactions between the applications a nd the event driven execution environment.
although static anal ysis techniques have been routinely used on software written in tradi tional programming languages such as java and c adapting them t o handle javascript code and the html dom is difficult.
in this work we propose the first constraint based declarative pro gram analysis procedure for computing dependencies over progra m variables as well as event handler functions of the various dom e lements which is crucial for analyzing the behavior of a clien t side web application.
we implemented the method in a software too l named js dep and evaluated it in a rtemis a platform for automated web application testing.
our experiments on a large se t of web applications show the new method can significantly reduc e the number of redundant test sequences and significantly increa se test coverage with minimal overhead.
ccs concepts software and its engineering automated static analysis software testing and debugging keywords javascript static analysis automated testing event dep endency partial order reduction .
introduction static analysis of client side javascript web application s is difficult not only due to the language s dynamic features but also due to the subtle interactions between javascript code and the event driven execution environment.
at the center of this e xecution environment is the html document object model dom .
the dom stores the buttons images text boxes and other vi sible objects on the web page together with a large number of event handler functions attached to these dom objects.
prior work on statically analyzing javascript focused primarily on mode ling thesource code html javascript normalized code cfg datalog factsdatalog rules .
alias analysis .
control data dependency .
dom event dependency z datalog engine in z3 dom event dependenciesautomated testing t ool artemis figure overall flow of dom event dependency analysis.
language as opposed to the language s in teraction with the dom.
for example existing methods do not robustly handle dependencies between dom event handlers e.g .
the various functions responding to the user s actions timers ajax requests or their callbacks despite that such dependencies are crucial in reasoning about client side web applications.
we propose the first constraint based static analysis metho d for computing dependencies both across event handlers and bet ween html dom elements.
such dom event dependencies fundamentally differ from traditional control and data dependencie s over program variables because they are tied to the event driven exe cution environment.
specifically a modern javascript web applica tion stores various data inside the dom while simultaneously usi ng javascript code to read and manipulate this data in response to various often user triggered events such as onclick onload and timeout .
if executing the handler maof eventacauses the handlermbof eventbto be registered triggered or removed we say that event bdepends on event a denoted a domb.
this differs from the traditional notion of control dependencies ctrl and data dependencies data over program variables.
furthermore statically reasoning about dom event dependencies is chall enging it requires proper handling of the aliasing between dom elem ents and modeling the effects of apis provided by the web browser a nd popular frameworks such as jquery .
figure shows the flow of our dom event dependency analysis which follows the declarative program analysis framework .
given the html and javascript source file s of a clie ntthis is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication fse november seattle wa usa c acm.
... artifact evaluated by fse 447side web application we first extract the javascript code an d generate its control flow graph cfg .
we traverse the cfg to encode its control and data flows in a set of logical constraints called d atalog facts .
next we specify our static dependency analysis in a set of datalog inference rules .
finally we use an off the shelf datalog engine in z3 to solve the datalog program.
internal ly the datalog engine repeatedly applies the set of inference rule s to the set of facts until they reach a fix point.
the fix point result s in a new relation dom over dom events.
this relation allows the user to query for dependency information through z3 s api.
our method for statically computing dom event dependencies differs from the prior work.
first it differs from the decla rative methods for analyzing programs written in standard programming languages such as java we analyze javascr ipt web applications.
additionally the static analysis of gua rnieri and livshits while targeting javascript focused on t ype inference as opposed to inter event handler dependencies in the html dom.
our method also differs from the dynamic change impact analysis of alimadadi et al.
which analyzed concrete ex ecutions to identify the interplay between javascript code cha nges and the content of the dom since it is dynamic their analysis is valid only for the given executions ours based on static analysi s is valid for all executions.
madsen et al.
proposed several s tatic analysis methods for javascript but they targeted applica tions usingnode.js or windows apis .
the static analysis tool of jensen et al.
modeled some aspects of the html dom and browser apis but its focus was on type inference as opposed t o a dependency analysis.
we implemented our new method in a static analysis tool named jsdep building upon e sprima for parsing the javascript source code js w ala for generating the control flow graph and z3 for solving the datalog program.
we evaluated js dep on a large set of client side web applications.
overall we analyzed pr ograms totaling lines of javascript code.
our experiments s how that our static analysis method can quickly process the javascri pt code of these applications and compute the dom event dependencie s with reasonable accuracy.
to demonstrate our technique s usefulness we leveraged it s results to improve the performance of a popular automated web a pplication testing tool named a rtemis .
a rtemis traverses the application s execution space by systematically triggeri ng handlers of various dom events.
however since a rtemis cannot statically compute dom event dependencies it relies on heuristics for generating sequences of event handler executions.
we show empir ically that these heuristics are largely random and introduce many redundant tests.
but our dom event dependency analysis can provably prune redundant test sequences and thus direct a rtemis to explore truly useful tests.
in particular the default a rtemis stuck at statement coverage even after running for .
hours wherea s our new method enabled a rtemis to quickly reach coverage.
besides a rtemis our static dom event dependency analysis may benefit other dynamic analysis or symbolic execution too ls such as kudzu symjs and jalangi .
a problem th at is common to these tools is that they lack the capability of co nducting a whole program static analysis in this sense our new m ethod is complementary.
in a broader sense our dependency analys is method is useful in many other software engineering applica tions e.g.
to improve program understanding software maintena nce automated debugging and program repair.
in summary the main contributions of our work are we propose the first constraint based static dependency ana lysis for client side web applications taking into conside ration not only traditional control and data dependencies but also the new dom event dependencies.
we propose a new method for leveraging our static dependency analysis results in an automated web application test ing tool a rtemis to eliminate redundant tests and improve test coverage.
we implement these new methods and evaluate them on a large set of web applications to demonstrate the efficiency o f the static analysis method and its effectiveness in improvi ng automated testing.
the remainder of this paper is organized as follows.
we first motivate the main ideas of our new methods through examples i n section .
we establish notation in section and formalize our static dependency analysis in section .
we present the inte gration of our dependency analysis with a rtemis in section .
we evaluate our approach empirically in section .
finally we review related work and conclude in sections and .
.
motiv ation in this section we show what dom event dependencies are and how they can improve the automated testing of web applicatio ns.
.
dom event dependency consider the example in figure .
an html file defines the dom elements including four buttons and a javascript file de fines the functions manipulating these elements.
the four bu ttons namedtest1 test4 are referenced in the javascript using the variablesa b c andd respectively.
the onclick event handler of a i.e.
the function executed if the button test1 is clicked registers the onclick event handler of cto the function makesomenoise .
the onclick event handler of bincrements the value of x. sincexis used inmakesomenoise to control the branch conditions the handler ofbaffects in some sense the behavior of the event handler ofc.
finally the event handler of dprints a message to the console.
from the javascript code we identify the following depende ncies clicking test1 registers an event handler to test3 .
clicking test2 increments the value of x which in turn affects the same handler of test2 .
clicking test3 traverses the program paths of the handler function makesomenoise based on the value of x. we say that the onclick event of test3 depends on the onclick event of test1 since the handler of test3 is registered only when the handler of test1 is executed.
also the onclick event of test3 depends on the onclick event of test2 since the handler of test2 modifies the value of xread by the handler of test3 .
similarly the onclick event of test2 depends on itself due to the reads writes to x. in contrast the handler of test4 does not depend on any dom event.
these dom event dependencies are shown in figure .
there are two types of dependencies in figure one relying on traditional control and data dependencies and another r elying on the new dom event dependency relation.
specifically test2 depends on test2 because the read and write of variable xin the handler of test2 changes the program state which also affects the behavior of makesomenoise fortest3 .
in contrast test3 depends ontest1 because the handler of test1 installs the handler of test3 this type of dependency arises only from the specific event driven execution environment of the web browser it cannot be expre ssed using the traditional control and data dependency relation s. to the best of our knowledge the only work somewhat related to our new dependency analysis is the change impact analysis procedure developed by alimadadi et al.
.
it monitors the int erplay between javascript code changes and their impact on the dom.
however it relies on a trace based dynamic analysis and is therefore only valid for the given execution traces.
our method i n contrast is solely static and valid over all possible executio ns.
in addition the modeling of dependencies between event handlers i n ali4481 html head pclick example of three buttons p script type text javascript src ex.js script head body div id content ... div div id buttons button id test1 type button b1 button button id test2 type button b2 button button id test3 type button b3 button button id test4 type button b4 button div body html 1vara document.getelementbyid test1 2varb document.getelementbyid test2 3varc document.getelementbyid test3 4vard document.getelementbyid test4 5varx 6function makesomenoise 7if x console.log x is lower than 8else if x console.log x is lower than 9else if x console.log x is lower than 10else if x console.log x is lower than 11else console.log x is higher than some error codes 14a.addeventlistener click function 15c.onclick makesomenoise 16b.addeventlistener click function 17x x 18d.
addeventlistener click function 19console.log test4 is clicked!
figure example html page and associated javascript file.
madadi et al.
is not as accurate as our method.
in particul ar they assume that function gdepends on function f definition in iffinvokesgand either the signature of gindicates that it takes parameters or the definition of fincludes a return value.
this is a much coarser definition than ours we model the actual imp act of the statements in a function during our dependency analys is.
.
web application testing next we show how dom event dependencies can help improve automated web application testing tools like a rtemis .
such tools generate test sequences by systematically triggering user events up to a fixed depth.
the search tree of our running example figur e up to depth three can be seen in figure a .
each edge represents the execution of an event handler and each path repres ents a test sequence.
the default algorithm in a rtemis inefficiently explores the search space since many of its randomly generated test sequences are actually redundant.
for example the onclick event click of test 1registration test click of test 2click of test click of test 2click of test figure dom event dependencies for the example in figure .artemis search tree test 1test4test2 test test test 3test test test 2test test test 2test a the default algorithm with no pruning.
artemis search tree test 1test4test2 test test test 3test test test 2test test test 2test b with dom event dependency based pruning.
figure event sequences explored by a rtemis for figure .
oftest4 does not have a dom event dependency with any dom event.
any permutation of events involving test4 is redundant e.g.
test1 test4 test3 leads to the same behavior as test1 test3 test4 and therefore only one needs to be tested.
using newly computed dom event dependencies in a rtemis allows redundant test sequences to be pruned away.
we will ex plain the detailed redundancy pruning algorithm in section bu t for now it suffices to say that permutations involving two indep endent event handlers can safely be ignored without affecting the e xploration capability of the tool.
after such reduction the new search tree shown in figure b is significantly smaller.
here g rayedout edges are those deemed redundant and therefore are skipp ed.
for example the onclick event oftest1 is not dependent with itself as seen in the dependency relation in figure .
so executing the onclick event of test1 after another onclick event of test1 does not alter the program s state and therefore can be skipped.
s imilarly test1 test4 test3 is skipped because an equivalent sequence test1 test3 test4 has already been tested.
also note that exploring all test sequences up to the depth d oes not guarantee to cover all statements in this program.
indee d only the first branch of the function makesomenoise in figure line can be executed sequences of only length three are not lon g enough to increment xabove while also registering and executing the handler associated with test3 .
fully covering all the statements in this case requires at least a sequence of length that i s test1 test3 test2 test2 test3 test2 test2 test3 test2 test2 test3 test2 test2 test3 test4 .
since we need to test up to depth for full statement coverag e the default search algorithm in a rtemis may explore more than 359sequences.
in contrast with our new pruning technique complete statement coverage can be achi eved by exploring at most60sequences.
we ran a rtemis with our new improvement on this example and reached coverage in onl y .
seconds.
the original version of a rtemis could not reach coverage after minutes.
in the remainder of this paper we present the detailed algor ithm of our new dom event dependency analysis.
.
preliminaries in this section we introduce the fundamental concepts and n otations for our work.
.
web applications client side web applications are executed by the web browse r which loads and parses the html javascript files represent s them as a dom tree and then executes the javascript code.
each nod e in the dom tree represents an object on the web page or a javascr ipt code block to be executed immediately after parsing.
each ob ject may also be associated with a set of events initiated either b y the user or by the browser such as onload andonclick .
these events are responded to by a set of javascript functions called even t handlers.
for example when a user clicks a button the callback function associated with the onclick event will be executed.
callback functions may be registered statically inside the html file o r dynamically inside the javascript code.
although the browser ensures that each callback function is executed atomically i.e.
i n a singlethreaded fashion the execution of multiple callback funct ions may interleave this makes the execution of the entire web appli cation nondeterministic.
.
javascript statements letstbe the set of javascript statements.
following the notation of guarnieri and livshits we define the syntax of ea ch statement st stas follows.
st st1 st2 v newv0 v1 ... v n v1 v2 v1 v2.f v1.f v2 m function v1 ... v n st v m v1 ... v n returnv each statement stis either empty an elementary statement or a sequence of statements of the form st1 st2.
an elementary statement can be an object construction where v0is a constructor and v1 ... v nare its arguments an assignment a load of the object fieldv2.f a store to the object field v1.f a definition of a function a call to a function or a return from a function.
other comple x statements may be transformed into a sequence of equivalent statements through preprocessing prior to applying our analysis .
.
points to analysis points to analysis is the process of determining whether a r eference variable v vcan point to o o a javascript object or html dom element.
as in the literature we use vto denote the set of all reference variables defined in the program oto denote the set of objects created at the set lof allocation sites and fto denote the set of object fields.
for each site li l we map all objects created at lito a single abstract object oi o. the points to relation denoted tptsto consists of a set of pairs of the form v oi meaning the reference variable v vpoints to the objectoi o and of the form oi.f oj meaning the field f f of the object oi opoints to the object oj o. we define an abstract transformer for each st stas a function fptsto tptsto st tptsto which takes a points to relation t tptsto as input and returns a new points to relation t tptsto as output.
for brevity we provide definitions only for the following statements allocation l new c assignment l r store l.f r load l r.ffor each of the above statements the new points to relation t is defined with respect to the old points to relation tas follows allocation t t l oi assignment t t l oi r oi t store t t oi.f oj l oi tand r oj t load t t l oi r oj tand oj.f oi t for an allocation we add l oi to the points to relation.
for an assignment if the pair r oi is already in the points to relation we add l oi as well.
for a store and a load the abstract transformers are defined similarly.
.
call graph construction although many of the function calls in javascript code can be resolved to a unique target function at the time of the static analysis there are cases where the resolution has to be carried out at r un time.
in such cases our analysis over approximates the set of fun ctions that may be called.
we leverage the result of our points to an alysis to determine which function may be invoked.
specifically co nsider the statement l v .m v1 ... v n wherev0 ris a reference variable m fis the field name and v1 ... v n vare the actual parameters of the function call.
letmi p0 p1 ... p n retj be a function that v0.mmay point to where p0refers back to the object retjrefers to the return value andp1 ... p nare the formal parameters.
for each object that v0 may point to denoted v0 o0 t and for each function that o0.mmay point to denoted o0.m m i t we transform the function call to the following statements p1 v1 ... pn vn executing the code in mi and l retj.
the abstract transformer for the function call is defined as f ollows t t p0 o0 p1 o1 ... pn on l oj such that v1 o1 t ... vn on t and retj oj t. .
dependency relations for each statement st st letvrd st be the set of memory locations read by st andvwr st be the set of memory locations written to by st. we define the traditional control and data dependency relations as follows a data dependency data exists betweenst1 st2 stifst1is a write to some variable xandst2is a read ofx.
that is st1 st2 dataifvwr st1 vrd st2 ne ationslash .
a control dependency ctrl exists between st1 st2 stifst1 is a branch statement st2is another statement and the evaluation of the predicate pinst1determines the execution of st2.
since each javascript code block is executed atomically we are concerned with the dependency relations between code block s as opposed to individual statements.
let m1andm2be two javascript functions.
we say m1 m2 ctrlif executing m1may affect the control flow of m2 that is there exists st1 m1andst2 m2 such that st1 st2 ctrl.
similarly we say m1 m2 data if st1 st2 data.
the dom event dependency relation in contrast is defined di rectly over events.
intuitively if the execution of some ca llback functionm1of the event ev1affects the execution of some callback function m2of the event ev2 there is a dom event dependency between ev1andev2.
more so m1may affect m2through control data dependencies or m1may affect m2by registering removing or modifying the callback functions of event ev2 which includesm2.
this effect is unique to the event driven environment of client side web applications.
formally definition .two events ev1 ev2 ev are in the dom event dependency relation ev1 ev2 dom if there exists a callback function m1ofev1and a callback function m2ofev2 such that 4501doma.onclick function 2c true 4domb.onclick function 5if c 6statement1 else 8statement2 figure example data control dependencies in the dom.
either m1 m2 data ctrl or executing m1registers removes or modifies the handler m2.
here t denotes the transitive closure of a relation t. consider the code in figure as an example.
there are two functions registered as the onclick event handlers of doma anddomb cis a global variable used in the two event handlers.
inside th e handler of doma there is an assignment to c. the value of cis used as the predicate of a branch in the event handler of domb.
so clicking doma affects the reachability of the statements guarded by the branch if c .
thus domb is dom event dependent on doma.
.
constraint based dependency analysis in this section we present our static analysis algorithm fo r computing dom event dependencies.
.
datalog based program analysis we follow the declarative program analysis framework pione ered by whaley livshits and lam where the analysis is represented by a datalog program consisting of a set of facts and a set ofrules .
the facts are relations that hold in the program and the rules specify the algorithm for deriving new relations from existing relations.
for example the first two lines below show the two facts describing a graph where n1is the parent of n2 andn2is the parent ofn3.
the next two lines define the rules to infer the ancestor relation if xis the parent of y xis the ancestor of y. or ifxis the parent of zandzis the ancestor of y xis the ancestor of y. parent n n2 parent n n3 ancestor x y parent x y ancestor x y parent x z ancestor z y a datalog engine takes the program above as input and compute s theancestor relation.
internally it repeatedly applies the rules over the facts until reaching a fix point.
then one may query the d atalog engine to check for example if ancestor n n3 holds.
.
generating the datalog facts we first normalize the javascript code to break down complex statements into series of simpler statements by adding auxi liary variables.
figure shows an example of this.
then we traver se the control flow graph cfg of the simplified code and for eac h statement generate its datalog facts.
later on these data log facts are merged with a predefined set of datalog rules that specify our dependency analysis algorithm.
finally we use a datalog en gine to solve the program to obtain the analysis results.
the datalog facts generated from the input program populate the relations shown in figure .
the domains used in these relati ons are as follows v the set of variables st the set of statement ids o the set of objects f the set of object fields and e load mouse keyboard timeout ajax other the set of event handler types.
next we provide examples on this process.chained statement normalized form vara document.images.length vartemp0 document.images vartemp1 temp0.length vara temp1 figure example for javascript code normalization.
assign v1 v v2 v st st variable assignment v1 v2with idst load v1 v v2 v f f st st object field load v1 v2.fwith idst store v1 v f f v2 v st st object field store v1.f v2with idst funcdecl v v o o vassigned function o v function ... formal o o n n v v vis thenthformal argument of function o actual st st n n v v vis thenthargument in call site at st method ret o o v v vis the return value of function o callret st st v v return into variable vat call site st stmt st st o o stis a statement in function o heap v v o o allocation of heap object ointo variable v ptsto v v o o variable vpoints to object o dom o o ois a dom object dom m odify o o e e f o st st attach function fto objecto s evente figure the relations defined to specify our analysis.
largely the relations in figure correspond to various sta tements in the program e.g.
assignments loads and stores.
each statement then for the most part generates a correspondin g input fact.
specifically every statement in the program is identi fied with a unique id st st. the formal arguments of a function are those used within the function itself e.g.
for function f a b ... a andbare the formal arguments.
given this function declaration ifa b vrepresent variables aandbandf orepresents the function f then f ormal f a and f ormal f b .
at a call site v f a1 b2 a1anda2are the actual arguments e.g.
actual s a1 wheresis the statement id of the call site and a1 vrepresents the variable a1.
the0thactual argument is the function object performing the call e.g.
a ctual s f .
continuing the example assume the statement return r is the return statement of the function f .
letr vrepresent rthen method ret f r .
each call site similarly has its own return value from a function.
using the previous call site and let v v represent the variable v then we have c allret s v .
next we present examples for generating facts about dom ele ments and operations.
dom