generating automated and online test oracles for simulink models with continuous and uncertain behaviors claudio menghi snt university of luxembourg claudio.menghi uni.lushiva nejati snt university of luxembourg shiva.nejati uni.lu khouloud gaaloul snt university of luxembourg khouloud.gaaloul uni.lulionel briand snt university of luxembourg lionel.briand uni.lu abstract test automation requires automated oracles to assess test outputs.
for cyber physical systems cps oracles in addition to be automated should ensure some key objectives i they should check test outputs in an online manner to stop expensive test executions as soon as a failure is detected ii they should handle time and magnitude continuous cps behaviors iii they should provide a quantitative degree of satisfaction or failure measure instead of binary pass fail outputs and iv they should be able to handle uncertainties due to cps interactions with the environment.
we propose an automated approach to translate cps requirements specified in a logic based language into test oracles specified in simulink a widely used development and simulation language for cps.
our approach achieves the objectives noted above through the identification of a fragment of signal first order logic sfol to specify requirements the definition of a quantitative semantics for this fragment and a sound translation of the fragment into simulink.
the results from applying our approach on industrial case studies show that i our requirements language can express all the requirements of our case studies ii the time and effort required by our approach are acceptable showing potentials for the adoption of our work in practice and iii for large models our approach can dramatically reduce the test execution time compared to when test outputs are checked in an offline manner.
introduction the development of cyber physical systems cpss starts by specifying cps control and dynamic behaviors as executable models described in languages such as matlab simulink .
these models are complex and subject to extensive testing before they can be used as a basis for software code development.
existing research on automated testing of cps models has largely focused on automated generation of test suites .
however in addition to test input generation test automation requires automated oracles i.e.
a mechanism to automatically determine whether a test has passed or failed.
to automate oracles engineers often rely on runtime crashes a.k.a.
implicit oracles to detect failures.
however implicit oracles often cannot effectively reveal violations of functional requirements as most of such violations do not lead to crashes.
as mandated by safety certification standards for cps functional requirements must be specified and be used as the main authoritative reference to derive test cases and to demonstrate system behavior correctness.
to achieve this goal we need to develop a r4 holds time b r4 fails low severity s c r4 fails high severity time stime sk qreal t qtarget t k 20figure three simulation outputs of our satex case study model indicating the error signal qreal t qtarget t .
the signal in a passes r4 in table but those in b and c violate r4 with low and high severity respectively.
oracles that can automatically check the correctness of system behaviors with respect to requirements.
in this paper we propose an approach to generating oracles that automatically determine whether outputs of cps models satisfy or violate their requirements.
for cps oracles in addition to be automated need to contend with a number of considerations that we discuss and illustrate below.
motivating example.
we motivate our work using satex a real world case study from the satellite domain .satex is a model of a satellite control system modeled in the matlab simulink language and developed by our partner luxspace.
briefly the main functions of the satex model are i to always keep the satellite on the desired orbit ii to ensure that the satellite is always facing the earth i.e.
the satellite s attitude is always pointing to the earth and iii to regulate the satellite speed.
the main functional requirements of satex are presented in the middle column of table and the variables used in the requirements are described in table .
before software coding or generating code from simulink models a common practice when simulink matlab models are used engineers need to ensure that their models satisfy the requirements of interest e.g.
those in table .
although there are a few automated verification tools for simulink in practice verification of cps simulink models largely relies on simulation and testing.
this is because existing tools for verifying simulink models are not amenable to verification of large simulink models like satexthat contain continuous physical computations and third party library code .
further cps simulink models often capture dynamic and hybrid systems .
it is well known that model checking such systems is in general undecidable .
to effectively test cps models engineers need to have automated test oracles that can check the correctness of simulation outputs with respect to the requirements.
to be effective in the context of cps testing oracles should further ensure the following objectives 1arxiv .03399v1 mar 2019table requirements for the satellite control system satex developed by luxspace.
id requirement restricted signal first order logic formula r1 the angular velocity of the satellite shall always be lower than .5m s. t wsat t .
r2 the estimated attitude of the satellite shall be always equal to .
t qestimate t r3 the maximum reaction torque must be equal to .015nm.
t trq t .
r4 the satellite attitude shall reach close to its target value within sec with a deviation not more than 2degrees and remain close to its target value.
t qreal t qtar et t r5 the satellite target attitude shall not change abruptly for every t the difference between the current target attitude and the one at two seconds later shall not be more than .
t qtar et t qtar et t sin r6 the satellite shall reach close to its desired attitude with a deviation not more than exactly sec after it enters its normal mode i.e.
sm t and after it has stayed in that mode for at least sec.
t sm t1 qreal t qestimate t .
the notation aindicates that ais a vector a indicates the norm of the vector.
table signals variables of the satex model.
var.
description var.
description sm satellite mode status.
trq satellite torque.
wsat satellite angular velocity.
qreal current satellite attitude.
qestimate estimated satellite attitude.
qtarget target satellite attitude.
o1.test oracles should check outputs in an online mode.
an online oracle a.k.a as a monitor in the literature checks output signals as they are generated by the model under test.
provided with an online oracle engineers can stop model simulations as soon as failures are identified.
note that cps simulink models are often computationally expensive because they have to capture physical systems and processes using high fidelity mathematical models with continuous behaviors.
further cps models have to be executed for a large number of test cases.
also due to the reactive and dynamic nature of cps models individual test executions i.e.
simulations have to run for long durations to exercise interactions between the system and the environment over time.
for example to simulate the satellite behavior for 24h i.e.
s the satex model has to be executed for 84minutes .
hours on core intel core i7 .20ghz 32gb of ram.
further the 24h length simulation of satex has to be re run for tens or hundreds of test cases.
therefore online test oracles are instrumental to reduce the total test execution time and to increase the number of executed test cases within a given test budget time.
o2.test oracles should be able to evaluate time and magnitudecontinuous signals.
cps model inputs and outputs are signals i.e.
functions over time.
signals are classified based on their timedomain into time discrete and time continuous and based on their value range into magnitude discrete and magnitude continuous.
the type of input and output signals depends on the modeling formalisms.
for example differential equations often used in physical modeling yield continuous signals while finite state automata used to specify discrete event systems generate discrete signals.
figure shows three magnitude and time continuous signal outputs of satex indicating the error in the satellite attitude i.e.
the difference between the real and the target satellite attitudes qreal t qtar et t .
an effective cps testing framework should be able to handle the input and output signals of differentcps formalisms including the most generic and expressive signal type i.e.
time continuous and magnitude continuous.
such testing frameworks are then able to handle any discrete signal as well.
o3.test oracles for cps should provide a quantitative measure of the degree of satisfaction or violation of a requirement.
test oracles typically classify test results as failing and passing.
the boolean partition into pass and fail however falls short of the practical needs.
in the cps domain test oracles should assess test results in a more nuanced way to identify among all the passing test cases those that are more acceptable and among all the failing test cases those that reveal more severe failures.
therefore an effective test oracle for cps should assess test results using a quantitative fitness measure .
for example the satellite attitude error signal in figure a satisfies the requirement r4in table .
but signals in figures b and c violate r4since the error signal does not remain below the 2threshold after 2000s.
however the failure in figure c is more severe than the one in figure b since the former deviates from the threshold with a larger margin.
a quantitative oracle can differentiate between these failure cases and assess their degree of severity.
o4.test oracles should be able to handle uncertainties in cps function models.
there are various sources of uncertainty in cps .
in this paper we consider two main recurring and common sources of uncertainties in cps uncertainty due to unknown hardware choices which results in model parameters whose values are only known approximately at early design stages.
for example insatex there are uncertainties in the type of the magnetometer and in the accuracy of the sun sensors mounted on the satellite see table .
uncertainty due to the noise in the inputs received from the environment particularly in the sensor readings.
this is typically captured by white noise signals applied to the model inputs e.g.
table shows the signal to noise s2n ratios for the magnetometer and sun sensor inputs of satex .
oracles for cps models should be able to assess outputs of models that contain parameters with uncertain values and signal inputs with noises.
contributions.
we propose simulink oracles for cps requirements with uncertainty socrates an approach for generating online oracles in the form of simulink blocks based on cps functional requirements section .
our oracle generation approach achieves the four objectives discussed above through the following novel elements 2table uncertainty in satex the values of the magnetometer type and the sun sensor accuracy parameters are given as ranges middle column .
the noise values for the magnetometer and sun sensor inputs are given in the right column.
component parameter values noises s2n magnetometer nt e 12t hz sun sensor .
.
e 6a we propose restricted signals first order logic rfol a signal based logic language to specify cps requirements section .
rfol is a restriction of signal first order logic sfol that can capture properties of time and magnitude continuous signals while enabling the generation of efficient online test oracles.
we define a quantitative semantics for rfol to compute a measure of fitness for test results as oracle outputs.
we develop a procedure to translate rfol requirements into automated oracles modeled in the simulink language section .
we prove the soundness of our translation with respect to the quantitative semantics of rfol.
further we demonstrate that the generated oracles are able to identify failures as soon as they are revealed i.e.
our oracles are online and our oracles can handle models containing parameters with uncertain values and signal inputs with noises.
finally we have implemented our automated oracle generation procedure in a tool which is available online .
we apply our approach to industry simulink models from two companies in the cps domain.
our results show that our proposed logic based requirements language rfol is sufficiently expressive to specify all the cps requirements in our industrial case studies.
further our automated translation can generate online test oracles in simulink efficiently and the effort of developing rfol requirements is acceptable showing potentials for the practical adoption of our approach.
finally for large and computationally intensive industry models our online oracles can bring about dramatic time savings by stopping test executions long before their completion when they find a failure without imposing a large time overhead when they run together with the model.
structure.
section outlines socrates and its underlying assumptions.
section presents the restricted signals first order logic and its semantics.
section describes our automated oracle generation procedure.
section evaluates socrates.
section presents the related work and section concludes the paper.
socrates figure shows an overview of socrates simulink oracles for cps requirements with uncertainty our approach to generate automated test oracles for cps models.
socrates takes three inputs a cps model with parameters or inputs involving uncertainties a set of functional requirements for the cps model and a set of test inputs that are developed by engineers to test the cps model with respects to its requirements.
socrates makes the following assumptions about its inputs a1.the cps model is described in simulink .
simulink is used by more than of engineers for simulation of cps and is the prevalent modeling language in the automotive domain .
engineerpartial simulink model online test oracle simulink test inputsgeneratetest oracles matlab function functional requirements oracle resultsuncertainty parameters input noisessocrates12345fitness valuesstop when fitness goes below a given thresholdfigure overview of socrates our automated oracle generation approach.
simulink appeals to engineers since it is particularly suitable for specifying dynamic systems and further it is executable and allows engineers to test their models as early as possible.
a2.functional requirements are described in a signal logic based language .
we present our requirements language in section and compare it with existing signal logic languages .
we evaluate expressiveness of our language in section .
a3.a set of test inputs exercising requirements are provided .
we assume engineers have a set of test inputs for their cps model.
the test inputs may be generated manually randomly or based on any test generation framework proposed in the literature .
our approach is agnostic to the selected test generation method.
socrates automatically converts functional requirements into oracles specified in simulink .
the oracles evaluate test outputs of the cps model in an automated and online manner and generate fitness values that provide engineers with a degree of satisfaction or failure for each test input .
engineers can stop running a test in the middle when socrates concludes that the test fitness is going to remain below a given threshold for the rest of its execution.
context formalization in section .
we describe cps simulink models without and with uncertainty and their inputs .
in section .
we present restricted signals first order logic rfol the logic we propose to specify cps functional requirements .
in section .
we describe how oracles compute fitness values of test inputs .
.
simulink models simulink is a data flow based visual language that can be executed using matlab and consists of blocks ports and connections.
blocks typically represent operations and constants and are tagged with ports that specify how data flow in and out of the blocks.
connections establish data flows between ports.
to simulate a simulink model m the simulation engine receives signal inputs defined over a time domain and computes signal outputs at successive time steps over the same time domain used for the inputs.
a time domain t is a non singular bounded interval of r. asignal is a function f t r. asimulation denoted by h i m o receives a set i i1 i2.
.
.im of input signals and produces a set o o1 o2.
.
.on of output signals such that each oi ocorresponds to one model output.
for example .
.
.
time .
.
.
.
.
.
.8speed figure signals wsat for the wsatoutput of satex .
the solid line signal is generated by satex with no uncertainty and the dashed line signal is generated when the s2n ratios in table are applied to the satex inputs.
figure shows a signal black solid line for the wsatoutput of satex computed over the time domain .
simulink uses numerical algorithms referred to as solvers to compute simulations.
there are two main types of solvers fixedstep and variable step.
fixed step solvers generate signals over discretized time domains with equal size time steps whereas variablestep solvers e.g.
euler runge kutta generate signals over continuous time domains.
while the underlying techniques and details of numerical solvers are outside the scope of this paper we note that our oracles rely on simulink solvers to properly handle signals based on their time domains whether discrete or continuous.
as a result our work in contrast to existing techniques is able to seamlessly handle the verification of logical properties over not just discrete but also continuous cps models.
simulink has built in support to specify and simulate some forms of uncertainty.
we refer to simulink models that contain uncertain elements as partial models denoted mp while we use the term definitive to indicate models with no uncertainty.
simulink can specifically capture the following two kinds of uncertainty that are common for cps and also discussed in section objective o4 i uncertainty due to the noise in inputs.
in simulink uncertainty due to the noise is implemented by augmenting model inputs with continuous time random signals known as white noise wn .
the degree of wn for each input is controlled by a signal to noise ratio s2n value which is the ratio of a desired signal over the background wn .
table shows the s2n ratios for two inputs ofsatex .
fig.
shows the signal wsat t gray dashed line after adding some noise to the original wsatoutput signal in black solid line .
ii uncertainty related to parameters with unknown values.
in simulink parameters whose values are uncertain are typically defined using variables of type uncertain real ureal which is a builtin type in matlab simulink that specifies a range of values for a variable .
table shows two parameters of satex whose exact values are unknown and hence value ranges are assigned to them.
letmpbe a partial simulink model with noutputs and let kbe the number of different value assignments to uncertain parameters ofmp.
asimulation of a partial simulink model mp denoted by hp i mp o1 o2.
.
.ok receives a set i i1 i2.
.
.im of input signals defined over the same time domain and produces a set of simulation outputs o1 o2.
.
.ok such that each oiis generated by one value assignment to uncertain parameters of mp.
specifically for each oi o1 o2.
.
.ok we have oi o1 o2.
.
.on such .
.
.
time .
.
.
.8speed figure a set of signals wsat for the output wsatofsatexwith uncertain parameters i.e.
when the sun sensor and magnetometer parameters are specified as in table .
thato1 .
.
.onare signals for outputs of mp i.e.
each oicontains a signal for each output of mp.
the function hpgenerates the simulation outputs consecutively and is provided in the robust control toolbox of simulink which is the uncertainty modeling and simulation tool of simulink models with dynamic behavior.
the value of kindicating the number of value assignments to uncertain parameters can either be specified by the user or selected based on the recommended settings of hp.
for example figure plots five simulation outputs for the output wsatofsatex .
the uncertainty in this figure is due to the sun sensor accuracy parameter that takes values form the range .
as indicated in table .
.
our requirements language our choice of a language for cps requirements is mainly driven by the objectives o1ando2described in section .
these two objectives however are in conflict.
according to o2 the language should capture complex properties involving magnitude and timecontinuous signals.
such language is expected to have a high runtime computational complexity .
this however makes the language unsuitable for the description of online oracles that should typically have low runtime computational complexity thus contradicting o1.
for example signals first order sfo logic is an extension of first order logic with continuous signal variables.
sfo however is not amenable to online checking in its entirety due to its high expressive power that leads to high computational complexity of monitoring sfo properties .
thus the procedure for monitoring sfo properties is tailored to offline checking.
in order to achieve both o1ando2 we define restricted signals firstorder logic rfol a fragment of sfo.
rfol can be effectively mapped to simulink to generate online oracles that run together with the model under test by the same solvers applied to the model which can handle any signal type i.e.
discrete or continuous hence addressing both o1ando2.
note that even though rfol is less expressive than sfo as we will discuss in section all cps requirements in our case studies can be captured by rfol.
rfol syntax.
lett t1 t2 .
.
.td be a set of time variables .
letf f1 f2 .
.
.
fl be a set of signals defined over the same time domain t i.e.
fi t rfor every i l. let us consider the grammar gdefined as follows f t n t n t n f f g h 1 2 f r 1 2 1 2 t 1 2 t 1 2 4where n r t t f f r r and gandhare respectively arbitrary unary and binary arithmetic operators is a relational operator in and 1 2 is atime interval oft i.e.
1 2 t with lower bound 1and upper bound 2. the symbols and are equal to or depending on whether 1 respectively 2 are included or excluded from the interval.
we refer to and astime term signal term andformula term respectively.
a predicate is a formula term in the form r. definition .
.
arestricted signals first order logic rfol formula is a formula term defined according to the grammar gthat also satisfies the following conditions is closed i.e.
it does not have any free variable and every sub formula of has at most one free time variable.
in rfol boolean operations combine predicates of the form r which compare signal terms with real values1.
the formulas further quantify over time variables of signal terms in rand bound them in time intervals 1 2 .
table shows the formalization of the satex requirements in rfol.
for example the predicate wsat .5of formula r1states that the angular velocity of the satellite should be less than .5m s and t forces the predicate to hold for a duration of 400s 24h the estimated time required for the satellite to finish an orbit.
rfol expressiveness.
here we discuss what types of sfo properties are eliminated from rfol due to the conditions in definition .
.
condition in definition .
requires closed formulas.
rfol properties must not include free variables i.e.
they should be formulas and not queries so that they generate definitive results when checking test outputs.
condition in definition .
is needed to ensure that the formulas can be translated into online oracles specified in simulink.
this condition eliminates formulas containing predicates rwhere includes an arithmetic operator applied to signal segments over different time intervals i.e.
signal segments with different time scopes .
for example the formula t t f t f t 4is not in rfol since f t f t 4has two free time variables tandt i.e.
it violates condition in definition .
.
the predicate f t f t 4in this formula computes the sum of two segments of signal frelated to time intervals and .
such formulas are excluded from rfol since during online checking the operands f t and f t cannot be simultaneously accessed to compute f t f t .
we note that formulas with arithmetic operators applied to signal segments over the same time interval e.g.
r4 and r5 in table or formulas involving different predicates over different time intervals but connected with logical operators e.g.
r6 are included in rfol.
comparison with stl.
in addition to sfo signal temporal logic stl is another logic proposed in the literature that can capture cps continuous behaviors.
we compare rfol with stl and in particular with bounded stl since test oracles can only check signals generated up to a given bound.
hence for our purpose bounded stl temporal operators have to be applied e.g.
u .
rfol subsumes bounded stl since boolean operators of stl can be trivially expressed in rfol and any temporal stl formula in the form of 1u 2can also be specified in rfol using time terms and time intervals.
the detailed translation is available online .
1note that in our logic negation is applied at the level of predicates.rfol semantics.
we propose a quantitative semantics for rfol to help engineers distinguish between different degrees of satisfaction and failure see objective o3in section .
as shown in table and also based on rfol syntax cps requirements essentially check predicates rover time.
in other words predicates rare the building blocks of rfol.
to define a quantitative semantics for rfol we need to first define the semantics of these predicts in a quantitative way.
in our work we define a domain specific diff function to assign a fitness value to r. we require diffto have these characteristics the range of diffis .
a value in indicates that rholds and a value in indicates that ris violated.
definition .
.
letdiffbe a domain specific semantics function for predicates r. let f f1 .
.
.
fl be a set of signals with the same time domain t. the semantics of an rfol formula for the signal set fis denoted by fand is defined as follows f n f f n iff fandn t undefined otherwise g f g f h 1 2 f h 1 f 2 f r f diff f r 1 2 f min 1 f 2 f 1 2 f max 1 f 2 f t n1 n2 f min t n1 n2 f t n1 n2 f max t n1 n2 f the choice of the max andminoperators for defining the semantics of and is standard the minimum has the same behavior as and evaluates whether a predicate holds over the entire time interval.
dually the max operator captures .
the semantics of signal terms f n depends on whether the signal is included in f and whether nis in the time domain t otherwise f n is undefined.
we say rfol iswell defined with respect to a signal set fiff no signal term in is undefined.
to avoid undefined rfol formulas signal time domains tshould be selected such that signal indices are included in t and further the formula should not have negative signal indices.
for example for properties in table we need a time domain t forr1tor4 a time domain t forr5 and a time domain t forr6.
finally we can infer the boolean semantics of rfol from its quantitative semantics for every formula term we have f iff f .
in other words holds over the signal set fiff f .
let f r. in our work we define diffas follows diff f r 1diff f r 1if else diff f r 1diff f r 1if else diff f r 1diff f r 1if else in the above is an infinitesimal positive value that ensures diff 0when 0and either or is used.
5our difffunction satisfies the two conditions described earlier and is closed under logical and .
for example r r is equal to r .
our difffunction further provides a quantitative fitness measure distinguishing between different levels of satisfaction and refutation.
specifically a higher value of diffindicates that ris fitter i.e.
it better satisfies or less severely violates the requirement under analysis .
for example the diffvalue of the predicate wsat .5for the signals shown in figure is above zero implying that the signals satisfy the predicate.
in contrast thediffvalues for signals qreal qtar et in figures b and c are .5and .
respectively.
this shows that the violation in figure c is more severe than that in figure b .
note that the above difffunction is only one alternative where we assume the fitness is proportional to the difference between andr.
we can define the difffunction differently as long as the two properties described earlier are respected and the proposed semantics for diff respects logical conjunction and disjunction operators.
for example a simple diffcan return 1when rholds and otherwise yielding the boolean semantics of rfol.
.
test oracles in this section we formally define our notion of test oracle.
we specifically discuss test oracles for partial simulink models since a definitive model is a specialization of a partial model.
recall that by simulating a partial simulink model mpfor a given test input i we obtain a set of kalternative signals for each output of mp while for a definitive model m the simulation output contains only one signal for each model output.
definition .
.
letmpbe a simulink model under test and let ibe a test input for mpdefined over the time domain t. let be an rfol formula formalizing a requirement of mp.
suppose o1 o2.
.
.ok hp i mp are the simulation results generated for the time domain t. we denote the oracle value of for test input iover model mpby oracle mp i and compute it as follows oracle mp i min o o1 o2.
.
.ok o specifically oracle mp i indicates the fitness value of the test input iover model mpand evaluated against requirement .
recall that based on definition .
the oracle output is a value in .
for definitive models the test yields a single set o o1 .
.
.
on of simulation outputs and hence the oracle computes o i.e.
it evaluates over the set oof test outputs.
as defined above for a partial model the oracle computes the minimum value of over every test output set.
hence for a partial model the fitness value for a test iis determined by the model output yielding the lowest fitness i.e.
the model output revealing the most severe failure or the model output yielding the lowest passable fitness .
oracle generation in this section we present the oracle generation component of socrates 4in figure .
this component automatically translates rfol formulas into online test oracles specified in simulink that can handle time and magnitude continuous signals and conform to our notion of oracle described in definition .
.
note that an rfol formula may not be directly translatable into an online test oracle ifit contains sub formulas referring to future time instants or to signal values that are not yet generated at the current simulation time.
for example consider the predicate qreal t qestimate t .02in the r6property of table .
the fitness value of this predicate at t i.e.
the oracle output in definition .
can only be evaluated after generating signals qreal and qestimate up to the time instant t .
this requires extending the time domain tby2000 seconds.
instead of forcing a longer simulation time we propose a procedure that rewrites the rfol formulas into a form that allows a direct translation into online test oracles.
this procedure called time and interval shifting is presented in section .
.
having applied the procedure to rfol formulas in section .
we describe our translation to convert rfol formulas into simulink oracles .
we further present a proof of soundness and completeness of our translation in that section.
all the proofs of the theorems are provided in our online appendix .
.
time and interval shifting below we present the time andinterval shifting steps separately time shifting.
any signal term that refers to a signal value generated in the future should be rewritten as a signal term that does not refer to the future.
for example the formula qreal t that refers to the value of qreal in the future cannot be checked online.
therefore our time shifting procedure replaces any signal term f t n with a signal term f t n as follows let be an rfol formula.
we traverse from its leaves to its root and replace every sub formula t n1 n2 t resp.
t n1 n2 t of with t n1 dt n2 dt t dt resp.
t n1 dt n2 dt t dt where dtis the maximum value of constant n in time terms t nappearing as signal indices in t .
for example the requirement r5in table is rewritten as t qtar et t qtar et t sin interval shifting.
to ensure that can be translated into an online test oracle for any t 1 2 in the interval 1 2 should end after all the intervals such that t is a sub formula of i.e.
2 and further it should begin after all the intervals such that t is a sub formula of i.e.
1 .
similarly for any t 1 2 in the dual of the above two conditions must hold.
these conditions will ensure that the evaluation of the sub formulas in the scope of tcan be fully contained and completed within the evaluation of their outer formula.
for example t f t t f t cannot be checked in an online way since the time interval of the inner sub formula i.e.
does not end before the time interval of the outer formula i.e.
.
therefore our intervalshifting procedure shifts each time interval 1 2 to ensure that it terminates after all its related inner time intervals.
let be an rfol formula.
we traverse from its leaves to its root and we perform the following operations i replace every subformula t 1 2 t of with t 1 du 2 du t du where duis the maximum value of constant nin the upper bounds 2of time intervals 1 2 associated with operators and the lower bounds 1of time intervals 1 2 associated with operators in t ii execute a dual procedure to update the time 6intervals of existential sub formulae.
for example the intervalshifting procedure rewrites the formula previously introduced as t f t t f t .
to ensure interval shifting is applied to signal variables with constant indices we replace every f n in where nis a constant with t f t where t is a new time variable that has not been used in .
we refer to the rfol formula obtained by sequentially applying time shifting and interval shifting to an rfol formula asshifted formula and denote it by .
theorem .
.
let be an rfol formula and let be its shiftedformula .
for any signal set f we have f f the time complexity of generating a shifted formula is where is the size of the formula i.e.
the sum of the number of its temporal and arithmetic operators.
both time and the interval shiftings scan the syntax tree of from its leaves to the root twice one for computing the shifting values dtanddufor every subformula of and the other to apply the shifting i.e.
replacing the variable twith t dtort du.
.
from rfol to simulink in this section we translate rfol formulas written in their shiftedforms as described in section .
into simulink.
table presents the rules for translating each syntactic construct of rfol defined in definition .
into simulink blocks.
note that handgin table respectively refer to binary arithmetic operators e.g.
or unary functions e.g.
sin and map to their corresponding simulink operations.
below we discuss the rules for t f t n t 1 2 and rsince the other rules in table directly follow from the rfol semantics.
note that signal variables in shifted formulas are all written as f t n s.t.n .
hence we give a translation rule for signal variables in the form of f t n only.
rule1 to compute the value of t we use an integrator simulink block to compute the formula t 0dtwhich yields t. rule4 to encode f t n we first obtain the delay napplied to the signal f. to obtain the value of nfrom t n we compute t t n .
we then use the transport delay block of simulink to obtain the value of fatntime instants before t. rule8 the formula t 1 2 is mapped into a simulink model that initially generates the value 1until the start of the time interval 1 2 .
when t 1 2 holds the multiplexer of rule8 selects the value of instead of .
note that we use symbol for symbol for symbol for and symbol for .
the feedback loop in the model combined with a delay block i.e.
z computes the minimum of over the time interval 1 2 .
once the time interval 1 2 expires the multiplexer chooses constant again.
this however has no side effect on the valuevalready computed for the formula t 1 2 because v 1and the minimum of vand1remainsvuntil the end of the simulation.
note that the rule for translating t 1 2 into simulink is simply obtained by replacing in rule8 min with max and constant with constant .
rule9 recall that the semantics of rdepends on a domain specific fitness function.
in our work we implement the diffblock in rule9 based on the functions given in section .
for function diff.let be an rfol formula and be its corresponding shifted formula.
we denote by m the simulink model obtained by translating using the rules in table .
the model m is a definitive simulink model and has one and only one output because every model fragment in table has one single output.
this output will be indicated in the following with the symbol e. below we argue that m conforms to our notion of test oracle given in definition .
and is an online oracle that can handle continuous signals.
in order to use m to check outputs of model mpwith respect to a property it suffices to connect the outputs of mpto the inputs of m .
we denote the model obtained by connecting the output ports of mp to the input ports of m bymp m .
clearly mp m has only one output signal e i.e.
the output of m .
theorem .
.
letmpbe a partial simulink model and let ibe a test input for mpdefined over the time domain t .
let be a requirement of mpin rfol.
suppose o1 o2.
.
.ok hp i mp and e1 e2 .
.
.
ek hp i mp m are simulation results generated for the time domain t. then the value of over every signal set oi o1 o2.
.
.ok is equal to the value of the signal ei generated by mp m at time tu.
that is oi ei tu .
further we have oracle mp i min e e1 .
.
.
ek e tu that is the minimum value of the outputs of mp m attuis equal to the oracle value as defined by definition .
.
theorem .
states that our translation of rfol formulas into simulink is sound andcomplete with respect to our notion of oracle in definition .
.
note that in the case of a definite simulink model m the output of m m is a single signal e. in summary according to theorem .
mp m orm m is able to correctly compute the fitness value of for test input i. theorem .
.
letmpbe a partial simulink model and let i be a test input for mpover the time domain t .
let be a requirement of mpin rfol.
suppose e1 e2 .
.
.
ek hp i mp m are simulation results generated for t. let dbe the maximum constant appearing in the upper bounds of the time intervals of for existential quantifiers i.e.
time intervals in the form of t in .
each ei e1 e2 .
.
.
ek is decreasing over the time interval d tu .
note that din theorem .
indicates the time instant when all the existentially quantified time intervals of are terminated and hence all the sub formulas within the existential quantifiers of are evaluated.
according to theorem .
the oracle output for becomes monotonically decreasing after d. therefore after d we can stop model simulations as soon as the output of mp m falls below some desired threshold level.
more specifically if the output ofmp m falls below a threshold at time t dit will remain below that threshold for any t t. hence mp m is able to check test outputs in an online manner and stop simulations within the time interval d tu as soon as some undesired results are detected.
note that d 0if does not have any existential quantifier.
our oracles can check simulink models with time and magnitudecontinuous signal outputs since all the blocks used in table can be executed by both fixed step and variable step solvers of simulink where the time step is decided by the same solver applied to the 7table translating the sffo formulae into simulink oracles.
rule rule1 rule2 rule3 rule4 rule5 formula t n t n f t n h 1 2 g simulink 1s1 nn nt tt nf t nf t n h 2g rule rule6 rule7 rule8 rule9 formula 1 2 1 2 t 1 2 r simulink max min and mux1minz t or or t rdi r model under test.
finally the running time of our oracle is linear in the size of the underlying time domain t. evaluation in this section we empirically evaluate socrates using eleven realistic and industrial simulink models from the cps domain.
specifically we aim to answer the following questions.
rq1 is our requirements language rfol able to capture cps requirements in industrial settings?
rq2 is the use of rfol and our proposed translation into simulink models likely to be practical and beneficial?
rq3 is a significant amount of execution time saved when using online test oracles as compared to offline checking?
implementation.
we implemented socrates as an eclipse plugin using xtext and sirius and have made it available online .
study subjects.
we evaluate our approach using eleven case studies listed in table .
we received the case studies from two industry partners luxspace a satellite system developer and qra corp a verification tool vendor to the aerospace automotive and defense sectors.
each case study includes a simulink model and a set of functional requirements in natural language that must be satisfied by the model.
two of our case studies i.e.
satex from luxspace and autopilot from qra corp are large scale industrial models and respectively represent full behaviors of a satellite and an autopilot system and their environment.
the other nine models capture smaller systems or sub systems of some cps.
our case study models implement diverse cps functions and capture complex behaviors such as non linear and differential equations continuous behaviors and uncertainty.
satex andautopilot are continuous models.
satex further has inputs with noise and some parameters with uncertain values.
table also reports the number of blocks blocks of the simulink models and the number of requirements reqs in our case studies.
in total our case studies include requirements.
rq1 rfol expressiveness .
to answer this question we manually formulated the functional requirements in our case studies into the rfol language.
all of the functional requirements of our eleven study subjects were expressible in rfol without any need to alter or restrict the requirements descriptions.
further all thesyntactic constructs of rfol described in section .
were needed to express the requirements in our study.
the answer to rq1 is that rfol is sufficiently expressive to capture all the cps requirements of our industrial case studies.
rq2 usefulness of the translation .
recall that engineers need to write requirements in rfol before they can translate them into simulink.
to answer this question we report the size of rfol formulas used as input to our approach the time it takes to generate online simulink oracles and the size of the generated simulink oracles.
we measure the size of rfol requirements as the sum of the number of quantifiers and arithmetic and logical operators and the size of simulink oracles as their number of blocks and connections.
figure a shows the size of rfol formulas for our case study requirements and figure b shows the number of blocks blocks and connections connections of the oracle simulink models that are automatically generated by our approach.
in addition figure c shows the time taken by our approach to generate oracle models from rfol formulas.
as shown in figure it took on average .6ms to automatically generate oracle models with an average number of .
blocks and .
connections for our case study requirements.
further the average size of rfol formulas is .
showing that the pre requisite effort to write the input rfol formulas for our approach is not high.
the difference in size between rfol formulas and their corresponding simulink models is mostly due to the former being particularly suitable for expressing declarative properties such as logical properties with several nested quantifiers.
given this property and in addition the fact that verification and test engineers are not always very familiar with simulink a tool dedicated to control engineers we expect significant benefits from translating rfol into simulink.
the answer to rq2 is that for our industrial case studies the translation into simulink models is practical as the time required to generate the oracles is acceptable.
it takes on average .6ms for socrates to generate oracle models and the average size of the input rfol formulas is .
showing that the pre requisite effort of our approach is manageable.
8table important characteristics of our case study systems from left to right name description number of blocks of the simulink model of each case study blocks and number of requirements in each case study reqs .
model name model description blocks reqs autopilot a full six degree of freedom simulation of a single engined high wing propeller driven airplane with autopilot.
satex discussed in section .
neural network a two input single output predictor neural network model with two hidden layers.
tustin a numeric model that computes integral over time.
regulator a typical pid controller.
nonlinear guidance a non linear guidance algorithm for an unmanned aerial vehicles uav to follow a moving target.
system wide integrity monitora numerical algorithm that computes warning to an operator when the airspeed is approaching a boundary where an evasive fly up maneuver cannot be achieved.
effector blender a control allocation method to calculate the optimal effector configuration for a vehicle.
two tanks a two tanks system where a controller regulates the incoming and outgoing flows of the tanks.
finite state machine a finite state machine executing in real time that turn on the autopilot mode in case of some environment hazard.
euler a mathematical model to compute dimensional rotation matrices for an inertial frame in a euclidean space.
050100150200numberrfol size 5101520time ms oracle gen. time 0100200300oracle size figure plots reporting a the size of the rfol formulas b the number of blocks and connections of the oracle models and c the time took socrates to generate the oracles.
rq3 impact on the execution time .
online oracles can save time by stopping test executions before their completion when they find a failure.
however by combining a model mand a test oracle i.e.
generating m m the model size increases and so does its execution time.
hence in rq3 we compare the time saved by online oracles versus the time overhead of running the oracles together with the models.
for this question we focus on our two large industrial models satex andautopilot since they have long and time consuming simulations while the other models in table are relatively small with simulation times less than one minute.
for such models both the time savings and the time overheads of our online oracles are practically insignificant.
during their internal testing our partners identified some faults insatex andautopilot violating some of the model requirements.
we received from our partners failing test inputs for autopilot defined over the time domain t and failing test inputs forsatex defined over the time domain t .
recall that satex contains some parameters with uncertain values.
we also received the value range for one uncertain parameter of satex i.e.
acm type from our partner.
we then performed the following three experiments.
expi we ran all the test inputs on the models alone without including oracle models.
expii we combined satex andautopilot with test oracle models related to their respectiverequirements and ran all the test inputs on the models with oracles.
we did not consider any uncertainty in satex and set acm type to a fixed value.
expiii we ran all the tests on satex combined with its oracle models and defined acm type as an uncertain parameter with a value range.
we repeated expii andexpiii for two threshold values threshold 0where test executions are stopped when tests fail according to their boolean semantics and threshold where test executions are never stopped.
figures a and b respectively show the results of expi and expii forautopilot andsatex .
specifically the figures show the time required to run the test inputs on autopilot andsatex without any oracle model m with oracle models m m for threshold and with oracle models m m for threshold .
specifically in the second case test oracles stop test executions when test cases fail and in the third case test oracles are executed together with the model but do not stop test executions.
our results show that on average it takes .1s and .2s to run tests on autopilot andsatex respectively i.e.
case m .
these averages respectively reduce to .3s and .4s when oracles stop test executions and they respectively increase to .6s and .1s when oracles do not stop test executions.
that is for autopilot the average time saving of our oracles is .
.5m while their average time overhead is .2m .
in contrast for satex our oracles lead to an average time saving of 80m and an average time overhead of 5m .
we note that autopilot is less computationally intensive.
in this case the time savings and overheads are almost equivalent because the size and complexity of the generated oracles are comparable to those of the model.
satex on the other hand is more computationally intensive and as the results show for satex our oracles introduce very little time overhead but are able to save a great deal of time when they identify failures.
finally we note that the time saving depends also on the presence of faults in models and whether and when test cases trigger failures.
nevertheless according to discussions with our partners and as evidenced by our case studies early cps simulink models typically contain faults and hence our approach can help in saving test execution times for such models.
995100105110115time s .
.
.
.
.
.
.
a autopilot 4970497549804985499049955000500550105015time s b satex without unc 9950996099709980999010000time s .
.
.
.
c satex with unc 10420104301044010450104601047010480figure test execution time on models without oracles m models with oracles m m with threshold 0and models with oracles m m with threshold 1for a autopilot b satex without uncertainty and c satex with uncertainty.
figure c shows the results of expiii for running satex with uncertainty.
since in the case of uncertainty a set of outputs are generated the total test execution time increases.
specifically it takes on average .9s to run satex with uncertainty without oracles .2s to run it when oracles stop test executions and .0s to run it when oracles do not stop test executions.
as the results show for satex with uncertainty the time saving is even higher i.e.
163m than the case of satex without uncertainty because oracles stop simulations as soon as one output among the set of generated outputs fails.
the answer to rq3 is that for large and computationally intensive industrial models our oracles introduce very little time overhead but are able to save a great deal of time when they identify failures .
when models contain uncertainty the time saving becomes even larger and the time overhead decreases making our online oracles more beneficial.
data availability.
our tool is available online .
among the considered models all the models with the exception of the satex model are available on request .
the satex model is not shared as it is part of a non disclosure agreement.
related work we classified the related work by analyzing whether the work addresses the oracle generation problem og ?
whether it satisfies assumptions a1anda2 section ?
and whether it aims to achieve objectives o1too4 section ?
note that assumption a3is considered in all the related work included here.
as shown in the table there is no work that achieves oracle generation and satisfies all our four objectives.
below we discuss the closest lines of work to ours among those included in table .
dokhanchi et al.
propose an online monitoring procedure for metric temporal logic mtl properties implemented in the s taliro tool .
the authors use a prediction technique to handle temporal operators that refer to future time instants compared to the shifting procedures proposed in our work.
as a result their monitoring procedure has a higher running time complexity than our oracles i.e.
polynomial in the size of time history versus linear in the time domain tsize .
furthermore they do not translate their monitors into simulink and hence cannot benefittable classification of the related work based on the following criteria is the work about oracle generation og ?
does the work build on the a1 and a2 assumptions see section ?
does it achieve the o1 to o4 objectives see section ?
assumption a3 is satisfied by all the related work.
assumpt.
objectives ref og a1 a2 o1 o2 o3 o4 the notation indicates that the monitoring procedure assumes a fixed sample rate and hence does not accurately handle variable step outputs.
from the execution time speed up of efficient simulink blocks and the simulink variable step solvers to handle continuous behaviors.
thus as shown by dokhachi et al.
the time overhead of their approach is considerably high as the time history grows.
jak i et al.
recently developed an online monitoring procedure for stl by translating stl into automata monitors with a complexity that is exponential in the size of the formula.
in contrast to our work such monitors are not able to handle continuous signals sampled at a variable rate directly.
this such signals are approximated as fixed step signals hence decreasing the analysis precision of continuous behaviors.
to the best of our knowledge and according to a recent survey the only work that like us translates a logic into simulink to enable online monitoring is the work of balsini et al.
.
the translation however is given for a restricted version of stl which for example does not allow the nesting of more than two temporal operators.
as discussed in section .
rfol subsumes stl.
hence our translation subsumes that of balsini et al.
.
breach is a monitoring framework for continuous 10and hybrid systems that translates stl into online monitors specified in c or matlab s functions.
however due to the overhead of integrating c or s functions in simulink running monitors in the breach framework greatly slows down model simulations by .
times making the monitors impractical for computationally expensive cps models such as our satex case study.
finally maler et al.
propose a monitoring procedure that receives signal segments sequentially checks each segment and stops simulations if a failure is detected.
this work however is only partially online since each segment is eventually checked in an offline mode.
there are a number of work defining a quantitative semantics for logics used in the context of cps.
dokhachi et al.
introduce the concept of robustness of an stl property specifying how robustly a requirement is satisfied or violated.
jak i et al.
use the concept of edit distance to measure the degree of similarity between two signals.
silvetti et al.
propose a variation of stl that enables to reason about the percentage of time a formula is satisfied in a bounded interval.
our semantics for rfol in contrast to the existing work captures the satisfaction degree of requirements.
conclusions in this paper we presented socrates an automated approach to generate online test oracles in simulink able to handle cps simulink models with continuous behaviors and involving uncertainties.
our oracles generate a quantitative degree of satisfaction or failure for each test input.
our results were obtained by applying socrates to industry case studies and show that i our requirements language is able to express all the requirements of our case studies ii the effort required by socrates to generate online oracles in simulink is acceptable paving the way for a practical adoption of the approach and iii for large models our approach dramatically reduces the test execution time compared to when test outputs are checked in an offline manner.