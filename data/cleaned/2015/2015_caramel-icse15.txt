caramel detecting and fixing performance problems that have non intrusive fixes adrian nistor1 po chun chang2 cosmin ra shan lu4 1chapman university 2university of wisconsin madison 3university of illinois urbana champaign 4university of chicago 1anistor chapman.edu 2pchang9 cs.wisc.edu 3cos illinois.edu 4shanlu cs.uchicago.edu abstract performance bugs are programming errors that slow down program execution.
while existing techniques can detect various types of performance bugs a crucial and practical aspect of performance bugs has not received the attention it deserves how likely are developers to fix a performance bug?
in practice fixing a performance bug can have both benefits and drawbacks and developers fix a performance bug only when the benefits outweigh the drawbacks.
unfortunately for many performance bugs the benefits and drawbacks are difficult to assess accurately.
this paper presents c aramel a novel static technique that detects and fixes performance bugs that have non intrusive fixes likely to be adopted by developers.
each performance bug detected by c aramel is associated with a loop and a condition.
when the condition becomes true during the loop execution all the remaining computation performed by the loop is wasted.
developers typically fix such performance bugs because these bugs waste computation in loops and have nonintrusive fixes when some condition becomes true dynamically just break out of the loop.
given a program c aramel detects such bugs statically and gives developers a potential sourcelevel fix for each bug.
we evaluate c aramel onreal world applications including popular java applications e.g.
groovy log4j lucene struts tomcat etc and widely used c c applications chromium gcc mozilla and mysql .
c aramel finds new performance bugs in the java applications and new performance bugs in the c c applications.
based on our bug reports developers so far have fixed and performance bugs in the java and c c applications respectively.
most of the remaining bugs are still under consideration by developers.
i. introduction software performance is critical for the success of a software project.
performance bugs1are programming errors that slow down program execution .
performance bugs create poor user experience affect the user perceived software quality degrade application responsiveness waste computational resources and lower system throughput .
even expert programmers can introduce performance bugs which have already caused serious and highly publicized incidents .
well tested commercial products such as internet explorer microsoft sqlserver visual studio and acrobat reader are also affected by performance bugs .
several techniques have been proposed to help detect various types of performance bugs.
however there performance bug is a well accepted term in some communities e.g.
mozilla bugzilla defines it as a bug that affects speed or responsiveness .
however others believe bug requires specifications and prefer to use the terms performance problem or performance issue .
we feel this is just a naming issue and use the mozilla bugzilla term of performance bug .are still many performance bugs that cannot be detected by existing techniques.
furthermore a crucial and practical aspect of performance bugs has not received the attention it deserves how likely are developers to fix a detected performance bug?
in practice when developers decide if they should fix a performance bug developers face a difficult choice between the potential drawbacks and the potential benefits of the fix.
on one hand similar to fixing functional bugs fixing performance bugs can have drawbacks.
first fixing performance bugs may introduce severe functional bugs which may lead to program crash or data loss.
the risk of having such negative and noticeable effects can make developers very cautious about improving performance.
second fixing performance bugs may break good software engineering practices making the code difficult to read maintain and evolve.
for example fixing performance bugs may require breaking encapsulation code cloning or specialization.
third fixing performance bugs takes time and effort especially if the fix involves several software modules or requires a complex implementation.
fourth fixing performance bugs which manifest for some inputs may slow down other code for some other inputs and developers must decide which of these slowdowns the slowdown caused by the performance bug for some inputs or the slowdown caused by the fix for some other inputs is preferable.
on the other hand fixing performance bugs has benefits i.e.
it speeds up code.
however unlike fixing functional bugs the benefits of fixing a performance bug are often difficult to assess accurately especially when the fix is complex.
first the speedup offered by the fix depends on the input and many inputs may not be sped up at all because performance bugs manifest only for certain inputs.
therefore developers need to estimate which inputs have which speedups and how frequent or important are these inputs in practice.
second the exact speedup offered by the fix for an input is difficult to estimate without executing the code and speedups of orders of magnitude i.e.
speedups for which accurate estimates are not necessary are rare.
unfortunately developers often have access to only a few real world inputs triggering a bug or none at all if the bug was detected during development using benchmarks static tools or code inspection and can find it difficult to estimate the expected speedup for the rest of the real world inputs that may trigger the bug.
in practice developers fix performance bugs when the benefits outweigh the drawbacks.
specifically developers are likelyto fix performance bugs that have simple and non intrusive fixes.
such fixes are unlikely to introduce new functional bugs do not increase code complexity and maintenance costs are easy to understand and implement and are unlikely to degrade performance for other inputs.
in other words the choice between benefits and drawbacks is made easy for developers because the fixes are simple and non intrusive fixing the bugs brings only benefits.
this paper makes the following contributions novel perspective compared with previous work this paper has a unique perspective towards detecting performance bugs we focus on detecting bugs that are very likely to be fixed by developers .
following the above discussion we propose to detect performance bugs whose fixes clearly offer more benefits than drawbacks to developers.
new family of performance bugs this paper identifies a family of performance bugs that developers are very likely to fix.
every bug in this family is associated with a loop2and a condition.
when the condition becomes true during the loop execution all the remaining computation performed by the loop is wasted.
in the extreme case when the condition is true at the start of the loop execution the entire loop computation is wasted.
developers typically fix performance bugs in this family because these performance bugs waste computation in loops and these performance bugs have simple and nonintrusive fixes when some condition becomes true just break out of the loop.
typically these bugs are fixed by adding one line of code inside the loop i.e.
if cond break which we call a condbreak fix .
we call cond al break condition .
important performance bugs the performance bugs in this family are important developers of real world applications typically fix these bugs.
developers are the ultimate arbiters for what is useful and what is not useful for their project and developers typically think these bugs must be addressed.
furthermore these bugs are not all the performance bugs that have non intrusive fixes and our work is a promising first step in this important research direction.
technique this paper proposes c aramel a novel static technique for detecting performance bugs that have condbreak fixes.
c aramel takes as input a program and outputs loops that can be fixed by condbreak fixes together with a potential fix for each buggy loop.
the fixes proposed by caramel can be directly applied to source code and are easy to read by developers.
c aramel works on intermediate code representation and analyzes each loop in five steps.
first caramel identifies the loop instructions that may produce results visible after the loop terminates.
second for each such instruction c aramel detects the condition under which the instruction can be skipped for the remainder of the loop without changing the program outcome.
we call this condition an i break condition similarly to the l break condition described earlier for the entire loop.
third c aramel checks if all instructions from step two can be skipped simultaneously without changing the program outcome i.e.
if all i break 2we focus on loops because most computation time is spent inside loops and most performance bugs involve loops .conditions can be satisfied simultaneously.
the conjunction of all i break conditions is the l break condition.
fourth caramel checks if the computation waste in the loop is not already avoided i.e.
if the loop does not already terminate when the l break condition is satisfied.
if all the previous steps are successful c aramel reports a performance bug.
fifth c aramel generates a fix for the performance bug.
the fix has the basic format if cond break where cond is the l break condition c aramel computed in the third step.
automatic fix generation automated bug fixing is challenging in general but c aramel is able to automatically generate fixes for most bugs because c aramel takes advantage of two characteristics of the performance bugs it detects the bugs have condbreak fixes which can be inserted right at the start of the loop thus avoiding complex interactions with other loop code and the l break condition in a condbreak fix is a relatively simple boolean expression sections ii iii .
evaluation our main measure of success for c aramel is if real world developers think the bugs found by c aramel are important as quantified by the number of bugs fixed.
we implement twocaramel tools one for java c aramel j and one for c c c aramel c. we evaluate c aramel j on popular java applications ant groovy jmeter log4j lucene pdfbox sling solr struts tika and tomcat.
caramel j found new real world performance bugs of which bugs have already been fixed by developers .
we evaluate c aramel c on widely used c c desktop and server applications chromium gcc mozilla and mysql.
caramel c found new real world performance bugs of which bugs have already been fixed by developers .
of the bugs not yet fixed bugs are confirmed and still under consideration by developers and bugs are still open.
bugs were not fixed because they are in deprecated code old code test code or auxiliary projects.
only bugs were not fixed because developers considered that the bugs have small performance impact or that the fixes make code more difficult to read.
caramel has few false positives for c aramel j and for c aramel c. out of bugs c aramel successfully generates fixes for bugs.
ii.
w hatperformance bugs havecondbreak fixes ?
we discuss below two bug characteristics that help understand what performance bugs have condbreak fixes.
we callresult instruction ri a loop instruction that may write to variables live and memory reachable after the loop.
ris are important in understanding performance bugs that have condbreak fixes.
for example if all ris in a loop do not need to execute under a certain condition the entire loop including all non ris can be skipped.
a where the computation is wasted a loop related performance bug can waste computation either in an entire iteration or in parts of an iteration in consecutive or arbitrary iterations in iterations at the start end or middle of the loop.
such a bug can have a condbreak fix i.e.
break out of the loop under a certain condition if it wastes computation in the entire iteration in one of the following three locations for every iteration in the loop short as every for every iteration at the end of the loop short as late or for every iteration at the start of the loop short as early .
bugs that waste computation in category every can be fixed by breaking out of the loop if the l break condition is satisfied at the loop entrance effectively skipping the entire loop.
bugs that waste computation in category late can be fixed by breaking out of the loop once the computation waste starts.
bugs that waste computation in category early can be fixed by iterating from the end of the loop and breaking out of the loop once the computation waste starts.
bugs that waste computation only in parts of an iteration or only in specific iterations cannot be fixed by condbreak fixes and are not the focus of c aramel .
b how the computation is wasted in order for the computation of an entire iteration to be wasted under a certain condition i.e.
the l break condition every ri in that iteration has to fall into one of following three cases the ri is not executed under the l break condition short as no result the ri is executed but under the l break condition its result does not change the values used by computation after the loop short as useless result or the ri is executed and its result changes the values used by computation after the loop but under the l break condition this result does not affect the perceived outcome of the program short as semanticallyuseless result .
identifying semantically useless result ris usually requires developers expert knowledge and the lbreak conditions are likely difficult to express in source code.
caramel focuses on no result and useless result ris.
based on the above discussion a loop can have a performance bug fixed by a condbreak fix if allris in the loop belong to one of the six types shown in figure .
note that the three computation waste locations in a effectively describe which instances of an ri can be skipped in the loop.
we describe individual ris of types i.e.
the types caramel focuses on in sections ii a ii d and we present how multiple ris appear in the same bug in section ii f. we briefly discuss type x and type y in section ii e. every late early no result type type type y useless result type x type type fig.
.
types of ris the bugs in the following examples are previously unknown real world performance bugs found by c aramel .
we reported them to developers and the developers fixed all of them.
a. type ris figure shows a performance bug from groovy containing a type ri.
line is the fix and it is notpart of the original buggy code.
the only ri in this loop is return true line which writes the method s return value and also causes the code after the loop to not execute.
when argtypes is initialized to a non empty array the ri cannot execute throughout the loop the entire loop computation is wasted and the loop can just be skipped.
the reason is that argtypes is never modified inside the loop.
when argtypes is initialized to a non empty array both argtypes nullandargtypes.length line are false throughout the loop which makes iszeroarg false which makes match line false which in turn means the ri cannot execute.
1class argtypes ... 2for iterator i methods.iterator i.hasnext f if !
argtypes null !
argtypes.length break fix 4methodnode mn methodnode i.next 5boolean iszeroarg argtypes null jjargtypes.length 6boolean match mn.getname .equals methodname iszeroarg 7if match return true ri 8g fig.
.
type ri in a groovy performance bug this ri is of type because if the i break condition is true at the start of the loop the ri is not executed category no result in any iteration of the entire loop category every .
the i break condition for the ri is that both argtypes null andargtypes.length are false.
the l break condition is the same as the i break condition because there is only one ri.
the condbreak fix is the code added in line the at the start of line means the line is added i.e.
the loop breaks when the l break condition is true.
we discuss fixes equivalent to the condbreak fix in section iii e. b. type ris figure shows a performance bug from pdfbox containing a type ri.
there are three loops in this code and two ris as shown in the figure.
ri is an ri for all three loops because it writes alreadypresent which is live at the end of all three loops.
similarly ri is an ri for loops and .
the ... in the figure replace some complicated control flow and method calls which we skip for clarity.
the ... contain no ris.
in this section we focus our discussion on ri because ri is of type which we will discuss in the next section.
loop does not have a bug which we will further explain in section iii d. loops and are both buggy as explained next for loop .
similar reasoning applies for loop .
1boolean alreadypresent false 2while itactualembeddedproperties.hasnext f loop if alreadypresent break fix ... non ris while itnewvalues.hasnext f loop ... non ris while itoldvalues.hasnext !alreadypresent f loop oldval texttype itoldvalues.next if oldval.getstringvalue .equals newval.getstringvalue f alreadypresent true ri gg if !alreadypresent f embeddedprop.getcontainer .addproperty newval ri 14ggggg fig.
.
type ri in a pdfbox performance bug for the first few loop iterations alreadypresent is false the condition on line evaluates to true and ri executes and performs useful computation.
however once alreadypresent is set to true on line the condition on line remains false for the remainder of the loop and all the remaining computation in the loop can just be skipped.
the reason is that the entire loop cannot assign alreadypresent to false.
consequently once alreadypresent becomes true on line it remains true and disables the execution of ri for the remainder of the loop.
ri is of type because once the i break condition becomes true ri is not executed category no result for 3the remaining loop iterations category late .
the i break condition for ri is that alreadypresent equals true.
we will explain in the next section that the i break condition for ri is also that alreadypresent equals true.
the l break condition is the conjunction of the two i break conditions i.e.
alreadypresent equals true.
the condbreak fix is the code added in line i.e.
the loop breaks when the l break condition is true.
c. type ris figure a shows a performance bug from tomcat containing two type ris ri and ri .
both ris set variable elexp to true.
once either ri is executed the remaining computation in the loop is unnecessary at best setting elexp to true again.
1boolean elexp ... 2while nodes.hasnext f if elexp break fix 4elnode node nodes.next 5if node instanceof elnode.root f if elnode.root node .gettype f elexp true ri gelse if checkdeferred elnode.root node .gettype !pageinfo.isdeferredsyntaxallowedasliteral f elexp true ri 11ggg a a type ri in a tomcat performance bug 1valid child.validate ri b type ri in a sling performance bug fig.
.
type ris ri is of type because once the i break condition becomes true ri s results for the remaining iterations category late do not change the values used by future computation category useless result .
similar reasoning applies for ri .
the i break condition for ri is that elexp equals true.
ri has the same i break condition.
the l break condition is the conjunction of the two i break conditions i.e.
elexp equals true.
the condbreak fix is the code on line i.e.
the loop breaks when the l break condition is true.
note that for ri and ri to be of type elexp can have any type not necessarily boolean as long as elexp is assigned a constant.
in fact even if elexp is not assigned a constant there is still an alternative way to set elexp to a value that does not change after some time as shown in figure b .
in figure b once valid is set to false the semantics of the operator ensures valid remains false.
the i break condition is that valid equals false.
d. type ris figure a shows a performance bug from jmeter containing a type ri line .
the variable length keeps getting overwritten by the ri.
consequently all iterations before the last iteration that writes length are wasted.
the reason is that computation after the loop will only see the last value written to length .
this last value does not depend on previous iterations except for the value of idx which can be computed when iterating from the end of the loop.
the ri is of type because its results for early iterations category early do not affect the values used by future computations category useless result .
the i break condition for the ri is that length has been written in the loop when1intlength ... 2for intidx idx headersize idx f for intidx headersize idx idx f fix 4header hd mngr.getheader idx 5if httpconstants.header.equalsignorecase hd.getname f length integer.parseint hd.getvalue ri break fix 8gg a bug and alternative fix 1intlength ... boolean wasexecuted false fix 3for intidx idx headersize idx f for intidx headersize idx idx f fix if wasexecuted break fix 6header hd mngr.getheader idx 7if httpconstants.header.equalsignorecase hd.getname f if !wasexecuted f fix wasexecuted true fix length integer.parseint hd.getvalue ri g fix 12gg b condbreak fix fig.
.
type ri in a jmeter performance bug.
the fix in a is an alternative fix.
the condbreak fix is in b .
iterating from the end of the loop.
the l break condition is the same as the i break condition because there is only one ri.
for clarity the condbreak fix is shown separately in figure b .
this fix looks complex because we want to make the l break condition i.e.
wasexecuted equals true explicit in the code.
differently from the type ri in figure a the ri in this example does not set length to a constant.
therefore we have to create an extra variable wasexecuted lines to track whether length has been written.
figure a shows a simpler alternative fix that does not use wasexecuted .
in the alternative fix the reversed loop breaks the first time when the ri is executed line7 .
the simpler alternative fix comes at a price it is correct only when the loop has one ri.
otherwise breaking out of the loop after one ri would incorrectly miss the execution of remaining ris.
e. type x and type y ris a type x instruction would be similar to ri and ri in figure a if the value of elexp would be a constant true before the loop started.
in practice c aramel never found such ris.
a type y ri cannot write to the same memory locations in different loop iterations.
checking that all dynamic instances of the same static instruction can only write to disjoint memory locations requires complex static analysis and c aramel does not perform such checks.
f .
bugs with multiple ris a buggy loop can contain multiple ris of the same or different types.
the only constraint is that a type ri cannot co exist with type or type ris because the former requires the bug fix to skip iterations at the start of the loop and the latter requires the bug fix to skip iterations at the end of the loop.
in practice we did not encounter type ris co existing with other types of ris.
some ris can be of multiple types as shown next for ri and ri .
the l break condition is the conjunction of all ris i break conditions.
figure shows an example bug with multiple ris from pdfbox.
unlike the bugs in figure and figure a this bug has nine ris that have different i break conditions.
ri and 4ri are type ris because once annotnotfound is set to false line annotnotfound cannot become true again and the condition on line evaluates to false in the remaining loop iterations.
similar reasoning applies for ri sigfieldnotfound line and the condition on line .
ri and ri are simultaneously type similarly to ri and ri respectively and type .
the i break conditions for ri and ri are annotnotfound equals false and sigfieldnotfound equals false respectively.
the l break condition is the conjunction of all nine i break conditions i.e.
both annotnotfound andsigfieldnotfound equal false.
1boolean annotnotfound ... 2boolean sigfieldnotfound ... 3for cosobject cosobject cosobjects f if !annotnotfound !sigfieldnotfound break fix ... some non ris 6if annotnotfound cosname.annot.equals type f ... ri and some non ris signaturefield.getwidget .setrectangle rect ri annotnotfound false ri g if sigfieldnotfound cosname.sig.equals ft apdict!
null f ... ri ri ri ri and some non ris acroformdict.setitem cosname.dr dr ri sigfieldnotfound false ri 15gg fig.
.
multiple ris in a pdfbox performance bug iii.
d etecting and fixing performance bugs that havecondbreak fixes we next present the high level c aramel algorithm section iii a and the algorithm steps sections iii b iii e .
a. high level algorithm figure shows the high level algorithm for c aramel .
caramel is a static technique that works on intermediate code representation ir .
c aramel receives as input the loop to analyze and various information to help the static analysis e.g.
the control flow graph for the method containing the loop pointer aliasing information and a call graph.
1void detectperformancebug loop l method m aliasinfo alias f 2sethinstruction iallris getris l m alias 3sethcondition iallcond new sethcondition i 4for instruction r allris f condition one typeone r l m alias condition two typetwo r l m alias condition three typethree r l m alias condition four typefour r l m alias allris.size if one.false two.false three.false four.false return allcond.putifnotfalse one two three four g if satis edtogether allcond notalreadyavoided allcond l f string x generatefix allcond l m reportbugandfix x allris allcond 15gg fig.
.
c aramel high level algorithm caramel works in five steps.
first c aramel computes the loop ris using routine static analysis line .
second for each ri r caramel checks if rbelongs to one of the four types presented in section ii and computes r s i break condition accordingly lines .
if rdoes not belong to any of the four types all the conditions computed on lines are false and therefore the loop does not have a bug line .
if r is of one of the four types c aramel saves for further use r s i break condition line .
third c aramel checks if all ris can be skipped simultaneously without changing theprogram outcome i.e.
if the i break conditions for individual ris can be satisfied simultaneously line .
the conjunction of the i break conditions is the l break condition.
fourth caramel checks if the computation waste in the loop is not already avoided i.e.
if the loop does not already terminate when the l break condition is satisfied line .
fifth using the l break condition c aramel generates a fix line and reports the bug line .
the bug report contains the fix and for each ri the ri type and i break condition.
the above algorithm enables c aramel to detect and fix performance bugs that involve multiple ris either of the same or different types similar to the bugs in figures a and .
this is because after step two c aramel works only with a collection of conditions and c aramel is not concerned with how these conditions were obtained in step two.
preliminary boolean expressions to compute the i break conditions and the l break condition c aramel reasons about boolean expressions.
c aramel represents and reasons about a boolean expression as one or multiple atoms connected by boolean operators not and or .
an atom refers to either a boolean variable or a boolean expression containing non boolean operators.
atoms do not contain other atoms.
for example an atom could be a method call returning a boolean value or a comparison between two integers.
to keep complexity low and scale c aramel does not reason about operations inside atoms.
an atom can be either true or false butnotboth simultaneously.
for space limitations we do not go into the details of how caramel works with boolean expressions and we give only a high level overview for two techniques used by c aramel .
these two techniques can be substituted by more sophisticated techniques such as symbolic execution.
however for caramel s purposes these two techniques offer good results at considerably reduced complexity.
technique t pathexec computes the execution condition of a loop instruction as the disjunction of all path constraints that correspond to the acyclic execution paths leading from the loop header to the instruction.
a path constraint is the conjunction of all branch conditions represented by atoms and negated when necessary along a path.
c aramel uses t pathexec in steps two and four of the caramel algorithm.
technique t instantiation computes for a boolean expression e in dnf form and some atoms set the values of the setatoms for which eis guaranteed false or true.
conversely t instantiation determines if emay be true or false irrespective of atoms in set.
t instantiation tries all possible combinations of values for the setatoms and uses logic rules such as false andunknown equals false to determine the value of e. for example for e atom1 and atom2 andset f atom1 g t instantiation determines that when atom1 equals true eis unknown and when atom1 equals false eis false.
in the usage context of c aramel sethas few atoms e.g.
when identifying type ris set contains the loop invariant atoms in e which is rarely more than and therefore t instantiation rarely tries more than combinations.
c aramel uses t instantiation in steps two three and four of the c aramel algorithm.
5b.
detecting the four ri types in the second step of the c aramel algorithm c aramel determines if a given ri all ris are known from step one belongs to one of the four types and if so the ri s i break condition.
we describe here each type and the algorithm c aramel uses to detect it.
identifying all ris that belong to each type would require complicated and non scalable analysis.
at the same time not all ris that belong to each type are common and have i break conditions that are easy to express in sourcecode.
c aramel focuses on ris whose type can be identified using scalable analysis and whose i break conditions are easy to express in source code.
c aramel can miss some ris that belong to these four types as explained below.
type an ri ris of type if there exists a condition csuch that rcannot execute throughout the loop if cis true when the loop starts.
the i break condition for risc.
to judge whether rbelongs to type c aramel searches for r s ibreak condition.
theoretically the i break condition could be composed of any variables and expressions that appear or do not appear in the entire program.
however inferring or searching for such generic i break conditions is difficult.
in practice caramel considers only i break conditions that can be computed by analyzing the potential execution paths that may reach rfrom the loop header and are composed of atoms that can be proved to be loop invariant based on control and data flow analysis.
constraint makes detecting candidate i break conditions feasible and scalable while constraint makes it easy to prove that a candidate i break condition cannot change its value throughout the loop execution.
additionally constraint ensures the ibreak condition is easy to express in source code because the candidate i break conditions contain only variables and expressions already present in the loop.
the c aramel algorithm uses t pathexec to compute the execution condition rexeccond forr gets the loop invariant atoms in rexeccond uses t instantiation to get these atoms values for which rexeccond is guaranteed to be false irrespective of the values of other atoms in rexeccond and constructs r s i break condition based on these atom values.
type an ri ris of type if there exists a condition csuch that rcannot execute once cbecomes true during the loop execution.
the i break condition for risc.
detecting type and type ris are similar and have similar challenges.
caramel applies similar constraints when searching for r s i break condition with only one difference for constraint .
for type checking c aramel only considers atoms that are assigned one constant in the loop.
this constraint makes it easy to prove that a candidate i break condition cannot change its value after all its component atoms are updated in the loop.
the c aramel algorithm for detecting type ris is similar to the algorithm for detecting type ris with two modifications.
first instead of identifying loop invariant atoms in rexeccond the type algorithm detects atoms inrexeccond that are assigned only one boolean constant value in the loop.
second when c aramel computes theatoms values for which rexeccond is guaranteed to be false caramel takes into account that the atoms identified above can take only the corresponding constant values.
type an ri ris of type if after a certain loop iteration rcan only write to the same output locations it wrote in previous iterations and the values written are identical to the existing values in these locations we call these existing values s. the i break condition is that the output locations contain s. to judge whether rbelongs to type c aramel examines r s output locations and output values.
theoretically r could be any instruction including a call to a method with complex control flow that writes to many memory locations.
reasoning about such a general ris difficult.
in practice caramel focuses only on ris that have a single output location either write a constant similar to figure a or perform the or operations similar to figure b which effectively correspond to sbeing constants false or true respectively and have an output location that is not written to in the loop with other values except s. constraint makes it easy to detect rdoes not change its output locations while constraints and make it easy to prove that after a certain loop iteration rcan only write s. additionally constraint ensures the i break condition is easy to express in source code because scan be identified statically.
the c aramel algorithm uses straightforward static analysis to implement the above checks.
type an ri ris of type if routputs values independent of computation in early iterations except for the loop index computation and if rcannot change its output locations.
the i break condition is that the values in the output locations have been updated the first time when iterating from the end of the loop.
to judge whether rbelongs to type caramel examines r s output locations and output values.
theoretically rcould be any instruction including a method call and checking the above conditions for such a general r is difficult.
in practice caramel focuses only on ris that have a single output location appear in loops that have no cross iteration data dependency except for the loop index computation and appear in loops that have only one ri.
constraint makes it easy to detect that rdoes not change its output locations and constraint makes it easy to prove that the output values are independent of computation in earlier iterations.
additionally constraint ensures the fix is similar to the alternative fix in figure a instead of the condbreak fix in figure b .
the c aramel algorithm checks if the loop has one ri and if no instruction in the loop body writes to memory or variables live between iterations except for the loop index.
c. checking whether ris can be skipped simultaneously in the third step of the c aramel algorithm c aramel checks if a scenario exists for which all ris can be simultaneously skipped without changing the program outcome i.e.
all ris i break conditions can be satisfied simultaneously.
the l break condition enabling this scenario is the conjunction of all i break conditions.
6figure gives a simplified example from lucene of why caramel performs this check.
the two ris in this loop are of type and have i break conditions roundnum equals true and roundnum equals false respectively.
however this loop does not contain a performance bug because the executions of the two ris cannot be skipped simultaneously i.e.
roundnum cannot simultaneously be true and false.
1introundnum ... 2stringbuilder sb ... 3for nal string name colforvalbyround.keyset f 4if roundnum f sb.append format.formatpaddleft template ri 6gelse f sb.append format.format ai template ri 8gg fig.
.
simplified code from lucene.
the ris are of type but these ris do not create a performance bug.
to perform this check c aramel applies t instantiation on the conjunction of selected i break conditions effectively checking there exists at least one combination of the involved atoms values that makes the conjunction true.
c aramel optimizes this check by applying it on selected instead of all i break conditions because the definitions of some ri types already guarantee that their corresponding i break conditions will never conflict with each other.
for example the i break condition for a type ri cannot conflict with the i break condition for a type ri.
the reason is that the atoms in the i break condition of a type ri must be loop invariant and therefore cannot appear in a type ri s i break condition.
d. checking the computation waste is not already avoided in the fourth step of the c aramel algorithm c aramel checks the execution is not already exiting the loop when the l break condition is true.
loop in figure lines is an example of why c aramel performs this check.
as mentioned in section ii b loop does not have a performance bug and we now explain why.
the only ri in loop is ri line which is of type and therefore it may seem loop performs useless computation once alreadypresent is set to true.
however once alreadypresent becomes true the loop exits !alreadypresent line and therefore the loop does not have a performance bug.
c aramel performs this check using t pathexec which is used to detect the execution condition for loop exits and t instantiation which is used to detect if the paths to loop exits may be taken in the original code when the l break condition is true.
e. automatic fix generation in the fifth step of the c aramel algorithm c aramel generates source code fixes.
automatic bug fixing is a difficult problem in general but it is feasible for c aramel because caramel focuses on bugs that have condbreak fixes.
caramel generates fixes in two steps.
first c aramel generates a source code level l break condition composed of source code level variables declared and initialized outside of the loop.
because the variable and method names are available at the ir level this process is straightforward in general.
the only challenge is that some atoms in the l break condition may involve variables that are not suitable for the finalsource code fix.
specifically some variables are introduced by compiler in the ir representation and do not exist in the sourcecode while some other variables are declared or initialized inside the loop by developers and therefore cannot be used in the fix at the start of the loop.
the solution is straightforward caramel repetitively replaces these unsuitable variables with their assigned expression.
this step guarantees not to change the value of the l break condition because of the way the i break conditions are defined in section iii b. second c aramel formats the fix according to the types of the ris and computes the line number where the fix is to be inserted using line number information from the intermediate source code representation.
when the loop contains ris of type or the fix simply inserts if l break condition break after the loop header as shown in the section ii examples.
in the special case when the loop contains only type ris the fix is if l break condition false theloop effectively executing the loop only when the l break condition is false.
this alternative fix is equivalent with the condbreak fix but is preferred by developers.
when the loop contains a type ri c aramel reverses the loop if the loop has an integer index variable that is incremented by one in the loop header similar to that in figure a otherwise caramel reports fix generation failure.
general loop reversal is difficult to do automatically but treating the above case was enough to fix the bugs we encountered in practice.
c aramel can handle more cases for loop reversal in the future.
f .
false positives false negatives and incorrect fixes caramel can have false positives false negatives and can generate incorrect fixes though in practice these issues were not significant section v .
these issues are typically created by unsoundness or incompleteness in the underlying static analysis framework.
we discuss sources of false positive in section v b. c aramel can have false negatives because due to unsoundness in the static analysis c aramel can label non ri instructions as ri and the spurious ris can make unnecessary loop computation look useful.
in practice this was not a major problem as c aramel found new bugs in widely used java and c c applications.
theoretically caramel can generate an incorrect fix for a real bug because due to incompleteness in the static analysis section v b caramel may not detect some ris.
if this happens the lbreak condition does not contain all the i break conditions and the fix causes the execution to exit the loop too early.
in practice c aramel did not generate any incorrect fix.
iv.
t woimplementations we implement two caramel tools for both java and c c programs which we call c aramel j and c aramel c respectively.
we implement c aramel j and c aramel c using wala and llvm static analysis frameworks respectively.
implementing the high level algorithms in section iii b takes into account the fact that the irs provided by wala and llvm are in ssa form.
c aramel j uses the pointer aliasing information provided by wala.
7caramel c conservatively assumes that every write to heap is an ri.
the analysis in both c aramel j and c aramel c is inter procedural.
the implementation closely follows the presentation in the previous section.
the only exception is that c aramel c currently detects only bugs that have one ri and therefore c aramel c does not perform step three in the c aramel algorithm.
we do not discuss further implementation details due to space limitations.
v. e valuation we evaluate c aramel onreal world applications from java and c c using our two c aramel implementations caramel j and c aramel c respectively.
we use popular java applications ant groovy jmeter log4j lucene pdfbox sling solr struts tika and tomcat and widely used c c desktop and server applications chromium gcc mozilla and mysql .
figure gives a short description of these applications.
we analyze the latest code versions of these applications except for lucene for which we use a slightly older version because c aramel does not support java .
of all the lucene bugs found by c aramel only two bugs are in code that no longer exists in the latest version.
in total c aramel generates bug reports.
this section first presents the new bugs found by c aramel .
it then discusses the false positives reported by c aramel the fix generation results and c aramel s running time.
we conduct the experiments on two intel i7 core gb machines running at .
ghz and .
ghz for the java and c c experiments respectively.
l app description locclasses j files c java1 ant build tool groovy dynamic language jmeter load testing tool log4j logging framework lucene text search engine pdfbox pdf framework sling web app.
framework solr search server struts web app.
framework tika content extraction tomcat web server 473c c chromium web browser gcc compiler mozilla web browser mysql database server fig.
.
the applications used in experiments a. new bugs found by caramel caramel is very effective at detecting performance bugs.
caramel finds a total of new bugs bugs in java applications and bugs c c applications.
of these bugs and in java and c c respectively have already been fixed by developers .
of the bugs not yet fixed bugs are confirmed and still under consideration by developers and bugs are still open.
bugs were not fixed because they are in deprecated code old code test code or auxiliary projects.
only bugs were not fixed because developers considered that the bugs do not have a significant performance impact.
only 1bugwas not fixed because developers considered that the fix hurts code readability.
we manually inspected all java and c c bugs reported by caramel and we find they are similar.
the only exception is that c aramel c can currently detect only bugs with one ri section iv and therefore all the c c bugs in this evaluation have one ri.
the bug examples shown so far in the paper are from java code.
figure shows an example bug from gcc which contains a type ri.
this bug was confirmed and fixed by developers.
1bool irred invalidated ... 2for each edge ae ei e src succs f if irred invalidated break fix 4if ae !
e ae dest !
exit block ptr !bitmap bitp seen ae dest index ae ags edge irreducible loop f irred invalidated true ri 8gg fig.
.
a gcc performance bug found by c aramel figure shows the detailed results for the new bugs found by c aramel .
the numbers in the table refer to the numbers of distinct buggy loops with each loop containing one or multiple ris.
out of the java bugs in figure contain more than one ri.
as explained in section ii f most of these bugs contain ris of the same type with only a few bugs containing ris of type and type as shown in the table the column headers show the type of the ris in the bug .
c aramel c can currently detect only bugs with one ri section iv and therefore no c c bug in figure contains multiple ris.
applicationtype type type type 4sumris ris ris ris ant groovy jmeter log4j lucene pdfbox sling solr struts tika tomcat chromium gcc mozilla mysql sum fig.
.
new bugs found by c aramel caramel found bugs in all applications in figure including in gcc which is highly tuned for performance and has been developed for more than two and a half decades.
indeed all the bugs that we reported to gcc have already been fixed by developers .
caramel found all four ri types in bugs.
looking at the type breakdown in figure we see type ris are more frequent than ris of other types.
we manually inspect all the bugs reported by c aramel and we find the bugs containing type ris typically appear in code performing a linear search for objects that have certain properties such as the bugs in 8figure .
this is a common operation in real world code and therefore it presents more opportunities for developers to introduce such bugs.
b. false positives caramel reports few false positives as shown in figure .
we manually inspect all false positives and find three causes.
complex analysis false positives occur when c aramel incorrectly judges in step three of its algorithm that some l break conditions are satisfiable.
such false positives can be reduced by complex analysis as described in this section but the number of such false positives does not justify the added complexity.
concurrent false positives are caused by expressions that appear to be loop invariant but that in reality can be modified by a concurrent thread.
such false positives can be reduced using static analysis or heuristics .
infrastructure false positives occur because wala may give incomplete results as described later in this section.
application complex aly.
concurrent infrastructure ant groovy jmeter log4j lucene pdfbox sling solr struts tika tomcat chromium gcc mozilla mysql sum fig.
.
false positives and their cause figure shows a complex analysis false positive from tomcat.
here c aramel detects that ri and ri are of type with i break conditions allrolesmode allrolesmode.auth only mode equals false line and allrolesmode allrolesmode.strict auth only mode equals false line respectively.
c aramel incorrectly judges in step three of its algorithm that it is possible to satisfy these two i break conditions simultaneously and caramel reports a bug.
however this conclusion is wrong because allrolesmode is an enumeration with three values and the loop is executed only when allrolesmode is not equal to the third value.
therefore when the loop executes allrolesmode can only have one of the two remaining values.
caramel could avoid this false positive by employing a complex analysis that takes into account the values enumeration variables can take and that determines the condition under which the entire loop is executed.
figure shows a concurrent false positive from lucene.
here c aramel detects atoms channel.isclosed and thread null lines as loop invariant and therefore concludes that the ri on line is of type .
however this1allrolesmode allrolesmode ... 2for inti i constraints.length i f 3securityconstraint constraint constraints 4if constraint.getallroles f if allrolesmode allrolesmode.auth only mode f log.debug granting access for ... ri g string roles request.getcontext .
ndsecurityroles if roles.length allrolesmode allrolesmode.
strict auth only mode f log.debug granting access for ... ri 11ggg fig.
.
complex analysis false positive from tomcat conclusion is wrong because channel andthread are both shared variables that can be modified by another thread in parallel with this loop s execution.
this is a typical custom synchronization that can be detected by existing tools .
1while !channel.isclosed f 2if thread null return ri 3tryfsleep retry interval gcatch exception e f ignored g 4g fig.
.
concurrent false positive from lucene the infrastructure false positives appear because to scale to large programs we instruct wala to not analyze code inside some libraries e.g.
java.awt andjavax.swing as recommended in wala s performance guidelines .
this may cause wala to give incomplete results which may cause caramel to miss some ris in step one of its algorithm.
c. automatic fix generation caramel successfully generates fixes for out of bugs.
we manually inspected all these fixes and confirmed all are correct.
for one bug in tomcat c aramel j could not generate a fix due to a limitation in wala.
specifically wala does not always provide line number information for assignment instructions.
therefore for this tomcat bug caramel could not generate a fix like the fix in figure a because c aramel did not know where to insert the break .
for the other bugs involving type ris wala did not suffer from this problem and c aramel could generate fixes.
note that loop headers are notassignment instructions.
therefore generating fixes immediately before or after loop headers which is how c aramel generates fixes for loops containing other ri types section iii e is not affected by this limitation.
we compare the fixes generated by c aramel with the fixes adopted by developers and find they are similar with one exception.
for bugs containing only one type ri condbreak fixes are different from manual fixes because developers prefer to insert a break immediately after the ri.
caramel could have easily followed developers style and generated the same fixes if wala was able to provide the line number of the ri.
however as describe above wala cannot guarantee to provide line number for assignment instructions and c aramel chooses to generate the basic condbreak fixes inserted right after the loop header.
d. overhead figure shows c aramel s running time in minutes.
columns sequential and parallel give the time for the sequential and parallel version c aramel using three threads 9respectively.
c aramel s parallel version divides the loops inngroups starts nthreads and lets each thread analyze the loops in one group.
c aramel j s parallel execution takes up to two hours for all but three applications.
most of this time is spent in wala s inter procedural pointer analysis.
we consider this running time acceptable because developers do not need to write test code like for a dynamic bug detection technique or devise complex usage scenarios like for a profiler.
furthermore after the initial run subsequent runs of caramel on the same code can focus only on code that has changed in the spirit of regression testing .
the speedup of the parallel version over the sequential version is over .5x for all but four applications which shows c aramel makes effective use of modern multi core machines.
c aramel c is much faster than c aramel j because c aramel c does not use interprocedural pointer alias analysis but instead conservatively assumes that every write to heap is an ri.
we did not consider necessary to parallelize c aramel c because the running time is small ranging from several minutes for gcc and mysql up to one and a half hours for chromium.
application sequential parallel speedup x ant .
groovy .
jmeter .
log4j .
lucene .
pdfbox .
sling .
solr .
struts .
tika .
tomcat .
chromium n a n a gcc n a n a mozilla n a n a mysql n a n a fig.
.
c aramel running time minutes vi.
d iscussion importance of bugs that have condbreak fixes the importance of a bug is ultimately decided by developers if the developers think the bug is important enough to fix it means that detecting and fixing that bug is important.
we evaluated caramel on real world applications and of the bugs found by c aramel are already fixed by the developers.
generality of bugs that have condbreak fixes these are definitely not all the bugs that have non intrusive fixes.
however these bugs are general real world applications written both in java and in c c contain such bugs.
we hope caramel s promising results will motivate future research to detect other performance bugs that have non intrusive fixes.
estimating the offered speedup caramel is a static technique and cannot easily estimate the speedup offered by the bug fix.
developers may appreciate such additional information.
however as our results show developers typically fix the bugs reported by c aramel even without knowing the exact speedup.
future work can try to estimate the speedup perhaps using techniques inspired by .vii.
r elated work improving performance and detecting performance problems several techniques identify slow code runtime bloat or increasing execution time .
siegmund et al.
and guo et al.
predict how configuration options influence performance trubiani et al.
consider uncertainty in performance modeling malik et al.
detect deviations in load tests and lu and song investigate design points in performance statistical debugging.
other techniques generate performance tests detect performance regression latent performance bugs concurrency performance problems and idle time .
unlike all these techniques c aramel makes the novel design decision to focus on performance bugs that have simple and non intrusive fixes.
specifically c aramel detects performance bugs that have condbreak fixes.
such bugs are not covered by previous work.
automatic bug fixing several recent techniques have been propose to automatically fix bugs .
genprog uses genetic programming lase sysedit and fixwizard use edits similar to previous edits.
other techniques repair bugs using approaches such as smt semantic analysis software contracts developer input etc.
unlike these techniques caramel automatically fixes performance bugs.
furthermore taking advantage of the unique properties of the bugs it detects caramel successfully fixes out of bugs.
viii.
c onclusions performance bugs affect even well tested software written by expert programmers.
in practice fixing a performance bug can have both benefits and drawbacks and developers fix a performance bug only when the benefits outweigh the drawbacks.
unfortunately the benefits and drawbacks can be difficult to assess accurately.
this paper presented c aramel a novel technique that detects and fixes performance bugs that have non intrusive fixes likely to be adopted by developers.
specifically c aramel detects performance bugs that have condbreak fixes when a condition becomes true during loop execution just break out of the loop.
we evaluated c aramel onreal world applications including popular java applications ant groovy jmeter log4j lucene pdfbox sling solr struts tika and tomcat and widely used c c applications chromium gcc mozilla and mysql .
c aramel found new performance bugs in the java applications and89 new performance bugs in the c c applications.
of these bugs developers have already fixed performance bugs in the java applications and performance bugs in the c c applications.
c aramel makes a promising first step in detecting performance bugs that have non intrusive fixes.