propagating configuration decisions with modal implication graphs sebastian krieter university of magdeburg germany harz university of applied sciences wernigerode germany sebastian.krieter ovgu.dethomas th m tu braunschweig germany t.thuem tu braunschweig.desandro schulze reimar schr ter gunter saake university of magdeburg germany sandro.schulze ovgu.de reimar.schroeter ovgu.de saake iti.cs.uni magdeburg.de abstract highly configurablesystemsencompassthousandsofinterdependent configuration options which require a non trivial configurationprocess.decisionpropagationenablesabacktracking free configuration process by computing values implied by user decisions.
however employing decision propagation for large scale systems is a time consuming task and thus can be a bottleneck in interactive configuration processes and analyses alike.
we propose modal implication graphs to improve the performance of decision propagation by precomputing intermediate values used in the process.ourevaluationresultsshowasignificantimprovementover state of the art algorithms for real world systems.
ccs concepts software and its engineering software product lines keywords software product line configuration decision propagation acm reference format sebastiankrieter thomasth m sandroschulze reimarschr ter andguntersaake.
.propagatingconfigurationdecisionswithmodalimplication graphs.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction highly configurable systems consist of thousands of configuration optionsalsoknownas features .thisenormousandeven growingamountofvariabilityposeschallengesforestablishedalgorithms used to analyze configurable systems .
in particular the variability analysis of large scalesystems including their configuration is still challenging as these tasks are computationally complex problems.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
features of a configurable system are typically connected by interdependencies that result from interactions within the system .
examples of these dependencies are features that require anotherfeature sfunctionalityandfeaturesthataremutuallyexclusive .
in order to configure a working system variant all dependenciesofaconfigurablesystemmustbeconsidered.thus every decision a user makes in a configuration i.e.
selecting a feature can imply to the inclusion or exclusion of other features.
during the configuration process it is often critical for users to immediately know the consequences of their decisions to avoid unwantedeffectslateron.forexample someusersaimtoconfigure aserversystemwithacertainoperatingsystemandtrafficmonitoring.
however their chosen monitoring application is incompatible with their operating system.
if they are unaware of such dependencies theirconfiguredsystemvariantisinvalid.asrealsystemsmaycontainthousandsofinterdependentconfigurationoptions finding contradictions within a configuration manually is not feasible.
decisionpropagation guaranteesthatusersareinformedabout all consequences of their decisions at any point during the configurationprocess.decisionpropagationdeterminesthefeatures that are implied or excluded by user decisions .
in an interactive configuration process decision propagation prevents usersfrommakingcontradictorydecisionsandreducestheamountofdecisionsauserhastomake.byemployingdecisionpropagation inourexample users whochoseaparticularmonitoringapplication or operating system can immediately notice the respectivedependency and adjust their configuration accordingly e.g.
by choosing an alternative monitoring application .
decision propagation is a computationally expensive task.
in general decisionpropagationisnp hardasitinvolvesfindingvalid assignmentsforinterdependentbooleanvariables alsoknown as thebooleansatisfiabilityproblem sat whichisnp complete .
with featureide we have implemented decision propagation ten years ago and did not face scalability problems while using smaller feature models.
however when our industry partner used featureidewithsystemshavingmorethan18 000features propagationofasingledecisiontookover20secondsonaverage summing up to hours to create one configuration without even consid ering the time required to reason about decisions and to interact with the tool.
while modern decision propagation techniques can reduce this time to a feasible level for human interaction decision propagation is still a bottleneck within automated configuration processes such as t wise sampling .
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. krieter et al.
we aim to speed up decision propagation by means of modal implication graphs.
we propose a graph assisted decision propagationalgorithmtoreducethenumberofsatisfiabilityproblemstobe solved.theideaistoprecomputeimplicitdependenciesbetween featuresandtomakethisinformationavailableduringconfiguration.inparticular wedistinguishbetweentwophasesoftheconfigurationprocess.inthe offlinephaseamodalimplicationgraphis constructedaccordingtothefeaturedependenciesofaconfigurable system which only needs to be re executed if these dependencies change.
the actual decision propagation is part of the onlinephase in whichour proposed algorithm traversesthe modal implication graph to determine the implied values.
our goal is to reduce the computational effort needed during the online phase and thus improve the response time of an interactive configuration process and analyses that derive configurations e.g.
t wise sampling .
we empiricallyevaluatetheimpactontheresponsetimebycomparing decisionpropagationwithandwithoutmodalimplicationgraphs.
in short our contributions are we introduce modal implication graphs to represent and access feature dependencies efficiently.
weproposeanalgorithmtopropagatedecisionsusingmodal implication graphs.
weprovideanopen sourceimplementationofouralgorithm as part of the featureide framework.
we provide a large scale evaluation of decision propagation including existing algorithms in terms of performance during the offline and online phase.
featuremodelsandconfigurations a featuremodel expressesthe variabilityof aconfigurable system bydefiningdistinctconfigurationoptions calledfeatures andtheir interdependencies .aconfigurationdefinesaselection of features that are used to derive a particular system variant .
a common representation for feature models is a feature diagram which represents feature dependencies in form of a tree structure .
a more general way to describe feature models are propositional formulas .
though propositional formulas lackstructuralinformation theycanexpressanyarbitraryboolean constraint between any group of features .
in this paper we use the representation of feature models as propositional formulas in conjunctive normal form cnf .
this representationcanbeappliedtoallfeaturemodelrepresentations thatusebooleanconstraints e.g.
featurediagramscanbeconverted into cnf .
an advantage of cnf is that it allows for automatedreasoningaboutfeaturesandtheirvalidconfiguration using satisfiability sat solvers .
in fig.
we depict the feature diagram of our running example theconfigurable serversystem.thefeature serveristherootofthe featuretreeandrepresentsthecommonpartofallvariantsofthe configurable system.
the features file system fs andoperating system os arebothmandatorychildrenof server whichmeans eachvariantthatcontains servermustalsocontain fsandos.by contrast the feature logging log is an optional child of server and is not required if serveris part of a variant.
the children of fs i.e.
ntfs hfs and ext are part of an or group which means feature model for configurable serversystem.
that at least one of them must be part of a variant that contains fs.
the children of os i.e.
windows win macos mac and debian deb arepartofanalternative whichmeansthatif osispartofa variant exactly one of them must be present too.
additionally the feature model contains two cross tree constraints a bi implication betweenntfsandwinandabi implicationbetween hfsandmac.
formally wedefineafeaturemodel fm f r asapairofa setoffeatures i.e.
variables fandasetofconstraints i.e.
clauses r. the set of features fcontains all features of the configurable system i.e.
f f1 ... fn withnbeingthenumberoffeatures .
fromfwe infer the set of literals l l1 l1 ... ln ln that represent the selection states of each feature where liindicates a selection and lia deselection of feature fi.
in particular we assumethat liisequalto li.wedefinethesetofconstraints r asr 2l.
each element in rrepresents a clause from the cnf.
following our definition the feature model depicted in fig.
is defined as fm server os fs log win mac deb ntfs hfs ext server win ntfs win ntfs mac hfs mac hfs os fs win mac win deb mac deb ntfs hfs ext win mac deb a configuration consists of a selection of features from a feature model.
formally we define a configuration cfor a feature modelfm f r as a set of literals in l such that c c withc c l l l l l notsubseteqlc .
if a feature fiis selected i.e.
li c or deselected i.e.
li c in a configuration we call it definedand otherwise undefined.
thus a feature can have one of three selection states selected deselected or undefined.
we call a configuration ccomplete if every feature is defined i.e.
complete c fm c f otherwise the configuration is partial.
if a configuration csatisfies all constraints in rit isvalid i.e.
valid c fm r r r c nequal otherwise it is invalid.
additionally we call a configuration satisfiable if it is valid or can be made valid by defining more features i.e.
satisfiable c fm c prime c c c prime valid c prime fm .
feature models may contain anomalies such that certain featureshavetoormustnotbeselected.afeature fiisdeadiffitis deselectedinanyvalidconfiguration i.e.
c li c valid c fm .
likewise a feature fiiscoreiff it is not deselected in any valid configuration i.e.
c li c valid c fm .
iff a feature is neither dead nor core we refer to it as variant.
the definitions of dead and core features can be generalized by taken arbitrary partial configurations into account.
given a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
propagating configuration decisions with modal implication graphs icse may june gothenburg sweden satisfiableconfiguration candafeature fiwith li li c fi isconditionallydead iff satisfiable c li fm andconditionally coreiff satisfiable c li fm .thesetofconditionallydead and core features represents all features that are not explicitly definedinasatisfiableconfiguration butareimpliedorexcluded implicitlybytheselectionstatesofotherfeatures.therefore we use the definition of conditionally dead and core features as formal basis of decision propagation.
sat based decision propagation ideally userscreateacompleteandvalidconfigurationinaninteractiveconfigurationprocessbysuccessivelyaddingnewliteralstoaninitiallyemptyset.withinteractive wemeanthatusersaregetting feedbackduringtheconfigurationprocess.withoutfurtherguidance it is possible that users select contradictory features and laterhavetobacktracktheirstepstoundooneormoreoftheirdecisions.
decision propagation can beused to avoid backtracking meaning thatusersneverhavetorevoketheirdecisionsinordertoobtain a valid configuration.given a satisfiablepartial configuration and acorrespondingfeaturemodel decisionpropagationdetermines allfeaturesthatareimplicitlydefined i.e conditionallydeadand core features and adds them to the given configuration.
for in stance considerthesatisfiablepartialconfiguration c server os fs ntfs for our running example.
only four features are explicitlydefinedbythegivenconfiguration.however giventhe featuremodel sdependenciessomeundefinedfeaturesareconditionallydeadorcore.forexample ifusersselectthefeature mac theconfigurationwillbeinvalidnomatterwhatotherfeaturesthey select.
thus they must backtrack their steps until they resolve this conflict.
in contrast if they apply decision propagation the resulting configuration c prime server os fs ntfs win mac deb hfs includes all conditionally dead and core features.
a sat based algorithm for decision propagation reduces the problemtomultipleinstancesofthesatproblemandsolvingthese usingoptimizedsatsolvers.inparticular thealgorithmtestsfor eachundefinedfeature fiwhetherthegivenpartialconfiguration c is still satisfiable if the fiis selected i.e.
satisfiable c li fm or deselected i.e.
satisfiable c li fm .
inalg.
wedepictthegeneralprocessofsat baseddecision propagation in pseudo code.
the algorithm takes as input a feature model fmand a satisfiable configuration ccurrent which includesthelatestdecisionoftheuser.itreturnsaconfiguration cnew thatcontainsallfeaturesthatareconditionallydeadorcore.the main procedure decisionpropagation initializes cnewwith the assignmentfrom ccurrent cf.line2 andcallsbothsub procedures getunknownandtesttodeterminethestateofeachundefined feature.getunknownreturnstheset lunknown thatcontainsall literalsthat mustbecheckedusingthe sat solver cf.
line3 .
testdetermines for each literal in lunknown whether it is conditionally deadorcore cf.line4 .both cnewandlunknown areupdated by test.
finally the updated cnewis returned.
we show a straight forward approach to implement both subprocedures getunknown and test in line of alg.
.
getunknown initializes lunknown by adding two literals for each currently undefined feature cf.
line .
test investigates a single literalltestfromlunknown by adding it to cnewand querying thealgorithm na ve sat based testing algorithm require fm f r feature model ccurrent current configuration return cnew new configuration global fm lunknown cnew procedure decisionpropagation cnew ccurrent lunknown getunknown for allltest lunknown do test ltest end for returncnew end procedure procedure getunknown return l l ccurrent l l end procedure procedure test ltest csolution sat fm cnew ltest ifcsolution then cnew cnew ltest end if end procedure sat solver cf.
line .
if there is no satisfiable configuration corresponding to cnew ltest every configuration that contains all literals from cnewmust also contain the complement of ltest i.e.
ltest .
thus the feature corresponding to ltestis either conditionally core i.e.
ltestis negative or dead i.e.
ltestis positive .
consequently ltestis added to cnew cf.
line .
fromalg.
wecanseethatforasingleexecutionofdecision propagationthena vealgorithmhastocallthesatsolvertwice foreachundefinedfeature.modernsatsolversalreadyapplytechniques such as incremental solving which aims to reduce the computing effort for repetitive sat queries by learning and reusing clauses that are implicitly implied by the original formula .
however evenwhenemployingmodernsatsolvingtechniques the na ve algorithm does not scale to large configurable systems.
janotaproposed amoreefficient waytodetermine whethera featureisconditionallydeadorcoregivenapartialconfiguration .
his advanced sat based algorithm employs the same concept but tries to reduce the number of tested literals.
we show the relevant codechangesinpseudocodeinalg.
.theconfigurationsfound by the sat solver are used to exclude literals from lunknown cf.
line .
with this algorithm our evaluation machine only required several minutes for configuring a system with more than features.
janota s algorithm also uses a special selection strategyforthesatsolver whichdeterminestheorderinwhich the solver considers literals to find asolution .
for brevity we exclude this selection strategy from the pseudo code.
graph assisted decision propagation we aim to enhance sat based decision propagation by reducing the number of necessary queries to the sat solver.
for this we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. krieter et al.
algorithm advanced sat based testing algorithm procedure getunknown csolution sat fm cnew return l l ccurrent l l csolution end procedure procedure test ltest csolution sat fm cnew ltest ifcsolution then cnew cnew ltest else lunknown lunknown csolution end if end procedure proposemodal implication graphs migs which represent certain relationships between features in the feature model.
in our approach we differentiate between an offline phase in which we compute a modal implication graph for a particular feature model andanonlinephase inwhichweuseitfordecisionpropagation.
theofflinephaseonlyneedstobeexecutedwhenthefeaturemodel is modified whereas the online phase is part of every configuration process.
our approach is based on two observations we made regarding decision propagation for large scale feature models in most cases the definition of a feature only affects a small set of other features.
if other features are affected it often results from binary requiresandexcludesconstraints.
thus weintroducemodalimplicationgraphsinsection4.1to identify the set of affected features and determine some of their selection states in the configuration.
in section .
we present an algorithm to derive a modal implication graph and describe the graph susageforgraph assisteddecisionpropagationinsection4.
.
.
modal implication graphs animplicationgraphisadirectedgraphthatdescribesapropositional formula consisting of a conjunction of implications between single literals i.e.
binary relations .
each node represents a literal of a variable and a directed edge from one node to another representsabinaryrelation.afeaturemodel sbinarydependencies can be transformed into an implication graph by representing each feature by a positive and a negative node and each requires and excludes constraint by an edge .
analogoustoanimplicationgraph themodalimplicationgraph forafeaturemodelconsistsofnodesthatrepresenttheliteralsof eachfeatureanddirectededgesthatrepresenttherelationsbetween these literals.
we extend implication graphs by introducing an additional edge type to express n ary relations such as or groups with three or more features.
wedifferentiatebetweentwotypesofedges weakandstrong.a strong edge indicates a binary relation e.g.
requires and excludes between two features.
if the literal of the source node is element of aconfiguration thenalsotheliteralofthedestinationnodemust be element of the configuration.
in contrast a weak edge indicates thattwoliteralsare partofann aryconstraint whichinvolvesat least one other literal.
for a partial configuration these weak edgescould become strong edges due to the selection and deselection of other features.
amodalimplicationgraphforourrunningexamplecanbeseen infig.
.
duetothealternativegroup thereisastrongedge from macto win which implies that if feature macis selected feature winmust be deselected i.e.
mac c win c .
in addition there is a weak edge from wintomac also resulting from the alternativegroup whichmeansthatundercertainconditions i.e.
iffeaturedebisdeselected macmustbeselectedif winisdeselected.
in other words this edge will become strong if debis deselected.
formally we define a modal implication graph g l s w to be a triple consisting of a set of nodes l which is equal to the set of literals a set of strong edges s and a set of weak edges w such that s w lstart lend lstart lend l lstart nequallend ands w .
as implications are transitive we are interested notonlyinedges whichdirectlyconnecttwoliterals butalsoin pathswithinagraph.analogoustoedgetypes wealsodifferentiate betweenstrongandweak paths.
we call a path from one node to anotherstrong ifitconsistssolelyofstrongedgesand weak ifit containsatleastoneweakedge.ifthereexistsatleastonestrong pathfromanode lstoanode ltwedenotethiswith ls trianglerightsldgltand callltstronglyconnected tols.complementarytothis ifthereexist onlyweakpathsfrom lttols wedenotethiswith ls gltandcall ltweaklyconnected tols.withinthecontextofamodalimplication graphg we define trianglerightsldgand gas trianglerightsld ls lt l2 ls lt s lm l ls trianglerightsldlm trianglerightsldlt ls lt l2 ls negationslash trianglerightsldlt ls lt w lm l ls lm lt ls lm trianglerightsldlt ls trianglerightsldlm lt stronglyconnectedliteralsaredirectlydependent whileweakly connected literals also depend on other literals.
moreover nonconnected literals are completely independent of each other.
thus wecanusethemodalimplicationgraphtounderstandtherelationship between any two features by looking at the paths between their respective nodes.
for instance in the modal implication graph from the server system ntfsisstronglyconnectedto mac via win .hence if macisselectedinasatisfiableconfiguration ntfsmustbedeselected.
in contrast debis weakly connected to ntfs via win .
thus ifntfsis deselected in a satisfiable configuration debmust be selected for certain conditions which in this example is thedeselection of mac.
finally no node is connected to log which means that it is independent of all other literals.
.
deriving modal implication graphs offline phase before using a modal implication graph in decision propagation i.e.
onlinephase weneedtoderiveitfromafeaturemodel i.e.
offline phase .
if the corresponding model evolves the graph must be recreated before the next decision propagation.
a modal implication graph is constructed by creatingand analyzing a feature model s cnf.
the cnf clauses can be categorized by their number of literals.
clauses containing just one literal i.e.
unit clauses can beignored astheydescribenorelationshipbetweenfeatures but simply make the respective features core or dead.
clauses with exactly two literals i.e.
two literal clauses are used to derive strong authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
propagating configuration decisions with modal implication graphs icse may june gothenburg sweden ntfs hfs mac mac ext deb hfsdeb win win ntfsext log log figure modal implication graph for serversystem.
edges.
weak edges are derived from the remaining clauses which containmorethantwoliterals i.e.
n literalclauses .wepropose the following four steps to derive a graph with minimal number of nodes and edges.
step adding nodes.
in the first step we initialize the graph byaddingtwoliteralnodesforeachvariantfeature.asdeadand corefeaturesarenotrelevantfordecisionpropagation weonlyadd variant features to reduce the graph s memory space consumption andsaveunnecessarytraversalduringtheonlinephase.wecompute the set of variant features by running alg.
with an empty configuration.
in our running example the features server os and fsare core and thus excluded from the graph cf.
fig.
.
step adding edges.
in the second step we add edges according to the following pattern.
for each two literal clause we addtwostrongedgestothegraph aseachtwo literalclausecan be transformed into two equivalent implications.
for instance the clause win maccan be transformed into win mac andmac win.
thus we add two strong edges from winto macand from macto win.
likewise an n literal clause can be transformed into nequivalent implications.
in this case we add a weak edge for each pairwise combination of literals i.e.
in totaln n .
for example the clause ntfs hfs extcan be transformedinto ntfs hfs ext hfs ntfs ext and ext ntfs hfs resultinginsixweakedges e.g.
from ntfstohfsand toext .
beforetransformingaclause wetestitforobviousredundancies.
inparticular weremoveliteralsthatareduplicatesorthatcannever be true i.e.
core and dead features and remove clauses that are tautologies.forinstance inourexampletheclause win os isatautology as osisacorefeature.likewise wecouldremove osfrom os win mac deb since it can never be true.
step3 a ddingimplicitstrongedges.
theinitiallyconstructed graph can contain implicit strong relationships between literalsthat are only weakly connected .
for instance in the graph of our running example debis weakly connected to ext cf.
fig.
.however duetothefeaturemodel sor groupandcross tree constraints extdirectly implies deband thus there could be a strong edge from extto deb.
to find implicit strong edges we employ a depth first search that investigates all pairs of weakly connected nodes.
we start thesearchwithanarbitrarynode aandconsidereachnode bthatis weaklyconnectedtoit.usingthesatsolver wecheck whether aimpliesb.
in that case we add a strong edge from atoband recursivelycontinuethesearchwith basnewstartingnode.due to this depth first search we are able to deduce strong edges by transitivity without querying the sat solver e.g.
from a trianglerightsldband b trianglerightsldc we can deduce that a trianglerightsldc .
we repeat the search with different starting literals until we checked every pair of weakly connected nodes.
step4 removingredundantweakedges.
redundantweakedges areweakedgesthatcanberemovedfromagraphwithoutchanging its reachability.
they can occur due to the inclusion of implicitstrong edges in step three and redundant constraint in the cnf.
the removal of redundantedges saves memory and decreases the number of weak paths that must be traversed in the online phase.
toremoveredundantweakedges weconsidertheircorrespondingclausesinthecnf.webeginwithorderingthelistofallclausesbytheirnumberofliteralsindescendingorder aslargerclausesaremorelikelytoberedundant.foreachn literalclause wequerythe satsolvertotestwhethertheclauseisredundantregardingthe current list of clauses and remove it from the list if it is redundant.
forexample wewouldremovetheclause ntfs hfs ext if there would be an additional clause ntfs hfs as this clause subsumes the former.
if a weak edge is no longer represented by any clause in the cnf we remove it from the graph.
alternative construction process.
step3and4areoptionaland canbeconsideredatrade offbetweenofflineandonlinetime.as step is the most time consuming one we evaluate its impactin our evaluation regarding both offline and online time.
when step three was applied during the construction process we call theresulting modal implication graph complete because it contains all possible strong edges .
in contrast if the step was skipped we call the resulting graph incomplete.
.
using modal implication graphs for decision propagation online phase weemploymodalimplicationgraphsinourgraph assisteddecision propagationalgorithmtoreducethenumberofsatqueriesduring theonlinephase.thealgorithmisbasedonalg.
cf.section3 but makes two major changes.
first it traverses strong paths forknown literals to find implied literals without querying the satsolver.
second it only tests literals that can be reached via weak paths from the starting literal which excludes features unaffected by a given decision.
inalg.
wepresenttherelevantdifferencesoveralg.
.inadditiontoafeaturemodel fmandthecurrentconfiguration ccurrent the graph assisted algorithm requires the modal implication graph gand the most recent decision in form of a literal lnew.
the procedure getunknown cf.
line traverses the modal implicationgraphtofindpotentiallyimpliedliterals.first thealgorithm checks whether there are any weak edges in the graph that can be transformed into strong edges according to the current configuration cf.line2 .second theoutgoingstrongpathsfrom lnewaretraversed cf.line3 .eachliteralthatcanbereached viaastrongpathisaddedto cnew i.e.
withoutanysatqueries .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. krieter et al.
algorithm graph assisted testing algorithm require fm f r feature model g l s w modal implication graph lnew literal of most recent decision return cnew new configuration global fm g lnew cnew lunknown procedure getunknown g prime updategraph g cnew cnew l l lnew trianglerightsldg primel lunknown l l l l cnew lnew g primel iflunknown nequal then lunknown lunknown sat fm cnew end if returnlunknown end procedure procedure test ltest csolution sat fm cnew ltest ifcsolution then g prime updategraph g lstron l l ltest trianglerightsldg primel cnew cnew ltest lstron lunknown lunknown l l lstron else lunknown lunknown csolution end if end procedure procedure updategraph gold r prime r l l cnew r r r cnew returnupdateedges gold r prime end procedure third alloutgoingweakpathsaretraversedfor lnew.allliterals that belong to undefined features and can be reached via a weak path are added to lunkown cf.
line .
the procedure test is similar to the procedure of the advanced sat based algorithm.
in addition test utilizes the modal implicationgraphwheneveranimpliedliteralisfoundbythesatsolver cf.
line .
for each found literal the graph s weak edges areupdatedagainandtheoutgoingstrongpathsaretraversed cf.
line .
all reachable literals are added to cnewand removed fromlunknown cf.
line .
evaluation with modal implication graphs migs we aim to speed up the onlinephaseofdecisionpropagationby in the offline phase.
therefore we evaluate the performance of different decision propagation algorithms.
we compare the offline andonlineexecutiontimeofgraph assisteddecisionpropagation usingmodalimplicationgraphs cf.section4 againstsat based decisionpropagation cf.section3 .indetail weaimtoanswerthe following research questions rq1doesthechoiceofadecisionpropagationalgorithmaffect the execution time of the offlinephase?
rq2doesthechoiceofadecisionpropagationalgorithmaffect the execution time of the onlinephase?rq3givenanumberofconfigurationprocesses i.e.
onlinephases which decision propagation algorithm is superior to othersintermsofoverallexecutiontimeandmemoryconsumption?
.
experimental setup to answer our research questions we perform two experiments with one factor and four treatments.
in summary we compare four different algorithms for decision propagation using real world systems.inadditiontoexecutiontime wemeasurethememoryconsumptionofthe derivedmodalimplicationgraphforeach feature model.inthefollowing wedescribewhichconfigurablesystems anddecision propagationalgorithmsweconsider howwedesigned the individual experiments and what values we measure during a single experiment.
all computations during the evaluation were run on a notebook with the following specifications cpu intel xeone3 1505mv5 .
ghz ram gb os windows7 java version .
.0 121 bit .
memory consumption was measured using the java instrumentation package.
configurable systems subjects .
in our evaluation we use the featuremodelsof120real worldconfigurablesystemswithvarying sizesandcomplexity whichhavebeenusedinpriorstudies .
themajorityofthesefeaturemodels containbetween1 and1 397features.ofthese117models 107comprisebetween2 968and4 138cross treeconstraints whileonehas14 295andtheother nine have between and cross tree constraints.
the remainingthreemodelscontainanevenhighernumberoffeatures.
thefeaturemodelsfromthesystemsautomotive01 automotive02 and linux contain and features and and constraints respectively.
decision propagation algorithms treatments .
in our evaluation we compare the following algorithms na ve sat based nsat advanced sat based asat graph assisted using an incomplete mig imig graph assisted using a complete mig cmig toensureafaircomparisonofallalgorithms weemployawhiteboxevaluation whereeachalgorithmusesthesamebaseimplementationas describedinsection3.
weprovide allalgorithmsaspart of the open source framework featureide2our implementation uses java and the default sat solver of sat4j version .
.
.
with sat4j we are able to employ incremental sat solving.
for each feature model we create a separate solver which is able todeduce new clauses while solving a query and later reuse these clauses in subsequent queries.
eachalgorithmperformscertaintasksduringitsofflinephase.
bothsat basedalgorithms cf.section3 determinethecoreand dead features i.e.
initial decision propagation .
in addition to computingcoreanddeadfeatures bothgraph assistedalgorithms cf.
section4 deriveamodalimplicationgraph.whilecmigderives a complete graph i.e.
containing all explicit and implicit strongedges imig derives an incomplete graph cf.
section .
.
the modalimplicationgraphisimplementedasanadjacencylist due authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
propagating configuration decisions with modal implication graphs icse may june gothenburg sweden to reasons of memory efficiency.
it is stored to and loaded from persistent memory using java s serialization mechanism.
duringtheironlinephase allalgorithmscalculateimpliedand excludedfeatures asdescribed insection3 and4.
whilethe satbasedalgorithmssolelyquerythesatsolver thegraph assisted algorithmsadditionallytraversethroughamodalimplicationgraph to avoid sat queries.
offlinephase experiment1 .
toanswerrq1 wemeasuretheexecutiontimeforeachalgorithm sofflinephase.asstatedabove the offline phase of each algorithm consists of all tasks after receiving thecnfofafeaturemodelandbeforestartingtheactualconfiguration process.
as the process of creating a cnf is independent from the chosen algorithm we do not include it as part of the offline phase but use the cnf as initial parameter for each algorithm.
to avoid computational bias and calculate a representable mean value for each feature model and algorithm we repeat the experiment times.furthermore we compensate forthe warm up effectof the java virtual machine jvm by performing an initial execution without any measurement.
online phase experiment .
to answer rq2 we measure the execution time for each algorithm s online phase.
we simulate a configuration process by using random decisions as we cannotknow which decisions users would make in their configurationsand want to avoid relying on false assumptions.
the simulated configuration process consists of the following steps start with an empty configuration randomly choose an undefined feature randomly define the feature i.e.
select or deselect apply decision propagation repeat until all features are defined wemeasuretheexecutiontimeforeachindividualapplicationof decisionpropagation.intheexperiment weneglectthetimethatauserwouldneedtomakeconfigurationdecisions i.e.
reasoningand input as these values highly depend on the user and thus would bias our results.
furthermore this is not an issue for automated configuration processes such as t wise sampling .
weuseapseudorandomgenerator whichhastheadvantagethat we can fix the random seed for each iteration of the experiment.
therefore we ensure that all algorithms get the same series of random decision and thus that the resulting configurations areequal.
to get meaningful results we repeat the experiment times with different random seeds.
analogous to experiment we compensate for the jvm warm up effect.
hypotheses.
in order to be able to draw meaningful conclusions we formulate the following null hypotheses from our research question rq1 and rq2 respectively hrq1 0the execution time of the offline phase is the same for all investigated decision propagation algorithms.
hrq2 0the execution time of the online phase is the same for all investigated decision propagation algorithms.
weconducttwoexperimentswithonefactor i.e executiontime and four treatments i.e algorithms using the same subjects i.e feature models .
hence we test our hypotheses using a paired wilcoxon mann whitneytest.wechoose95 asourconfidenceinterval.ourexpectationisthattheofflinephaseofbothsat basedalgorithmsisfasterthantheofflinephaseofthegraph assistedalgorithms but that they perform worse during the online phase.
this isduetothedifferenceineffortofthealgorithmsduringtheoffline phase.nsatandasatdotheleastamountofprecomputations whileimigadditionallyderivesanincompletemodalimplication graph and cmig even derives a complete modal implication graph.
thismeansthat duringtheonlinephase cmigcanaccessmore information than imig while imig has more information than asat and nsat.
hence we expect that for the offline phase nsat andasatarefasterthanimig whichisagainfasterthancmig.
for the online phase we expect that the fastest algorithm is cmig followed by imig asat and nsat in that order.
.
results and interpretations in the following we present and analyze our evaluation results and answer our research questions.
in table1 we give an excerpt oftheaggregatedevaluationresultsforaselectionofoursubject systems.
for brevity we do not list the results from all featuremodels.
3for each feature model we list its number of features and constraints memory consumption of the modal implication graph andaggregatedmeasurementsofourexperiments.weshow the execution time that each algorithm needs during its offlinephase.
additionally we show the execution time of the onlinephase when and of variant features were defined.
the number of defined features includes the features defined by decisionpropagation.all shownresultsrepresentthemean value over the conducted experiments.
we also show the mean of all values over all feature models and conducted experiments at the bottomofthetable.however weomittheresultsofnsat asits offline phase is equal to asat and its online phase execution time isordersofmagnitudelargerthanallotheralgorithms e.g.
over 100timeslargercomparedtoasat .inthefollowing wediscuss the results in more detail.
offlinephase experiment1 .
wedisplaytheresultsofourfirst experimentinfig.3inthefirstdiagramformostfeaturemodels.
we excluded the four largest feature models i.e.
automotive01 automotive02 freebsd and linux from the diagram as they are visually hard to compare to the other models due to their size.
nevertheless we state the results for these models in table .
each data point represents the offline time of a particular algorithmand feature model.
on the y axis we show the execution timein milliseconds and on the x axis the number of features in the feature model.
ourdata reveals that the execution times fromthe different algorithms differ in orders of magnitude.
for instance forthefeaturemodelautomotive01 asatrequired67 ms imig ms and cmig ms for the offline phase.
in terms of memoryconsumption theadditionalmemoryrequiredtostorea modalimplicationforimigandcmigliesbetween0.
mbforthe feature model freebsd and .
mb for automotive02 with a mean value of .
mb over all feature models.
intable2 weshowthep valuesofthewilcoxon mann whitney test for all pairwise combinations of algorithms.
in all cases we receivedap valueoflessthan10 15and thus wecanrejectournull 3a complete table can be found here blob master icse2018 evaluation execution times.pdf authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. krieter et al.
table1 offlineandonlinetimeofevaluatedalgorithmsforaselectionoffeaturemodels meanvalueover200experiments .
feature model features clauses mig mem offline time in s summationtext.1online time in s for relative number of defined features ory byte asat imig cmig asat imig cmig asat imig cmig asat imig cmig freebsd .
.
.
.
.
.
.
.
.
.
.
.
.
.
automotive01 .
.
.
.
.
.
.
.
.
.
.
.74linux .
.
.
.
.
.
.
.
.
.
.
.
.
.
.66automotive02 .
.
.
.
.
.
.
.
.
.
.
.
all models .
.
.
.
.
.
.
.
.
.
.
.
figure execution time of offline online and combined offline and online phase of all algorithms for multiple featuremodels sortedbysize .break evenpoint oftwoalgorithmsindicatesthenumberofonlinephasesonealgorithm soverall execution time becomes faster than another e.g.
cmig is faster than asat for two or more online phases .
table pairwise comparison of algorithms.
attribute asat imig asat cmig imig cmig p value hrq1 p value hrq2 hypothesis hrq1 .
for all feature models asat needs significantly lesstimeforitsofflinephasethanthetwograph assistedalgorithms.
likewise imig needs significantly less time than cmig.
therefore we can answer rq1 yes there is a significant difference in the time required for the offline phase of the differentalgorithms.
these results are expected as the algorithms offline phases differ in the amount of precomputations.
while asat only detectscoreanddeadfeatures imighastoderiveanincomplete modalimplicationgraphinaddition.moreover cmigdoesallof theaboveandalsocomputesimplicitstrongedgeswithinthemodal implication graph to make it complete.
online phase experiment .
we depict the aggregated results of our second experiment in fig.
in the second diagram for most feature models.
we provide the results for the remaining featuremodels in table .
analogous to the diagram for the offline time each data point represents the mean execution time over experimentsforaparticularalgorithmtodefine100 ofthevariant featuresofonefeaturemodel.onthey axis weshowtheexecution timeinmillisecondsand onthex axis thenumberoffeaturesin the feature model.
from our data we can see that for every feature modelasatrequiresmoreonlinetimethanbothgraph assistedal gorithms.incontrast thereisnobigdifferenceinthetimerequired by both graph assisted algorithms.
nevertheless using cmig indicates slight improvements over imig.
to illustrate the results of the second experiment in more detail we depict the execution time for each individual decision propagation for the feature model of linux in fig.
.
each data pointoriginates from oneof the conducted experiments and represent the execution time of decision propagation by a particular algorithm.onthey axis wedepictthetimeinmillisecondsand on the x axis the number of defined variant features beforedecision propagationwasexecuted.theregressioncurvesindicatethemean execution time over experiments.
for asat the data pointsforaparticularx valuespreadwidearoundtheregressioncurve.however most data points lie above the data points from cmig andimig.whilecmigshowsslightlybetterresultsthanimig thedifferencebetweenbothismostlyintherangeofafewmilliseconds.
it is also notable that for both graph assisted algorithms there are many data points that are close to zero.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
propagating configuration decisions with modal implication graphs icse may june gothenburg sweden figure execution time during online phase with asat imig and cmig for the feature model of linux.
we list the results from the wilcoxon mann whitney test for experiment 2in table .
again wecan reject our nullhypothesis hrq2 0aswereceivedap valueoflessthan10 15foreachalgorithm combination.asatneedssignificantlymoretimethanimigand cmig whereascmigisfasterthanimigtoasignificant butrather small degree.
therefore wecananswerrq2 yes thereisasignificantdifferenceintheexecutiontimeofdecisionpropagationforthedifferent algorithms.
these results correspond to our expectations as allalgorithms can access a different amount of information during theironlinephase.cmigtraversesacompletemodalimplication graph whileimigusesagraphthatmightlackssomestrongedges.
bycontrast asatdoesnotuseanyadditionaldatastructureand hastoinferallneededfeaturedependencieson the fly.thelowperformanceincrease ofcmig overimig isdueto thesmall number of implicit strong edges that can be derived in the offline phase.
comparisonofofflineandonlinephase.
asthenumberofconfigurationprocessesandchangestothefeaturemodelmightdifferfor eachconfigurablesystem weareinterestedinthecombinedcost ofofflineandonlinephase.forabettercomparisonofexecutiontimes for offline and online phase we present the diagrams for bothresultssidebysideinfig.3withbothdiagramssharingthe same y axis.
moreover we visualize the combined cost of offlineand online phase in the third diagram of fig.
.
in this diagram weaddthetimeneededfortheofflinephasetothetimerequired to execute the online phase once.
again we depict the results of thealgorithmsforallbutthelargestfeaturemodels.wevisualize the number of online phases necessary for each algorithm to break even with the other algorithms in the fourth diagram of fig.
.
thevisualizationclearlyindicatesthatimigneedslesstimethan asat even for just one iteration of the online phase.
regarding cmig we see that its higher offline time compared to asat is amortizedaftertwoiterationsoftheonlinephase.inourevaluation we experienced only two exceptions of this observation for the feature models freebsd three iterations and automotive02 five iterations cf.
table1 .asthe onlinetimefor bothgraph assistedapproaches only differs slightly cmig needs many more online phasesinordertoamortizeitsinitialcostswhencomparedtoimig.
indetail wemeasuredbetween112and801necessaryiterations with a mean value of over all feature models.
considering the observations we made from the evaluation results wecananswerrq3 inmostcasesimigissuperiortoboth asat and cmig in terms of overall execution time.
only when consideringanincompleteonlinephase i.e.
creatingonlyapartial configuration asatoutperformsimigduetoitsefficientoffline phase.
on the other hand cmig outperforms imig for a high number of online phases i.e.
in our experiments .
thus in general imig seems to be preferable over the other three algorithms as it provides a good trade off between the time required for offline andonlinephase.asatandcmigarepreferableoverotheralgorithms only in some extreme cases.
when the feature model evolves more frequentlythantheconfigurations asatcanbesuperior.incase that configurations are updated frequently while the feature model does not evolve for a longer period of time cmig can be superior as its online phase requires less time than asat and imig.
regardingmemoryconsumption inourexperimentswefoundthatthe memory required tostore a modal implication graph wasat maximum5.1mb whichisrelativelysmallcomparedtotheavailable main memory on modern hardware.
thus the additional memory consumption can be neglected for most applications.
.
threats to validity internal.a number of issues might threaten the internal validity ofourresults.first bugsintheimplementationmightcausewrong results.wemitigatethisissuebydeployingunitteststotesteach algorithm individually.
furthermore we compared the resulting configurations of all algorithms and found no difference during all conducted experiments.
additionally we use matured open source tools such as sat4j to further reduce the possibility of bugs.
second theresultscouldbebiasedinfavorofourproposedalgorithms.thisisduetothefact thatweimplementedallevaluatedalgorithmsbyourselves.however weusethesamebaseimplementation for all algorithms and for each algorithm we only do the necessary modifications as described in section and section .
third random input data might lead to unrepresentative results.
to simulate a configuration process we used a series of random decisions whichmightnotcorrespondtoareal worldconfiguration.
however a randomized approach gave us the capability toefficiently do multiple iterations with distinct random seeds and thus gather more data.
to avoid random bias we evaluate each setting in iterations.
external.
therearesomethreatsthatmayaffectthegeneralizability of our results.
first our results might not transfer to real configuration applications.
our simulated configuration process is likelytobedifferentfromamanualconfigurationbyauserwithdomain knowledge.
in addition starting with a partial configurations may mitigate the problem of slow initial decision propagations cf.
fig.
.
however a manual configuration process strongly depends on the particular user which could bias the results as well.
second thetestedfeaturemodelsmightnotberepresentativeof featuremodelsusedinpractice.tomitigatethisissue wetested120 real worldfeaturemodelswithavaryingnumberoffeaturesand authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. krieter et al.
constraintsthathavebeenusedinpriorstudies .furthermore weincludedthelargestreal worldfeaturemodelsreferenced in literature at the moment.
third in our implementation we only employ sat4j as sat solver.however weusesat4jasablack box suchthatothersolvers e.g.
sat csp bdd mdd couldalsobeplugged in.asweshift sat calls from the online to the offline phase faster solvers should improve both online and offline computation.
related work interactiveconfiguration.
manytoolsalreadyprovidedecision propagation for an interactive configuration process.
among those tools are gears guidsl s2t2 configurator s.p.l.o.t.
andvariamos .ourworkisbasedonsat based decisionpropagationasproposedbyjanota .othersproposedto propagatedecisionsusingbinarydecisiondiagrams bdds and constraint satisfaction problem csp solvers .
bdds are somewhatsimilartoourmodalimplicationgraphs asbothavoid someeffortduringdecisionpropagation i.e.
onlinephase bymore effortfortheircreation i.e.
offlinephase .aproblemwithbdds is that they typically do not scale for feature models larger than 000features.forinstance thereisnobddforlinuxsofar.while csp solvers can handle constraints beyond boolean formulas as needed for extended feature models they often reduce inputs tosatisfiabilityproblemsinternally.hence wehavelittlehopethat theycouldimproveperformancecomparedtoourgraph assisted algorithm.
similar to csp satisfiability modulo theories smt extend the boolean sat problem to first order logic .
as far as weknow smtsolvers suchasz3 havenotbeenappliedto decisionpropagationyet.however asourapproachisindependent from the actual solver but instead tries to reduce the number of requiredsatqueries weassumethatapproachesthatemploysmt solvers can also benefit from model implication graphs.
in our evaluation we use configurable systems such as linux and ecos that provide their own feature modeling language and correspondingconfigurationtools i.e.
kconfig andcdl .
although theselanguagesallowformulti valuedlogic theycan be translated into boolean feature models .
the kconfig languagedifferentiatesbetween selectanddependsconstraints.in termsofmodalimplicationgraphs selectcanbeconsideredastrong edge asitdirectlyimpliesotherfeatures whiledependscanbeseenasasetofweakedges.incontrast modalimplicationgraphsdonot rely on manual specification of select and depends constraints but cancomputetherespectiverelationships whichavoidsmistakes by users and represents feature dependencies more efficiently.
anothertechniquetoavoidcontradictionswithinaconfiguration iserror resolution which automatically detects and tries to resolve conflicts .configurationtoolsthatsupportthiskindof techniqueare forexample pure variants andfama .
contrarytodecisionpropagation errorresolutioncanbeapplied at any point during or after the configuration process.
to support error resolution modalimplication graphscan becombinedwith cycle detection algorithms.
decreasing the configuration time can also be achieved by considering only a subset of system s configuration options.
users mightbeinterestedincertainpartialconfigurationsoronlyneedtoconfigureasub treeofthefeaturemodel.anexampleofthisare staged configurations and the configuration of decomposed or sliced feature models .
while in our evaluation we only focusedoncompleteconfiguration modalimplicationgraphscould alsospeed uppartialconfigurationprocesses cf.fig.
.
aninteractiveconfigurationprocessisnotlimitedtoensurevalid configurations but can also provide other useful information.
for instance users can be supported by recommender systems or visualfeedback .alltechniquesthatconsiderfeaturedependenciescanpotentially benefitfrommodalimplication graphs as they provide a fast and complete access to binary feature relations.
automated configuration.
besides manual configuration by a user configurations can also be created automatically by certainalgorithms.
a use case for automated configuration is product based testing which requires the generation of a representative sampleofconfigurations .anotherusecaseistheproduct generationviaoptimizationofnon functionalproperties .
similar to manual configuration decision propagationcan beusedinanautomatedconfigurationprocesstoquerythefeature model and derive valid configurations.
thus modal implication graphs could also be applied in automated configuration processes.
product line analyses.
there exist many analyses for configurable systems that reason about feature model dependencies .forinstance inourwork weusetheanalysis of finding core and dead features.
similar to decision propagation mostanalysescanbeimplementedusingsatsolvers .therefore modal implications graphs could be used to speed up those analyses as well.
conclusion and future work decision propagation is a useful method for an interactive configurationprocess.itpreventsusersfromdefiningcontradictions during the configuration process.
however current implementations do not scale well for large scale configurable systems.
in this work we introduced modal implication graphs an extension of implication graphs for feature models to support the application of decision propagation.
we presented the concept of modal implicationgraphs theirderivationfromfeaturemodels andhowtheyare employed during decision propagation.
based on our open source implementation we evaluated the benefits of using graph assisted decision propagation for a complete configuration process and reasoned about its trade offs.
compared to a sat based approach usingmodalimplicationgraphscansignificantlyspeedupdecision propagation and thus make its application feasible for large scale configurable systems.
in future work we will apply modal implication graphs to applications beyond decision propagation.
we are convinced that many existing approaches could profit from modal implication graphs.
this includes analyses such as atomic sets visualization of feature model dependencies and product based testing.