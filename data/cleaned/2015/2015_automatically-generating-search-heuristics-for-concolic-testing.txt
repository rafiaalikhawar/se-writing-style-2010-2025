automatically generating search heuristics for concolic testing sooyoung cha korea university sooyoungcha korea.ac.krseongjoon hong korea university seongjoon korea.ac.krjunhee lee korea university junhee lee korea.ac.krhakjoo oh korea university hakjoo oh korea.ac.kr abstract we present a technique to automatically generate search heuristics forconcolictesting.akeychallengeinconcolictestingishowto effectivelyexplore theprogram s executionpathsto achievehigh code coverage in a limited time budget.
concolic testing employs a searchheuristictoaddressthischallenge whichfavorsexploring particular types of paths that are most likely to maximize the final coverage.
however manually designing a good search heuristic isnontrivialandtypicallyendsupwithsuboptimalandunstable outcomes.thegoalofthispaperistoovercomethisshortcomingof concolic testing by automatically generating search heuristics.
we defineaclassofsearchheuristics namelyaparameterizedheuristic and present an algorithm that efficiently finds an optimal heuristic foreachsubjectprogram.experimentalresultswithopen sourcec programsshowthatourtechniquesuccessfullygeneratessearch heuristicsthatsignificantlyoutperformexistingmanually crafted heuristics in terms of branch coverage and bug finding.
ccs concepts software and its engineering software testing and debugging acm reference format sooyoungcha seongjoonhong junheelee andhakjoooh.
.automatically generating search heuristics for concolic testing.
in icse icse 40th international conference on software engineering may 27june gothenburg sweden.
acm new york ny usa pages.
introduction concolic testing has emerged as an effective softwaretesting method with diverse applications .
the idea of concolic testing is to symbolically execute a program alongside the concrete execution where the main job of the symbolic execution is to collect path conditions.
initially the program is executed witharandominput.aftertheprogramfinishes abranchofthe current path is selected and negated to find an input that drives thenextprogramexecutiontofollowapreviouslyunexploredpath.
this way concolic testing systematically explores the execution paths of the program greatly improving random testing.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
key component of concolic testing is the so called search heuristic.
because of the path explosion problem exploring all execution paths of a nontrivial program is simply impossible.
instead concolic testing relies on a search heuristicto maximize code coverage in a limited time budget.
a search heuristic has a criterion andsteersconcolictestingbychoosingthebestbranchtonegate according to the criterion.
for example the cfds control flow directedsearch heuristic picksthebranchthatisclosesttothe uncoveredregionsoftheprogramandthecgs context guided search heuristic selects a branch only if it is in a new context.
it is well known thatthe effectiveness of concolic testing depends heavily on the choice of the search heuristic .
however manuallydesigningsuchaheuristicischallenging.itis notonly nontrivialbut alsolikely todeliver sub optimal andunstableresults.aswedemonstrateinthispaper nomanually designedexistingheuristicsconsistentlyachievegoodcodecoverageinpractice.forexample thecgsheuristicisarguablyastate of the art andoutperformsexistingapproachesforanumberofprograms .
however wefoundthatcgsissometimesbrittleandinferioreventoarandomheuristic.furthermore existingsearchheuristicscame from a huge amount of engineering effort and domain expertise.
the difficulty of manually coming up with a good search heuristic is a major remaining challenge in concolic testing.
to addressthis challenge this paper presentsa newapproach that automatically generates search heuristics for concolic testing.
to this end we use two key ideas.
first we define a parameterized search heuristic which creates a large class of search heuristics.
the parameterized heuristic reduces the problem of designing a goodsearchheuristicintoaproblemoffindingagoodparameter value.second wepresentasearchalgorithmspecializedtoconcolic testing.
the search space that the parameterized heuristic poses is intractably large.
our algorithm effectively guides the search byiteratively refining the search space based on the feedback from previous runs of concolic testing.
experimental results show that automatically generated heuristics by our approach outperform existing manually crafted heuristicsforarangeofcprograms.wehaveimplementedourtechnique in crest and evaluated it on c programs .
150kloc .
for every benchmark program our technique has successfully generated a search heuristic that achieves considerably higher branch coverage than the existing state of the art techniques.
we also demonstrate that the increased coverage by our technique leads to more effective finding of real bugs.
this paper makes the following contributions we present a new approach for automatically generating search heuristics for concolic testing.
our work represents a significantdeparturefrompriorwork whileexistingwork e.g.
focusesonmanuallydevelopingaparticularsearchheuristic ourgoalistoautomatetheveryprocess of generating such a heuristic.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden sooyoung cha seongjoon hong junhee lee and hakjoo oh wepresentaparameterizedsearchheuristicandanefficient algorithm for finding good parameter values.
we extensively evaluate our approach with c programs.
we makeourtool calledparadyse anddatapubliclyavailable.
preliminaries insection2.
wedefineagenericconcolictestingalgorithm.section .
discusses existing search heuristics and their limitations.
.
concolic testing concolictestingisahybridsoftwaretestingtechniquethatcombinessymbolic andconcreteexecutionstosystematicallyexplore the program s execution paths.
concolic testing begins with executing the subject program p with an initial input v0.
during the concrete execution concolic testingmaintainsa symbolicmemorystate sandapathcondition .
the symbolic memory is a mapping from program variables to symbolic values.
it is used to evaluate the symbolic values of expressions.
for instance when sis variables xandyaremappedtosymbolicexpressions and 1where and aresymbols thestatement z x ytransfersthesymbolic memory into .
the path condition represents the sequence of branches taken during the currentexecutionoftheprogram.itisupdatedwheneveranassume statement assume e is encountered.
for instance when s x mapsto ande x thepathcondition getsupdatedby .
let 1 2 nbe the path condition that results from the initial execution.
to obtain the next input value concolic testing chooses a branch condition iand generates the new path condition primeas follows prime logicalandtext.
j i j i. that is the new condition primehas the same prefix as up to the i th branch with inegated sothatinputvaluesthatsatisfy primedrivetheprogram execution to follow the opposite branch of i. such concrete input valuescanbeobtainedfromansmtsolver.thisprocessisrepeated until a fixed testing budget runs out.
algorithm1presentstheconcolictestingalgorithm.thealgorithm takes a program p an initial input vector v0 and a testing budget n i.e.
the number of executions of the program .
the algorithm maintains the execution tree tof the program which is the list of previously explored path conditions.
the execution tree t andinputvector vareinitiallyemptyandtheinitialinputvector respectively lines and .
at line the program pis executed with the input v resulting in the current execution path mexplored.thepathconditionisappendedto t line5 .inlines6 the algorithm chooses a branch to negate.
the function choose first chooses apath condition from t thenselects abranch i.e.
i f r o m .
once a branch iis chosen the algorithm generates the new path condition prime logicalandtext.
j i j i.i f primeis satisfiable the next input vector is computed line where sat returns true iff is satisfiable andmodel finds an input vector vwhich is a model of i.e.
v .
otherwise if primeis unsatisfiable the algorithm repeatedly triesto negate another branch untila satisfiablepathconditionisfound.thisprocedurerepeatsforthegiven budget nand the final number of covered branches branches t is returned.
1parametric dy namic symbolic e xecution concolic testing input program p initial input vector v0 budget n output the number of branches covered t angbracketleft angbracketright v v0 form 1tondo m runprogram p v t t m repeat i choose t 1 n until sat logicalandtext.
j i j i v model logicalandtext.
j i j i end for return branches t theperformanceofalgorithm1variesdependingonthechoice of the function choose namely a search heuristic.
since the numberofexecutionpathsinaprogramisusuallyexponentialinthe numberofbranches exploringallpossibleexecutionpathsisinfeasible.
to address this problem concolic testing relies on the search heuristic that steers concolic testing in a way to maximize code coverageinagivenlimitedtimebudget .thegoalofthispaperis toautomaticallygenerateaneffectiveheuristicforagivenprogram.
.
existing search heuristics beforepresentingourtechnique wedescribetwonotablesearch heuristics.theseheuristicsareknowntoperformcomparatively better than other heuristics .
control flowdirectedsearch cfds .
cfdsisbasedon the natural intuition that uncovered branches near the current executionpathwouldbeeasiertobeexercisedinthenextexecution.
this heuristic first picks the last path condition m then selects a branchwhoseoppositebranchisthenearestfromanyoftheunseen branches.
thedistance betweentwo branchesis calculatedby the number of branches on the path from the source to the destination.
to calculate the distance cfds uses control flow graph of the program which is statically constructed before the testing.
context guidedsearch cgs .
cgsbasicallyperforms the breath first search bfs on the execution tree while reducing the search space by excluding branches whose contexts are alreadyexplored.givenanexecutionpath thecontextofabranch in the path is defined as a sequence of preceding branches.
the searchgatherscandidatebranchesatdepth dfromtheexecution tree picks a branch from the candidates and the context of the branch is calculated.
if the context has been already considered cgs skips that branch and continues to pick the next one.
oth erwise the branch is negated and the context is recorded.
when all the candidate branches at depth dare considered the search proceedstothedepth d 1oftheexecutiontreeandrepeatsthe process explained above.
limitations.
existingsearchheuristicshaveakeylimitation they rely on a fixed heuristic and fail to consistently perform well on a wide range of target programs.
our experience with these authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically generating search heuristics for concolic testing icse may june gothenburg sweden heuristicsisthattheyareunstableandtheireffectivenesssignificantly varies depending on the target programs.
for example cgs outperforms other existing heuristics for several benchmarks e.g.
expat .
.
andgrep .
figure1 .however wefoundthatthe cgsheuristicissometimesinferioreventotherandomheuristic e.g.
tree .
.
.
that is the key feature contexts of cgsis not appropriate for some programs.
besidestheirsub optimality anotherkeylimitationofexisting approaches is that developing a good search heuristic requires a huge amount of engineering effort and expertise.
given that theeffectiveness of concolic testing depends heavily on the searchheuristic ordinarydeveloperscannotfullybenefitfromconcolictesting.
these observations motivated us to develop a technique that automatically generates search heuristics.
our technique in this section we present our technique for automatically gen erating search heuristics for concolic testing.
we define a family ofsearchheuristics namelyparameterizedsearchheuristics section3.
andpresentanalgorithmtochoosethebestheuristicfrom the family for a given subject program section .
.
.
parameterized search heuristic letp programbe a subject program under test.
recall that a search heuristic the choosefunction in algorithm is a function from execution trees to pairs of a path condition and a branch choose searchheuristic executiontree pathcond branch where executiontree isthesetofallexecutiontreesoftheprogram pathcond the set of all path conditions in the trees branchthe set of all branches in p. wedefineafamily h searchheuristic ofsearchheuristicsasa parameterizedheuristic choose where istheparameterwhichis ak dimensional vector of real numbers h choose rk .
given an execution tree t angbracketleft 1 2 m angbracketright our parameterized search heuristic is defined as follows choose angbracketleft 1 m angbracketright m argmax j mscore j intuitively theheuristicfirstchoosesthelastpathcondition m fromtheexecutiontree t thenselectsabranch jfrom mthat getsthehighest scoreamongallbranchesin thatpath.exceptfor the cgs heuristic all existing search heuristics choose a branch from the last path condition.
in this work we follow this common strategybutourmethodcanbegeneralizedtoconsidertheentire execution tree as well.
we explain how we score each branch in mwith respect to a given parameter werepresentthebranchbyafeaturevector.wedesigned40 boolean features describing properties of branches in concolictesting.afeature iisabooleanpredicateonbranches i branch .forinstance oneofthefeatureschecks whether the branch is located in the main function or not.
given a set of kfeatures 1 ... k where kis the length of the parameter a branch is represented by a boolean vector as follows angbracketleft 1 2 ... k angbracketright.table branch features for concolic testing.
features are static and features are dynamic.
description 1branch in the main function 2true branch of a loop 3false branch of a loop 4nested branch 5branch containing external function calls 6branch containing integer expressions 7branch containing constant strings 8branch containing pointer expressions 9branch containing local variables 10branch inside a loop body 11true branch of a case statement 12false branch of a case statement 13first branches of a path 14last branches of a path 15branch appearing most frequently in a path 16branch appearing least frequently in a path 17branch newly covered in the previous execution 18branch located right after the just negated branch 19branch whose context k is already visited 20branch whose context k is already visited 21branch whose context k is already visited 22branch whose context k is already visited 23branch whose context k is already visited 24branch negated more than times 25branch negated more than times 26branch negated more than times 27branch near the just negated branch 28branch failed to be negated more than times 29the opposite branch failed to be negated more than times 30the opposite branch is uncovered depth 31the opposite branch is uncovered depth 32branch negated in the last executions 33branch negated in the last executions 34branch negated in the last executions 35branchinthefunctionthathasthelargestnumberofuncovered branches 36theopposite branchbelongs tounreachedfunctions top10 of the largest func.
37theopposite branchbelongs tounreachedfunctions top20 of the largest func.
38theopposite branchbelongs tounreachedfunctions top30 of the largest func.
39the opposite branch belongs to unreached functions of branches 40branch inside the most recently reached function next we compute the score of the branch.
in our method the dimension kof the parameter equals to the number of branch features.
we use the simple linear combination of thefeaturevectorandtheparametertocalculatethebranch score .
finally wechoosethebranchwiththehighestscore.thatis amongthebranches 1 ... nin m wechoosethebranch jsuch that score j score k for all k. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden sooyoung cha seongjoon hong junhee lee and hakjoo oh branch features.
we have designed features to describe useful properties of branches in concolic testing.
table shows the features whichareclassifiedinto12staticand28dynamicfeatures.
astaticfeaturedescribesabranchpropertythatcanbeextracted without executing the program.
a dynamic feature requires to execute the program and is extracted during concolic testing.
the static features describe the syntactic properties of each branchintheexecutionpath whichcanbegeneratedbyanalyzing the program text.
for instance feature indicates whether the branchhasapointerexpressioninitsconditionalexpression.we designed these features to see how much such simple features help toimprovebranchcoverage asthereisnoexistingheuristicthat extensively considersthe syntactic properties ofbranches.
at first glancefeatures2and3seemredundant butnotso.thetrueand false branches of loops have different roles by giving a high score to a true branch we can explicitly steer concolic testing away from the loop i.e.
negating the true branch while giving a high score to a false branch leads to getting into the loop.
on the other hands we designed dynamic features to capturethedynamicsofconcolictesting.forinstance feature24checkswhetherthebranchhasbeennegatedmorethan10times duringconcolictesting.thatis duringtheexecutionoftheprogram thebooleanvalueofeachdynamicfeatureforthesamebranchmay change while the static feature values of the branch do not.
we also incorporated the key insights of the existing search heuristicsintothefeatures.forexample dynamicfeatures19 were designed based on the notion of contexts used in the cgs heuristic whilefeatures30 31arebasedontheideaofthecfds heuristic that calculates the distance to uncovered branches.
.
parameter optimization algorithm nowwedescribeouralgorithmforfindingagoodparametervalue of the parameterized search heuristic.
we formally define the optimization problem and then present our algorithm.
optimizationproblem.
inourapproach findingagoodsearch heuristiccorrespondstosolvinganoptimizationproblem.wemodel the concolic testing procedure in algorithm by the function c program searchheuristic n whichtakesaprogramandasearchheuristic andreturnsthenumber of covered branches.
given a program pand a search heuristic choose c p choose performsconcolic testing algorithm1 using the heuristic for a fixed number of executions i.e.
n .
we assume thatthe initialinput v0 andthe number ofexecutions n are fixed for the program.
given a program pto test our goal is to find a parameter that maximizes the performance of the concolic testing algorithm with respectto p. formally our objective is to find such that argmax rkc p choose .
that is we aim to find a parameter that causes the concolic testingalgorithm cwiththesearchheuristic choose tomaximize the number of covered branches in p. optimization algorithm.
weproposeanalgorithmthatefficientlysolvestheoptimizationproblemin .asimplisticapproachto solve the problem would be random sampling which randomly samplesparametervaluesandreturnsthebestparameterfoundforagiventimebudget.however wefoundthatthisnaivealgorithmis extremely inefficient and leads to a failure when it is used for finding a good search heuristic of concolic testing section .
.
this is mainlybecauseoftworeasons.first thesearchspaceisintractably large and therefore blindly searching for good parameters without anyguidanceishopeless.second asingleevaluationofaparameter value is generally unreliable and does not represent the average performance in concolic testing.
this performance variation arises from the inherent nondeterminism in concolic testing e.g.
branch prediction failure .
inresponse wedesignedanoptimizationalgorithm algorithm2 specializedtoefficientlyfindinggoodparametervaluesofsearch heuristics.thekeyideabehindthisalgorithmistoiterativelyrefine the sample space based on the feedback from previous runs of concolic testing.
the main loop of the algorithm consists of the threephases find check and refine.thesethreestepsarerepeated until the average performance converges.
atline2 thealgorithminitializesthesamplespaces.itmaintains ksample spaces ri i where kis the dimension of the parameters i.e.
thenumberofbranchfeaturesinourparameterizedheuristic .
in our algorithm the i th components of the parameters aresampledfrom ri independentlyfromothercomponents.for alli riis initialized to the space .
inthefirstphase find werandomlysample nparametervalues 1 2 ... nfromthecurrentsamplespace r1 r2 rk line and their performance numbers i.e.
the number of branches covered areevaluated lines9 .inexperiments weset nto1 for vim .
among the parameters we choose the top k parametersaccordingtotheirbranchcoverage.inourexperiments kis set to because we observed that parameters with good qualities are usually found in the top parameters.
this first step of executing a program times can be run in parallel.
inthenextphase check wechoosethetop2parametersthat showthebestaverageperformance.atlines16 the kparameters chosen from the first phase are evaluated again to obtain theaveragecodecoverage over10trials where b irepresentsthe average performance of parameter prime i. at line we choose two parameters t1 top and t2 top with the best average performance.thisstep check isneededtoruleoutunreliableparameters.
because of the nondeterminism of concolic testing the quality of a search heuristic must be evaluated over multiple executions.
inthethirdstep refine werefinethesamplespaces r1 ... rk based on t1and t2.
each riis refined based on thevalues of the i th components i t1and i t2 o f t1and t2.
when both i t1and i t2 are positive we modify riby min i t1 i t2 .
when both i t1and i t2are negative riis refined by max i t1 i t2 .
otherwise ri remains the same.
then our algorithm goes back to the first phase find andrandomlysamples nparametervaluesfromtherefined space.
finally ouralgorithmterminateswhenthebestaveragecoverage b t1 obtainedinthecurrentiterationislessthanthecoverage max fromthepreviousiteration lines30 .thisway weiterativelyrefineeachsamplespace riandguidethesearchtocontinuously find and climb the hills toward top in the parameter space.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically generating search heuristics for concolic testing icse may june gothenburg sweden algorithm our parameter optimization algorithm input program p output optimal parameter rkforp k the dimension of initialize the sample spaces ri fori angbracketleftmax converge angbracketright angbracketleft false angbracketright repeat step find sample nparameters 1 ... n e.g.
n i n i sample from r1 r2 rk evaluate the sampled parameters fori 1tondo bi branch coverage achieved with i bi c p choose i end for pick top kparameters prime i k i 1from i n i 1with highest bi step check for all kparameters prime ido b i summationtext.
j 1c p choose prime i end for pick top parameters t1 t2with highest b i step refine fori 1tokdo if i t1 0and i t2 0then ri min i t1 i t2 else if i t1 0and i t2 0then ri max i t1 i t2 end if end for check convergence ifb t1 maxthen converge true else angbracketleftmax max angbracketright angbracketleft b t1 t1 angbracketright end if untilconverge return max experiments in this section we experimentally evaluate our approach that automatically generates search heuristics of concolic testing.
we implementedourapproachinatool paradyse ontopofcrest a concolic testing tool widely used for c programs .
we conductedexperimentstoanswerthefollowingresearchquestions effectivenessofgeneratedheuristics doesourapproach generateeffectivesearchheuristics?howdotheyperform compared to the existing state of the art heuristics?
time for obtaining the heuristics how long does our approachtaketogeneratethesearchheuristics?isourapproach useful even considering the training effort?
efficacy of optimization algorithm how does our optimizationalgorithmperformcomparedtothenaivealgorithm by random sampling?
important features what are the important features to generate effective search heuristics for concolic testing?table benchmark programs program total branches loc source vim .
165k gawk .
.
30k ours expat .
.
49k grep .
15k sed .
9k tree .
.
4k ours cdaudio 3k floppy 2k kbfiltr 1k replace .5k evaluation setting.
we have compared our approach with fiveexistingheuristics cgs context guidedsearch cfds control flowdirectedsearch randombranchsearch dfs depth firstsearch andgenerationalsearch .wechose these heuristics for comparison because they have been commonly usedinpriorwork .inparticular cgsandcfdsare arguablythestate of the artsearchheuristicsthatoftenperform the best in practice .
the implementation of cfds random anddfsheuristicsareavailableincrest.theimplementationsof cgs and generational search came from the prior work .
we used open source benchmark programs .3the benchmarks are divided into the large and small programs.
the large benchmarks include vim expat grep sed gawk and tree.
thefirstfourarestandardbenchmarkprogramsinconcolictesting forc whichhavebeenusedmultipletimesinpriorwork .thelasttwoprograms gawkandtree werepreparedby ourselves which are available with our tool.
our benchmark set alsoincludes4smallones cdaudio floppy kbfiltr and replace which were used in .
weconductedallexperimentsunderthesameevaluationsetting theinitialinput i.e.
v0inalgorithm1 wasfixedforeachbenchmarkprogramandasinglerunofconcolictestingusedthesame testing budget executions i.e.
n 4000in algorithm .
note that the performance of concolic testing generally dependson the initial input.
we found that in our benchmark programs except for grepandexpat different choices of initial input did not much affect the final performance so we generated random inputsforthoseprograms.for grepandexpat theperformanceof concolic testing varied significantly depending on the initial input.
for instance with some initial inputs cfds and random covered 150lessbranchesin grepthanwithotherinputs.we avoidedthis exceptional case when selecting the input for grepandexpat.
for expat we chose the same input used in prior work .
for grep weselected aninputon whichtherandom heuristicwaseffective.
the initial inputs we used are available with our tool.
theperformanceofeachsearchheuristicwasaveragedovermultipletrials.evenwiththesameinitialinput thesearchheuristicshavecoveragevariationsforseveralreasons searchinitialization inconcolictesting therandomnessofsearchheuristics and soon.werepeatedtheexperiments100timesforallbenchmarks 2we obtained the implementation from authors via personal communication.
3henceforth the version numbers will be omitted when there is no confusion.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden sooyoung cha seongjoon hong junhee lee and hakjoo oh table average branch coverage on small benchmarks ours cfdscgsrandom gen dfs cdaudio floppy replace kbfiltr table4 effectivenessintermsofmaximumbranchcoverage ours cfds cgs random gen dfs vim8 expat1 gawk2 grep1 sed tree table effectiveness in terms of finding bugs ours cfds cgs random gen dfs gawk .
.
grep .
exceptfor vimforwhichweaveragedover50trialsasitsexecution takes much longer time.
the experiments were done on a linux machine with two intel xeon processor e5 and 192gb ram.
.
effectiveness of generated heuristics foreachbenchmarkprogram weranouralgorithm algorithm2 to generateoursearchheuristic ours andcompareditsperformance withthatoftheexistingheuristics.weevaluatetheeffectiveness with two measures branch coverage and capability to find bugs.
branch coverage.
forbranchcoverage wemeasuredtheaverage and maximum coverages.
the average branch coverage isobtained by averaging the results over the trials for vim .
the maximum coverage refers to the highest coverage achieved during the trials for vim .
the former indicates the average performancewhilethelatterthebestperformanceachievableby each heuristic.
figure compares the average branch coverage achieved by differentsearchheuristicson6largebenchmarks.theresultsshowthatthesearchheuristicsgeneratedbyourapproach ours achieve thebestcoverageonallprograms.inparticular ourssignificantly increased the branch coverage on two largest benchmarks vim andgawk.for vim ourscovered8 297branchesin4 000executions while the cfds heuristic which took the second place for vim covered branches.
note that cfds is already highly tuned andthereforeoutperformstheotherheuristicsfor vim forinstance cgs covered branches only .
for gawk ours covered brancheswhile thecgsheuristic thesecondbestone managedto cover branches.
for expat sed and tree our approach improved the existing heuristics considerably.
for example ours covered branches for expat increasing the branch coverageofcgsby50.for grep oursalsoperformedthebestfollowedby cgs and cfds.
on small benchmarks we obtained similar results ours togetherwithcgs consistentlyachievedthehighestaverage coverage .
in the rest of the paper we focus only on the large benchmarks where existing manually crafted heuristics fail to perform well.
onallbenchmarksinfigure1 oursexclusivelycoveredbranches that were not covered by other heuristics.
for example in vim a total of branches were exclusively covered by our heuristic.
for other programs the numbers are expat gawk grep sed tree .
these results are statistically significant on all benchmark programs in figure the pvalue was less than .01according to wilcoxon signed rank test.
in figure the standard deviations for each heuristic are as follows ours vim expat gawk grep sed tree cfds vim expat gawk grep sed tree cgs vim expat gawk grep sed tree .othersearchheuristicsalso have similar standard deviations.
infigure1 wecomparedtheeffectivenessofsearchheuristics over iterations of executions but our approach was also superiortoothersoverexecutiontime.forexample giventhesame time budget sec ours and random the second best covered and branches respectively for vim figure .
the results were averaged over trials.
table4comparestheheuristicsintermsofthemaximumbranch coverage on large benchmarks.
the results show that our approachinthiscasealsoachievesthebestperformanceonallprograms.forinstance in vim weconsiderablyincreasedthecoverage of cfds the second best strategy ours covered branches while cfds managed to cover .
for expat ours and cgs the second best have covered and branches respectively.
note that there is no clear winner among the existing search heuristics.exceptforours cfdstookthefirstplacefor vimandsed in terms of average branch coverage.
for gawk expat and grep the cgs heuristic was the best.
for tree the random heuristic wasbetterthancfdsandcgs.intermsofthemaximumbranch coverage cfds was better than the others for vimandgawkwhile cgswasfor grepandsed.thegenerationalandrandomheuristics surpassedcfdsand cgsin expatandtree respectively.on the otherhand ourapproachisabletoconsistentlyproducethebest search heuristics in terms of both coverage metrics.
bug finding.
we found that the increased branch coverage by our approach leads to more effective finding of real bugs not seeded ones .
table reports the number of trials that successfully generate test cases which trigger the known performance bugs in gawkandgrep .duringthe100trials whereasingletrial consistsof4 000executions ourheuristicalwaysfoundthebugin gawkwhile all the other heuristics completely failed to find it.
ingrep ourssucceededtofindthebug47timesoutof100trials which is much better than cgs does times .
other heuristics were not able to trigger the bug at all.
4evaluatingtheperformanceofsearchheuristicsoveriterationsisacommonpractice astheexecutiontimeofaprogrammayvaryconsiderablydependingon the input.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatically generating search heuristics for concolic testing icse may june gothenburg sweden figure average branch coverage achieved by each search heuristic on large benchmarks ourheuristics aregoodatfinding bugsbecausetheyaremuch better than other heuristics in exercising diverse program paths.
weobservedthatotherheuristicssuchascgs cfds andgenalso covered the branches where the bugs originate.
however the bugs arecausedonlybysomespecificpathconditionsandtheexisting heuristics could not generate inputs that satisfy the conditions.
we remark that we did not specially tune our approach towards findingthosebugs.infact wewerenotawareofthepresenceof those bugs at the early stage of this work.
the bugs in gawkand grep cause performance problems for example grep .2requires exponentialtime andmemory on particularinput strings thatinvolveback