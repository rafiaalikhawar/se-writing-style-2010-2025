presence condition simplification in highly configurable systems alexander von rhein alexander grebhahn sven apel norbert siegmund dirk beyer and thorsten berger university of passau germany university of waterloo canadac ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
abstract for the analysis of highly configurable systems analysis approaches need to take the inherent variability of these systems into account.
the notion of presence conditions is central to such approaches.
a presence condition specifies a subset of system configurations in which a certain artifact or a concern of interest is present e.g.
a defect associated with this subset .
in this paper we introduce and analyze the problem of presence condition simplification .
a key observation is that presence conditions often contain redundant information which can be safely removed in the interest of simplicity and efficiency.
we present a formalization of the problem discuss application scenarios compare different algorithms for solving the problem and empirically evaluate the algorithms by means of a set of substantial case studies.
i. i ntroduction highly configurable systems have become more and more complex in recent years .
a configurable system provides configuration options also known as features to tailor the system according to a given set of requirements.
a configuration option typically represents a choice to include a certain functionality in a system variant.
as often not all combinations of configuration options are allowed or meaningful additional constraints are defined between them typically using a variability model such as a feature model or decision model .
the constraints of the variability model are enforced globally that is they must hold for all configurations.
apresence condition is an expression over a set of configuration options.
the condition represents a subset of configurations in which a certain implementation artifact such as a code fragment is included in the corresponding system variants or in which a certain behavior can be observed.
for many application scenarios it is important that presence conditions are as simple as possible.
for example if the presence condition identifies defective system variants a developer needs to understand the condition i.e.
which options need to be enabled or disabled to fix the defect .
in this paper we focus on boolean configuration options and boolean presence conditions which is sufficient to represent most presence conditions in practice .
with presence conditions as a key concept variability aware analyses emerged for type checking static analysis model checking and variability model analysis .
a variability aware analysis analyzes a configurable system as a whole incorporating its variability model.
typically the analysis considers only valid combinations of options and it presents its findings e.g.
a detected defect annotated with presence conditions.
for example a reported presence conditioncould identify all system variants containing a certain type error.
even in small systems with few options these conditions can be very complex and difficult to understand.
consider the example of the tool spl verifier for verification of configurable systems which reports the following defect in the e m ail system a benchmark for interactions between options in configurable programs 1specification violated on condition 2encrypt decrypt keys sign verify base autoresponder !sign !verify base autoresponder the defect in this example is caused by an interaction of only two options encrypt andautoresponder .
all other parts of this presence condition have been introduced by the global variability model e.g.
encrypt requires keys .
a desirable simplification of the presence condition is to identify encrypt andautoresponder as the sole cause of the defect and to hide the parts introduced by the variability model.
simplifying the condition and identifying the responsible options help in fixing the defect .
a straightforward way to simplify a presence condition or make it more readable is to find the smallest but equivalent expression.
this problem is known as the minimum equivalentexpression problem .
although finding a minimal equivalent expression might reduce the size of the presence condition the minimal equivalent expression is still larger than necessary.
one reason for unnecessarily large expressions is that variability aware analyses typically consider only configurations satisfying the variability model.
thus the variability model is an integral part of every reported presence condition even though the condition describes only a local situation or fact.
since the variability model must be satisfied globally this information obfuscates the presence condition.
our goal is to simplify a given presence condition such that it becomes smaller and can be used instead of the original presence condition.
in the example above we want to remove the constraints already enforced by the variability model from the presence condition and show only the rest to the user.
this rest must be satisfied in addition to the variability model to reach the situation of interest e.g.
it identifies the source of the defect .
to this end we introduce the presence conditionsimplification problem and present a formal definition of the problem.
we are interested in a function simp p m such that the expression p0 simp p m is equivalent to the presence condition punder all assignments that satisfy the context m m p0 p .
in addition to this invariant the size of p0should beas small as possible we define a size measure in section iii c .
there are many other application scenarios of presencecondition simplification including the simplification of preprocessor directives in system software ifdef conditions are simplified based on the conditions of surrounding ifdef conditions in the nesting hierarchy and the simplification of cross tree constraints in variability models information that is already encoded in the feature option hierarchy is removed from the cross tree constraints .
as a solution for presence condition simplification we identify and adopt three algorithms from the circuitoptimization domain.
to the best of our knowledge the algorithms have not yet been applied to the simplification of presence conditions.
the first algorithm restrict is based on binary decision diagrams bdds .
the second and third algorithms are solutions for two level logic minimization the quine mccluskey algorithm and the e spresso algorithm .
to compare the algorithms and to explore their feasibility and effectiveness for presence condition simplification we conduct a series of experiments on three application scenarios and subject systems.
we evaluate processing time and size reduction of presence conditions for the three algorithms.
our results show that presence condition simplification can achieve substantial improvements in reasonable time for various realistic application scenarios.
for example in an experiment where we simplified analysis results e1 one simplification algorithm simpbdd reduced the size of presence conditions by on average.
furthermore we analyze how the simplification algorithms scale with the increasing complexity of the input expressions.
in summary we contribute a formalization of the presence condition simplification problem in the context of highly configurable systems and a discussion of scenarios to which presence condition simplification can be applied.
a discussion of three algorithms solving the problem restrict quine mccluskey and e spresso .
an evaluation of the algorithms on three application scenarios and subject systems showing that simplification potential exists and the algorithms scale in realistic scenarios.
one of the presented algorithms simpbdd has been integrated in the variability aware analysis tool typechef resulting from our research.
we provide a replication package for our experiments and further detailed results on an accompanying website ii.
b ackground to establish the terminology that we use throughout the paper we give an overview of configurable systems and boolean presence conditions.
a configurable system provides a set of configuration options to be set by the user to derive a desired system variant .
in what follows we use the e m ailsystem of hall as a running example.
the e m ailsystem simulates a network of e mail hosts between which e mails are sent.1struct email 2intid char from char to char subject char body if defined encrypt defined decrypt 4intisencrypted char encryptionkey endif incoming e mails enter here 8void incoming struct client client struct email msg if defined decrypt decrypt client msg decrypt encrypted incoming e mails endif if defined forward forward client msg forward incoming e mails automatically endif ... store e mail in a mailbox ... if defined decrypt decrypt a given e mail if the key of the sender is known 19void decrypt struct client client struct email msg ... endif fig.
excerpt of the configurable e mail system figure shows an excerpt of the system s code with variability expressed using if preprocessor directives.
in addition to the basic functionality base the e m ail system offers eight configuration options keys enables support for private and public keys encrypt and decrypt implement encryption and decryption sign andverify implement signing of e mails and verifying of signatures forward implements automatic e mail forwarding autoresponder generates automatic response e mails and addressbook provides contact management.
a configuration of a system is a total mapping from the configuration options to values.
here we focus on boolean configuration options whose values can only be true orfalse because they are an important backbone of configurations in practice non boolean configuration options can be represented by multiple boolean variables if the domain is discrete and small such as for enumerations.
we represent a mapping from options to choice values such as base7!true keys7!true forward7!
true encrypt7!false with a boolean expression such as base keys forward encrypt typically not all possible mappings are valid in a configurable system a variability model defines the set of valid configurations.
a possible representation of a variability model is again a boolean expression for example base decrypt encrypt sign verify encrypt keys sign keys .
all assignments of configuration options for which the variability model is satisfied correspond to the set of valid configurations.
apresence condition is a boolean expression over the set of configuration options .
we use the term presence condition in a broad sense but it always is a boolean expression denoting the condition for presence of certain code or behavior in variants of the configurable system.
for example a presence condition can denote the condition for a defect in the system or for the presence of a statically conditional piece of code in a variant.
finally given two boolean expressions fandg and the fact that fimplies g we refer to fas an implicant also known aspremise of g and to gas an implicate also known as conclusion of f. aprime implicant fofgis an implicant of gthat is minimal that is the removal of any literal from fresults in a non implicant for g. for example the expression g x y whas the implicants x y x w and more.
the term x yis a prime implicant the removal of xoryleaves a non implicant.
iii.
p resence condition simplification we illustrate the problem of presence condition simplification by means of three practical application scenarios section iii b define invariants for a solution of the problem formally section iii c and discuss algorithms satisfying these invariants section iii d .
a. problem overview presence condition simplification aims at simplifying a presence condition pwith respect to its context m. as an approximate measure for simpleness of a boolean expression we use the number of its literals but other measures are possible as well see section iii c for further details .
pand mare given as boolean expressions and we require that pis embedded in m which means that pis evaluated only if mis satisfied.
a simplification function simp receives two boolean expressions pandmand returns a boolean expression.
b. application scenarios although the application domain is much broader we are particularly interested in presence condition simplification in the context of developing and analyzing highly configurable systems.
next we illustrate three interesting scenarios.
reporting analysis results variability aware analyses often report the condition under which certain events or states occur as presence conditions.
recall our example of spl verifier which implements variability aware model checking of configurable systems.
the tool prints the following output after verifying hall s e m ailsystem 1specification violated on condition 2encrypt decrypt keys sign verify base autoresponder !sign !verify base autoresponder the e m ailsystem can be configured with various options and some combinations of options can lead to violations of certain specifications as reported above by spl verifier .
such violations indicate either an incomplete variability model which should be fixed to prevent defective configurations or a bug in the system.
since spl verifier verifies only configurations that satisfy the variability model which is standard in variability aware analyses the reported presence conditions contain parts that are already implied by the variability model.
this mix of error condition with variabilitymodel constraints hinders understanding and pinning down the source of an error.
even though the e m ailsystem has only nine configuration options the reported defect conditions are often unnecessarily complicated.
the defect conditions we encountered for the e m ailsystem have between and literals.
by applying presence condition simplification to the 1the specification states that e mails must be decrypted before sending an automatic response.
... 33obj lockdep lockdep.o ... a excerpt from kernel makefile826 if defined prove locking ... if defined trace irqflags defined prove locking ... else ... endif ... endif b excerpt from kernel lockdep.c fig.
nested variability annotations with redundancy defect presence condition shown above we yield the following result containing only instead of literals 1specification violated on condition 2variabilitymodel encrypt autoresponder simplification of variability annotations variability annotations are directives in a system s source code that conditionally include or exclude parts of the code based on the choice of configuration options.
for illustration we focus on two implementation mechanisms for variability annotations conditional inclusion of files in build scripts and if preprocessor directives.
figure shows an example of both mechanisms used together taken from the linux kernel v3.
.
figure 2a shows an excerpt of the makefile in thekernel directory.
it states that the object file of lockdep.c is included if option lockdep is enabled.
figure 2b shows an excerpt of file lockdep.c which contains several if directives.
observe that in the example the innermost if directive figure 2b line is enclosed by two conditions the if condition in line and the condition from the makefile .
the conjunction of both enclosing conditions is the context of the condition in line m lockdep prove locking and p trace irqflags prove locking .
using presence condition simplification we can remove the redundant term prove locking from the condition of the inner preprocessor directive without changing the behavior of any variant of the linux kernel simp p m trace irqflags .
admittedly the expressions involved in this example are relatively simple so a developer might be aware of the redundancy and leave it for documentation.
still in more complex cases simplification can be more effectful especially because it is also beneficial for tools working on the code to ease automatic reasoning.
automatic code analysis of systems with ifdef variability is difficult because the preprocessor directives can be interleaved with normal ccode in complicated ways.
the tool typechef solves this problem by providing a variability aware parser for ccode with if directives.
it is used by many research projects which would benefit from presence condition simplification.
typechef resolves preprocessor directives and macros and it generates an abstract syntax tree ast preserving the variability induced by if directives.
technically nodes in the ast are annotated with the presence conditions that correspond to the if directives.
due to difficulties in thebasekeysencryptsignaddressbookautoresponderforwarddecryptverifylegend optionalsign verifyencrypt decryptfig.
feature model of the e m ailsystem parsing process e.g.
macro expansion these presence conditions are often an overapproximation of the actual presence conditions and contain redundancy.
we can make the ast generated by typechef more concise by simplifying the presence conditions with their context presence conditions of ancestors in the ast conjoined with the presence condition of the file which improves the performance of subsequent analyses such as type checking or data flow analysis .
variability model generation a variability model can be expressed in different formats.
in this paper we use boolean expressions but other scenarios require richer representations such as feature models by kang et al.
figure shows a representation of the feature model of the e mail system section ii .
such a model contains a hierarchy that shows dependencies between the configuration options child parent implication .
for example selecting option encrypt implies selecting its parent keys.
constraints that cannot be encoded in the hierarchy are written as separate cross tree constraints .
for example the dependencies from encrypt todecrypt and vice versa are expressed as cross tree constraints.
if a variability model is given as a boolean expression for instance when extracted from source code it is sometimes desirable to transform it into a visual model for presentation.
there are a number of approaches e.g.
that synthesize a hierarchy shown as tree in figure and constraints between siblings in the hierarchy.
all constraints that cannot be encoded in the hierarchy or as sibling constraints are added as cross tree constraints.
if the cross tree constraints are still complex it is advisable to simplify them using the hierarchy and the sibling constraints as context.
that is the cross tree constraints should not restate the dependencies covered by the hierarchy or the sibling constraints.
given the hierarchy constraints h the sibling constraints s and the cross tree constraints ctc this can be achieved with simp ctc h s .
the result of simplification can replace the original cross tree constraints because the context of hierarchy and sibling constraints always hold.
c. problem formalization function simp p m has two inputs a presence condition p and a context m. the goal is to represent the relevant information in pas concise as possible.
the input parameters and the result of the simplification are boolean expressions.
even though the problem and the described algorithms section iii d work on general boolean expressions we use them only in the configurable systems context.we assume that the context mis available and holds significant information on the situations in which pcan be evaluated.
if it is not available or if it represents a tautology then we have to assume that all information in pis relevant to identify the situation or fact that prepresents.
in this case the only possibility to improve the presentation of pis to generate a minimum equivalent expression forp .
however in the scenarios that we focus on usually a substantial non tautology context is available e.g.
a global variability model .
presence conditions are meant to be evaluated only if the context mholds.
the information encoded in a presence condition pis essentially the set of implicates of p. elements of this set can be categorized as follows an implicate of pis either also an implicate of mor no implicate of m. implicates in group are redundant and can be dropped.
some implicates in group are implied by elements of group conjoined with mand are therefore also redundant.
if we can extract the essential non redundant elements of group and present them as replacement for p this would be sufficient because the context mguarantees that the implicates in group are satisfied.
hence we do not search for an equivalence preserving function but we aim at removing implicates from pif they are redundant with respect to mand if they increase the size of p. figure illustrates the relationship between p m and simp p m in terms of the configuration space of a configurable system.
the white rectangle mrepresents all valid configurations.
the rectangle prepresents the space of configurations denoted by the presence condition.
pencloses only configurations that are in m. also pis often smaller than mbecause it specifices a certain local condition within the global space of configurations.
the rectangle simp p m represents the simplified presence condition.
this rectangle encloses all configurations of p but also configurations from out of m if it helps to remove implicates from the expression i.e.
if it reduces the size of p .
the objective is that the area of simp p m represents a more concise expression than p. context m presence condition p simplified presence condition simp p m fig.
illustration of presence condition simplification.
each point on the plane represents a configuration.
the crosshatched area denotes the overlapping of the area of p andsimp p m .
the simplified presence condition can include configurations not allowed by the context e.g.
the variability model if it helps reducing the size of the condition.
formally the invariant for correctness of simp p m is m simp p m p this invariant states that in the context of m the expressions p and simp p m are logically equivalent.
therefore we can use simp p m as replacement for p provided that mholds.
equation is a sufficient condition for the correctness of replacing all occurrences of pin the context mbysimp p m .
2a condition that includes more configurations can be smaller in size than a condition with more implicates.in the simplest case simp p m pwould be a valid solution.
however our goal is to simplify p. so we define an objective function stating that simp p m must be minimal according to a given measure size 8x m x p size simp p m size x defining a general measure for the size of boolean expressions is not reasonable as it depends on the application scenario.
in the application scenarios we are interested in cf.
section iii b conciseness of expressions is most important because they are usually presented to the user.
in other cases expressions are used to generate hardware circuits for which other optimization goals are needed.
in practice we have to compare formulas given in notations with different constraints e.g.
cnf dnf or bdd because different simplification algorithms described in section iii d have different input and output formats.
to avoid bias of different notations we focus on the complexity of the encoded formula.
to this end we convert all expressions to a canonical normal form before comparison.
as canonical form we choose a reduced if then else normal form derived from bdds that contains only and as operators.
after the expressions are converted to the same notation there are several possible size measures for comparison.
we choose the number of occurrences of literals as size measure because it represents the total expression length and is not influenced for instance by lengths of variable names.
so for the remaining sections we define the measure size y as the number of occurences of literals in the string representation of an expression yin canonical form.
for expression y a b a c size y b c and twice a .
we also evaluated the number of operators and the number of nodes in a bdd representation as alternative size measures but observed no major deviations in our experiments cf.
section iv .
in their work on the minimum equivialent expression problem hemaspaandra and schnoor have also used the number of occurrences of literals and the number of operators.
we decided against measures such as the depth of an ast of the formula because a cnf dnf representation would always have depth which renders the measure useless for our purposes.
d. implementation we introduce four algorithms solving the presence conditionsimplification problem brute force simpbf restrict simpbdd espresso simpe and quine mccluskey simpqc .simpbffinds an optimal solution but it iterates over all possible solutions.
the other three algorithms employ heuristics to improve computational complexity while still satisfying the invariant of equation .
naive solution the brute force simpbf algorithm enumerates all implicates of p. technically it uses the clauses of the canonical conjunctive normal form ccnf of p. then it builds the powerset of these clauses.
for each element of the powerset the algorithm tests whether it satisfies equation and therefore qualifies as a solution.
from all possible solutions the algorithm selects an optimal solution according to the size measure.the ccnf has 2nclauses for nconfiguration options.
therefore the size of the powerset of the set of clauses is 22n and we have to iterate through the entire set.
due to its computational complexity we cannot use simpbfin our experiments.
bdd simplification the second algorithm was first described by coudert and madre in as the restrict algorithm simpbdd .
the restrict algorithm takes two expressions pand mrepresented as bdds and generates a third bdd c simpbdd p m that satisfies the invariant of equation .
the algorithm is intended to minimize the number of nodes in the bdd representation of simpbdd p m .
this is in line with our optimization goal but as the algorithm uses heuristics it does not always generate optimal results.
for further details we refer to the original publication and to our supplementary website.
like many other bdd operations simpbdd is a polynomialtime graph manipulation algorithm if caching is used .
in the worst case the size of the graph may be exponential in the number of the variables which renders the algorithm also exponential in the number of variables.
however in practice the worst case is unlikely which is part of the reason for the success of bdds.
two level logic minimization the third solution is to transform the problem of presence condition simplification into a two level logic minimization problem which can be solved with the quine mcclusky andespresso algorithms simpqcand simpe .
the attribute two level arises from the fact that input expressions are expected in dnf and a dnf has two levels the global level with operations and the clause level with operations .
two level logic minimization receives a boolean expression fand a second expression dc which represents a don t care set called dc set .
the expressions divide the entire space of option assignments into three partitions the set of assignments for which f dcis satisfied called the on set the set of assignments for which f dcis satisfied called the off set and the dc set for which dcis satisfied.
the result of two level logic minimization is a simplified version of f. mapped to our problem expression frepresents the presence condition p. dc describes variable assignments for which the resultsimpe p m need not be equivalent to p. in our case these are all variable assignments that are not valid in the context m .
that is dc is the piece of information needed for minimization.
so the setup f panddc msatisfies equation .
two level logic minimization can be exact or heuristicsbased.
an exact algorithm determines the minimal set of prime implicants needed to represent fwithout respecting dc.
it can be solved with the quine mcclusky algorithm which is np complete.
in a nutshell the algorithm starts with computing all prime implicants for the union of the on and dc sets.
finding the smallest set of these prime implicants that still cover fis basically a set covering problem which is also np complete.
the algorithm uses reduction techniques and a branch and bound strategy to solve this problem .
3our implementation works for up to four configuration options.for performance several heuristics have been developed.
the most prominent heuristic based algorithm is the espresso algorithm which utilizes a local search without generating all prime implicants.
it is composed of three main operations expand reduce and irredundant .
the operations expand and reduce are applied to improve the current term during optimization and the operation irredundant is used to get out of a local minimum.
in our experiments we evaluate the espresso algorithm denoted with simpe and the quine mccluskey algorithm denoted with simpqc.
for further details on the algorithms we refer to an overview paper .
input format conversion different application scenarios of presence condition simplification require different input formats for the parameters pandm.
so the input expressions need to be converted in formats suitable for the different algorithms.
this is mainly a technical issue that we describe in the appendix.
iv.
e valuation we evaluate the different algorithms for presence condition simplification guided by two research questions rq1 we expect that presence conditions with a known context are often too complex and can be simplified.
in which application scenarios does this hold and are the resulting expressions substantially smaller?
rq2 how does the processing time of the algorithms simpbdd simpe and simpqcscale to complex simplification tasks?
we evaluate these research questions on the application scenarios described in section iii b on overall example configurable systems.
as a measure of simplification rq1 we compare the number of occurences of literals in the expression before and after simplification.
to ensure a fair comparison we transform the results generated by the simpeandsimpqc algorithms to bdds after the algorithms have terminated.
this step ensures that the compared result strings are compact and have the same variable order.
we do not include the time needed for this transformation.
the processing time rq2 is measured per simplification task.
to ensure fairness we did not call simpbddon in memory bdds but wrote them to a file invoked simpbdd in a new process and measured the time for that process to terminate.
this time includes parsing the presence condition and context and writing the result expression.
in total we designed five experiments labelled e1 through e5.
to evaluate research question rq1 we needed sets of boolean presence conditions and contexts from different application scenarios and configurable systems.
we obtained these sets from different research projects and did one experiment per project.
e1 and e2 represent variations of the reporting analysis results application scenario e3 and e4 apply the simplification of variability annotations scenario to source code and to the internal code representation in typechef respectively.
to evaluate research question rq2 we needed a setting where we can flexibly control the size of the problem.
we chose to evaluate this question with the variabilitymodel generation scenario and used a variability model generator to create simplification tasks.
in the generator table i s ubject systems and application scenarios more details are available on the supplementary website apache e1 l inux v2.
.
.
e3 e4 splot models e5 e mail e1 e2 l inux v3.
e3 sql ite e1 e3 elevator e2 llvm e1 z ipme e1 h264 e1 pkj ab e1 other linked list e1 snw e1 systems e3 we can increase the number of generated variables and therefore generate harder problems.
we used these generated tasks in e5 to evaluate the processing time performance of the algorithms.
a. subject systems and experiments we use a diverse set of subject systems from various sources to evaluate the different applications of presence condition simplification.
for each system we ensured that a variability model was available.
table i gives an overview of the systems and in which experiments they are used.
the experiments e1 e5 are described next.
classification of variants e1 the first application scenario is based on an approach that estimates non functional properties footprint response time etc.
of the variants of a configurable system .
experiments evaluating the approach typically generated huge datasets.
for e1 we use the following systems from previous studies apache e mail h264 and llvm prediction of response time per variant and linked list pkj ab snw sql ite and zipme prediction of binary footprint per variant .
presence conditions in this scenario indentify system configurations for which the prediction accuracy is low possibly due to unknown interactions among configuration options.
presence condition simplification is useful for pinpointing these to a smaller number of options such that further investigation is possible.
we have presence conditions for seven different levels of prediction accuracy and simplify all of them seperately using the corresponding variability model as context.
reporting defect locations e2 for our second experiment we use data from a study evaluating the performance of variability aware model checking .
during experiments the authors found many defects in the subject systems that occur only under certain presence conditions.
we use the e mail andelevator systems which are standard benchmarks for interaction detection .
presence conditions of defects and the variability model are given as textual boolean expressions.
an example for the defect location scenario is the output of the spl verifier tool given in section iii b .
we simplify the defect presence conditions and evaluate the performance of the simplification algorithms.
code annotation simplification e3 to evaluate the simplification potential for code annotations we use several configurable software systems with if directives and apply simplification to the if conditions see section iii b .
for our experiments see section iv c we use configurable systems including the l inux kernel.
the context of if conditions in these projects has two components the conditions of enclosing if directives and the condition under which the respective file will be included inthe project as described in section iii b .
in projects that use kconfig we used the tool kbuild miner to extract the conditions under which source files are used.
for the others we assumed that each file is used in all configurations.
we extracted if conditions in source files with the predator tool .
predator also provides the hierarchy of if conditions such that we can generate for each if condition a context consisting of the conjunction of the enclosing if conditions and the file condition.
given these pairs of if conditions and contexts we apply the simpbdd simpeandsimpqcalgorithms and measure how often the conditions could be improved to evaluate the potential for presence condition simplification.
we skip pairs for which if conditions or contexts are tautologies or contradictions because then simplification is impossible.
ast annotation simplification e4 in this experiment we analyze the variability aware asts generated by typechef .
each generated ast node has a presence condition.
due to difficulties in parsing c code with if directives e.g.
undisciplined annotations and macro expansion the resulting presence conditions are often larger than the conditions written in the source code .
for simplification we generated a context for each presence condition pby building the conjunction mof all presence conditions on the path from pto the root node of the ast.
then we applied simplification ofpin the context mand evaluated the reduction in the size of the presence conditions.
again we do not simplify if pormis a tautology or a contradiction.
even though we optimize only an internal representation here it can affect processing time.
furthermore presence conditions are visible to users as part of reports as debugging info and if the ast is printed again after some modification e.g.
automatic code refactoring .
cross tree constraint simplification e5 to evaluate the scalability potential of presence condition simplification we used the variability model generator from the splot repository for generating test variability models.
each model comprises hierarchy grouping and cross tree constraints given in cnf.
this is the same setup as in the final step of the variability model generation scenario section iii b .
as scaling factor we used the number of configuration options of the generated models.
we have generated sets of variability models with configuration options models in total .
for each model we simplify the cross tree constraints using the hierarchy and sibling constraints as context.
all constraints are given in cnf so we apply the force algorithm to optimize the bdd variable ordering.
the more compact representation is beneficial for simpbdd but also for simpeand simpqc.
b. experiment setup for our experiments we use existing algorithm implementations simpbdd is available as function net.sf.javabdd.bdd.simplify bdd in the javabdd library simpe is available in the espresso tool and simpqcis also implemented in espresso as a revised version of the original quine mccluskey algorithm.
we provide links to the tools on our supplementary website.
we also tried to use scherzo a newer tool for two level logic minimization however we were not able to apply it to presence condition simplification because of technical problems and missing documentation.
all experiments have been executed on an intel xeon machine cores with .
ghz with ubuntu .
.
regarding parallelization we have not observed that more than one core was used in the experiments.
in all experiments simplification has been executed in a jvm with gb of ram.
we set the timeout for the simplification algorithms in all experiments to seconds the usual response time was much less .
in the experiments e1 e4 we encountered only timeouts with simpeand with simpqc .
all timeouts occured while simplifying presence conditions of the sql ite system e1 .
for code simplification e3 we used scripts to call the external analysis tools e.g.
typechef .
the tool output was aggregated and later simplified.
during the experiments we measured the processing time of the algorithms and the number of literals in the expressions before and after simplification.
we use the number of occurences of literals as size measure section iii c .
we also evaluated other measures number of operands and node count in the bdd but they do not change the overall picture.
for each simplification we compare the size of the original presence condition pand the simplified presence condition simp p m .
for these comparisons we define the reduction factor as size simp p m size p .
in some cases the size of the supposedly simplified expression was larger than the size of the original expression.
this can happen because some of the algorithms rely on heuristics.
such cases are easy to detect and we just use the original expression instead of the generated expression.
in such cases we logged that simplification did not improve the expression size the reduction factor is .
to provide a ground truth we would need to iterate over all solutions i.e.
apply the brute force algorithm .
however due to the complexity of the problem brute force does not scale for any of our experiments.
c. results classification of variants e1 figure shows the reduction factors we observed for the classification of variants per subject system.
a lower reduction factor indicates a better simplification result.
each boxplot covers all experiments per algorithm and subject system.
figure shows that the number of literals is generally much lower after simplification and that simpbdd generates slightly better results on average than simpeandsimpqc as confirmed by paired mann whitney tests p values below 001for both tests .
these results confirm rq1 for this application scenario and the considered systems there is significant simplification potential and the algorithms are able to simplify the presence conditions substantially.
figure shows the time needed for simplification in a quantile plot.
for example the point in graph simpein the plot states that the th fastest simplification with simpetook ms and there were simplification tasks that took ms or less with simpe.
the plot shows how the algorithms scale when tasks are harder to solve using thefig.
reduction factors for the classification of variants e1 time for simplification ms presence conditions ordered by processing time simpbdd simpe simpqc fig.
time for simplification in a quantile plot e1 a point x y in the plot states that the x th fastest simplification with the respective algorithm took ymilliseconds the right most xvalue indicates the number of solved tasks the yaxis has a logarithmic scale table ii r eduction factors for defect location reporting e2 simpbdd simpe simpqc elevator .
.
.
e m ail .
.
.
same simplification tasks as in figure the time for simpqc and simpeis negligible for easy tasks but increases with harder tasks simpbdd needs between ms and500 ms in most cases however it can solve more problems than simpqc andsimpe.
note that in our setup simpbdd requires startup time for the jvm which dominates the processing time.
reporting defect locations e2 in e2 we consider verification of e m ailandelevator as application scenario.
note that e m ailandelevator are the same systems as in e1 but the considered presence conditions represent very different facts in e1 the presence conditions represent the prediction accuracy of the non functional property prediction approach .
in e2 the considered presence conditions point to configurations in which specifications of the configurable systems are violated as identified by spl verifier .
table ii shows the average reduction factor per case study and algorithm.
all three algorithms achieve significant improvements of the simplified expressions in terms of the reduction factors providing further evidence for rq1.
overall the reduction factors are very similar for all algorithms.
the maximum time measured for simplification was ms which is negligible.
code annotation simplification e3 in e3 we evaluate the potential for simplification of if conditions in source code.
before after a presence condition size .
.
.
.
.
.
b reduction factor fig.
experiment results for the typechef ast simplification on linux e4 overall we found only few situations where our approach could improve the presence conditions.
for detailed results of the experiment we refer to the supplementary website.
with all three algorithms and in all systems except gnuplot .
and libxml2 .
we could improve only less than of the parsable non trivial presence conditions.
if we could not parse the conditions this was usually due to non boolean configuration options.
most situations for which we could improve the conditions are rather simple similar to the example shown in figure .
the experiment e3 shows that our approach is feasible in the application scenario but there is only little potential for simplification in the considered systems.
if conditions in the analyzed systems do not contain much redundancy which indicates a good code quality.
so the expectation stated in rq1 does not hold in this application scenario for these systems.
ast annotation simplification e4 to evaluate the simplification potential in asts as generated by typechef we modified typechef such that it applies simplification to all presence conditions generated as ast annotations.
in particular we analyzed the ast conditions generated for linux .
.
.
the actual subject of e4 is typechef not linux so one version is sufficient .
figure shows the results by means of violin plots.
a violin plot contains a boxplot and shows also the probability density of the data.
in total we found non trivial presence conditions inlinux s ast.
figure 7a shows that most of these have less than literals.
however there is a substantial number of presence conditions that have an extremely large number of literals.
after simplification shown data generated with simpbdd the conditions have less than literals.
figure 7b shows the reduction factors observed with simpbdd the results are similar for simpeandsimpqc .
for most presence conditions we achieved extreme improvements which leads us to two conclusions confirming rq1 typechef introduces many redundancies during parsing because we did not observe similar sizes for linux in e3 and simplification can remove those redundancies from the ast.
cross tree constraint simplification e5 to evaluate the scalability of simpbdd simpe and simpqc rq2 we ran experiments with synthetic feature models of different sizes see scenario cross tree constraint simplification .
figure shows the time needed for simplification of the cross tree constraints in a quantile plot.
it supports the general resulttime for simplification ms presence conditions ordered by processing time simpbdd simpe simpqcfig.
scalability of simplification algorithms shown in a quantile plot e5 similar to the quantile plot in figure of e1 simpbdd has a higher processing time for simple tasks again consider jvm startup time but it can solve more tasks and is faster than simpeandsimpqcwhen it comes to harder tasks.
simpqcperforms better than simpe which was not to be expected because it is an earlier algorithm solving the same problem.
we were not able to run a complete evaluation for larger problem sizes because the computation of the input files for simpeandsimpqcis very expensive for harder problems.
when evaluating presence condition simplification on problem instances with options simpbdd still needs only ms on average when the bdd is already loaded in memory .
in summary the answer to rq2 is that simpbdd has a high base processing time ms but scales better than the other algorithms.
d. threats to validity a threat to internal validity is that we have no exact measure for the simplicity of boolean expressions.
this is a problem that is not specific to our work in general it is difficult to define such a measure.
we have tried a number of different measures and observed similar results so we expect our observations to hold with other sensible measures.
in addition we tried to use a ground truth for the minimal size measure in our experiments.
however even small problems require an infeasible amount of computations.
hence we focus on the comparison between the algorithms.
another threat to internal validity is that we used existing tools to compare the algorithms so we rely on that the tools actually implement the algorithms correctly.
still we verified that each simplification result satisfies equation .
a threat to the external validity as always is the selection of subject systems and application scenarios.
to mitigate this threat we selected a diverse set of application scenarios and subject systems.
our assumption that simplification can significantly improve presence condition size holds in all these scenarios except for code annotation simplification .
a possible threat to the external validity is that we can only handle boolean options.
however it has been shown that the majority of presence conditions in large configurable systems e.g.
kernels of linux andfreebsd can be expressed using only propositional expressions and that the large majority of options in configurable systems software is boolean .even if parts of the context cannot be expressed with boolean options a partial context can be used for simplification.
even though the majority of our subject systems and application scenarios are real our approach is certainly limited with respect to very large presence conditions.
we tried larger problem instances in experiment e5.
however for one variability model with options we had to generate an input file for simpewith gb which is not feasible.
for very large presence conditions the simplified presence condition will probably still be quite large so it is questionable whether simplification is even useful in such cases.
we argue that even if the result expression is still large every bit of size reduction helps if the result is used as input to an analysis tool.
if a user interprets the still large result the user might use tools such as dependency graphs.
such graphs are simpler once redundant information is removed by simplification.
v. r elated work simplification of presence conditions in the context of highly configurable systems has not been investigated before.
however work on variability model reasoning and the extraction of presence conditions is related.
variability model reasoning aims at analyzing properties of variability models e.g.
consistency or of sets of models e.g.
relationships between models to assure correctness and to support evolution and configuration of systems.
a common reasoning operation is to calculate differences between two variability models.
this problem is closely related to ours and has been explored before .
in general computing differences diffs between two entities aandbinvolves two tasks stripping the information of afrom band vice versa.
thus a diff is a pair of sub comparisons.
the main difference to our simplification problem is that a diff has to be exact.
that is all the information of bis removed from aandonly the remainder is presented to the user.
therefore applying model differencing methods on presence conditions has fewer means to influence the size of the presence condition.
our problem formulation gives us more leverage information that is contained in pand mcan either remain in simp p m or be removed.
we use this leverage to make simp p m smaller and more readable.
off the shelf reasoners such as bdd libraries or sat solvers are used for reasoning about boolean expressions.
scalability experiments show that sat solvers are more scalable than bdds for most analyses on feature models.
however bdds are efficient for analyses that rely on enumerating configurations they are known to scale up to models with features .
in our experiments simpbdd exhibited a better scalability than simpeandsimpqc but for smaller models and presence conditions and for a very different analysis which has not been investigated before.
good news is that the algorithms we tested scaled on generated models which are usually more complex and harder to reason about than real world models .
we are not aware of any sat based algorithm applicable to our problem.
however investigating the feasibility of using a sat solver would be valuable future work.various researchers have extracted and analyzed presence conditions in the context of highly configurable systems.
presence conditions have been extracted using static analysis from build systems and using dynamic analysis by compiling individual system variants .
all these pieces of work show the importance of complex presence conditions to realize the mapping between the variability model and implementation.
in fact presence conditions in source code and other artifacts are means to maintain the variability model by establishing a balance between constraints residing in the model and in other artifacts.
our experiments e3 have shown that the size of presence conditions in real systems is moderate suggesting that such systems are relatively well maintained.
in our search for simplification algorithms we have also looked at several research areas related to bdds and two level logic minimization.
in particular decomposable negation normal forms semantic tableaux and minimization of propositional formulae appeared promising at first sight but in the end we have not found algorithms applicable to our problem.
vi.
c onclusion we formally defined the problem of presence condition simplification a presence condition pis simplified with respect to its context m in which the presence condition is used.
it is not necessary and even obstructive for pto include information that is already guaranteed by m which offers simplification potential.
we provide solutions to this problem by mapping presence condition simplification to related problems developed in the 90s for different purposes namely two level logic minimization and the r estrict algorithm.
we discussed a variety of application scenarios for presence condition simplification in the area of development and analysis of highly configurable systems.
the application scenarios include the simplification of presence conditions representing defects found by variability aware analysis tools if conditions in source code and in variability aware asts and cross tree constraints in variability models.
in a series of experiments we evaluated the different algorithms concerning their effectiveness and processing time as well as the different application scenarios concerning their potential for simplification.
in our experiments we found substantial potential for simplification of presence conditions in many real use cases e.g.
performance prediction or defect reporting and the algorithms are suited well for simplification.
this suggests that our approach may produce good results in other contexts too.
our experiments have shown that reduction factors are usually better with simpbdd than with simpqcorsimpe.
concerning scalability we have shown that simpbdd can handle larger problems than simpqcor simpe.
in future work we plan to include presence condition simplification in a variety of analysis tools for configurable systems.
furthermore our work can serve as a basis for researchers to further investigate algorithms for presencecondition simplification.