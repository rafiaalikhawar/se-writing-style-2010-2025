iccta detecting inter component privacy leaks in android apps li li alexandre bartel tegawend e f. bissyand e jacques klein yves le traon steven arzt siegfried rasthofer eric bodden damien octeau patrick mcdaniel snt university of luxembourg firstname.lastname uni.lu ec spride technische universit at darmstadt firstname.lastname ec spride.de department of computer science and engineering pennsylvania state university octeau mcdaniel cse.psu.edu department of computer sciences university of wisconsin abstract shake them all is a popular wallpaper application exceeding millions of downloads on google play.
at installation this application is given permission to access the internet for updating wallpapers and use the device microphone to change background following noise changes .
with these permissions the application could silently record user conversations and upload them remotely.
to give more confidence about how shake them all actually processes what it records it is necessary to build a precise analysis tool that tracks the flow of any sensitive data from its source point to any sink especially if those are in different components.
since android applications may leak private data carelessly or maliciously we propose iccta a static taint analyzer to detect privacy leaks among components in android applications.
iccta goes beyond state of the art approaches by supporting intercomponent detection.
by propagating context information among components iccta improves the precision of the analysis.
iccta outperforms existing tools on two benchmarks for icc leak detectors droidbench and icc bench.
moreover our approach detects icc leaks in apps from malgenome and icc leaks in apps in a set of google play apps.
i. i ntroduction modern mobile operating systems have enhanced usage experience to allow users to easily install third party software.
with the growing momentum of the android operating system thousands of applications also called apps emerge every day on the official android market google play as well as on some alternative markets.
as of may billion apps have been installed from the google play store and as of september billion android devices have been activated .
the success of the android os in its user base as well as in its developer base can partly be attributed to its communication model named inter component communication icc which promotes the development of loosely coupled applications.
by dividing applications into components that can exchange data within a single application or even across several applications android encourages software reuse and thus reduces developer burden.
unfortunately the icc model which provides a message passing mechanism for data exchange among components can be misused by malicious apps to threaten user privacy.
indeed researchers have shown that android apps frequently send users private data outside the device without their priorconsent .
those applications are said to leak private data.
recently researchers have investigated icc methods as features for vulnerability detection in lieu of permissions and api calls.
however there is still a lack of a comprehensive study on the characteristics of the usage of iccs by android malware.
typically what is the extent of the presence of privacy leaks in android malware?
to answer such a question an android analysis tool has to be developed for tracking privacy leaks.
although most of the privacy leaks are simple i.e.
easily identifiable as they operate within a single component there have recently been reports of cross components privacy leaks .
thus analyzing components separately is not enough to detect leaks it is necessary to perform an inter component analysis of applications.
android app analysts could leverage such a tool to identify malicious apps that leak private data.
for the tool to be useful it has to be highly precise and minimize the false positive rate when reporting applications leaking private data.
in this paper we use a static taint analysis technique to find privacy leaks e.g.
paths from sensitive data called sources to statements sending the data outside the application or device called sinks.
a path may be within a single component or cross multiple components.
state of the art approaches using static analysis to detect privacy leaks on android apps mainly focus on detecting intra component sensitive data leaks.
chex for example uses static analysis to detect component hijacking vulnerabilities by tracking taints between sensitive sources and sinks.
flowdroid performs taint analysis within single components of android applications but with a better precision.
most recently amandroid has been proposed to detect icc based privacy leaks in android apps.
however it does not currently tackle content provider one of the four android components.
it is also not sensitive to some complicated icc methods such as bindservice and startactivityforresult .
thus we propose iccta an inter component communication taint analysis tool for a sound and precise detection of icc links and leaks.
although our approach is generic and can be used for any data flow analysis we focus in this paper on using iccta to detect icc based privacy leaks.
to verify our approach we developed apps containing icc based privacy leaks.
we have added these applications to droidbench anopen test suite for evaluating the effectiveness and accuracy of taint analysis tools specifically for android apps.
the apps cover the top used icc methods illustrated in table i. besides we test iccta on real world apps randomly selected from google play market in which we detect icc leaks in apps.
we also launch iccta on the malgenome set containing malware where iccta reports apps with icc leaks.
by comparing the detecting rate r of detected apps of tested appsof the two data sets we found that rmalgenome .
is much higher than rgoogleplay .
.
thus we can conclude that icc are significantly used by malware to leak private data making icc a potential feature for malware detection.
the contributions of this paper are as follows we present the findings of an empirical study on the use of icc in android malware and benign apps.
we propose a novel methodology to resolve the icc problem by directly connecting the discontinuities of android apps at the code level.
we developed iccta an open source tool for intercomponent taint analysis.
we provide an improved version of droidbench with new apps for the assessment of tools which detect iccbased privacy leaks.
finally we present an assessment of iccta using i the droidbench and icc bench test suites ii realworld android applications iii malware apps from malgenome.
we make available online our full implementation as an open source project along with the extended droidbench apps and the scripts to reproduce our experimental results on to better mitigate mobile icc leaks we also release the problematic apps from google play and from malgenome to the research community at the above website.
ii.
m otivation to motivate our work we present an overview of the android icc system highlighting the implications of its design and implementation choices in ii a. we further perform an empirical study of how iccs are used in android apps to expose the difference of usage between malware and benign apps cf.
section ii b .
finally we give a concrete example to introduce icc leaks in section ii c. a. android icc overview an android application is made up of basic units called components described in a special file the manifest included in the application package.
there are four types of components activities that represent user interfaces and constitute the visible part of android applications broadcast receivers that wait to receive event messages such as incoming calls or text messages from other components or the system content providers which act as the standard interface to share structured data between applications and services which execute compute intensive tasks in the background.
android service components are particular as their processing is hidden to the device user opening numerous opportunities for malicious actions.
android provides specific methods hereinafter referred to as icc methods for triggering inter component communications among any combinations of the above components.
icc methods take as parameter a special kind of object called intent which specifies the target component s for the message.
all icc methods1are called with at least one intent object as an argument.
to facilitate the use by some apps of existing features provided by other apps android allows to target components by specifying in the intent anaction to handle.
such intents are known as implicit intents .
when an implicit intent is used e.g.
for activities the system searches in the installed applications and presents the user with a list of applications capable of handling the action e.g.
choose a browser to open a url .
these intents may also specify categories amimetype and data for the target components.
in order to be selected for receiving the implicit intents applications containing the target components need to specify an intent filter in their manifest file declaring their capabilities to process such intents.
android however offers the possibility for components to directly interact with each other.
one component can thus send anintent to another by naming it explicitly.
these are known asexplicit intents .
b. icc usage in android apps to the best of our knowledge there have been no empirical investigation of the usage of icc in android apps.
yet given the importance of icc in the android development model as well as its potential correlation with malware functioning as introduced above a thorough study on real world apps can provide answers to the following important questions how often are iccs used in android apps?
this question will lead to the investigation of the extent to which each of the different icc methods are used in apps and what types of components they are targeting.
what kind of intents are used for icc in apps?
this question is important to estimate the differences in the instantiations of implicit intents andexplicit intents .
is the usage of icc different between malware and benign apps?
investigating this question may open directions for malware detection research which seeks reliable app features to use in machine learning processes.
datasets we attempt to provide answers to the questions above using two distinct datasets of over one thousand applications each.
the first dataset named malgenome includes android malware samples collected by zhou et al.
.
although the originally published dataset contains apps some of these apps share the same package names therefore we consider them as duplicates.
1exceptcontent provider related methods such as query or insert .malgenome googleplay0 the byte code size kilobyte a the bytecode sizemalgenome googleplay0 the number of intents b the total intentsm g m g0 the number of intents c3d c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c10 c3d c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c10 c22 c44 c55 c4a c57 c4a c55 c5a c34 c46 c53 c57 c4a c44 c46 c activity service the number of intents me ge mipgip me ge mipgip c3d c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c10 c3d c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c40 c10 c22 c44 c55 c4a c57 c4a c55 c5a c34 c46 c53 c57 c4a c44 c46 d explicit implicit fig.
the comparison between malgenome and googleplay apps.
m means malgenome g means googleplay ex means explicit and im means implicit.
to highlight the difference between median values we cut off some upper whiskers .
the second dataset hereafter referred to as googleplay is a set of1 023android apps2randomly selected from the official google market.
results we now present the findings of our investigation.
prevalence of iccs in app code first we compute the usage rate of icc methods.
to that end we parse the app byte code to count the instances of specific method calls based on a catalog of icc method names.
this analysis was performed on all the 2apps.
table i shows the usage rate of the icc method names separating the top most used from all other icc methods.
table i the top used icc methods.
when these methods are overloaded we consider the one with the most number of calls.
icc method of calls of apps startactivity .
.
startactivityforresult .
.
query .
.
startservice .
.
sendbroadcast .
.
insert .
.
bindservice .
.
delete .
.
other icc methods .
total the of calls represents the absolute number of icc method calls from the entire two sets.
the of apps represents the number of apps using at least once the corresponding icc method.
.
of the apps in our dataset use the startactivity icc method which accounts for .
of the total icc methods calls.
startactivity is used to launch a new activity component e.g.
to switch from one user interface window to another.
the second most used icc method is startactivityforresult which also launches a new activity component.
in this case however the flow goes back to the calling component.
then follows query an icc method used to access content providers.
startservice which appears in .
of the apps is used to launch a new service.
number of intents before computing details in the number of intents3in the code of dataset apps we compare the sizes of apps across the malgenome and googleplay sets.
2we choose apps to avoid a class imbalance issue.
3in this paper we do not distinguish the difference between intents and icc methods since basically an intent is corresponding to an icc method.fig.
1a represents the boxplot4of the size of the apps for both sets.
the median value for the malgenome set is kb whereas the median value is kb for the googleplay set.
we ensure that this difference of median sizes between the datasets is significantly different by performing a mannwhitney wilcoxon mww .
the resulting p value confirms that the difference is significant at a significance level5at .
.
to account for any potential bias that the difference of app sizes between datasets may introduce we proceed to normalize all results according to a unit of dex code size.
a normalized result nris obtained by applying the formula nr ir bs 100k whereiris the initial result and bsis the byte code size.
a absolute number of intents fig.
1b represents the boxplot of the normalised numbers of intents per apps.
the median number of intents is .5per 100kb per app for the malgenome dataset and .9for the googleplay dataset.
the mww test again shows that this difference is statistically significant.
malicious applications manipulate significantly more intents than benign apps b number of intents vs component types we further investigate the difference of number of intents per app in the two datasets by comparing the usage of intents for icc exchange with specific types of components.
fig.
1c shows the boxplot of number of intents used to launch an activity left two and a service right two .
the median values are respectively .50and0.50for the malgenome dataset and .48and0.00for the googleplay dataset.
c explicit intents vs implicit intents table ii provides comparison data on the proportion of implicit andexplicit intents among the overall numbers of intents .
in the malgenome set intents in total are found where .
are explicit intents .
in the google play set however only .
out of of the intents are explicit intents .
fig.
1d presents boxplots detailing the normalised number of implicit and explicit intents for both activity and service.
the median values between the malgenome dataset and the 4we use the r tool to draw the boxplot.
each boxplot contains five main horizontal lines.
from top to bottom maximum i.e.
the greatest value excluding outliers upper quartile of data points are above this line median lower quartile and minimum.
5given a significance level .
ifp value there is one chance in a thousand that the difference between the datasets is due to a coincidence.table ii comparison of the use of intents in the data sets.
dataset activity service receiver total expl.
impl.
expl.
impl.
expl.
impl.
expl.
impl.
malgenome google play googleplay dataset are close in the case of implicit intents.
on the other hand there is a larger difference for explicit intents.
we further confirm that this difference is statistically significant via the mww test using a significance level of .
.
malicious applications tend to use more explicit intents than benign apps.
this empirical investigation of icc in malware and benign apps highlights the importance of icc in the context of android app security management.
in particular the focus of this study has demonstrated that some android properties e.g.
possibility to explicitly target a component thus bypassing user s choice are exploited by malicious apps.
such apps can indeed leak private data across components.
after presenting our approach for detecting leaks that are related to icc we will perform a final experiment to investigate whether there is a correlation between the number of intents and the number of icc leaks.
a positive correlation will thus provide confirmation that icc can be explored as a feature for malware detection.
c. icc leaks we define a privacy leak as a path from sensitive data called source to statements sending this data outside the application or device called sink.
a path may be within a single component or across multiple components.
in this paper thesources andsinks we use are provided by susi .
telephonymanager telmnger default smsmanager sms default 3classactivity1 extends activity 4voidoncreate bundle state 5button to2 button findviewbyid to2a 6to2.setonclicklistener newonclicklistener 7voidonclick view v 8string id telmnger.getdeviceid 9intent i new intent activity1.this activity2.class 10i.putextra sensitive id 11activity1.this.startactivity i 13classactivity2 extends activity 14voidonstart 15intent i getintent 16string s i.getstringextra sensitive 17sms.sendtextmessage number null s null null listing a running example.
listing illustrates the concept of icc leak through a concrete example.
the code snippets present two activities activity 1andactivity .activity 1registers an anonymous button listener for the to2button lines .
an icc method startactivity is used by this anonymous listener.
when button to2is clicked the onclick method is executed and the user interface will change to activity .
anintent containing the device id lines considered as sensitive data is then exchanged between the two components by first attaching the data to the intent with the putextra method lines and then by invoking the icc methodstartactivity lines .
note that the intent is created by explicitly specifying the target class activity .
in this example sendtextmessage is systematically executed when activity 2is loaded since onstart is in the execution lifecycle of an activity .
the data retrieved from theintent is thus sent as a sms message to the specified phone number there is an icc leak triggered by button to2.
when to2is clicked the device id is transferred from activity 1toactivity 2and then outside the application.
in this paper we aim to perform static taint analysis for android apps to detect such inter component communication icc based privacy leaks.
in static taint analysis a leak k corresponds to a sequence of statements which starts from asourcesand ends with a sinkd.sources are identified as they return private data from the user s point of view into the application code while sinks are identified as they send data out of the application.
an icc leak is a special leak which contains in its statement sequence at least one icc method.
normally c s ne ationslash c d wherec s means the component of methods.
but in some cases c s can equal to c d .
take icc method startactivityforresult as an example component c1can use this method to start a component c2 in method m1 .
oncec2finishes running c1runs again in methodm2 with some result data returned from c2.
an icc leak may occur as m1 c2 m2but in this situation c m1 c m2 .
iii.
o urapproach in this section we introduce in section iii a the specificity of android apps that makes statically analyzing them difficult.
then we present an overview of our tool called iccta which is designed to detect icc leaks in section iii b. iccta uses a two step approach icc links extraction taint flow analysis for icc.
sections iii c and iii d detail these two steps respectively.
a. static analysis for android is difficult despite the fact that android apps are mainly programmed in java off the shelf static taint analysis tools for java do not work on android applications.
static analyzers for android need to be adapted mainly for three reasons.
the first reason is that as already mentioned android applications are made of components.
communications between components involve intent filter and intent .
the dynamic resolution done by the android system to match intent filter andintent induces a discontinuity in the control flow of android applications.
this specificity makes static taint analysis challenging by requiring pre processing of the code to resolve links between components.
take listing as an example analysis tools need to be able to find the link from icc methodstartactivity toactivity2 and to be able to propagate the intent iin line to method getintent in line .
the second reason is related to the user centric nature of android applications in which a user can interact a lot through the touch screen.
the management of user inputs isandroid appicc methodstarget components icc linksjimple jimple icc lifecycle callback tainted pathsicc links db .
.
.
taint paths db .
bytecode instrumentation .
taint analysis fig.
overview of iccta.
mainly done by handling specific callback methods such as theonclick line in listing method which is called when the user clicks on a button.
static analysis requires a precise model that simulates users behaviors.
the third and last reason is related to the lifecycle management of the components.
there is no main method as in a traditional java program.
instead the android system switches between states of a component s lifecycle by calling callback methods such as onstart oronresume .
however these lifecycle methods are not directly connected in the code.
modeling the android system allows to connect callback methods to the rest of the code.
b. iccta overview fig.
shows the overview of iccta our open source tool to detect icc leaks.
even if android apps are implemented in java an app is compiled into dalvik bytecode instead of the traditional java bytecode.
in a first step iccta uses dexpler to transform this dalvik bytecode into jimple a soot s internal representation .
soot is a popular framework to analyze java based apps.
in the second step arrows .
iccta extracts the icc links and in step stores them as well as all the collected data e.g.
icc call parameters or intent filter values into a database.
based on the icc links in step .
iccta modifies the jimple representation to directly connect the components to enable data flow analysis between components.
in step .
by using a modified version of flowdroid a high precise intra component taint analysis tool for android apps iccta builds a complete controlflow graph of the whole android application.
this allows propagating the context e.g.
the value of intents between android components and yielding a highly precise data flow analysis.
to the best of our knowledge this is the first approach that precisely connects components for data flow analysis.
at last step iccta stores the reported tainted paths leaks into database.
in both steps and we store all the results including the icc methods with their attribute values such as uri and intent the target components with their intent filter values the built icc links and the reported icc leaks into a database.
this allows to only analyze an app once and then reuse the results from the database.
in the next two sections we detail the main technical contributions of iccta which lie in steps 2and4.
modifications of activity1 activity1.this.startactivity i ipcsc.redirect0 i a creation of a helper class classipcsc static void redirect0 intent i activity2 a2 newactivity2 i a2.dummymain b modifications in activity2 publicactivity2 intent i this.intent for ipc i publicintent getintent return this .intent for ipc public void dummymain lifecycle and callbacks are called here c fig.
handling startactivity icc method.
c. icc links extraction in this section we detail our approach to extract the icc links of the analyzed apps.
an icc link l m cis used to link two components in which the source component contains an icc method mthat holds information e.g.
the class name for an explicit intent or the action category mimetype .
.
.information for an implicit intent to access the target component c. as shown in fig.
iccta uses three steps to extract the icc links from an app.
in step .
iccta leverages epicc to obtain the icc methods and their parameters e.g.
action of intents .
epicc is a tool based on soot and heros to identify icc methods as well as their parameter values e.g.
action category .
in iccta we use ic3 an advanced tool that implements the idea of epicc to also parse theuris e.g.
scheme host to support content provider related icc methods e.g.
query and to fully support the data field of intents.
in step .
iccta identifies all the possible target components by parsing the configuration file named androidmanifest of an app to retrieve the values of the intent filters .
in some situations analyzing the bytecode is also necessary since broadcast receiver can be registered at runtime.
in step .
we match icc methods with their target components i.e.
the intents with intent filters through the rules introduced by the android documentation .
d. taint flow analysis for icc in this section we detail our instrumentation approach to perform taint flow analysis for icc.
as detailed in section iii a there are three types of discontinuities in android icc methods lifecycle methods and callback methods.
we first describe how iccta tackles icc methods in section iii d1.
then we detail how iccta resolves lifecycle and callback methods in section iii d2.
icc methods in step .
of fig.
the jimple code is instrumented by iccta to connect components.
this code modification is required for all icc methods listed in table i .
the main idea of the transformation is to replace an icc method call with an instantiation of the target component with the appropriate intent .
we detail these modifications for the two most used icc methods startactivity and startactivityforresult .
we handle icc methods for service s and broadcast receiver s in a similar way.
startactivity.
fig.
shows the code transformation done by iccta for the icc link between activity 1andactivity 2of our running example.
iccta first creates a helper class named ipcsc b in fig.
which acts as a bridge connecting the source and destination components.
then the startactivity icc method is removed and replaced by a statement calling the generated helper method redirect0 a .
in c iccta generates a constructor method taking an intent as parameter a dummymain method to call all related methods of the component i.e.
lifecycle and callback methods and overrides the getintent method.
an intent is transferred by the android system from the caller component to the callee component.
we model the behavior of the android system by explicitly transferring the intent to the destination component using a customized constructor method activity intent i which takes an intent as its parameter and stores the intent to a newly generated field intent for ipc .
the original getintent method asks the android system for the incoming intent object.
the new getintent method models the android system behavior by returning the intent object given as parameter to the new constructor method.
the helper method redirect0 constructs an object of typeactivity the target component and initializes the new object with the intent given as parameter to the helper method.
then it calls the dummymain method of activity .
to resolve the target component i.e.
to automatically infer what is the type that has to be used in the method redirect0 in our example to infer activity iccta uses the icc links stored in step in which not only the explicit intents but also the implicit intents are resolved.
therefore there is no difference for iccta to handle explicit or implicit intents based iccs.
startactivityforresult.
a component c1can use this method to start a component c2.
oncec2finishes running c1runs again with some result data returned fromc2.
fig.
shows the control flow mechanism of startactivityforresult icc method.
there are two discontinuities one from to similar to the discontinuity of thestartactivity method and the other from to .
thestartactivityforresult icc method has a more complex semantic compared to common icc methods that only trigger one way communication between components e.g.
startactivity .
fig.
shows how the code is instrumented to handle the startactivityforresult method for fig.
.
to stay consistent with common icc methods we do not instrument the finish method of c2 to callonactivityresult method.
instead we generate a fieldintent for ar to store the intent which will be transferred back to c1.
the intent that will be transferred back is set by thesetresult method.
we override the setresult method to store the value of intent tointent for ar .
the helper method ipcsc.redirect0 does two modifications to link these two components directly.
first it calls the dummymain method of the destination component.
then it calls the onactivityresult method of the source component.
act.startactivityforresult i ipcsc.redirect0 act i a voidsetresult intent i this.intent for ar i publicintent getintentfar return this .intent for ar c classipcsc static void redirect0 c1 c1 intent i c2 c2 newc2 i c2.dummymain intent reti c2.getintentfar c1.onactivityresult reti b fig.
handing the startactivityforresult icc method.
a and c represents the modified code of c1andc2respectively.
b is the glue code connecting c1andc2.
some method parameters are not represented to simplify the code.
android systemc1 entry point startactivityforresult onactivityresultc2 entry point setresult finishc1c2 fig.
the control flow of startactivityforresult .
lifecycle and callback methods one challenge when analyzing android applications is to tackle the callback methods and the lifecycle methods of components.
an introduction about lifycycle and callback methods can be found in .
there is no direct call among those methods in the code of applications since the android system handles lifecycles and callbacks.
for callback methods we need to take care of not only the methods triggered by the user interface ui events e.g.
onclick but also callbacks triggered by java or the android system e.g.
the oncreate method .
in android every component has its own lifecycle methods.
to solve this problem iccta generates a dummymain method for each component in which we model all the methods mentioned above so that our cfg based approach is aware of them.
note that flowdroid also generates a dummymain method but it is generated for the whole app instead of for each component like we do.
iv.
e valuation our evaluation addresses the following research questions rq1 how does iccta compare with existing tools?
rq2 can iccta find icc leaks in real world apps?
rq3 what is the runtime performance of iccta?
all the experiments discussed in this section are performed on a core i7 cpu running a java vm with 8gb of heap size.
a. rq1 comparison with existing tools in this research question we compare iccta with four existing tools flowdroid ibm appscan source .
didfail and amandroid .
flowdroid is a state of theart open source tool for intra component static taint analysis appscan source is a commercial tool released by ibm while didfail and amandroid are two recent state of the art tools for detecting android icc leaks.
all the tools are able to directly analyze android bytecode except appscan source which is only able to analyze the source code of the apps.
unfortunately we were unable to compare iccta with otherstatic taint analysis tools as either they fail to report any leaks e.g.
scandroid or their authors did not make them available e.g.
sefa .
experimental setup we assess the efficacy of all aforementioned tools by running them against about test cases for icc leaks from two benchmarks droidbench and iccbench.
droidbench.
droidbench is a set of hand crafted android applications for which all leaks are known in advance.
these leaks are used as ground truth to evaluate how well static and dynamic security tools find data leaks.
droidbench version .
contains different test cases with different privacy leaks.
however all the leaks in droidbench are intracomponent privacy leaks.
thus we developed test cases to extend droidbench with icc leaks.
the new set of test cases covers each of the top icc methods in table i. among the new test case applications we included four startactivity that do not contain any privacy leaks and thus will help detect false alarm rates of analysis tools.
finally for each test case application we add an unreachable component containing a sink.
these unreachable components are used to flag tools that do not properly construct links between components.
icc bench.
icc bench is another set of apps introduced by amandroid .
it contains test case applications where one of them uses explicit intents of them use implicit intents and the remaining two use dynamic techniques to register the target component.
however each of the test case applications indeed contain one icc leak and do not contain any unreachable component as droidbench does.
because the source code of apps in the icc bench were not available we could not evaluate appscan on this benchmark.
icc data leak test table iii presents the results for comparing how related tools perform in the detection of icc leaks.
all added to droidbench from icc bench test cases and the corresponding detection outcome for the tools are listed in this table.
flowdroid.
because flowdroid has already been evaluated on the first version of droidbench we present in table iii its test results for the newly added test cases which are dedicated to icc leaks.
although as mentioned earlier flowdroid was initially proposed to detect leaks in single android components we can use flowdroid in a way that it computes paths for all individual components and then combines all these paths together whether there is a real link or not .
thus we expect flowdroid to detect most of the leaks although with false positives.
results of table iii confirm this since flowdroid shows a high recall .
and a low precision .
.
furthermore flowdroid misses three more leaks than iccta in bindservice .
after investigation we discovered that this is due to the fact that flowdroid does not consider some callback methods for service components.
appscan source .
.
appscan requires a lot of manual initialization work since it has no default sources sinks configurationfile and is unable to analyze android applications without specifying the entry points of every component.
we define thegetdeviceid andlog methods which we always use in droidbench for icc leaks as source and sink respectively.
we also add all components entry point methods such as oncreate for activities as callback methods so appscan knows where to start the analysis.
appscan is natively unable to detect inter component data flows and only detects intra component flows.
appscan has the same drawbacks as flowdroid and should have a high recall and low precision on droidbench.
we use an additional script to combine the flows between components.
as expected appscan s recall is high .
and its precision is low .
.
compared to flowdroid appscan does worse.
indeed appscan does not correctly handle startactivityforresult and thus misses leaks going through methods receiving results from the called activities in startactivityforresult test cases.
didfail.
since didfail does not handle explicit icc it fails to report leaks for test cases that use explicit intents between components.
for implicit icc it is able to report all the leaks for test cases implicit even when those implicit iccs use advanced features like mimetype ordata .
however didfail fails on case startactivity test cases indicate that didfail is not sensitive on mimetype anddata .
our assumption is that didfail uses an overapproximation approach to build implicit icc links.
as long asaction andcategory are matched an icc link is constructed.
indeed startactivity usemimetype ordata but do not contain any real icc link.
because didfail currently only focuses on activity it fails to report any leak for the service broadcast receiver dynamically registered or not and content provider test cases.
amandroid.
amandroid is the most recent state of the art tool that is able to detect icc leaks.
overall for the test cases amandroid reaches a precision of .
true positives false positives and a recall of .
missed leaks .
three of the missed leaks and two of the false alarmed leaks are caused by startactivityforresult where amandroid is not able to combine setresult method to onactivityresult method.
the startservice2 test case usesintentservice instead of service which is used by test case startservice1 to implement the service.
amandroid is able to report a leak on startservice1 but fails to report a leak on startservice2 .
this indicates that it does not completely model service s lifecycles.
when the callback method changes from onstartcommand to onhandleintent amandroid is not able to deal with it anymore.
eight other missed leaks indicate that amandroid currently does not handle the bindservice method and content provider components.
amandroid reports two false positives for startactivity which indicates that it is not able to distinguish the extra keys of an intent.
indeed startactivity do not contain anyleaks because they use different extra keys for the transferred intent.
finally amandroid misses a leak on test case dynregister2 becausedynregister2 uses string operations e.g.
stringbuilder objects to contact multiple strings which amandroid cannot parse.
iccta.
our tool iccta also misses a leak on case dynregister2 like amandroid because currently it cannot parse complicated string operations as well.
the same reason causes iccta to yield a false positive on case startactivity7 where one extra key is built through complicated string operations.
the current version of iccta performs a simple string analysis to distinguish the extra keys of an intent between one another.
iccta outperforms both the commercial and academic tools by achieving a precision of .
and a recall of .
on droidbench and icc bench.
b. rq2 experimental results on real world apps to evaluate our approach we launch iccta on two android app sets malgenome which contains malware apps and from googleplay with randomly selected apps.
formalgenome iccta reports apps rmalgenome .
containing at least one icc leak with a total of leaks.
and for googleplay iccta detects apps rgoogleplay .
with icc leaks.
since rmalgenome is significantly higher than rgoogleplay we can conclude that malware indeed use icc to leak private data.
we further studied the correlations between the number of intents and the number of detected icc leaks for the two data sets.
in this study only apps that contain icc leaks are considered.
interestingly our results show that there is no correlation for googleplay apps.
however there exists a positive correlation formalgenome .
the spearman s rho for malgenome yielded the value .
p value .
suggesting that the malware do use icc to leak private data.
in total iccta detects apps from the malgenome and googleplay sets.
we summarize the most frequently used source methods and sink categories java classes from those apps in table iv.
the most used source method isgetlongitude it is used times.
the most used sink category is sharedpreferences it is used times.
the reason why we study sink category instead of sink methods is that there are a lot of sink methods belonging to a same sink category e.g.
log sink category includes eight sink methods which save private data to disk .
we further studied the sourcemethod sinkcategory pairs of the detected leaks.
we found that the most frequently used pair is getlongitude sharedpreferences which happened times.
for example in malgenome app com.evilsunflower.farmer obtains its longitude in classsetpreferences and transfers it into component pushservice in which the longitude is leaked.
it also frequently happened in googleplay such as in app infire.beautyleg.sexy.girls andro.an.moneymanagerfree .
now we give one case study to describe the detail of a leak.
com.wanpu.shuijinddp version is an app in whichtable iv the top used source methods and sink categories method type counts detail source methods getlongitude get longitude getlatitude get latitude getdeviceid get imei or esn getlastknownlocation get location getline1number get phone no.
of line sink categories sharedpreferences putint putstring http execute log error or warn file write string message sendtextmessage an icc leak has been reported by iccta.
it takes the device id we consider the device id as sensitive data as an unique user id to communicate with a remote server6via http.
it first reads the device id and stores the id to a private field in class com.waps.appconnect .
then method showoffers of classappconnect transfers the device id to component offerswebview in which the device id has been sent to a remote server through a http parameter.
in this case the device id has been leaked to a specified remote server through an icc.
besides the device id may be captured by hackers since it only uses http instead of https to communicate with the remote server.
finally we investigated the total reported leaks and we found that out of .
leaks are leaked through service components.
these findings are interesting since using icc makes leak detection difficult for analysis tools while using service s hides those leaks to the user.
indeed service components are running in the background with no interaction with the user contrary to activity components .
we were able to find icc leaks in a large set of realworld apps.
correlation studies have further revealed that malware are indeed using icc to leak private data.
c. rq3 runtime performance we present the runtime performance analysis of flowdroid amandroid and iccta in fig.
.
we randomly selected apps from our googleplay set for our study.
among those only apps have been successfully analyzed by all three tools altogether.
first we compare the performance between flowdroid and iccta1to check whether our bytecode instrumentation step influences the final performance or not.
as shown in fig.
the performance of iccta 1is almost as good as flowdroid.
indeed an icc link introduces lines of jimple code on average which is negligible comparing to the total code lines e.g.
lines for megabyte bytecode on average .
second and finally we compare the performance between iccta2and amandroid.
in this case we take into account the icc links extraction time for a fair comparison since amandroid also builds the icc links.
fig.
shows that the median values of iccta and amandroid are similar.
however the runtime performance of iccta 2presents significantly less variation than amandroid s suggesting that amandroid is highly sensitive to different properties e.g.
size of the app.
iii test results on droidbench and icc bench where multiple circles in one row means multiple leaks expected and an all empty row means no leaks expected as well as no leaks reported.
indicates the tool crashed on that test case.
because flowdroid and appscan are not able to directly report icc leaks we try our best to manually match their results to report icc leaks.
for the rest tools we only consider their reported icc leaks.
true positive correct warning false positive false warning false negative missed leak test case of c. unreachable c. explicit icc flowdroid appscan didfail amandroid iccta droidbench startactivity1 t t startactivity2 t t startactivity3 t t startactivity4 t f startactivity5 t f startactivity6 t t startactivity7 t t startactivityforresult1 t t startactivityforresult2 t t startactivityforresult3 t t startactivityforresult4 t t startservice1 t t startservice2 t t bindservice1 t t bindservice2 t t bindservice3 t t bindservice4 t t sendbroadcast1 t f insert1 t f delete1 t f update1 t f query1 t f icc bench explicit1 f t implicit1 f f implicit2 f f implicit3 f f implicit4 f f implicit5 f f implicit6 f f dynregister1 f f dynregister2 f f sum precision recall and f higher is better lower is better lower is better precision p .
.
.
.
recall r .
.
.
.
.
f1 measure 2pr p r .
.
.
.
.
time s flowdroid iccta amandroid iccta 2fig.
the runtime performance comparison among amandroid flowdroid and iccta.
iccta 1does not count the icc links extraction time while iccta 2does.
all the experiments are performed with the default options.
v. l imitations at the moment iccta resolves reflective calls only if their arguments are string constants.
it is also oblivious to multi threading.
for native calls iccta carries the limitation of flowdroid.
currently iccta does not handle some rarely used icc methods such as startactivities andsendorderedbroadcastasuser .
iccta cannotresolve complicated string operations e.g.
by using stringbuilder and the string analysis is within a single method which may cause false alarms.
in android inter app communication iac shares the same mechanism as icc.
thus our approach is also able to detect iac leaks cf.
but in this paper we do not perform experiments on that.
we experienced that iccta cannot properly analyze some apps too much memory consumption or hangs .
running iccta on a big server could significantly decrease the failing rate.
vi.
r elated work as far as we know iccta is the first approach to seamlessly connect android components through code instrumentation in order to perform icc based static taint analysis.
by using a code instrumentation technique the state of the context and data e.g.
an intent is transferred between components.
amandroid performs an icc analysis to detect icc leaks and has been developed concurrently with iccta.
amandroid needs to build an inter component data flow graph icdfg and an data dependence graph ddg to perform icc analysis.
since iccta uses an instrumentation approach it does not need to additionally build such assistant graphs.
amandroid provides a general framework to enable analysts to build a customized analysis on android apps.
iccta provides asource sink configuration to achieve the same function.
amandroid is not able to analyze content provider as well as some icc methods such as bindservice and startactivityforresult .
finally our instrumentation approach is more flexible and enables generating an app with all components linked at the code level.
this app can then be analyzed by any static analysis tool e.g.
soot or wala .
didfail also leverages flowdroid and epicc to detect icc leaks.
currently it focuses on icc leaks between activities through implicit intents.
thus it will miss leaks involving explicit intents and components other than activities .
also it does not handle some parameters for implicit intents such as mimetype anddata and thus generates false links between components.
the consequence of that is a higher false positive rate.
scandroid and sefa are another two tools that perform icc analysis.
however neither of them keeps the context between components and thus are less precise than iccta by design.
comdroid and epicc are two tools that tackle the icc problem but mainly focus on icc vulnerabilities and do not taint data.
chex is a tool to detect component hijacking vulnerabilities in android applications by tracking taints between sensitive sources and externally accessible interfaces.
however it is limited to at most object sensitivity which leads to imprecision in practice.
pcleaks performs data flow analysis to detect potential component leaks which not only includes component hijacking vulnerabilities but also component launch or injection vulnerabilities.
contentscope is another tool that tackles potential component leaks but it only analyzes content provider components.
multiple prior works use static analysis to detect intracomponent privacy leaks in android apps .
androidleaks and leakminer state the ability to handle the android lifecycle including callback methods but the two tools are not context sensitive which precludes the precise analysis of many practical scenarios.
however those tools are not able to detect icc leaks.
asdroid and appintent are two other tools using static analysis to detect privacy leaks in android apps.
both of them try to analyze if a data leak is a feature of the application or not.
this kind of analysis is out of the scope of this paper.
multiple prior works investigated privacy leaks on systems other than android.
pios uses program slicing and reachability analysis to detect the possible privacy leaks in ios apps.
taj and andromeda uses the same taint analysis technique to identify privacy leaks in web applications.
except privacy leaks detection there has been a rich body of work on other android security issues such as energy bugs and ssl vulnerabilities .
our work can complement their research by providing a highly precise control flow graph toenable them to perform inter component data flow analysis and consequently to get better results.
other approaches dynamically track the sensitive data to report security issues.
taintdroid is one of the most sophisticated dynamic taint tracking system.
taintdroid uses a modified dalvik virtual machine to track flows of private data.
copperdroid is another dynamic testing tool which observes interactions between android components and the linux system to reconstruct high level behavior and uses some special stimulation techniques to exercise the app to find malicious activities.
several other systems including appfence aurasium appguard and betterpermission try to mitigate the privacy leak problem by dynamically monitoring the tested apps.
however those dynamic approaches can be fooled by specifically designed methods to circumvent security tracking .
thus dynamic tracking approaches may miss some data leaks and yield an under approximation.
on the other hand static analysis approaches may yield an overapproximation because all the application s code is analyzed even code that will never be executed at runtime.
these two approaches are complementary when analyzing android applications for data leaks.
vii.
c onclusion this paper addresses the major challenge of performing data flow analysis across multiple components for android apps.
we have presented iccta an open source tool to perform icc based taint analysis.
in particular we demonstrate that iccta can detect icc based privacy leaks by providing a highly precise control flow graph through instrumentation of the code of applications.
unlike previous approaches iccta enables a data flow analysis between two components and adequately models the lifecycle and callback methods to detect icc based privacy leaks.
when running iccta on droidbench and icc bench it reaches a precision of .
and a recall of .
.
when running iccta on a set of apps of the malgenome project it reports icc leaks in apps .
.
when running iccta on a set of realworld apps randomly selected from google play market it detects icc leaks in apps .
.
other existing privacy detecting tools e.g.
androidleaks could benefit by implementing our approach to perform icc based privacy leaks detection.