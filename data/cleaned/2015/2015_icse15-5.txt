trivial compiler equivalence a large scale empirical study of a simple fast and effective equivalent mutant detection technique mike papadakis yue jia mark harman and yves le traon interdisciplinary centre for security reliability and trust university of luxembourg luxembourg crest centre university college london uk michail.papadakis uni.lu mark.harman ucl.ac.uk yue.jia ucl.ac.uk and yves.letraon uni.lu abstract identifying equivalent mutants remains the largest impediment to the widespread uptake of mutation testing.
despite being researched for more than three decades the problem remains.
we propose trivial compiler equivalence tce a technique that exploits the use of readily available compiler technology to address this long standing challenge.
tce is directly applicable to real world programs and can imbue existing tools with the ability to detect equivalent mutants and a special form of useless mutants called duplicated mutants.
we present a thorough empirical study using large open source programs several orders of magnitude larger than those used in previous work and benchmark programs with hand analysis equivalent mutants.
our results reveal that on large real world programs tce can discard more than and of all the mutants as being equivalent and duplicated mutants respectively.
a humanbased equivalence verification reveals that tce has the ability to detect approximately of all the existing equivalent mutants.
i. introduction mutation testing has been shown to be a valuable testing technique capable of simulating real faults and almost every other testing adequacy criteria .
mutants are versions of the program under test in which a fault is deliberately inserted in order to either assess test effectiveness or to support generation of effective tests .
despite its undisputed potential the perception of mutation testing is that it is expensive.
this is partly due to the large number of mutants and partly because of the equivalent mutant problem the topic of this paper.
while the problem of the large number of mutants has largely been addressed in the literature by techniques such as mutant sampling and the mutant execution optimisations the equivalent mutant problem remains a challenge particularly because the underlying scientific question is undecidable .
the problem with equivalent mutants is that we may make a syntactic change to a program yet leave its semantics unaffected some mutants may prove to be equivalent to the original program from which they are constructed.
unfortunately the question of program equivalence of course undecidable so we can never hope for a complete solution to the equivalent mutant problem.if we can find fast scalable and reasonably effective ways to reduce the incidence of equivalent mutants we may sufficiently overcome the practical ramifications of equivalent mutants.
the equivalent mutant problem is such a large stumbling block to mutation testing that many researchers believe that its effective removal would be sufficient to make mutation testing practical and widely applicable.
our goal is to provide empirical evidence to support the claim that a straightforward and effective equivalent mutant detection technique already exists yet it is not exploited.
recently several mutation testing tools have been implemented for popular programming languages like c and java .
however none includes anytechnique for equivalent mutant detection.
our results demonstrate that a simple scalable and widelyapplicable technique which we call trivial compiler equivalence tce can be exploited to imbue existing mutation tools and techniques with the ability to detect as many as of equivalent mutants.
we present results that evaluate tce on benchmarks with known sets of equivalent mutants and also large scale systems several orders of magnitude larger than those used in any previous work on equivalent mutant detection.
our tce approach has now been incorporated into the m ilumutation testing tool making it the first tool that supports equivalent mutant detection fully automated.
we present a thorough empirical study of tce s potential to address this long standing mutation testing challenge.
our results are surprising the simple tce approach can detect about of all equivalent mutants thereby having the potential to dramatically save human effort in mutation testing.
since the technique is conservative all identified equivalent mutants can safely be discarded.
tce has other applications in mutation testing and beyond.
for example in mutation testing there would be no point in including two mutants that are equivalent to each other even if they are not equivalent to the original program from which they are constructed either one or the other of these two mutually equivalent mutants can be discarded saving some effort.
we refer to these mutants as duplicated mutants.
this question of mutual mutant equivalence has not been studied before.
our findings show that at least of mutants are duplicated and can be discarded.our findings may also have implications beyond mutation testing.
for example in software development environments it is quite often the case that developers make small changes to a system for example to fix the bug the inverse of mutate testing which insert synthetic bugs .
the question arises as to whether it would be worthwhile for the software development environment to include as a sanity check a check for equivalence using tce.
our results suggest that this is possible given the compilation time involved but more importantly our results show that it is also potentially useful of all simple edits mutants turn out to be tce equivalent.
surely a developer would like to have this sanity check information available after each edit?
the rest of the paper is organized as follows section ii presents mutation testing and related approaches.
section iii details our experiment and the studied research questions while section iv analyses our results.
our findings are discussed in section v. finally the threats to validity and our conclusions are presented in sections vi and vii.
ii.
b ackground a. mutation testing mutation testing embeds artificial defects on the programs under test.
these defects are called mutants and they are produced by simple syntactic rules e.g.
changing a relational operator from to .
these rules are called mutant operators .
by applying an operator only once i.e.
the defective program has only one syntactic difference from the original one a mutant called a first order mutant is produced.
by making several syntactic changes i.e.
applying the operators multiple times a higher order mutant is produced.
in this paper we consider only first order mutants.
these are generated by applying the operators at all possible locations of the program under test as supported by the current version of m ilu.
by measuring the ability of the test cases to expose mutants an effectiveness measure can be established.
mutants are exposed when their outputs differ from those of the original program.
when a mutant is exposed it is called as killed while in the opposite case it is called as live.
of course ideally equivalent mutants should be removed from the test effectiveness assessment.
so gives the effectiveness measure called mutation score i.e.
the ratio of the exposed mutants to the number of the introduced excluding the equivalent ones.
undecidability of equivalencies means that it is unrealistic to expect all the equivalent mutants to be removed the best we can have here is just effective algorithms that can remove most equivalent mutants.
currently a large number of mutants must pass a manual equivalence inspection .
this constitutes a significant cost.
in addition effort is wasted when testers generate test cases either manually or automatically in attempting to kill equivalent mutants.
apart from the human effort there is a computational cost since equivalent mutants cannot be killed they have to be exercised on the entire test suite whereas killable mutants only require the executions until they are killed.b.
equivalent mutants early research on mutation testing has demonstrated that deciding whether a mutant is equivalent is an undecidable problem .
fortunately partial and heuristic solutions exist .
however tackling the equivalent mutant problem is hard.
this is evident by the fact that very few attempts exist.
in literature this problem is tackled in two ways.
one is to address the problem directly by detecting some equivalent mutants while the second one is to avoid them by identify likely nonequivalent ones or help with the manual analysis.
we refer to them as the detect andreduce approaches respectively.
table i summarizes the current state of the art techniques in chronological order.
from this table it becomes evident that very few methods and tools exist.
regarding the equivalent mutant detection only one publicly available tool exist with the largest considered subject being composed of lines of code.
it is noted that all the large subjects i.e.
having more than lines of code that were used in the previous research involve a form of sampling.
mutants are sampled from the studied projects with no information about the relevant size of the components classes that these mutants are located.
in these lines in table i we report the size of the projects that we consider.
acree studied killable and equivalent mutants and found that testers correctly identified equivalent mutants for approximately of the cases.
in of the cases they identified equivalent mutants as killable while in of the cases they identified killable mutants as equivalent.
therefore indicating that detection techniques such as the one suggested by the present paper not only help at saving resources but also at reducing the mistakes made by the humans.
the idea of using compiler optimization techniques to detect equivalent mutants was suggested by baldwin and sayward .
the main intuition behind this technique is that code optimization rules such as those implemented by compilers form transformations on equivalent programs.
thus when the original program can be transformed by an optimization rule to one of its mutants then this mutant is ipso facto equivalent.
baldwin and sayward proposed adapting six compiler optimization transformations.
these transformations were then studied by offutt and craft who implemented them inside mothra a mutation testing tool for fortran.
they found that on average of the equivalent mutants can be detected.
our approach is inspired by this recruitment of compilers research to assist in equivalent mutant detection.
however we propose a truly simple and therefore scalable and directly exploitable use of compilers which remained unexplored.
our tce simply declares equivalencies only for those mutants which their compiled object code is identical to the compiled object code of the original program.
offutt and pan developed an automatic technique to detect equivalent mutants based on constraint solving.
this technique uses mathematical constraints to formulate the killing conditions of the mutants.
if these conditions are infeasible then the mutants are equivalent.table i summary of the related work on equivalent mutants.
author s year languagelargest subject eq.
mutantsavailable toolcategory findings baldwin sayward detect compiler optimization can be used to detect eq.
mutants acree fortran detect humans make mistakes when they identify eq.
mutants offutt craft fortran detect compiler optimization can detect on average of eq.
mutants offutt pan fortran detect constraint based testing can detect on average of eq.
mutants voas mcgraw detect slicing may be helpful in detecting eq.
mutants hierons et al.
detect reduceprogram slicing can be used to detect and assist the identification of eq.
mutants harman et al.
detect reducedependence analysis can be used to detect and assist the identification of eq.
mutants adamopoulos et al.
reduce co evolution can help in reducing the effects of eq.
mutants grun et al.
java reduce coverage impact can be used to classify killable mutants schuler et al.
java reduce invariants violations can be used to classify killable mutants schuler zeller java reduce coverage impact can be used to classify killable mutants nica wotawa java detect constraint based testing can detect eq.
mutants kintis et al.
java reduce higher order mutants can be used to classify killable mutants kintis malevris java detectdata flow patterns can detect of the eq.
mutants introduced by the aois operator papadakis et al.
c reduce coverage impact can be used to classify killable mutants this paper c detectcompilers can be used to effectively automate the mutant equivalence detection nica and wotawa implemented a similar constraintbased approach to detect equivalent mutants and demonstrated that many equivalent mutants can be detected.
voas and mcgraw suggested that program slicing can help in detecting equivalent mutants.
later hierons et al.
showed that amorphous program slicing can be used to detect equivalent mutants as well.
although potentially powerful these techniques suffer from the inherent limitations of the constraint based and slicing based techniques.
it is evident that the constraint based approach was assessed on programs consisting of lines of code at maximum while the slicing technique remains unevaluated apart from worked examples.
the scalability of these approaches is inherently constrained by the scalability of the underlying constraint handling and slicing technology.
furthermore a new implementation is required for every programming language to be considered.
by contrast tce applies to any language for which a compiler exists and so is as scalable as the compiler itself.
kintis and malevris used data flow patterns to detect equivalent mutants.
they showed that of the equivalent mutants produced by the aois operator i.e.
insertion of the increment decrement operator can be detected.
since this approach works only on one operator lacks implementation and its evaluation was based on instances it leaves the practicality and scalability questions open.
hierons et al.
suggested using program slicing to reduce the size of the program considered during the equivalence identification.
thus tester can focus on the code relevant to the examined mutants.
harman et al.
also suggested using dependence based analysis as a complementary method to assist in the detection of equivalent mutants.adamopoulos et al.
suggested the use of coevolutionary techniques to avoid the creation of equivalent mutants.
in this approach test cases and mutants are simultaneously evolved with the aim of producing both high quality test cases and mutants.
however these previous approaches have been evaluated only on case studies and synthetic data so their effectiveness and efficiency remains unknown.
more recently several studies sought to measure the impact of mutant execution.
instead of finding a partial but exact solution to the problem as done by the detect approaches they try to classify the mutants to help identify likely killable ones and likely equivalent ones based on their dynamic behavior.
this idea was initially suggested by grun et al.
and developed by the studies of schuler et al.
and schuler and zeller who found that impact on coverage can accurately classify killable mutants.
papadakis et al.
proposed a mutation testing strategy that takes advantage of mutant classification.
kintis et al.
further develop the approach using the impact of mutants on other mutants i.e.
using higher order mutants.
c. reducing the cost of mutation testing mutant sampling has been suggested as a possible way to reduce the number of mutants.
empirical results demonstrate that even small samples can be used as cost effective alternatives to perform mutation testing and .
other approaches select mutant operators.
instead of sampling mutants at random they select mutant operators that are empirically found to be the most effective.
to this end offutt et al.
demonstrated that five mutant operators are almost as effective as the whole set of operators.more recently namin et al.
used statistically identified optimal operator subsets.
other cost reduction methods involve mutant schemata .
this technique works by parameterizing all the mutants through instrumentation i.e.
introduce all the mutants into one parameterized program.
however apart from the inherent limitations of this technique and the execution overheads that introduces it also makes all the equivalent mutant detection techniques not applicable.
other approaches identify redundant mutants that fail to contribute to the testing process.
kintis et al.
defined the notion of disjoint mutants i.e.
a set of mutants that subsumes all the others and found to subsume all.
ammann et al.
defined minimal mutants showing that this may reduce the number of mutants.
kaminski et al.
and just et al.
leverage the suggestions made by tai on fault based predicate testing and demonstrated it possible to reduce the redundancy within the relational and logical operators.
higher order mutation can also reduce mutant numbers sampling and searching within the space of higher order mutants both reduce the number of mutants and also of the equivalent mutants.
iii.
e xperimental study and settings this section details the settings of our experiment.
it presents the tce approach in iii a our research questions in iii b the programs used in iii c the employed mutant operators in iii d and the execution environment in iii e. a. detecting mutant equivalencies the tce approach executable program generation involves several transformation phases that change the machine code.
different optimization transformation techniques result in different executables.
however when we have multiple program versions with identical source code then there is no point differentiating them with test data it is safe to declare them as functionally equivalent.
tce realizes this idea to detect mutant equivalencies.
it declares equivalent any two program versions with identical machine code.
tce simply compiles each mutant comparing its machine code with that of the original program.
similarly tce also detects duplicated mutants by comparing each mutant with the others residing in the same unit i.e.
function.
as the reader will readily appreciate tce implementation is truly trivial hence the name it is a compile command combined with a comparison of binaries.
b. research questions the mutation testing process is affected by the distorting effects of the equivalent and duplicated mutants on the mutation score calculation.
therefore a natural question to ask is how effective is the tce approach at detecting equivalent and duplicated mutants.
this poses our first rq rq1 effectiveness how effective is the tce approach at detecting equivalent and duplicated mutants?
we answer this question by reporting the prevalence of the equivalent and duplicated mutants detected by the tce approach using gcc.to reduce the confounding effects of different compiler configurations we apply four popular options and report the number of the equivalent and duplicated mutants found.
the answer to this question also allows the estimation of the amount of effort that can be saved by the tce method.
existing literature on mutant equivalent detection techniques suffers from performance and scalability issues.
as a result the authors are unaware of any mutation testing system that includes a proposed equivalent mutant detection.
by contrast the tce is static and can be applied to any program that can be handled by a compiler.
this makes tce potentially scalable but we need some empirical study to determine the degree to which it scales.
hence in our second rq we seek to investigate the observed efficiency and the scalability of the tce approach rq2 efficiency how efficient and scalable is the tce approach?
to demonstrate the scalability we use six large open source projects and we report the efficiency of the mutant generation equivalent mutant detection and duplicated mutant detection processes.
we also explored the trade off between the effectiveness and efficiency using different compiler settings.
to decide when it is appropriate to stop the testing process testers need to know the mutation score.
to this end they need to identify equivalent mutants.
the tce approach improves the approximation by determining equivalent mutants.
however to what extent?
this is investigated by our next rq rq3 equivalent mutants what proportion of the equivalent mutants can be detected?
what types of equivalent mutants can be detected?
to answer rq3 we need to know the ground truth how many equivalent mutants are there in the subjects studied?
we therefore applied the tce approach on a benchmark set with hand analysed ground truth data on equivalent mutants.
the benchmark includes manually identified equivalent mutants over small and medium sized subjects.
we report the proportion of the equivalent mutants found by the tce.
we also analyse and report the types of the detected equivalent mutants.
this information is useful in the design of complementary equivalent detection techniques.
mutation testers usually employ subsets of mutant operators.
therefore knowing about the relationship between the operators and the equivalent and duplicated mutants found by the tce approach is useful in the sense that mutation testers can better understand the importance of their choices.
hence our next rq is to examine the extent of the equivalent and duplicated mutants found per mutant operator rq4 impact on mutant operators what is the contribution of each operator in the proportion of equivalent and duplicated mutants found by tce?
finally we investigate whether the size of the programs or the number of mutants they contain correlates with the effectiveness of the tce approach.
one might expect that in larger programs the equivalent mutant identification would be harder thereby impeding the tce s effectiveness.rq5 correlation analysis does program size or number of mutants affect tce?
we answer this question by investigating correlations between the number of equivalent and duplicated mutants found by tce and program and mutant set size.
c. subject programs we used two sets of subjects.
the first is composed of six large open source programs.
in this set we choose realworld programs that vary in size and application domain.
the second set was taken from the study of yao et al.
and it is composed of subjects.
we choose this set because it is accompanied by manually identified equivalent mutants.
the availability of known equivalent mutants allows us to answer the rq3 because it provides a ground truth on the undersidable equivalence question for a set of subjects.
the rest of rqs are answered using the larger programs.
regarding the large programs compiling all their mutants constitutes a time consuming task.
this is due the increase of the mutants according to the size of the programs.
it is evident by our reported results presented in section iv b where it took more than hours to compile only the mutants involved in the vim eval component under o3 .
tce may be scalable in itself but applying it to all possible mutants of a large program is clearly infeasible.
though there are techniques to reduce the number of mutants i.e.
by sampling we prefer not to use them in case we unintentionally bias our sample of mutants.
we prefer to sample safer over the code to be mutated in a systematic way so that we do not pre exclude any mutants from our investigation.
therefore we rank their source files according to their lines of code.
then we select the two largest components.
on these two components we apply mutation to all the functions they contain.
table ii presents the information about the first set of subjects.
the second set contains programs with lines of code ranging from to lines programs with to lines and real world programs with to lines.
additional details for this programs can be found in .
the gzip andmake are gnu utility programs.
the first program performs file compression and the second one builds automatically executable files from several source code files.
the two largest components of gzip are the trees and gzip .
the former implements the source representation using variable length binary code trees and the later implements the main command line interface for the gzip program.
the two largest components of the make program are main and job .
the later implements utilities for managing individual jobs during the source building processes and the former implements the command line interface.
the gsl gnu scientific library is a c c numerical library which provides a wide range of common mathematical functions.
its two largest components are gen and blas .
the gen implements utilities that compute eigenvalues for generalised vectors and matrices.
the blas implements blas operations for vectors and dense matrices.table ii subject program details the loc shows the lines of code of the project comp and comp size shows the components considered and their size the func and muts show the number of functions and mutants of the components.
program loc comp comp size func muts gzip .
323tree gzip msmtp .
.
068smtp msmtp make .
122main job git .
012refs diff gsl .
863gen blas vim .
769spell eval total the program msmtp is an smtp client for sending and receiving emails.
the components studied are the smtp and the msmtp .
the smtp implements the coreutilities for exchanging information with smtp servers and the msmtp component implements the command line interface for msmtp .
the program gitis a source code management system and the components selected are the refs and diff .
the refs implements the reference data structure that associates history edits with sha values and the diff component implements utilities for checking differences between git objects for example commits and working trees.
finally the program vimis a configurable text editor.
the selected components spell and eval implement utilities for checking and built in expression evaluation respectively.
d. mutant operators based on previous research on mutant operator selection we identify and use two sets of operators.the first set proposed by offutt et al.
is composed of five operators i.e.
abs aor lcr ror and uoi.
we use this set due to its extensive use in literature .
the second set was used in the studies of andrews et al.
where it was shown that it provides accurate predictions of the real fault detection ability of the test suites.
this set is composed of eight operators three of them i.e.
aor lcr and ror are drawn from the first set while the other five i.e.
crcr oaaa obbn ocng and ssdl are designed to cater the common c faults.
a detailed description of the operators is reported in table iii.
to generate the mutants we use m ilu an open source mutation testing tool for c. we detail exactly how the operators were applied since this is an important piece of information that differs from one tool to another.
the abs and uoi operators were only applied on numerical variables.
the crcr was applied to integer and floating numeric constants.table iii the mutant operators used.
name description abs absolute value insertion e abs e e abs e aor arithmetic operator replacement x y x y x6 y lcr logical connector replacement x y x y x6 y ror relational operator replacement x y x y !
x6 y uoi unary operator insertion v v v v v v v v crcr integer constant replacement ci x x2 ci ci ci oaaa arithmetic assignment mutation x y x y x6 y obbn bitwise operator mutation x y x y x6 y ocng logical context negation e !
e e2 if e while e ssdl statement deletion s remove s no mutant operator was applied on the variables of the lefthand side of assignment statements we only apply them at the right hand sides.
all operators are applied recursively to all sub expressions.
further details and the implementation of the operators can be found on the webpage of m ilu1.
e. experimental environment all our experiments were undertaken on the microsoft azure cloud platform using a a9 compute intensive instance in the ubuntu .
operating system with compiler gcc .
.
to compile the mutants we used four configuration options.
we compile with no optimisation settings denoted as none and with the three popular ones as realized by the gcc compiler denoted as o o2and o3.
we use the linux time utility to measure the cpu execution time of all the involved processes.
to check whether two binaries are equivalent we use the diff utility with the flag binary .
in short we use agcc flag combined with a diff .
iv.
r esults a nswers to research questions this section reports our results and provides answers to the research questions.
a. rq1 tce effectiveness to assess the effectiveness of the tce approach answering rq1 we measure the number of the detected equivalent and duplicated mutants.
we also measure the proportions of these mutants per program computed as the percentage of the detected to introduced.
when mutants are mutually equivalent to each other i.e.
they are duplicated one of them should be kept while the other s should be discarded.
in our results we only report the number of mutants that should be discarded.
iv reports our results per program and per considered optimization option.
overall these results indicate that tce can detects in total equivalent mutants accounting for .
of all mutants.
tce also detected duplicated mutants which account for of all mutants.
overall tce can thus remove approximately of all mutants.
figure depicts the proportions of both equivalent and duplicated mutants detected per program.
the horizontal axis of the graph is ordered by the size of the components while the vertical axis records the proportions of mutants detected.
from these results it is evident that all the subjects have a reasonably high proportion of equivalent and duplicated mutants.
the proportions of equivalent mutants detected varies from program to program.
in the worst case it is while in the best it is .
we observe a small variation in the proportions of the identified equivalent and duplicated mutants.
the only exceptions are the gsl blas andgsl gen components.
in the former case tce detects many equivalent mutants and very few duplicated ones while in the later case it detects very few equivalent mutants and a similar to the other programs ratio of duplicated mutants.
this divergence is mainly attributed to the internal structure and code characteristic of the component.
finally table iv reveals that depending on the options used the detected equivalencies differ.
for instance the o3 option found on average and of the equivalent and duplicated mutants that are detected by applying all the options.
interestingly with respect to equivalent mutants among the different optimization options i.e.
o o2 ando3 there is no clear winner and their behavior varies between programs.
however the overall differences are relatively small between the options.
with respect to duplicated mutants the results are clear and they show that the best options are the o2and o3.
b. rq2 tce efficiency to assess the efficiency of the tce approach and answer the rq2 we report the cpu execution time.
table v summarises the execution time of tce in total average and per employed component using the four studied compiler settings.the columns comp.
eq.d.
and d.d.
record the execution time with respect to the compilation process the equivalent mutant detection and duplicated mutant detection per considered compilation option respectively.
gzip treesmsmtp smtpgzip gzipgsl gengsl blasmake mainmake jobgit refsmsmtp msmtpgit diffvim spellvim evalproportion of compilable mutantsequivalentduplicatedfig.
the proportion of equivalent and duplicated mutants detected by tce per program studied.table iv equivalent and duplicated mutants detected by tce.
none o o2 and o3 report the fraction of all identified equivalent mutants that were detected per optimization flag.
number of mutants reports the distinct number of detected mutants by all the options together and of all mutants reports the percentage of detected to the number of mutants.
programnone o o2 o3 number of mutants of all mutants eq.
dup.
eq.
dup.
eq.
dup.
eq.
dup.
eq.
dup.
eq.
dup.
gzip gzip .
.
.
.
.
.
.
.
gzip trees .
.
.
.
.
.
.
.
vim spell .
.
.
.
.
.
.
.
vim eval .
.
.
.
.
.
.
.
make main .
.
.
.
.
.
.
.
make job .
.
.
.
.
.
.
.
git diff .
.
.
.
.
.
.
.
git refs .
.
.
.
.
.
.
.
msmtp msmtp .
.
.
.
.
.
.
.
msmtp smtp .
.
.
.
.
.
.
.
gsl blas .
.
.
.
.
.
.
.
gsl gen .
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
table v execution time compilation comp.
equivalent mutant detection eq.d.
and duplicated mutant detection d.d.
.
optimisation settings for gcc programnone o o2 o3 comp.
eq.d.
d.d.
comp.
eq.d.
d.d.
comp.
eq.d.
d.d.
comp.
eq.d.
d.d.
sec sec sec sec gzip trees msmtp smtp gzip gzip gsl gen gsl blas make main make job git refs msmtp msmtp git diff vim spell vim eval total average these results reveal that the execution time of the equivalence detection process is reasonably small compared to the compilation one.
for instance tce requires on average seconds on all the cases to detect equivalent mutants while the average compilation cost is seconds in the best case.
a similar case arises when considering the costs for detecting duplicated mutants.
while this is approximately an order of magnitude higher than the cost of detecting equivalent mutants it is still reasonable seconds and no more than of the cheapest compilation cost.
it is noted that our approach checks for equivalencies only the combinations of mutants that are located on the same function.
therefore the reported time is analogous to the number of combinations between the mutants located at each function of the project and not between the whole combinations of all project mutants.our results show that the compilation time of the o3option is almost times higher than the none option.
however this is counterbalanced by the improved effectiveness of the option.
in this case the total time spend for compiling detecting equivalent and duplicated mutants is respectively and seconds.
therefore tce analyzed mutants in seconds.
this time accounts for less than seconds per mutant suggesting that it is reasonably fast.
c. rq3 equivalent mutants to determine the ratio of detected to all existing equivalent mutants we applied tce to the equivalent mutants identified by yao et al.
using the accompanying website data from www0.cs.ucl.ac.uk staff y.jia projects equivalent mutants .
this site is regularly updated so data may differ slightly from those previously reported .
additional details about these data can be found on the website.table vi number no.
and proportion of detected equivalent mutants on the yao et al.
benchmark set.
programnone o o2 o3 no.
no.
no.
no.
min bubble profit mid prime triangle insert day calendar carsimulator tcas defroster schedule hashmap replace space flex make total table vi reports the number and the proportions of equivalent mutants detected by tce when using the different settings.
the results are surprisingly good.
they reveal that tce can detect from to of all the equivalent mutants.
this number accounts for on average which is approximately of all the mutants both killable and equivalent mutants .
these results are achieved within a few seconds with the potential to save considerable manual and computational resources.
together with the previously presented results we conclude that tce is effective and practically applicable on large real world programs.
regarding the types of the equivalent detected mutants i.e.
second part of rq3 we recall that equivalent mutants are equivalent because a they reside in unreachable code b it is impossible to affect the program state that pertains immediately after mutant execution or c there is no possible way to propagate the infection they introduce to the program output.
interestingly the equivalent mutants detected by tce reside within all of these categories.
in particular tce detected and of the equivalent mutants caused by the a b and c respectively.
d. rq4 mutant operators to determine the influence of the mutant operators on the effectiveness of tce answering rq4 we measure the number of detected equivalent and duplicated mutants per operator.
we also measure the ratios of detected to introduced mutants by the studied operators.
it is noted that the choice of which mutants should be discarded when computing the duplicated mutants can unfairly influence the reported numbers with respect to the mutant operators that they belong to.
to avoid this in this section we report the number and proportions of all the mutants that are duplicated and not the discarded ones.table vii reports the number and proportions of the equivalent and duplicated mutants found by tce per program and operator.
these results suggest that on different programs a similar proportion of equivalent and duplicated mutants can be detected by tce.
the only exceptions are the gsl blas andgsl gen components.
figure depicts the proportions of equivalent and duplicated mutants detected per operator.
the horizontal axis follows the presentation order of the operators from table vii while the vertical axis records the proportions of detected mutants.
these results reveal that the abs and uoi operators introduce at least equivalent mutants of all that they introduce.
they also show that tce detects more than of equivalent mutants produced by the abs ror uoi and crcr operators.
regarding the duplicated mutants tce detects large proportions above on all of them but the abs lcr and oaaa.
interestingly the lcr operator seems to produce very few equivalent or duplicated mutants.
in conclusion our results show that all but the lcr and oaaa operators produce a relatively high ratio of useless mutants i.e.
equivalent and duplicated.
in practice this involves a huge overhead that fortunately can be saved by tce.
e. rq5 program size and mutant equivalencies to answer rq5 we use the spearman rank correlation coefficient .
this is a non parametric statistical test that measures whether two variables ranks are related i.e.
it assesses the monotonic relationship between the two variables.
the spearman correlation gives values in the range of with indicating no relationship and indicating a perfect one also implies a perfect inverse relationship .
we found a correlation between the number of mutants and the number of equivalent mutants detected .
.
since more mutants leads to more equivalent ones this result suggests that tce can identify a certain amount of them.
a stronger correlation was also found for the number of mutants and the detected duplicated .
.
this is a surprising result since it indicates that a certain percentage of duplicated mutants is always produced by the operators.
we also study the relation between the program size and the number of detected equivalent mutants.
we found a medium to small correlation .
.
a slightly lower correlation was found between the size of program and the number of duplicated mutants .
.
absaorlcrroruoicrcroaaaobbnocngssdlproportion of mutantsequivalentduplicatedfig.
the proportion of equivalent and duplicated mutants detected by tce per mutant operatortable vii number no.
and proportion of equivalent and duplicated mutants detected by tce per operator.
equivalent mutants programabs aor lcr ror uoi crcr oaaa obbn ocng ssdl no.
no.
no.
no.
no.
no.
no.
no.
no.
no.
gzip trees msmtp smtp gzip gzip gsl gen gsl blas make main make job git refs msmtp msmtp git diff vim spell vim eval total duplicated mutants programabs aor lcr ror uoi crcr oaaa obbn ocng ssdl no.
no.
no.
no.
no.
no.
no.
no.
no.
no.
gzip trees msmtp smtp gzip gzip gsl gen gsl blas make main make job git refs msmtp msmtp git diff vim spell vim eval total we found a medium correlation between the size of program and the whole number of mutants .
.
this result is surprising since it suggests that larger programs do not necessarily involve a higher number of mutants.
in conclusion our results indicate that both the number of mutants and the equivalences detected by tce are more related to the code characteristics of the programs than to their size.
v. i mplications the proposed technique is solely based on the use of compilers thereby avoiding the several limitations of other methods and tools.
it does not require any sophisticated source code analysis techniques or any expensive test executions.
thus it can be directly applied on real world systems and can be easily incorporated within mutation testing tools.
we have seen that tce reduces the total number of mutants by where are equivalent and are duplicated.
the existence of so many useless mutants has a distorting influence on the accuracy of the mutation score measurement.
according to our results at least the of all the mutants are duplicated.
this implies that the true mutation score might be underestimated or overestimated by killed or live duplicated mutants.therefore it is possible that when we compare testing methods one might have a fake advantage by killing more duplicated mutants than the other .
future empirical studies must remove these mutants to avoid biased results.
the time to detect equivalent and duplicated mutants is approximately and seconds per program.
this indicates that once the mutants have been compiled the equivalence detection comes almost for free .
this is an important finding because it suggests that tce can be applied to remove equivalent and duplicated mutants before the application of other time consuming cost reduction methods.
interestingly the detected mutant equivalencies are partly dependent on the compiler options used.
although it is rather unlikely that equivalent mutants detected by one compiler option are not equivalent according to another to be absolutely sure beyond any doubt that tce guarantees equivalence we need to know which compiler settings are going to be used in the deployment environment.
no previous research takes into account the particular compiler settings but since we are using tce we cannot ignore it.
all previous work seems to assume that there is only one compiler option but actually there are as many options as the actual settings used by the deployed programs.when the deployed code compiler settings are known tce can exploit this information.
when they are unknown at mutation test time we can investigate with a reasonable sample checking for variance in equivalence behaviour.
we investigated this using the four most popular compiler settings.
we explored the main gccsettings covering a wide range of optimization options and found that all of them can be used to detect mutant equivalencies some are more effective than others of course .
we also explored the trade off between effectiveness and efficiency using different settings.
our results suggest that the oand o2 option are reasonably good because they consume less compilation time than the o3 option.
however none of them is superior to the others in detecting equivalent mutants.
we also studied only first order mutants.
however tce is generic and can be applied to detect equivalent and duplicated higher order mutants.
finally we can advance our approach by using some form of either binary abstraction such as semantic interpretation as done by binjuice or checksum as done by md5.
the fist case might have an effect on the effectiveness of tce while the second one on the performance of the diff comparisons.
vi.
t hreats to v alidity as it is usual in software engineering experiments our subjects might not be representative.
to ameliorate this issue we selected real world programs several orders of magnitude larger than those used in previous equivalent mutant detection studies of varying size and application domain.
we also performed an additional evaluation using a different set of programs composed of benchmark subjects taken from the literature.
our approach provided similar results in these two sets i.e.
on average it detects equivalent mutants approximately as .
of all the mutants on the real world programs while on the subjects of the literature it detects approximately .
.
additionally our results are in line with those reported in literature2providing confidence that they are realistic.
we studied the mutants of the c language and tce implemented using gcc.
additional studies are needed to determine tce performance on other languages.
other threats are due to the use of software systems.
thus thegcc compiler and the diff utility may have defects.
however these systems are heavily tested and deployed.
thus it is unlikely that they would have defects that would influence our results to a great extent.
implementation defects of m ilu may have an influence.
to reduce this threat we carefully check its results.
however we consider this threat as small since m iluhas also been used by several authors in their studies e.g.
independently of us.
furthermore we used the yao et al.
benchmark which was entirely built by hand.
these results served as a sanity check to reduce the threat to validity.
2offutt and pan reported that of all the mutants are equivalent.
delamaro et al.
found kintis et al.
schuler and zeller papadakis et al.
and yao et al.
.
thus the actual ratio of the equivalent mutants is in the range of .
tce detects .
which is more or less similar to what we found in rq3.our results might be affected by our choice of mutation operators.
to ameliorate this threat we used all the popular operators included in most existing mutation testing tools .
we also included those empirically found to correlate with fault detection.
the use of the yao et al.
benchmark may also poses another threat.
this is due to the manual analysis performed some killable mutants may have been mistakenly identified as equivalent.
however this study was performed independently of the present one and hence it is not likely that these kind of mistakes coincidentally match the results of tce.
additionally it is equally possible that any such mistakes have also led to the effectiveness of our method being underestimated.
finally all our subjects tools and data are available in the accompanied website of the present paper3.
this helps reducing all the above mentioned threats since independent researchers can check replicate and analyse our findings.
vii.
c onclusions software engineering is a unique mix of both science and engineering.
sometimes researchers including the authors of this paper can become so bedazzled by their search for clever science that they may overlook simple yet effective engineering solutions that lie within their grasp.
we report on one such case in this paper the search for techniques to ameliorate the effect of equivalent mutants on mutation testing.
previous work has concentrated on complicated detection techniques involving sophisticated semantic dependence analysis meaning preserving transformation rules and constraint solving techniques.
unfortunately these techniques proved neither sufficiently scalable nor widely applicable to have become adopted in production tools or research prototypes.
by contrast the trivial compiler equivalence approach that we advocate in this paper is both as scalable and as widely applicable as the compiler technology upon which it rests.
we simply declare to be equivalent any mutant for which the compiled object code is identical to the program from which is constructed.
our contribution does not lie in the proposal of this technique which is as the name implies trivial .
rather the contribution of this paper is to demonstrate that tce can detect a large proportion of real world equivalent mutants.
our empirical study on benchmarks shows that of equivalent mutants can be detected by tce.
perhaps more importantly in a set of six large programs we found that tce can also detect more than of all mutants to be equivalent perhaps as many as of all equivalent mutants respectively.
viii.
a cknowledgments mike papadakis is supported by the national research fund luxembourg inter mobility .
mark harman is partly supported by the uk epsrc projects ep i033688 gismo and ep g060525 a platform grant for the centre for research on evolution search and testing crest at ucl.
yue jia is supported by the epsrc project ep j017515 daase and by microsoft azure grant .
equivalence