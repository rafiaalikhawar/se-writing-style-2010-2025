safe memory leak fixing for c programs qing gao yingfei xiong yaqing mi lu zhang weikun yang zhaoping zhou bing xie hong mei key laboratory of high confidence software technologies peking university moe institute of software school of electronics engineering and computer science peking university beijing p. r. china fgaoqing11 xiongyf04 miyq13 zhanglu xiebing meih g sei.pku.edu.cn fweikunyang zhouzhaoping g pku.edu.cn abstract automatic bug fixing has become a promising direction for reducing manual effort in debugging.
however general approaches to automatic bug fixing may face some fundamental difficulties.
in this paper we argue that automatic fixing of specific types of bugs can be a useful complement.
this paper reports our first attempt towards automatically fixing memory leaks in c programs.
our approach generates only safe fixes which are guaranteed not to interrupt normal execution of the program.
to design such an approach we have to deal with several challenging problems such as inter procedural leaks global variables loops and leaks from multiple allocations.
we propose solutions to all the problems and integrate the solutions into a coherent approach.
we implemented our inter procedural memory leak fixing into a tool named leakfix and evaluated leakfix on programs with 522k lines of code.
our evaluation shows that leakfix is able to successfully fix a substantial number of memory leaks andleakfix is scalable for large applications.
i. i ntroduction recently a lot of research effort has been put into automatic bug fixing .
given a violated correctness condition these approaches try to modify the code to satisfy the condition.
however automatic bug fixing faces two fundamental difficulties.
first the correctness condition is often under specified in practice.
current approaches usually rely on test cases or assertions both of which are usually inadequate in the code and rarely ensure correctness.
second the search space is often very large even infinite and it is very difficult to find an efficient fixing algorithm in general.
current approaches usually run in hours and may produce undesirable fixes.
due to these fundamental difficulties we argue that instead of general bug fixing we should also study fixing approaches for specific types of bugs.
in this paper we report our attempt of developing an approach that fixes a specific type of bugs memory leaks in c programs.
there are several reasons to choose memory leaks as our target problem.
first dealing with memory leak is an important problem in software development.
while many approaches have been proposed to detect memory leaks it is still difficult to fix a we sincerely thank zhenbo xu and jian zhang at institute of software chinese academy of science for their advice on implementation.
this work is supported by the national basic research program of china under grant no.
2014cb347701 and the national natural science foundation of china under grant no.
and .
yingfei xiong is the corresponding author.
r e c o r d p i n t b a d r e c o r d i d 3while h a s n e x t f i f s e a r c h c o n d i t i o n !
n u l l p g e t n e x t e l s e p s e a r c h f o r n e x t s e a r c h c o n d i t i o n i f i s b r o k e n p f b a d r e c o r d i d p i d break 11g f r e e p 13g .
.
.
o p e r a t i o n s on b a d r e c o r d i d return fig.
.
the code of procedure check records memory leak .
second memory leaks cannot be easily handled by general bug fixing approaches as we cannot easily specify the condition of no leak as an assertion or a test case.
third the no leak condition is general.
we can build it into our approach without relying on user defined test cases and assertions.
fourth the problem of fixing memory leaks takes a much simpler form than fixing general bugs as the main task is to find a suitable location to insert the deallocation statement.
to understand the difficulty of fixing a memory leak let us take a look at an example program in fig.
.
this is a contrived example mimicking recurring leak patterns we found in real c programs.
procedure check records checks whether there is any bad record in a large file and the caller could either check all records or specify a search condition to check only part of records.
in this example both get next andsearch for next will allocate and return a heap structure which is expected to be freed at line .
however the execution may break out the loop at line causing a memory leak.
many existing detection approaches report only the allocation that may be leaked which may be far from the place where the leak occurs.
in this example the leaked allocation will be inside the procedures get next andsearch for next where the actual leak occurs in another procedure.
fastcheck is a detection approach that gives a path where the memory is leaked.
this noticeably reduces the search space for identifying the leak but it is still difficult to correctly fix the leak.
to fix the leak we have to insert a deallocation statement satisfying the following conditions.
in any execution the memory chunk has to be allocated before the deallocation.
there is no double free no other deallocation will free this memory chunk.
the memory chunk will not be used after the deallocation.
the developer needs to have a comprehensive understanding of the code to find a suitable location and a suitable pointer to be freed.
in this example if the developer chooses to insert a deallocation of pbefore line s he has to look into the procedure get next andsearch for next to make sure that they return allocated memory chunks in all cases.
also s he has to ensure that the code after the loop has no deallocation or