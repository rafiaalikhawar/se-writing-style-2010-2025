effectiveerror specification inference viadomain knowledgeexpansion daniel defreez universityof california davis usa dcdefreez ucdavis.eduhaaken martinson baldwin universityof california davis usa hmbaldwi ucdavis.edu cindy rubio gonz lez universityof california davis usa crubio ucdavis.eduadityav.thakur universityof california davis usa avthakur ucdavis.edu abstract error handlingcoderesponds to theoccurrence ofruntimeerrors.
failuretocorrectlyhandleerrorscanleadtosecurityvulnerabilities and data loss.
this paper deals with error handling in software writtenincthatusesthereturn codeidiom thepresenceandtype of error is encoded in the return value of a function.
this paper describes eesi astaticanalysisthatinfersthesetofvaluesthata function can return on error.
such a function error specification canthenbeusedtoidentifybugsrelatedtoincorrecterrorhandling.
the key insight of eesiis to bootstrap the analysis with domain knowledge related to error handling provided by a developer.
eesi usesacombination ofintraprocedural flow sensitive analysisand interprocedural context insensitive analysis to ensure precision andscalability.webuiltatool ecctodemonstratehowthefunction error specificationsinferredby eesicanbeusedtoautomatically find bugs related to incorrect error handling.
eccdetected bugsacross9programs ofwhich110havebeenconfirmed.
ecc detected previously unknown bugs of which are confirmed.
twopatcheshave already been mergedintoopenssl.
ccs concepts softwareanditsengineering automatedstaticanalysis errorhandlingandrecovery software defectanalysis .
keywords errorhandling staticanalysis bugfinding acmreference format danieldefreez haakenmartinsonbaldwin cindyrubio gonz lez andaditya v.thakur.
.effectiveerror specificationinferenceviadomain knowledge expansion.in proceedingsofthe27thacmjointeuropeansoftwareengineeringconferenceandsymposiumonthefoundationsofsoftwareengineering esec fse august 26 30 tallinn estonia.
acm new york ny usa 11pages.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 26 30 tallinn estonia associationfor computing machinery.
acm isbn ... .
introduction error handling code responds to the occurrence of runtime errors insoftware.forexample afunctionattemptingtoallocatememory needs code tohandle the case when there is no memoryavailable and a device driver requires code to handle the situation when the hardware device does not respond.incorrect handling ofsuch errors can lead to serious problems such as security vulnerabilities anddataloss.ignoringtheerrorreturnedbyamemoryallocator would lead to the code accessing invalid memory and ignoring the errorreturnedbythehardwaredevicemightleadtodatacorruption.
thus correctlyhandling errorsincode isparamount.
thispaperdealswitherrorhandlinginsoftwarewritteninthec programminglanguage.intheabsenceofexception handlingmechanisms suchcprogramsusethe return codeidiom thepresence and type of error is encoded in the value returned by a function.
failuretocorrectlycheckforsucherrorvaluesatfunctioncallsites can leadto error handling bugs section .
this paperpresents effective error specification inference eesi pronounced ee see a static analysis that infers function errorspecificationsforprogramsusingthereturn codeidiom.a function error specification isthesetofvaluesthatthefunctioncanreturn onerror.forexample thefunction acpi pci link allocate irq inthelinuxkernelreturnsanegativeintegeronerror acpi ec allocreturns0onerror and acpi allocate root table returns anonnegative integeronerror.
to understand the challenges in inferring error specifications considerthe following intentionallyabstract code intf1 if f2 f3 return return the function f1has only two possible return values 0and1.
looking at the body of the function f1 we cannot infer whether f1 returns0or1onerror orwhetheritisinfallible doesnotreturn anyerrorvalue .thereisnothinginherentinthecodethatimplies thataparticularvaluerepresentsanerror.contrastthissituation with thatin languagessupporting exceptionhandling exceptions are caughtandhandledinwell labeled catchblocks.
totacklethischallenge eesibootstrapstheanalysisbyutilizing developer provideddomainknowledge.suchdomainknowledge can include a list of functions that only occur along error paths esec fse august 26 30 tallinn estonia defreez martinsonbaldwin rubio gonz lez andthakur error only functions a list of error codes or the error specification for a few functions section .
.
for example if the domain knowledge includes the fact that calls to function f3only occur along error paths then eesiwill infer that f1returns0on error if thedomainknowledgeprovidedincludesthefactthat f2returns anonnegativevalueonerror then eesiwillinferthat f1returns 1onerror.byexpandinguponthisinitialknowledge eesiinfers errorspecifications.
inpractice thedomainknowledgerequiredfor eesiisverysmall typicallyconsistingofonlyasingleerror onlyfunction andafew functionerror specifications section .
.forexample openssl was analyzed using the single error only function err put error andthesingleinitialerror specificationthat mallocreturns0 null pointer onerror.errorcodesareusedinpriorwork .however thedifferenceliesinthefactthat eesiexpandsonthisinitialdomain knowledge and is able to find function error specifications that arenot restrictedtosucherrorcodes.forexample eesiisable to infer error specifications for functions that return zero positive or nonnegative values on error even though the errorcodes in the linux kernel are negative integers.
errorsmaypropagatethroughlongfunction callchains often crossing subsystem boundaries.
for example a memory allocation errorstartingatthelinuxkernelslaballocatorwillbefirstreturned asanullpointerfrom slab alloc beforebeingconvertedtoanegative error code in the ip routing function ip route input mc beforefinallybeingconvertedtoapositiveerrorvaluein xfrm4 rcv encap finish sevenfunctioncallsawayfromtheoriginalerror.adevelopermightfinditdifficulttomanuallyinferthefunction error specification.documentationoffunctionerror specifications ifavailable isoftenincorrect .thefunctionerror specifications inferred by eesican be used at development time to determine what errors need to be handled.
consequently eesineeds to be scalable.itcannotrelyonclientsofthecodetoinfertheerrorspecifications andneedstoinfererrorspecificationsforallfunctions inthe program not justpublicapi functions.
eesicastsfunctionerror specificationinferenceascomputing the least fixpoint of a set of constraints.
the constraints are constructedviaaflow sensitiveanalysisofthebody offunctions the inferrederrorspecificationsarecontextinsensitive section .this formulation enables eesito scale to large programs while still maintaining precision.
eesitakes min sec to analyze 320k lines of linux file system code and obtains an overall precision of .
section .
.
this paper also presents ecc section4 an automated tool that uses the function error specifications inferred by eesito find error handlingbugs suchasinsufficienterrorchecks.
eccdetected error handling bugs across programs of which have been confirmed.
eccdetected previously unknown bugs of which are confirmed and we are in the process of confirming potential bugs.
two patches have already been merged into openssl section .
.
the contributionsofthis paper can be summarizedas we develop eesi a static analysis to infer function errorspecifications using domainknowledge section .
wedevelop ecc atoolthatusesfunctionerror specifications to find error handlingbugs section .1static int ext4 dx csum verify struct inode inode struct ext4 dir entry dirent 3struct dx countlimit c 4struct dx tail t 5intcount offset limit count 7if !ext4 has metadata csum inode i sb return 10c get dx countlimit inode dirent count offset 11if !c ext4 error inode inode dir seems corrupt?
run e2fsck d. return 15limit le16 to cpu c limit 16count le16 to cpu c count 17if count offset limit sizeof struct dx entry ext4 block size inode i sb sizeof struct dx tail warn no space for csum inode return 21t struct dx tail struct dx entry c limit 23if t dt csum !
ext4 dx csum inode dirent count offset count t return 26return figure the function ext4 dx csum verify returns for success and0 forerror.
weevaluatetheprecisionoftheerrorspecificationsinferred byeesion real world c code section .
and compare eesiwiththe state of the art section .
.
weevaluatetheeffectivenessof eccatfindingerror handling bugsinreal world c code section .
.
overview figure1shows the ext4 dx csum verify functionfrom the ext4 linuxfilesystem.similartothefunction f1wediscussedinsection1 it can return either 0or .eesiis bootstrapped with the initialdomainknowledgethatthefunction ext4 error inode is anerror onlyfunction itisonlycalledonerrorpaths.because ext4 dx csum verify mustreturn 0afterthecallto ext4 error inode on line13 eesiinfers that 0is an error value for ext4 dx csum verify.
thisexampleillustratessomeofthechallengesofinferringfunctionerror specifications.onechallengeisthattheerrorspecificationofafunctioncannotbe inferredfrom its returntype.pointerreturning functions often return a null pointer as an error value but not always.
identifying such a default error value is even more difficult for integer returning functions such as ext4 dx csum verify.someprogramsrecommendaspecificconventionforerror values but these are not always strictly adhered to.
for instance although many linux functions return 0on success and a negative error code on failure the function ext4 dx csum verify is oneofmanyexamplesthatdonotfollowthisconvention.theerrorspecificationof ext4 dx csum verify is undocumented and 467effective error specification inference esec fse august 26 30 tallinn estonia 1static struct buffer head ext4 read dirblock ... 2if ext4 dx csum verify inode dirent set buffer verified bh 4else ext4 error inode inode func line block directory index failed csum brelse bh return err ptr efsbadcrc figure excerpt from the function ext4 read dirblock which hastheonlycallto ext4 dx csum verify .
returnedconstant returnedfunctioninference enginellvm irfunction error specificationsdomain knowledge callconstraints figure eesi architecture a developer must read the definition of the function to learn this specification often requiring following longcallchains.
priorwork deduceserrorspecificationofafunctionfromits usageandonempiricalcharacteristicsoferrorpaths.however such an approach must necessarily resolve inconsistencies between call sitesthroughavotingmechanism anddoesnotworkforfunctions withonlyafewcallsites.forexample thefunction ext4 dx csum verifyiscalledexactlyonceinthelinuxkernel fromthefunction ext4 read dirblock figure2 .
bugsrelatedtoincorrecterrorhandlingcanbesubtle.whenthis call toext4 dx csum verify was introduced into ext4 read dirblock infebruary2013 ext4 dx csum verify returned in two failure cases leading to undetected checksum failures inext4 thedefaultfilesystemofmanylinuxdistributions.this issue was fixed in whenext4 dx csum verify was patchedtoalwaysreturn0onfailureand1onsuccess.thisexample illustratestheneedforanautomatedtechniquethatinfersfunction error specifications andidentifiesbugsrelatedtoincorrecterror handling.
error specification inference this section describes the static analysis used by eesito infer function error specifications figure starting with some basic definitions.
definition .
anerrorvalue forafunction fisavaluereturned byfthat indicates fencounteredaruntimeerror.
example3.
.
thevalue0isanerrorvalueforfunction ext4 dx csum verify infigure1 thisfunctionreturns0whenitencounters aruntimeerror for example online .
nequal0 ... ... nequal0 ... ... ... ... ... ... v 0ifv 0ifv 0ifv figure extended sign lattice lwith its concretization function l p z and abstractionfunction z l the set of error values for a function is its error specification .
functions that have no error values such as the c library function strcmp arecalled infalliblefunctions .however individualcallers ofafunctionmighttreatcertainreturnvaluesasindicatinganerror hasoccurred butthesereturnvaluesarenoterrorvaluesforthe called function.
for example a caller of strcmpmight treat the result of a specific string comparison as an error but this does not mean that strcmpisencounteringan error.
tomaketheproblemofinferringthesetoferrorvaluestractable we abstract sets of error values to elements in the extended sign latticel.thelatticealongwithitsconcretizationfunction l p z and abstraction function z lis shown in figure .
for example theelement concretizestothesetofallintegers z concretizes to the empty set .
theelementsoflrepresentthemostcommonchecksthatdevelopersperformonerrorvalues.
this latticecapturesnull dereference checksbecause the null valuefor pointers isrepresentedby0.
definition .
given the set of functions fin the program the error specification e f lmaps each function f ftol l such that l contains the setof errorvaluesfor f. example .
.
in figure e ext4 dx csum verify l. thisfunctionreturns0onerrorandtherearenoothererrorvalues.
.
intraproceduralanalyses this section describes the flow sensitive intraprocedural analyses usedbyeesi.weuseftodenotethesetoffunctionsintheprogram sftodenotethesetofstatementsinfunction f f andcallsites f to denotethe setofstatements that contain acallto function f. callconstraintsanalysis.
callconstraints analysisdetermines the constraints on function return values necessary to execute a statement.
definition3.
givenafunction f f constraint f s f l l if the statement s sfmay be executed when any call to function f finfreturns avaluein l .
example .
.
constraint f s3 ext4 dx csum verify nequal0 lin figure because the statement on line s3 is executed when the call to the function ext4 dx csum verify in function f ext4 read dirblock returns anon zerovalue.
468esec fse august 26 30 tallinn estonia defreez martinsonbaldwin rubio gonz lez andthakur f finit e f einit f initspecf nelementfinit e f initbots sfretconst f s c c ec e f e f c errorcode s sfretconst f s c s callsites f f feo e f e f c erroronlycall s sfretconst f s cconstraint f s f l l e f nequal l nequal e f e f c errorconstant s sfretfunc f s constraint f s f l l e f nequal e f e f e callpropagation figure eesi inferencerules returnedconstant analysis.
returnedconstant analysis determines the constant if any that must be returned if a statement executes.
definition .
givenafunction f f retconst f s c ziff must return the constant cif the statement s sfis executed.
example3.
.
retconst f s5 retconst f s7 retconst f s8 efsbadcrc infigure wheres5 s7 ands8arestatementsonlines and8 respectively infunction f ext4 read dirblock andthe macro efsbadcrc definesaconstant.
returnedfunction analysis.
returnedfunction analysis determines the call return value if any that must be returned by a function if astatementexecutes.
definition .
givenafunction f f retfunc f s f fiff mustreturnthevaluereturnedbyacalltofunction f infifthe statement s sfisexecuted.
example .
.
retfunc f s5 hid quirks init in figure c wheres5is the statement on line andf hid init because ifline5isexecutedthenthe function hid init must returnthe valuereturnedbyacallto hid quirks init .
.
domain knowledge eesiutilizes three types of domain knowledge to bootstrap the error specification inference i error codes ec zare specific constants that are used to denoteanerrorvaluebyconvention.consequently ifafunction freturns an error code c ecthencis an error valuefor f. for example macrossuchas enomemandefsbadcrc areusedtodenote errorcodes inthe linux kernel.
ii error only functions feo fare functions that are only calledwhenanerrorhasoccurred.consequently apathinfunction hastoreturnanerrorvalueifacalltoafunction feo feooccurs along that path.
for example ext4 error inode in figure 2is an error only function.
consequently efsbadcrc isan errorvalue for the function ext4 read dirblock .
iii initialerror specification einit finit lspecifiesfunctionerror specificationsforthefunctions finit f.forexample finit malloc andeinit malloc lfor openssl which states that mallocreturns nullpointer onerror.
.
interproceduralinference engine figure5shows the inference rules that eesiuses to infer the functionerror specification e f l definition usingtheresults of the prior intraprocedural analyses section .
as well as the domainknowledge section .
.
theinitspec ruleinitializese f using the initial error specificationeinit f whenf finit andtheinitbot ruleinitializes e f to whenf nelementfinit.
a constant cis returned by a function f fif there exists a statement s sfandretconst f s c. theerrorcode erroronlycall anderrorconstant rules all determine whether a constant cthat can be returned by a function fis an error value forf.ifcisdeterminedtobeanerrorvaluefor f thentheerrorspecification of fis updated using the abstraction of c that is e f e f c .
theerrorcode rulestates that if the function fcan return an errorcode c ec thencisan errorvaluefor f. theerroronlycall rulestatesthatifstatement sinfunction fis a call to an error only function feoand the function freturns the constant cwhensisexecuted then cisan errorvaluefor f. theerrorconstant rulestates that if function freturns the constant cwhen a call to function f returns an error value thencis an error value for f. if the condition constraint f s f l l e f nequal istruethen sinfcouldbeexecutedwhenthe f returnsanerrorvalue.therestriction l nequal isaddedtothisruleto limitthedetrimentalimpactofmissederrorchecks orotherwise incorrectcode onspecification inference.
thecallpropagation rulestatesthatiffunction freturns thereturnvalueoffunction whenacalltofunction f returnsan error value then the error values of are also error values for f. hence theerrorspecification e f canbeupdatedtoincludethe errorspecification e .
afterinitializingtheanalysisusingthe initspec andinitbot rules theremainingrulesareapplieduntilfixpoint followingastandard kleene iteration sequence.
the analysis terminates because the height of the lattice lis finite.
the soundness of the inference rulesfollowsfromthesoundnessoftheunderlyingintraprocedural analysesandthe correctness of the domainknowledge.
469effective error specification inference esec fse august 26 30 tallinn estonia error handlingbug detection this section describes a static analysis that finds error handling bugsusingthefunctionerror specification e f linferredby eesi.specifically wedescribe error checkchecker ecc thatfinds bugsrelatedto insufficientorincorrecterrorchecks.
definition6.
anerrorcheck isaconditionalbranchstatementthat tests if the valuereturnedbyafunctioncallisan errorvalue.
eccfindsinconsistenciesbetweentheerror specificationofa function definition andtheerrorchecks definition associated with calls to that function.
these inconsistencies are manifested in three differentbugpatterns.
a insufficient error checks.
insufficient error checks occur when the error checks associated with a call to a function ffail tocoveralloftheerrorvaluesthat fmayreturn.thiscanoccur when the return value of a function is not saved at all saved but not checked or when the return value of a function is checked for arangeofvaluesthatisapropersubsetoftheerrorvaluesthata function mayreturn.
b inverted error checks.
an inverted error check is an error checkthatgetsthedirectionoftheerrorpathwrong.acommon cause of inverted error checks is the use of error values that do not conformtotheidiomaticerrorhandlingconventionsusedtosignal errors in c such as returning on error.
the bug involving the originalversionof ext4 dx csum verify describedinsection is an instance of an inverted error check.
in this case the bug was fixedbymodifying ext4 dx csum verify to return 1onerror.
c incomplete error specifications.
another type of inconsistency arises when the error check for a function call is correct but the implementation of the function does not return the correct set of errorvalues.
this ariseswhen there are error checks for values thatafunctioncannotreturn resultingindeadcode.anexampleof a previously unknown bug of this type that we found in the linux kernel isshowninfigure b .
experimentalevaluation the experiments described in this section were designed to answer the following researchquestions rq1howaccuratelydoes eesiinferfunctionerror specifications?
rq2howdoes eesicompare withthe state ofthe art?
rq3howeffectiveis eccatfindingerror handlingbugswhen using the functionerror specifications inferredby eesi?
.
experimentalsetup benchmarks.
table1liststheprogramsusedintheevaluationof eesiandtheirsize.theseprogramswerechosentobearepresentative cross section of important software written in c ranging from operating systems to cryptographic libraries.
linux fs stands for linux file system which includes the virtual file system vfs the linux memory manager and fourfile systems ext2 ext4 btrfs andfat.
linux nfc is thenear fieldcommunicationsubsystem of the linux kernel.
full linux kernel refers to a runnable linux kernel includingallcomponentsinthe defaultconfiguration.
domain knowledge.
we used the following types of domain knowledge see section .2andtable when running eesi i errorcodes ec .
34errorcodeswereusedwhenrunning eesion linuxfs linuxnfc andfulllinuxkernel.noerrorcodeswere usedfor the restofthe programs.
ii error only functions.
eesirequired the use of few error only functions.
finding these error only functions was easy because they mostly contained errorin their name.
for example openssl was analyzed using the single error only function err put error .
iii initial error specification.
eesirequired the use of few initial error specifications.theerrorspecificationforallocationfunctions such asmalloc calloc and slab alloc was used as initial error specificationwhenrunning eesiontheprograms aslistedin table2.errorspecificationsfor13 pthreadlibraryfunctionswas usedas initialerror specification when analyzing netdata.
theerrorspecificationsforthefollowingfunctionswasalsoused when analyzing linux fs sync inode metadata ext4 inode locandjbd2 journal metadata .
these functions were identified by looking at the position of their corresponding vertices in thereturnpropagationgraphgeneratedforlinuxfilesystems.a return propagation graph is a directed graph where every vertex representsaprogramfunctionandthereisanedgefrom utovif the function corresponding to vpropagates the return value of the function corresponding to u. if many vertices are reachable from a source vertex uin the return propagation graph then eesiis more likelytoinfererrorspecificationsfornewfunctionswhentheerror specification for the function corresponding to uis provided as an initialerror specification.
analysis and bug checking performance.
eesiandeccare implementedusingllvm andareavailable at com ucd plse eesi .
the full linux kernel analysis was run on an amazon ec2 r4.2xlarge instance while the rest were run on a .
ghzi7 4790cpuwith32gbofram.table 1showstheruntime performance of eesiandecc.
for out of programs eesitakes less than one minute to run.
the analyses of openssl linux fs andfulllinuxkerneltake1min33sec 5min25sec and12min sec respectively.
eccis also efficient with full linux kernel taking the mosttime min sec.
.
rq1 accuracyof eesi eesiidentifieserrorspecificationsfor18 919functionsamongall programsanalyzed.table 2providesanoverviewofthetypesof table size of programs in kloc thousands of lines of code andruntimeperformanceofeesiandecc timesare minutes secondsofelapsed wall clocktime .
kloc eesi ecc openssl pidginotrv4 mbedtls netdata linux fs linux nfc fulllinux kernel littlefs zlib 470esec fse august 26 30 tallinn estonia defreez martinsonbaldwin rubio gonz lez andthakur table domainknowledgeused byeesiandthetotal numberofspecification pertype inferred byeesi error only functions initialerror specifications specificationsinferred byeesi program ec funcs example specs example nequal0 openssl err put error malloc pidginotrv4 na malloc mbedtls mbedtls strerror calloc netdata perror malloc linux fs ext4 error 7ext4 inode loc linux nfc na slab alloc fulllinux kernel na slab alloc littlefs na na zlib na malloc total inferred specifications.
the two most common types are 0and 0with a total of specifications.
we observe that integerreturning functions commonly return a negative number onerror which is a strong convention in the linux kernel and that pointerreturning functions commonly return null pointer on error.
however theseconventionsarenotalwaysadheredto eesialso infers2 475errorspecificationsofthetypes nequal0 and .
openssl linux fs and full linux kernel include specifications from all types.
for example eesiinfers that the linux fs function ext4 read dirblock figure2 has the errorspecification .
we compared theoutput of eesiwiththeground truthfor395 functions to evaluate the accuracy of the specifications inferred by eesi.
ground truthwas obtained via manual review of thesource code.
these specifications included a random sample of correct specifications from the projects in table a random sample of correct openssl functions all correct functions defined by the zlib library and an additional correct randomly sampled specifications in opensslthat overlap between eesiand apex section .
.
.
in total of the function error specifications inferred by eesiexactly matched the ground truth.
thus the estimatedprecision of eesiis0.
.
oneoftheprimarysourcesofinaccuracyin eesiiswhenafunctionusesanoutparameterinsteadofareturnvaluetosignalerrors.
figure6showsonesuchcasewherethevalue 0isincorrectlyinferred as an error value for tcp fastopen defer connect when actually the pointer argument erris set to enobufs .
pointer 1bool tcp fastopen defer connect struct sock sk int err ... 4if tp fastopen req tp fastopen req cookie cookie 6else err enobufs 8return false false is defined as figure eesi incorrectly infers that is an error value for tcp fastopen defer connect duetotheuseofanoutparametererrto signalerrors.operands behave similarly to return values in that the caller needs to check errinstead of thereturnvalue.
weplanto address this infuture versionsofthe eesiimplementation.
frommanual inspectionof395functions weconcludethat eesiinferserrorspecificationswithaprecisionof0.
answeringrq1.
.
rq2 comparisonwith state of the art thissectionpresentsaqualitative andquantitative comparison of eesiwith the error specification inference toolapex .
.
.
qualitativecomparison.
wecomparethetoolsintermsof the following fourcharacteristics eesi analyzes implementations directly.
eesiinfers function error specifications directly from the program.
apex relies on clients of the program to infer function error specifications.
obtainingandbuildingindividualclientsaddsasignificantamountof manual effortto the specification inference task.
eesi infers specifications for internal and api functions.
eesiinfers specifications for internal and api functions while apex is limited to frequently used api functions.
an api function table3 qualitativecomparisonofeesiwithapex.
eesi analyzesprogramsdirectlyinsteadofrequiringtheirclients.
eesiinfersfunctionerrorspecificationsforbothinternal andapifunctions.
eesiincorporatesdomainknowledge insteadofrelyingonthepath lengthheuristicusedbyapex.
eesi scales to large programs while apex does not due to its use ofpath sensitive symbolicexecution.
eesiapex directanalysis 2a api functions 2b internal functions domainknowledge scalable 471effective error specification inference esec fse august 26 30 tallinn estonia table quantitative comparison of eesi with apex.
allfnsis the total number of non void functions defined by the library.
apifnsisthenumberofnon voidfunctionsdefinedbythelibrarythatarecalledfromoneoftheclientslistedinsection .
.
.
timecompares the time each tool requires to perform its analysis mm ss .
total specs is the intersection of the tool output withallfns.apispecs istheintersectionofthetooloutputwith apifns.precision istheratioofcorrectspecificationsreported bythetooltothetotalnumberofapispecsreportedbythetool.
recallistheratioofthetotalnumberofapispecsreported bythetooltothetotalnumberofapispecsthatcanreturnanerror.theopensslresultswerecalculatedforarandomsample of50apifunctions.
time total specs api specs precision recall allfns apifns eesiapex eesiapex eesiapex eesiapex eesiapex zlib .
.
.
.
openssl .
.
.
.
is a function that is defined in a library and called by clients of thelibrary.internalfunctionsarefunctionsthatarenotavailable toclients.internalfunctionsareoftenrefactoredintosmallfunctionswhichareonlycalledfromafewlocations.therefore relying on patterns among a large number of calls to these functions to determinetheerrorspecificationofafunctionisnotaviableoption.
eesiincorporatesdomainknowledge.
eesiisbootstrapped withsmallamountsofdeveloper providedknowledge.thisinput providesafirmfoundationonwhichadditionalfunctionerrorspecificationscanbeinferred.incontrast apexreliesontheassumption that error paths are shorter than non error paths.
this assumption frequentlydoesnothold.thefunction sidtab reverse lookup is one example that illustrates the problem with this approach.
an excerptfromthisfunction simplifiedforthepurposeofpresentation isshowninfigure .atthetopofthefunction acachelookup isperformedtocheckiftheentrycanbereturned.whenthecache lookup is successful the function returns 0along the shortest path throughthefunction.theerrorcode enomemisreturnedonfailure this errorpathisconsiderably longer thanthe successpath.
eesiscalestolargeprograms.
evenforlargeprogramssuch asthelinuxkernel eesiisabletoinfererrorspecificationsforthousands of functions in only a few minutes .
apex can take hours to infer specifications for only the api functions insmalleruser spacelibraries .apexreliesonpath sensitive symbolic execution provided by clang static analyzer which has already been extensivelyoptimizedfor performance.
1static int sidtab reverse lookup struct sidtab s struct context context u32 index ... 4rc sidtab rcache search s context index 5if rc return 7rc enomem ... statements omitted 9rc 10out unlock 11return rc figure example ofashort non errorpath fromlinux5.
.
quantitativecomparison.
weprovideaquantitativecomparisonofeesiwithapexforthelibrariesopensslandzlib.weused theclientslistedin toinferspecificationsforopenssl and zlib with apex clamav .
.
curl .
.
gnutls .
.
httpd1.
.
lighttpd .
.
lynx .
.
nginx .
.
openssh .0p1tor0.
.
.
andmutt .
.
.wecomparedapexresultstotheresults obtainedwhenrunning eesionopensslandzlibdirectly without the needto analyze theirclients .
notethatapexcantreatanapplicationasaclientofitself however this requires the application to include a large number of calls toitsfunctions.weattemptedtouseapextoinferspecificationsin thelinuxkernelwhentreatingitasaclientofitself.apexcrashed whenrunonthelinuxkernel thesymbolicexecutionphaseproduced constraints that the apex analysis scripts were unable to process.apexalsocrashedwhenusingopensslasaclientofitself thus we did not include it when running apex for openssl.
we didnotconsiderrunningapexontherestofourprogramsbecause either they are not libraries or they do not include a large number offunctioncallsforapextobeeffective.togatherrun timeperformance thetoolswererunonanamazonec2c5.9xlargeinstance with36 cpucores and72gbof memory.
all25non voidzlibapifunctionswereusedforevaluation.due to the size of the openssl library a randomsample of non void openssl api functions were used for evaluation.
precision and recallaredefinedintermsoftheexpectednumberofapifunctions the number of api functions that are called from any of the clients considered by apex that can return an error value according to groundtruth.groundtruthwasestablishedbymanuallyreviewing the zlib and openssl source code.
of the zlib api functions could return an error.
of the randomly sampled openssl functions could return an error.
definition .
precision andrecallare definedas precisiondef correct total recalldef total ground ground wheretotalisthesetofspecificationsreportedbythetool correct isthesetofspecificationsreportedbythetoolthatmatchtheground truth and groundis the ground truth set of non void functions that can return an error.
table4lists the total number of functions and the total number of api functions for each library.
the table also summarizes 472esec fse august 26 30 tallinn estonia defreez martinsonbaldwin rubio gonz lez andthakur table summary ofbugsreported byecc.
tbr total bug reports ct confidence threshold ibr inspectedbugreports cb confirmedbugs pb potentialbugs bb benign bugs fp falsepositives.
ibrbreakdown tbr ct ibr cb pb bb fp openssl .
pidginotrv4 mbedtls netdata linux fs .
linux nfc .
fulllinux kernel .
littlefs zlib total theresults.becauseapexreliesonclientstoinferfunctionerrorspecifications itonlyinfersspecificationsforapifunctionsandnot internalfunctions.thisisreflectedinthedifferenceinthetotalnumberofspecificationsinferredbyeachtool the totalspecs column intable4 .inparticular eesifinds8 and11 morespecifications than apex in zlib and openssl respectively.
when restricting the comparisontoapifunctions eesialsofindsmorespecifications than apex while exhibiting higher precision and recall for both libraries in considerably less time.
eesitook sec to analyze zlib and1min19sectoanalyzeopenssl.apextook2hoursand1.
hoursto analyze the clientsofzlib andopenssl respectively.
in addition to the randomly sampled openssl api functions wealsorandomlysampled150opensslspecificationsforfunctions where both eesiandapex providedaspecification.of these eesispecifications and118apexspecifications were correct.
eesiinfers specifications for internal and api functions is not dependent on the path length heuristic is more scalable ismoreprecise andinfersmoreapifunctionspecifications thanthe state ofthe art.
this answers rq2.
.
rq3 usefulnessof eesispecificationsin bug finding in this section we evaluate the bug finding effectiveness of ecc section4 which uses the function error specifications inferred byeesi section3 .
table5summarizes the bug reports produced byecc.
the total bug reports tbr per program varied from to .theibrcolumnliststhenumberofbugreportswemanually inspected.
we inspected all bug reports for the programs for whicheccgenerated less than bug reports.
for the remaining programs we computed a confidence for each bug report and onlyinspectedbugreportswhose confidencewasgreaterthanor equal to the confidence threshold ct .
the confidence threshold waschosensoastolimitthenumberofinspectedbugreportsto around 100per program.the confidence ofabugreportinvolving the returnvalueofafunction fisdefinedasthe number ofcalls tofthat have correct error checks divided by the total number ofcallstof.therestofthesectiondescribesthebreakdownofthe inspectedbugreports ibr breakdown .
confirmedandpotentialbugs.
intotal wefound 110confirmed bugs cb and107potentialbugs pb .confirmedbugs includethe following bugsthatwereportedandwereconfirmedbydevelopers bugsthatwereindependentlyfoundbyothers andbugs that we confirmed ourselves .
potential bugs are instances in whichthereportisnotanobviousfalsepositive butthecomplexity ofthecodepreventsusfromconfirmingthebugwithoutadditional input from developers.
of the confirmed bugs bugs were previously unknown all of the potential bugs were previously unknown.
herepreviouslyunknownmeansthat toourknowledge no one knew about them.
all bugs were previously unknown to us.
note that confirmed bugs have been found in all programs exceptforlittlefsandzlib.weareintheprocessofreportingall confirmedandpotentialbugstodevelopers.patchesweprovided for two of the openssl bugs were merged into openssl for the .
.1brelease .
confirmed bugs in linux.
eccfound24 previously unknown confirmed bugs in version .
rc3 of the linux kernel using error specifications generated by eesi.
figure8shows one such bug.
infigure a thefunction hid modify dquirk returnstheerror code enomemonline6ifkzallocisunable toallocate memory.
the function hid quirks init in figure b correctly checks the return value of hid modify dquirk on line5 but fails to propagate the error value.
consequently eesiinfers that the error specificationfor hid quirks init is .notallerrorsneedtobe propagated but in this case we observe an inconsistency between the error specification for hid quirks init and the error check online4infigure c .theerrorcheckonline 4resultsindead code.
confirmed bugs in openssl.
eccfound8 previously unknown confirmed bugs in version .
.1a of openssl.
patches sent by us for two of these bugs have been merged and we are in the processofreportingthe remaining.
figure9shows a previously unknown bug that eccfound in openssl.online thecallto m asn1 new of canreturnanull pointer on memory allocation failure.
on line this pointer is dereferenced resultinginasegmentationfaultif rekisnull.we generatedapatchforthisbug whichwasacceptedbytheopenssl developers andmergedintoopenssl .
.1b .
it is not immediately obvious that m asn1 new of can return a null pointer at all and even less obvious that it returns a null pointerinresponse tomemory allocationfailure.
m asn1 new of is a macro wrapping the function asn1 item new .asn1 item newreturnsnull when asn1 item ex new returnsnull which in turnpropagatestheerrorfrom asn1 item embed new whichreturns null when the openssl zalloc macro wrapping crypto zallocfails whichpropagateserrorsfrom crypto malloc .finally crypto malloc failswhen mallocreturnsanullpointer allowing eesito infer that on line rekwill be null when mallocfails.
trackingdownsuchlongerror propagationchainsmakesitdifficult for adeveloper to manually inferfunction errorspecifications.
because of its importance openssl has been reviewed extensively.
in january quarkslab performed a security assessmentoftheopensslcode spending60man daystoauditfour 473effective error specification inference esec fse august 26 30 tallinn estonia 1static int hid modify dquirk ... ... 3intret 4hdev kzalloc sizeof hdev ... 5if !hdev 6return enomem ... 8out 9kfree hdev 10return ret a hid modify dquirk returnszeroonsuccess and a negativeerror on failure.1inthid quirks init ... ... 3for n count qparam n ... 5if hid modify dquirk ... !
6pr warn could not parse hid quirk module param 9return b hid quirks init checks for hid modify dquirk serror butfailsto propagate it.1static int init hid init void 2intretval enomem 3retval hid quirks init ... 4if retval gotousbhid quirks init fail ... 7return ... 9usbhid quirks init fail 10return retval c hid init expectserrortopropagate resulting indead code.
figure bug found by ecc in linux .
rc3 resulting from an incomplete error specification.
the error originating in a is notpropagated by thefunction shownin b .the missing propagation results indeadcodein c .
1intcms recipientinfo kari init ... 2ri d.kari m asn1 new of cms keyagreerecipientinfo 3if !ri d.kari return ... 6rek m asn1 new of cms recipientencryptedkey ... 8if flags cms use keyid rek rid type cms rek keyidentifier figure9 nullpointerdereferencefoundbyeccinopenssl which was previously unknown to the openssl developers.
we provided apatch that was merged into openssl .
.1b.
components of openssl .
in the code quality section of their report on the secure remote password srp protocol they find eight cases where the return value of a function is not checked for errors.sevenoftheseeightbugsarereported byecc .
confirmed bugs in pidgin otrv4.
eccfound31 previouslyunknown confirmederror handlingbugs inthepidginpluginthat supports the upcoming v4 standard of off the record messaging otr .
otr provides deniability for instant messaging conversations making it useful for journalists and other actors in situationswhere itmightbeimportant todenythata conversation occurred.
this otr plugin was chosen because of its global importance and because the developers had identified error handling bugsasahighpriority.thedefectsidentifiedby eccwouldlead to crashesorotherundefinedbehaviorinthe plugin.
benign bugs.
table5also reports benign bugs bb .
these areinstancesinwhichchecksareindeedmissing ecccorrectly reports them but the missing checks do not result in a serious enough problemtowarrantafix.
anexample ofthiswouldbe an unchecked output error during logging even though the specificationiscorrect the errorisconsideredbenign inour evaluation.
falsepositives.
table5showsthenumberof falsepositives fp reported by ecc.
table6showsa breakdown of the types of false positives we encountered while inspecting the bug reports for the threeprograms withthe mostfalsepositives.
incorrectspec false positives occur in eccwheneesihas inferred the incorrect errortable6 breakdownoffalsepositivesineccbugreportsfor asubset ofprograms.
linux fs openssl fulllinux total incorrectspec missedchecks interprocedural outparameter nofail total specification for a function.
only one of the false positives in ecc wasdueto inaccuraciesinerrorspecifications inferredby eesi.
thelargestnumberoffalsepositivesaredueto missedchecks where the implementation of eccfailed to identify an error check.
forexample thelinuxkerneldefinesassertionfunctionsthatcrash thekerneloncertainconditions.
eccisnotawareofthesefunctions and therefore reportsthereturnvalueasunchecked.improving eccto remove such false positives ispart of future work.
interprocedural falsepositivesoccurwhentheerrorvalueis passed as an argument to callee function that contains the error check.
outparameter falsepositivesoccurwhenthe error value is assigned to an out parameter and the caller function contains the error check.
finally the nofail false positives are peculiar to linux where memory allocations can be requested that will not fail the memory allocator willloopindefinitely .
eccdetected246 error handling bugs across9programs of which have been confirmed.
eccdetected previously unknown bugs of which are confirmed and weareinthe processofconfirming107potentialbugs.
two patcheshavealreadybeenmergedintoopenssl.finally ecc identified29 benign bugs.this answers rq3.
.
threatsto validity the function error specifications inferred by eesiare of course dependentuponthedomainknowledgeprovided.asseenintable 474esec fse august 26 30 tallinn estonia defreez martinsonbaldwin rubio gonz lez andthakur thetotalnumberofinputsissmall anditwouldbeeasyforproject developers to providemore domainknowledge withlittleeffort.
eesiwas evaluated on the programs in table .
our results may notgeneralizetosoftwarethatexhibitssignificantlydifferenterrorhandlingbehavior.however theseprogramswerechosentobea representative crosssection ofimportantsoftware written inc. related work error handling specifications.
acharya and xie use data miningtechniquesonstatictracestomineerror handlingspecifications for relevant apis used in software packages.
the approach follows a restricted classification of error handling code and limits toidentifyingerrorchecksandcleanupcodeinclientcode.kang et al.
introduce apex a tool for finding error specifications for api c functions.
section .3presents a detailed qualitative and quantitative comparison between eesiandapex.
fault injection techniques have also been used toextract errorhandling specifications .
fetzer et al.
introduce the notion of failure atomicity in the context of exceptions and proposetechniquestoautomaticallydetectandmasknon atomic exception handling in c and java applications.
s kraut and fetzer detect and patch incorrect c error handling client code.
incorrecterror handlingcodeisidentifiedwhenthesystemcrashes.
patchingtransformsunhandlederrorsintoerrorstheapplication can handle.
prabhakaran et al.
build models of how journalingfilesystemsmustbehave under differentjournalingmodes andusethesetofinderror handlingspecificationsrelatedtodisk write failures.
marinescu and candea describe a framework for testingrecovery code througherror code injection.
eesiis a static analysis tool and therefore better suited to handling systems software such as the linux kernel.
the linux kernel comes equipped with a fault injection framework but injecting errors into software that interacts with devices is difficult as it requiresthehardwaretobepresent.foruser spacecode eesiis complementary to dynamicfaultinjection.
functionerror specificationstofinderror handlingbugs.
a numberoftoolsrequirefunctionerror specificationstodetectbugs orinferhowerrorsshouldbehandled.epex takesasinputthe errorvaluesthatafunctioncanreturnandreportsaspotentialbugs error paths that do not handle the error where error handling is definedasreturninganerrorvalue logging orexiting.errdoc isanimprovementoverepex whichtakesasinputspecifications inferred using apex.
because apex cannot be used to infer specifications for functionsin the linux kernel errdoc cannotbe usedto findorfixerror handlingbugsinthelinuxkernel.defreezetal.
createdfunc2vectoembedfunctionsinavectorspacesuchthat functionsthatfulfillthesameroleorpurposeareincloseproximity and used this embedding to improve the quality of error handling specifications.
their specification miner takes as input function error specifications.
eesiis scalable and capable of inferring more functionspecificationsthanthestateoftheart.therefore allthese toolscould benefitfrom eesi.
otherapproachestofindingerror handlingbugs.
staticanalysis techniques have been proposed to track the propagationoferrorcodesinsystemssoftwaretofindawiderange oferror handlingbugssuchasdroppederrorcodes.sahaetal.
present a static analysis to find resource release omission faults inccode.juxta isasymbolic executionbasedapproachto find semantic bugs including error handling bugs across linux file systems.
henkel et al.
use code embeddings to detect incorrectreturnederrorcodesinlinuxcode.byusingtheexpressive error specifications inferred by eesi eccis able to find subtle error handling bugs that do not necessarily involve error codes see section 2and section which is beyond the capability of the above techniques.
finally a large body of work e.g.
has proposed static analysis to find error handling bugs in java programs whichare outsidethe scope of this paper.
conclusion this paper presented eesi a static analysis to infer function errorspecificationsforprogramswrittenincthatusethereturn code idiom.eesibootstraps the analysis by using three types of domain knowledge error codes error only functions and initial error specifications.theinferencerulesusedby eesiexpandon this initial domain knowledge to infer additional function errorspecifications.ourevaluationof eesionreal worldprograms such asopensslandthelinuxkernel showthat eesicanaccurately infer function error specifications while scaling to large programs.
we demonstrated how the function error specifications inferred byeesican be used to automatically find bugs related to incorrect error handling by building a tool named eccto find three types of error handling bugs insufficient error checks inverted error checks andincompleteerrorspecifications.
eccdetected246bugs across programs of which have been confirmed as actual bugs.eccdetected previously unknown bugs of which are confirmed andweareintheprocessofconfirming107potential bugs.twopatcheshave already been mergedintoopenssl.
the careful orchestration of intraprocedural flow sensitive analysesandinterproceduralcontext insensitiveanalysisallows eesi to be scalable and precise.
as shown in our evaluation eesitakes onlyminutestorunonevenverylargeprogramssuchasthelinux kernel.eesioutperformsthestateoftheart inprecision recall and performance.
furthermore by not relying on heuristics based onusageoffunctionsorempiricalpropertiesoferrorpaths eesi ismore generallyapplicable.
thescalabilityof eesimakesitagoodfitforcontinuousintegrationanddeliverypipelinesthatruntoolsoneverycommit.
eesi could be used tonotifydeveloperswhen the errorspecificationof afunctionhaschanged.giventhelongerror propagationchains that occur in large programs this can be particularly useful as changing the error specification of a function can have unintended consequencesthat result indefective error handling code.