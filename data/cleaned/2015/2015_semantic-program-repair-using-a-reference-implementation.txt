semantic program repair using a reference implementation sergey mechtaev national university of singapore mechtaev comp.nus.edu.sgmanh dung nguyen national university of singapore nguyenmanhdung1710 gmail.comyannic noller humboldt university of berlin yannic.noller informatik.hu berlin.de lars grunske humboldt university of berlin grunske informatik.hu berlin.deabhik roychoudhury national university of singapore abhik comp.nus.edu.sg abstract automated program repair has been studied via the use of techniquesinvolvingsearch semanticanalysisandartificialintelligence.
most of these techniques rely on tests as the correctness criteria which causes the test overfitting problem.
although various approaches suchas learning from code corpus have been proposed to address this problem they are unable to guarantee that the generatedpatchesgeneralizebeyondthegiventests.thisworkstudies automated repair of errors using a reference implementation.
the referenceimplementationissymbolicallyanalyzedtoautomatically infer a specification of theintended behavior.
this specification is thenusedtosynthesizeapatchthatenforcesconditionalequivalence of the patched and the reference programs.
the use of the reference implementation as an implicit correctness criterion alleviates overfitting in test based repair.
besides since we generate patches by semantic analysis the reference program may have a substantially different implementation from the patched program which distinguishes our approach from existing techniques for regression repair like relifix.
our experiments in repairing the embedded linux busybox with gnu coreutils as reference and vice versa revealedthattheproposedapproachscalestoreal world programs and enables the generation of more correct patches.
ccs concepts software and its engineering automatic programming software verification keywords debugging program repair verification acm reference format sergeymechtaev manh dungnguyen yannicnoller larsgrunske andabhikroychoudhury.
.semanticprogramrepairusingareferenceimplementation.
in proceedings of 40th international conference on software engineering gothenburg sweden may june icse pages.
joint first authors permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
introduction software developers spend a significant amount of time and resourcesforbugfixing.automatedprogramrepairhasgainedprominenceduetoitspotentialtoreducethemanualdebuggingeffortby automaticallysuggestingpatchesforgivendefects.indeed stateof the artprogramrepairsystemshavebeenshowntobeableto address defects in real world software.
however the low quality ofautomaticallygeneratedpatchesremainsagreatbarriertothe adoption of this technology by software developers in practice.
problem.
theprimaryreasonforthelowqualityofautomatically generatedpatchesis thelackofspecifications oftheintendedbehavior.mostprogramrepairsystemsrelyontestsasthecorrectness criteria because a formal specification is often unavailable in practice.
however since tests is an incomplete specification generated patchesoftendonotcorrespondtodeveloperintentions butmerely overfit thetests.inordertoincreasethe qualityofautomatically generatedpatches researchershaveproposedsuchtechniquesas patchprioritization anti patterns testgeneration etc.althoughthesetechniquesincreasetheprobabilityoffinding correctpatches theyneverthelessdonotprovideany correctness guarantees beyond the tests in a given test suite.
intuition.
to address the overfitting problem we propose to automatically infer the missing specification for a buggy program from a correct reference program.
a reference program is an alternativerealizationofthesamefunctionality whichisoftenavailable forlibraries e.g.standardlibraryimplementations audiocodecs compressionalgorithms parsers cryptographicalgorithms network protocols commodity software e.g.
gnu coreutils and busyboximplementthesamesetofunixutilities intheareaofdigital signal processing web servers anddatabase management systems.notethatareferenceprogrammayhaveasubstantially different implementation different data structures and algorithms which distinguishes our approach from repair techniques that employ previous program versions.
the use of a reference programenablesustoalleviatetestoverfittingandprovidesadditional correctness guarantees.
challenges.
ideally ageneratedpatchshouldenforcetheequivalence of the patched and the reference programs which poses two challenges scalability and applicability.
first a recent work reported that a straightforward combination of an equivalence checkingsystem withcounterexample guidedinductivesynthesis tosynthesizeequivalence enforcingpatchesisnotscalable.
second real world implementations of the same functionality rarelyfollow preciselythesamespecification e.g.gnucoreutils acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden mechtaev et al.
implementsasupersetofthefunctionalityimplementedinbusybox and therefore cannot be directly used for equivalence checking.
solution.
toaddresstheabovechallenges weintroduceamethodologyofpatchgenerationbasedonareferenceimplementationthat integratesthenotionofconditionalequivalence andarecent scalable patch generation algorithm .
we rely on the user insighttoprovidean inputcondition forpatchgenerationthatshould includeabug triggeringinputand correspondtofunctionalitysharedbythebuggyandthereferenceprograms.then our systemautomaticallygeneratesapatchforthebuggyprogramthat enforcesconditionalequivalence ofthepatchedandthereference programs that is equivalence for all inputs satisfying the provided condition.althoughtheuserisonlyrequiredtoprovideaninput condition the propertybeingcheckedisderivedautomaticallyfrom thereferenceprogram thisstillmaybenon trivialforapplications that involve a complex execution setup.
to tackle this problem we propose a practical approach of introducing an input condition basedontheideaofparameterizedtests i.e.theconditionis defined by injecting symbolic parameters into existing tests.
contributions.
the main contributions of this work are we propose to infer a correct specification from a reference implementation and use it to guide program repair in order to address the test overfitting problem.
weintroduceascalablealgorithmofpatchgenerationbased on a reference implementation that guarantees conditional equivalence of the patched and the reference programs w.r.t.
a user defined input condition.
we conduct an evaluation on two implementations of unix utilities gnucoreutilsandbusybox thatdemonstratesthat ourmethodologyaddressesthetestoverfittingproblemof program repair and scales to real world software.
overview ourapproachtakesfourinputs atestsuite abuggyandareference program and a user defined input condition figure .
asthefirststep thenode faultlocalization offigure1represents the identification of suspiciousexpressions that might need to get repaired.thisisdonebyapplyingstatisticalfaultlocalization based on the given test suite and the buggy program.
the suspiciousexpressionsinthebuggyprogramgetreplacedwithsymbolic variables denoted as the instrumented buggy program.
as the second step the module symbolic analysis of figure contains the symbolic execution of the reference program and the instrumentedbuggyprogramusingtheuser definedinputconditionasaprecondition.theresultofeachsymbolicexecutionisa set of pairs of resulting path conditions and symbolic output states see definition .
that is used as a specification.
as the last step the inferred specifications for the reference andthebuggyprogramsarepassedintothepatchgeneratorthat performsa counterexample guidedinductiverepair loop.specifically itperformsthefollowingiterationsstartingfromtheoriginalbuggy expression as the initial empty patch construct a verification condition vc for the patch.
generate a counterexample input that violates the conditional equivalence property by solving vc.buggy program test suite user defined input conditionreference implementation fault localization symbolic execution of instrumented buggy programsymbolic execution of reference program conditional equivalence checker angelic forest extractorpatch synthesizer patchinput symbolic analysis counterexample guided inductive repair figure overall workflow of the approach.
extract an angelic forest for the generated input.
synthesize a patch that satisfies the angelic forest.
go to step .
thislooprepeatsuntilaconditionalequivalence enforcingpatch is synthesized or the next patch angelic forest cannot be found.
toillustrateourapproach weconsiderthereferenceprogram in figure 2a and the buggy program in figure 2c.
the reference programimplementsanalgorithmofsearchingforanelementof anarrayvialinearsearch whilethebuggyprogramsusesbinary search.
the buggy program contains a bug in line .
acrucialelementofourapproachistheinputcondition that hastobedefinedbytheuser.themosttrivialchoiceoftheinput conditionwouldbesimply true i.e.
checkingequivalenceforall programinput.however thisapproachmayhaveapoorscalability as it has been reported in previous works .
instead we suggest definingtheinputconditionbyparameterizingexistingtests.specifically not all inputs of a test case must be considered concretely some of them can be handled symbolically.
therefore the user can transform the test cases in logical constraints and possibly add additionalconstraints.thisrepresentsapracticalsolutiontobalancethecompletenessandscalabilityofautomatedprogramrepair.
the wider the input condition is formulated the more complete in terms of covered input space will be the generated patch.
todefinetheinputcondition assumethattheuserformulates itinformallyinthefollowingway weonlyconsidersortedarraysof the length and without duplicates.
first we introduce a mapping between program variables and symbolic variables x mapsto a mapsto length mapsto authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic program repair using a reference implementation icse may june gothenburg sweden 1intsearch intx inta intlength 2inti 3for i i length i if x a return i 7return a reference programid r r out r1 0 r2 nequal 0 1 r3 nequal 0 nequal 1 22 r4 nequal 0 nequal 1 nequal 2 b summary of reference program 9intsearch intx inta intlength intl intr length do intm l r if x a return m else if x a bug fix x a l m else r m while l r return c buggy programid b c b out b1 1 b2 nequal 1 0 2 0 x mapsto a mapsto 1 b3 nequal 1 0 nequal 2 1 0 x mapsto a mapsto 1 1 x mapsto a mapsto 2 b4 nequal 1 0 nequal 2 1 0 x mapsto a mapsto 1 1 x mapsto a mapsto 2 b5 nequal 1 0 0 0 x mapsto a mapsto 1 b6 nequal 1 0 nequal 0 1 0 x mapsto a mapsto 1 1 x mapsto a mapsto 0 b7 nequal 1 0 nequal 0 1 0 x mapsto a mapsto 1 1 x mapsto a mapsto 0 d specification of buggy program negative input x mapsto a mapsto length mapsto expected output symbolic inputs x mapsto a mapsto length mapsto input condition colonequal 0 1 2 e test and input conditionvc 0 1 2 logicalanddisplay r r out logicalanddisplay b b out r b e dblbracketleft c dblbracketright r out b out 0 1 2 r1 b3 0 nequal 1 0 0 1 nequal 2 1 1 2 r1 b4 0 nequal 1 0 0 1 nequal 2 1 1 2 r3 b6 2 nequal 1 0 0 1 nequal 0 1 1 0 r3 b7 2 nequal 1 0 0 1 nequal 0 1 1 0 f verification condition figure artifacts of motivating example then the input constraint is defined as follows colonequal 0 1 2 the given test suite contains one negative test case with the input x mapsto a mapsto length mapsto and the expected output because the first element is equal to the searched value .
the testcasepassesforthereferenceprogram butfailsforthebuggy program.
the statistical fault localization identifies the expression in line as a suspicious expression hence we introduce the symbolicvariable andgenerateaninstrumentedbuggyprogramby replacing x a with .
note that the test case is not encoded intheinputcondition i.e.
therepairstepsthemselvesareindependentfromanygivenconcretetestinput.thistestcaseisonly needed for the identification of suspicious expressions.
assuming we execute the reference and instrumented buggy program with a preconditioned symbolic execution.
preconditioned symbolic execution see definition .
explores only a subset of programpathsthatareconsistentwiththecondition .wewillget theresultspresentedinfigure2bandfigure2d.thetablescontain so calledspecifications see definition .
which describe the path condition rfor the reference program and bfor the buggy program the current context for the suspicious expression c and the output symbolic state r outfor the reference program and b out for the buggy program .
the superscript index of indicates theoccurrence id or instance id of this expression since it can be visited more than once during the execution.
withtheresultsofthepreconditionedsymbolicexecutionwe canbuildtheformulaoftheverificationconditionfortheconsideredexpression x a .averificationcondition vc encodes thefollowingidea ifbothexecutionsinthereferenceandbuggy program follow the same path then their outputs should be the same.
the vc will also encode the values of the visible variables intheexpression x a computedinthesymboliccontext c that we denote as x a dblbracketleft c dblbracketright.
the simplified version of this first iteration vc is presented in figure 2f.
we skipped contradictingpairsofpathconditionsfromthebuggyandthereference program and discarded pairs that contradict the input condition .
additionally wesimplifiedtheformulabyremovinglineswhere the symbolic output states match already i.e.
r out b out.
in such casestheimplicationisalways trueand hence itdoesnotprovide anyadditionalvalue.theremainingformulaincludesthefollowing combinationsofpaths representedbytheaccordingidsinfigure2b and figure 2d r1 b3 r1 b4 r3 b6 r3 b7 as also indicated at the beginning of each line in the shown vc.
in order to check the validity of the verification condition we checktheunsatisfiabilityofitsnegationasinpreviousworks .thenegatedvcwillbesolvedusinganoff the shelfsmtsolver to generate satisfying values representing counterexamples which authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden mechtaev et al.
donotsatisfythevcwiththecurrentreplacementforthesuspicious expression.
after negating the vc the smt solver generates a counterexample input x mapsto a mapsto .
in order to find the correct truth value for also called angelic value seedefinition3.
welookatthepathconditionofthebuggy programthatleadstothecorrectoutputsymbolicstate whichis here r out 0accordingtothereferenceprogram.comparingwith thetableinfigure2d thisoutputcanonlybereachedinthebuggy program by following the path b5.
in order to take this specific pathwiththegiveninputvalues 0needstobe false.thisleads to the following angelic forest which is the input structure for our synthesizer and represents all needed values for the specific suspicious expression see definition .
0 c given that c colonequalfalse colonequal x mapsto a mapsto wherecrepresentsanangelicvalueoftheconsideredexpression a value that enables the program to pass the counterexample test and representsanangelicstate theconcretevaluesofprogram variables in the context in which the expression is executed .
thegeneratedvaluesareusedtobuildtheinputforacomponentbased synthesizer which generates a new patch matching the current synthesizerinput.
given this input the synthesizer returnsa plausiblepatch x a .after insertingthisexpression inthe vc and negating it the smt solver generates a second counterexample input x mapsto a mapsto .
the correct output symbolic stateforthisinputis r out 2andthismatchesonlythepath b2.in ordertotakethisspecificpathwiththesecondcounterexample 0 needstobe true.thisleadstoanextensionofourangelicforestto 0 false x mapsto a mapsto 0 true x mapsto a mapsto .
given this input the synthesizer returns the patch x a .
after inserting this expression in the vc and negating it the smt returnsunsatisfiable i.e.
thesynthesizedpatchfulfillsallrequirements.notethat x a isnotsyntacticallyequivalentwith thecorrectpatch x a butinthiscontext i.e.withthepreceding if condition both expressions are semantically equivalent.
our approach results in a patch for the buggy program so that given the input condition the patched programis conditionally equivalent with the reference program.
for comparing with test driven repair techniques we applied angelix whichusesasimilarpathgenerationalgorithm and hence itrepresentstheclosestexistingapproachandmeansamore fair comparison than using any other test driven repair technique.
for our motivating example we observed that angelix only canproduce the plausible patch a a .
it fixes only the given negative test case so in order to generate a correct patch it would be necessary to include more test cases.
since our repair approach is capable of using another program as correctness reference itgenerates the input for the synthesizer itself with the presented counterexample guided approach.
inthismotivatingexampleweshowedthatwithourapproach it is possible to use a relatively simple reference program e.g.
thelinearsearch torepairanoptimizedprogram e.g.
thebinary search .thetwoprogramsdonotneedtobestructurallysimilar as long as they solve the same problem.
background inthissection weintroducethenotationusedtoformallydescribethe presentedalgorithms define underlyingprogram analysistech niques andalsointroducerelatedpartsofpreviouspatchgeneration methods that are reused in our approach.
weconsiderprogramswritteninanimperativeprogramming language.
programs are denoted as p1 ... pkand the set of all program asp.
we define p as a program obtained from pby substituting an expression ewithe prime.
program variables are represented as v1 ... vkand the set of all program variables as v. the considered programming language contains a statement assumedefined as follows assume colonequalif loop goto loop thatisthisstatementtriggersanon termination aninfiniteloop when the given condition does not hold.
concrete program states functions from program variables to values areindicatedas andthesetofallconcreteprogramstates isdenotedas twoconcreteprogramstates 1and 2areequal iff v v. 1 v 2 v .thevalueofanexpression eevaluated in the context is denoted as e dblbracketleft dblbracketright.
we define a concrete program execution as in the following definition .
concrete execution .
a concrete execution procedureexec p isafunctionthatforagivenprogram pandaconcreteinputstate inreturnsthecorrespondingoutput state outif the program terminates and the literal otherwise.
we consider a first order language l. we use the letters and to denote variables from l and the letters and to designateformulasfrom l.weusetheletter toindicate symbolic program states that is functions from program variables to logical terms froml for a program variable v the corresponding logical term is v .
we express the equality of two symbolic program states 1and 2as the formula 1 2 colonequal logicalandtext v v 1 v 2 v .
wedenotealogicaltermcomputedbyevaluatinganexpression e in the context ase dblbracketleft dblbracketright.
assume that 1 mapsto n1 ... k mapsto nk is an assignment of the variables froml a mapping from the variables to values .
we say that this assignment satisfiesa formula iff a substitution of the variables iwith the corresponding values ni denoted as dblbracketleft 1 mapsto n1 ... k mapsto nk dblbracketright evaluates to true.
we also introduce a concretization of symbolic states defined as follows definition .
concretization .
let be a symbolic state 1 mapsto n1 ... k mapsto nk be an assignment of the variables from l.a concretization dblbracketleft 1 mapsto n1 ... k mapsto nk dblbracketrightof withtheassignment 1 mapsto n1 ... k mapsto nk is defined as follows dblbracketleft 1 mapsto n1 ... k mapsto nk dblbracketright colonequal v. v dblbracketleft 1 mapsto n1 ... k mapsto nk dblbracketright thatisasaconcreteprogramstate amappingofprogramvariables into values expressedusing lambda notation computedby substituting all the variables iin the logical terms in the codomain of with the corresponding values ni.
in order to infer a specification we rely on symbolic execution that we non constructively define as follows definition .
symbolic execution .
a symbolic execution proceduresymexec p 2l is a function that for a given authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic program repair using a reference implementation icse may june gothenburg sweden programpandasymbolicinputstate inreturnsafinitesetofpairs out where isthepathconditionand outisthecorresponding symbolic output state.
for each assignment of the symbolic variables 1 mapsto n1 ... k mapsto nk if this assignment satisfies the formula then out exec p in given that in colonequal in dblbracketleft 1 mapsto n1 ... k mapsto nk dblbracketrightand out colonequal out dblbracketleft 1 mapsto n1 ... k mapsto nk dblbracketright.
definition .
partial equivalence under .letp1andp2be programs beaprogramstate.wesaythat p1andp2arepartially equivalent under iff at least one of the following holds exec p1 exec p2 exec p1 exec p2 .
sinceprovingpartialequivalenceforallinputsiscurrentlyinfeasible when dealing with large real world programs this work focusesonconditionalequivalence arelaxednotionofpartial equivalence that checks equivalence only for a subset of inputs.
definition .
conditional partial equivalence .
letp1andp2be programs lbeaninputcondition.
wesaythat p1andp2are conditionallypartiallyequivalent underaninputcondition iffthey are partially equivalent under each input in dblbracketleft dblbracketright true .
inordertosynthesizepatches werelyonascalablepatchgeneration methodology proposed in angelix that infers a compact synthesis specification based on angelic values and synthesizes a patch using component based patch synthesis .
definition3.
angelicvalue .
letpbeaprogram tbeafailing test ebe a program expression and eibe itsi th instance in the executiontraceof t.angelicvalue cissuchthatreplacingexpressions eiwithcduring the execution of tmakesppass the test t. definition .
angelic path .
letpbe a program ebe a set of program expressions in p tbe a test.
an angelic path is a set of triples ei c whereeiis thei th instance of an expression e e appearingintheexecutiontraceof t cisanangelicvalueof ei and represents an angelic state at ei such that replacing all eiin the execution trace of twith the corresponding angelic values cforces theprogram ptopassthetest tand theprogram ptobein the state when the expression eiis evaluated.
definition3.
angelicforest .
letpbeaprogram ebeasetof programexpressionsin p tbeatest.
angelicforest atforthetest t is a set of angelic paths for t. anangelicforestcanbeextractedasshowninalgorithm1.fora given program pwith an expression e this algorithm accepts a test apairofinputandoutputstates andasetoftriples c out .
thesetoftriplesiscomputedusingsymbolicexecutioninsucha way that represents apath conditionin p cdepicts asymbolic state that the program preaches when the expression eis evaluated along the path and outrepresents the symbolic output statecomputedalongthepath .thealgorithmiteratesthrough the given triples and extracts angelic values by solving the path constraint conjoined with the given input output relation.
givenanangelicforest angelix canconstructanexpression from a given library of components that satisfies a given angelic forest.
more formally for a given angelic forest atand a set ofalgorithm angelic forest extraction data test in out set of triples c out result angelic forest at 1at 2foreach c out do 3 in out out 4ifissat then mapsto n1 mapsto n2 ... getsatisfyingassignment c n2 c c dblbracketleft mapsto n1 mapsto n2 ... dblbracketright at at e c c 9end 10end 11returnat components c1 ... cn itproducesanexpression econstructedfrom c1 ... cnthat satisfies the following property logicalordisplay path at logicalanddisplay ei c pathe dblbracketleft dblbracketright c suchetakes the angelic value cfor each angelic state and therefore passes the test tby construction.
our approach inthissection weformallydefinethreemaincomponentsofouralgorithm specificationinference verificationconditionconstruction and patch synthesis.
.
specification inference themainintuitionofourapproachisthatitispossibletoinferacorrect specification from a reference implementation and synthesize apatchthatenforcesthisspecificationinagivenbuggyprogram.
hereinafter we refer to the given reference implementation as the programprand the given buggy program as the program pb.
inordertoinferaspecification weusepreconditionedsymbolic execution defined as follows definition .
preconditioned symbolic execution .
apreconditionedsymbolicexecution procedure psymexec p l 2l is a symbolic execution in which each path condition is conjoined with a given formula.
it can be defined as psymexec p colonequal symexec p prime wherep prime colonequalassume p. theimplementationofpreconditionedsymbolicexecutionisdiscussedinsection5.asaresultofaddingthecondition preconditioned symbolic execution is significantly more efficient than conventional symbolic execution since it explores only a subset of program paths that is consistent with the condition .
for a given reference program and an input condition we infer asymbolicsummaryoftheprogramcomputedthroughpreconditioned symbolic execution definition .
symbolic summary .
letpbe a program be an input condition is a symbolic state.
a symbolic summary is a set of pairs sum p colonequal out such that out psymexec p .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden mechtaev et al.
foragivenbuggyprogram asuspiciousexpressionandaninput condition we infer the following specification definition4.
specification .
letpbeaprogram ebeaprogram expression be an input condition is a symbolic state over variables 1 ... k.aspecification is a set of triples spec p e colonequal c out suchthat out psymexec p prime wherep prime colonequal p choose isafunctionthatreturnsafreshsymbolicvariable ieachtimeit isexecuted.foreach path cindicatesasymbolicstateinthecontextofwhichthefunction choose is called when the program is symbolically executed along .
wesaythatasummary sum p iscompleteifforeachinput satisfying the condition one of the following holds exec p out sum p .
dblbracketleft dblbracketright true.
thecompletenessofaspecification spec p e canbedefined in a similar manner.
in order to simplify further definitions we assume without loss of generality that all formulas contain only a single variable representingprograminputsandasinglevariable representing the values of the replaced program expression.
.
verification condition tocheckprogramequivalence weconstructaverificationcondition for agiven patch using the inferredspecification.
ideally this conditionshould expresstheproperty foreachinput satisfyinga giveninputcondition ifthereisapathinthereferenceprogram followed by thisinput then there shouldbe a path inthe patched program followed by this input and the outputs produced along these paths are equal .
we refer to this condition as strict.
definition .
strict verification condition .
letprbe a reference program pbbeabuggyprogram ebeasuspiciousexpressionin pb e primebeacandidatepatch beaninputcondition inisasymbolic stateoverthevariable .astrictverificationcondition vcstrictfor the program pb is defined as follows logicalanddisplay r r out r logicalordisplay b b c b out b e prime dblbracketleft b c dblbracketright r out b out where the symbolic summary r r out colonequalsum pr in and the specification b bc b out colonequalspec pb e in .
however the above condition cannot be used in many practical situations where the existing symbolic execution engines reach theirlimits.forinstance wehavetorestrictthenumberofexplored pathsbyperformingloopunrollinginupto kiterations.asaresult theinferredspecificationisincomplete andtheintroducedstrict verification condition may classify two equivalent programs as non equivalent.
for example if an input is captured by some path condition r butnotcapturedbyany b thentheprogramswillbe considerednon equivalent.toaddressthis weuseamorepractical version of the verification condition that we refer to as liberal.
definition4.
liberalverificationcondition .
letprbeareference program pbbeabuggyprogram ebeasuspiciousexpressionin pb e primebeacandidatepatch beaninputcondition inisasymbolic state over the variable .aliberal verification condition vcliberalstart with original expressionref.
prog.
summary sum pr buggy prog.
specification spec pb e vcliberal is sat?
patch found candidate patchcounterexample is sat?
no patchbuggy prog.
specification spec pb e is sat?no angelic values angelic forestsynthesis constraintcomponent librarynegate no yes no yesnoyesconditional eqivalence checker patch synthesizer angelic forest extractor figure counterexample guided inductive repair.
for the program pb is defined as follows logicalanddisplay r r out logicalanddisplay b bc b out r b e prime dblbracketleft b c dblbracketright r out b out where the symbolic summary r r out colonequalsum pr in and the specification b bc b out colonequalspec pb e in .
comparedwiththestrictverificationcondition theliberalone only requires that for all intersections between a path condition rin the reference program and bin the buggy program i.e.
inputs satisfying r b the symbolic outputs are the same in both programs.
in the other words this verification condition only checksequivalenceofthefunctionalityforwhichaspecification has been inferred from both programs.
.
patch generation toimplementascalablepatchgenerationthatenforcesconditional equivalence of the referenceand the buggy programs we propose amethodologyof counterexample guidedinductiverepair cegir that effectively combines counterexample guided inductive synthesis cegis and a patch synthesis algorithm of angelix .
the overall workflow of the patch generator is shown in figure and illustrated by an example in section .
it performs acounterexample guided refinement loop starting from the origi nal expression as the initial candidate patch.
the loop combines three modules a conditional equivalence checker an angelic forest extractorandapatchsynthesizerthataredescribedindetailsbelow.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic program repair using a reference implementation icse may june gothenburg sweden conditionalequivalencechecker.
inordertoverifythatagiven candidatepatchmakesthebuggyprogramconditionallyequivalent tothereferenceprogram wesolvetheliberalverificationcondition given in definition .
.
in order to solve the universally quantified formula wechecktheunsatisfiabilityofitsnegation soasinprevious works .
note that the introduced verification condition isan formula thereforeitsnegationalsoproducesauniversallyquantified formula.
however the quantifiers can be replaced with sinceforeach thevaluesof isuniquelyidentifiedby theconstraint b e prime dblbracketleft bc dblbracketright.thus thenegationoftheliberal verification condition in definition .
is logicalordisplay r r out logicalordisplay b bc b out r b e prime dblbracketleft b c dblbracketright r out nequal b out the above formula is an formula therefore it can be solved using an off the shelf smt solver.
if the formula is unsatisfiable then the patch is correct conditionally equivalent to the reference program .
otherwise a counterexample test is generated.
angelicforestextractor.
givenacounterexampletestandaspecification inferred from the buggy program our algorithm computes a compact specification for the expression based on angelic values angelicforest .thealgorithmofangelicforestextractionissimilar to that used in angelix .
it is presented in algorithm .
if angelicvaluescannotbeextracted thenthebugcannotbefixedatthe considered location or the specification is incomplete .
otherwise the values are extracted and passed to the synthesizer.
patchsynthesizer.
sincetheinputtothesynthesizerisanangelic forest we used the angelix implementation of a patch synthesizer that extends smt based component based program synthesis .
if a patch cannot be synthesized then the search space the set ofconsideredtransformations isinsufficienttofindarepair.ifa patch is found it is passed to the conditional equivalence checker.
proposition .
correctness guarantee .
letpbbe a buggy program prbe a reference program be an input condition ebe asuspicious expressionin pb.assume that e primeisapatch thatisproducedbythecegiralgorithm figure3 givencompletespecifications sum pr andspec pb e asinputs.then pb andpr are conditionally partially equivalent w.r.t.
the condition .
implementation we have implemented the tool semgraft for evaluating our technique.semgraftconsistsofthreemaincomponents preconditioned symbolic executor verification condition generator andpatch generator.
semgraft receives a buggy and a reference program an input condition and a test suite as input and produces a patch for the buggyprogramastheoutput.figure4showsthearchitectureofour tool.
below we explain how these components are implemented.
preconditioned symbolic executor pse .
pse is built on top of klee awidelyusedsymbolicexecutionengine.tosupport preconditionedsymbolic execution themodified versionofklee takestheuser definedinputcondition insmtlib2formatasinput.
specifically wemodifythefunction forkofthekleeinterpreter whichiscalledwhenkleeencountersasymbolicbranch.thepath conditionsofbothbranchesareconjoinedwiththeinputcondition to determine whether a path is terminated immediately or furtherklee z3 serverpreconditioned symbolic executor strict vc generator liberal vc generatorverification condition generatorpatch generator conditional equivalence checker angelix forest extractor patch synthesizer figure architecture of semgraft.
explored.
we integrate z3 solver with klee and pass symbolic constraintsbetweenthemforcheckingthesatisfiabilityofsymbolicexpressions.pseoutputssymbolicformulainsmtlib2formatand invokes z3 solver via a wrapper function.
verificationconditiongenerator vcg .
vcgtakesthesymbolic summary of the reference program and the specification of the buggy program both of which are obtained by executing pse with the input condition.
our tool semgraft supports both kinds of verification condition as per subsection .
but the default option of vcg is the liberal verification condition which is more practical for real world programs.
we use an open source library jsmtlib1 for processing smt files generated by pse.
patch generator pg .
pg takes the liberal verification condition in smtlib2 format and executes a counterexample guided inductive repair loop until it finds a patch that satisfies the desired property.
the workflow of pg is shown in figure .
experimental evaluation toevaluatetheeffectivenessofourapproach weaimtoinvestigate the following research questions rq1 can semgraft generate repairs for real world software?
rq2 can semgraft alleviate the overfitting problem of exist ing test suite based program repair techniques using the reference implementation?
rq1 is designed to investigate the applicability of our approach for repairing real world applications.
a previous study has reportedthatastraightforwardcombinationofastate of the art equivalencecheckingsystemwithcounterexample guidedinductivesystemsscalesonlytosmallprograms.tobeapplicabletorealworldprogramssuchasbusyboxandgnucoreutils ourapproach sacrifices discovers a partial specification for checking conditional equivalence w.r.t.
a user provided condition.
therefore we also discuss how such a condition can be derived from existing tests.
rq2assessesthecorrectnessofgeneratedpatchescomparedwith test drivenprogramrepairapproaches.asinpreviousworks weidentifyageneratedpatchas correctonlyifitis syntactically equivalent to the developer patch modulo trivial refactorings .
1jsmtlib website authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden mechtaev et al.
table busybox subject programs buggy prog.buggycommitref.
prog.ref.
prog.versionfailure description angelix semgraft sedc35545a sed of gnu sed version .
failed to handle zero length match correct correct seqf7d1c59 seq of coreutils version .
wrong output when input arguments are equal correct correct sed7666fa1 sed of gnu sed version .
wrong output when handling s num incorrect correct sortd1ed3e6 sort of coreutils version .
wrong output when handling kstart n.endchar incorrect correct seqd86d20b seq of coreutils version .
seqno longer accepts value as increment argument incorrect correct sed3a9365e sed of gnu sed version .
failed to handle s which has empty matches incorrect correct table coreutils subject programs buggyprog.
buggycommitref.
prog.ref.
prog.versionfailure description angelix semgraft mkdir f7d1c59 mkdir of busybox version .
.
segmentation fault incorrect correct mkfifo cdb1682 mkfifo of busybox version .
.
segmentation fault incorrect correct mknod cdb1682 mknod of busybox version .
.
segmentation fault incorrect correct copy f3653f0 copy of busybox version .
.
failed to copy a file correct correct md5sum 739cf4e md5sum of busybox version .
.
segmentation fault correct correct cut6f374d7 cut of busybox version .
.
failed to handle b like b incorrect correct .
experimental setup inordertoaddressthedescribedresearchquestions wechoosethesubjectsinourexperimentsaccordingtothefollowingfourcriteria.
the subjects are real world software that is widely used.
referenceprogramsareavailablethatprocessthesameinputs as the buggy programs but exhibit the correct behavior.
thebuggyandthereferenceprogramaresubstantiallydifferent in their structure.
thedeveloperpatchesarewithinthesearchspacesofourimplementation.
by the search space we mean the set of consideredtransformationsdefinedthroughthecomponents used for component based synthesis.
the last criteria allows us to reason about correctness of generated patches e.g.
if the developer patch was not in the search space then any generated patch would a prioribe identified as incorrect .
our subjects are real software errors of two open source c projectsbusybox andgnucoreutils extractedfrom commit logs bug reports and previous research .
both busybox and gnu coreutils provide many common unix utilities but busybox has been implemented with size optimization limited resources andismainly usedforsmall orembeddedsystems.
we employ our tool semgraft to repair the embedded linux busybox with gnu tools like coreutils as reference and vice versa.
to address the second question rq2 we compared our technique with a state of the art test driven program repair approach angelix .angelixiscloselyrelatedtoourtechniquesinceitalso appliessymbolicexecutiontoinferspecificationandsynthesizes patches.
we selected this approach for our evaluation because this enables us to more objectively investigate the impact of specifi cation inferred from a reference program.
specifically since ourimplementation reuses the synthesizer of angelix both angelixand semgraft explore the same space of candidate patches.
inorder to ensure that the systems have access to the same seman tic information about the program we integrated the algorithmof angelix into semgraft in such a way that both tools use thesamespecificationinferredfromthebuggyprogram werefertothis version of angelix as angelix .
the main difference of thetwo tools is that semgraft performs a counterexample guidedinductive repair loop to ensure conditional equivalence with the reference implementation while angelix relies solely on the test suite provided by gnu coreutils busybox developers and stops immediately when finding an expression satisfying the tests.
allourexperimentswereperformedonintelxeoncpue5 v4 .20ghz cpu with ubuntu .
bit operating system.
.
summary of experiments table summarizes our experiments with busybox and table summarizes our experiments with gnu coreutils.
for each pair of a buggy and a reference program the tables show the name of the buggyprogramanditsversioninthecommithistory thereferenceprogramanditsversion adescriptionofthebug andtheresultsof executing angelix and semgraft for repairing the defect.
semgraft demonstrated that the proposed approach can be applied to real worldprograms.
specifically it managed torepair all defects that are repaired by angelix.
since the workflow of semgraftalsoincludesinferringspecificationforareferenceprogram andcheckingverificationconditions itrequiredalongertimeto generatedpatches.specifically angelix required15minuteson average to generate patches while semgraft required minutes.
intheexperiments semgraftinferredspecificationsconsisting of up to paths from a reference program and up to paths inabuggyprogram.thenumberofpaths ingeneral dependson the structure of the buggy and the reference programs bounds used for symbolic execution and the chosen condition .
typically thespecificationinferredfromthebuggyprogramincludesmore authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic program repair using a reference implementation icse may june gothenburg sweden if !rhs specified if eol range start eol range start eol range start initial field found true a patch generated by angelix based on tests.
if !rhs specified if eol range start initial eol range start eol range start initial field found true b patch generated by semgraft based on reference program.
figure generated patches for cut ver.
6f374d7 .
paths due to additional symbolic variables injected into the buggy program for suspicious expressions.
as can be seen from the tables semgraft generated repairs equivalent to developer patches for all considered examples while angelix that relies only on tests repaired less than half of the defects correctly.
this shows that the reference implementation indeed can help to alleviate test overfitting.
.
deriving input condition aninputconditionusedforenforcingconditionalequivalenceof the patched and the reference program is an important part of our approachandithastobedefinedbytheuser.weuseanexample ofabugin cut ver.6f374d7 todemonstratehowsuchacondition can be defined in practice.
cutextracts sections from each line ofits input.the buggyversionof cutofgnu coreutilswrongly interprets the command b as b extract input bytes staring from the third byte instead of b extract input bytes staringfromthesecondbyte .thedeveloperprovidesthefollowing two tests that cover the buggy functionality echo ne cut b 3echo ne cut b 2forboth ofthese tests theexpected outputis .the abovetwo testscoverprogrambehaviorfortwoconcretepairsofindexes and .
however this is insufficient for a test driven program repair to produce a patch that generalizes beyond the tests.
in this work we propose to define an input condition for generatingconditionalequivalence enforcingpatchesby parametrizing existing tests.
note that the purpose of parametrizing the test is tomakegeneratedpatchesgeneralize yetensuringtractabilityof specification inference.
therefore the user should parametrize the essentialpartinthetestrelatedtothefailure.inthiscase weinject parametersinsteadoftheindexes thataffectthewaythedata is processed.
as a result we obtain the following input echo ne cut b 0 1where 0and 1indicate the injected parameters.
given such a parametrization the condition will be accordingly defined as colonequalarg0 arg0 b arg1 arg1 arg1 in wherearg0andarg1denote command line arguments inis the standard input stream.
this example demonstrates that defining an input condition for ourapproachmayrequireasmalleffortfromtheuser.however we believethatsuchaconditioncanbepotentiallyderivedautomatically.onepossiblewaytodothatwouldbetoexecutethefailing testconcolically to collect input constraints e.g.
using zesti and construct an input condition for our approach by generalizing the obtained constraint.
we leave this for future work.
.
impact of reference program inthissection weshowhowtheuseofareferenceimplementation can enable semgraft to find a correct path while angelix finds a plausible passing the given tests but incorrect repair.
forthe discussedbugin cutprogram angelix uses thetests given above to construct a patch in figure 5a.
this patch adds a condition into the program that changes the way how indexes in the given command are handled.
the expression includes the disjunct eol range start thatensuresthattheindex3isnot used by the command b .
however this condition does not generalize to other values of the indexes that can appear in such command but merely overfit the given test.
asoppositetoangelix semgraftextractsaspecificationfrom thebuggyandthereferenceprogramsviapreconditionedsymbolic execution with .
in this example it extracts paths from the buggy program and paths from the donor program busybox cut .
then it performs a counterexample guided inductive repair loop until it finds a patch that enforces conditional equivalence of coreutils cutandbusybox cutw.r.t.
.specifically afterobtaining a candidate patch as in figure 5a it generates a counterexample test b for which the output of coreutils cutdiverges from busybox cut.
based on this test it extracts the angelic path 0 true initial mapsto eol range start mapsto 1 false initial mapsto eol range start mapsto .
given the extracted path semgraft generates the patch in figure5b whichisidenticaltothedeveloperrepair.semgraftalso provesthatitiscorrect equivalenttobusybox cut forallpossible combinations of indexes in the described command.
threats to validity internal validity.
the main threat to internal validity is the manual construction of the input condition for our experiments that were based on the negative developer written tests.
in general creatingsuchconditionsmaynotbetrivial.however existingtech niqueslikedeltadebugging couldhelptheusertominimizethe testinputargumentsstillshowingthebuggybehavior andhence tosimplifytheinputcondition.additionally theperformedmanual inspection of the experimental results might be error prone.
to mitigate this two authors of the paper double checked the created input conditions and the generated patches.
external validity.
the main threat to external validity is that the chosen selection of subjects may not generalize to other programs.
we could not use existing repair benchmarks due to the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden mechtaev et al.
lack of reference programs.
however we focused on subjects from thegnucoreutilsandbusybox whicharewell knownthroughout the community and provide implementation of similar functionality.anotherthreattoexternalvaliditymaybethescalabilityof our approach.
it mainly depends on the number of explored paths during the symbolic analysis and the size of the generated verification condition.
therefore among others we introduced theuser defined correctness property which enables the limitationof the search space to a practical usable scope.
furthermore the approachislimitedbythecapabilitiesoftheunderlyingsymbolic executionengine whichwetriedtoimprovebyusinganefficient preconditioned symbolic execution approach.
constructvalidity.
themainthreattoconstructvalidityisthe correctnessofourimplementationbecauseourstatementabouttheconditionalpartialequivalenceofthegeneratedpatchholdsonlyif the implementation is correct.
we implemented our approach as extensions of existing works klee symbolic execution engine and a synthesizer adapted from angelix .
therefore our extension inherits the incorrectness of the baseline.
however face validity showed that the results are consistent with the expected outcome.
related work .
program repair in the last years several program repair approaches havebeen developed.
these approaches can be classified into syntax based and semantics based techniques.
syntax based generate and validate program repair techniques such as e.g.
genprog ae rsrepair andacs requiresubtasksincludingfaultlocalization patch generation and execution of regression test cases.
mechanizing these tasks has received significant attention from the automated and search based software engineering community.
approachesdeveloped byle goueset al.
martinez and monperrus showmeaningfulresultstowardstheautomation of bug fixing.
the main idea of these approaches is to use failed testcasestolocalizepotentialfaultsandthenapplymutationsto thesourcecodeuntiltheprogramsatisfiesallunittestcases.the mutations that are applied to the program code can range from smallchangeslikemodification additionorremovingasinglecode line tocomplexeditoperations minedfromsoftware repositories.relifix utilizespreviousprogramversionsinorder toperformautomatedrepairofregressionbugs howeveritrelies on syntactic similarity of the previous and the buggy programs whichdistinguishesitfromourapproach.thequalityofpatches produced by test based repair approaches may be low since thepatches may overfit the test data.
a study on the correlation of patchqualitywiththequalityofthetest suiteguidingtherepair has been recently conducted .
semantics based techniques like semfix nopol directfix spr angelix and jfix splitpatch generationinto twophases.
first theyinfer a synthesisspecificationfortheidentifiedprogramstatements.second they synthesize a patch for these statements based on theinferred specification.
however since most of semantics basedtechniques rely on tests as the correctness criteria the inferred specification only captures the property of passing the tests .our approach seeks to solve the test overfitting problem in programrepair.weshowthat subjecttotheavailabilityofareferenceimplementation ourscalablesymbolicanalysiscanproducehigher quality patches and provide partial correctness guarantees.
.
software transplantation automatedsoftwaretransplantation toolslike scalpel and codecarboncopy aim at transplanting new functionality from a donor application into a recipient application.
codephage canfixprogramerrorslikeoutofboundsaccess integer overflow and divide by zero errors.
they focus on finding an er ror checking code in the donor application that can serve as acompensation for a missing check in the host application.
sincetheir approach tries to copy code it is necessary to translate the checkfromthedatastructuresandnamespaceofthedonorinto an application independent representation suitable for insertion into the recipient application.
the advantage of searchrepair compared to other repair approaches is the use of semantic code search toidentifysuitablecodefragmentsforrepair.our approach differs from software transplantation literature since we do not seek to inject any new functionality lifted from a donor program.ourgoalistoincreasethequalityofgeneratedpatches usingadifferentcorrectnesscriteria namelythereferenceprogram.
we also differ from recent works on grafting of code clones since this line of work seeks to achieve greater test reuse across code clones for the sake of differential testing.
.
equivalence checking lahiri et al.
proposed an approach to find the rootcause for equivalencefailuresbyleveragingsemanticsimilaritybetweentwoprogrambinaries.sincetheyaimtoextractacompletespecification theirapproachscalesonlytosmallprograms.ourworksacrifices completeness for the sake of applicability by checking conditional equivalenceofabuggyprogramandareferenceprogramw.r.t.a user defined input condition.
conclusion weproposedamethodologyofgeneratingpatchesbasedonareference implementation.
our technique addresses the test overfitting problem by providing additional correctness guarantees.
specifically it synthesizes a conditional equivalence enforcing patch w.r.t.auser definedinputcondition.ourexperimentsdemonstratedthat ourmethodscalestoreal worldprogramssuchasgnucoreutils and busybox and helps to generate more correct repairs.