efficient detection of thread safety violations via coverage guided generation of concurrent tests ankit choudhary department of computer science tu darmstadt germanyshan lu department of computer science university of chicago usamichael pradel department of computer science tu darmstadt germany abstract as writing concurrent programs is challenging developers often rely on thread safe classes which encapsulate most synchronization issues.
testing such classes is crucial to ensure the correctness of concurrent programs.
an effective approach to uncover otherwise missed concurrency bugs is to automatically generate concurrent tests.
existing approaches either create tests randomly which is inefficient build on a computationally expensive analysis of potential concurrency bugs exposed by sequential tests or focus on exposing a particular kind of concurrency bugs such as atomicity violations.
this paper presents covcon a coverage guided approach to generate concurrent tests.
the key idea is to measure how often pairs of methods have already been executed concurrently and to focus the test generation on infrequently or not at all covered pairs of methods.
the approach is independent of any particular bug pattern allowing it to find arbitrary concurrency bugs and is computationally inexpensive allowing it to generate many tests in short time.
we apply covcon to thread safe java classes and it detects concurrency bugs in of them.
compared to five state of the art approaches covcon detects more bugs than any other approach while requiring less time.
specifically our approach finds bugs faster in of cases with speedups of at least 4x for of cases.
keywords test generation coverage concurrency i. i ntroduction writing correct and efficient concurrent software is difficult.
to alleviate the pain of developing concurrent software in object oriented shared memory languages such as java or c developers often use thread safe classes .
these classes encapsulate concurrency related challenges such as how to synchronize concurrent memory accesses in an efficient and deadlock free way and provide an easy to use interface to developers.
in essence each thread can use an instance of a thread safe class as if no other thread was using the instance concurrently without any synchronization between the threads that access the instance.
the thread safe class guarantees that the behavior of the execution is equivalent to a method level linearization of the concurrent calls to the shared instance.
because thread safe classes are widely used ensuring their correctness is crucial for ensuring the overall correctness of concurrent programs.
an effective approach for validating the correctness of a thread safe class is automated test generation.
the basic idea is that a test generator creates concurrent unit tests i.e.
tests where multiple concurrently executing threads exercise a shared instance of the class under test.
to determine whether a generated test exposes a bug theconcurrent execution is then compared against linearizations of the test or analyzed by existing detectors of data races atomicity violations or deadlocks .
existing generators of concurrent tests fall into three categories.
random based approaches select at random which methods to call in the concurrently executed threads and randomly combine threads with each other .
these approaches have minimal requirements but are often inefficient because they tend to repeatedly test already exercised behavior yet miss behavior that can expose bugs.
sequential test based approaches execute existing sequential unit tests of the thread safe class identify concurrency bugs that may occur when combining multiple sequential tests into concurrent tests and then synthesize such tests .
these approaches rely on appropriate sequential tests and impose a relatively high computational cost.
finally coverage based approaches compute a set of concurrency related coverage requirements and generate tests that cover as many of these requirements as possible .
this direction is promising.
however existing approaches use coverage criteria that demand expensive coverage measurement and test generation.
furthermore a common limitation of existing non random approaches is to consider only a particular kind of concurrency bugs e.g.
data races atomicity violations or deadlocks .
this paper presents a novel coverage guided approach for generating concurrent tests that can detect arbitrary kinds of concurrency bugs.
the approach is a simple yet effective alternative to the existing approaches.
we follow the philosophy of recent coverage based approaches to guide random based test generation toward not yet covered interleavings making it less random and more likely to trigger not yet exercised mis behavior.
unlike existing approaches we drastically simplify the analysis and computation associated with interleaving coverage.
we face two major challenges in achieving this goal.
first we require a lightweight technique to assess which interleavings are not yet covered by existing test cases.
naively enumerating all possible interleavings i.e.
total orders of memory accesses is practically infeasible.
existing coverage based approaches focus on partial orders of memory accesses of which there are finitely many.
however they still require an expensive coverage measurement that analyzes every access to global or heap objects.
second we require a lightweight technique for steering automatic test generation ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
toward tests likely to cover not yet covered interleavings.
this is non trivial for existing approaches as they need to figure out which call sequences may cover specific memory accesses that are part of a targeted interleaving.
furthermore the obvious solution prioritizing interleavings that have been covered the least or not at all fails for realistic classes under test because some interleavings may be infeasible.
to address these two challenges we use a coverage metric that abstracts the set of interleavings into concurrent method pairs i.e.
the set of pairs of methods that execute concurrently.
an important insight that enables the idea to scale to realistic classes is that concurrent method pairs yield a finite coverage domain that is computationally inexpensive to measure yet an effective approximation of possible and covered interleavings.
the approach instruments the class under test to measure which pairs of methods execute concurrently when executing a generated concurrent test.
the approach then uses the coverage information to easily construct tests aimed at covering infrequently covered pairs of methods while minimizing the priority of method pairs that simply cannot execute concurrently e.g.
because both methods are protected by the same lock.
we call the presented approach covcon standing for cov erage guided generation of con current tests.
the main benefit of covcon is to be both conceptually and computationally simple yet effective and efficient in triggering concurrency bugs.
note that our work differs from recent work on generating schedules based on concurrent coverage metrics because covcon generates test cases instead of schedules.
the problem of generating test cases is orthogonal to the problem of generating schedules for executing these test cases.
once test cases are available e.g.
generated by covcon they can be explored with any approach for generating schedules including coverage based approaches active testing bounded exploration and exhaustive exploration .
in contrast without bug triggering test cases even the best schedule exploration technique cannot find any bugs.
steering the testing process toward higher coverage is inspired by a long tradition of using coverage to direct the testing of sequential programs.
traditional sequential coverage metrics such as statement coverage branch coverage or definition use coverage are widely used to measure testing sufficiency.
they indicate which parts of the code still lack testing and guide developers or automated test generation tools toward those parts.
coverage directed testing generation is a natural step for concurrency testing given the success of coverage directed testing in sequential software.
when taking this step finding a simple yet effective coverage measurement and test generation scheme is crucial to the success of this promising direction.
we evaluate the covcon approach with thread safe classes from popular java projects and compare our coverageguided approach with five existing approaches.
our approach detects concurrency bugs in of the classes which is more than any other approach.
at the same time covconsignificantly reduces the time required to find bugs for of cases our approach is faster than the state of art with speedups of at least 4x for of the cases.
in summary this paper contributes the following the first approach to use a finite simple and generic metric of interleaving coverage as a driver for generating concurrent tests.
the insight that concurrent method pairs provide an inexpensive metric of interleaving coverage that effectively steers test generation.
this insight yields a conceptually simple yet highly effective test generation approach to automatically test thread safe classes.
a comprehensive experimental comparison of generators of concurrent tests that exceeds previous experiments both in the number of classes and in the number of approaches.
the results show that covcon outperforms all state of the art approaches both in terms of bug finding capabilities and efficiency.
ii.
o verview this section outlines the main ideas of our coverage guided approach for generating concurrent tests and illustrates them with an example.
figure 1a shows a supposedly thread safe class under test.
methods m2andm3both use a field li which m2may set to null and which m3may dereference.
unfortunately m3checks whether li is non null before dereferencing it without enforcing that the check and the dereference operation are executed atomically.
as a result a client of the class that calls m2and m3concurrently may trigger a nullpointerexception violating the thread safety property that the class intends to guarantee.
to test the class covcon generates multi threaded unit tests section iv d such as the test shown in figure 1b.
the test instantiates the class may call some of its methods not shown in the example and then spawns two threads.
the concurrent threads both use the shared instance cof the class under test and call some of its methods.
each generated test focuses on a particular pair of methods m1 m3 for the example and tries to execute these methods concurrently.
next covcon executes the test and gathers an execution trace that records method entry and exit events of the concurrently executing threads section iv b .
the trace in figure 1c shows the calls done by thread and on the left and right respectively.
note that the trace contains events of both the direct calls such as the calls to m1andm3 and the indirect calls such as the calls to m4through m3.
during the execution in figure 1c several pairs of methods execute concurrently m3 m3 m3 m4 m1 m3 and m1 m4 .
the main feature of covcon is to maintain and exploit information about interleaving coverage.
our work builds on concurrent method pairs a measure that stores how often a particular pair of methods has executed concurrently section iv a .
figure 1d lists all pairs of methods of the class under test.
for each pair the approach maintains two counters how often covcon has already generated a test that tries to call the methods concurrently and how often the methods authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a class under test class c list li ... synchronized void m1 ... synchronized void m2 if ... li null intm3 if li null return m4 synchronized this return li.size void m4 ... b generated test cc newc c.m1 c.m3 c.m3 c.m1 thread thread c trace of test execution enter m1 exit m1 enter m3 enter m3 enter m4 exit m4 exit m3 enter m1 enter m4 exit m4 exit m3 exit m1 d coverage information method coverage priority pair tried covered after init after ially tests tests m1 m1 m1 m2 m1 m3 m1 m4 m2 m2 m2 m3 m2 m4 m3 m3 m3 m4 m4 m4 fig.
example to illustrate coverage guided generation of concurrent tests.
have indeed executed concurrently.
these counters may differ because a particular execution may not schedule two methods concurrently because a pair of methods may never or rarely be able to execute concurrently due to synchronization and because a call in a test may call other methods.
given the execution trace in figure 1c covcon updates the coverage information as follows.
it increments the number of tries for m1 m3 because the test focuses on this pair of methods.
furthermore it updates the number of times that m3 m3 m3 m4 m1 m3 and m1 m4 are covered.
the third column of figure 1d illustrates the coverage information that covcon may gather by generating and executing tests.
some method pairs such as m1 m1 have not been covered at all because they are protected by the same lock.
other method pairs such as m2 m4 are covered relatively often because m4gets exercised both by tests that directly call m4and by tests that directly call m3 increasing its chance to execute concurrently with other methods.
note that even though the number of tries are the same for all method pairs in the example this need not be the case.
covcon uses the coverage information to focus the generation of tests on pairs of methods that have not yet been covered or that have been covered less frequently than others section iv c .
a naive approach might always pick the pair of methods with the lowest covered count.
however this approach would spend most of its testing efforts on method pairs that cannot execute concurrently such as m1 m2 .
instead we present a prioritization technique that accounts both for pairs that cannot be executed concurrently and pairs that are frequently executed concurrently because they are called by other methods.
the last column of figure 1d shows the score that covcon assigns to each method pair after generating and executing tests.
based on the scores the approach is most likely to focus on the three pairs m2 m3 m3 m3 and m3 m4 in its next round of test generation which includes the method pair m2 m3 that is prone to the atomicity violation.
the testing process illustrated in figure continues until covcon detects a thread safety violation or until the user stopsthe approach when the testing reaches a time out or a test coverage goal.
during this process the approach continuously updates the coverage information and refines the decisions on which pairs of methods to test next.
iii.
b ackground c oncurrent tests covcon analyzes a supposedly thread safe class under test by generating concurrent tests .
such a test consists of a sequential prefix executed in a single thread and multiple concurrent suffixes executed in concurrent threads.
the prefix instantiates the class under test and possibly calls additional methods to bring the instance into a state that may expose errors.
the suffixes all share the single instance of the class under test created by the prefix.
similar to prior work this paper focuses on tests with two suffixes.
to check whether executing a concurrent test exposes a concurrency bug we build upon the thread safety oracle .
it checks whether the concurrent execution of a test leads to an exception or a deadlock and if it does checks whether the same exception or deadlock also occurs in any of the methodlevel linearizations of the test.
if the exception or deadlock occurs only in a concurrent execution but not in any of the linearizations then the oracle reports a thread safety violation.
because thread safety guarantees that each concurrent behavior of a class corresponds to a method level linearization the thread safety oracle reports a warning only if the class indeed suffers from a concurrency bug.
the oracle may miss bugs that do not manifest as an exception or a deadlock and bugs not triggered during the concurrent execution due to nondeterminism.
iv .
a pproach the following describes the details of covcon a coverageguided approach to generate concurrent tests.
given a supposedly thread safe class under test the approach repeatedly performs two steps until it finds a thread safety violation or until the user stops the approach test generation.
create a multi threaded unit test that exercises the class under test.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
test execution and validation.
execute the test and decide whether it exposes a thread safety violation.
the main contribution of this work is to improve the efficiency and effectiveness of the first step by guiding the test generator toward tests that will cover not yet or infrequently explored interleaving behaviors.
we first present the interleaving coverage metric used by covcon section iv a .
covcon gathers coverage information during the execution of tests by instrumenting the class under test and by analyzing execution traces section iv b .
based on the gathered coverage information covcon assigns priorities to interleavings giving highest priority to interleavings that require more thorough testing section iv c .
finally covcon uses the priorities to steer the test generation toward not yet or infrequently covered concurrent behaviors section iv d .
a. interleaving coverage a major challenge for coverage guided test generation is to find a coverage metric that is both efficient and practical to use.
efficiency refers to the cost of computing the coverage domain i.e.
the set of all interleaving behaviors that clients of a thread safe class can explore the cost of gathering coverage facts i.e.
which of these interleaving behaviors have been covered by test executions and the cost of synthesizing a test case to satisfy a particular coverage requirement.
efficiency is critical because otherwise the benefits of using coverage information may not outweigh the cost compared to a coverageoblivious approach.
it is also critical that the coverage domain is neither too small nor too big.
otherwise the coverage goal is either too easy or too difficult to achieve in practice.
a naive approach would be to compute all possible instruction level interleavings via static analysis and to measure which of these interleavings are covered by an execution.
unfortunately precisely computing this coverage domain is computationally expensive and gathering coverage facts would impose huge runtime overhead.
moreover covering all instruction level interleavings that clients of a class may explore is practically infeasible because the coverage domain would be very large or even infinite.
recent coverage based approaches focus on partial order interleavings and hence address the practicality issue of the naive approach but cannot address the efficiency issues.
to enable covcon to efficiently compute interleaving coverage we use an approximate interleaving coverage metric.
the metric called concurrent method pairs measures which pairs of methods are executed concurrently.1each concurrent method pair consists of two publicly accessible methods of the class under test.
concurrent method pairs are inspired by deng et al.
s concurrent function pairs which was proposed to reduce the dynamic bug detection cost for predefined inputs.
our work is the first to apply the metric to 1we consider m1 m2 and m2 m1 to be the same method pair because the order is irrelevant for concurrency bug detection.
this terminology differs from the mathematical definition of pair but is in line with previous work .object oriented programs and to adapt it to the problem of generating concurrent tests.
the concurrent method pair metric is both efficient and practical to use.
computing the coverage domain is straightforward as it requires only the set of publicly accessible methods of the class under test.
likewise gathering coverage facts is computationally inexpensive as we show in sections iv b. finally the set of concurrent method pairs is finite and can be covered in reasonable time section vi f .
the following section describes how we compute and use this metric.
b. gathering coverage information covcon keeps track of three kinds of coverage related information the setpof concurrent method pairs that could potentially be covered by test executions.
a mapcthat assigns each method pair p p to the number of times that the pair has been covered i.e.
how often the two methods in phave been executed concurrently.
we call c p the covered count ofp.
a maprthat assigns each method pair p p to the number of tests where the methods in pare directly called in different suffixes i.e.
the number of tests that are designed to try increasing the covered count of p.w e callr p the tried count ofp.
pis computed as the set of all pairs of publicly accessible methods of the class under test.2r is updated whenever a method pair pis selected as the prioritized method pair section iv c .
updating crequires instrumentation and trace analysis for each test execution which will be discussed in detail in the remainder of this subsection.
instrumentation to detect which methods of the class under test execute concurrently covcon instruments each publicly accessible method defined in the class and its superclasses.
the instrumentation records the start and the end of every invocation of the method into an execution trace.
definition execution trace the trace created while executing a concurrent test is a sequence of trace entries.
each entry is a tuple e m o h s where eis the kind of event start or end mis the fully qualified signature of the current method ois a unique identifier of the object on which the method is called or null for static methods his a unique identifier of the current thread and sis a global logical timestamp.
to obtain the global timestamp covcon maintains a global counter that serves as a logical clock shared among all threads.
each time when the instrumented code creates a new trace entry it increments the counter and records the incremented counter as the current timestamp.
2a possible extension of covcon could be to refine pvia a static analysis that prunes methods that cannot execute concurrently due to synchronization.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm analyze execution trace to update information about covered method pairs.
input execution trace trace and covered counts c output updated covered counts c mcur maps threads to currently executing methods for all e m o h s trace do ife start then for all h prime m cur do ifh prime negationslash hthen for all m prime m cur h prime do p sort m m prime c p c p mcur h .push m else if e end then mcur h .pop to detect the start of a method execution covcon inserts a call statement at the beginning of the method.
detecting the end of a method execution is slightly more complicated because a method may have multiple exit points including exit points caused by checked and unchecked exceptions.
to consider all possible exit points of a method covcon surrounds the original method body with a try catch finally statement which catches and re throws all exceptions.
the finally block which is always executed at the end of the method records the trace entry for exiting the method.
analyzing the execution trace based on the execution trace of a test covcon determines which pairs of methods have executed concurrently and updates their covered counts accordingly.
algorithm summarizes the trace analysis.
the algorithm iterates through all trace entries and maintains a stack of currently executing methods for each thread.
for each event that represents the start of a method m the algorithm pushes m to the stack of the current thread h line .
moreover the algorithm checks which other methods m prime execute concurrently i.e.
in another thread h prime and increments the covered count for the pair m m prime line .
since the order of methods is irrelevant for the concurrent coverage pair metric the algorithm represents each pair in a canonical format by sorting the method signatures.
when the algorithm observes the end of a method m it pops mfrom the stack of the current thread line .
the algorithm considers the general case of an arbitrary number of concurrently executing methods even though this work focuses on tests with only two suffixes.
one reason is that there may be more than two concurrently executing methods when a method called in a suffix spawns additional threads.
c. prioritizing method pairs in the following we present how covcon decides which method pairs to prioritize during test generation.
the input to this step is the coverage information gathered during prior executions of generated tests specifically the maps candr which store the covered counts and tried counts of method pairs respectively.the prioritization addresses three challenges c1 to maximize the chance to discover a new thread safety violation covcon should generate tests to exercise pairs of methods that have not yet been tested extensively.
in particular pairs that have not yet been tried at all should have highest priority.
c2 to avoid spending testing effort on pairs of methods that cannot be executed concurrently covcon should reduce the priority of such pairs.
for example a method pair may never rarely execute concurrently if significant parts of both methods are protected by the same lock.
c3 to avoid spending testing effort on pairs of methods that are frequently executed concurrently even though only few tests have directly called them in concurrent suffixes covcon should reduce the priority of such pairs.
for example such a method pair may occur if helper methods that are called by many other methods often execute concurrently.
an obvious solution would be to assign highest priority to method pairs pwith the lowest covered count c p .
this approach addresses c1 but fails to address c2 and c3.
for example such an approach would repeatedly attempt to test m1 m2 from figure 1a which cannot execute concurrently due to synchronization.
to address all three challenges we present a prioritization score that assigns an integer value to each method pair.
definition prioritization score given a method pair p p letrbe its tried count r p and let cbe its covered count c p .
the prioritization score s p is the following ifr then s p .
ifr negationslash then s p max r c max r .
covcon prioritizes method pairs with a low score.
the first case of definition r partly addresses c1 by prioritizing pairs that have not yet been tried to cover by any test.
the first part of the second case max r c addresses c2 and c3 by assigning a higher score i.e.
lower priority to pairs that are either infrequently covered despite frequent attempts to cover them or frequently covered despite few attempts to cover them.
finally the second part of the second case max r addresses c1 by assigning a lower score i.e.
higher priority to pairs that have not yet been attempted to cover frequently.
for illustration table i shows the scores for tried counts and covered counts ranging from zero to ten.
for a pair that has not yet been called concurrently in any test the score is zero i.e.
this pair gets highest priority c1 .
in contrast a pair with a high tried count and a relatively low covered count illustrated by the left bottom corner cells in table i gets a high score i.e.
this pair gets low priority c2 .
a pair that has a high covered count despite having a relatively low tried count illustrated by the gray cells on the right side of table i also gets a relatively high score i.e.
a low priority c3 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able i prioritization score depending on covered count x axis and tried count y axis .
lower score implies higher probability to be focused on in future tests.
r p c p instead of probabilistically prioritizing method pairs covcon could also completely avoid re testing already covered pairs.
the rationale for using prioritization is that the ability of a test to expose a bug depends not only on which methods execute concurrently but also e.g.
on the arguments provided to the methods.
as another alternative to definition covcon could use a static analysis to determine which pairs of methods can execute concurrently and which pairs of methods are likely to be called frequently by other concurrently executing methods.
we have initially considered this option but found that an inexpensive static analysis does not provide an advantage over the prioritization score.
in contrast the benefit of the presented prioritization score is threefold.
first it avoids a static analysis of the class under test and its dependences.
this design makes the approach both conceptually and computationally simpler which is critical to the overall testing effectiveness.
second the approach is language agnostic and can be easily applied to other languages than java whereas adapting a static analysis to another language is non trivial.
finally static analysis may incorrectly judge a pair of methods that cannot execute concurrently due to ad hoc synchronization but our prioritization score would not be affected.
d. creating tests after covcon decides to prioritize a method pair pprio m1 m2 it creates tests to focus on it.
the execution of these tests aims at triggering the concurrent execution of m1andm2 and at increasing the interleaving coverage.
this goal is nontrivial to achieve as we need to build up some meaningful state for m1andm2to execute upon and more importantly we want to improve interleaving coverage as much as we can with as little overhead as we can.
covcon creates tests that have a sequential prefix and two concurrent suffixes.
it builds upon the test generation approach from to create the prefix that instantiates the class under test and calls up to kadditional methods with appropriate arguments to bring the tested object into a state that may reveal concurrency errors.
for each prioritized method pair covcon creates two prefixes one without any additional calls i.e.
k and one with up to k additional calls.
the rationale is that some concurrency bugs can only be triggered after bringing the object into a bug exposing state by invoking a sequence of calls whereas other bugs may show only on a freshly instantiated instance.
for example a class that represents a file handle may become unusable after calling a method that closes the file.
the suffix generation is more tricky.
the first question is which methods should be called from the suffix.
the existing test generation approach from generates the suffixes using randomly selected methods which clearly does not fit the prioritization goal here.
instead covcon generates suffixes that call only methods from the pair pprio .
the second question is how to call these methods m1and m2to improve the test coverage.
one possible approach is to create a suffix m1 m1 ... and a suffix m2 m2 ... and to combine these suffixes into a concurrent test.
such a test is likely to improve coverage for the pair m1 m2 but unlikely to also cover m1 m1 and m2 m2 .
as an alternative the test generator could create a test that runs the same suffix m1 m2 m1 ... in two concurrent threads.
such a test is not only likely to cover the pair m1 m2 but may also cover m1 m1 and m2 m2 .
unfortunately the chance to trigger an execution where m1andm2run concurrently is relatively low because both threads start by calling m1and alternate between the two methods in the same order.
instead of these two naive approaches covcon creates two suffixes a suffix m1 m2 m1 ... and a suffix m2 m1 m2 ... and combines the prefix with these two suffixes into a test.
that is each suffix calls the methods ofpprio alternately.
the benefit of starting this alternation with different methods in the two suffixes is to maximize the chance that the pair of methods m1 m2 executes concurrently.
one could achieve the same goal by inserting sleeps or synchronization operations .
in contrast covcon s approach is more lightweight as it does not introduce any overhead.
covcon creates suffixes that have up to lmax calls per suffix.
for the first five tests created for a particular pair pprio w e setlmax .
for example when lmax covcon creates a test with a suffix m1 m2 and another suffix m2 m1 .
after the first five tests we set lmax .
the rationale for varying lmax is to quickly identify bugs that can be triggered with short suffixes and to then explore longer suffixes that allow for more interleavings but that also require the thread safety oracle to analyze more linearizations.
e. putting everything together algorithm summarizes the covcon test generation approach.
given a supposedly thread safe class under test the algorithm generates and executes tests until it finds a thread safety violation or until the user terminates the automatic testing after a timeout or a coverage goal is reached.
at first the algorithm computes the set pof concurrent method pairs for the given class line .
then the algorithm initializes the maps candrwith zero for each method pair authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm coverage guided generated of concurrent tests.
input class under test c output thread safety violation viol p computecmp s c for all p p do r p c p while true do pprio prioritizecmp c r updatet riedcounts p r t generatetests pprio for all t t do trace viol executeandv alidate t ifviol negationslash none then return viol updatecoveredcounts trace c in the set p to indicate that no pair has been tried yet and that no pair has been covered yet lines to .
the main part of the algorithm repeatedly generates executes and validates tests while gathering coverage information to steer the test generation toward not yet covered method pairs in the set p lines to .
this part consists of three main steps.
first function prioritizecmp selects based on the coverage information gathered in candrand the prioritization score a method pair pprio to focus on next and updates the tried count of pprio as discussed in section iv c. second function generatetests creates a set tof concurrent tests that focus on the prioritized pair pprio a s discussed in section iv d. third the algorithm executes each test int and checks whether it exposes a thread safety violation using the thread safety oracle section iii .
if the oracle reports a thread safety violation line then the algorithm terminates.
after each test execution the algorithm updatescto increase the covered counts of method pairs that have executed concurrently line as explained in section iv b. there is one optimization that we have not discussed yet.
since there are often multiple method pairs with the same lowest prioritization score as an optimization covcon computes the priorities once for all method pairs and stores all method pairs with the lowest score into a set pprio of prioritized pairs.
when algorithm calls prioritizecmp the function checks whether pprio is non empty and if so removes and returns a random element of pprio .
only if the set of pre computed prioritized method pairs becomes empty covcon computes the priority scores for all method pairs and fills pprio again.
the benefit of this optimization is to significantly reduce the number of computations of prioritization scores.
the downside is that prioritization is not always based on the most recent coverage information.
we find that in practice the benefits of the optimization outweigh this disadvantage.v.
i mplement a tion the implementation of covcon is available for download.
to instrument classes under test covcon builds upon the eclipse java development tools.
the instrumented classes under test write an execution trace into a file which is then analyzed to update the coverage information and to prioritize method pairs for the next round of test generation.
the test generation is implemented based on an existing framework for generating concurrent tests.4to execute generated tests we use the default scheduler of the java vm because this work focuses on test generation not on exploring test executions.
more sophisticated test execution approaches such as systematic exploration of interleavings or active testing could be plugged into our implementation.
vi.
e v alua tion to evaluate covcon we apply our implementation to supposedly thread safe classes with known real world concurrency bugs which have been used to evaluate prior work .
we compare the effectiveness and efficiency of covcon to five state of the art approaches for generating concurrent unit tests .
to the best of our knowledge this is the largest experimental comparison of approaches for generating concurrent tests both in terms of number of classes and number of approaches.
a. experimental setup table ii lists the classes under test.
the concurrency bugs in these classes include data races atomicity violations and deadlocks as shown in the bug column of the table.
the benchmarks include all classes used in except for one because we could not obtain the source code and all classes used in .
the table gives the number of lines of code methods and potential concurrent method pairs pfor each class.
these values include both the class itself and its superclasses but not java.lang.object because this is the code tested by covcon.
we compare our approach to random based test generation using contege and to coverage based test generation using autocontest .
to compare our approach with sequential test based approaches we use narada intruder and omen which detect data races atomicity violations and deadlocks respectively.
in contrast covcon detects all three kinds of concurrency bugs.
for a fair comparison we combine the three existing tools into a single tool that starts all three individual tools in parallel and reports a bug as soon as one of the individual tools has found a bug.
we call the combined sequential test based approach nainom standing for na rada in truder and om en.5since nainom relies on sequential seed tests to generate concurrent tests we need to provide sequential tests for each class under test.
for a fair 5as an alternative to running the three tools in parallel we also experiment with applying them in a round robin fashion.
since the parallel version of nainom is slightly more efficient we report these results.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
comparison with covcon which does not require creating any sequential tests and to avoid biasing nainom s behavior by providing a particular set of manually written sequential tests we generate sequential tests via feedback directed random test generation similar to randoop .
the generated tests call each public method of the class under test at least once as suggested by the authors of nainom.
the efficiency of automated concurrency testing depends not only on the generated tests but also on how these tests are executed.
both covcon and contege execute tests using the default scheduler of the java vm.
in contrast nainom and autotestgen build upon more sophisticated approaches for exploring interleavings that are likely to reveal concurrency bugs quicker .
since targeted strategies to explore the space of possible interleavings are known to outperform repeated execution we expect this difference in the setups to work in favor of nainom and autocontest.
for all approaches we measure the time to detect a bug as the total time required by each tool i.e.
including test generation and test execution or exploration time.
we use a timeout of one hour per run on a particular class.
because all approaches involve non deterministic decisions we repeat each experiment ten times with a different random seed.
to determine whether the time required by two approaches to detect a bug differs in a statistically significant way we compute the confidence intervals confidence of the measured times and check whether these intervals overlap.
all experiments are done on an intel core i7 cpu with eight .6ghz cores and 32gb memory running ubuntu .
l ts bit .
b. bug finding capabilities covcon detects thread safety bugs in of the classes under test.
the detected bugs include data races atomicity violations and deadlocks.
in comparison the existing contege nainom and autocontest approaches fail to detect a bug in and classes respectively.
table ii lists the average time required to detect a bug where marks that an approach fails to find a bug within the one hour timeout for all ten runs of the approach.
a reason why autocontest which shares the idea of coverage directed test generation fails to detect various bugs is that it focuses on a particular kind of atomicity violation.
in contrast covcon uses a generic coverage goal suitable for any kind of concurrency bug.
c. efficiency an important criterion for applying automated concurrency testing in practice is the time required to detect a bug.
we compare this time for covcon and the state of the art approaches.
on average covcon requires seconds to find a bug in a given class.
in contrast all existing approaches require significantly more time and often exceed our one hour timeout as we discuss in detail in the following.
figure shows for each class under test the average speedup of covcon over the existing approaches.
speedup 6personal communication september .
1x 2x 3x 4x 4x 3x 2x 18speedup over existing approaches classes under testcontege nainom autocontest fig.
speedup of covcon over existing approaches in terms of the average time required to detect a bug.
note that several speedup factors exceed the displayed range.
here means the average time taken by the slower approach divided by the average time taken by the faster approach.
we present cases where covcon is the faster approach as a positive speedup and cases where covcon is a slower approach as a negative speedup.
several speedups exceeds the range that is shown in the figure.
for example for class logger covcon is at least 4x faster than all three existing approaches.
for class vector covcon is at least 4x faster than contege .3x faster than nainom and at least 4x slower than autocontest.
overall covcon clearly outperforms the existing approaches.
we discuss exceptions to this overall result below.
table ii provides detailed execution times and speedup factors for all classes.
the columns in the time to bug block show how long each approach takes to detect a bug in a particular class.
for example covcon requires seconds to detect a bug in logger whereas contege takes seconds on average.
we mark classes that cannot be analyzed by a particular tool because the tool crashes with .
the last block in table ii shows the speedup of covcon over the existing approaches.
for example covcon is .
times faster in finding a bug in logger than contege.
because we stop the existing approaches for several classes after the onehour timeout the speedup is an underapproximation.
for example covcon is at least .
times faster than nainom for class logger .
to ease the presentation the table color codes the speedups where a darker colors means a higher speedup.
we also mark which speedups are statistically significant by printing these speedups in bold.
contrary to most classes there are three classes where an existing approach clearly outperforms covcon.
the xstream class is an outlier in the comparison with contege.
the reason is that covcon s prioritization mechanism is less successful than for the other classes in steering testing toward higher interleaving coverage section vi f .
the vector .
.
class stands out in the comparison with autocontest.
the reason is that this class suffers from an atomicity violation that is unlikely to be triggered yet perfectly matches the bug authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
t able ii classes under test and the time required to find bugs in them with covcon and existing approach.
indicates a timeout.
the last columns color code the speedup of covcon over the existing approaches into three categories faster .0x and 2x much faster 2x and 4x a lot faster 4x .
speedups printed in bold are statistically significant.
time to bug seconds avg.
speedup of covcon over .. id class loc meth.
cmps bug covcon contege nainom auto contege nainom autocontest contest bufferedinputstream jdk .
atom.
.
.
.
logger jdk .
.
atom.
.
.
.
synchronizedmap jdk .
.
deadl.
.
.
concurrenthashmap jdk .
.
atom.
.
.
.
stringbuffer jdk .
.
atom.
.
.
timeseries jfreechart .
race .
.
.
xyseries jfreechart .
.
race .
.
.
numberaxis jfreechart .
.
atom.
.
.
.
periodaxis jfreechart .
.
race .
.
xyplot jfreechart .
.
race .
.
day jfreechart .
.
race .
.
.
peruserpooldatasource dbcp .
race .
.
sharedpooldatasource dbcp .
race .
.
xstream xstream .
.
race .
.
v ector jdk .
.
atom.
.
.
.
v ector jdk .
.
atom.
.
.
.
intrange apache commons .
atom.
.
.
.
asmap google commons .
atom.
.
.
.
pattern that autocontest targets.
finally naimon is faster than covcon in detecting a bug in concurrenthashmap .
despite these outliers the overall results show covcon to be significantly more efficient than state of the art approaches.
d. number of tests the overall effectiveness of automated testing depends both on how effective individual tests are and on how long it takes to generate such tests .
covcon may generate and execute several hundreds or even thousands of tests before finding a bug whereas nainom and autocontest typically require less then a hundred tests.
however as our results in section vi c show covcon clearly outperforms nainom and autocontest in terms of the overall effectiveness because the higher effectiveness of their generated tests comes at a significantly higher cost for generating each test.
e. comparison with naive prioritization we compare our prioritization of method pairs section iv c with a naive prioritization that always selects the method pair that has been tried the least number of times.
if multiple such pairs exist the approach randomly picks from all pairs with the minimum tried count.
the efficiency of this naive prioritization is either similar or worse than for our prioritization.
for example the time required to find a bug with the naive prioritization is 450x 13x and 5x higher than with covcon for bufferedinputstream numberaxis and day respectively.
f .
steering toward uncovered interleavings to validate our hypothesis that covcon effectively steers toward tests that cover not yet covered interleavings we compare the interleaving coverage achieved when executing tests 10000coverage time seconds xyplot 10000coverage time seconds peruserpooldata source fig.
interleaving coverage over time for two representative classes.
the upper red curve is for covcon the lower green curve is for contege.
the x axis is log scaled.
generated by covcon and the random based contege.
each experiment runs either until coverage is reached or until one hour is over and each experiment is repeated times.
figure shows the results for two representative classes.
each graph gives the percentage of covered concurrent method pairs over time and it provides the mean and confidence interval for each data point.
the results show that a coverage guided approach indeed achieves higher interleaving coverage in less time.
for most classes the interleaving coverage achieved through both automated testing approaches saturates at some point and covcon reaches this point earlier than contege.
note that reaching coverage may be infeasible e.g.
when two methods cannot execute concurrently because they are protected by the same lock.
g. breakdown of overall execution times figure shows how much time covcon spends on i generating tests ii executing tests iii analyzing the execution trace to update coverage information and prioritizing concurrent method pairs and iv checking for thread safety authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
123456789101112131415161718percentage of overall time classes under testthread safety oracle coverage tracking prioritization test execution test generation fig.
breakdown of time spent in different parts of covcon.
violations by executing linearizations of concurrent test executions.
most time is spent in the test generation part of the approach which underlines the need to steer this part toward tests that explore not yet covered behavior.
class synchronizedmap is an outlier because an unusually high amount of time is spent in the thread safety oracle.
the reason is that about of all generated tests cause an exception or a deadlock so the thread safety oracle must check an unusually high number of linearizations to check whether the misbehavior is due to a thread safety violation.
vii.
r ela ted work a test generation section vi experimentally compares our work to recent random based sequential testbased and coverage based generators of concurrent tests.
other existing approaches include the randombased ballerina and the coverage based consuite .
conceptually covcon improves upon random based approaches by using interleaving coverage to steer the test generation toward infrequently tested interleavings.
in contrast to sequential test based approaches covcon does not require sequential tests but has the class under test as its only input.
the main differences of our work to existing coverage based approaches are i to use a conceptually and computationally simpler coverage metric and ii to work well for arbitrary kinds of concurrency bugs.
speedgun generates concurrent tests that expose performance problems.
schimmel et al.
combine test generation with a static pre analysis of the code to find methods that access shared data.
one could integrate such a static analysis into covcon to reduce the set of concurrent methods pairs to consider.
claessen et al.
propose a test generator for erlang programs .
it requires a user to provide a finite state model of the tested program whereas our approach is fully automatic.
multithreadedtc and imunit are unit testing frameworks to manually write concurrent unit tests.
in contrast covcon generates tests automatically.
besides concurrent tests there is a long history of approaches for generating sequential tests e.g.
based on random testing symbolic execution concolic execution and genetic algorithms .
b interleaving coverage several concurrency related coverage metrics have been proposed.
taylor et al.
pioneered by proposing a hierarchy of concurrency coverage criteria .bron et al.
discuss coverage metrics that are useful for human developers that write concurrent tests .
other work adapts the definition use path coverage criterion to concurrent programs .
lu et al.
theoretically analyze the cost of seven interleaving coverage criteria .
our work differs from these approaches by using interleaving coverage as a feedback mechanism for generating concurrent tests.
the coverage criterion that covcon builds on concurrent method pairs is inspired by deng et al.
s concurrent function pairs .
they use the criterion to select from pre defined inputs to analyze with dynamic concurrency bug detectors whereas we use it to generate new inputs.
since the design goals are different how they measure coverage and use coverage to conduct prioritization are also completely different from us.
c schedule exploration a single program and input may have many different schedules approaches for exhaustive bounded change based and heuristic exploration of schedules have been proposed.
active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs .
other work uses concurrent coverage metrics to select and prioritize schedules to explore .
selecting schedules and generating tests are two orthogonal problems.
covcon can be combined with existing schedule exploration approaches and such a combination may further reduce the time required to detect bugs.
d static analysis synthesis v erification one alternative to testing concurrent software are synthesis and verification .
these approaches rely on a formal specification that describes the desired behavior of the synthesized program.
instead covcon can be directly applied to existing thread safe classes.
another alternative are static analyses e.g.
to detect data races or deadlocks .
in contrast to those covcon covers multiple kinds of concurrency bugs and guarantees to report only true positives.
viii.
c onclusion this paper presents covcon an efficient coverage guided generator of concurrent tests.
the main idea is to measure which interleavings are not yet covered by existing tests and to generate tests likely to cover these interleavings.
key to the success of covcon is the insight that concurrent method pairs provide an inexpensive coverage metric that is effective in steering test generation toward not yet covered interleavings.
an implementation of the covcon approach reveals concurrency bugs in thread safe classes from popular java libraries.
furthermore we show that covcon reduces the time to detect bugs over existing random based and sequential testbased approaches in of cases with speedups of at least 4x in of cases.