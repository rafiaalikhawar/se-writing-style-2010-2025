model driven run time enforcement of complex role based access control policies ameni ben fadhel university of luxembourg luxembourg ameni.benfadhel uni.ludomenico bianculli university of luxembourg luxembourg domenico.bianculli uni.lulionel c. briand university of luxembourg luxembourg lionel.briand uni.lu abstract a role based access control rbac mechanism prevents unauthorized users to perform an operation according to authorization policieswhicharedefinedontheuser srolewithinanenterprise.
several models have been proposed to specify complex rbac policies.however existingapproachesforpolicyenforcementdonot fullysupportallthetypesofpoliciesthatcanbeexpressedinthese models which hinders their adoption among practitioners.
inthispaperweproposeamodel drivenenforcementframework forcomplexpoliciescapturedbygemrbac ctx acomprehensive rbac model proposed in the literature.
we reduce the problem ofmakinganaccessdecisiontocheckingwhetherasystemstate fromanrbacpointofview expressedasaninstanceofthegemrbac ctxmodel satisfiestheconstraintscorrespondingtothe rbac policies to be enforced at run time.
we provide enforcement algorithmsforvarioustypesofaccessrequestsandevents anda prototypetool morro implementingthem.wealsoshowhow to integrate morro into an industrial web application.
the evaluation results show the applicability of our approach on a industrial system and its scalability with respect to the various parameters characterizing an ac configuration.
ccs concepts security and privacy access control software and its engineering model driven software engineering keywords role basedaccess control enforcement policies model driven engineering acm reference format ameni ben fadhel domenico bianculli and lionel c. briand.
.
modeldriven run time enforcement of complex role based access control policies.in proceedingsofthe201833rdacm ieeeinternationalconferenceon automated software engineering ase september montpellier this work has received funding from the european research council under the european union s horizon research and innovation programme grant agreement no from the luxembourg national research fund fnr grant no fnr p10 and from the university of luxembourg grant reacp .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
11pages.
introduction access control ac systems have been used to restrict a user to accesscriticalresourceswithinanenterprise.oneofthemostused acmodelsisrole basedaccesscontrol rbac whichallowsa usertoaccessa resourceortoperformanoperationbased onher role e.g.
her job position within an enterprise.
the first rbac model rbac96 defines authorization policiesby mapping each user to a set of roles and each role to a set of permissions a permission is defined as an abstraction of a set of operations that can be performed on a set of objects i.e.
resources.therefore auserisallowedtoperformonlytheoperationsofthepermissionsassociatedwithherrole.severalproposals haveextendedrbac96tosupportnewtypesofpolicies suchas delegation andcontextual .inaddition toextended rbacmodels severalpolicy languageshave been proposed to ease the specification of complex rbac policies on top of these models.
in this paper we consider our recent proposal ofanrbacmodel calledgemrbac ctx whichhasbeen designed to be very expressive by seamlessly integrating the varioustypesofauthorizationpoliciessurveyedintheliteratureand classifiedinataxonomy .tothebestofourknowledge thegemrbac ctxmodelistheonlyonesupporting allthepoliciestypes classifiedin prerequisite cardinality precedenceand dependency rolehierarchy separationofduty sod binding of duty bod delegation and revocation contextual and their different facets.
moreover gemrbac ctxispairedwithahigh levelpolicyspecificationlanguage gemrbac dsl to encourage its adoption among practitioners.
we formalized the policies supported by gemrbac ctx as ocl objectconstraintlanguage constraints toenable theiroperationalization.followingamodel drivenapproach we defined the semantics of gemrbac dsl by mapping the language constructs to the ocl constraints presented in .
abiggapbetweenthedefinitionofnew richerrbacmodelsand languagesandtheiradoptioninpracticeistheavailabilityofan enforcementmechanism thelatterisacomponentthatreceivesauser accessrequest hereafterreferredtoas acrequest atruntime and makes an access decision allow deny based on the policies configured for a system.
the lack of enforcement mechanisms for more expressive rbac models has favored the adoption on a large scale ofthestandardrbac96model whichis however the leastexpressivemodel.forinstance oneofourindustrialpartners developing communication solutions for manipulating sensitive dataincriticalsituationssuchasnaturaldisastersorwars needs to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france ameni ben fadhel domenico bianculli and lionel c. briand specify and enforce complex policies that involve the user s context spaceandtime thehistoryofoperationsperformedbytheuser androledelegations.anexampleofsuchapolicy inthecontextof asylumseekersassistance is anoperatorwiththerole coordinator can register asylum seekers only if he is located within a miles radius from the base camp from 8am to 7pm.
such policies are not supported by rbac96 but can be specified usinggemrbac ctx and expressedusinggemrbac dsl .
however they cannot be enforced because there is no enforcement mechanism forchecking the complex acpolicies that aresupported by the gemrbac ctx model.
indeed state of the art enforcement mechanisms such as support ac models which are much less expressive than gemrbac ctx.
in this paper we aim to fill this gap by proposing an automated mechanismtoenforcecomplexacpoliciesdefinedontopofthe gemrbac ctxmodelandexpressedinthegemrbac dsllanguage.wefollowamodel drivenengineering mde approach forenforcementbasedonstandardizedtechnologiessuchastheunifiedmodellinglanguage uml andobjectconstraintlanguage ocl .
more specifically we reduce the problem of enforcing rbac policies to the evaluation of the corresponding ocl constraintson an instance of the gemrbac ctx model.
one advantage of such an approach is that the translation of gemrbac dsl policies into ocl constraints is already defined by adopting a model driven approach we can leverage the existing operationalization through oclconstraintsof gemrbac dslpolicies.moreover oclconstraint checking given that ocl is a standard is a consolidated technologyimplementedinmaturetools suchastheconstraint query evaluator included in eclipse ocl .
our model driven enforcement approach not only enforces policies uponreceiving a user request but also providesa continuous enforcementaftermakinganaccessdecision byhandlingevents corresponding to changes in the rbac configuration to guarantee that a new configuration still fulfills the ac policies.
the relevant access decisions are re evaluated whenever a new change from an ac point of view occurs at the system state level e.g.
a user changes location or a new user is authenticated .
for instance wheneverauserchangesherlocation ourenforcementmechanism checks whether her active roles should be deactivated because of hernewlocation .thisenforcementisknownasusagecontrol in the area of ac.
although there have been a few proposals for model driven enforcement they adopt an rbac model much simpler than gemrbac ctx and thus can deal with a limited setof ac policy types moreover they consider a subset of the acrequests events supported by our approach.
furthermore definingalgorithmstopreciselydecidewhenandhowtoenforceocl constraints corresponding to gemrbac dsl policies as well as definingandengineeringanarchitecturetointegratetheconstraint checker into a web application remain open questions that are addressed in this paper.
weimplementedourmodel drivenenforcementmechanismina prototype calledmorro.weintegratedmorrointoawebappli cationdevelopedbyourindustrialpartner followingtheguidelines ofthexacmlstandardarchitecture ourimplementationincludesapolicyenforcementpoint pep andapolicydecisionpoint pdp .althoughtheproposedarchitecturehasbeendesignedbasedon our partner specifications it can be generalized and integrated into other web applications.
we evaluated morro in terms of applicabilityandscalability.theevaluationresultsshowthatmorro can be adopted without considerably impacting the overall performance in terms of response time of a web application and that morroscaleslinearlywithrespecttothevariousparameters e.g.
the number of users and roles characterizing an ac configuration.
overall the results confirm the feasibility of using a model driven approach to efficiently enforce complex rbac policies.
to summarize the main contributions of this paper are a model driven approach for enforcing access control policies definedontopofthegemrbac ctxmodel includingalgorithms specifyingwhenandhowthepolicyconstraintsareenforced an extensive empirical evaluation of our approach when integrated in an industrial system to assess its performance and scalability.
thepaperisorganizedasfollows.section 2presentsbackground material.section 3illustratesourmodel drivenapproachforenforcing gemrbac ctx policies.
section 4describes the integration of the proposed approach into the architecture of an industrial webapplication.section 5presentstheempiricalevaluationresults.
section6reviewsthestateoftheart.section 7concludesthepaper.
background the gemrbac ctx model thegemrbac ctxmodel isanextensionoftherbac96 model thathasbeendesignedaftersurveyingthevarioustypes of the authorization policies proposed in the literature.
the restof this section gives an overview of the main entities of gemrbac ctx that are used in the subsequent sections.
the gemrbac ctx model defined as a uml class diagram contains all the entities user role session permission o ft h e originalrbacmodel.theseentitiesaremodeledasumlclasses.
a permission is represented as a set of operations that can be performed on a set of objects.
the relations among these rbac entities are modeled as uml associations.
each role is assigned to asetofpermissionsandtoasetofusers.arolecanbeinherited using a role hierarchy relation.
the inheritance of role assignment relationships can be defined using a role hierarchy policy a user or a role assigned to a role respectively permission must also be assigned to allits sub roles respectively sub permissions .
asessionisamappingofoneusertoasubsetoftherolesthat have been assigned to her this mapping activates the role s for a certain user.
however in some systems only a subset of the assignedrolescanbeactivated e.g.
becauseoftheuser slocation which are called enabled.
once a role is enabled a user can request its activation within a session.
both role enabling and activation aremodeledasumlassociationsbetweenthe roleandsession classes.similarly apermissionisenablediftheuserisallowedto perform its associated operations.
in addition to assignment relations authorization policies are definedto restrictauser access.for instance roleand permission enabling disablingcanberegulatedthroughprecedenceandcontextualpolicies.
precedencepolicies defineaprecedencerelationship betweentheenablingofaroleandtheactivationofanotherrole for example role studentisenabledonlyifa supervisor rolehasbeen already activated.
contextual policies restrict a user to activate a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
model driven run time enforcement of complex rbac policies ase september montpellier france roleorperformanoperationassignedtoapermissionofherroledependingonherlocation location basedpolicy andthecurrent time time basedpolicy .thecontext i.e.
spatialandtemporal information ismodeledwithclass rbaccontext whichcontainsa timeexpression and oralocation .thegemrbac ctxmodel supports policies with fine grained temporal and spatial expres sions such as the first monday of each month from april to january and the first floor of building a .
a role is disabledifitscorrespondingcontextualoraprecedencepolicyis violated a permission is disabled if its corresponding contextual policy is violated.
thegemrbac ctxmodelsupportsothertypesofauthorizationpolicies.
prerequisitepolicies defineapreconditiononuser torole assignment allowing a user to acquire a role only if she is already assigned to another one .
prerequisite policies can alsobedefinedatthepermissionlevel allowingaroletoacquire a permission only if this role is already assigned to another permission.cardinality policies define a bound on the cardinality of roleactivationandassignmentrelations e.g.
apolicyoftype cardinalityonroleactivationrestrictsauserfromactivatinganumber of roles that exceeds a given threshold.
dependency policies complementary to the precedence ones restrict the deactivation of aroleifanotherroleisstillactive .separationofdutypolicies sod define a mutual exclusion relation among roles permissions orusers theentitiesinvolvedinsuchrelationsarecalled conflicting sodpoliciescanbeeitherstaticordynamic.
staticsod policiesdeal with user to role and role to permission assignments for example staticsodonconflictingrolesspecifiesthatthesameusercannot be assigned to mutually exclusive roles.
dynamic sod policies deal withuser roleactivationthroughasession inthiscase auseris allowedtoacquireconflictingrolesbutshecannotactivatethem at the same time.
examples of this type of policy are dynamic sod on conflicting roles dcr or users dcu and history based his dsod .binding of duty bod policies are the dual of the sod ones and define a correlation between a set of permissions whicharecalled bounded theyareusuallyusedinthecontextof workflow systems whose activities can be performed by different userswithdifferentroles.forexample inrole basedbod theoperationsallowedbytwoormorepermissionshavetobeperformed by the same role .
to support history based policies such as dynamicsodorbod operationsperformedbyauseronagiven object in a certain context are recorded and modeled as instances of classhistory.delegation policies allow a user to delegate or transfer her role to another user .
a delegation is partial if only a strict subset of the permissions associated to a role has been delegated total otherwise.
revocation policies allow a user to revoke a delegated role .
aninstanceofthegemrbac ctxmodelcorrespondstoasnapshot of the system state from an rbac point of view at a giventime point.
for example the object diagram in figure 1depicts aninstanceofthegemrbac ctxmodelthatrepresentsthefollowingrbacentities two users u1andu2 tw orolesr1andr2 twopermission s p1andp2 t w ooperation sop1andop2 four objects o1 o2 o3ando4.
permission p1is assigned to role r1and permission p2isassignedtorole r2throughrole permissionassignmentassociations rpa .permission p1mapsoperations op1and op2to objects o1ando2 similarly permission p2maps operations1 session u1 userr1 role p2 permissionu2 user p1 permission op1 operation op2 operation o1 objecto3 object o2 objecto4 object r2 role legend ra role activation ura user role assignmentrpa role permission assignmentra rarpaurauraura ura rpa cu1 rbaccontextpu1 location figure an instance of the gemrbac ctx model representing a system state.
op1toobjects o3ando4.moreover bothroles r1andr2areassigned both to user u1and to user u2through user role assignment associations ura .
at the time when the snapshot has been taken only user u1isconnectedthroughhersession s1andhasactivatedher assignedroles r1andr2 asshownbytherole activationassociations ra .thelocationofuser u1ismodeledwithobject cu1 an instance of the rbaccontext class with a location object pu1.
thepoliciessupportedbythegemrbac ctxmodelhavebeen formalized asocl constraints to enabletheir operationalization.forinstance a dynamicseparationofdutypolicy dsod on conflictingroles suchas ausercanactivateeitherrole r1orr2 is checked by verifying the following invariant taken from of the classsession defined as an ocl constraint session defined as an ocl constraint 1context session invdsod 2letr1 role role.
allinstances select r role r.idrole r1 4r2 role role.
allinstances select r role r.idrole r2 6in ifself.activer oles includes r2 orself.activeroles includes r1 then self.activer oles includes r2 xorself.activeroles includes r1 endif the dsod policy above can be checked on the model instance showninfigure 1byevaluatingtheinvariant dsodonthesession object s1.
in this case the condition at lines 7istruebecause bothroles r1andr2areactive.therefore wefollowthe thenbranch andevaluate thebooleanexpressionat lines .thisexpression states that the list of active roles associated with session s1should containeither r1orr2 butnotboth.sincebothrolesareactive the expression evaluates to false meaning that the policy is violated.
the ocl formalization of the rbac policies has been used to define the semantics of gemrbac dsl a high level policy specificationlanguagebuiltontopof gemrbac ctx.eachpolicy expressed in gemrbac dsl is mapped to an ocl constraint to operationalize its checking.
for instance the dsod policy above can be expressed in gemrbac dsl as pl1 dsod conflicting roles activation r1 r2 we remark that gemrbac dsl does not express basic ac policies i.e.
those encoded as a role to user and role to permission assignments and as b role to session activation or enabling relations gemrbac dslassumesthatsuchpoliciesarealreadydefinedat the model level as uml associations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france ameni ben fadhel domenico bianculli and lionel c. briand snap processor access decision gemrbac dsl policies...before deployment after deployment run time ac request ac event initialsnap snapenforcement framework1 .a ocl constraints targetsnap... ocl constraints to evaluate ocl checker enforcement upon ac event enforcement upon ac request3.b .b .a3 x x2 figure overview of the proposed model driven framework for policy enforcement.
model driven enforcement of complex policies thegoalofthispaperistoproposeanautomatedmechanismtoenforce access control policies defined on top of the gemrbac ctx modeland expressedusingthegemrbac dsllanguage.one basic idea to achieve this goal is to leverage the operationalization throughoclconstraintsof gemrbac dslpoliciesproposedin to define a model driven enforcement approach.
at the base of this approachthereis thereductionoftheproblemofenforcinggemrbacdslpoliciestotheevaluationofthecorrespondingoclconstraints on an instance of gemrbac ctx which captures the system state from an ac point of view .
adopting a model driven approach for enforcing gemrbac dsl policies has two main advantages the possibility of building upon the existing translation of gemrbacdsl policies into ocl constraints which is already optimized for efficient checking the reliance on ocl which is a standard and for which there exists mature constraint checking technology.
nevertheless putting such an approach in operation requires todefinealgorithmstopreciselydecidewhenandhowtoenforce suchconstraints aswellastooutlineanarchitecturethatdescribes how to integrate the constraint checker into a web application architecture theseareopenquestionsthatwillbeaddressedbythe coming sections.
figure2illustrateshowourapproachcanberealizedinanenforcementframework.beforedeployingtheapplication weassume that a security admin has defined the initial system state from the point ofview of ac.
thismeans that themain rbac entities i.e.
users roles permissions operations and objects of the system havebeendefined togetherwiththeirassignmentrelations e.g.
assignment of permissions to the various roles .
these entities representingthestaticrbacviewofthesystem arecapturedin an instance of the gemrbac ctx model called initialsnap.w e also assume that the security admin has defined the ac policies ingemrbac dsl.thesepoliciesarethentranslatedintoasetof oclconstraints withrespecttothegemrbac ctxmodel using the translation defined in .
after deployment when the system is executing the enforcement framework works as follows.
its inputs are thesetofoclconstraintscorrespondingtothegemrbacdsl policies defined for the system.
a snapshot snapof the system state from the point of view of ac represented as a gemrbac ctx instance.
this snapshottable policies checked for each type of ac request event rpprq rh ac as prec dep s dcr dcu obj op his bod ct cl deleg rev ra check check check ar check check check check rd check check check check check rr check check check check ao check check check check check check ua check check check ulc check ud check legend.
r ac request event.
p policy.
type of ac request event ra role activation ar access to a resource rd role delegation rr role revocation ao administrative operation ua user authentication ulc user s location change ud user disconnection.
type of policy prq prerequisite rh role hierarchy ac cardinality on role activation as cardinality on assignment rela tions prec precedence dep dependency s static sod dcr dynamic sod on conflicting roles dcu dynamic sod on conflicting users obj object based dsod op operational based dsod his history based dsod bod binding of duty ct time based context cl location based context deleg delegation rev revocation.
captures both the static rbac view of the system and the dynamic rbacview e.g.
activesessions users contexts itisupdatedat run time as the ac configuration evolves.
notice that right after the start of the system execution snapcorresponds to initialsnap.
the actual ac request that has to be enforced.
it contains asinstancesofthecorrespondingclassesofthegemrbac ctx model the objectto accessand the operation to performon it such as get url to resource .
thevariousstepsoftheenforcementprocessareshowninfigure2andaremarkedwithgreendashedlinesandcircles.themain component of the enforcement framework is the snapprocessor.
oncetheframeworkreceivesanacrequest step thesnapprocessorfirstanalyzestherequestbycheckingwhethertherequest isvalid step .forinstance ausercannotrequesttoactivatea role that is not assigned to her.
in case the request is not valid the access is denied and the access decision is returned step .
otherwise iftherequestisvalid the snapprocessor buildsanew snapshotofthesystemstate step .a startingfromthecurrent statecapturedbythe snap.thisnewsnapshot called targetsnap and also represented as an instance of the gemrbac ctx model captures the next system state from the point of view of ac as iftheacrequesthadbeenallowed.aftercreatingthe targetsnap thesnapprocessor selects based on the type and the parameters of the ac request the ocl constraints to evaluate step .b correspondingtothepoliciestoenforce thepoliciesselectionfollows the rules encoded in the top part of table .
the selected ocl constraints are evaluated by an ocl checker step .
in this way makinganaccessdecisionforanacrequest step isequivalent toverifyingwhetherthe targetsnap satisfiestheoclconstraints corresponding to the policies to enforce.
if the constraints evaluate totrue itmeansthattheacrequestcanbeallowed sinceitwillnot violate any policy.
onthe contrary when the constraints evaluate tofalse it means that allowing the request would violate one or more of the policies defined for the system.
our approach adopts also the usage control concept for ac which aims to revise ac decisions by re enforcing ac policies when a new update from the point of view of ac occurs at the systemlevel.forinstance wheneverauserchangesherlocation ourenforcementmechanismre evaluatesthe oclconstraintscorresponding to the location based policies for this user to check authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
model driven run time enforcement of complex rbac policies ase september montpellier france algorithm enforcement upon receiving an ac request input a ac request snap current system state p list of system policies output a tuple angbracketleftd targetsnap angbracketright where d access decision targetsnap new system state plc targetsnap null d null ifvalidaterequest a then targetsnap buildtargetsnap a snap plc selectpolicies p a elsed false ifdisnullthen d check targetsnap plc return angbracketleftd targetsnap angbracketrightalgorithm enforcement after an ac event occurs input e ac event snap current system state p list of system policies output usnap updated system state plc usnap null usnap updatestate e snap plc selectpolicies p e for each policy pinplcdo check usnap p ifpis not satisfied then rectify usnap p e returnusnap whetherthenewsystemstatesatisfiesthem.thevariousstepsof theenforcementprocessuponanaceventareshowninfigure and are marked with blue solid lines and squared boxes.
in our case weassumethattheenforcementframeworkwillreceive from an external component a notification when an ac event occurs step1 .
reacting to this notification the snapprocessor creates thetargetsnap obtained by updating according to the received event the current system state captured by the snap step2.a .
thesnapprocessor thenselects basedonthetypeoftheacevent theoclconstraintstoevaluate step .b correspondingtothe policies to enforce the policies selection follows the rules encoded inthebottompartoftable .finally itchecks bymeansoftheocl checker whethertheselectedpoliciesarestillsatisfied step .
if a policy violation is detected the snapprocessor updates the targetsnapbydisabling deactivatingthecorrespondingrole step the updated targetsnap then becomes the new snap step5 .
thenextsubsectionsexplainhowour frameworkenforcesac policies when making an access decision for an ac request section3.
andwhenhandlingnotificationsforacevents section .
.
.
making access decisions for ac requests the procedure for enforcing policies upon receiving an ac request isshowninalgorithm .ittakesasinputanacrequest a asnapshot snapcorresponding to the system state from the point of view of ac at the time of the request and the list pof policies defined forthesystem itreturnsatuple containingtheaccessdecision d a boolean value with truecorresponding to allow and falseto deny andasnapshot targetsnap aninstanceof gemrbac ctx correspondingtothenewsystemstateasiftherequesthadbeen authorized .besidesvariables dandtargetsnap theprocedureuses an auxiliary variable plc representing the list of policies to check for a specific type of the ac request and initialized to an empty list.
both variables targetsnap anddare initialized to null.
our approach considers ac requests of type role activation access to a resource roledelegation rolerevocation and administrativeoperation i.e.
assigning a role to a user or to a permission .
first the snapprocessor checksthevalidityoftherequestbycallingoperation validaterequest line2 correspondingtostep in figure .
the validity is determined based on the type of the ac request as follows.
in case of a role activation the request is valid if the role to activate is already enabled for the user whomadetherequest.incaseofan accesstoaresource therequested permission e.g.
p should be assigned to an active role rin the current session of the user who made the request and should be enabled if the user who made the request acquired role rthrough adelegation thisdelegationshouldincludepermission p.incase of arole delegation therole beingdelegated should beassigned to theuserwhomadetherequestandnotassignedtotheuserwho willreceivethedelegation.incaseofan administrativeoperation the requested user respectively permission should not belong tothelistofusers respectively permissions assignedtotherole indicated in the request.
iftheacrequest aisnotvalid the snapprocessor setstheaccess decisiondtofalse line5 .
otherwise the snapprocessor builds the targetsnap by calling operation buildtargetsnap line3 corresponding to step .ain figure2 .
this operation takes as input the acrequest aandthesnapshot snap itsbehaviordependsonthe type of the ac request role activation.
we consider a request of the form user u1 requestingtoactivaterole r1 .first weremoverole r1fromthelist ofenabledroles.then weaddittothelistofactiverolesforuser u1 if a precedence policy is specified for role r1 thesnapprocessor enables the list of roles which should be enabled for other users according to the precedence relation.
access to a resource.
we consider a request of the form user u1with role r1requesting to perform operation op1on object o1 .
tobuildtargetsnap weaddanewinstanceoftype history tothe currentsnap.
this instance records that user u1 while having role r1 performed operation op1on object o1through permission p1.
role delegation .
we consider a request of the form user u1 requesting to delegate her role r1to user u2 .
thetargetsnap is obtained by adding role r1to the list of delegated roles for user u2 and creating a new instance of class delegation.
role revocation.
we consider a request of the form user u1 requesting to revoke delegation d1 we also assume that user u2 acquired role r2through delegation d1 originated from u1 .
we build the targetsnap by removing role r2from the list of delegated roles assigned to user u2 marking delegation d1asrevoked and recording the revoking user u1 .
administrativeoperation.weconsiderarequestoftheform adminrequestingtoassignrole r1touser u1 or adminrequesting to assign role r1to permission p1 .
thesnapprocessor builds the targetsnap byaddingtheappropriateassignmentrelation i.earoleto user assignment or a role to permission assignment relation.
afterbuildingthe targetsnap thesnapprocessor extractsthelist plcofpoliciestocheckfromthesystempolicieslist pbycalling operation selectpolicies line4 corresponding to step .bin figure2 .
this operation determines the list of policies to check based on the type i.e.
according to table and the parameters oftherequest.forinstance incaseofanacrequestoftype role activation the list plcwill contain all the policies in pwhose type isindicatedinrow ra i.e.
ac dcr dcu andwhoseparameters match at least one of the request parameters i.e.
the user who made the request and the role to activate .
then if the accessdecision dhas not been set yet i.e.
it is null the algorithm invokes the ocl checker operation checkat line6 corresponding to step 4in figure2 .
this operation evaluates on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france ameni ben fadhel domenico bianculli and lionel c. briand thetargetsnap the ocl constraints corresponding to the policies inplc theresultoftheevaluationwillcontaintheaccessdecision.
the algorithm ends by returning the tuple with both the access decision dandthenewsystemstate targetsnap step5infigure2 .
we recall that when the access is denied targetsnap will benull.
.
handling notifications for ac events the procedure for updating the system state captured by the snap andenforcingpoliciesuponreceivinganotificationforanacevent isshowninalgorithm .ittakesasinputanacevent e asnapshot snapcorresponding to the system state from the point of view of ac at the time of the notification and the list of policies pdefined forthesystem itreturnsasnapshot usnap whichisaninstanceof thegemrbac ctxmodelcorrespondingtotheupdatedsystem state.
besides variable usnap initialized to null the procedure usesanauxiliaryvariable plc representingthelistofpoliciesto check for a specific type of event and initialized to an empty list.
ourapproachconsiderseventsoftype userauthentication user s location change and user disconnection.
upon receiving an event notification the snapprocessor first updates the system state according to the received event by calling operation updatestate line2 correspondingtostep .ainfigure2 .thisoperationtakesasinputthereceivedacevent eandthe currentsystemstatecapturedbythe snap itreturnstheupdated stateinusnap.the behaviorofoperation updatedependson the type of the event e theuser authentication event corresponds to the case of a userlogginginthesystem.weassumethattheenforcementframeworkreceivesthenotificationfromanauthenticationserver which checks the user credentials and allows her login.
in this case weupdate the state by adding a new instance of class session for theauthenticated user updatingtheuser s location andenabling within the newly added session all the roles assigned to the user.
theuser s location change event corresponds to the case of a connected user changing her location.
we assume that a geolocalizationserverkeepstrackoftheuserposition thisserversendsanotificationtotheenforcementframeworkwheneveraconnected user changes her location.
in this case the state is updated by updating the user s location.
theuserdisconnection eventcorrespondstothecasewhena user is experiencing network issues.
we assume that the authen tication server periodically checks for the online status of a userand sends a notification to the enforcement framework when it detects that the user is offline1.
in this case we update the state by removing the session of the disconnected user.
afterwards the snapprocessor extractsthelist plcofpoliciesto check from the system policies list p by calling operation selectpolicies line3 corresponding to step .bin figure .
this operation determines the list of policies to check based on the type according to table and the parameters of the received event notification.for instance incaseof a userauthentication event the listplcwill contain all the policies in pwhose type is indicated in rowua i.e.
ct cl and whose parameters match at least 1the case of a user sending a log out request to the authentication server is treated by forwarding the request to the enforcement mechanism which is then processed as explained in section .
.one of the notification parameters.
then for each policy pinplc thesnapprocessor invokes the ocl checker operation checkat line5 corresponding to step 3in figure to evaluate on the usnap theoclconstraint s correspondingto p.iftheresultofthe evaluationisfalse itmeansthatthenewsystemstate asdetermined in response to the event e violates policy p. applying the usage control concept the snapprocessor amends the usnap by calling operation rectify line6 corresponding to step 4in figure the behavior of this operation depends on the type of the event e user authentication.
we consider a notification of the form u1 s1 loc where u1istheuserbeingauthenticated s1isthetoken representingtheuser ssession locisthecurrentpositionoftheuser.
for each role renabled for user u1in session s1 thesnapprocessor amendsusnapby disabling role rin session s1.
user s location change.
we consider a notification of the form u1 loc1 loc2 where u1denotestheuserand loc1andloc2correspond respectively tothepreviousandthenewpositionofuser u1.foreachrole rassignedtouser u1 thesnapprocessor amends usnapaccording to the state of role r if it is enabled respectively active the snapprocessor willdisable respectively deactivate it from all the sessions of user u1.
user disconnection.
we consider a notification of the form u1 s1 where u1istheuserbeingauthenticatedand s1isthetoken representing the user s session.
for each role rassigned to user u1 thesnapprocessor amendsusnapbydisablinganddeactivatingrole r1from all sessions in the system.
the algorithm ends by returning usnap step5in figure2 .
run time architecture and implementation wehaveintegratedtheenforcementframeworkpresentedinsection3into the architecture of a web application developed by our partner.thisarchitectureincludes a awebapplicationandaset ofmicro services whichexposeresourcesaccessiblethroughthe web interface b a geo localization server which records the users position andc anauthenticationserver for authenticatingusers based on their credentials.
to integrate our enforcement framework we have added two newcomponentstothisarchitecture an authorizationserver and aproxy.thesecomponentsfollowstheguidelinesofthexacml standardarchitecture whichprescribestousetwocomponents apolicyenforcementpoint pep anda policydecisionpoint pdp .in this standard architecture a user ac request is intercepted by the pep whichwilltransformitintoanxacmlrequestandforwardit to the pdp the latter evaluates the request based on the authorization policies.
in our case the pep is the proxy while the pdp is the authorizationserver.the authorizationserver integratesthe snapprocessor andtheoclcheckershowninfigure itreceivesac requests and notification of ac events and enforces the policies as described in section making sure that only authorized users can accesstheresourcesexposedbythesetofmicro services.the proxy isagatewaythatinterceptsuseracrequests itfirstforwardsthem to theauthorization server which makes an access decision that is returnedtothe proxy iftheaccessdecisionis allow the proxyforwards the original user request to the corresponding micro service.
inaddition wehaveincludedastoragecomponentfortheaccess authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
model driven run time enforcement of complex rbac policies ase september montpellier france controldata whichcontainsthesnapshot snap givenininputto andupdatedbythe authorizationserver andthegemrbac ctx policies to enforce.
although the resulting enforcement architecture has been designed based on the architectural specifications provided by our industrialpartner itcanbegeneralizedandintegratedintoother web applications.
more specifically the proxycan be integrated seamlessly within existing load balancers which are very common inwebapplications theauthorizationserver andthestorage are additional components that can be deployed on any web application server.
implementation.
the core of our framework is a component called morro model driven f ramework for run time enforcement of rbac p olicies and includes the authorization server and theproxy.
morro has been implemented in java with a microservicebasedarchitectureusingthespringboot frameworkand thezuulproxyv.
.
.
.theimplementationofthe authorizationserver usestheeclipsemodelingframework emf andeclipse ocl v. .
.
the snapis expressed as an ecore model.
evaluation in this section we report on the evaluation of morro when deployed in a real web application with a complex ac configuration.
we assess the efficiency and applicability of morro by answering the following research questions rq1 howlongdoestheauthorizationserverinmorrotaketo processacrequests events whendeployedonarealindustrialsystem under various ac configurations?
rq2 howdotheaccessdecisiontimeandtheaceventprocessing timeof theauthorizationserver inmorroscalewith respectto changes of the various parameters potentially affecting the performance of an ac configuration?
rq3 what is the communication overhead between the authorization server and theproxyin case of an ac request?
.
evaluation settings we considered a real ac configuration used by our industrial partner consisting of users roles permissions objects and operations create read update and delete .
we defined a set of gemrbac dsl policies in collaboration with the security engineers of our partner.
we then determined the types of policies used in the specification and for each type we considered a representativeexampletoanswertheresearchquestionsmentioned above.toenablemorrotoenforcethem weusedthemappingof these policies to ocl constraints we previously proposed in .
wedeployedmorroontoamicro service basedarchitecture provided by our industrial partner.
this architecture was running onadevelopmentmachineequippedwithadualcpuintelxeon e5 2640v2 2ghzand24gbofmemory weusedthismachineto run all the experiments.
all time measurement were performed by invoking the system.nanotime method of the standard java library version .
.
duetospacereasons inthefollowingwepresentonlyasummaryoftheevaluationresults.werefertothefirstauthor sphd thesis foracompletedescriptionofthepoliciesused in the evaluation and for the detailed experimental results.
.
performance on an industrial system methodology.
to address rq1 we measured the time taken by the authorization server in morro to process different types of ac requests and events.
more specifically in case of an ac request we measured the access decision time i.e.
the time difference from the time the authorization server receives the request to the time it yields an access decision.
in case of an ac event we measured the execution time needed to update the current system state snap i.e.
thetimedifferencefromthetimetheauthorizationserverreceivesanotificationforanaceventuntilthetimeitupdatesthe current system state.
based on the ac configuration of the test application defined by our industrial partner we generated two types of ac requests and two types of ac events.
for each type of request respectively event the access decision time respectively execution time was assessed both on a basic configuration i.e.
an acconfigurationthatisonlydeterminedbyroleassignmentand activation relations and on configurations that add to the basic configurationotherpoliciestobechecked.thetypesofrequests and events generated are accesstoaresource.weconsidertwoscenarios whenthe role of the user making the request has been assigned and when asubsetofthepermissionsassignedtothisrolehasbeendelegated.
asfortheconfigurations inadditiontothebasicone weuseone with a history based dsod policy and another with a bod policy.
role activation.
the additional configurations use the cardinality on role activation and the dcr policies.
userauthentication.weconsidertwoscenarios inwhichwe distinguish whether the user s position is known or not.
the additionalconfigurationsuseprecedence location based andtimebased policies.
user slocationchange.weconsideroneadditionalconfiguration with a location based policy.
for all configurations we considered the worst case scenario with the maximum allowed value for each system parameter e.g.
maximum number of roles assigned to a user .
since morro runs on a java based environment the measurements of the running time are affected by various factors .
furthermore the network based communication between the proxy andtheauthorizationserver introducessomenoise.forthesereasons when measuring the access decision time for ac requests we sent ten ac requests discarded the first one since it is affected by the loading time of the run time libraries and measured the averagevalueovercheckingtheninesubsequentrequests.asfor measuringtheexecutiontimeforprocessingacevents wewere able to achieve stable results by sending only five notifications.
as above since the first value is affected by the loading of the runtimelibraries wediscardeditandmeasuredtheaveragevalueoverprocessing the four subsequent notifications.
in both cases to keep the same instance over the different runs we designed the initial acconfigurationofthesystemsuchthattheoclcheckeryields false denying the access request .
results.
we answer rq1by summarizing the main results.
the access decision time within the authorization server is less than 64ms thehighestvalueisobtainedwhileevaluatinganacrequest of typeaccess to a resource for a configuration with a history based dsod policy in a role delegation scenario.
this value has to be authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france ameni ben fadhel domenico bianculli and lionel c. briand analyzed in the context of web applications which are accessed by users from a browser.
in modern web applications the complexity ofeachsinglewebpagerequiresarelativelyhighnetworktime i.e.
the time needed by a browser to fetch all resources to be displayed on a page for example a web page from wikipedia requires on average1880msof networking time .
under this scenario a maximumoverheadof 64msduetotheacenforcementframework wouldcorrespondtolessthan4 increaseoverthetotalnetworking time which is quite affordable in practice.
theexecution time for processing a notification of an ac event is less than 512ms the highest value is obtained while evaluating an acrequestoftype userauthentication foraconfigurationwitha precedencepolicyconsideringthecasewhentheuserpositionis known.
this value has also to be interpreted in the context of web applications.
in such a context an ac event is triggered by a user action and its processing should be completed before the next user request so that the latter can be evaluated on the updated system data asmodifiedbytheacevent .hence theexecutiontimefor processing the notification of an ac event should be less than the time between the completion of a user request and the start of a newone i.e.
the thinktime .tcp w acommonbenchmark for web applications considers an average think time of 7s the maximum value for the execution time in our system 512ms i s well below this threshold.
.
scalability methodology.
to answer rq2 we evaluated the scalability of the authorization server.
scalability is concerned with analyzing thechange in access decision time and ac event execution time as parametersincreaseinvalue withrespecttodifferentscenariosand configurations.
our goal is to use such information to draw conclusions on how our solution is likely to tackle even more complex ac situations.
we considered the same ac requests and ac events used to answerrq1 andthecorrespondingscenariosandconfigurations.
to assess the effect of a parameter we varied it while keeping all the other relevant system parameters constant.
the parameter variedeitherbetweenarangeofvalueswithacertainstepincrement orthroughasetofpredefinedvalues thelattercaseoccurred for parameters that affect the evaluation of spatial and temporalpolicies.
the snapshots of the system state corresponding to all these configurations were generated using an internally developed parametrizedgenerator.ineachexperimentalrun wesentanac request or an ac event notification.
in the case of ac requests we measured the access decision time in the case of ac events we measuredtheexecutiontimeforprocessingtheevent.inbothcases we measured these values following the same procedure described in the answer to rq1.
results.
for space reasons here we only present the results corresponding to one type of ac request and to one type of ac event on a specific configuration.
table2reportsthe evaluationresults foran acrequest oftype access to a resource ar and for an ac event of type user authentication ua .weconsider1 anacrequestoftheform u1withrole r1insession s1requestingtoperformoperation op1onobject o1 onaconfigurationwithahistory baseddsodpolicy his forbothtable2 scalabilityof morroundervarioussystemconfigurations.
ac confparamvalues range step inctime ms lower upper min max data trend ar his rlab1 k 10k 1k alc m .
sd .
d1 k 10k 1k linear e1 k 4k1k alc m .
sd .
f1 k 10k 1k linear ar his rldb1 k 10k 1k alc m .
sd .
d1 k 10k 1k linear e1 k 4k1k123 alc m .
sd .
f1 k 10k 1k linear ua prec ulg1 k 10k 1k199 linear c1 k 5k1k845 linear a 10k 25k 5k891 linear ua prec klg1 k 10k 1k233 linear c1 k 5k1k1497 linear a 10k 25k 5k901 linear parameters labels.
a sessions in the system b active roles in s1 current session of the user who made the request c active roles in all sessions.
d logs associated with conflicting roles e objects within the set of logs f operations in the system g roles assigned to user u1.
configurationscenarioslabels.rla roleassignmentscenario rld roledelegation scenario ul the user location is unknown kl the user location is known.
scenarios of role assignment rla and role delegation rld and an ac event of type user authentication ua with a notification of theform u1 s1 loc where u1is theuser being authenticated s1is the token representing the user s session locis the current positionoftheuser onaconfigurationwithaprecedencepolicy prec fortwoscenarios inwhichwedistinguishwhethertheuser s position is known kl or not ul .
column ac conf indicates for each request event the considered configuration and scenario.
for instance the configuration on the first row ar his rla corresponds to the case of an ac request of type access to a resource on a configuration with a his policy while considering a role assignment scenario.
column paramindicates with a label see legend at the bottom of the table the parameter being assessed during the run column values range denotes the lower and upper bounds oftherangeofvaluesthroughwhichtheparameterisvaried the stepincrementisshownincolumn stepinc columntimeindicates the access decision time columns minandmaxdenote the lowest and the highest time values observed across runs column data trendindicates the trend observed for the data points in case of an almost constant referred to as alc trend we include the average columnm and the standard deviation sd .
the answerto rq2is thatthe access decisiontime and theexecution time for processing a notificationof an ac event are either linearwith respect to the parameters of the various configurations oralmostconstant i.e.
thereisnomuchvariationacrossruns with lowsd .
thesetrendscan beexplained intermsof theoperations called in the ocl constraints see evaluated for each policy.
forexample forthefirstconfiguration ac his rla withparameter b thenumberofactiverolesinsession s1 theaccessdecision timeisalmostconstant i.e.
itdoesnotdependonparameter b this isduetothedefinition in oftheoclconstraintcorresponding tothehistory baseddsodpolicy inwhichcheckingwhetherboth conflicting roles are active in session s1is performed in a constant authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
model driven run time enforcement of complex rbac policies ase september montpellier france time.similartrendscanbeobservedfortheotherconfigurations for each type of ac request event.
overall these results imply that our solution is applicable for even more challenging ac situations with larger numbers of sessions roles and permissions.
the highest value for the access decision time we measured was148ms inthecaseofarequestoftype accesstoaresource ina configurationwitha hispolicy witharoledelegationscenario with 10k objects within the set of logs.
along the lines of the discussion forrq1 such value would represent an overhead with respect to the average networking time see for fetching a complex web page.
such an overhead is still acceptable when enforcing ac policies in large systems.
the highest value for the execution time we measured was 2017ms in the case of an ac event of type user authentication in a configuration with a precedence policy with 25k active sessions withaknownuserlocation.asalsodiscussedfor rq1 this valuewouldstillbebelowthethinktimethreshold 7s provided by the tcp w benchmark.
.
overhead of the communication between the authorization service and the proxy methodology.
to address rq3 we measured the communication overhead between the authorization service and the proxy i.e.
the time takento dispatch an authorization request from theproxy to theauthorizationserver plusthetimetopropagatetheaccessdecisionfromtheauthorizationserverbacktotheproxy.wecomputed this overhead as the difference between the access decision time measured within the proxy and the access decision time measured within the authorization server the access decision time within theproxyisthedifferencebetweenthetimeinstantatwhichthe proxy receives an ac request from the user and the time instant at whichtheproxyreceivesanaccessdecisionforthatrequestfrom the authorization server.
wemeasuredthisdifferenceforalltherequests events scenarios and configurations mentioned in section .
.
results.
the answer to rq3is that theoveralloverhead of the communicationbetweenthe authorizationservice andthe proxy is less than 60ms.
when considering both the access decision time withintheauthorizationserverandthecommunication overhead between the authorization server and the proxy the most taxing ac request is one of type access to a resource for a configuration witha his policy withanaccessdecisiontimewithintheproxyof 107ms.alongthelinesofthediscussionfor rq1 suchvaluewould representlessthan6 oftheaveragenetworkingtime see for fetching a complex web page.
furthermore this value is far below the threshold 200ms indicated in the requirements specifications of the web application developed by our industrial partner.
related work thisworkleveragesourpreviousworkonmodelingandspecifying complex rbac policies using the gemrbac ctx model and the gemrbac dsl language including the operationalization of rbac policies as ocl constraints.
this paper complements and advances our previous work by providing an approach for the enforcement of rbac policies which includes the description of algorithms specifying when and how the policy constraints are en table3 supportofacrequests eventsinexistingpolicyenforcementapproaches abbreviationsaredefinedintable ac request ac event ra ar rd rrao ua ulc ud sohr et al.
hummer et al.
martinez et al.
zhang et al.
margheri et al.
mourad et al.
kallel et al.
mariscal et al.
mustafa et al.
kirkpatrick et al.
bhatti et al.
ben david et al.
morro this work forced thedefinitionandengineeringofanarchitecturetointegrate the constraint checker into a web application and an empirical evaluationoftheperformanceandscalabilityoftheapproachwhen integrated into an industrial system.
a work very close to our contribution has been proposed by sohretal.
whichimplementsthepdpasamodel drivenauthorizationengine inthecontextofwebservices.rbacpolicies are expressed as ocl contraints using the use tool a validation toolforumlmodelsandoclconstraints.similartomorro to make an access decision the authorization engine checks whether thesystemstate representedasanumlobjectdiagram satisfies therbacpoliciesexpressedasoclconstraints.themaindifference is that this work is based on the standard rbac96 model which supports a limited subset of the policies that can be specified in gemrbac ctx and enforced by our approach .
more precisely the proposed enforcement mechanism supports only cardinality prerequisite and history based sod.
moreover contextual policies assume that the context is represented symbolically i.e.
fine grainedspatial e.g.
withrelativelocations andtemporal e.g.
withintervals policiesarenotsupported.becauseoftheseintrinsic limitationsintheunderlyingmodel theenforcementmechanism can deal with only a subset of the ac requests access to a resource role activation and administrative operation and events user authentication supported by morro.
furthermore the approach presented in reference does not support usage control.
other model driven approaches for policy enforcement have been presented in .
in the approach by hummer et al.
rbac policies are written in a domain specific language based on uml activity diagrams and mapped to business process execution languageforwebservices ws bpel specificationstobeenforced atruntime however thisworksupportsonlyseparationofduty andbindingofdutypolicies.theworkbymartinezetal.
deals with the generation of a pdp infrastructure from a specification written in a policy language using atl model transformations.
a limitation shared by these model driven approaches is that rbac policies are only enforced as a response to a user ac request of typerole activation oraccess to a resource.
similarly the work by zhang et al.
propose an enforcement framework that supports only delegation and revocation policies.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france ameni ben fadhel domenico bianculli and lionel c. briand recentworkbymargherietal.
proposesaframeworkforthe specification analysis and enforcement ofabac attributebased access control policies rbac can be seen as a specific case of abac where role is one of the attributes.
in this work both ac requests and policies are expressed in a high level language calledfacpl theyarethentranslatedintoconstraintstobesolved using an smt solver.
although this approach is at a high level conceptually similar to ours both approaches formalize the semantics of ac policies as constraints either in ocl or in smt lib the underlyingacmodelsaredifferent.asaconsequence thetypesof requestsandeventsuponwhichthepoliciesareenforcedarealso different thefacpl based frameworkonlysupportsacrequests of typeaccess to a resource and does not support the concept of usage control.
furthermore its empirical evaluation considered only one small case study and randomly generated policies assessing scalability only in terms of the number of attributes.
other proposals deal with the generation of aspects from policy specifications the generated aspects are inserted into the application to be executed at run time.
mourad et al.
propose the use ofbpelaspectstoenforceacpoliciesinthecontextofwebservice composition.
kallel et al.
generate enforcement aspects in aspectjfromanrbacspecificationwrittenintemporalz.mariscalet al.
introduceanewumlartifact called role slice whichisused to generatedaspects.
mustafa etal.
proposean authorization engine in which policies written inazs pe cification are translated intoajavamodelinglanguage jml specificationtobechecked by a jml runtime assertion checker.
alimitationsharedbyallapproachesmentionedaboveisthat they do not adopt the usage control concept meaning that the proposed enforcement mechanisms cannot react to changes in the rbac configuration.
other proposals deal with context based usage control in rbac.
kirkpatricketal.
proposeaproximity basedenforcementmechanismforthegeo rbac modelusingthexacmlarchitecture.
however this work does not consider role activation as a separate request whensubmittingarequesttoaccessaresource theuserhas tospecifytheroletoactivate.althoughtheproposedmechanism incorporates usage control only policies supported by the georbac model i.e.
location based anddynamic sodon conflicting roles areenforced.anauthorizationframeworkforenforcingtimebased policies based on the x gtrbac language and its model gtrbac has been proposed by bhatti et al.
.
policies writteninthex gtrbaclanguageareenforcedusingajava basedgui application.bendavidetal.
proposearun timeenforcement mechanism composed of a monitor and a change analyzer.
both the running system and the rbac policies are expressed using the models runtime paradigm as a running architecture model.
by observing the system behavior the monitor sends a notification tothechangeanalyzerwheneverachangeisdetected.uponthis notification thechangeanalyzerbuildsatargetarchitecturemodelthatwillbeusedtoevaluatetherbacpolicies.thisworkissimilartoourenforcementapproachastheybuildatargetmodeltoenforce therbacpolicies.however thisapproachwasnotimplemented and only assignment and activation relations are supported.
table3summarizes to which extent the policy enforcement approachesdiscussedabovesupportthevariousacrequests eventspresented in section .
as one can see the morro framework proposed in this paper is the only one that supports all of them.
in addition none of the approaches discussed above provides afullsupportforthecomprehensivesetofauthorizationpolicies captured by gemrbac ctx.
although some approches provide a prototype implementation of their enforcement mechanisms none of these implementationsare available for a performance comparison the only exceptionis the facpl framework that however supports a different ac model.
furthermore only few of the aforementioned approaches provide an empirical evaluation assessing the access decision time however we could not compare these approacheswith ours sincethe underlyingrbacmodels andthe application contexts are different.
while in this paper we have addressed the problem of enforcing acpolicies thereisaseriesofwork orthogonaltoours thatfocuses on testing and static verification of ac policies and in some cases theirimplementation usingvarious techniquessuch asmutation testing model based testing model checking sat solving theorem proving and static analysis .
conclusion and future work inthispaperwepresentedamodel drivenenforcementframework for policies defined on top of a comprehensive role based access control model gemrbac ctx which leverages the operationalizationoftheaccesscontrolpoliciesasoclconstraints.wereduce the problem of making an access decision to checking whethera system state from an rbac point of view expressed as an instance of the gemrbac ctx model satisfies the oclconstraints corresponding to the rbac policies to be enforced.
policies are enforced both when an ac request is made and when an ac event is triggered we provide the checking algorithms for both cases.
weimplemented the coreof ourenforcement framework ina tool calledmorroandprovidedanintegrationstrategyforatypical industrial web application following the guidelines of the xacml standard architecture.
the evaluation results show that morro canbe adoptedwithoutconsiderably impactingtheresponse time ofawebapplicationandthatmorroscaleslinearlywithrespecttothevariousparameterscharacterizinganacconfiguration.overall theresultsconfirmthefeasibilityofusingamodel drivenapproach to efficiently enforce complex rbac policies.
althoughweconsideredthegemrbac ctxmodelintheapplicationofourapproach thelatterisgenericanddoesnotdependon gemrbac ctx it can be applied to any other ac model that can be expressed in uml and whose policies can be expressed in ocl.
as part of future work we plan to assess the end to end performance of a system integrating morro under different evaluation settings such as a production configuration deployed on an elastic cloud infrastructure.
we also plan to optimize morro in termsof time efficiency by adopting cache based enforcement and in terms of space efficiency by adopting the kevoree modeling framework kmf which is optimized for manipulating models at run time on large distributed systems.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
model driven run time enforcement of complex rbac policies ase september montpellier france