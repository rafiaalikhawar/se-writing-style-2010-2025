an unsupervised approach for discovering relevant tutorial fragments for apis he jiang1 jingxuan zhang1 zhilei ren1 tao zhang4 jianghe dlut.edu.cn jingxuanzhang mail.dlut.edu.cn zren dlut.edu.cn cstzhang hrbeu.edu.cn 1school of software dalian univ ersity of technology dalian china 2key laboratory for ubiquitous network and service software of liaoning province dalian china 3state key laboratory of software enginee ring wuhan university wuhan china 4college of computer science and technology ha rbin engineering university harbin china abstract developers inc reasingly rely on api tutorials to facilitate software development.
however it remains a challenging task for them to discover relevant api tutorial fragments explaining unfamiliar apis.
existing supervised approaches suffer from the heavy burden of manually preparing corpus specific annotated data and features.
in this study we propose a novel unsupervised approach namely fragment recommender for apis with pagerank and topic model frapt .
frap t can well address two main challenges lying in the task and effectively determine relevant tutorial fragments for apis.
in frapt a fragment parser is proposed to identify apis in tutorial fragments and replace ambiguous pronouns and variables with related ontologies and api names so as to address the pronoun and variable resolution challenge.
then a fragment filter employs a set of nonexplanatory detection rules to remove non explanatory fragments thus address the non explanatory fragment identification challenge.
finally two correlation scores are achieved and aggregated to determine relevant fragments for apis by applying both topic model and pagerank algorithm to the retained fragments.
extensive experiments over two publicly open tutorial corpora show that frapt improves the state of the art approach by .
and .
respectively in terms of f measure .
the effectiveness of key components of frapt is also validated.
keywords application programming interface pagerank algorithm topic model unsupervised approaches i. introduction reusing application progr amming interfaces apis in existing libraries and fram eworks could greatly speed up software development process .
hence it is critical for developers to search and use apis properly .
as one of the most important api documenta tions api tutorials are often consulted by developers to learn how to use apis in a given programming context .
however api tutorials are usually lengthy and mixed with irrelevant information so it is tedious for developers to peruse a full tutorial for an unfamiliar api .
one feasible solution is to split tutorials into consecutive fragments and recommend relevant fragments containing ex planation information to developers .
hereafter if a fragment explains an api then they are relevant.
otherwise they are irrelevant.
in recent years three approaches have been proposed to resolve the task of discovering relevant tutorial fragments for apis in the literature namely fitsea gmr and ir .
among these approaches fitsea and gmr are supervised approaches and dramatically outperform ir.
there are two stages in these supervised approaches namely training and test.
in the trainin g stage tutorials are split into fragments and apis are manually labeled as relevant or irrelevant to their fragments.
the labeled apis and their fragments form a series of fragment api pairs.
some predefined features are extracted from each fragment api pair.
these extracted features with their class labels relevant or irrelevant are taken to train a classifier.
in the test stage the trained classifier is used to predict the class labels of new fragment api pairs.
however there are some drawbacks in these supervised approaches due to the heavy burden of manual annotation efforts and feature construction.
g122 different corpora require their corpus specific annotated data thus cost a lo t of manual efforts.
supervised approaches may easily lead to the bias between training and test especially when conducting cross corpus prediction .
g122 the effectiveness of supervised approaches largely depends on the features to capture the specific characteristics of corpora.
when applying the constructed features on different corpora cl assifiers may behave well on some corpora while poorly on the others .
the above drawbacks in supervised approaches motivate us to propose an unsupervised approach which possesses several advantages compared to supervised approaches .
first there is no need to annotate corpus specific data and train a classifier so that it costs far less manual efforts and avoids the bias between training and test.
second unsupervised approaches can adapt to different corpora by adjusting some parameters instead of constructing features.
in this study we propose a novel unsupervised approach namely fragment recommender for apis with pagerank and topic model frapt .
frapt can find the relevance between fragments and apis effectively and recommend relevant fragments for apis to de velopers automatically.
in frapt all fragments are taken into a fragment parser to identify apis replace ambiguous pronouns and variables with related ontologies and api names and find sentence boundaries and their types after tutorial segmentation.
then a fragment filter is introduced to filter out non explanatory fragments which do not explain any apis.
next both topic model and pagerank algorithm are applied to each retained ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fragment to achieve two typ es of correlation sco res between fragments and apis.
by aggregating the correlation scores relevant fragments for apis can be identified and recommended for developers.
to evaluate the effectiveness of frapt and validate the impacts of its key component s we conduct extensive experiments on all publicly available annotated tutorial corpora namely mcgill corpus and and roid corpus .
frapt improves the state of the art approach fitsea by .
and .
respectively in terms of f measure .
in addition the key components of frapt also exhibit their effectiveness.
for example by aggregating the correlation scores from both topic m odel and pagerank algorithm better f measure can be achieved and improve any of them by up to .
and .
over the two tutorial corpora.
the main contributions of this study are listed as follows a fragment filter with a set of non explanatory detection rules is proposed to remove non explanatory fragments effectively.
we propose a new unsupervised approach frapt leveraging topic model and pa gerank algorithm to discover relevant fragments for apis.
frapt is publicly available at e jxzhang frapt .
a series of experiments are cond ucted to validate the effectiveness of frapt and its components.
the results demonstrate that frapt significantly improves the state ofthe art supervised approach.
ii.
motivation examples in this section we discuss the main challenges lying in the task of discovering relevant fragments for apis.
apis can be explained at different levels by tutorials ranging from package level class or interface level to method level.
in order to facilitate comparison of different approaches similar as apis are chosen at class or interface level in this study.
on one hand when facing an unfamiliar api developers usually want to know how to use some available behaviors rather only one method .
on the other hand tutorials usually introduce some programming topics by using a set of methods of classes .
as a result apis are selected at class or interface level in this study.
fig.
shows two fragment examples.
fragment a and fragment b are extracted from the jodatime tutorial and the android graphics tutorial respectively.
fragment a has three paragraphs with four apis namely datetime interval duration and period .
however fragment a is irrelevant to any of them according to the manual annotation .
in co ntrast there are two paragraphs with a piece of code example in fragment b. four apis are detected namely canvas bitmap surfaceholder and surfaceview .
according to the manual annotation canvas and bitmap are relevant to this fragment whereas surfaceholder and surfaceview are not.
based on the above tutorial fragments we find that two challenges need to be addressed for effectively discovering relevant tutorial fragments for apis.
g122 pronoun and variable resolution pronouns and variables are widely used in api tutorials.
these pronouns and variables may be ambiguous if we do not consider their surroundi ng sentences or programming context.
we observe that about fragments contain at least one pronoun and fragments with code examples declare variables in the open tutorial corpora .
the influences of apis will be w eakened if the on tologies of these pronouns and variables are apis.
taking fragment b from the graphics tutorial in fig.
as an example if we only consider the third sentence it holds all of your draw calls the ontology of it is ambiguous.
with the help of its context we can infer that it stands for the api canvas .
in contrast the second statement in code example in fragment b declares a canvas variable c with b as a parameter.
by inspecting its programming context we can infer that b stands for the api bitmap .
g122 non explanatory fragment identification not all the fragments are designed to e xplain apis.
nonexplanatory fragments do not explain any apis accordingly an explanatory fragment explains at least one api .
as to an investigation on the tutorial co rpora used in this study we find that fragments are annotated as nonexplanatory fragments.
for example fragment a belongs to non explanatory fragments since all of its apis appear in an enumeration sentence and fragment a just gives an overview of the whole jodatime tutorial .
in the following part of this paper we present how our new approach frapt addresses the above challenges and explain its workflow with fragment a and fragment b. iii.
framework of frapt the whole framework of frapt consists of two phases namely the relevance discovery phase and the fragment recommendation phase see fig.
.
relevance discovery phase.
t h i s p h a s e a i m s t o f i n d the relevance between fragments and apis.
frapt first jodatime is like an iceberg 10ths of it is invisible to user code.
many perhaps most applications will never need to see what s below the surface.
this document provides an introduction to the jodatime api for the average user not for the would be api developer.
the bulk of the text is devoted to code snippets that display the most common usage scenarios in which the library classes are used.
in particular we cover the usage of the key datetime interval duration and period classes.
we finish with a look at the important topic of formatting and parsing and a few more advanced topics.
when you re writing an application in which you would like to perform specialized drawing and or control the animation of graphics you should do so by drawing through a canvas .
a canvas works for you as a pretense or interface to the actual surface upon which your graphics will be drawn.
it holds all of your draw calls.
via the canvas your drawing is actually performed upon an underlying bitmap which is placed into the window.
in the event that you re drawing within the ondraw callback method the canvas is provided for you and you need only place your drawing calls upon it.
you can also acquire a canvas from surfaceholder .lockcanvas when dealing with a surfaceview object both of these scenarios are discussed in the following sections .
however if you need to create a new canvas then you must define the bitmap upon which drawing will actually be performed.
the bitmap is always required for a canvas .
you can set up a new canvas like this bitmap b bitmap .createbitmap bitmap .config .argb 8888 canvas c new canvas b b fragment b figure .
fragment examples a fragment a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
segments tutorials into coherent fragments by a tutorial segmentation component and inputs the fragments into a fragment parser to detect apis resolve pronouns in sentences and variables in code examples to address the pronoun and vari able resolution challenge and identify sentences with their types.
then the parsed fragments are taken into a fragme nt filter to detect and filter out nonexplanatory fragments so as to address the non explanatory fragment identification challenge.
next on one hand the fragments are taken into a t opic model to find semantic connections between fragments and apis.
based on the fragment topic matrix and the t opic term matrix obtained from the topic model a type of correlation scores between fragments and apis can be achie ved.
on the other hand pagerank algorithm is applied to the graph constructed by sentences in fragments and anot her type of correlation scores between fragments and apis can also be achieved according to the pagerank values of sentences containing apis.
last a relevance identification scheme is designed to decide the relevance between fragments and apis.
fragment recommendation phase.
the goal of this phase is to recommend relevant fragments for the unfamiliar apis queried by developers.
when a developer wants to use an unfamiliar api to accomplish some programming tasks he she inputs the unfamiliar api into frapt.
frapt looks up the relevance between fragment s and apis obtained from the first phase and recommends relevant tutorial fragments to the developers.
iv.
main components of frapt a. tutorial segmentation tutorial segmentation follows the same method as to divide tutorials into c oherent fragments.
first we split tutorials into a series of parag raphs.
then we iteratively merge sibling paragraphs until the length of the paragraphs reaches within a specified range words to words .
in such a way the tutorial fragments can be achieved for each tutorial.
b. fragment parser fragment parser conducts four steps to parse a fragment namely api discovery pronoun and variable resolution sentence identification and sentence type identification.
api discovery first of all we detect all the apis contained in each fragment.
all the open tutorials are available on the internet in the form of html.
alth ough apis in different tutorials have different styles most of tutorials follow w3c guidelines and link apis to their corresponding specification webpages with href tags.
by parsing the linked webpages and matching api names with the anchor text we can decide whether a link is an api or not.
some tutorials do not li nk apis to their specification webpages.
in this situation we tokenize the tutorials into a stream of tokens and matc h these tokens with all the available api names.
the same as if a token matches an api name lexically we continue to search its context a sequence of tokens surround th is token with a window size of to find whether it contains some keywords such as class interface and api .
if yes it is treated as an api.
with api discovery four apis are detected for each fragment in fig.
.
datetime interval duration and period are discovered in fragment a. canvas bitmap surfaceholder and surfaceview are detected in fragment b. pronoun and variable resolution to address the pronoun and variable resolution challenge pronoun and variable resolution identifies ontologies for pronouns and apis for variables and replaces pronouns and variables with their ontologies and apis.
in frapt reconcile an automatic coreference resolution tool is leveraged to perform pronoun resolution thus we can obtain mappings between pronouns and their ontologies.
we replace all the pronouns with their ontologies for all the sentences.
in contrast if a variable is declared in a piece of code example and some operations are performed on the variable in the following statements the variable is used to call its methods rather than its api especially in objectoriented programming languages.
we inspect each statement in the code examples and build a mapping between each variable and its api.
then we replace all the variables with their apis for each statement.
in such a way the impacts of apis are enhanced.
taking fragment b as an example the third sentence it holds all of your draw calls.
in the first paragraph starts with a pronoun namely it .
by analyzing the context of this sentence reconcile finds that it stands for the api canvas .
as a result we replace it with canvas so that the api canvas is enhanced.
there are two code statements in this fragment.
the first statement creates a bitmap variable b and the second statement declares a canvas variable c using b as a parameter.
by analyzing the statements we can create two mappings namely b bitmap and c canvas .
variable b appears in the second statement and we replace it with its api namely bitmap .
as a result the two statements are changed to bitmap b bitmap .createbitmap bitmap .config .argb 8888 canvas c new canvas bitmap tutorials tutorial segmentation pagerank based correlation score calculation relevance between fragments and apis topic based correlation score calculation relevance identification topic based scores pagerank based scores unfamiliar apis relevant fragments for unfamiliar apis relevance discovery phase retained fragments fragments figure .
workflow of frapt fragment filter fragment parser parsed fragments fragment recommendation phase frapt api discovery pronoun variable resolution sentence identification sentence type identification relevant fragment recommender authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sentence identification tutorials usually contain not only api explanations but also code examples to show how apis are used in specific situations.
to obtain each sentence we delete all the html tags in fragments.
an open tool namely lingpipe is leveraged to detect the sentence bo undaries so that the sentences are identified.
we treat each statement in code examples as one sentence.
we can obtain statements by splitting at the places of semicolons.
however there are some exceptions e.g.
if and for statements.
for the exceptions we can split code at this place where there is a match between left parent hesis and right parenthesis.
we identify and sentences for fragment a and fragment b respectively and mark each sentence with a sentence id see fig.
.
sentence type identification different types of sentences have different contributions to explain apis.
to differentiate the importance of each sentence we define two sentence types i.e.
marginal sentences and principal sentences.
marginal sentences include conditional sent ences enumeration sentences example sentences comparative sentences and code comments.
principal sentences are the other sentences except the above sentences.
intuitively principal sentences are more important than marginal sentences.
marginal sentences can be detected by keyword matchi ng in the following ways g122 conditional sentences can be fou nd by keywords of if and whether .
g122 enumeration sentences can be detected when more than two apis are listed and connected by and or or .
g122 example sentences can be detected by some keywords e.g.
for example for instance and such as .
g122 comparative sentences can be detected by keywords such as compared to unlike... and more...than... .
in this study inheritance describing sentences are also treated as comparative sentences which can be found by keywords e.g.
extend inherited from and subtype of .
g122 code com ments start with the string of etc.
the fifth sentence in fragment a is an enumeration sentence and the seventh sentence in fragment b is a conditional sentence.
as a result they are marginal sentences.
the other se ntences can be viewed as principal sentences.
c. fragment filter fragment filter aims to filter out those non explanatory fragments which do not expla in any apis by some nonexplanatory detection rul es.
we first specify how we perform an in depth ob servation to identify these non explanatory detection rules.
then we sho w the details of the rules.
non explanatory detection rules identification there are three steps to identify non explanatory detection rules namely non explanatory fragment identification characteris tics formulation and nonexplanatory detection rules generation.
non explanatory fragment identification.
we select the essential java classes tutorials as the representative tutorials to observe since they introduce basic java classes e.g.
exception handing and i o processing and do not overlap with the two tutorial corp ora used in this study .
therefore the identified non explanatory detection rules can be applied to the tu torial corpora in this study without introducing a sampling bias into the results.
we segment the essential java classes tutorials into fragments by the tutorial segmentation component and evenly distribute these fragments to the second and the third author of this study to check.
they are required to analyze and understand these fragments to select the non explanatory fragments.
characteristics formulation.
for each identified nonexplanatory fragment the two authors investigate what are the characteristics that lead this fragment to be a nonexplanatory fragment.
to find the answer the authors measure different characteristics for each non explanatory fragment and check if one or some of them could answer this question e.g.
the number of sentences and the number of contained apis.
if they convince that one or some characteristics of a fragment make it to be a non explanatory fragment they formulate a new characteristic or merge it to an existing one.
finally the authors achieve two sets of formulated characteristics.
non explanatory detection rules generation.
the two authors check the two formulated characteristic sets to find the common characteristics appearing in both two sets.
interrater kappa agreement is applied to evaluate the two formulated characteristic sets .
the kappa agreement is .
showing a moderate agreement.
then they decide the most suitable threshold for each common characteristic found by two authors simultaneously.
for example how many sentences can differentiate non explanatory fragments from explanatory fragments .
in such a way through successive iterations of discussion and coordination they find some characteristics that could well detect the boundary between non explanatory fragments and explanatory fragments.
these characteristics with th eir thresholds are transformed to some non expl anatory detection rules.
non explanatory detection rules after the non explanatory detection rules identification we find that non explanatory fragments comp ly with at least one of the following characteristics rules g122 non explanatory fragments usually contain only one api and this api appears only once.
the more times an api appears in a fragment the more chances the fragment is relevant to this api.
the fragment pays less attention on api explan ation if there is only one api.
g122 the lengths of non explanatory fragments are usually less than five sentences.
in such a short fragment an api cannot be fully explained considering that most of apis may contain more than one method so as to have sophisticated behaviors.
g122 the proportion of sentences containing apis is less than in non explanatory fragments.
it is hard to explain any api in such a small proportion of sentences containing apis.
g122 all the apis in non explanatory fragments only appear in m arginal sentences.
in this situation apis are only used to be listed as examples or enumeration.
in the other principal sentences the fragments focus on other information rather than apis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i. api probabilities assigned to each topic term api topic topic topic topic topic ... canvas .
.
.
.
.
... bitmap .
.
.
.
.
... surfaceholder .
.
.
.
.
... surfaceview .
.
.
.
.
... g122 non explanatory fragments have some good indicator terms and phrases.
some keywords and phrases can give important clues and act as good indicators for fin ding non explan atory fragments e.g.
summary overview introduction for more information about ... see ... and more details in ... .
based on these characteristics we construct a fragment filter with five non exp lanatory detection rules to identify non explanatory fragments.
if one fragment conforms to any of these rules it is marked as a non explanatory fragment to be filtered out.
in fragment a all the apis appear in an enumeration sentence so it follows the fourth rule.
as a result fragment a is detected as a non explanatory fragment and filtered out.
in contrast fragment b is inconsistent with none of these rules and requires further processing.
d. topic based correlation score calculation topic based correlation score cal culation aims to achieve a correlation score between fragments and apis according to the results of topic model.
as a popular way to analyze a large scale of documents topic model can be used to find semantic relationships between documents and terms .
as a result each document is expressed by a series of topics with different probabilitie s. in contrast a topic is represented by a collection of terms with various probabilities.
in this study one typ e of topic model namely latent dirichlet allocation lda is leveraged and stanford topic modeling toolbox is introduced to help us to perform lda.
we introduce the same method as to obtain the best configurations i.e.
the topic number for lda.
each tutorial fragment is treated as a document to put into lda and lda outputs the topic probability distributions for each fragment as well as the term probability distributions for each topic.
here the terms include not only pure text but also apis.
since we intend to investigate the correlation scores between fragments and apis only the api probability distri butions for all the topics are used in the following part.
based on the output of lda we can obtain a correlation score between fragments and apis by the following formula score g3021 api fragment g3 g3 g963 p g3 g4666api t g4667 p g3 t fragment t topic g3 g3 g3 g3 g3 where p api t is the api probability for topic t and p t fragment is the probab ility of topic t for the fragment.
taking fragment b as an example the fragment can be represented by five topics with non zero probabilities namely .
.
.
.
.
.
table i shows the api probability distributions on the five topics.
following the formula the score t values for canvas bitmap surfaceholder and surfaceview with fragment b are .
.
.
and .
respectively.
e. pagerank based correlation score calculation this component aims to obtai n another correlation score between fragments and apis based on the pagerank value of each sentence.
pagerank algorithm attempts to evaluate the importance of each sentence through link analysis .
first of all we create a directed graph based on the sentences in a fragment and each vertice in the graph stands for a sentence.
to build directed edges between vertices we calculate the widely used cosine similarity with tf idf term weight between sentences .
if the similarity is not zero between two sentences we draw two directed edges toward each other between their corresponding vertices.
in such a way we can build a directed graph.
after pagerank algorithm is applied to the directed graph we can obtain the pagerank value for each sentence.
different sentences have different contributions to explain apis.
the greater the pagerank value of a sentence the more closely it catches the central meaning of the fragment.
if an api appears in sentences with greater pagerank values then it is more likely to be explained by this fragment.
a scheme is designed to obtain correlation scores between fragments and apis as follows score g3017 g3019 g4666 g4 g19 g12 g481 g3 fragment g4667 g3 g3 g963 pr g3 s g3 g3p g3 api g3 g513 g3 g149 s fragment g963 pr g3 s s fragment where s stands for a sentence in the fragment pr s means the pagerank value of sentence s and p g3 api g3 g513 g3 g149 g4676 g31 if s contains api if s does not contain api table ii shows the matrix representation of the directed graph with pagerank values listed in the last line for fragment b. the ids are their corresponding sentence id and the values in the table show the similarities between the corresponding sentences.
the pagerank values range from .
to .
for each sentence.
the api canvas appears in ten sentences.
note that canvas has already replaced it in the sentence it holds all of your draw calls.
after pronoun resolution.
the score pr between canvas and fragment b is .
according to the formula .
bitmap appears five times since the variable b in the last statement has been replaced by bitmap .
as a result the score pr between bitmap and fragment b is .
.
in the same way the score pr values for surfaceholder and surfaceview with fragment b are all .
.
table ii.
similarity matrix of directed graph for fragment b id .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pr .
.
.
.
.
.
.
.
.
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
f. relevance identification we design a relevance identification scheme to detect the relevance between fragments and apis.
in this study we in troduce a threshold t for each tutorial as one of the inputs of relevance identification scheme which is used by all the fragme nts in the tutorial to compare with the two correlation scor es to decide the relevance between fragments and apis.
in the experimental results section see vi.a we will dem onstrate how the threshold t influences the results and how to find a good value of it automatically.
table iii shows the relevance identification scheme.
for each api in a fragment we normalize the two correlation scores between this api and its fragment namely each score is divided by the maximum score of the same type of scores in this fragment resp ectively.
then we check whether all the types of sentences containing this api are marginal sentences.
if yes then we treat that this api only appear in less important sentences and m ark it as irrelevant to this fragment.
if the two normalized correlation scores between this api and its fragment namely score t and score pr exceed the threshold t at the same time then the api is identified as relevant to the fragment.
otherwise the api is identified as irrelevant to this fragment.
with such a scheme we can find the relevance between fragments and apis.
still taking fragment b as an example score t and score pr values for canvas bitmap surfaceholder and surfaceview with fragment b are .
.
.
and .
.
.
respectively after normalization.
none of these apis only appear in marginal sentences so they need further processing.
if the threshold t is set to .
we can find that both score t and score pr of canvas and bitmap with fragment b are greater than the threshold t simultaneously.
hence they are marked as relevant to fragment b. neither score t nor score pr of surfaceholder and surfaceview with fragment b exceed the threshold t so they are marked as irrelevant to fragment b. in summary with frapt fragment a is marked as a non explanatory fragment and filtered out.
canvas and bitmap are relevant to fragment b whereas surfaceholder and surfaceview are not.
g. relevant fragment recommender in the fragment recommendation phase relevant fragment recommender recommends relevant fragments for unfamiliar apis queried by developers by looking up the detected relevance between fragments and apis.
for example if a developer inputs an unfamiliar api canvas to frapt.
the recommender finds that fragment b is relevant to canvas and recommends fragment b to the developer.
v. experimental setup a. tutorial corpora in the previous studies two publicly open tutorials are constructed shown in table iv which shows the number of apis and fragments rather than fragment api pairs.
mcgill corpus consists of five tutorials and android corpus is composed of four tutorials.
these corpora have been manually annotated into relevant and irrelevant fragments with their contained apis.
b. baseline approaches ir approach ir approach uses an information retrieval method to find relevant fragments for apis .
cosin e similarities with tfidf term weight are calculated between fragments and api specifications.
a fragment is treated as relevant to an api if their cosine similarity is high er than a th reshold.
the threshold in each tutorial is defined as follows first the k most similar fragments are achieved by calculating cosine similarities for each api where k is the number of relevant fragments for this api based on the annotation.
then the average of all k th fragments similarities for all the apis is used as the threshold.
gmr approach gmr approach is the sem inal work to find relevant fragments for apis .
before extracting features some text transformation operations are conducted e.g.
sentence identification and part of speech tagging.
twenty features are defined to measure linguistic and structural characteristics between fragments and apis.
a maxent classifier is trained to determine relevant fragments for apis.
fitsea approach fitsea approach is the state of the art method to find relevant fragments for apis .
it introduces some new sources to extend apis to overcome the information mismatch between fragments and apis.
besides co table iii.
r elevance identification scheme input sentence types score t and score pr values between apis and their fragment f threshold t output the relevance between fragments and apis for each api a in f normalize score t a f and score pr a f find all sentences containing a if types of these sentences are all marginal sentences a is irrelevant to f else if normalized score t a f t normalized score pr a f t a is relevant to f else a is irrelevant to f table iv.
d etails of the tutorial corpora corpus tutorial apiexplanatory fragment nonexplanatory fragment fragment with codefragment without code mcgill corpus jodatime math library col. official col. jenkov smack android corpus graphics resources data text authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
occurrence apis are proposed to act as good indicators to improve the results.
c. evaluation meth ods and metrics supervised approaches can be eval uated by the widely used ten fold cross validation tfcv to measure how accurately an approach performs .
we employ tfcv rather than leave one out cross validation loocv in since the fundamental unit is th e fragment api pair in loocv and a fragment containing multiple apis is simultaneously put into both the training set and the test set which is far away from real applications.
in tfcv we treat fragments as fundamental units to partition a tutorial into subsets of equal size after identifying apis and generating fragment api pairs.
among the subsets one subset is used as the test set and the other subsets are used as the training set.
after all the subsets are used once as the test set when cross validation is repeated times the results are averaged to evaluate the performance of the approach.
in contrast unsupervised approaches frapt and ir can determine the relevance between fragments and apis without the overhead of traini ng.
given a tutorial fragment or an api unsupervised approaches can discover its relevant apis or fragments using their designed frameworks.
in this study we introduce precision recall and fmeasure to evaluate the performance of each approach.
these metrics are employed by ir gmr and fitsea in as evaluation metrics.
precision measures how accurate the results of experiments are.
recall indicates the coverage of the results.
f measure balances precision and recall since there is a tradeoff between them.
there are four kinds of results obtained from the experiments namely tru e positive tp false negative fn true negative tn and false positive fp .
tps indicate the results which correctly predict relevant fragment api pairs as relevant .
fns indicate the results which incorrectly predict relevan t fragment api pairs as irrelevant.
tns and fps indicate the results which predict irrelevant fragment api pairs as irrel evant and relevant respectively.
precision recall and f measure can be calculated as follows precision g3 g3 g851tp g851tp g3 g3 g851fp g3400 g883 g882 g882 g936 recall g3 g3 g851tp g851tp g3 g3 g851fn g3400 g883 g882 g882 g936 f measure g3 g32 g3 g3precision g3 g3recall precision g3 g3recall g3400 g883 g882 g882 g936 vi.
experimental results in this section we investigate five research questions rqs to evaluate different aspects of frapt.
a. investigation to rq1 rq1 how does the threshold t influence the performance of frapt?
motivation.
the threshold t plays an important role to determine the relevance between fragments and apis in the relevance identification component see iv.f .
we try to explore how the threshold t influences the results and decide a good value t0 for t in this rq.
figure .
results of rrapt on jodatime tutorial figure .
results of frapt on graphics tutorial approach.
we select one tutorial from the two tutorial corpora respectively as cases to investigate this rq namely the jodatime tutorial in mcg ill corpus and the graphics tutorial in android corpus.
we adjust t from to with a step size of .
in the selected tutorials to obtain the results.
given a tutorial we try to find a good tutorial specific value threshold t0.
by comparing the values of precision recall and f measure we can validate whether t0 is close the optimal value.
t0 is derived from the percentage of sentences containing apis and their methods in the whole tutorial.
this scheme is design ed by the observation intuitively more sentences in a fragment contain apis and their methods more chances the fragment is relevant to apis.
hence t can be calculated as follows g1846 g2868 g883 g3 g486 g3 sentences g139 g144 g3 g131 g3 g150 g151 g150 g145 g148 g139 g131 g142 g3 containing apis and their method g149 all the sentences g3 g139 g144 g3 g131 g3 g150 g151 g150 g145 g148 g139 g131 g142 result.
fig.
and fig.
show the precision recall and f measure against t for the two selected tutorials.
we can see that with the growth of t the curves of precision show upward trends in both tutorials.
for example when t is set to frapt achieves a precision of .
in the jodatime tutorial.
when t comes to the precision rises to .
.
on the contrary the curves of recall show downward trends in both tutorials.
here the recall cannot achieve when t is set to since some e xplanatory fragments are filtered out as non explanatory fragments in the fragment filter component.
for example in the graphics tutorial frapt achieves a recall of .
when t set to is and it drops to .
when t is set to .
compared to precision and recall the curves of f measure are relatively stable.
the black vertical lines in fig.
and fig.
show t calculated by the formula in the two tutorials namely .
and .
respectively.
we can see that the values of fmeasure almost approximate the best values using t in the jodatime tutorial and the graphics tutorial.
even though frapt does not achieve the best f measure the gap is trivial.
for instance frapt achieves the f measure of .
in the graphics tutorial which is lower than the best value only by .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.00the jodatime tutorial precision recall f measure .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.00the graphics tutorial precision recall f measure authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v. d etailed results of different approaches corpus tutorial precision recall f measure frapt fitsea gmr ir frapt fitsea gmr ir frapt fitsea gmr ir mcgill corpus jodatime .
.
.
.
.
.
.
.
.
.
.
.
math library .
.
.
.
.
.
.
.
.
.
.
.
col. official .
.
.
.
.
.
.
.
.
.
.
.
col. jenkov .
.
.
.
.
.
.
.
.
.
.
.
smack .
.
.
.
.
.
.
.
.
.
.
.
android corpus graphics .
.
.
.
.
.
.
.
.
.
.
.
resources .
.
.
.
.
.
.
.
.
.
.
.
data .
.
.
.
.
.
.
.
.
.
.
.
text .
.
.
.
.
.
.
.
.
.
.
.
figure .
average results of each approach conclusion.
the threshold t may influence the performance of frapt.
the tutorial specific threshold t0 is close to the optimal value.
in th e following rqs we use the threshold t0 for each tutorial to conduct all the experiments.
b. investigation to rq2 rq2 to what extent is frapt superior to the three baseline approaches over the two tutorial corpora?
motivation.
in this rq we want to examine whether our unsupervised approach frapt can be superior to the existing approaches over the two tutorial corpora.
approach.
frapt and the three baseline approaches are implemented and tested over th e two tutorial corpora to compare the results.
results.
table v shows the detailed values of precision recall and f measure for each approach over the two tutorial corpora.
we can see that different approaches behave differently over the two corpora.
frapt shows the best recall and f measure in almost al l tutorials.
for example frapt gets the best precision of .
among all the approaches in the jodatime tuto rial in mcgill corpus.
at the same time it also achieves the best recall and fmeasure .
and .
respectively .
the average values of these evaluation metrics are presented in fig.
.
we can see that frapt achieves the best results in all the conditions among all the approaches.
for example the average precision recall and f measure of frapt are .
.
and .
respectively on mcgill corpus whereas the other approaches are all below for the f measure .
frapt improves the state of theart approach fitsea by .
and .
on average over the two corpora in terms of f measure .
when comparing different supervis ed approaches fitsea achieves better results than gmr e.g.
f measure of fitsea is .
over mcgill corpus whereas gmr only achieves .
.
table vi.
r esults of fragment filter mcgill corpus android corpus true irrelevant false irrelevant true irrelevant false irrelevant figure .
average results of frapt and frapt filter conclusion.
as an unsupervised approach frapt can achieve better results than the state of the art supervised approach verified by tfcv.
considering the advantages of unsupervised approaches it is a better choice to use frapt for discovering relevant tutorial fragments for apis.
c. investigation to rq3 rq3 what is the impact of fragment filter on detecting non explanatory fragments and improving results of frapt?
motivation.
we build a fragmen t filter to detect and filter out non explanatory fragments see iv.c to address the non explanatory fragment identification challenge.
we try to explore its impact on frapt in this rq.
approach.
there are two types of results namely true non explanatories and false non explanatories.
true nonexplanatories are the results in which non explanatory precision recall f measure precision recall f measure mcgill corpus android corpus frapt .
.
.
.
.
.
fitsea .
.
.
.
.
.
gmr .
.
.
.
.
.
ir .
.
.
.
.
.
approach comparison precision recall f measure precision recall f measure mcgill corpus android corpus frapt .
.
.
.
.
.
frapt filter .
.
.
.
.
.
results of frapt and frapt filtertable vii.
detailed results of frapt and frapt f ilter corpus tutorial precision recall f measure frapt fraptfilter frapt fraptfilter frapt fraptfilter mcgill corpus jodatime .
.
.
.
.
.
math library .
.
.
.
.
.
col. official .
.
.
.
.
.
col. jenkov .
.
.
.
.
.
smack .
.
.
.
.
.
android corpus graphics .
.
.
.
.
.
resources .
.
.
.
.
.
data .
.
.
.
.
.
text .
.
.
.
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table viii.
d etailed results of frapt and frapt p rons res corpus tutorial precision recall f measure frapt fraptpronsres frapt fraptpronsres frapt fraptpronsres mcgill corpus jodatime .
.
.
.
.
.
math library .
.
.
.
.
.
col. official .
.
.
.
.
.
col. jenkov .
.
.
.
.
.
smack .
.
.
.
.
.
android corpus graphics .
.
.
.
.
.
resources .
.
.
.
.
.
date .
.
.
.
.
.
text .
.
.
.
.
.
figure .
average results of frapt and frapt pronsres fragments are correctly marked as non explanatory while false non explanatories are the results in which explanatory fragments are incorrectly marked as non explanatory.
after applying fragment filter we count the number of true nonexplanatories and false non ex planatories to show the effectiveness of fragment filter.
we also compare frapt against a variant of frapt namely frapt filter which re moves fragment filter and keeps the other components the same.
by comparing frapt against frapt filter the impact of fragment filter can be further shown.
results.
as shown in table vi fragment filter correctly marks and true non expla natories for mcgill corpus and android corpus and incorrec tly marks false nonexplanatories respectively.
fragmen t filter can detect a great number of non explanatory fragments accurately and only falsely filter out a fraction of explanatory fragments.
table vii and fig.
show the detailed and average results of frapt against frapt filter.
we can see from table vii that fragment filter can largely improve precision and f measure .
for instance frapt obtains f measure of .
in the jodatime tutorial whereas frapt filter only achieves .
.
as shown in fig.
introducing fragment filter will effectively improve precision and f measure .
for example frapt achieves an average f measure of .
on mcgill corpus wh ereas frapt filter only achieves .
in the same situation.
we can also find similar phenomenon on android corpus.
frapt filter can achieve better recall on average whereas it shows far worse precision and f measure .
overall frapt balances precision and recall and shows better results.
conclusion.
fragment filter can detect a great number of non explanatory fragments at the cost of a small fraction of explanatory fragments.
it can balance precision and recall effectively thus improve the results of frapt.
table ix.
d etailed results of frapt and its variants corpus tutorial precision recall f measure fraptfrapttopic fraptpr frapt frapttopic fraptpr fraptfrapttopic fraptpr mcgill corpusjodatime .
.
.
.
.
.
.
.
.
math library .
.
.
.
.
.
.
.
.
col. official .
.
.
.
.
.
.
.
.
col. jenkov .
.
.
.
.
.
.
.
.
smack .
.
.
.
.
.
.
.
.
android corpusgraphics .
.
.
.
.
.
.
.
.
resources .
.
.
.
.
.
.
.
.
data .
.
.
.
.
.
.
.
.
text .
.
.
.
.
.
.
.
.
figure .
average results of frapt and its variants d. investigation to rq4 rq4 how does pronoun and variable resolution impact on the performance of frapt?
motivation.
we perform pronoun and variable resolution for each fragment in fragment parser to address the pronoun and variable resolution challenge.
to test wh ether resolution is effective we set up this rq.
approach.
we define a variant of frapt namely frapt pronsres which deletes the subcomponent of pronoun and variabl e resolution from frapt.
we compare the results of frapt against frapt pronsres to show the impact of pronoun and variable resolution in this rq.
results.
table viii and fig.
show the detailed results and average results of frapt and frapt pronsres respectively.
we can see from table viii that applying pronoun and variable resolution can impr ove the results.
for example frapt improves f measure by .
in the text tutorial of android corpus.
we can see from fig.
that the average f measures of frapt pronsres over the two tutorial corpora are .
and .
and frapt improves it by .
and .
respectively.
we find that using prono un and variable resolution achieves different improvements in distinct tutorial corpora.
there are two potential reasons lead ing to this phenomenon.
first different tutorials ma y contain different numbers of pronouns and variables hence different improvements are achieved.
second pronoun and variable resolution will enhance the influence of relevant apis.
at the same time the influence of irrelevant apis may also be strengthened.
conclusion.
pronoun and variable resolution is an effective text transformation operati on to improve the results.
e. investigation to rq5 rq5 does frapt achieve better results by aggregating topic model and pagerank algorithm than by any of them alone?
precision recall f measure precision recall f measure mcgill corpus android corpus frapt .
.
.
.
.
.
frapt pronsres .
.
.
.
.
.
results of frapt and frapt pronsres precision recall f measure precision recall f measure mcgill corpus android corpus frapt .
.
.
.
.
.
frapt topic .
.
.
.
.
.
frapt pr .
.
.
.
.
.
results of frapt and variants without topic and pr authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
motivation.
frapt finds relevant fragments for apis by aggregating both topic model and pagerank algorithm.
to explore whether leveraging bot h of them can improve the results of frapt than any of them alone we set up this rq.
approach.
in the same way as the previous rqs we set up two variants of frapt.
the first one is frapt topic which only considers the co rrelation scores from pagerank algorithm.
the second variant is frapt pr which only takes the correlation scores from topic model into account.
results.
table ix shows the values of precision recall and f measure over the two tutorial corpora.
we can see from the table that in almost all the situations frapt achieves the best results compared to its variants in terms of precision and f measure .
taking the smack tutorial in mcgill corpus as an example the precision is .
in frapt whereas frapt topic and frapt pr achieve .
and .
respectively.
when considering fmeasure frapt outperforms frapt topic and fraptpr by .
and .
respectively.
when taking recall into account even though frapt shows a slight decline it can better balance precision and recall to achieve significant improvement.
from fig.
which shows the average values we can see that frapt shows its advantage.
the reason why aggregating topic model and pagerank algorithm could improve the results may be that topic model can find semantic relationships between fragments and apis while pagerank algorithm tries to find lexical and structural connections between them.
by aggregating both topic model and pagerank algorithm frapt could better capture the relevance between fragments and apis.
conclusion.
by aggregating both topic model and pagerank algorithm frapt can better detect relevant fragments for apis.
vii.
threats to validity a. threats to internal validity internal validity is the degree of our approach to link independent variables to depen dent variables.
in the experiments we have already inves tigated the influences of several important components incl uding fragment filter and pronoun and vari able resolution etc.
from the results of the rqs we can find that they are effective components.
besides topic model and pagerank algorithm have been applied to many areas and their stability a nd scalability have been proved.
as a result this th reat has been taken into consideration and minimized as many as possible in frapt.
b. threats to external validity external validity is the ability to which the conclusion of the experiments can be generalized to other corpora and research settings.
in this study we introduce all the tutorial corpora we can obtain.
these tutorials are related to java and android apis and cover many different topics with different sizes and origins .
as a result they are representative tutorials for research study.
it is unclear how our approach performs when appl ying to other tutorials.
in the future we plan to introduce more tutorials to verify frapt.
viii.
related work there are a lot of api documentations helping developers to use apis e.g.
api specifications api tutorials forums and blogs .
a series of works exist in the literature related to api documentations .
we mainly introduce three research topics i.e.
content classification information enhancement and error detection.
content classification aims to analyze the content of api documentations to improve the efficiency of consulting api documentations.
maalej and r obillard developed a taxonomy of knowledge types to study the nature of knowledge in api reference docum entations.
monperrus et al.
conducted an empirical study on the directives and kinds of directives were developed and discussed.
dekel et al.
developed and released an eclipse plugin named emoose to show the associated directives for methods.
information enhancement augm ents api documentations by some knowledge units.
treude and robillard proposed sise to augment api documentations with insight sentences from stack overflow.
kim et al.
proposed an approach to enrich api documentations with code examples.
the results of user study showed that the enriched api documentations can improve the productivity of developers.
error detection attempts to find errors in api documentations.
zhong and su formulated a set of inconsistencies and combined natural language processing as well as code analysis techniques to find these inconsistencies and more than errors were found and reported.
as typical api documentations we focus on api tutorials in this study.
different from the above research topics we attempt to break up api tutorials into fragments and find relevant fragments for apis.
ix.
conclusion and future work it remains a challenging issue to discover relevant fragments for apis.
in this study we propose an unsupervised approach namely frapt.
combined with two fragment examples we demonstrate how each component works in frapt.
we compare frapt against three existing approaches over two publicly open tutorial corpora.
the results show that frapt achiev es better results than the state of the art approach.
besides some key components in fratp are also evaluated to show their effectiveness.
for future works we try to improve frapt in several directions.
first we plan to a ddress the threats to external validity by introducing more tutorial corpora to validate frapt.
second we try to adap t frapt to discover relevant fragments for different levels of apis e.g.
method level.
third we try to develop an eclipse plugin encapsulating frapt to facilitate learning and using apis for developers.
acknowledgment we thank the reviewers for their comments.
this work is supported by the new cen tury excellent talents in university under grant ncet the national natural science foundation of chin a under grants and th e fundamental research funds for the central universities under grant dut14yq203.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.