diffuzz differential fuzzing for side channel analysis shirin nilizadeh university of texas at arlington arlington tx usa shirin.nilizadeh uta.eduyannic noller humboldt universit at zu berlin berlin germany yannic.noller hu berlin.decorina s. p as areanu carnegie mellon university silicon v alley nasa ames research center moffett field ca usa abstract side channel attacks allow an adversary to uncover secret program data by observing the behavior of a program with respect to a resource such as execution time consumedmemory or response size.
side channel vulnerabilities are difficultto reason about as they involve analyzing the correlationsbetween resource usage over multiple program paths.
we present d iffuzz a fuzzing based approach for detecting side channel vulnerabilities related to time and space.
d iffuzz automatically detects these vulnerabilities by analyzing two versions of theprogram and using resource guided heuristics to find inputs thatmaximize the difference in resource consumption between secretdependent paths.
the methodology of d iffuzz is general and can be applied to programs written in any language.
for thispaper we present an implementation that targets analysis of j ava programs and uses and extends the k elinci and afl fuzzers.
we evaluate d iffuzz on a large number of j ava programs and demonstrate that it can reveal unknown side channel vulnerabilities in popular applications.
we also show that d iffuzz compares favorably against b lazer and t hemis t w o state of the art analysis tools for finding side channels in j ava programs.
index t erms vulnerability detection side channel analysis dynamic analysis fuzzing i. i ntroduction side channel attacks enable an adversary to uncover sensitive information from programs by observing non functional characteristics of program behavior such as execution time memory usage response size network traffic or power con sumption.
there is a large literature on side channels showingevidence that they are practical and can have serious securityconsequences .
for instance exploitable tim ing channel information flows were discovered for google skeyczar library the xbox and implementationsof rsa encryption .
more recently the meltdown andspectre side channel attacks have shown how to exploitcritical vulnerabilities in modern processors to uncover secretinformation.
these vulnerabilities highlight the increased needfor tools and techniques that can effectively discover sidechannels before they are exploited by a malicious user inthe field.
however side channel vulnerabilities are difficult toreason about as they involve analyzing correlations betweenresource usage over multiple program paths.
in this paper we present d iffuzz a dynamic analysis approach for the detection of side channels in software systems.
joint first authorsgiven a program whose inputs are partitioned into public andsecret variables d iffuzz uses a form of differential fuzzing to automatically find program inputs that reveal side chan nels related to a specified resource such as time consumedmemory or response size.
we focus specifically on timing andspace related vulnerabilities but the approach can be adaptedto other types of side channels including cache based.
differential fuzzing has been successfully applied before for finding bugs and vulnerabilities in a variety of applications such as lf and xz parsers pdf viewers ssl tls libraries and c compilers .
however to the best ofour knowledge we are the first to explore differential fuzzingfor side channel analysis.
typically such fuzzing techniquesanalyze different versions of a program attempting to discoverbugs by observing differences in execution for the sameinputs.
in contrast d iffuzz works by analyzing two copies of the same program with the same public inputs but withdifferent secret values and computing the difference in side channel measurements time or space observed over the twoexecutions.
if the difference is large then it means that theprogram has a side channel vulnerability which should beremedied by the developer.
the approach is similar to the well known method of selfcomposition which is used to check that no matter what the secret is the program yields the same output.
if thatis the case the program is said to satisfy non interference meaning that the program leaks noinformation otherwise the program is vulnerable.
however it has been argued that non interference with regard to side channels istoo strong a property for most realistic programs as it isalmost always the case that some variation in resource usage particularly execution time exists for different program paths.if the difference is small it may not be exploitable in practice since it may not be actually observable by an attacker.
forexample consider the case of a client server application.
smallvariations in execution time on the server side may not beobservable and therefore exploitable on the client side.
insuch cases the program can be considered secure although itdoes not satisfy non interference.
if on the other hand thedifference is large this indicates a side channel vulnerabilitysince an attacker can use differences between measurementsto distinguish between secrets.
for this reason d iffuzz does not merely check non interference but instead employs ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
resource guided heuristics to automatically find inputs that attempt to maximize the difference in resource consumption between secret dependent paths.
the methodology that we advocate with d iffuzz is general and can be applied to programs written in any language.
for this paper we present an implementation that targets j ava programs and is based on a merican fuzzy lop afl and k elinci .
afl is a fuzz testing tool that uses genetic algorithms to mutate user provided inputs using byte level operations with the goal of increasing coverage k elinci provides an interface to execute afl on j ava programs.
to perform side channel analysis d iffuzz instruments a program to record resource consumption in addition to coverage along the paths that are executed by the fuzzed inputs.
furthermore diffuzz records the difference in resource consumption in a user defined cost.
this difference is sent back to the fuzzer whose mutants are marked as important if there is an increase in the computed difference thus guiding the fuzzer towards inputs that expose vulnerabilities.
we have applied d iffuzz on well known widely used java applications such as apache ftpserver and authmereloaded where we found new previously unknown vulnerabilities which were confirmed by the developers.
additionally we have applied our approach on complex examples from the darpa space time analysis for cybersecurity stac program ibasys an image based authentication system and crime an instance of the compression ratio info leak made easy attack where we found vulnerabilities related to both time and space consumption.
we also compared d iffuzz with b lazer and t hemis two state of the art analysis tools for finding side channels in j ava programs.
both tools perform static analysis and can in principle guarantee absence of side channels but may also give false alarms due to underlying over approximation.
in contrast d iffuzz performs a dynamic analysis and thus does not give false alarms provided that the fuzzing driver is meaningful see section .
.
but it can not prove absence of vulnerabilities.
we evaluated d iffuzz on the same benchmarks from themis and b lazer and were able to find the same vulnerabilities.
we also ran d iffuzz on the corrected safe versions when they were available .
for the majority of these cases we found that as expected d iffuzz correctly finds zero or a small differences thus showing the usefulness of the approach also in the case of absence of vulnerabilities.
however we have also found that in some cases d iffuzz uncovered new vulnerabilities in versions which were shown to be safe with blazer and t hemis .
in summary this work makes the following contributions we present d iffuzz the first differential fuzzing approach for finding side channel vulnerabilities.
we evaluate d iffuzz on multiple security critical j ava applications and we report new vulnerabilities in well known j ava applications such as apache ftpserver.
we compare with state of the art tools b lazer and themis where we highlight some new vulnerabilitiesin programs that were previously deemed safe.
ii.
a pproach figure shows the overview of our differential fuzzing approach.
to start the analysis the user needs to provide initial seed files that exercise the program under test cf.
step in figure .
the user also needs to provide a driver which parses an input file into three elements pub common public value sec1 andsec2 two secret values one for each program copy and executes two copies of the program on these inputs.
the program is instrumented to record resource consumption and coverage information.
the seed files are put into a queue for further processing cf.
step in figure .
this queue is used during the whole process as the central data structure that includes all the inputs that are deemed interesting by the analysis.
the fuzzer will take the inputs from the queue and will mutate them repeatedly cf.
step in figure .
in order to decide whether a mutated input is interesting for further processing d iffuzz executes the driver with this input computes the cost difference between two executions which is handled as the score for this input and compares it with the maximum cost difference aka cost difference high score which was observed in the previous executions cf.
step in figure .
only the inputs that either lead to increased high score or to increased overall program coverage will be forwarded to the fuzzing queue cf.
step in figure .
the process is repeated until a user specified timeout occurs.
we describe the d iffuzz approach in more detail below.
a. side channel analysis information flow analysis is typically used to determine that a program manipulates secret data in a secure manner.
the analysis accepts programs as secure if the secret data can not be inferred by an attacker through their observations of the systems.
this intuitive property is called non interference .i n the case of side channels the observations consist of the sidechannel measurements that an attacker can make.
there are many techniques for checking non interference.
the simplest one is through self composition .
at a high level the technique reduces the problem of secure information flow of a program to analyzing two copies of the same program where the secret inputs are renamed but the public values stay the same and checking that these two copies create the same observation.
letpbe a program and p llbracketpub sec rrbracketbe the execution of the program pwith inputs pub andsec.
as it is customary in the security literature we break down the program inputs to a tuple of public low values and secret high values.
we abbreviate the public values as pub and the secret values as sec.
furthermore let c .
be the evaluation of a program execution with respect to a particular cost encoding the resource usage e.g.
execution time or response size of the program.
the non interference requirement can then be formalized as follows pub sec sec c p llbracketpub sec rrbracket c p llbracketpub sec rrbracket authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
initial seed filesqueuemutate repeatedlymutated files that showed new interesting behavior assess input for instrumented program pparse input pub sec 1p p pub sec2calculate cost differencecov1 cost1 cov2 cost2check increased cost difference orincreased coverage ?fuzzing driver costdiff cost1 cost2 fig.
overview of d iffuzz approach.
intuitively the property states that any two secrets are indistinguishable through the side channel observations and therefore can not be uncovered by an attacker.
although satisfying non interference is a sound guarantee for a system to be secure this requirement is too strict for the side channel analysis of most realistic programs.
particu larly for timing channels small differences in computationsmay be imperceptible to an attacker and can thus not beexploited in practice.
this problem was observed in variouspapers before and was formalized as checking epsilon1bounded non interference in not only programs withzero interference can be accepted as secure but also programswhere the difference between observations is too small belowa threshold epsilon1 to be exploitable in practice.
thus the program is deemed to be secure if the following condition holds pub sec sec c p llbracketpub sec rrbracket c p llbracketpub sec rrbracket epsilon1 one can perform the above check by enumerating all the possible input combinations measuring the resource con sumption for each run and performing the check for thetwo versions of the program but this could become quickly intractable for most realistic programs.
we therefore advocate the use of fuzzing to address the problem.
however typical fuzzing tools are engineered to only increase code coverage and can thus be very slow in generatinginputs that expose a significant difference in resource con sumption.
the key ingredient of our approach is the incorpora tion of heuristics that guide the fuzzing towards configurationsthat maximize this difference as explained in the followingsections.
note that unlike previous techniques that use staticanalysis to check epsilon1 bounded non interference we do not require the user to provide an a priori threshold epsilon1 instead we let the tool try to maximize the difference between secret dependent paths.
b. attacker model we review here the attacker model considered in this paper which is similar to previous work on the topic .
we assume the program is deterministic and that the side channelmeasurements are precise.
we further assume that the attackercan not observe anything else i.e.
the attacker does not use themain channel to infer information .
when measuring resourceusage we assume that any variations are caused by the applica tion software and we are thus ignoring side channels relatedto the hardware architecture or the physical environment.
inprinciple we can handle all these side channels by using anavailable model of the corresponding resource.
even in the absence of a model we could use the inputs generated by the fuzzer to run the programs on a specific platform and performactual precise measurements with respect to the resource ofinterest.
furthermore we could measure the wall clock timeand also the jit just in time compilation effect.
the mentioned assumptions are realistic.
for example imagine a server client scenario in a distributed environment sim ilar described in in which the attacker is physicallyseparated from the victim application i.e.
there is no chance toobserve any physical side channel.
for an encrypted networkcommunication the attacker cannot read the content of thesent messages and hence relies on the metrics that can beobserved during communication with the server like responsesizes and response times.
additionally based on the physical distribution the attacker should not have the possibility to manipulate the victim application to observe any hardware level side channels.
note that d iffuzz is also applicable to non deterministic code and in the experiments we report on such an application.however in general the results could be imprecise in thiscase due to the noise introduced in the measurements.
more analysis would be necessary which is left for future work.
c. differential fuzzing our approach aims to use fuzzing to analyze the two copies of the program and to guide it to find inputs that maximize the cost difference between two program executions for which only the secret values are different maximize pub sec sec 2 c p llbracketpub sec rrbracket c p llbracketpub sec rrbracket fuzzing driver in order to apply fuzzing we need a driver that parses the inputs from the fuzzer and executes the twocopies of the code under test while also measuring the costdifference.
procedure shows the general driver of our fuzzing approach.
it starts with parsing the input cf.
line i.e.
reading three different input values the public value and twosecret values which are used to execute the program twice asformulated in equation .
additionally the parsing can take authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
some simple constraints for these input values as described below.
for each execution we measure the costs cf.
line and and calculate the absolute cost difference cf.
line .
this value is used to guide the fuzzer cf.
line to generate more inputs with the goal of increasing the difference.
in our implementation this notion of cost difference is realized by setting user defined cost values.
procedure differential fuzzing driver pub sec sec parse input constraints cost measure p pub sec cost measure p pub sec cost diff cost cost setuserdefinedcost cost diff input constraints solving the maximization problem described in equation for two totally arbitrary chosen input tuples might not be expedient because most applications assume certain properties of the secret values.
for example if a password is stored as a hash the application would assume that the hashed values have the same fixed length.
using secret values with arbitrary lengths for testing this application would lead to results that are not meaningful.
therefore in practice it is useful to set some simple constraints on the inputs.
in our approach we have a constructive solution i.e.
we rely on the user to encode input constraints in the driver such that only the inputs that satisfy these constraints are passed to the programs.
for example the driver can limit the size of a string during parsing by simply not reading more characters than a given threshold or the driver can ensure a certain character set for a string that should represent a hash value by mapping all non member characters to member characters during parsing.
analysis outcome the result of the analysis is a set of concrete public and secret inputs that expose the maximum cost difference between two secret dependent paths found by the fuzzer.
if the difference is large it indicates a side channel vulnerability and the developer can use the provided inputs to precisely pinpoint the problem and fix the vulnerability e.g.
by making the cost similar on both program paths.
if on the other hand the difference is small or zero it could mean that the program has no vulnerabilities or that the fuzzer was not run long enough.
the developer can then run the fuzzer longer to get enough confidence that the software indeed has no vulnerability.
the fuzzer also records the coverage achieved on the analyzed code and this information can also be examined to increase the confidence in the reported results.
manual effort diffuzz requires manual effort in writing the drivers and the input constraints.
in the driver the user needs to specify how to parse the input file to retrieve valid input values the entry point to start the target application and how to measure the execution cost.
as many applications come with test cases we use them to determine entry points.
we believe that the manual effort is not high as all the drivers are very similar and follow procedure the constraints are minimal and application specific e.g.
passwords have certain lengths .
one can also envision using fuzzing to discover theseconstraints automatically following the work on grammar inference from .
however this is left for future work.
d. fuzzing programs for fuzzing we use off the shelf tools such as afl .
afl is a state of the art security oriented grey box fuzzer that employs compile time instrumentation and genetic algorithms to automatically generate test inputs that improve the branch coverage of the analyzed code.
fuzz testing tools have been very successful at finding bugs and vulnerabilities in a variety of applications ranging from image processors and web browsers to system libraries and various language interpreters.
for example afl was instrumental in finding several of the stagefright vulnerabilities in android the shellshock related vulnerabilities vulnerabilities in bind as well as numerous bugs in security critical applications and libraries such as o penssl o penssh gnutls g nupg php a pache ijg jpeg libjpeg turbo and many more cf.
bug list on afl s website .
motivated by the success of fuzzing we aim to use this technology for finding side channel vulnerabilities.
typically fuzzers use heuristic algorithms to mutate user provided inputs to increase coverage with the goal of finding crashes and other vulnerabilities.
in contrast d iffuzz uses fuzzing to perform a relational analysis where the goal is to maximize the difference in resource usage for two copies of the program.
to realize this goal an off the shelf fuzzer can be extended as follows the instrumentation is modified to collect additional information related to a resource consumption such as timing memory usage and response size and the difference between the costs observed for two program copies is recorded and sent back to the fuzzer whose logic is modified to consider as important the inputs that increase this difference.
in particular the fuzzer maintains the so far observed difference high score and prioritizes inputs leading to new high score in addition to improved coverage attempting to maximize the difference and thus find side channels.
the timing cost is approximated by counting every bytecode instruction executed by the program.
a similar cost is used in previous static analysis tools t hemis and b lazer allowing us to compare with them.
note that we can also measure the wall clock time directly by recording the execution time for each execution.
the measurements can be performed on a clean un instrumented version of the program using the inputs provided by fuzzing.
however we found that these measurements could sometimes be imprecise due to garbage collection and other processes running on the same machine.
one can perform multiple runs for the same input and take the average of these measurements but we did not explore this direction further in this work as we found that counting the instructions provides a good approximation.
memory usage is measured by intermittent polling using a timer which results in measuring the maximum consumption at any point during program execution.
d iffuzz also measures response size in bytes for the values that are returned and the messages that are sent by the application.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we note that afl supports programs written in c c or objective c. to make it applicable to j ava programs we use kelinci which provides an afl style instrumentation for j ava programs executes the instrumented programs and sends results back to a simple c program that interfaces with afl.
afl does not know about the j ava program in the background because it only communicates with the mentioned interface program and hence afl can use its heuristics to generate inputs that are then executed on the java programs.
e. example we illustrate the side channel analysis on a password checking example.
listing and listing show the code for the comparison of a user password with a server side stored password in an unsafe and safe way respectively.
0boolean pwcheck unsafe byte pub byte sec if pub.length !
sec.length return false for inti i pub.length i if pub !
sec return false return true listing unsafe password checking 0boolean pwcheck safe byte pub byte sec boolean unused boolean matches true for inti i pub.length i if i sec.length if pub !
sec matches false else unused true else unused false unused true return matches listing safe password checking the unsafe variant contains a timing side channel because its early return in lines and .
these two locations were fixed in the safe variant by iterating over the complete password even when the two passwords already do not match at an earlier point.
to apply d iffuzz we built a driver for the unsafe variant based on procedure with length limit of bytes for each fuzzed value see listing .
the way we parse the input in this example ensures that all three values have same length.
the field mem.instrcost holds the current cost measured by the instrumentation i.e.
in our case the number of executed bytecode instructions.
the method mem.clear resets the current cost which is necessary to measure the cost for each execution separately.
kelinci.addcost diff tells thefuzzer to use the cost difference diff as cost metric during the input assessment.
we did run the fuzzer for minutes and obtained a maximum cost difference of bytecode instructions with the inputs shown in listing .
the value of sec 2is matching the complete value of pub whereas the value of sec 1is not matching at all.
note that the fuzzer generated these values on its own without any further influence by the driver.
the initial input file the seed file generated randomly leads to the cost difference .
in fact the difference of instructions is the worst case scenario and was already retrieved by the fuzzer within seconds.
a value greater than was retrieved by the fuzzer within seconds.
0voiddriver string args intmaxlen intmaxdata maxlen byte allbytes readdatauptomax args maxdata intlen allbytes .length byte pub arrays .copyofrange allbytes len byte sec 1 arrays .copyofrange allbytes len len byte sec 2 arrays .copyofrange allbytes len len 9mem.clear boolean answer1 pwcheck unsafe pub sec 1 longcost1 mem.instrcost 13mem.clear boolean answer2 pwcheck unsafe pub sec 2 longcost2 mem.instrcost longdiff math .abs cost1 cost2 18kelinci .addcost diff listing password checking driver pub sec 1 sec 2 listing input for max cost difference after min.
afterwards we used a similar fuzzing driver on the safevariant for minutes as well and we ran d iffuzz again.
in this case we have observed no cost differences i.e.
.
to further check that the program was indeed repaired we executed the safe variant with the inputs obtained with the previous fuzzer run on the unsafe variant obtaining again zero difference.
iii.
e v aluation to assess the effectiveness of d iffuzz in identifying side channel vulnerabilities we evaluated it on two sets of benchmarks.
the first set taken from and contains programs with known time and space side channels as well as repaired versions.
the second set contains new complex examples from the darpa space time analysis for cybersecurity stac program as well as popular real world applications on which we identified new vulnerabilities.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for the first set of benchmarks we compare d iffuzz with b lazer and t hemis two state of the art static analysis tools for detecting side channel vulnerabilities in java programs.
b lazer uses decomposition techniques for proving bounded non interference while t hemis uses quantitative cartesian hoare logic reasoning to check bounded non interference for j ava programs where the bound epsilon1is set to either or .
since b lazer and t hemis are not available we perform the comparison on the same set of benchmarks that were used to evaluate the respective tools .
we received the code for all the benchmarks from the themis developers.
we note that three examples were missing apache shiro apache crypto and bc java we therefore could not analyze them.
our tool and the benchmarks are available at our github repository a. experimental setup for each target application we wrote a driver in j ava following the steps in procedure section ii .
note that by default the instrumentor ignores all library code and hence we specifically copied methods from libraries into the application to instrument them as well.
due to the randomness in fuzzing we run d iffuzz on each application five times and we report the averaged results.
all the experiments were performed on a server with open suse leap .
featuring quad core amd .
ghz and gb of memory.
we used o penjdk .
.
and gcc .
.
.
although typically d iffuzz is able to identify a side channel vulnerability in a few seconds we run each experiment for minutes.
as mentioned d iffuzz reads the inputs to a program from an initial seed file.
in general we used a randomly generated file.
some applications get specific types of inputs such as ibasys that needs an image file.
in that case we extracted the byte encoding from a random image and used it as the initial input file.
for finding timing side channels we use a simple cost model that counts the bytecode instructions during the program run.
both b lazer and t hemis similarly count the instructions for their timing side channel analysis.
b. evaluating diffuzz on the blazer examples we employed d iffuzz on the examples from for evaluating b lazer which were also analyzed with t hemis .
they consist of programs with timing side channels and repaired safe versions.
they are small applications with up to a hundred lines of code.
note that the safe version of unixlogin was not executable due to a nullpointerexception during hash comparison cf.
the figure in the b lazer paper second example line .
although t hemis did not include this subject we fixed the issue by adding a dummy comparison of the same md5 hash of the provided password.
results we summarize the results in table i. the average column shows the average cost difference between two executions of an application.
the time column includes the time that each of the tools d iffuzz b lazer themis needed to identify a vulnerability.
the numbers for b lazer and t hemis are extracted from for the t hemis experiments the bound epsilon1was set to zero.
for d iffuzz the time shows the average earliest time that cost difference is bigger than zero .
the time values for some safe versions are not provided because in those cases the is zero.
the results indicate that d iffuzz is able to accurately identify all the side channel vulnerabilities in the unsafe versions.
the average cost difference for all unsafe programs is more than zero and sometimes it is very large.
diffuzz behaves as expected on the majority of the safe versions finding zero difference but it also found some discrepancies.
in two cases array and unixlogin the differences found and may be attributed to slight discrepancies between the intermediate representations of the different analyses and can thus be considered negligible.
however in two other cases d iffuzz found large values indicating that the repaired versions are in fact notsafe.
we discuss them below.
loopandbranch both b lazer and t hemis deemed the repaired version of loopandbranch function as safe.
diffuzz instead identified a huge difference 404in computed costs which occurs due to integer overflow.
in particular the value assigned by the fuzzer to one of the secrets is the maximum integer value in java which gets added to becoming a negative value.
as a result none of the loops in the code get executed and the cost is very small compared to the cost of the other execution with the second secret value.
this vulnerability which was confirmed by the developers of b lazer highlights the importance of handling overflow in analysis tools.
gpt14 this function computes the modular exponentiation abmod p used for the encryption and decryption of messages.
here aandpare public values and bis the secret.
blazer reported this example as safe for a non zero bound whereas t hemis reported it as safe for a zero bound noninterference .
d iffuzz found that even though the repair has substantially reduced the cost difference still which is consistent with the b lazer results .
this vulnerability is due to an extra ifstatement that depends on the secret and it was confirmed by the themis developers.
c. evaluating diffuzz on the themis examples we further evaluated d iffuzz on the larger j ava programs with time and space side channels from .
these programs have up to 20k loc although only some smaller parts were analyzed with all three tools and are extracted from complexreal world applications such as tomcat spring security and eclipse jetty http web server.
all benchmarks except dynatable advanced table openmrs and oacc come with a repaired version.
some of the benchmarks tomcat pac4j include interactions with a database.
in our experiments we created the required databases and run them instead of simulating them with other data structures.
we used the h2 database engine to create an sql database accessible via the jdbc api.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i the results of applying d iffuzz to the b lazer examples.
discrepancies are highlighted in red and italics.
benchmark version average std.
error maximum time s diffuzz blazer themis microbench array safe .
.
.
.
.
.
array unsafe .
.
.
.
.
.
loopandbranch safe .
.
.
.
.
.
loopandbranch unsafe .
.
.
.
.
.
sanity safe .
.
.
.
sanity unsafe .
.
.
.
.
straightline safe .
.
.
.
.
straightline unsafe .
.
.
.
.
.
unixlogin safe .
.
.
.
unixlogin unsafe .
.
.
.
.
stac modpow1 safe .
.
.
.
modpow1 unsafe .
.
.
.
.
.
modpow2 safe .
.
.
.
modpow2 unsafe .
.
.
.
.
passwordeq safe .
.
.
.
.
passwordeq unsafe .
.
.
.
.
.
literature k96 safe .
.
.
.
k96 unsafe .
.
.
.
.
.
gpt14 safe .
.
.
.
.
.
gpt14 unsafe .
.
.
.
.
.
login safe .
.
.
.
login unsafe .
.
.
.
.
results table ii displays our results the results for themis are taken from .
once again d iffuzz successfully identified vulnerabilities in the unsafe versions of these examples and for the majority of the repaired versions diffuzz found only small differences as expected.
in one case jetty d iffuzz identified a new vulnerability in the repaired version.
some other examples tomcat pac4j oacc also show some discrepancies.
we provide more details below.
jetty themis was used to analyze a known vulnerability in the eclipse jetty http web server and a repaired version of it.
furthermore t hemis found a similar vulnerability in another part of the jetty application.
the original unsafe version of the code performs some checking over sensitive credential information by calling the built in equality method provided by the java.lang.string library .
since this method returns false as soon as it finds a mismatch between two characters it introduces a timing side channel vulnerability.
the method has been repaired with the one in listing .
this repair is very common and has been used in many implementations to avoid time channels.
0boolean stringequals string s1 string s2 boolean result true intl1 s1.length intl2 s2.length if l1!
l2 result false intn l1 l2 ?l1 l2 for inti i n i result s1.charat i s2.charat i return result listing jetty safe string comparison analyzed in interestingly for this example d iffuzz found that it is still vulnerable with .
the reason for this vulnerability is subtle.
it turns out that the operation at line is not constant time it takes either or bytecodes depending on the outcome of the equality check between the two characters the operation is optimized for the case that the outcome is false .
although there is a difference of only one bytecode instruction having this operation in the loop amplifies its impact.
this could not be discovered by t hemis because in its intermediate representation jimple the operation at line takes constant time.
we further note that we imposed no constraints on the input and this is in line with the t hemis experiments.
the observed difference is proportional with the size of the input and for small input sizes both versions could be considered safe.
however for large input sizes both safe and unsafe versions are in fact not safe.
tomcat pac4j oacc the vulnerability of pac4j is due to the encoding of a password which is performed during user authentication and is assumed to be expensive.
nevertheless the code provided by the t hemis developers did not include an expensive implementation of the password encoding they instead used a model which was not provided to us .
since we did not use any models we could not find a noteworthy cost difference between the provided safe and unsafe versions cf.
table ii subject pac4j safe and pac4j unsafe .
we also used another more expensive password encoding method denoted with a star in table ii which iterates over the password to get a stronger indication that there is an actual timing sidechannel vulnerability cf.
table ii subject pac4j unsafe .
we also found vulnerabilities in the unsafe versions of tomcat and oacc however the generated s were small.
upon consulting with the t hemis developers it appears that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii comparison against t hemis benchmark version diffuzz themis average std.
error maximum time s epsilon1 epsilon1 time s spring security safe .
.
.
.
.
spring security unsafe .
.
.
.
.
jdk7 msgdigest safe .
.
.
.
.
jdk6 msgdigest unsafe .
.
.
.
.
picketbox safe .
.
.
.
.
picketbox unsafe .
.
.
.
tomcat safe .
.
.
.
.
tomcat unsafe .
.
.
.
.
jetty safe .
.
.
.
.
jetty unsafe .
.
.
.
.
orientdb safe .
.
.
.
.
orientdb unsafe .
.
.
.
pac4j safe .
.
.
.
.
pac4j unsafe .
.
.
.
.
pac4j unsafe .
.
.
.
boot auth safe .
.
.
.
.
boot auth unsafe .
.
.
.
.
tourplanner safe .
.
.
tourplanner unsafe .
.
.
.
.
dynatable unsafe .
.
.
.
.
advanced table unsafe .
.
.
.
.
openmrs unsafe .
.
.
.
.
oacc unsafe .
.
.
.
.
similar to pac4j some manually built models were used which we could not obtain.
d. employing diffuzz on new examples we also applied d iffuzz on new j ava examples including two complex applications taken from the cybersecurity stac program ibasys and crime and two realworld open source projects apache ftpserver and authmereloaded .
results table iii shows the results.
for the reported zero day vulnerabilities all are confirmed and collaborating with the developers and the community solutions have been proposed and at this point most of them have been fixed.
we explain our findings in more details.
crime crime is an instance of the crime attack compression ratio info leak made easy which is as follows.
suppose a user is tricked into visiting a website attack.com which has a malicious script making several requests to bank.com .
each request is a concatenation of public input generated by the script and the login secret cookie of the user.
to avoid latency protocols such as https and spdy compress the requests before they are sent.
the communication channel is encrypted but the adversary can observe the size of the compressed package.
when the public input is close to the secret the compression is more efficient due to the redundancies and the reduction in the size of the compressed package is more significant.
hence the adversary can infer information about the secret.
we analyzed the string compression procedure loc .
it uses various inputoutput streams and involves complex string manipulations that are difficult to analyze with existing static analysis tools.
diffuzz correctly identifies a space side channel that reveals the secret through the size of the compressed output.ibasys ibasys is a network based authentication server that uses images in place of textual passwords.
to log in a user supplies a username and a passcode image e.g.
a jpeg image .
following a successful authentication ibasys replies with a response containing an encrypted session token.
this session token could then be used to interact with other services that rely on ibasys for their authentication needs.
we analyzed the authentication procedure loc which performs complex image manipulations.
diffuzz managed to generate input files that are bytecode representations of valid images and it was also able to uncover a timing channel that is due to early termination in a loop that matches the two public and private provided images.
the maximum cost difference found by d iffuzz is where the length of image public is bytes.
apache ftpserver we also applied d iffuzz on the opensource project apache ftpserver which has a very large code base we focused our analysis on specific classes as reported below.
we identified a previously unknown timing side channel in the class cleartextpasswordencryptor loc in which the method boolean matches string string uses the string.equals method for the comparison of the user provided password and the server side stored password.
this comparison returns false as soon as a character does not match and hence it could be used by a potential attacker to obtain knowledge about the hidden secret password.
we have found this kind of vulnerability also in the classes md5passwordencryptor loc and saltedpasswordencryptor loc .
we reported the issues to the developers who confirmed and fixed all of them.
we also analyzed safe versions provided by the developers which fixed the issue.
for all of them but one the safe variant of string comparison did eliminate the vulnerability.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii the results of applying d iffuzz on new examples benchmark version average std.
error maximum time s stac crime unsafe .
.
.
.
ibasys imagemacher unsafe .
.
.
zero day vulnerabilities apache ftpserver clear safe .
.
.
.
apache ftpserver clear unsafe .
.
.
.
apache ftpserver md5 safe .
.
.
.
apache ftpserver md5 unsafe .
.
.
.
apache ftpserver saltedpw safe .
.
.
.
apache ftpserver saltedpw unsafe .
.
.
.
apache ftpserver saltedpw unsafe .
.
.
.
apache ftpserver stringutils safe .
.
apache ftpserver stringutils unsafe .
.
.
.
authmereloaded safe .
.
.
.
authmereloaded unsafe .
.
.
.
for the class saltedpasswordencryptor diffuzz still detected a vulnerability so we continued our investigation and discovered that in addition to the matching method the used encryption method leaks information about the generated salt.
we have thus analyzed method string encrypt string pw string salt marked with a star in table iii.
we are discussing with the developers with regard to this new vulnerability.
0public final static string pad unsafe string src char padchar boolean rightpad inttotallength intsrclength src.length if srclength totallength return src intpadlength totallength srclength stringbuilder sb newstringbuilder padlength for inti i padlength i sb.append padchar if rightpad return src sb.tostring else return sb.tostring src listing apache ftpserver stringutils.pad unsafe version note that the salt in saltedpasswordencryptor gets randomly generated during encryption.
nevertheless for the matches method we fuzz the complete stored password including the salt.
furthermore for the more focused analysis of the encrypt method we test if the algorithm leaks some information about the used salt via a side channel.
we have also found a timing side channel in the method string stringutils.pad string char boolean int listing which was also confirmed by the developers.
this method leaks the padding in a timing side channel from which a potential attacker could obtain the length of the src string.
the padding is used to extend a username to fixed length hence a potential attacker could obtain the length of a given username which might be used for further attacks.
the vulnerability is caused by the early return in line and the for loop in line which only runs for padlength iterations.
the safe version provided in our repository solves both issues.authmereloaded we have also found an unknown timing side channel in the open source project authmereloaded which is an authentication plugin for minecraft servers available on github.
it provides features like username spoof protection and anti bot measures.
specifically we found a vulnerability in the class royalauth loc in the inherited method boolean comparepassword string password hashedpassword hashedpassword string name .
similar vulnerabilities have been found in the classes sha256 andpbkdf2 .
the developers fixed these vulnerabilities within a few days by using a constant time comparison algorithm.
e. discussion one advantage of d iffuzz compared to the other tools is that it not only shows whether an application is vulnerable but also shows the magnitude of the vulnerability.
this observation can be leveraged to estimate the severity of a vulnerability and it also makes it possible for the developers to compare different repaired versions of an application.
analysis time tables i ii and iii also show the time that each of the tools needed for analysis.
both b lazer and themis were run on different hardware making the timing reported incomparable.
in general static analysis is shown to be much faster than dynamic analysis our results show that nonetheless d iffuzz is able to identify vulnerabilities in a reasonable time.
in principle d iffuzz can run for a long time and it can still generate new inputs that increase the cost difference.
however we observed in preliminary test executions that our experiments find a plateau within minutes which is the time bound we applied.
for our experiments we observed three different kinds of behavior a d iffuzz identifies a small cost difference very fast and it increases it over time b d iffuzz identifies a big cost difference very fast and remains in a plateau after a few seconds and c d iffuzz needs a long time to find a cost difference at all.
cases a and b were almost equally distributed on our experiments and covered almost all of them.
only for three experiments we observed case c .
as an illustration the plots in figure show the average maximum cost development within the first minutes for the three cases.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time seconds cost instructions orientdb time seconds cost instructions ibasys time seconds cost instructions loopandbranch fig.
averaged cost over time for orientdb ibasys and loopandbranch unsafe versions .
orientdb case a checks passwords by comparing between user given and stored passwords.
the longer the matching prefix is the higher will be the processing cost.
exact value matching is in general very difficult for fuzzing because it is hard to randomly generate the exact unlikely values that match the stored password.
while d iffuzz finds quickly a small prefix which reveals a cost difference greater than zero it needs some time to reach a higher value.
for ibasys case b d iffuzz finds the maximum average value already after a few seconds and thus leads very fast to the shown plateau value.
the reason could be that the initial seed file guides the fuzzer already into a costly path or that the costly paths have a high probability and hence the fuzzer can easily catch them.
for loopandbranch case c d iffuzz reaches some parts of the code only with specific values for the secret and this is difficult to achieve with fuzzing.
we believe that the limitations illustrated with cases a and c can be mitigated by adding further guidance to the fuzzer and by e.g.
combining fuzzing and symbolic execution.
vulnerability vs exploit diffuzz can identify sidechannel vulnerabilities but can not assess whether they are exploitable by a real attack.
the synthesis of a real attack which would be necessary to assess the severity of the found vulnerability is out of scope for this work.
nevertheless we believe that our contribution is a first step in this direction.
iv .
r elated work diffuzz is related to a large body of work on checking non interference via self composition .
for instance related work presents a self composition approach to timingchannel analysis which however does not check bounded noninterference.
we already compared with the most recent related tools b lazer and t hemis .
cocochannel uses static analysis for finding sidechannel vulnerabilities and presents a comparison with themis and b lazer on the same benchmarks showing better scalability.
while cocochannel also found discrepancies in the t hemis and b lazer benchmarks the approach still fails to report vulnerabilities for the repaired versions in e.g.
loopandbranch and jetty.
stacco also uses a differential analysis for finding timing side channels using random inputs.
however staccodoes not perform directed fuzzing it does not check bounded non interference and it does not address java.
there is a large amount of related work on side channel analysis for example .
the most successful approaches use abstract interpretation for cache side channels analysis and are thus quite different than d iffuzz.
other techniques use symbolic execution and constraint solving with model counting for quantifying side channel leakage and for synthesis of attacks.
they address j ava programs but may have scalability issues due to the expensive constraint manipulation.
other related techniques aim to quantify leakage using monte carlo sampling .
in contrast to d iffuzz these techniques provide quantitative results but they may be imprecise in practice.
fuzzing has received renewed interest in the software engineering community with many recent approaches reported .
most related are techniques that use fuzzing alone or a combination of fuzzing and symbolic execution to analyze the algorithmic complexity of programs by monitoring a resource consumption.
in particular badger also uses kelinci and afl for the fuzzing part.
none of these works address side channel analysis.
v. c onclusions and future work we presented d iffuzz the first differential fuzzing approach for automatically finding side channel vulnerabilities.
we have shown that d iffuzz can keep up with existing approaches such as b lazer and t hemis .
furthermore d iffuzz found new vulnerabilities in popular open source j ava applications such as apache ftpserver.
in the future we plan to explore automated repair methods to eliminate the vulnerabilities discovered with d iffuzz.
additionally we plan to augment our work with statistical guarantees similar to the stads framework .
acknowledgment this material is based on research sponsored by darpa under agreement number fa8750 .
the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright notation thereon.
this work is also supported by the german research foundation gr empress .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.