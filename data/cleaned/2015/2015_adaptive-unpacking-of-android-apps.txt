adaptive unpacking of android apps lei xue xiapu luo l ey u shuai wang dinghao wu department of computing the hong kong polytechnic university college of information sciences and technology the pennsylvania state university cslxue csxluo cslyu csswang comp.polyu.edu.hk dwu ist.psu.edu abstract more and more app developers use the packing services or packers to prevent attackers from reverse engineering and modifying the executable or dex files of their apps.
at the same time malware authors also use the packers to hide the malicious component and evade the signature based detection.
although there are a few recent studies on unpacking android apps it has been shown that the evolving packers can easily circumvent them because they are not adaptive to the changes of packers.
in this paper we propose a novel adaptive approach and develop a new system named packergrind t o unpack android apps.
we also evaluate packergrind with real packed apps and the results show that packergrind can successfully reveal the packers protection mechanisms and recover the dex files with low overhead showing that our approach can effectively handle the evolution of packers.
i. i ntroduction with more than million apps on the google play android has accounted for around of all smartphone sales to end users .
at the same time recent reports revealed that of mobile malware runs on android most of which are repackaged apps .
they are legitimate apps carrying malicious components injected by attackers.
one root cause is the lack of binary protections which is one of the ow asp mobile top ten risks so that attackers can easily reverse engineer the apps and tamper their code.
to protect apps from being tampered and reverse engineered a number of app packing services or packers emerge which conceal and obfuscate the real code i.e.
dex files and prevent others from obtaining them .
unfortunately attackers also utilize packers to hide malware for evading the signature based detection and impeding the investigation of their malicious behaviors .
a recent report from symantec reveals that the number of packed android malware has increased from to .
therefore researchers proposed a few unpacking approaches recently to recover the dex files from packed apps in order to facilitate the analysis of mobile malware .
however the arms race between packers and unpacking tools never ends.
the latest version of packers could easily evade those unpacking tools.
the key issue lies in the one pass processing strategy adopted by the unpacking tools.
in other words they are not adaptive to the evolution of packers.
in this paper we propose a new adaptive approach which employs an iterative process to recover the dex files from packed apps and develop a new system named packergrind to automate most steps in the process.
the corresponding author.our iterative process consists of three major tasks including monitoring which captures how packed apps work especially how it prepares the real code for execution and then generates tracking reports based on which we can determine the data collection points recovery which collects the pieces of data in dex files at the selected data collection points and reconstructs dex files analysis which determines whether new data collection points are needed to recover dex files.
automating this process is non trivial because we need to address two challenging research questions rq1 how to conduct cross layer profiling of packed apps behaviors in a smartphone?
rq2 how to effectively recover the dex files of apps packed by different packers?
answering rq1 needs a system that can perform cross layer monitoring of an app s behaviors and run in real smartphones.
note that with the support of android framework apps run in the runtime which was the dalvik virtual machine dvm before android .
and became the new android runtime art afterwards and the runtime is on top of the modified linux.
packed apps usually exploit the features of the java language android framework and native libs instructions to hide the real code detect emulator and prohibit debugging .
existing dynamic analysis systems for monitoring apps cannot address rq1 because they either rely on emulator e.g.
qemu and debugging techniques or lack of the support of cross layer profiling .
to tackle rq1 we propose and develop a novel cross layer monitoring component for packergrind .
by exploiting dynamic binary translation it collects information from the runtime the system and the instruction layers and runs in smartphones.
moreover it supports both dvm and art .
existing unpackers for android apps cannot fully address rq2 because of their one pass processing strategy.
to approach rq2 we first identify basic dex data collection points by scrutinizing how dvm and art load and run apps.
since different packers employ various protection methods to modify the code and data in memory dynamically packergrind provides detailed tracking reports as well as suggested criteria to recognize the protection patterns.
moreover packergrind conducts static analysis on the dex file obtained at each run to facilitate users to identify new data collection points if needed.
although this step might need manual inspection the detailed information and scripts provided by packergrind could alleviate the workload.
packergrind also has built in rules to automatically unpack apps protected by existing packers ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accessible to us.
after that packergrind will re run the packed app collect dex data at selected collection points and finally reconstruct the dex file.
in summary our major contributions include we propose a new iterative process to unpack android apps.
this process as well as the new system packergrind i s adaptive to the evolution of packers.
we design packergrind that automates most steps in the iterative process.
it can conduct cross layer monitoring and dex file recovering in real smartphones.
moreover it supports both dvm and art .
to our best knowledge it is thefirst system that can address the above two challenging research questions simultaneously.
we implement packergrind with .3k lines of c c code not include v algrind and .5k lines of python code and compare it with the state of the art unpacking tools with real apps packed by popular packers.
the results show that packergrind can unpack all these apps with low overhead whereas dexhunter recovered a few and androidunpacker unpacked none.
the rest of the paper is organized as follows.
section iiintroduces background knowledge and a motivating example.
section iiidescribes the basic dex data collection points.
section ivdetails the design and implementation of packergrind and section vreports the experimental results.
after discussing the limitations of packergrind and future work in section vi we introduce the related work and conclude the paper in section vii and section viii respectively.
ii.
b ackground a. dex file the bytecode of an android app is contained in the dex file which is a highly structured data file consisting of different dex data items e.g.
proto id item code data item .
a dex file has three major sections including header section data identifiers section and data section.
the header section includes a summary of the dex file e.g.
checksum size and offsets .
the data identifiers section contains identification lists for defined classes namely string ids type ids proto ids field ids method ids and class defs each of which contains multiple items.
for example string id item contains the offset from the start of the dex file to the corresponding string data item .
the data section contains the information related to bytecode including map list type list class data item s code data item s debug info item s encoded array item s and four annotation data items.
b. android app packing packers usually protect apps code from three aspects namely hiding dex files impeding the dumping of dex files in memory and hindering the reverse engineering of dex files.
hiding dex files.
packers often use three approaches to hide dex files.
dex file modification.
packed apps use nativecode to modify dex files in the memory when the app is running.
for example apps packed by baidu packer in fill a special method with valid instructions just before the method is called and erase them after execution.
packergrind can capture such behaviors and dump the correct instructions at the right moment.
dynamic class loading.
packers put the bytecode of selected functions in separated dex files and load them when the functions are invoked.
they even encrypt the dex files and decrypt them before loading the required classes.
packergrind can dump the dex files after they are loaded because it traces the runtime s functions.
native method.
packers could turn the selected dex functions into native methods and then invoke them through java native interface jni from the dex file.
although packergrind is not designed to reverse engineer the native code for regenerating the bytecode it can still provide useful information about the native methods thanks to its cross layer monitoring component.
impeding the dumping of dex files.
packers usually employ three approaches to prevent unpackers from dumping the real code in memory.
emulator detection.
since many dynamic analysis systems rely on android emulator packers employ advanced techniques to determine whether a packed app is running in an emulator.
if so the app will exit.
packergrind does not rely on the emulator.
instead it exploits dynamic binary translation to perform cross layer monitoring and recovers dex files.
anti debug.
if an unpacker attaches to the packed apps as a debugger it can monitor the apps and obtain the dex files.
to impede such method the packed apps often launch multiple threads and let one thread attach to another using ptrace because a process can only be attached by one process.
packergrind does not use this approach.
hooking.
to prevent unpackers from accessing and dumping the dex files in memory packed apps often hook the functions related to file and memory operations to prohibit unpackers from using them.
packergrind can disable these hooks.
anti reverse engineering of dex files.
packers commonly employ various techniques e.g.
obfuscation etc.
to raise the bar for understanding the internal logics through static code analysis.
handling them is out of the scope of packergrind .
c. motivating example existing unpackers are not adaptive to the changes of packers and hence can be easily circumvented.
in particular they usually perform one pass processing based on the developer s knowledge for obtaining the dex files.
therefore packers can modify their behaviors accordingly to defeat such unpackers.
we argue that unpackers should be adaptive to the changes of packers by monitoring and learn their behaviors.
we use an app packed by baidu packer in db as a motivating example.
as show in fig.
the original code of oncreate in mainactivity is replaced by those at line and oncreate001 is empty and called between two jni methods i.e.
a.d and a.e .
by monitoring the packed app we find that when a.d is invoked it fills oncreate001 with correct instructions which will be erased after a.e is called.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the state of the art unpackers i.e dexhunter and appspear cannot obtain the instructions in oncreate001 effectively.
dexhunter collects the dex data in dvmdefineclass .
however when this function is called the correct instructions have not been written to oncreate001 yet and thus dexhunter misses them.
similarly appspear assumes that dvm s parsing methods e.g.
dexgetcode always provide expected results.
however in this example dexgetcode can only obtain the right instructions of oncreate001 when it is invoked between a.d and a.e .
in other words appspear cannot get the correct results if it misses the right moment.
since dexhunter and appspear are implemented within the runtime they cannot monitor packed apps behaviors at the system and the instruction levels to determine the right moments.
public void oncreate bundle bundle string str lxxx oncreate001 landroid os bundle v a.d str oncreate001 bundle a.e str private void oncreate001 bundle savedinstancestate fig.
oncreate method of the app packed by the baidu packer of db .
packergrind can address this issue because it iteratively monitors packed apps at different layers facilitates the determination of collection points and recovers the dex files.
by analyzing the dex file obtained in the first run we can learn that the instructions of oncreate001 are modified during execution.
according to the tracking report we know that a.d is called before oncreate001 to fill the instructions and a.e is invoked after oncreate001 to erase them.
moreover as shown in fig.
the parameters of both method a.d and a.e are the name of oncreate001 .
with such information we add a new collection point between a.d and a.e and then packergrind can reconstruct the correct dex file automatically.
iii.
b asic dexdata collection points as shown in fig.
we divide the process from dex files loading to method execution into four phrases namely parsing dex files loading classes resolving methods and executing methods.
consequently we define four basic collection points for dvm and art respectively.
dex file parserclass loadermethod resolutionmethod executionpacker loadmethodfromdex dexmethod method classobjectdexfileparse dexfile dvmcallmethodv dvmcallmethoda dvminvokemethod dvminterpret resolve methods dexreadclassdatamethod dexcomparenamedescr iptorandmethod dexgetcode direct methods virtual methodsdvmdefineclass fig.
the process from dex file loading to method execution.
a. dalvik vm dvm parsing dex files.
a dex file can be loaded either from a file in storage through opendexfilenative or a memoryspace through opendexfile bytearray .
both methods will call dexfileparse to parse the dex file and return the structure dexfile to represent this dex file in runtime as shown in fig.
.
since dexfile is initialized according to the dex file header in dexfileparse we select dexfileparse as the first dex data collection point.
loading classes.
a class can be loaded through dalvik dalvik system dexfile defineclassnative .
in this function dvmdefineclass is called to load the class and return the structure classobject that contains the class s information e.g.
fields methods etc.
.
moreover the structure class def item is read from the dex file and then the structureclass data item is parsed from the dex file according to its offset in class def item .
after that classobject is initialized.
hence we choose dvmdefineclass as the second dex data collection point.
resolving methods.
when loading a class the class loader will resolve each method to initialize classoject according toclass data item .
during such resolution the class loader first obtains dexmethod from the dex file by calling dexreadclassdatamethod .
then it creates a structure method according to dexmethod inloadmethodfromdex .
during the initialization of method dexcomparenamedexcriptorandmethod is called to check whether it is a finalize method and then dexgetcode is invoked to fetch the code information from the dex file to populate method .
since the symbols of inline functions and static functions are not exported inlibdvm.so w el e t dexcomparenamedexcriptorandmethod instead of dexgetcode be the third dex data collection point.
executing methods.
native code can invoke java methods through java reflection or jni reflection using functions like dvminvokemethod dvmcallmethoda and dvmcallmethodv .
since they call dvminterpret for both fast interpreter and portable interpreter we select it as the fourth dex data collection point.
b. android runtime art during the installation of an app art invokes the tool dex2oat to compile the dex file to the oat file which is in elf format but contains both the dalvik bytecode and the compiled code.
if an app without oat file is being launched art performs the same action.
art can execute a method in the interpreter mode which is similar to dvm or the compiled code mode.
by default if a method has compiled code art runs its compiled code.
otherwise art interprets its dalvik bytecode.
if a packed app uses dex2oat to compile dex files containing real code into oat file packergrind obtains the dex file according to the arguments passed to dex2oat .
for the methods executed in the interpreter mode packergrind also has four basic dex data collection points.
parsing dex files.
similar to dvm dexfile represents the dex file in runtime which contains the information of classes and methods.
the class constructor of dexfile i.e.
dexfile will read the dex file in memory and parse it similar to dexfileparse indvm .
therefore we choose dexfile as the first dex data collection point.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
loading classes.
defineclass of class classlinker is used to load and parse each class in the dex file and return an instance of class class to represent the class in runtime.
hence we select defileclass as the second dex data collection point.
resolving methods.
art uses artmethod to represent each method of a class and the instance of artmethod for a method is initialized in loadmethod .
therefore we let it be the third dex data collection point.
executing methods.
invoke of the class artmthod inart is invoked when a java method is called by java reflection and jni reflection.
hence we select invoke as the fourth dex data collection point.
iv .
p acker grind a. overview data collection dex reconstructionstatic analysis report analysisrecovery analysis monitoring dex file collection points fig.
the iterative process realized by packergrind .
to be adaptive to the evolution of packers packergrind adopts the iterative process shown in fig.
to recover dex files.
this process consists of three tasks in each run.
more precisely when running a packed app in smartphone packergrind monitors its behaviors from three layers including runtime system and instruction and generates a tracking report.
at the same time packergrind collects dex data at specified collection points and reconstructs dex files by the end of each run.
then it performs static analysis on the recovered dex files.
users determine whether new collection points are needed according to the tracking report and the result of static analysis because the basic data collection points described in section iii may not be enough for packergrind to collect all data of the original dex file.
we propose basic protection patterns in section iv e to help users determine additional collection points if needed.
based on these patterns we have identified all collection points for packers accessible to us as described in section v. after adding the new collection points packergrind will run the process one more time and repeat this procedure until the dex file is correctly recovered.
fig.
shows the architecture of packergrind .
it consists of three components for finishing the three tasks in the iterative process.
the monitoring component section iv b tracks the behavior of packed apps at three layers and generates the tracking report.
the recovery component section iv d automatically gathers dex data at selected collection points and reconstructs the dex file.
the analysis component section iv e performs static analysis on the dex file dumped at each run and determines whether new data collection points are needed.
we develop packergrind based on v algrind and therefore it runs in real smartphone instead of emulator.packergrindmonitoringruntime tracking dex file parsing class loading jni loading jni invoking system tracking memory management memory copy move instruction tracking storeg statement store statement analysis recovery file operation fig.
architecture of packergrind .
b. monitoring runtime layer to locate the structure dexfile which represents a dex file in runtime and collect dex data from the four basic data collection points section iii packergrind monitors the arguments and the returns of the selected functions in table i using the function wrapping technique .
for example by wrapping dexfileparse with the wrapper function dexfileparse wrapper we can obtain the arguments passed to dexfileparse and its return.
table i wrappers for tracking dex and dvm related events.
category wrapped functions tracked information dex datadexfileparse dex file parsing dvmclassdefine class loading dexcomparenamedescriptorandmethod method resolution dvminterpret dvmmterpstdrun method execution dvmcalljnimethod jni invocation dvminvokemethod java reflection dvmcallmethodv dvmcallmethoda jni reflection native module dvmloadnativecode native code loading table i lists two set of functions.
one includes the functions related to the basic dex data collection points and the function dvmcalljnimethod because some packers use native code to modify java methods through jni.
moreover it contains the functions related to java reflection and jni reflection i.e.
dvminvokemethod dvmcallmethodv dvmcallmethoda because they are used by some packers to invoke java methods.
the other set has dvmloadnativecode because it will be called when system.load orsystem.loadlibrary is used to load native module.
since native modules allow packed apps to release or modify the dex data we wrap dvmloadnativecode to track such behaviors.
system layer packed apps can release and modify the dex data in memory by calling system library functions and system calls through its native module.
since such behaviors cannot be monitored at the runtime layer packergrind tracks them at the system layer by wrapping memory management functions e.g.
allocation free mapping etc.
file operations e.g.
open read write and close and data movement functions e.g.
memcpy strcpy etc.
.
it also traces the invocation of some system calls e.g.
sys map sys unmap and sys protect because they can be used by packed apps to allocate memory release memory and change memory access permissions respectively.
packergrind maintains a surveillance memory list for the ranges of memory that may be used to store the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dex data and records the operations on them in tracking report.
packergrind also wraps some functions for special purposes.
for example some packers adopt timeout mechanism for anti unpacking e.g.
ijiami .
more precisely if the unpacking process takes a time longer than the packer s timeout threshold the app crashes.
to address this issue we wrap the system call sys gettimeofday to modify the timestamps returned to the packer so that its timeout mechanism will not be activated.
users can use packergrind to track more functions if necessary.
instruction layer packergrind instruments store instructions to monitor operations for modifying dex files because packed apps can write and modify dex data in memory directly through its native code instead of invoking memory copy or move functions.
packergrind skips system libraries because no system library functions except memory copy and move functions which are wrapped at the system layer will modify dex files.
packergrind maintains a system library memory list for the memory regions of system libraries and uses it to determine whether an instruction belongs to system libraries.
to monitor memory modifications packergrind inserts an intermediate representation ir of function invocation statement before ist storeg andist store statements that are translated from packed apps native code by v algrind .
in this irstatement the instruction tracking function will be called to check whether the target address is in the surveillance memory list.
if so packergrind records the target address operand value and instruction address in the tracking report.
c. tracking report a tracking report contains three major types of information and its length depends on the app s execution time.
dex file.
when a new dex file represented by dexfile is found packergrind parses dexfile and records the memory information about the dex file e.g.
dex file header classes methods and codes .
memory modification.
packergrind maintains a dex file list containing the memory ranges of all dex files in the runtime.
when functions and instructions for memory modification are identified packergrind checks whether the target addresses are in the memory range of a dex file.
if so the modification information is written to the tracking report.
at the system layer this information includes the invoked function target address the dex structure to which the target address belongs e.g.
dex header field and the value written to the target address.
at the instruction layer this information includes instruction address instruction types i.e.
ist storeg andist store target address target address information and the stored value.
method invocation.
at the runtime layer and the system layer the invocation and the return of any wrapped function are logged into the tracking report with the parameters and the return values.
d. recovery it collects the dex data and reconstructs dex files.
dex data collection in each run packergrind starts collecting dex data after a dexfile is identified because it represents a dex file.
once the dex file is located throughdexfile packergrind initializes a shadow memory for storing the collected dex data items belonging to this dex file and then copies the data items to the shadow memory.
when a new dex data item is collected packergrind firstly checks whether the shadow memory for this data item exists.
if so packergrind copies this data item to the shadow memory.
otherwise packergrind creates a new shadow memory for this data item copies it to the shadow memory and changes the corresponding offset to this item in the shadow memory.
dex file assembling after collecting dex data packergrind assembles them into a dex file.
since a packer can release dex data in discontinuous memory areas there will be more than one shadow memory allocated for storing the collected dex data.
therefore packergrind allocates a continuous memory and assembles the collected dex data together to reconstruct dex files.
specifically packergrind performs a two step dex file construction.
first it divides the collected dex data items into different groups according to their types.
for example packergrind groups all class def item s together to assemble class defs .
after that these groups of data will be put together according to the dex format.
by so packergrind can obtain the offsets of the dex data items and the sizes needed for such data structures.
second packergrind allocates a continuous memory region and copies the collected data to it starting from their group offsets.
for each data structure packergrind updates its members according to the offsets of the data structures.
for example when a class data item is copied into the continuous memory region we will update the corresponding class def item.class data off .packergrind will recalculate the meta data of dex header after all data structures are copied into the continuous memory region to ensure the validity of dex file.
eventually packergrind dumps the memory region and outputs the dex file.
e. analysis we analyze the dumped dex file and the tracking report to achieve three purposes.
first since packed apps usually use jni methods i.e.
native code to dynamically modify dex files in memory and the dumped dex file may contain unexplored paths to jni methods we conduct static bytecode analysis to look for such paths.
second we inspect the tracking report to determine whether new data collection points are needed.
third we identify more information about the discovered jni methods from the result of cross layer monitoring.
static bytecode analysis we employ intellidroid to determine how to trigger the jni methods in the dumped dex files through statical analysis.
given an app and a set of targeted jni methods intellidroid can help us find the execution paths leading to these methods as well as the corresponding input.
thus we first extract jni methods from the dex files and let them be the target methods and then use intellidroid to look for the execution paths leading to them with event handlers as the entry points.
after that we drive the app to execute the target jni methods following the corresponding paths.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
syscall open data dalvik cache data app demo .killerud .gestures .apk classes .dex flag 0x00020000 fd first dex file is opened and tracking starts ........ invoke dvmloadnativecode data app lib demo .killerud .gestures libmobisec .so load the native library named libmobisec.so return dvmloadnativecode data app lib demo .killerud .gestures libmobisec .so invoke dvmcalljnimethod pdexfile 0x05f3ef40 mth lcom ali mobisecenhance stubapplication attachbasecontextit vl jni method attachbasecontextit vl is invoked syscall open 0x61c6faf0 data data demo .killerud .gestures files libmobisecx1 .so flag 0x00020042 fd file named libmobisecx1.so is opened and file handler is syscall mmap off 0x00000000 0x375b6000 0x375b7a58 flat rw prot 0x2 fd file lbmobisec1.so is mapped to memory range 0x375b6000 0x375b7a58 invoke dexfileparse file 0x375b6000 0x375b7a58 flag kdexparsedefault pdexfile 0x00000000 dexfileparse is invoked to parse memory range 0x375b6000 0x375b7a58 return dexfileparse file 0x375b6000 0x375b7a58 flag kdexparsedefault pdexfile 0x05f44970 dexfileparse returns results pdexfile 0x05f44970 syscall close fd file lbmobisec1.so is closed 3759dc87 executable store a 0x375b654c v 0x24 interfacesoff pdexfile 0x05f44970 classidx the interfaceoff classidx value is modified by native code 3759e1f3 executable store a 0x375b6b2a v 0x80 class data item pdexfile 0x05f44970 classidx the code data item of the class classidx is modified by native code 3759e1f9 executable store a 0x375b6b2b v 0x80 class data item pdexfile 0x05f44970 classidx the code data item of the class classidx is modified by native code ....... 3759e205 executable store a 0x375b6bc7 v 0x80 class data item pdexfile 0x05f44970 classidx the code data item of the class classidx is modified by native code 3759e209 executable store a 0x375b6bc8 v 0x00 class data item pdexfile 0x05f44970 classidx the code data item of the class classidx is modified by native code return dvmcalljnimethod pdexfile 0x05f3ef40 mth lcom ali mobisecenhance stubapplication attachbasecontextit vl jni method attachbasecontextit vl returns invoke dvmdefineclass pdexfile 0x05f44970 class lhiof enigma android gestures gesturesdemoactivity dvmdefineclass is invoked to define class gesturesdemoactivity return dvmdefineclass pdexfile 0x05f44970 class lhiof enigma android gestures gesturesdemoactivity dvmdefineclass returns.
fig.
tracking report for an app packed by the ali packer.
tracking report analysis we provide python scripts to analyze the tracking report in order to recognize the protection patterns and determine whether new collection points are needed.
by exploiting the insight that a portion p e.g.
dex header methods etc.
of a dex file should be valid right before it is being used we define four basic protection patterns for p it is changed to valid value before its first use fmt it is modified to invalid value after its last use tmf it is altered to valid value before being used and turned to invalid after the use fmtmf it is always valid t .
although the basic protection patterns are by no means comprehensive they cover all packed samples accessible to us.
users can define new patterns after studying the tracking report.
to recognize the protection patterns we first collect the method invocation and the memory modification information from the tracking report.
according to the target address information of each modification operation m we identify which portion of the dex file is modified by m. by checking the method invocation information we determine when the portion is used.
given each portion p we regard its content is valid when it is being used.
a quick approach to detect invalid portions is to apply static analysis tool to the dumped dex file and see whether there is any parsing error.
during the first run packergrind collects dex data at the basic data collection points and hence the dumped dex file may include invalid portion.
if so we infer the protection pattern and select new data collection points i.e.
when its content is valid .
after that we execute packergrind again to collect more valid portions.
we use an app packed by ali packer as an example to illustrate this process.
fig.
shows the tracking report.
at line dvmloadnativecode is called to load the native library libmobisec.so .
then the jni method attachbasecontextit vl of class lcom ali mobisecenhance stubapplication is called by dvmcalljnimethod line and it returns at line .
the information about the instruction layer modifications is from line to line .
at line 3759dc87 and executable are the instruction address and the executable permission of the address respectively.
store indicates the instruction type which is ist store at line .
a0x375b654c and v0x24 are the target address and the stored value respectively.
interfacesoff pdexfile 0x05f44970 classidx denotes that the target address is the field interfacesoff of the 5th class public void oncreate bundle savedinstancestate super .oncreate savedinstancestate setcontentview c0000r .layout .main this .display windowmanager getsystemservice window .getdefaultdisplay this .mlibrary gesturelibraries .fromrawresource this c0000r .raw.gestures if !this .mlibrary .load finish findviewbyid c0000r .id.gestures .addongestureperformedlistener this a the original oncreate .
public void oncreate bundle savedinstancestate a.v this new object savedinstancestate b the oncreate in an packed app.
invoke dvmcalljnimethod pdexfile 0x05f41a90 mth lcom baidu protect a v vill jni reflection landroid app activity oncreate vl jni reflection landroid app activity setcontentview vi jni reflection landroid app activity getsystemservice ll jni reflection landroid view windowmanagerimpl getdefaultdisplay l jni reflection landroid gesture gesturelibraries fromrawresource lli jni reflection landroid gesture gesturelibraries resourcegesturelibrary load z jni reflection landroid app activity findviewbyid li jni reflection landroid gesture gestureoverlayview addongestureperformedlistener vl return dvmcalljnimethod pdexfile 0x05f41a90 mth lcom baidu protect a v vill c tracking report of a.v .
fig.
the method oncreate before and after packing and the tracking report of a.v .
in the dex file which is represented by a dexfile in memory address 0x05f44970 .
at line the field interfaceoff of the 5th classes classidx in the dex file is modified.
from line to the class data item s of classes from classidx toclassids in the dex file are modified by the store i.e.
ist store instruction.
finally the class gesturesdemoactivity is defined by dvmdefineclass at line and .
the tracking report shows that the class data item s of all classes are filled with valid values in the jni method attachbasecontextit vl before dvmdefineclass .
since the runtime loads classes in dvmdefineclass based onclass data item s the class data item s contents are valid after calling attachbasecontextit vl .
that is class data item follows the fmt protection pattern.
hence we can collect the dex data after attachbasecontextit vl returns.
since packergrind collects dex data when it is defined by dvmdefineclass by default the collected content is valid and no more run is needed.
native methods inspection a packer can re implement an app s java methods in the native module and then call them through jni.
although packergrind is not designed to reverseengineer the native code for reconstructing the bytecode it can still provide useful information about the native methods authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
thanks to its cross layer monitoring capability.
more precisely packed apps have to use jni reflection i.e.
dvmcallmethodv ordvmcallmethoda to invoke android framework apisi n java.
since packergrind has wrapped these functions it can provide rich information about the native methods.
for example fig.
shows the method oncreate in the original app and that in the app packed by baidu.
it shows that the method oncreate has been re implemented in native code which invokes android framework apis through jni reflection.
in other words after packing the original implementation of oncreate is replaced with the invocation of the native method a.v .
from the tracking report of a.v shown in fig.
6c we can infer the original implementation of oncreate .
for example the method oncreate of class android app activity is invoked at line .
correspondingly as shown in fig.
6a the method oncreate of the mainactivity s super class android app activity is invoked at line .
note that other unpackers e.g.
cannot profile such behavior.
f .
implementation on art we adopt similar methods to monitor packed apps running inart .
different from dvm that provides only two functions to invoke a java method in native code art provides call type method functions and callstatic type method functions to call non static methods and static methods respectively.
type indicates the type of the method s return value.
to call a native method through jni art invokes the functions artinterpretertocompiledcodebridge or art quick generic jnitrampoline depending on whether the native method contains compiled code or not.
both of them eventually establish the jni calling environment according to the jni call convention in art .
before the execution of native code the functions jnimethodstart or jnimethodstartsynchronized will be called depending on whether the native method is synchronized or not.
we wrap these two functions to track the invocation of jni methods and get the name of jni methods inart .
since art is implemented in c all dex data structures are stored in class objects.
we parse such class objects and recover dex data structures from them.
packergrind currently supports the art in android .
and it reuses the modules at the system layer and instruction layer for dvm .
v. e v alua tion we conduct extensive experiments to evaluate packergrind by answering the following five questions.
q1 can packergrind be adaptive to the evolution of packers and identify their protection mechanisms?
q2 can packergrind correctly recover dex files?
q3 is packergrind better than other available unpackers?
q4 can packergrind facilitate the analysis of malware?
q5 what is the overhead of packergrind?
a. data set we use two sets of packed apps to evaluate packergrind .
the first set has packed apps with ground truth.
more precisely we download randomly selected open source apps from f droid and then upload them to online commercial packing services qihoo ali bangcle tencent baidu ijiami in mar.
denoted as db and mar.
denoted as db to construct packed apps.
the second set consist of packed malware samples from palo alto networks .
these samples were packed by eleven packers including ali apkprotect baidu bangcle ijiami naga qihoo tencent liapp netqin and payegis .
we conduct the experiments in both android .
with dvm and android .
with art on a nexus smartphone .
packergrind monitors the protection patterns of these packed apps and recover their dex files.
b. protection mechanisms using packergrind we reveal the protection mechanisms adopted by packers each of which has two versions for db and db individually.
as shown in table ii packers are evolving with new techniques and hence unpackers should be adaptive to the evolution.
packergrind can unpack apps protected by all mechanisms except the re implement method .
table ii protection mechanisms adopted by six packers in db and db .
the symbol before or after denotes whether a packer in db or db uses the mechanism or not.
packer qihoo ali bangcle tencent baidu ijiami dynamically release dex check check check check check check check check check check check dynamically modify dex check check check check check check check customized dex parsing check check re implement method check anti debug e.g.
ptrace check check check all but tencent packer of db release dex files to memory dynamically.
in db all packers except baidu dynamically modify selected structures in the dex file.
for example ali packer changes the class data item of each class in the loaded dex file from invalid value to valid one before the class is defined.
moreover ijiami packer sets the dex file header with valid value before dexfileparse is called and changes it to invalid value after using dexfileparse .
qihoo packer and ijiami packer of db use their own functions rather than the standard runtime functions to parse certain structures of the dex file.
qihoo packer invokes the native code in its library libjiagu.so instead of dvmdefineclass to load classes.
ijiami packer parses the methods of the loaded classes again using the native code in its library libexec.so and changes the instruction offsets of those methods to valid values right before dvmdefineclass returns.
baidu packer of db re implements all oncreate functions using native code with the same functionality.
bangcle packers uses ptrace to protect the app process from being attached by debugging tools while ijiami packer of db periodically searches for the string com.android.reverse to detect zjdroid .
answer to q1 packergrind is adaptive to the evolution of packers and can identify the protection mechanisms adopted by various packers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
c. recovering dex files number of runs required for determining all dex data collection points table iii shows that packergrind needs one run for ali bangcle tencent and the new version of baidu packers i.e.
db .
it takes two runs to handle qihoo ijiami and the old version of baidu packers i.e.
db .
once the dex data collection points for a packer are identified packergrind can recover the dex files in one run.
table iii number of runs required for determining all dex data collection points.
packer qihoo ali bangcle tencentbaidu db baidu db ijiami number of runs2 qihoo.
since qihoo packer parses the protected dex file using native code in its library libjiagu.so instead of standard functions packergrind locates the first dex file when dvmintepret is invoked i.e.
the fourth dex data collection point .
from the tracking report we notice that theclass data off is changed to zero after its library libjiagu.so is loaded.
since packergrind does not find the dex file at other collection points we add a new data collection point right before dvmloadnative for the second run and then the correct dex file is recovered.
public void oncreate bundle bundle string str lxxx oncreate001 landroid os bundle v a.d str oncreate001 bundle a.e str private void oncreate001 bundle savedinstancestate super .oncreate savedinstancestate setcontentview c0000r .layout .main this .display windowmanager getsystemservice window .getdefaultdisplay this .mlibrary gesturelibraries .fromrawresource this c0000r .raw.gestures if !this .mlibrary .load finish findviewby id c0000r.id.gestures .addongestureperformedlistener this fig.
content of oncreate001 after 2nd run.
baidu.
for the samples packed by the old version of baidu packer i.e.
in db we find that the method oncreate001 which is recovered after the first run is empty.
hence we add a new data collection point after a.d by analyzing the tracking report and the dex file recovered in the first run.
in the second run the dex file is successfully recovered e.g.
fig.
.
ijiami.
after the first run we observe that all instructions of the methods in the mainactivity are zero.
by analysing the tracking report we find that the packed apps modify the instructions of method s after method resolution.
moreover the instructions of method s are different from those of the corresponding code item structure in dex file.
therefore we add a new data collection point after dvmdefineclass for the second run and then the dex file is successfully recovered.
correctness of recovered dex files we assess the correctness of recovered dex files from three aspects.
first we apply five popular static analysis tools which can reverseengineer dex files to the recovered dex files because they adopt different verification strategies to check dex files.
these tools include baksmali dexdump dex2jar jadx and ida pro .
packergrind can successfullyrecover the dex files of almost all samples.
the only exception comes from dex2jar when it handles the recovered dex files from tencent samples from db .
it failed to transform the dalvik bytecodes into java bytecodes due to dex optimization conducted by dvm .
table iv difference between the original dex file and recovered dex file from the samples of db db circleminusand represent the recovered dex file has additional code less code and the same code compared with the original dex file respectively .
packer qihoo ali bangcle tencent baidu ijiami db db circleminus second we compare the difference between the original dex files and the recovered dex files.
we randomly select packed samples samples packed by each packer decompile the dex files into java codes and then manually compare the decompiled java codes from the original dex files and those from the recovered dex files.
the comparison results are summarized in table iv.
the recovered dex files are the same as the original dex files for qihoo packer ijiami packer ofdb ali packer of db and tencent packer of db .
ali packer of db adds two classes to the original dex files each of which has one field and three empty methods.
it also inserts the invocation of exit.b exit.a to the beginning of every java method.
exit.a just returns false and exit.b is empty.
tencent packer of db adds two classes to each packed sample while ijiami packer of db inserts five classes.
for bangcle packer there are six additional classes and twelve additional classes added to the packed samples of db and db respectively.
in the main activity class a method named com sec plugin action app started is inserted and invoked at the beginning of the method smallemphoncreate .
bangcle packer of db creates an intent named com.secneo.plugin.action.app started and broadcasts it in com sec plugin action app started .
bangcle packer of db further creates a new monitoring thread in com sec plugin action app started .
baidu packer of db adds two classes to each packed sample and re implements all the oncreate methods using the dynamic code modification technique.
baidu packer of db inserts one additional class to each packed app but replaces the implementation of oncreate methods with native codes.
therefore for these methods the recovered java code is less than the original java code.
answer to q2 packergrind can correctly recover all dex code that are not removed by packers as well as the additional classes methods inserted by packers.
even for the methods that are re implemented in native code packergrind can still recover useful sematic information based on which it is possible to regenerate the dex code.
d. comparison while two recent tools dexhunter and appspear claimed to be general unpackers only dexhunter s source code is available.
hence we only compare packergrind dexhunter authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and android unpacker using randomly selected samples from six packers i.e.
samples from each packer .
we perform two step checking on the correctness of recovered dex files.
first the dex files can be disassembled by baksmali.
second we compare them with the dex files of the original apps.
the failure in any step will lead to in table v indicating unsuccessfully unpacking.
table v comparison among android unpacker dexhunter and packergrind .
packer qihoo ali bangcle tencent baidu ijiami android unpacker dexhunter packergrind android unpacker recovers dex files by attaching to the app process through ptrace and dumping dex files in memory.
however it cannot attach to packed apps with anti debugging capability.
moreover for packers that dynamically release and modify dex files android unpacker cannot obtain the valid dex files because it does not know the proper dumping moment.
packergrind can successfully recover all dex files from six packers.
we mark baidu samples with because the dex code in oncreate of those samples has been re implemented in native code as detailed in section iv e .
although packergrind is not designed to reverse engineer native code it can still provide very useful information about the native method as explained in section iv e. dexhunter cannot correctly recover the dex files for samples from qihoo baidu and ijiami.
for qihoo samples the dex files dumped by dexhunter only contain stub classes instead of real code such as com.qihoo.util.configuration and com.qihoo.util.stubapplication because qihoo packer uses its own functions instead of runtime methods monitored by dexhunter to load classes.
for baidu samples the dex files dumped by dexhunter cannot be disassembled because their dex headers have been modified by the packed apps.
hence they cannot be recognized by de compilers.
dexhunter also cannot recover the original dalvik bytecodes of oncreate .f o r ijiami samples dexhunter cannot unpack them successfully due to the time out checking mechanism utilized by ijiami.
more precisely the packed apps will check the existence of a long running task which exceeds a time threshold and exit if found.
therefore the process of dexhunter will stop because its unpacking operations takes such a long time that the packed app exits quickly.
answer to q3 packergrind outperforms other available unpacking tools i.e.
android unpacker and dexhunter .
e. unpacking malware we apply packergrind to malware samples packed by eleven popular packers and successfully recover all dex files.
by performing static analysis on these dex files we find that malware often employed packers to hide the invocations of sensitive apis requiring permissions.
given a dex file we scan all sensitive apis in it and count how many permissions are required according to the mapping between permissions and apis from pscout .
it is worth noting that many detectionsystems leverage sensitive apis and permissions to discover mobile malware .
letppandprdenote the number of permissions required by a packed app and its recovered dex file respectively.
we calculate the means of ppandprfor all malware samples packed by a packer.
the result listed in table vi shows that from the recovered dex files we find more evidences i.e.
sensitive apis requiring certain permissions to explain why a malware sample needs certain permissions.
for example for naga samples before unpacking we cannot find any api invocation requiring the permissions in the manifest i.e.
pp .
malware detection system may think that these samples just overclaim the permissions without using them.
in contrast after unpacking we can identify api invocations that require permissions in the manifest on average i.e.
pr .
letapandarindicate the number of sensitive api invocations in a packed app and its recovered dex file respectively.
we compute the means of apandarfor all malware samples packed by a packer.
the result listed in table vi obviously indicates that many more sensitive apis can be found from the recovered dex file.
for example no sensitive api invocation is found in malware samples packed by ijiami whereas on average .
sensitive api invocations can be found from the recovered dex files.
answer to q4 packergrind can facilitate malware detection by exposing the hidden malicious components.
f .
overhead .
.
.
.
.
.
.
.
.
nativejavaoverall score of cf benchmarkwith packergrind with valgrind without valgrind fig.
cf benchmark results.
to evaluate the overhead introduced by packergrind w e run cf b enchmark times on nexus without v algrind with v algrind and with packergrind respectively.
the scores ofcf b enchmark on the same smartphone without v algrind serve as the baseline for comparison.
fig.
shows the results obtained in three scenarios which include the overall scores the scores of java operations the scores of native operations.
we can see that v algrind incurs .
times slowdown and packergrind brings .
times slowdown on average compared with the baseline.
since packergrind is based on v algrind it is still efficient because it is only .
times slower than v algrind.
compared with the dynamic analysis systems based on emulator that may introduce times slowdown packergrind has acceptable efficiency.
answer to q5 packergrind introduces acceptable low overhead compared to v algrind and emulator based dynamic systems.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vi permissions and sensitive api calls in malware samples before and after unpacking by packergrind .
packer ali apkprotect baidu bangcle ijiami naga qihoo tencent liapp netqin payegis number of samples average value of pp .
.
.
.
.
.
.
.
.
.
.
average value of pr .
.
.
.
.
.
.
.
.
.
.
average value of ap .
.
.
.
.
.
.
.
.
.
.
average value of ar .
.
.
.
.
.
.
.
.
.
.
vi.
d iscussion packergrind can only recover the dex data after the methods for releasing the real code are invoked.
the majority of existing packers execute such methods which are usually jni methods when a packed app is launched to avoid performance degradation.
we also use intellidroid to trigger the execution of such methods.
since packers may delay the execution of such methods after knowing the mechanism of packergrind we will leverage advanced input generator for android to enhance packergrind in future work.
packergrind is based on v algrind.
similar to the antiemulator methods packed apps may detect the existences ofpackergrind and then cease releasing the real code.
for example they could check the app starting command or count the time used to finish some operations.
to address this issue we could change the return value of selected apis to hide the existence of packergrind or insert additional irstatements to modify the registers and force the app to execute forward.
packergrind currently focuses on the operations related to dex files.
packed apps may hide the real code by modifying the compiled code in oat files directly.
moreover if packed apps load different code into the same memory and execute them under different conditions packergrind cannot decide which code is real.
since packergrind can trace such modifications and monitor code execution we will address these issues by employing more semantic information in future work.
vii.
r ela ted work although there are already many studies on code packing unpacking almost all of them focus on x86 native codes .
the unpacking techniques for x86 binaries cannot be applied to packed android apps because android and the oses running on x86 cpu have different architectures and execution models let alone the different formats of their executables.
for example android packers need to protect both the dex code and the native code if any whereas traditional packers only hide native code .
since mobile malware adopts packers to evade the detection a few studies on unpacking apps were proposed recently from both academia and industry .
however all of them adopt the one pass strategy i.e.
dump the dex data at fixed points and therefore they can be easily evaded by the latest packers.
for example dwroiddump only collects the dex data in dvmdexfileopenfromfd when a dex file is mapped to memory by the runtime.
dexhunter and appspear are proposed to be general unpacker by customizing android runtime.
dexhunter inserts code in defineclassnative to extract dex files from memory.
however it may dump invalid dex files since packers can release thereal code after this function.
appspear instruments the dalvik interpreter to collect required data during method execution and then reconstruct the dex file.
unfortunately appspear may also dump invalid data because it relies on dvm s parsing methods to collect dex data.
note that packers could make these methods return inaccurate results and use their own functions to parse dex files.
moreover appspear does not support art.
in contrast packergrind adopts an iterative approach and conducts cross layer monitoring so that it is adaptive to the changes of packers.
experimental results show that it outperforms existing approaches.
moreover it supports both dvm and art.
existing cross layer monitoring tools for android cannot collect all necessary information and fulfill the requirement for handling packed apps.
for example profiledroid cannot handle packed apps because it relies on apktool to conduct static analysis.
taintdroid neither supports art nor collects information at the runtime system and instruction layers.
droidscope and ndroid rely on qemu which can be detected by packers .
viii.
c onclusion the evolving app packers can easily circumvent existing unpackers because they adopt the one pass strategy and hence are not adaptive to the changes of packers.
to address this challenging issue we propose a novel iterative process and develop packergrind to recover the dex files from packed apps.
with the capability of conducting cross layer profiling in real smartphones packergrind can effectively monitor the packing patterns and adapt to the evolution of packers for extracting dex files.
our extensive experiments with real packed apps illustrate the effectiveness and efficiency of packergrind .
we will release packergrind to the community only for research purposes to prevent illegal use.
interested users please send an email to packergrind gmail.com for the system using your university s email account.
the first data set and the hash values of the samples in the second data set will be available at acknowledgement we thank the anonymous reviewers for their helpful comments.
we appreciate the collaboration with mobile malware research team at palo alto networks.
this work is supported in part by the hong kong grf no.
polyu 13e 16e hong kong itf no.
uim hkpolyu research grants g ua3x g ybjx shenzhen city science and technology r d fund no.
jcyj20150630115257892 the us national science foundation grant no.
ccf and office of naval research grant no.
n00014 n00014 and n00014 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.