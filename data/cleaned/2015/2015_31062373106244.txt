droid an energy aware mutation testing framework for android reyhaneh jabbarvand and sam malek school of information and computer sciences university of california irvine usa jabbarvr malek uci.edu abstract the rising popularity of mobile apps deployed on battery constrained devices underlines the need for effectively evaluating their energy properties.
however currently there is a lack of testing tools for evaluating the energy properties of apps.
as a result for energy testing developers are relying on tests intended for evaluating the functional correctness of apps.
such tests may not be adequate for revealing energy defects and inefficiencies in apps.
this paper presents an energy aware mutation testing framework called droid that can be used by developers to assess the adequacy of their test suite for revealing energy related defects.
droid implements fifty energy aware mutation operators and relies on a novel automatic oracle to determine if a mutant can be killed by a test.
our evaluation on real world android apps shows the ability of proposed mutation operators for evaluating the utility of tests in revealing energy defects.
moreover our automated oracle can detect whether tests kill the energy mutants with an overall accuracy of thereby making it possible to apply droid automatically.
ccs concepts software and its engineering software testing and debugging keywords software testing mutation testing energy testing android acm reference format reyhaneh jabbarvand and sam malek.
.
droid an energy aware mutation testing framework for android.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction energy is a demanding but limited resource on mobile and wearable devices.
improper usage of energy consuming hardware components such as gps wifi radio bluetooth and display can drastically discharge the battery.
recent studies have shown energy to be a major concern for both users and developers .
in spite of that many mobile apps are abound with energy defects.
the majority of apps are developed by start up companies and individual developers that lack the resources to properly test their programs.
the resources they have are typically spent on testing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
functional aspects of apps.
however tests designed for testing functional correctness of a program may not be suitable for revealing energy defects.
in fact even in settings where developers have the resources to test the energy properties of their apps there is generally a lack of tools and methodologies for energy testing .
thus there is an increasing demand for solutions that can assist the developers in identifying and removing energy defects from apps prior to their release.
one step toward this goal is to help the developers with evaluating the quality of their tests for revealing energy defects.
mutation testing is an approach for evaluating fault detection ability of a test suite by seeding the program under test with artificial defects a.k.a mutation operators .
mutation operators can be designed based on a defect model where mutation operators create instances of known defects or by mutating the syntactic elements of the programming language.
the latter creates enormously large number of mutants and makes energy aware mutation testing infeasible as energy testing should be performed on a real device to obtain accurate measurements of battery discharge.
additionally energy defects tend to be complex e.g.
manifest themselves through special user interactions or peculiar sequence of external events .
as rene et al.
showed complex faults are not highly coupled to syntactic mutants energy aware mutation operators should be designed based on a defect model.
in this paper we present droid an energy aware mutation testing framework for android.
in the design of droid we had to overcome two challenges an effective approach for energy aware mutation testing needs an extensive list of energy anti patterns in android to guide the development of mutation operators.
an energy anti pattern is a commonly encountered development practice e.g.
misuse of android api that results in unnecessary energy inefficiencies.
while a few energy anti patterns such as resource leakage and suboptimal binding have been documented in the literature they do not cover the entire spectrum of energy defects that arise in practice.
to that end we first conducted a systematic study of various sources of information which allowed us to construct the most comprehensive energy defect model for android to date.
using this defect model we designed and implemented a total of fifty mutation operators that can be applied automatically to apps under test.
an important challenge with mutation testing is the oracle problem i.e.
determining whether the execution of a test case kills the mutants or not.
this is particularly a challenge with energy testing since the state of the practice is mostly a manual process where the engineer examines the power trace of running a test to determine the energy inefficiencies that might lead to finding defects.
to address this challenge we present a novel and fully automated oracle that is capable of determining whether an energy mutant is killed by comparing the power traces of tests executed on the original and mutant versions of an app.
esec fse september paderborn germany reyhaneh jabbarvand and sam malek we have extensively evaluated droid using open source android apps.
our experiments show that droid is capable of effectively and efficiently evaluating the adequacy of test suites for revealing energy defects.
we found statistically significant correlation between mutation scores produced by droid and test suites ability in revealing energy defects.
furthermore droid s automated oracle showed an average accuracy of making it possible to apply the mutation testing techniques described in this paper in a fully automated fashion.
finally using droid we identified previously unknown energy defects in the subject apps.
reporting these defects to developers of them were verified as bugs and are fixed to date using the patches we provided to developers.
this paper makes the following contributions a comprehensive list of energy anti patterns collected from issue trackers android developers guide and android api reference.
design of fifty energy aware mutation operators based on the energy anti patterns and their implementation in an eclipse plugin which is publicly available .
a novel automatic oracle for mutation analysis to identify if an energy mutant can be killed by a test suite.
experimental results demonstrating the utility of mutation testing for evaluating the quality of test suites in revealing energy defects.
the remainder of this paper is organized as follows.
section provides an overview of our framework.
sections describes our extensive study to collect energy anti patterns from variety of sources and presents the details of our mutation operators with several coding examples.
section introduces our automated approach for energy aware mutation analysis.
section presents the implementation and evaluation of the research.
finally the paper outlines related research and concludes with a discussion of our future work.
framework overview figure depicts our framework droid for energy aware mutation testing of android apps consisting of three major components eclipse plugin that implements the mutation operators and creates a mutant from the original app runner profiler component that runs the test suite over both the mutated and original versions of the program profiles the power consumption of the device during execution of tests and generates the corresponding power traces i.e.
time series of profiled power values and analysis engine that compares the power traces of tests in the original and mutated versions to determine if a mutant can be killed by tests or not.
our eclipse plugin implements fifty energy aware mutation operators derived from an extensive list of energy anti patterns in android.
to generate mutants our plugin takes the source code of an app and extracts the abstract syntax tree ast representation of it.
it then searches for anti patterns encoded by mutation operators in ast transforms the ast according to the anti patterns and generates the implementation of the mutants from the revised ast.
after generating a mutant the runner profiler component runs the test suite over the original and mutant versions while profiling the actual power consumption of the device during execution of test cases.
this component creates the power trace for each test case that is then fed to the analysis engine.
analysis engine employs a novel algorithm to decide whether each mutant is killed or lived.
at a high level it measures the similarity between time series generated by each test after execution on the original and mutated versions of an app.
in so it accounts for distortions in the collected data.
if the temporal sequences of power values for a test executed on the original and mutated app figure energy aware mutation testing framework are not similar analysis engine marks the test as killed.
a mutant lives if none of the tests in the test suite can kill it.
the implementation of our framework is extensible to allow for inclusion of new mutation operators android devices and analysis algorithms.
in the following two sections we describe the details of our energy aware mutation operators and mutation analysis engine.
mutation operators to design the mutation operators we first conducted an extensive study to identify the commonly encountered energy defects in android apps which we call energy anti patterns .
to that end we explored bug repositories of open source projects documents from google and others describing best practices of avoiding energy inefficiencies and published literature in the area of green software engineering.
.
defect model and derivation of operators our methodology to collect the energy anti patterns was a keywordbased search approach.
we started by crawling the android open source project issue tracker and xda developers forum and searched for posts that have at least one of the following keywords energy power battery drain and consumption .
we then manually inspected these posts to find energy related issues as reported by users and developers.
the outcome of this step was a list of energyrelated issues and 295apps that possibly had instances of those issues.
we excluded commercial apps from the list since our study requires the availability of source code.
that left us with 130opensource apps for further investigation.
we then searched the issue tracker of the 130apps for the aforementioned keywords and narrowed down to 91open source apps that had at least one issue open or closed related to energy as reported in their issue tracker.
we considered apps whose energy issues were reproducible by the developers whether confirmed or fixed or had an explanation as to how to reproduce the issue which left us with 41apps.
moreover we studied the related literature and found 18additional open source apps with energy issues.
in the end we were able to identify 59open source apps with confirmed energy defects.
we manually investigated the source code of these 59apps to find misuse of android apis utilizing energy expensive hardware components e.g.
cpu wifi radio display gps bluetooth and sensors as reported in the corresponding bug trackers.
for example omim issue states app is using gps all the time or at least trying to use .
as a result we investigated usage of apis belonging tolocationmanager package in android.
as another example sipdroid issue states after using the app display brightness is increased almost full and its stays that way .
thereby we investigated the source code for apis dealing with the adjustment of screen brightness e.g.
getwindow .addflag flag keep screen on and getwindow .getattributes .screenbrightness .
209 droid an energy aware mutation testing framework for android esec fse september paderborn germany table list of proposed energy aware mutation operators.
category description of class mutation operators hardware type locationincrease location update frequency luf t luf d gps wifi radior change location request provider lrp c lrp a r i redundant location update rlu rlu p rlu d d voiding last known location lkl r connectivityfail to check for connectivity fcc r fcc a wifi radio bluetoothr i frequently scan for wifi fsw h fsw s r redundant wifi scan rws d use cellular over wifi ucw c ucw w i long timeout for corrupted connection ltc r i downloading redundant data drd d unnecessary active bluetooth uab r frequently discover bluetooth devices fdb h fdb s r redundant bluetooth discovery rbd d wakelockwakelock release deletion for cpu wrdc wrdc p wrdc d cpu wifid keep wakwfulbroadcastreceiver active wbr d wakelock release deletion for wifi wrdw wrdw p wrdw d d acquire high performance wifi wakelock hpw r displayenable maximum screen timeout mst displayi set screen flags ssf i use light background color lbc r enable maximum screen brightness msb i recurring callback and loophigh frequency recurring callback hfc t hfc s hfc a hfc h wifi radio cpu memory bluetooth displayr redundant recurring callback rrc d running an alarm forever raf d battery related frequency adjustmentbfa t l bfa t f bfa s l bfa s f bfa a l bfa a f bfa h l bfa h fi increasing loop iterations ili i sensorsensor listener unregister deletion sludsensorsd fast delivery sensor listener fdsl r investigating the source code of energy inefficient apps provided us with common mistakes that developers make or mistakes that have severe impact on the energy consumption of apps.
in addition we crawled android developers guide and android api reference for best practices related to energy consumption using the aforementioned keywords.
this way we found additional energy issues that either happen in specific use cases that are uncommon among apps or their impact cannot be readily observed by end users.
in total we identified 28types of energy anti patterns from our investigation which were used to design our energy aware mutation operators for the purpose of this work.
table lists our energy aware mutation operators.
we designed and implemented 50mutation operators column in table corresponding to the identified energy defect patterns grouped into 28classes column in table .
we also categorized these classes of mutation operators into 6categories which further capture the commonality among the different classes of operators.
each row of the table presents one class of mutation operators providing a brief description of the operators in the class the id of mutation operators that belong to the class list of the hardware components that the mutation operators might engage and modification types made by the operators r replacement i insertion d deletion .
due to space constraints in the following sections we describe a subset of our mutation operators.
details about all mutation operators can be found on the project website .
.
location mutation operators when developing location aware apps developers should use a location update strategy that achieves the proper tradeoff between accuracy and energy consumption .
user location can be obtained by registering a locationlistener implementing several callbacks and then calling requestlocationupdates method oflocationmanager to receive location updates.
when the app no longer requires the location information it needs to stop listening to updates and preserve battery by calling removeupdates1 public class trackactivity extends activity private locationmanager manager private locationlistener listener protected void oncreate manager getsystemservice location service listener new locationlistener public void onlocationchanged use location information to update activity manager .
requestlocationupdates network listener protected void onpause super .
onpause protected void ondestroy super .
ondestroy manager .
removeupdates listener figure example of obtaining user location in android oflocationmanager .
though seemingly simple working with android locationmanager apis could be challenging for developers and cause serious energy defects.
figure shows a code snippet inspired by real world apps that employs this type of api.
when trackactivity is launched it acquires a reference to locationmanager line creates a location listener lines and registers the listener to request location updates from available providers every minutes i.e.
or every meters change in location line .
listening for location updates continues until the trackactivity is destroyed and the listener is unregistered line .
we provide multiple mutation operators that manipulate the usage of locationmanager apis.
luf operators increase the frequency of location updates by replacing the second luf t or third luf d parameters of requestlocationupdates method with such that the app requests location notifications more frequently.
if luf mutant is killed more details in section it shows the presence of at least one test in the test suite that exercises location update frequency of the app.
such tests however are not easy to write.
for instance testing the impact of location update by distance 210esec fse september paderborn germany reyhaneh jabbarvand and sam malek protected void downloadfiles string link wifilock lock getsystemservice .
createwifilock lock .
acquire url url new url link connectivitymanager manager getsystemservice connectivity service networkinfo nets manager .
getactivenetworkinfo if nets .
isconnected httpurlconnection conn url .
openconnection conn .
connect code for downloading file from the url lock .
release figure example of downloading a file in android requires tests that mock the location.
to our knowledge none of the state of the art android testing tools are able to generate tests with mocked object.
thereby developers should manually write such test cases.
failing to unregister the location listener and listening for a long time consumes a lot of battery power and might lead to location data underutilization .
for example in figure listener keeps listening for updates even if trackactivity is paused in the background.
such location updates are redundant as the activity is not visible.
rlu mutants delete the listener deactivation by commenting the invocation of removeupdates method.
this class of mutants can be performed in onpause method rlu p ondestroy method rlu d or anywhere else in the code rlu .
killing rlu mutants specially rlu d and rlu p requires test cases that instigate transitions between activity lifecycle and service lifecycle to ensure that registering unregistering of location listeners are performed properly under different use cases.
.
connectivity mutation operators connectivity related mutation operators can be divided to networkrelated which engage the wifi or radio and bluetooth related.
mutation operators in both sub categories mimic energy anti patterns that unnecessarily utilize wifi radio and bluetooth hardware components which can have a significant impact on the battery discharge rate.
.
.
network mutation operators.
searching for a network signal is one of the most power draining operations on mobile devices .
as a result an app needs to first check for connectivity before performing any network operation to save battery i.e.
not forcing the mobile radio or wifi to search for a signal if there is none available.
for instance the code snippet of figure shows an android program that checks for connectivity first and then connects to a server at a particular url and downloads a file.
this can be performed by calling the method isconnected ofnetworkinfo .
fcc operator mutates the code by replacing the return value of isconnected with true fcc r or adds a conditional statement to check connectivity before performing a network task if it is not already implemented by the app fcc a .
fcc operators are hard to kill as they require tests that exercise an app both when it is connected to and disconnected from a network.
to that end tests need to either mock the network connection or programmatically enable disable network connections.
fcc r if true httpurlconnection conn url .
openconnection conn .
connect code for downloading file from the url another aspect of network connections related to energy is that energy cost of communication over cellular network is substantially1 public void discover int scan interval bluetoothadapter blue bluetoothadapter .
getdefaultadapter private runnable discovery new runnable public void run blue .
startdiscovery handler .
postdelayed this scan interval handler .
postdelayed discovery connecttopaireddevice transferdata handler .
removecallbacks blue figure example of searching for bluetooth devices in android higher than wifi.
therefore developers should adjust the behavior of their apps depending on the type of network connection.
for example downloads of significant size should be suspended until there is a wifi connection.
ucw operator forces the app to perform network operations only if the device is connected to cellular network ucw c or wifi ucw w by adding a conditional statement.
for ucw w network task is performed only when there is a wifi connection available.
for ucw c on the other hand the mutation operator disables the wifi connection and checks if a cellular network connection is available to perform the network task.
therefore killing both mutants requires testing an app using both types of connections.
ucw w wifimanager manager getsystemservice wifi service if manager .
iswifienabled httpurlconnection conn url .
openconnection conn .
connect code for downloading file from the url .
.
bluetooth mutation operators.
figure illustrates a code snippet that searches for paired bluetooth devices in android.
device discovery is a periodic task and since it is a heavyweight procedure frequent execution of discovery process for bluetooth pairs can consume high amounts of energy.
therefore developers should test the impact of discovery process on the battery life.
fbd mutation operator increases the frequency of discovery process by changing the period of triggering the callback that performs bluetooth discovery to e.g.
replacing scan interval with 0in line of figure .
apps can repeatedly search for bluetooth pairs using handlers realized in fbd h as shown in figure or scheduledthreadpoolexecuter realized in fbd s an example of which is available at .
killing fbd mutants requires test cases not only covering the mutated code but also running long enough to show the impact of frequency on power consumption.
failing to stop the discovery process when the bluetooth connections are no longer required by the app keeps the bluetooth awake and consumes energy.
rbd operator deletes the method call removecallbacks for a task that is responsible to discover bluetooth devices causing redundant bluetooth discovery.
killing rbd mutants may require tests that transit between android s activity or service lifecycle states e.g.
trigger termination of an activity service without stopping the bluetooth discovery task.
.
wakelock mutation operators wakelocks are mechanisms in android to indicate that an app needs to keep the device or part of the device such as cpu or wifi awake.
inappropriate usage of wakelocks can cause no sleep bugs and seriously impact battery life and consequently user experience.
developers should test their apps under different use case scenarios 211 droid an energy aware mutation testing framework for android esec fse september paderborn germany to ensure that their strategy of acquiring releasing wakelocks does not unnecessarily keep the device awake.
wakelock related mutation operators delete the statements responsible to release the acquired wakelock.
depending on the component that acquires a wakelock e.g.
cpu or wifi the type of defining wakelock e.g.
powermanager wakefulbroadcastreceiver and the point of releasing wakelock.
we identified and developed support for 8wakelock related mutation operators details and examples can be found at .
.
display mutation operators some apps such as games and video players need to keep the screen on during execution.
there are two ways of keeping the screen awake during execution of an app namely using screen flags e.g.
flag keep screen on to force the screen to stay on or increasing the timeout of the screen.
screen flags should only be used in the activities not in services and other types of components .
in addition if an app modifies the screen timeout setting these modifications should be restored after the app exits.
as an example of display related mutation operators mst adds statements to activity classes to increase the screen timeout to the maximum possible value.
for mst there is also a need to modify the manifest file in order to add the permission to modify settings.
mst changes to source code and manifest file settings .
system .
putint getcontentresolver screen off timeout integer .
max value uses permission android name permission .
write settings .
recurring callback and loop mutation operators recurring callbacks e.g.
timer alarmmanager handler and scheduledthreadpoolexecuter are frequently used in android apps to implement repeating tasks.
poorly designed strategy to perform a repeating task may have serious implications on the energy usage of an app .
similarly loop bugs occur when energy greedy apis are repeatedly but unnecessarily executed in a loop .
one of the best practices of scheduling repeating tasks is to adjust the frequency of invocation depending on the battery status.
for example if the battery level drops below an app should decrease the frequency of repeating tasks to conserve the battery for a longer time.
while hfc class of mutation operators unconditionally increases the frequency of recurring callbacks bfa operators do this only when the battery is discharging.
therefore the bfa mutants can be killed only when tests are run on a device with low battery or the battery status is mocked.
depending on the apis that are used in an app for scheduling periodic tasks we implemented 8mutation operators of type bfa.
as with some of the other operators details and examples can be found at .
.
sensor mutation operators sensor events such as those produced by accelerometer and gyroscope can be queued in the hardware before delivery.
setting delivery trigger of sensor listener to low values interrupts the main processor at highest frequency possible and prevents it to switch to lower power state.
this is particularly so if the sensor is a wakeupsensor .
the events generated by wake up sensors cause the main processor to wake up and can prevent the device from becoming idle.
in the apps that make use of sensors tests are needed to ensure that the usage of sensors is implemented in an efficient way.
private sensoreventlistener listener private sensormanager manager protected void oncreate listener new sensoreventlistener manager getsystemservice sensor service sensor acm manager .
getdefaultsensor accelerometer manager .
registerlistener listener acm delay normal e6 protected void onpause super .
onpause manager .
unregisterlistener listener figure example of utilizing sensors in android fdsl operator replaces the trigger delay last parameter in method registerlistener in line of figure to and changes the wakeup property of the sensor in line .
in addition apps should unregister the sensors properly as the system will not disable sensors automatically when the screen turns off.
a thread continues to listen and update the sensor information in the background which can drain the battery in just a few hours .
slud operator deletes the statements responsible for unregistering sensor listeners in an app.
for a test to kill a slud mutant it needs to trigger a change in the state of app e.g.
terminate or pause the app without unregistering the sensor listener.
fdsl sensor acm manager .
getdefaultsensor accelerometer true manager .
registerlistener listener acm delay normal analyzing mutants mutation testing is known to effectively assess the quality of a test suite in its ability to find real faults .
however it suffers from the cost of executing a large number of mutants against the test suite.
this problem is exacerbated by considering the amount of human effort required for analysis of the results i.e.
whether the mutants are killed or not as well as identifying the equivalent mutants .
to streamline usage of mutation testing for energy purposes we propose a generally applicable scalable and fully automatic approach for analyzing the mutants which relies on a novel algorithm for comparing the power traces obtained from execution of test cases.
.
killed mutants during the execution of a test power usage can be measured by a power monitoring tool and represented as a power trace a temporal sequence of power values.
a power trace consists of hundreds or more spikes depending on the sampling rate of the measurement and can have different shapes based on the energy consumption behavior.
figure shows the impact of a subset of our mutation operators on the power trace of sensorium an app that collects sensor values of a device e.g.
radio gps and wifi and reports them to the user.
figure 6a is the power trace of executing a test on the original version of this app.
figures 6b d show power traces of the same test after the app is mutated by rlu fsw h and msb operators respectively.
we can observe that these mutation operators have different impacts on the power trace of the test case.
we have developed a fully automatic oracle that based on the differences in the power traces of a test executed on the original and mutant versions of an app is able to determine whether the mutant was killed or not.
algorithm shows the steps in our approach.
the algorithm first runs each test ti 30times on the original version of an app a and collects a set of power traces pa line .
212esec fse september paderborn germany reyhaneh jabbarvand and sam malek figure a baseline power trace for sensorium and the impact of b rlu c fsw h and d msb mutation operators on the power trace the repetition allows us to account for the noise in profiling.
since our analysis to identify a threshold is based on a statistical approach we repeat the execution 30times to ensure a reasonable confidence interval1.
the algorithm then runs each test tion the mutant a and collects its power trace pa line .
alternatively for higher accuracy the test could be executed multiple times on the mutant.
however our experiments showed that due to the substantial overlap between the implementation of the original and mutant versions of the app repetitive execution of a test on the original version of the app already accounts for majority of the noise in profiling.
following the collection of these traces the algorithm needs to determine how different is the power trace of mutant pa in comparison to the set of power traces collected from the original version of the app pa. to that end the algorithm first has to determine the extent of variation in the 30energy traces of pathat could be considered normal due to the noise in profiling.
one possible solution to compute this variation is to take their euclidean distances.
however euclidean distance is very sensitive to warping in time series .
we observed that power traces of a given test on the same version of the app could be similar in the shape but locally out of phase.
for example depending on the available bandwidth quality of the network signal and response time of the server downloading a file can take to seconds.
thereby the power trace of the test after downloading the file might be in the same shape but shifted and warped in different repetitions of the test case.
to account for inevitable distortion in our power measurement over time we measure the similarity between power traces by computing the dynamic time warping dtw distance between them.
dtw is an approach to measure the similarity between two time series independent of their possible non linear variations in the time dimension .
more specifically dtw distance is the optimal amount of alignment one time series requires to match another time series.
given two power traces p1 and p2 dtw leverages a dynamic programming algorithm to compute the minimum amount of alignments required to transform one power trace into the other.
it constructs an n mmatrix d where d is the distance between p1 and p2 .
the value of d is calculated as follows d p1 p2 min d d d the dtw distance between p1and p2isd .
the lower is the dtw distance between two power traces the more similar in shape they are.
1according to central limit theorem by running the experiments at least thirty times we are able to report the statistical values within a reasonable confidence interval .algorithm energy aware mutation analysis input ttest suite aoriginal app a mutant output determine if a mutant is killed or lived 1foreach ti tdo iskilled i f alse pa ett race a ti pa ett race a ti ra f indrepresentati vet race pa 6 computet hreshold ra pa ra distance computedistance ra pa ifdistance then iskilled i true to determine the algorithm first uses dtw to find a representative trace for a denoted as ra line .
it does so by computing the mutual similarity between 30instances of power trace and choosing the one that has the highest average similarity to the other instances.
once algorithm has derived a representative power trace it lets to be the upper bound of the confidence interval of the mean distances between the representative power trace and the remaining in pa line .
this means that if we run tionaagain the dtw distance between its power trace and representative trace has a likelihood of being less than different.
finally algorithm computes the dtw distance between ra and pa line .
if distance is higher than the variation is higher than that typically caused by noise for test ti and the mutant is killed otherwise the mutant lives lines .
.
equivalent and stillborn mutants anequivalent mutant is created when a mutation operator does not impact the observable behavior of the program.
to determine if a program and one of its mutants are equivalent is an undecidable problem .
however well designed mutation operators can moderately prevent creation of equivalent mutants.
our mutation operators are designed based on the defect model derived from issue trackers and best practices related to energy.
therefore they are generally expected to impact the power consumption of the device.
in rare cases however mutation operators can change the program without changing its energy behavior.
for example the arguments of a recurring callback that identifies the frequency of invocation may be specified as a parameter rather than a specific value e.g.
scan interval at line of figure .
if this parameter is initialized to replacing it with 0by droid s fbd operator creates an equivalent mutant.
as another example lrp c can generate equivalent mutants.
lrp c mutants change the provider of location data e.g.
first parameter of requestlocationupdates at line in figure to gps .
although location listeners can be shared among different providers each listener can be registered for specific provider once.
as a result if the app already registers a listener for gps lrp c would create an equivalent mutant.
213 droid an energy aware mutation testing framework for android esec fse september paderborn germany to avoid generation of equivalent mutants droid employs several heuristics and performs an analysis on the source code to identify the equivalent mutants.
for example droid performs an analysis to resolve the parameter s value and compares it with the value that mutation operator wants to replace.
if the parameter is initialized in the program and its value is different from the replacement value droid generates the mutant.
otherwise it identifies the mutant as equivalent and does not generate it.
the eclipse plugin realizing droid is able to recognize stillborn mutants those that make the program syntactically incorrect and do not compile.
droid does so by using eclipse jdt apis to find syntax errors in the working copy of source code and upon detecting such errors it rolls back the changes.
evaluation in this section we present experimental evaluation of droid for energy aware mutation testing.
specifically we investigate the following five research questions rq1.
prevalence quality and contribution how prevalent are energy aware mutation operators in real world android apps?
what is the quality of energy aware mutation operators?
what is the contribution of each mutant type to the overall mutants generated by droid ?
rq2.
effectiveness does droid help developers with creating better tests for revealing energy defects?
rq3.
association to real faults are mutation scores correlated with test suites ability in revealing energy faults?
rq4.
accuracy how accurate is droid s oracle in determining whether tests kill the energy mutants or not?
rq5.
performance how long does it take for droid to create and analyze the mutants?
.
experimental setup and implementation subject apps to evaluate droid in practice we randomly collected apps from seventeen categories of f droid open source repository.
we then selected a subset of the subject apps that satisfied the following criteria we selected apps for which droid was able to generate at least mutants and the generated mutants belonged to at least different categories identified in table .
we further reduced the apps to a subset for which we were able to find at least one commit related to fixing an energy defect in their commit history.
finally to prevent biasing our results we removed apps that were among the apps we studied to derive the energy defect model and eventually our operators.
at the end we ended up with a total of apps suitable for our experiments.
droid injected a total of energy aware mutation operators in these apps distributed among them as shown in table .
mutant generation we used droid to generate energy mutants.
our eclipse plugin is publicly available and supports both firstorder and higher order mutation testing .
it takes the source code of the original app parses it to an ast traverses the ast to find the patterns specified by mutation operators and creates a mutant for each pattern found in the source code.
for an efficient traversal of the ast the plugin implements mutation operators based on the visitor pattern .
for example instead of traversing all nodes of the ast to mutate one argument of a specific api call mentioned in the pattern we only traverse ast nodes of type methodinvocation to find the api call in the code and mutate its argument.
in addition to changes that are applied to the source code some mutation operators require modification in the xml files of the app.
for instance mutation operators mst and ucw cadd statements to the source code to change phone or wifi settings requiring the proper access permissions to be added to the app s manifest file.
additionally we compare energy mutants generated by droid with mutants generated by major and the android mutation framework developed by deng et al.
.
power measurement the mobile device used in our experiments was google nexus running android version .
.
.
to profile power consumption of the device during execution of test cases we used trepn .
trepn is a profiling tool developed by qualcomm that collects the exact power consumption data from sensors embedded in the chipset.
trepn is reported to be highly accurate with an average of .
error in measurement .
test suites we used two set of reproducible tests to evaluate droid .
the first set includes tests in robotium and espresso format written by mobile app developers and the second set includes random tests generated by android monkey .
both set of tests are reproducible to ensure we are running identical tests on both original and mutant versions of the app.
faults to evaluate the association between mutation score and fault detection ability of test suites we searched the issue tracker and commit history of the subject apps to find the commits related to fixing energy related faults.
as shown in table we were able to isolate and reproduce energy related faults for the subject apps.
.
rq1 prevalence quality and contribution to understand the prevalence of energy aware mutation operators we first applied droid on the subject apps described in section .
.
we found that droid is able to produce energy mutants for all programs no matter how small ranging from to with an average of mutants.
this shows that all apps can potentially benefit from such a testing tool.
table provides a more detailed presentation of results for of the subject apps selected according to the criteria described in section .
.
here we also compare the prevalence of energy aware operators with prior mutation testing tools namely major and android mutation testing tool of deng et al.
.
the result of this comparison is shown in table .
overall droid generates much fewer mutants compared to other tools which is important given the cost of energy mutation testing e.g.
the need to run and collect energy measurements on resource constrained devices.
in total droid generates mutants for the subject apps thereby producing and less mutants than major and deng et al.
respectively.
spearman s rank correlation between the prevalence of energy aware mutants and mutants produced by other tools suggests that there is no significant monotonic relationship between them major .
and deng et al.
.
with significance level p .
.
this is mainly due to the fact that droid targets specific apis android specific constructs and other resources such as layout xml files that are not considered in the design of mutation operators in other tools.
furthermore we calculated the number of droid mutants that are duplicate of mutants produced by the other tools.
table presents the percentage of duplicate energy aware mutants under thedupcolumns.
due to the large number of mutants generated by other tools we used trivial compiler equivalent tce technique to identify a lower bound for duplicate mutants.
tce is 2we were not able to use pit as pit does not support android and its mutants are held only in memory which prevented us from building the mutant apks.
214esec fse september paderborn germany reyhaneh jabbarvand and sam malek table test suites and mutants generated for subject apps.
apps loc faultsmutants test suites droid major deng et al.
tests mutant coverage mutation score dup dup titeti te ti te dsub openbmap ametro gtalk ushahidi opencamera jamendo a2dp.vol sensorium table mutation analysis of each class of mutation operators for subject apps.
operator id luf lrp rlu lkl wrdc wrdw hpw fcc fsw rws ucw ltc drd mst lbc msb uab fdb rbd hfc rrc raf bfa ili slud fdsl total equivalent contribution tikilled alive tekilled alive a scalable and effective approach to find equivalent and duplicate mutants by comparing the machine code of compiled mutants.
in addition to compiled classes we also considered any difference in the xml files of the mutants as droid modifies layout and manifest files to create a subset of mutants.
on average only and of mutants produced by droid are duplicates of the mutants produced by major and deng et al.
respectively.
these results confirm that droid is addressing a real need in this domain as other tools are not producing the same mutants.
table also shows the contribution of each class of energy aware mutation operators for subject apps.
display related mutation operators have the highest contribution followed by locationrelated connectivity related and recurring related mutation operators.
wakelock related and sensor related oeprators have less contribution.
these contributions are associated to the power consumption of hardware components since display gps wifi and radio are reported to consume the highest portion of device battery .
finally droid generates no stillborn mutants and only of all the mutants were identified to be equivalent as shown in table .
to summarize the results from rq1 indicate that potentially all apps can benefit from such a testing tool as droid was able to generate mutants for all subject apps the small number of mutants produced by droid makes it a practical tool for energy aware mutation testing of android the great majority of energy aware mutation operators are unique and the corresponding mutants cannot be produced by previous mutation testing tools and all operators incorporated in droid are useful as they were all applied on the subject apps albeit with different degrees of frequency.
.
rq2 effectiveness to evaluate whether droid can help developers to improve the quality of test suites we asked two mobile app developers both with substantial professional android development experience at companies such as google to create test suites for validating the energy behavior of subject apps.
these initial test suites denoted asti contained instrumented tests to exercise the app under various scenarios.
tables and show the result of running tion the subjectapps.
as we can see while the initial test suites are able to execute the majority of mutants high mutant coverage values on table many of the mutants stay alive low mutation score on table .
the fact that so many of the mutants could not be killed prompted us to explore the deficiencies in initial test suites with respect to alive mutants.
we found lots of opportunities for improving the initial test suites such as adding tests with the following characteristics exercising sequences of activity lifecycle wakelocks and other resources such as gps are commonly acquired and released in lifecycle event handlers.
therefore the only way to test the proper management of resources and kill mutants such as rlu wrdw wrdc and mst is to exercise particular sequence of lifecycle callbacks.
tests that pause or tear down activities and then resume or relaunch an app can help with killing such mutant.
manipulate network connection a subset of network related mutation operators namely fcc ucw hpw and rws only change the behavior of the app under peculiar network connectivity.
for example fcc can be killed only when there is no network connectivity and hpw can be killed by testing the app under a poor wifi signal condition.
tests that programmatically manipulate network connections are generally effective in killing such mutants.
manipulate bluetooth or battery status none of the uab rbd and bfa mutants were killed by the initial test suites.
that is mainly due to the fact that the impact of such mutants is only observable under specific status of bluetooth and battery.
for example bfas change the behavior of an app only when the battery is low requiring tests that can programmatically change or emulate the state of such components.
effectively mock location location based mutants can be killed by mocking the location.
although changing the location once may cover the mutated part effectively killing the location mutants specifically luf requires mocking the location several times and under different speeds of movement.
longer tests some mutants namely lbc ltc and raf can be killed only if the tests run long enough for their effect to be 215 droid an energy aware mutation testing framework for android esec fse september paderborn germany table accuracy of name s oracle on the subject apps.
apps accuracy precision recall f measure dsub openbmap ametro gtalk ushahidi opencamera jamendo a2dp.vol sensorium average observed.
for example if the test tries to download a file and terminates immediately the impact of ltc forcing an app to wait for a connection being established is not observable on the power trace.
repeating tasks a subset of mutants are not killed unless a task is repeated to observe the changes.
for example drd mutants are only killed if a test tries to download a file multiple times.
we subsequently asked the subject developers to generate new tests with the aforementioned characteristics which together with ti resulted in an enhanced test suite tefor each app.
as shown in tables and tewas able to kill substantially more mutants in all apps.
these results confirm the expected benefits of droid in practice.
while tiachieves a reasonable mutant coverage on average among all subject apps it was not able to accomplish high mutation score on average .
this demonstrates that droid produces strong mutants i.e.
hard to kill thereby effectively challenging the developers in designing better tests.
furthermore running the enhanced test suites on the subject apps we were able to find previously unknown energy bugs.
after reporting them to the developers of them have been confirmed as bugs by the developers and of them have been fixed by the submission date of this paper as corroborated by their issue trackers .
.
rq3 association to real faults if mutation score is a good indicator of a test suite s ability in revealing energy bugs one would expect to be able to show a statistical correlation between the two.
since calculating such a correlation requires a large number of test suites per fault we first generated random tests for each app using android monkey .
for each app we randomly selected tests from its test suite consisting of both random and developer written tests mentioned in the previous section and repeated the sampling times.
that is in the end for each subject app we created test suites each containing tests from a pool of random and developer written tests.
we then ran each test suite against the subject apps and marked them as tf ail if the test suite was able to reveal any of its energy faults or tpass if the test suite was not able to reveal any of its energy faults.
to avoid bias in this experiment we did not consider the energy faults found by us rather focused on those that had been found and reported previously.
for each tf ail andtpass we computed the mutation score of the corresponding test suite.
finally for each fault we constructed test suite pairs of tf ail tpass and computed the difference in their mutation score which we refer to asmutation score difference msd .
among a total of pairs of tf ail tpass generated for faults tf ailwas able to attain a higher mutation score compared totpass in of pairs.
furthermore to determine the strength of correlation between mutation kill score and fault detection we used one sample t test as msd values were normally distributed and there were no outliers in the dataset verified with grubbs test .
ournullhypothesis assumed that the average of the msd values among all pairs equals to while the upper tailed alternative hypothesis assumed that it is greater than .
the result of one sample t test over pairs confirmed that there is a statistically significant difference in the number of mutants killed by tf ail compared to tpass p value .87e with significance level p .
.
small p value and large number of samples confirm that the results are unlikely to occur by chance.
note that we removed equivalent and subsumed mutants for msd calculation to avoid type i error .
.
rq4 accuracy of oracle to assess the accuracy of the droid s oracle we first manually built the ground truth by comparing the shape of power traces for each original app and its mutants.
to build the ground truth we asked the previously mentioned developers to visually determine if power traces of the original and mutant versions are similar.
visually comparing power traces for similarity in their shape even if they are out of phase i.g.
shifted noisy is an easy albeit time consuming task for humans.
in case of disagreement we asked a third developer to compare the power traces.
for each mutant we only considered tests that executed a mutated part of the program but not necessarily killed the mutant and calculated false positive if the ground truth identifies a mutant as alive while oracle considers it as killed false negative if the ground truth identifies a mutant as killed while oracle considers it as alive true positive if both agree a mutant is killed and true negative if both agree a mutant is alive metrics.
table shows the accuracy of droid s oracle for the execution of all tests in teon all the subject apps.
the results demonstrate an overall accuracy of for all the subject apps.
additionally we observed an average precision of and recall of for the droid s oracle.
we believe an oracle with this level of accuracy is acceptable for use in practice.
.
rq5 performance to answer this research question we evaluated the time required for droid to generate a mutant as well as the time required to determine if the mutant can be killed.
we ran the experiments on a computer with .
ghz intel core i7 processor and gb ddr3 ram.
to evaluate the performance of the eclipse plugin that creates the mutants we measured the required time for analyzing the code finding operators that match and applying the changes to code.
from table we can see that droid takes less than .
second on average to create a mutant and .
seconds on average to create all the mutants for a subject app.
to evaluate the performance of oracle we measured the time taken to determine if tests have killed the mutants.
table shows the time taken to analyze the power trace of all tests from teexecuted on all mutant versions of the subject apps.
from these results we can see that the oracle runs fast it is able to make a determination as to whether a test is able to kill all of the mutants for one of our subject apps in less than a few seconds.
the analysis time for each test depends on the size of power trace which depends on the number of power measurements sampled during the test s execution.
to confirm the correlation between analysis time and the size of power trace we computed their pearson correlation coefficient denoted with pcc in table .
from the pcc values we can see there is a strong correlation between analysis time and the size of power trace among all subject apps.
related work our research is related to prior work on mutation testing as well as approaches aimed to identify energy inefficiencies in mobile apps.
216esec fse september paderborn germany reyhaneh jabbarvand and sam malek mutation testing mutation testing has been widely used in testing programs written in different languages such as fortran c c java and javascript as well as testing program specifications and program memory usage .
however there is a dearth of research on mutation testing for mobile applications specifically android apps.
mutation operators for testing android apps were first introduced by deng and colleagues where they proposed eleven mutation operators specific to android apps.
they designed mutation operators based on the app elements e.g.
intents activities widgets and event handlers.
unlike their operators that are designed for testing functional correctness our operators are intended for energy testing.
therefore our mutation operators are different from those proposed in .
in addition they followed a manual approach to analyze the generated mutants rather than our automatic technique for mutation analysis.
green software engineering in recent years automated approaches for analysis testing refactoring and repair of programs have been proposed by researchers to help developers produce more energy efficient apps.
liu et al.
identified missing sensors and wakelock deactivation as two root causes of energy inefficiencies in android apps.
they proposed a tool called greendroid that can automatically locate these two problems in apps.
banerjee and roychoudhury proposed a set of energy efficiency guidelines to re factor android apps for better energy consumption.
these guidelines include fixing issues such as sub optimal binding and nested usage of resources as well as resource leakage.
a subset of our operators are inspired by the energy anti patterns that are described in these works.
in our previous work we presented an energy aware test suite minimization approach for android.
to determine the quality of tests we used a coverage metric that is calculated based on the actual energy cost of executing the tests.
this work complements our prior work as the mutation score produced by droid could be used as an alternative metric for minimization of test suites.
gupta and colleagues provided a framework to identify common patterns of energy inefficiencies in power traces by clustering power traces of a windows phone running different programs over a period of time.
unlike their approach we compare power traces of executing a test on two different versions of an app knowing one is mutated to determine whether they are different.
to the best of our knowledge this paper is the first to propose an automated energy aware mutation testing framework for android.
our research is orthogonal to other energy aware testing approaches such as test generation and regression testing as it helps them to evaluate the quality of the test suites.
threats to validity external validity random selection of hundred apps to evaluate our research may introduce external threats to validity of results as they may not be representative of all apps.
to mitigate this threat we selected apps from various categories of f droid to investigate rq1.
for investigating the other research questions we applied the inclusion criteria discussed in section .
.
we believe that the resulting apps are sufficient to demonstrate the overall applicability of the approach yet small enough to afford a detailed description for the reader.
internal validity power measurement is sensitive to the workload of the test as well as environmental factors.
to control for the power measurement threats we used reproducible tests to run identical tests on both original and mutant versions of an app.
wetable performance analysis of name on the subject apps.
appstime s pcctotal per mutant analysis per test dsub .
.
.
.
.
openbmap .
.
.
.
.
ametro .
.
.
.
.
gtalk .
.
.
.
.
ushahidi .
.
.
.
.
opencamera .
.
.
.
.
jamendo .
.
.
.
.
a2dp.vol .
.
.
.
.
sensorium .
.
.
.
.
average .
.
.
.
configured trepn to read power consumption data at a millisecond interval.
as power consumption measurements tend to be less accurate when the device is plugged into a power source we ran the tests on the device over adb wireless.
trepn can operate in two modes app level and system level.
since we used intents to start and stop profiling and trepn does not provide a mechanism for profiling a specific app via intents we measured the power consumption of the device during execution of tests.
to remove the impact of other apps on the measurements we disabled and uninstalled all unnecessary apps on the device.
construct validity to derive anti patterns we used a collection of keywords to find apps with energy defect.
although we make no claims that this set of keywords is minimal or complete prior research has shown that they are frequently used in the issue trackers of apps with energy bugs .
we acknowledge that the collection of energy issues identified through our study may not be complete due to this reason.
however we believe the presented energy aware defect model is the most comprehensive one in the literature to date.
concluding remarks energy efficiency is an important quality attribute for mobile apps.
naturally prior to releasing apps developers need to test them for energy defects.
yet there is a lack of practical tools and techniques for energy testing.
in this paper we presented droid a framework for energyaware mutation testing of android apps.
the novel suite of mutation operators implemented in droid is designed based on an energy defect model constructed through an extensive study of various sources e.g.
issue trackers api documentations .
droid provides an automatic oracle for mutation analysis that compares power traces collected from execution of tests to determine if mutants are killed.
our experiences with droid on real world android apps corroborate its ability to help the developers evaluate the quality of their test suites for energy testing.
droid challenges the developers to design tests that are more likely to reveal energy defects.
given that none of the existing automated android testing tools are able to generate tests that are sufficiently sophisticated to kill many of the mutants produced by droid we believe the next logical step is the development of test generation techniques suitable for energy testing.