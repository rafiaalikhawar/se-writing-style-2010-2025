nomen est omen exploring and exploiting similarities between argument and parameter names hui liu1 qiurong liu1 cristian alexandru staicu2 michael pradel2 y ue luo1 1school of computer science and technology beijing institute of technology china 2department of computer science tu darmstadt germany liuhui08 liuqiurong bit.edu.cn cris.staicu gmail.com michael binaervarianz.de qq.com abstract programmer provided identifier names convey information about the semantics of a program.
this information cancomplement traditional program analyses in various soft ware engineering tasks such as bug finding code comple tion and documentation.
even though identifier names ap pear to be a rich source of information little is known abouttheir properties and their potential usefulness.
this paper presents an empirical study of the lexical similarity between arguments and parameters of methods which is one promi nent situation where names can provide otherwise missinginformation.
the study involves real world java pro grams.
we find that for most arguments the similarity is either very high or very low and that short and generic names often cause low similarities.
furthermore we showthat inferring a set of low similarity parameter names fromonesetofprogramsallowsforpruningsuchnamesinanother set of programs.
finally the study shows that many arguments are more similar to the corresponding parameter thanany alternative argument available in the call site s scope.as applications of our findings we present an anomaly de tection technique that identifies renaming opportunities and incorrect arguments in programs and a code recommendation system that suggests correct arguments with aprecision of .
ccs concepts software and its engineering software development techniques maintaining software keywords empirical study name based program analysis identifiernames static analysis method arguments .
introduction identifier names chosen by developers convey information about the semantics of a program but many program permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than theauthor s must be honored.
abstracting with credit is permitted.
to copy otherwise orrepublish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt copyright held by the owner author s .
publication rights licensed to acm.
isbn .
.
.
.
ignore identifier names.
as a result running an analysis on a human written program with meaningful iden tifier names and on an equivalent program where all iden tifiers are consistently replaced with arbitrary strings gives exactly the same result.
however ignoring names discards a valuable source of information that may provide hintsthat are otherwise unavailable to an analysis.
to exploitthis information recent work uses identifier names to inferapi specifications to identify mismatches between a method name and the method s implementation to synthesize code completions to predict syntactic andsemantic properties of programs to suggest identifiernames and to detect incorrectly ordered method arguments of the same type .
despite these recent approaches little is known about the properties of identifier names in real world software and about how one could exploit these properties.
are identifiernames that refer to semantically related values similar?
is it possible to predict from identifier names which variable field or method a developer will use next?
how prevalentare names that convey little or no semantic information such as generated variable names or very short names and is there a way to identify them?
addressing these questions is valuable because it may pave the road for name basedanalyses that complement traditional program analysis.
forexample one could exploit the similarity of names to com plete pieces of code automatically to warn developers about anomalies that may correspond to code worth changing or to infer documentation from names.
this paper focuses on the lexical similarity of arguments and parameters of methods which is one prominent situation where identifier names may provide otherwise missing semantic links.
we say argument to values passed to a method at a call site and we say parameter to the formal parameter in the method s definition.
since an argumentand its corresponding parameter often refer to the same instance we hypothesize that their names are often similar.
.
research questions toevaluatethishypothesis weconductanempiricalstudy that addresses the following research questions rq1 how similar are argument names to the names of their corresponding parameters?
answering this questionwill help to decide whether exploring similarities between argument names and parameter names is worthy.
rq2 howlongareargumentnamesandparameternames in real world java programs and how does the length relate to their similarity?
answering this question may help es2016 ieee acm 38th ieee international conference on software engineering timate how much confidence one can have into similarities between names of particular lengths.
rq3 how often does an overriding method change the parameter names compared to the names in the overriddenmethod?
answering this question helps estimate how oftencomparing arguments to the parameter names of the stati cally resolved call target is sufficient and how often considering the dynamic call target would yield different results.
rq4 why are some arguments dissimilar to corresponding parameters?
answering this question my help applicationsthatexploitnamesimilaritiestoignoreparticularkinds of dissimilarities.
rq5 if parameters with specific names such as arg0 are frequently assigned with dissimilar arguments in sample applications are parameters with the same name frequentlyassigned with dissimilar arguments in other applications?
if yes can we build a set of low similarity parameters that are likely to be assigned with dissimilar arguments?
answering thisquestionmayhelpapproachesthatexploitthesimilarityof names such as name based code completion or anomaly detection to reduce false positives by ignoring arguments assigned to low similarity parameters.
rq6 how often is the argument chosen by the developer more similar to the corresponding parameter than anyof its potential alternatives?
answering this question will help to estimate the accuracy of approaches that exploit the similarity of names such as code completion.
.
summary of findings to address these questions we empirically study named arguments in popular open source java programs.
the main findings of the study are the following.
for rq1 we find that the distribution of the lexical similarity is a u shape the similarity is either extremely high or extremelylow.
many arguments exactly match their correspondingparameter.
incontrast themajorityofthoseargumentsthatarenotsimilartotheircorrespondingparametersare very dissimilar have a similarity of .
forrq2 wefindthat84 ofallargumentnamesand70 of all parameter names have at least four characters.
almost all argument names and most parameter names are composed of atmost three terms.
on average overall studied parameters the similarity to their arguments in creases with the length of parameter names and with the number of terms used in the parameter name.
however there is no strong correlation between the length of namesandthesimilaritybetweenindividualpairsofargumentsandparameters.
these results suggest that one cannot infer thesimilarity between an argument and a parameter from the length of their names.
for rq3 we find that most of all overriding methods have exactly the same list of parameter names as their overridden method.
that is comparing arguments to the parameters of a statically computed call target is sufficient in most cases even though a call may be dispatchedto a different target method at runtime.
for rq4 we find that the main reason for dissimilar arguments and parameters are short parameter names.
among the named arguments whose similarity with their correspondingparameteriszero areassignedtoparam eters named with a single character and of them areassignedtoparametersnamedwithnomorethanthreecharacters.
another reason for dissimilar pairs of arguments andparameters are generic data collection operations.
among the named arguments whose lexical similarity withtheir corresponding parameters is zero are assigned toparameters named index item key o r value.
such names are common in methods manipulating data collections.
for rq5 we find that most dissimilar pairs of argument names and parameters are due to a small set of pa rameters that occur again and again across programs such asarg0.
that is extracting a set of parameter names to ignore from sample programs helps finding parameters that are likely to be associated with dissimilar arguments in otherprograms.
finally forrq6 wefindthatmostargumentnames that are not associated with low similarity parameters aremore similar to their corresponding parameter name thanany other argument that a programmer could use in thecurrent scope.
the figure is even up to for those arguments whose lexical similarity with their correspondingparameters is at least .
.
that is analyzing the similarityof argument names and parameter names can help in deciding which argument to use and in detecting incorrect orotherwise suspicious arguments.
.
applications our results suggest several research directions for exploiting identifier names to support and further automate software development tasks and we explore two such directions.
first we present a static anomaly detection technique thatwarns about argument names that seem not to match theircorresponding parameter name.
the basic idea is to report a warning when the developer could use another argument than the current one and when this change would make theargument name and parameter name significantly more sim ilar to each other.
we apply the analysis to programs where it finds known incorrect arguments previously unknown incorrect arguments and renaming opportunities with a precision of .
second we present a name basedrecommendation system that suggests an argument while adeveloper writes code that calls a method.
the basic idea is to recommend an argument from a set of potential arguments so that the recommended argument is the mostsimilar to the corresponding parameter.
the approach rec ommends correct arguments with a precision of .
in summary this paper contributes the following the first extensive empirical study of argument names and parameter names in real world java programs.
empiricalevidenceshowingthatmostargumentnames and parameter names are either similar to each otheror can be easily filtered and that names help in decid ing which argument to assign to a parameter.
two practical applications of our findings anomalydetection and argument recommendation along withexperimental results that show that the applicationsare effective.
.
setup of the study .
methodology to study the lexical similarity of identifier names involved in method calls we compare named method arguments and 1064method parameters with a string similarity metric.
the first step of the study is to extract identifier names from the source code of the subject applications.
to this end an ast based staticanalysisextractsfromeachformalparam eter in a method definition the identifier of the parameter called parameter name .
furthermore the analysis extracts at each call site the names of particular kinds of arguments called argument names .
specifically the analysis considers the following expressions that may be passed as arguments for a variable the argument name is simply the variable name.
for a call expression the argument name is the name of the called method.
that is we ignore the receiver object and any arguments of the call.
for example ifthereturnvalueofamethodcall student.firstname is passed as an argument then the argument name is firstname .
for a field access expression the argument name is the name of the field again ignoring the receiver object.f o re x a m p l e i ft h ea r g u m e n ti sstudent.id then the argument name is id.
for the thiskeyword the argument name is the name of the class of which thisis an instance.
for example if in a method invocation print this the argument this refers to an instance of class student then the argument name is student.
all other arguments such as complex expressions are ignored in the study.
to compare argument names with parameter names the analysis matches each call site with a method definition.thismatchingisbasedonthestaticallyknowntargetmethodto which the call resolves.
as a result each parameter nameis associated with a set of argument names.
based on the extracted argument and parameter names we compute the similarity of two names as follows.
tomeasure the lexical similarity between names we decom pose each identifier name into a sequence of terms noted asterms arg .
the decomposition is based on underscores and capital letters assuming that the name follows the popularcamel case or snake case naming convention.
we measurethelexical similarity between argument argand parameter paras follows lexsim arg par comterms arg par comterms par arg terms arg terms par comterms n1 n2 isthelongestsubsequenceof terms n1 where each term in the subsequence appears in terms n2 .
for example lexsim length inputlength and lexsim fieldlength fieldlength .
the measure may assign a similarity of to non equal names such as foobar and barfoo which may appear unintuitive but is not a problem in practice.
.
subject applications we search for the most popular open source java applications from sourceforge and select the top resulting ap plications for investigation.
sizes of such applications vary lj figure distribution of lexical similarity between arguments and parameters from to non blank lines of source code.
in total the subject applications are composed of lines of code.
from these subject applications we extract all named arguments.
in total we get named arguments from these applications.
for each such argument we compute the lexicalsimilaritybetweenitanditscorrespondingparameteraccording to formula .
.
results of the study .
rq1 distribution of lexical similarity to address the question how similar argument and parameter names are we compute the similarity between all argument names and the names of their corresponding parameters.
figure shows the distribution of the similarity.the figure shows that the distribution has a u shape sim ilarity is either very high or very low.
in of all cases the similarity is equal to whereas in of all cases the similarity is i.e.
the names share no common terms .
from the figure we also observe that the number of arguments whose similarity with corresponding parameters belongs to .
.
.
.
.
.
.
.
and .
.
is extremely small.
one of the reasons is that the similarity is computed based on terms and thus the similarity isdiscrete.
if two names contain no common terms the sim ilarity is zero.
otherwise the numerator of formula isat least .
that is to obtain a similarity smaller than .
the denominator must be greater than .
.
however it is not so common that the length of two identifier names is longer than terms.
consequently the numberof arguments whose similarity with corresponding parameters belongs to .
.
is extremely small.
the same is true for other intervals e.g.
.
.
.
.
.
.
and .
.
.
we conclude from these results that the similarity of argument and parameter names is worth exploring further because a significant part of all arguments is very similar to its corresponding parameter.
.
rq2 length of names to address the question how long argument names and parameter names in real world java programs are we mea sure for each name the number of characters and the number of terms in the name.
figure shows the results.
the 1065 e e d e e d w figure length of argument names and parameter names.
lj e lj e d lj e lj e d w figure correlation between length of names and average similarity with polynomial trendlines left hand side of the figure shows that most names are composed of no more than characters.
for example of the argument names contain to characters.
of the parameter names contains no more than characters.
the right hand side of the figure shows that most names arecomposed of a small number of terms.
of the parame ter names and of the argument names are composed ofat most three terms.
single term names account for of argument names and of parameter names.
theaveragelengthofargumentnames .7terms ishigher than that of parameter names .
terms .
one of the reasons why argument names contain more terms are method invocations whose return value is passed as an argument.
for a single term parameter e.g.
rectangle an argument could be a method invocation e.g.
createrectangle .
wealsoinvestigatewhetherthelengthofparameternames or argument names influences the similarity between arguments and parameters.
the results are presented in figure .
the figure shows that the average similarity increaseswhen the length of parameter names increase.
in contrast the similarity decreases while the length of argument names increases.
even though on average over all studied arguments and parameters the length of names influences thesimilarity the length of parameter names and argumentnames is only weakly correlated to similarity for individualpairs of arguments and parameters.
the correlation coefficientis0.
parameternames and .
argumentnames respectively.
one of the reasons for this seemingly contra dictory result is that even for the argument or parameter names of the same length the similarity between arguments and parameters may vary dramatically.
we conclude from these results that the length of parameter names does influence the similarity between their names.
this finding suggests that developers should aim for expres sive parameter names with multiple terms if appropriate .
.
rq3 parameter names of overridden methods for this study we resolve invoked methods based on the statically known type of the receiver object.
however staticanalysis may resolve method invocations incorrectly becausethe dynamic receiver type may be a subtype of the staticreceiver type that overrides the called method.
to investigate to what extent such mis resolution may influence the measured similarity between arguments and parameters wemeasure how often overriding methods use different param eter names than the overridden method.
in total over all applications we find that most of the overriding methods have exactly the same parameterlist including the same parameter names as the methodsthey override.
in other words in most cases the fact thatstatic method resolution may be incorrect does not influence the measured similarity between arguments and parameters.
.
rq4 reasons for dissimilarity to address the question why some arguments are dissimilar to their corresponding parameter we further analyze all pairs of argument name and parameter name that have asimilarity of .
in total there are such pairs.
we randomly sample of them and manually inspect them.
moreover we validate the results of the manual inspectionon the whole population of pairs of names.
the manual analysis leads to two findings first very short parameter names are the major reason for the dis similarity between arguments an parameters.
of thearguments are assigned to parameters named with a singlecharacter e.g.
sand i and .
of the arguments are assigned to parameters named with at most three characters.
such short parameter names often convey little semantics and therefore cause dissimilarities with the correspondingargument names.
second generic parameter names of methods of collection classesareanotherreasonforthedissimilaritybetweenargu ments and parameters.
of the arguments are assignedto parameters named index item key o r value.
such parameter names are popular in methods that manipulate datacollections.
although such parameter names are meaningful their corresponding arguments are usually dissimilar to them because their arguments are concrete value or indexes.f o re x a m p l e a ni n v o c a t i o no fm e t h o dlist.add int in dex object value may be add i newelement .
toinvestigatewhethertheanalysisresultsonthe200sample arguments can be generalized we validate the results onthe entire population of argument names that have no simi larity with the corresponding parameter name.
the valida tion results are as follows of the named arguments were assigned to parameters named with a single character.
out of the named arguments were assigned to parameters named with no more than3 characters.
these data are similar to the analysisresults on the sample.
of the named arguments wereassignedto index item key o r value whichissimilar to the analysis results on the sample.
we conclude from the results that short parameter names and generic names are main reasons for dissimilarities be tween argument names and parameter names.
this find ing can benefit applications of name similarities which may e.g.
ignore such parameters.
.
rq5 filtering parameters with low similarity the following addresses the question whether one can build a set of low similarity parameters from a corpus of sample applications.
we present a technique for computingsuch a set and assess the effect of filtering pairs of argument names and low similarity parameter names.
given a corpus of sample applications our approach for identifying low similarity parameters has three steps.
first we cluster all argument names in the sample applications by their corresponding parameter names.
if the parameters associated with two arguments have the same name thenwe assign both arguments into the same cluster.
that is each cluster is associated with a unique parameter name.second for each cluster we calculate the average similarity sbetween arguments in this cluster and their corresponding parameters.
finally if the average similarity sof a cluster is smaller than .
we add the parameter name associated with this cluster to the set of low similarity parameters.
for example for two calls m a x and m a y of the method m a a b b we extract two clusters c a a n dc b .
the average similarities for caand cbareavg lexsim a a lexsim a a and avg lexsim x b lexsim y b respectively.
hence we add bto the set of low similarity parameters.
to assess to what extent extracting low similarity parameters from sample programs can help find parameters that are likely to be associated with dissimilar arguments in other programs we carry out a k fold cross validation on the subject applications k .
the applications are randomlypartitioned into groups notated as sag i i ... where each group is composed of subject applications.for the ith cross validation we consider all subject applications except for those in sag ias the corpus of training applications and we consider the applications in sag 1as the validation applications.
after identifying low similarity parameters from a corpus of sample applications we compute all argument names inthe remaining applications whose corresponding parametersare low similarity parameters.
we call such arguments filtered out arguments .
figure shows the distribution of the similarity between filtered out arguments and their corresponding parameters.
the figure shows that for most on average of the filtered out arguments the simi larity between them and their corresponding parameters iszero.
note that this percentage is significantly higher than when considering all arguments figure .
the observationtable influence of ignoring arguments associated with low similarity parameters.
similarity arguments n1 filtered out arguments n n2 n1 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total lj figure distribution of similarity parameters and arguments that are not associated with lowsimilarity parameters.
holds in all of the six rounds of cross validations regardless of the changes on both training data and validation data.
the above results show that low similarity parameters are an effective means for filtering arguments across applications.
in the remainder if the paper we use low similarity parameters computed from all subject applications.
table 1illustrates how filtering out arguments associated with low similarity parameters changes the distribution of similarity between arguments and parameters.
from the table we observethatargumentsthatarelesssimilartotheirparametersare more likely to be filtered out.
for example the filteringremoves75 ofallargumentswhosesimilaritywiththeirpa rameters is zero whereas the filtering removes only of all arguments whose similarity with parameters is not zero.
figure shows the distribution of similarity between parameters and arguments that are not filtered out arguments.
by comparing figure with figure we observe that the distribution of lexical similarity between arguments and parameters has been reshaped dramatically by filtering basedon low similarity parameters the ratio of arguments thatare dissimilar to their parameters decreases and the ratio ofarguments that are similar to their parameters increases.
weconcludefromtheresultsthatcomputinglow similarity parameters from a corpus of sample applications is an effec tive means to predict whether a parameter will be dissimilarto its arguments.
this finding enables approaches that exploit name similarities to improve their precision by ignoring low similarity parameters.
1067 s s s s s s figure distribution of similarity between parameters and arguments associated with low similarity parameters.
.
rq6 picking among alternative arguments to address the question how similar the argument chosen bythedeveloperistootheravailablearguments wecompareeach argument against its potential alternatives.
to thisend wedefinewhichargumentscouldbeusedbyadeveloper and then compute which of these possible arguments is the most similar to the parameter.
definition .
potential alternatives of argument argare ifargis a local variable or a field of the enclosing class all fields of the enclosing class and local variables thatare available at the location are in the set of potentialalternatives.
ifargis a field access or a method invocation without arguments then all field accesses and method invoca tions without arguments that have the same receiverobject are potential alternatives.
ifargis a method invocation with arguments method invocationswiththesamereceiverobjectandthesame arguments are in the set of potential alternatives.
for example for an argument a.b.foo the following are potential alternatives a.b.bar and a.b.getbar .l i k e w i s e for a method invocation x.getsize y the method invocation x.length y is a potential alternative.
replacing an argument with a potential alternative may introduce syntactical errors or type errors.
for example some alternatives may not be available in the current scope e.g.
privatefields ortheirtypesmaybeincompatiblewith the parameter s type.
we exclude such invalid potential al ternatives from the comparison and define alternative argumentsas follows definition .
analternative argument of argument argis a potential alternative that does not introduce new syntac tical or type errors while replacing arg.
among the alternative arguments alt args we call arguments that have the greatest lexical similarity with the cor responding parameter paramost similar argument definition .
an alternative argument m alt altargs is amost similar argument if for any alternative argument anyalt altargs the following inequation holds lexsim malt par lexsim anyalt par to investigate how often the argument chosen by the developer is more similar to the corresponding parameter than any of its potential alternatives we compare each argumentname in the applications to the names of its alternative ar guments especially the most similar argument .
of the studied arguments do not have any alternative arguments i.e.
they are the only argument thatis available in the scope of the method call and that istype compatible with the parameter.
among the 387arguments with alternatives only a small number .
have an alternative that is more similar to the parameter than the current argument.
in other words .
ofallargumentsareamongthemostsimilarofallpos sible arguments.
for of the arguments with an alternative the current argument is even strictly more similar to the parameter than any of its alternatives.this number increases to for arguments whose similar ity with the corresponding parameter is greater than .
.
we also analyze the impact of filtering arguments associated with low similarity parameters section .
.
afterthe filtering we keep arguments of which have at least one alternative.
among these argu ments are more similar to the corresponding parameters than any of their alternatives.
compared to the ratio without filtering arguments theratio has increased by .
one of thereasons for the increase is that most of the arguments whosesimilarity to their corresponding parameters is zero have been filtered out based on low similarity parameters.
we conclude from these results that approaches that try toinferthemostappropriateofallavailablearguments such ascodecompletionoranomalydetection haveahighchance tomakeaccuratesuggestions inparticularwhenfilteringarguments based on low similarity parameters and thresholdsin minimal similarity.
.
applications the results from section suggest several applications that exploit the similarities between arguments and param eters.
in this section we explore two such applications.
.
anomaly detection we present a static analysis that detects anomalies.
the main idea is to report arguments and parameters where the current argument is significantly less similar to the param eter than an alternative.
the analysis helps developers in two ways.
first it reveals call sites that accidentally pass incorrect arguments .
based on the analysis the developer can fix such bugs possibly using the alternative argumentsuggested by the analysis.
second the analysis reveals argu mentsand parameters that are correctbut notappropriately named making the code unnecessarily hard to understand and maintain.
developers should address such renaming opportunities by choosing identifier names that convey the semantics of the value that the identifier points to.
.
.
approach and implementation our approach for detecting incorrect arguments and renaming opportunities works as follows.
for a given argu mentcurargthe analysis at first checks the corresponding parameter paragainst the set of low similarity parameters section .
.
if paris in this set which suggests that it is oftenassociatedwithdissimilararguments thentheanalysis ignores the current argument and does not report any warning for it.
otherwise the analysis computes the most similarpotential argument m alt definition .
if maltis different from curargand if the difference is above a threshold i.e.
lexsim malt par lexsim curarg par t h e n the analysis reports a warning that suggests to replace thecurrent argument with m alt or to rename the argument or the parameter.
we implement the approach as an eclipse plug in that can be used in two ways.
first to check arguments incremen tally and instantaneously that is whenever an argument isintroduced or modified.
in this scenario the plug in identi fies and reports suspicious arguments immediately when the developer introduces them and suggests to the developer an alternative argument as a quick fix.
second to check all ar guments in a project at once.
in this scenario the plug inchecks the whole application and reports all suspicious arguments along with the source code location of each problem and suggestions for alternative arguments.
.
.
calibration the approach depends on a threshold that decides when to present warnings to the developer.
in the following wepresent how we calibrate this threshold using three open sourceprogramsthatarenotamongthesubjectapplications of the study domination version .
.
.
openbravo pos version .
.
and dom4j version .
.
.
the applications cover different domains and are developed by different developers.
to choose a reasonable threshold we conservatively set the threshold to .
and apply the anomaly detection to the three applications.
we manually check every reportedwarning and classify as a true positive if it points to a valid renamingopportunityortoanincorrectargument.
basedon this classification we compute the precision of the anomaly detection as follows precision number of true positives number of reported warnings.
for the reported warnings the similarity between arguments and parameters is discrete and it is either .
.
.
.
or .
we observe that the precision increases while increases from .
to .
and it decreases slightly1 example from lwjgl commit 029fa0e signature of called method void writeversionfile file file float version incorrect method call writeversionfile dir latestversion fix applied in commit 3656b80 writeversionfile versionfile latestversion example from mondrian commit b583845 signature of called method void putchildren rolapmember member arraylist children incorrect method call cache.putchildren member list fix applied in commit c26d9f2 cache.putchildren member children figure examples of incorrect arguments detectedby the anomaly detection.
after this point.
based on these results we use .
in the remaining experiments.
.
.
evaluation we evaluate the effectiveness of the anomaly detection by manually identifying known problems related to incorrect arguments in the history of the subject applications and bychecking whether the analysis detects these problems.
toidentify known problems we use changedistiller to extract source code changes that affect a single argument and then manually filter those that replace an incorrect argu ment with a correct argument.
our methodology ensuresthat each considered change is indeed a bug fix.
we manually inspect the commit messages and the changed code and we keep only those changes that definitely fix a bugcaused by using an incorrect argument.
most of the commitmessages of the selected changes are very explicit e.g.
codecleanup wrong parameter was used fixed bug uploadrate is protocol data or fix for bug correctly reference the crosstab id .
we consider all applications thathaveapubliclyaccessibleversioncontrolsystem git svn or cvs which yields of the applications.
in total we identify incorrect arguments in of these applications.
figure lists two example bugs.
we then apply the anal ysis to the buggy versions of the applications manuallyinspect all reported anomalies and classify each of them asincorrect argument renaming opportunity or false positive.
we apply the anomaly detection to the subject applications with known incorrect arguments .
theapproach successfully detects of the known incorrect ar guments.
besides such incorrect arguments the approach also identifies incorrect arguments that have been missed bythemanualidentificationbasedonchangedistiller show ing that incorrect arguments are more frequent than ourchangedistiller based search suggests.
in addition to the incorrect arguments the analysis reports127renamingopportunitiesand33falsepositives.
theaverage precision of the analysis i.e.
the sum of the numberof incorrect arguments and renaming opportunities dividedby the total number of reported anomalies is .
the detected renaming opportunities fall into four categories abbreviations .
for example the approach warns about an argument cwhose correspond1069table results of anomaly detection.
application size loc known incorrect argumentsreported warningsidentified incorrect argumentsidentified renaming opportunitiesfalse positivesprecision lwjgl mondrian davmail vassal engine vuze azureus version .
vuze azureus version .
vuze azureus version .
itext jabref pydeva1 pydevb29 subsonic jasperreports library sweet home 3d total aversion e9325bcef1f1a911642b3a76cf5563753f512eaa .
bversion 8fef8ba12fe8b5ff0cd37c2bb6f5c4750c18a54c .
ing parameter is country and about a name dsthat stands for data source .
incomplete descriptions that are missing a noun .
identifier names often consist of a noun combined with some adjunct.
the approach warns aboutseveral argument names where the noun is missing such as missed which should be renamed into missedmembers because the corresponding parameter is parentmembers and to connect which should be renamed into to connect address.
meaningless names .
the approach reports argument names that reveal little or nothingabout the value that the identifier refers to such aslistand object.
inconsistent names .
the approach reports argument names where multiple terms are usedto describe a single concept such as fileandmodule orthickness and width.
most of the renaming opportunities are associated with arguments i.e.
leading to renamings of arguments suggesting that the quality of parameter names is gener ally higher than that of argument names.
it is reasonablein that developers usually pay more attention to parameternames because methods are expected to be called later and may be used by other developers.
however arguments are often encapsulated and hidden within methods and thus de velopers rarely expect them to be read or modified by otherdevelopers.
previousworkshowsthatmeaningfulidentifiernamescontribute to code understandability and we believe thatfollowingtherenamingsuggestionsoftheanalysiscangreatlyimprove the readability of the code.
there are two main reasons for false positives reported by the approach.
first the analysis is unable to distinguishintended from unintended anomalies.
for example for thestatement bounds new rectangle bounds.y bounds.x bounds.height bounds.width theanalysissuggestsswapping the last two arguments because their corresponding parameters are widthand height respectively.
however thedeveloper intends to rotate the rectangle i.e.
the anomalyis intended.
second the analysis currently fails to identifysimilarities that are obvious for a human but not for ourdefinition of similarity e.g.
because the analysis does nottokenize names correctly or because it is unaware of irregular english plural forms.
we believe that the second reason for false positives can be addressed by more sophisticatedprocessing of names such as butler et al.
s method for tok enizing identifier names or techniques borrowed from the natural language processing community.
.
recommendation of arguments as the second application of the findings presented in section we present a name based recommendation system that suggests arguments to a developer.
such a system can e.g.
be used as part of the code completion algorithm ofan ide where it recommends an argument just when thedeveloper types a method call.
the key idea is to pick from the set of potential arguments the argument whose similarity with the corresponding parameter is significantly higherthan any of the alternatives.
.
.
approach our approach recommends arguments as follows.
first for a given argument slot i.e.
where an argument should beinserted the approach retrieves its corresponding parameter noted as par.
if the name of this parameter is one of the low similarity parameters then the approach makes no recommendation for this argument.
otherwise the approachcollects all potential arguments noted as s pot local variables parameters of the enclosing method invocation on methods of the enclosing class and fields of the enclosing class.
it does not consider complex expressions or literals likethis.getauthor .getname and because considering such complex expressions or literals would make the searchspaceforpotentialargumentsextremelylarge.
third it excludes elements from s potthat are not type compatible with the parameter or are not available in the slot.
ex cluding such elements guarantees that the recommendedargument will not introduce syntactic errors.
fourth it computes the similarity between the parameter name and 1070table results of argument recommendation.
applicationsize loc recommended argumentsprecision neuroph wurfl json lib joda time total the names of the collected potential arguments.
finally if there is an argument in spotwhose similarity is significantly greater than others i.e.
the distance is no less than the approach recommends this argument.
.
.
calibration to calibrate the threshold and to evaluate the approach weruntherecommendationsystemforeachargumentslotina program i.e.
for each argument position of all call sites in the program.
for each slot we compare the recommended argument against the current one.
if both arguments areidentical the recommendation is considered to be correct.
otherwise the recommendation is considered to be incorrect.
based on these data we compute the precision of the approach as the number of correct recommendations dividedby the total number of recommendations.
we calibrate the threshold on three open source applications htmlunit ckeditor a n d c3p0.w e o b s e r v e t h a t while is smaller than .
the precision increases quickly with the increase of .
however after that the precision increases insignificantly with the increase of .
consequently we use .
in the remaining experiments.
.
.
evaluation the approach is evaluated on four open source applications neuroph wurfl joda time a n d json lib.t h e evaluation results are presented in table .
from the table we observe that the approach recommends arguments with a precision of .
of the incorrect recommendations are associated with arguments that are either complex expressions or literals which the approach cannot recommend.
consequently if the current argument is a complex expression or a literal the approach fails to recommend the correct argument.
of the arguments in the subject applications are complexexpressions or literals.
another reason for incorrect recommendations are typecasts such as map value.s i n c e the approach recommends type compatible arguments only it cannot succeed if the actual argument is a cast expres sion.
excluding complex expressions literals and cast expressions the precision of the recommendation is up to .
among the recommended arguments are associated with inter class invocations i.e.
the invocations and the arguments are out of the documents wherethe invoked methods are declared.
the average precision for such inter class recommendation is .
it is even slightly greater than that for inner class recommendation averageprecision .
a possible reason is that many of the inter class invocations are associated with apis whose parameters are often named more carefully.
.
threats to v alidity a threat to external validity is that conclusions drawn from a set of java applications might not hold for other applications.
to reduce the threat we select the most popu lar open source applications from sourceforge which yields60 applications from various application domains.
furthermore for rq5 we address this threat via k fold cross validation.
for rq4 another threat to external validity is that we manually analyze only samples to investigate why some arguments are dissimilar to their corresponding parameters.
to reduce this threat we randomly select these sample arguments from the population and validate the analysisresults on the entire population.
the study results depend on the similarity measure that compares argument names and parameter names.
we haveexperimentswithseveralalternativesimilaritymeasures butwe have not found major changes in the overall results ofthe study.
for example when replacing formula with thestring similarity based metric from the resulting accuracy in argument recommendation is almost identical to the current one .
in future work it would be inter esting to try additional alternative measures of similarity.
our evaluation of the effectiveness of a name based anomaly detection is subject to two threats to validity.
first our approach to manually identify known argument relatedchanges in the history of applications may not yield a repre sentative set of argument related bugs.
we carefully inspecteach of the changes that we consider as known bugs to ensure that they are indeed bugs but we cannot ensure that we consider all such bugs in the history of these applica tions.
second the classification of anomalies into incorrectarguments renaming opportunities and false positives is to some degree subjective.
to reduce any potential bias three engineers inspect each warning and must reach a consensusabout its classification.
.
related work theimportanceofidentifiernameshasbeenvalidatedand well recognized .
as suggested by lawrie et al.
there are two main sources of domain information identifier names and comments.
because many developers do not write comments identifier names are critical for programcomprehension.
a method in which names assist in reverseengineering is presented in it consist of extracting conceptlatticesbyanalyzingtheidentifiersnamesinprograms.
consistent naming is important and a number of approaches havebeenproposedtokeepnamesconsistent .
thebasic idea is that a single concept within the same applica tion should be referred to by the same name .
a number of approaches have been proposed to calculate name similarity for identifiers.
cohen et al.
compare dif ferent string metrics for matching names and records.
anumber of approaches to tokenize identifiers have been proposed .
enslen et al.
propose an approach to split identifiers into sequences of words by mining word fre quencies in source code.
butler et al.
propose an approachto decompose identifier names into meaningful words evenif these names do not follow the camel case naming convention.
taneja et al.
suggest to use a synonym database to improve the accuracy of name comparison.
these ap1their paper has inspired the prefix of our title.
1071proaches might be used to split identifiers and to facilitate computationofhybridsimilarity betweenidentifiers.
incorporating such sophisticated approaches of computing the similarity between arguments and parameters may increasethe similarities measured in our study.
zhang et al.
propose an approach to recommend arguments for api usage.
they mine existing code bases and build an argument usage database.
for each api usage the approach retrieves similar usage instances from the databaseand recommends arguments by concretizing such instances.a difference between their work and this one is that their approach depends on a large number of usage instances of the apis.
for non api method invocation or less popularapis it is challenging to collect such instances.
an approach by pradel and gross relates to one of the applications of our findings anomaly detection.
theypresentanapproachtoidentifyproblemsrelatedtotheorderof equally typed arguments.
for each call site they reorderequally typed arguments.
if the reordered arguments matchthe names used at other call sites significantly better they report a warning.
our anomaly detection differs from theirs in the following two aspects.
first they identify problemsrelated to the order of equally typed arguments while thiswork addresses arbitrary arguments.
second they comparearguments at a call site with other arguments at other call sites of the same method .
in contrast we compare arguments with corresponding parameters.
there are several approaches that identify renaming opportunities.
the first category of such approaches is to identifyrenamingopportunitiesbycheckingidentifiernames against predefined rules.
all names breaking such rules arepresented as potential renaming opportunities.
abebe etal.
introduce lexicon bad smells that indicate potentiallexicon construction problems.
caprile and tonella propose an approach to standardize program identifier names.
first it standardizes the lexicon terms in identifier names .second it standardizes the arrangement of terms within anidentifier name.
other approaches to standardize identifier names have been conducted by lawrie et al.
and butler et al.
.
our work differs from these approaches inthat it can identify renaming opportunities without requir ing a set of predefined naming conventions.
the second category of work on renaming opportunities searchesforinconsistentnaming.
deissenboeckandpizka propose a model based approach for identifying inconsistentnaming.
based on maps between concepts and names theirapproach can identify two categories of basic warnings.
the first category of such warnings is given when two identifiers have identical names but different types.
the second cate gory of such warnings is given when an identifier is declaredbut never referenced.
the first category of such warningsmight suggest renaming opportunities.
our approach differs from their work in that it focuses on arguments and parameters only arguments and parameters often refer to thesame concept and thus does not require the maps betweenconcepts and names.
it is a great advantage because it is difficult to build the maps accurately and it usually requires domainexperts.
thiesandroth proposeanotherwaytoidentify inconsistent naming.
they analyze variable assign ments and identify variables that refer to the same objectand are used in the same way.
they suggest such variables to share the same name.
our approach differs by focusing on arguments and parameters instead of assignments.the third category of work on renaming opportunities builds relationships between special terms and infers a setof rules e.g.
that a method that matches contain should return a boolean .
methods that break such rules are reported as renaming opportunities.
our approach differs from their work in that our approach identifies renaming op portunities on arguments and parameters whereas their ap proach identifies renaming opportunities on method names.
the fourth category of work on renaming opportunities generalize renamings conducted in the rest of the program.once a rename refactoring is conducted manually or withtool support liu et al.
recommend to rename closelyrelated software entities whose names are similar to that of the renamed entity.
the approach proposed in this paper differs from that in in that it does not depend on con ducted renamings.
arnaoudovaetal.
analyzeandclassifyidentifierrenamings e.g.
by comparing the original and the new name using an ontological database .
future work may improve oursimilarity measure using such ontological databases.
statistical language models extracted from a corpus of codehave been used to automatically suggest identifier names for variable names as well as method and class names .
jsnice predict names of local variables in javascriptapplications.
.
conclusions and future work this paper presents the first in depth empirical study of similarities between the names of arguments and parame ters of methods.
our results show that identifier names ofarguments and parameters are often similar to each other that dissimilar names can be filtered based on low similarityparameters inferred from a set of sample programs and that many arguments are the most similar to the corresponding parameter of all possible arguments that are available in thescope of the method call.
as applications of our findings wepresent an anomaly detection technique that identifies renaming opportunities and potentially incorrect arguments aswellasarecommendationsystemthatsuggestsargumentst oad e v e l o p e rw h oi st y p i n gam e t h o dc a l l .
the broader impact of our work is to show that identifier names are a rich source of information that can provide otherwise missing information to program analyses.
we expect our results to encourage future research on name basedprogram analyses which will complement existing programanalyses for several software engineering tasks.
for example names may improve code completion algorithms support the generation of documentation and support fault local ization.