quick v erification of concurrent programs by iteratively relaxed scheduling patrick metzler habib saissi p ter bokor neeraj suri technische univerist t darmstadt germany metzler saissi pbokor suri deeds.informatik.tu darmstadt.de abstract the most prominent advantage of software verification over testing is a rigorous check of every possible software behavior .
however large state spaces of concurrentsystems due to non deterministic scheduling result in a slow automated verification process.
therefore verification introduces a large delay between completion and deployment of concurrent software.
this paper introduces a novel iterative approach to verification of concurrent programs that drastically reduces this delay.
byrestricting the execution of concurrent programs to a small set of admissible schedules verification complexity and time is drastically reduced.
iteratively adding admissible schedules after their verification eventually restores non deterministic scheduling.
thereby our framework allows to find a sweet spot between a low verification delay and sufficient execution time performance.our evaluation of a prototype implementation on well known benchmark programs shows that after verifying only few schedules of the program execution time overhead is competitive to existing deterministic multi threading frameworks.
i. i ntroduction automated verification of concurrent programs with nondeterministic scheduling is known to be challenging verification has to consider all possible schedules a concurrent pro gram may be executed with which may result in exponentiallymany states to be verified known as state space explosion .
partial order reduction por is able to reduce the state space of a concurrent program by identifying equivalenceclasses of program executions such that only one represen tative of each class needs to be verified .
such anequivalence class is called mazurkiewicz trace or simply trace.
however the reduced state space may still be of exponentialsize .
hence the high complexity of state space explorationfor concurrent systems remains and hinders a wide applicationof automated verification e.g.
model checking in industrialsoftware development.
in particular verification introduces a considerable delay between completion and deployment of software.
when de velopment of a candidate program is complete it may be deployed only after the verifier approved that it is correct under all possible schedules.
this verification delay reaches large values for benchmark programs even if state of the artpor is used .
we conjecture that the verification delayis unacceptably high for large areas of industrial softwaredevelopment.
nevertheless individual traces can be verifiedquickly as can be seen when relating verification time to thenumber of explored traces.in the area of concurrency testing deterministic multithreading dmt can help to reduce the number of necessarytest cases.
several techniques exist to restrict scheduling suchthat scheduling is deterministic for a particular inputand or only a reduced set of schedules may occur .such dmt techniques trade potential execution time overhead compared to executing the unmodified program for reduced non determinism that may simplify testing.
however these approaches do not allow to control the schedule that will occur in advance which renders them unsuitable for automatedverification of concurrent programs.
we are not aware of any existing tool or concept that allows to execute selectedschedules after they are successfully verified.
moreover it is not possible to adjust the amount of non determinism inexisting dmt approaches.
we propose to make the amount of non determinism and thereby the verification delay adjustable by using interme diate verification results and reducing non determinism bydynamically constrained scheduling.
in particular instead of waiting for verification to complete we propose to use inter mediate verification results that guarantee program correctnessfor one or more schedules.
by generalizing the concept of mazurkiewicz traces for symbolic model checking we areable to use por as a verification technique with intermediate verification results.
as soon as a single trace is verified theprogram may be used inside a suitable execution environmentwith constrained scheduling.
by continuously verifying andpermitting more traces scheduling constraints are iteratively relaxed and as shown by our evaluation execution time overhead is reduced.
thus execution time overhead can betraded for verification delay.
we provide the following contributions.
we develop a formal framework for iterative automated verification ofconcurrent programs.
we introduce the concept of symbolic traces as an extension and generalization of mazurkiewicz traces to symbolic model checking.
we discuss implemen tation issues for a suitable execution environment using ourprototype implementation for ll vm programs .
we show experimentally that only few traces need to be verified to considerably reduce execution time overhead.
ii.
o verview we propose iteratively relaxed scheduling irs for concurrent programs with non deterministic scheduling as an .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research new ideas776 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
v erifier execution environment unconstrained scheduling v erify program program can be safely used a conventionalv erifier irs execution environment v erify program submit initialschedule iterativelysubmit additional schedules permit allschedulesprogramcan be safely used b irs figure the program verification process sequence diagram improvement over the conventional approach to program verification develop a program or program update .
v erify the program.
the program can be safely used with unconstrained scheduling .
in case verification is successful correctness is ensured forall feasible schedules of the program.
this guaranty comesat the price of a typically large verification delay becauseof exponentially many schedules when unconstrained non deterministic scheduling is used.
instead of waiting until the program is verified for all feasible schedules we propose to start using the programalready after a use case specific threshold of schedules hasbeen verified.
correctness is guaranteed by wrapping theprogram in an irs execution environment which permits only verified schedules by constraining scheduling.
we provide details about irs execution environments in section iii.specifically verifying a concurrent program with irs proceedsas follows.
develop a program or program update .
continuously verify individual schedules or sets of schedules.
as soon as one admissible schedule is available the program can be safely used inside an irs executionenvironment.
additional verified schedules may be added during program usage to relax scheduling constraints.
the difference between conventional verification and irs is illustrated in figure .
while conventionally the verificationdelay corresponds to the full verification time irs enables toadjust verification delay and the amount of non determinismin scheduling the longer the verification delay the more schedules are verified and the fewer scheduling constraintsare necessary to enforce that only admissible schedules mayoccur.
constraining scheduling presumably introduces considerable execution time overhead.
while execution time overhead may be considerable relaxing scheduling constraints is able toquickly reduce this overhead.
our experiments show that iter atively relaxing scheduling constraints also iteratively reducesexecution time overhead which we detail in section v. given a positive relationship between relaxed scheduling constraints and decreased execution time overhead irs maybe used to exploit the sweet spot between a short verificationdelay and small execution time overhead.
in other words irs enables to use as much non determinism in scheduling as needed for execution time performance and no more nondeterminism than necessary in order to limit the verification delay.
an additional advantage of irs over conventional program verification is that programs that show both correct and erroneous schedules can be used safely as erroneous schedulesare never enabled.
such a program may be either correctedsuch that eventually all schedules can be enabled or leftunchanged such that the program is used with erroneous sched ules disabled.
in contrast conventional verification requires tocorrect the program so that the program is only available after verification is restarted and completed successfully.
please note that it is well possible that a program that is used inside anirs execution environment has erroneous schedules.
however program usage inside the irs environment is always safeas only correct schedules are enabled.
the only limitationin such a case is that the program cannot be used safely with all schedules enabled e.g.
outside the irs executionenvironment .
several scenarios of how to use irs are conceivable e.g.
safely deploy programs with large state spaces due to concurrency that are infeasible to fully verify.
in case a program update introduces a bug but correct schedules can still be found safely deploy the program with erroneous schedules disabled until the bug is fixed.
for a given time budget for verification maximum verification delay verify as much schedules as possible untilthe threshold is reached and deploy the program withthe remaining schedules disabled .
v erification delay isreduced.
for a given budget of execution time performance e.g.
maximum execution time overhead start verification andcontinuously test the execution time performance for theso far verified schedules.
as soon as the program isfast enough deploy the program with the remainingschedules disabled .
v erification delay is reduced.
in addition to continue verification after deployment and continuously extend the set of verified and enabled schedules.
execution time performance is increased afterdeployment.
it is required to update scheduling con777 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
straints online.
with a suitable implementation it is not necessary to update the program itself.
depending on the specific requirements of a use case it may be suitable or even necessary to combine or extendthese scenarios.
as we detail in section iv it is possible torealize an irs execution environment completely inside anapplication program without modifying the operating system.
in order to execute programs safely inside an irs execution environment i.e.
such that the specification is never violated while preserving usability i.e.
such that full program func tionality is available it must be ensured that intermediateverification results correspond to scheduling constraints thatdescribe how to remain inside the known to be safe statespace for arbitrary program inputs.
thereby it is guaranteed that the program is safely executed regardless of the current input.
while this requirement may be strong for programswith non deterministic inputs the same limitation applies forverification of sequential programs.
although there exist techniques to deterministically execute concurrent programs e.g.
in order to supportconcurrency testing irs constitutes a novel approach to verifying concurrent programs.
to our best knowledge all existing dmt approaches depend on concrete program inputsfor enforcement of a deterministic execution no guarantyis given about which schedule is used after a change inprogram inputs.
however program verification requires correctbehavior for every possible program input.
consequently using an existing dmt approach for verification would requireto verify a program separately for each individual input whichis typically infeasible.
iii.
a pproach a key requirement for a verification technique to be useful in conjunction with irs is to yield meaningful intermediateverification results.
otherwise safe execution of the programwould have to wait until the program has been verified forall schedules and irs would be reduced to conventionalverification.
meaningful intermediate verification results eithershow a counter example for program correctness or guaranteecorrectness under certain scheduling constraints.
no additionalconstraints should be necessary such as constraints aboutprogram inputs or execution length as a program may not befully operational under such constraints.
therefore techniquessuch as explicit state model checking or bounded modelchecking are unsuitable for irs.
partial order reduction por is a state space reduction technique suitable for symbolic model checking although it is often presented for explicit state model checking .
we choose por as a verification technique to instantiateirs and extend the notion of mazurkiewicz traces to a novelconcept of symbolic traces in order to support symbolic model checking with meaningful intermediate verification results.
an alternative technique for reducing the complexityof non deterministic scheduling iterative context bounding icb would equally fit to produce meaningful interme diate verification results.
however to our knowledge icb has not been applied to symbolic model checking before.
a. system model a concurrent program p is a transition system s s init wheresis a finite set of states sinit s is a set of initial states program intputs is a finite set of threads and p s arrowrighttophalfs is an acyclic transition relation for a given state and thread there is at most one successor state .
we write s1t s2to denote s1 t s .
apartial execution ofpis an initial state the program input for this execution and a sequence s0 u sinit whereu t1...t nsuch that there exist states s1 ... s nwith s0t1 s1 tn sn s0may be omitted if it is clear from the context or arbitrary .
in order to uniquely describe each occurrence tiof a thread in u it is associated with an event e nsuch that e t k withk tj j i tj ti i.e.
especifies the thread tiand the number of thread occurrences of tithat occur before position iinu.
we assume the existence of a dependency relation for p that induces a happens before relation between events and anotion of mazurkiewicz equivalence on partial executions .
we extend the notion of mazurkiewicz traces to symbolictraces as follows.
a symbolic trace or simply traceoofp is a graph o e o co o that represents a partial order the happens before relation of some partial execution uofp and all partial executions that are mazurkiewicz equivalent to u. we say that uis a linearization ofo.
letu t1...t n be an arbitrary linearization of osuch that there exist states s1 ... s nwiths0t1 s1 tn sn.eo e1 ... e n is a set of events such that eicorresponds to tifor1 i n. cois a set of sets of path constraints that may be collected during model checking .
o eo co eois an edge relation between events annotated with path constraints such that for every event ei eoand every incoming edge of eiwith path constraints c sisatisfiesc.
we write traces p for a set of traces that completely cover the state space of p i.e.
it is sufficient to verify all traces in traces p in order to decide correctness of p. b. algorithm given a program p we define an irs execution environment that is able to continuously receive representations ofadmissible traces from a verifier and schedule the programpsuch that only admissible executions occur.
v erifier and execution environment of pare defined by algorithm .
during execution of a program the irs execution environment maintains that the current partial execution s u adheres to the scheduling constraints represented by someadmissible trace o for which we write s u precedesorcurlyo.w e formalize this notion for a sequence u t1...t nwith s0t1 s1 tn snfor some states s0 ... s nandowith eventseo e1 ... e m as s0 u precedesorcurlyoif uis empty or authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm irs data v the set of admissible traces initially empty 1v erifier for each trace ointraces p do verifyo ifois correct then addoto the set of admissible traces v 6execution environment set the current partial execution s u to the empty sequence whilephas not terminated do choose some thread tfrom admissible v s u execute the next event of t appendttou there exists some ei eothat represents t1and for all incoming edges with path constraints c s0does not satisfycand s1 t2...t n precedesorcurlyremove ei o where remove ei o isowitheiand all incoming and outgoing edges of eiremoved.
intuitively s0 u precedesorcurlyocan be checked as follows if uis empty the condition is satisfied as they do not contain any events that can violate any ordering given by o.i fuis not empty check whether the first element ofucorresponds to an event eiinothat has no incoming edge that satisfies the current path constraints i.e.
no event has tobe scheduled before under the current program inputs .
thecondition is satisfied if uwithout its first element adheres to owithe iand all adjacent edges removed.
for a given partial execution s0 u and a set of admissible tracesv we define the set of all threads that can be executed next without violating adherence to an admissible trace asadmissible v s u t p o v. s0 u t precedesorcurlyo .
when large fractions of a program s state space are to be explored i.e.
when vcontains many traces time and space complexity of checking t admissible v s u and s0 u precedesorcurly omay be relevant.
an efficient implementation of algorithm may use for example a compact representation of multipletraces in a single data structure.
the execution environment representation of algorithm corresponds to the interleaving semantics of concurrent pro grams.
it does not show explicitly when threads wait forpermission to execute their next memory access.
in a simpleimplementation a thread waits before each memory access which corresponds to one wait operation per loop iteration ofthe execution environment.
for a possible implementation ofan execution environment please refer to section iv.
correctness in order to use irs for program verification it is necessary to ensure that an irs execution environmentpermits only correct traces i.e.
traces that show correctprogram behavior.
for algorithm it is clear that onlyexecutions that adhere to a admissible trace may occur bythe definition of admissible .
call i32 getthreadid class.indexer workunit this alloca i32 3store i32 i32 load i32 i32 bitcast i32 to i8 6call void before memory access i32 i8 i64 i32 cmpxchg i32 i32 i32 seq cst seq cst 8call void after memory access i32 listing a global memory access cmpxchg after inserting callbacks directly before and after.
progress besides correctness progress is required in order to safely use a program inside an irs execution environment with the same functionality as the unmodified program.progress for an irs execution environment expresses thatas long as a program has not yet terminated there exists a thread that can be scheduled next in coherence with a admissible trace i.e.
admissible v s u is not empty.
in other words progress means that irs does not introduceadditional deadlocks into the program.
algorithm providesprogress as only complete traces are added by the verifier.
iv .
i mplement a tion we have implemented irs in a c prototype that uses the ll vm compiler infrastructure to automatically in strument ll vm ir code and enforces a set of admissibletraces when executing the program.
this design allows to use irs for programs that can be translated to ll vm ir e.g.
c or c programs.
after instrumenting a program and linking to our irs library the program can be safely used provided that at least one correct schedule is known withoutmodifying the operating system or any other parameters of the environment.
we do not see fundamental obstacles to implement irs differently e.g.
inside a java virtual machine for programs that can be translated to java bytecode or witha customized scheduler inside the operating system.
our implementation consists of an ll vm pass responsible for instrumentation and a library that enforces specified tracesin instrumented code.
the instrumentation inserts a callback tothe library directly before and after memory access instructions load store compare and swap .
only those memory accesses are instrumented that directly access a global variable or wherethe address of the access depends possibly transitively onthe value of a global variable.
hence the library sees threadexecutions as a sequence of events that contain exactly one global memory access.
we consider two events dependent if they access the same memory location and at least one of themis a write operation.
listing shows the global memory access of the indexer benchmark and how callbacks are inserted.
identifiers havebeen renamed for easier readability.
only line contain ing the compare and swap instruction cmpxchg is contained in the original program.
all additional lines are added by our instrumentation.
before the memory access thread id memory location and whether the access can modify thememory are reported by callback before memory access to the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
library where the event is recorded.
after the memory access callback after memory access signals that the memory access is completed.
at the beginning of the program an additional scheduler thread is started which collects recorded eventsand decides whether an event is currently admissible.
when a program thread enters the callback function before a memory access it checks whether it is necessary to wait foran other thread in order to follow the set of admissible traces.
only if this is the case synchronization with the schedulerthread is necessary.
the program thread appends its currentevent to a queue of requests and waits on a c conditionvariable.
once the scheduler thread reads the request andthe corresponding event is admissible the program thread issignaled and continues by locking the memory location ofthe current access performing the memory operation andrecording the executed event.
when testing our implementation we found that as expected locks and condition variables are responsible for alarge portion of execution time overhead.
in order to reduce thenumber of locks we introduced busy waiting in the schedulerthread which made synchronization between program threadsand the scheduler thread faster for most cases.
however insome cases synchronization may also be much slower whichmay be a disadvantage if execution time should never exceeda tight maximum.
we expect further improvement by the useof more advanced lock less synchronization.
alternative implementation approaches that do not use an additional scheduler thread are well conceivable and we expectimportant insights from comparing different implementation approaches.
for example it might be overall faster to perform scheduling tasks locally in program threads instead of thescheduler thread.
even if this duplicates work execution timemight be improved by omitting synchronization.
v. e xperiment al ev alua tion we concentrate our experimental evaluation on supporting the claim that iteratively relaxing scheduling constraints decreases execution time overhead.
experimentally validating this claim would show that it is feasible to use irs to adjustand find a sweet spot between verification delay and executiontime overhead.
as development of our prototype is only in anearly stage we do not provide a full experimental evaluation but report preliminary results for two benchmark programs indexer and last zero that are used to evaluate poralgorithms.
these programs have been chosen because model checking them with por is well studied.
we use the last zerobenchmark with worker threads for which abdulla et al.report traces and 1813s execution time for por.
for indexer we use threads where abdulla et al.
report traces and 3155s execution time for por .
table i shows our experimental results.
each benchmark is run without instrumentation plain and instrumented by our prototype irs .
the number of admissible traces isgradually increased.
each configuration is run times.
wereport the median execution time and execution time overheadin comparison to the unmodified benchmark.
illustrating thetable i e xecution time overhead of irs and verifica tion dela y benchmark traces time s overhead delay s interpolated last zero irs last zero irs last zero irs last zero irs last zero plain indexer irs indexer irs indexer irs indexer irs indexer plain interplay of execution time overhead and verification delay weshow the linearly interpolated verification delay for verificationtimes given by abdulla et al.
as an approximation of howlong a model checker would need to verify the correspondingnumber of traces.
for both benchmarks execution time overhead can be reduced considerably by permitting only a small portion ofall traces.
for last zero permitting less than of all tracesreduces execution time overhead from to .
forindexer permitting of all traces reduces execution timeoverhead from to .
however execution timeoverhead is reduced less drastically when additional traces arepermitted.
nevertheless execution time overhead with onlyfew admissible traces is competitive with the execution timeoverhead of up to about and reported for coredetand dthreads .
vi.
r ela ted work approaches that attempt to limit the amount of nondeterminism in the behavior of multi threaded programs per form deterministic multi threading dmt and may be imple mented using runtime systems libraries andos modifications .
liu et al.
present dthreads as a re placement for the multi threading library pthreads.
for a given input dthreads forces a deterministic execution by allowing threads to execute in parallel updating separate copies of theshared state.
the separate copies are then merged back in adeterministic order once a synchronization point is reached.
in cui et al.
propose to enforce deterministic schedules byrecording initial executions and reusing the executed schedulesubsequently on compatible executions with similar inputs.another deterministic approach is parrot which combinesa runtime environment with constrained scheduling with amodel checker for bug finding.
only performance critical partsof the program need to be model checked that are manuallyexcluded from deterministic scheduling.
the main difference between these dmt approaches and irs is that the former support concurrency testing while our approach is suitable for program verification by supporting symbolic program inputs.
using existing dmt approaches for verification seems unrealistic as their scheduling constraintsdepend on concrete program inputs which would requireto verify all possible inputs separately.
another limitation authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of above described dmt approaches are fixed scheduling constraints that cannot be relaxed at runtime.
in contrast our approach allows to automatically and iteratively relaxscheduling constraints at runtime eventually leading to allschedules that are successfully verified being permitted.additionally these dmt approaches either provide no fairnessin scheduling completely deterministic execution or providefairness for parts of the program by completely unconstrainedscheduling.
irs in contrast may provide controlled fairnessby enabling corresponding schedules and enabling them.
another line of work deals with limiting the number of context switches to facilitate concurrency bug detection and concurrency testing.
in and programs are model checked using bounded model checking bmc where the smt formula is further constrained to allow only a certain number of context switches.
by so they reduce thenumber of program executions that the sa t smt solver hasto consider.
musuvathi et al.
take this further by usingan iterative approach to context switch bounding icb .
theystart with an initial number of context switches and iterativelyallow more to gain a higher confidence in the correctness ofthe program.
in this approach the model checker implementsan explicit state space exploration strategy that systematicallyexplores all possible executions as long as a number of contextswitches is not exceeded.
while these techniques only dealwith bug finding and concurrency testing irs proposes a complete verification deployment solution.
nevertheless weexpect that the concept of icb can be applied to symbolic model checking as well and therefore could be used as averification technique under irs.
to our knowledge icb hasnot yet been applied to symbolic model checking.
in addition to scheduling a source of non determinism are relaxed memory models in modern architectures.
relaxedmemory models allow more feasible orderings than the morerestricted sequential consistency model sc leading to moreprogram behavior that has to be covered by the model checker.in a memory monitoring approach is proposed to makesure that sc is maintained during the execution of a program.fang et al.
in present an automated memory fenceinsertion technique to enforce sc using instrumentation atthe source code level.
in both cases the program can besafely verified under the assumption that sc holds with areduced state space.
similarly to irs these approaches restrictthe amount of non determinism.
however in contrast to irs they are not able to dynamically adapt the amount of non determinism and are restricted to non determinism due torelaxed memory access.
vii.
c onclusion we propose a formal framework for iteratively relaxed scheduling irs as a method to make both verificationdelay and the amount of non determinism in scheduling ofconcurrent programs adjustable.
by enforcing scheduling constraints multi threaded programs can be safely used even if the program has only partially been verified.
we outline severalscenarios of how to use irs to enable verification of programswith intractably large state spaces enable safe deployment of programs with erroneous schedules handle verificationwithin a given time budget manage execution time overhead and increase execution time performance after deployment.our preliminary experimental results suggest that iterativelyrelaxing scheduling constraints gradually reduces executiontime overhead.
a cknowledgments we thank the anonymous reviewers for their constructive comments.
research supported in part by h2020 escudo cloud .
r eferences a. v almari the state explosion problem in lectures on petri nets i basic models advances in petri nets ser.
lncs vol.
.
springer .
e. m. clarke o. grumberg m. minea and d. peled state space reduction using partial order techniques international journal on software t ools for t echnology transfer sttt vol.
no.
.
p .
godefroid partial order methods for the v erification of concurrent systems an approach to the state explosion problem ser.
lncs.springer vol.
.
c. flanagan and p .
godefroid dynamic partial order reduction for model checking software in symposium on principles of programming languages popl .
acm .
g. gueta c. flanagan e. y ahav and m. sagiv cartesian partialorder reduction in international spin w orkshop ser.
lncs vol.
.
springer .
p .
a. abdulla s. aronis b. jonsson and k. f. sagonas optimal dynamic partial order reduction in symposium on principles of programming languages popl .
acm .
t. liu c. curtsinger and e. d. berger dthreads efficient deterministic multithreading in symposium on operating systems principles sosp .
acm .
h. cui j. simsa y .
lin h. li b. blum x. xu j. y ang g. a. gibson and r. e. bryant parrot a practical runtime for deterministic stable and reliable threads in symposium on operating systems principles sosp .
acm .
a. w .
mazurkiewicz trace theory in advances in petri nets .
the ll vm compiler infrastructure h. cui j. wu j. gallagher h. guo and j. y ang efficient deterministic multithreading through schedule relaxation in symposium on operating systems principles sosp .
acm .
b. wachter d. kroening and j. ouaknine v erifying multi threaded software with impact in f ormal methods in computer aided design fmcad .
ieee .
m. musuvathi and s. qadeer iterative context bounding for systematic testing of multithreaded programs in conference on programming language design and implementation pldi .
acm .
t. bergan o. anderson j. devietti l. ceze and d. grossman coredet a compiler and runtime system for deterministic multithreadedexecution in international conference on architectural support for programming languages and operating systems asplos .
acm .
a. aviram s. weng s. hu and b. ford efficient system enforced deterministic parallelism in symposium on operating systems design and implementation osdi .
usenix association .
i. rabinovitz and o. grumberg bounded model checking of concurrent programs in international conference computer aided v erification ca v ser.
lncs vol.
.
springer .
l. c. cordeiro and b. fischer v erifying multi threaded software using smt based context bounded model checking in international conference on software engineering icse .
s. burckhardt and m. musuvathi effective program verification for relaxed memory models in international conference computer aided v erification ca v ser.
lncs vol.
.
springer .
x. fang j. lee and s. p .
midkiff automatic fence insertion for shared memory multiprocessing in international conference on supercomputing ics .
acm .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.