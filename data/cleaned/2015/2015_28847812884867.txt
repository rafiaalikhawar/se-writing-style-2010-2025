automated energy optimization of http requests for mobile applications ding li yingjun lyu jiaping gui and william g. j. halfond university of southern california los angeles california usa dingli yingjunl jgui halfond usc.edu abstract energy is a critical resource for apps that run on mobile devices.
among all operations making http requests is one of the most energy consuming.
previous studies have shown that bundling smaller http requests into a single larger http request can be an e ective way to improve energy e ciency of network communication but have not de ned an automated way to detect when apps can be bundled nor to transform the apps to do this bundling.
in this paper we propose an approach to reduce the energy consumption of http requests in android apps by automatically detecting and then bundling multiple http requests.
our approach rst detects http requests that can be bundled using static analysis then uses a proxy based technique to bundle http requests at runtime.
we evaluated our approach on a set of real world marketplace android apps.
in this evaluation our approach achieved an average energy reduction of for the subject apps and did not impose a signi cant runtime overhead on the optimized apps.
categories and subject descriptors d. .
testing and debugging keywords energy optimization mobile apps http requests .
introduction mobile devices such as smartphones and tablets allow users to download and run millions of di erent apps.
these apps combine sensor data and live access to the internet to provide both entertainment and crucial services to end users.
however the overall usability of mobile devices is limited by their battery life.
therefore optimizing the energy consumption of these apps can allow users to more fully utilize their mobile devices and take advantage of the services provided by their apps.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
communication is one of the primary energy consuming operations in mobile apps.
on average network communications can consume over of the total non idle state energy of an app .
among all kinds of network operations those related to http are the most energy consuming representing almost of all network related energy consumption .
therefore reducing http related energy consumption can have a signi cant impact on the overall energy consumption of an app and improve the overall user experience by increasing the underlying device s battery life.
traditionally optimizing network communication energy usage has been seen as a hardware or os level concern.
however over the past couple of years a growing body of work has begun to investigate ways to optimize network energy consumption at the application layer.
one of the more promising ideas has focused on ways to bundle http requests combining multiple small http requests into a larger http request.
this has been very successful in the web browser domain for improving performance .
in this domain bundling has targeted multiple parallel asynchronous http requests such as ajax calls to reduce the average network latency of http requests.
however these automated bundling techniques developed for web browsers cannot be used to reduce network energy consumption for mobile apps because they only target asynchronous http requests which are common in ajax based web apps but are far less common in mobile apps.
our recent work has shown that bundling http requests can also decrease energy consumption for mobile apps but did not provide any way to automatically detect when apps should have their requests bundled nor de ne a way to automate the bundling process.
in this paper we present a comprehensive approach for detecting when certain types of http requests can be bundled and for rewriting the app so that the bundling can happen at runtime.
our approach can be roughly broken down into three phases detection bundling analysis and runtime optimization.
in the rst phase we employ static analysis based techniques to identify http requests that can be safely bundled together.
in the second phase we use string analysis to identify relationships between requests in bundles and con gure a set of bundling rules.
these rules are then used in the third phase at runtime by a proxy server which detects the start of sequences that can be bundled and uses the bundling rules to carry out the optimization.
we performed an extensive empirical evaluation of our technique and ran it against a set of real world mobile apps.
ieee acm 38th ieee international conference on software engineering in our experiments we found that our technique could reduce on average of the apps total energy consumption.
our approach was also fast it analyzed and optimized each mobile app in under ninety seconds and did not impose any runtime overhead on the execution of the apps.
lastly we ran our detection algorithms on marketplace apps and found that .
of the apps with more than one http api invocation could potentially be optimized by our technique.
this implies that over apps in the google play app store could bene t from using our technique.
overall these results are very positive and indicate that our approach can signi cantly decrease energy consumption for a large number of mobile apps.
the structure of this paper is as follows.
in section we introduce background information about http requests in mobile apps and summarize our previous ndings.
we give an overview of our approach in section .
we introduce the details of the three phases of our approach in section section and section .
the results of our evaluation are reported in section and we discuss threats to the validity of our evaluation in section .
finally we have related work in section and the conclusion in section .
.
background the process of making an http request consumes a large amount of energy due to the underlying operations such a request entails.
http is part of a multi layer network protocol stack which includes tcp ip and various hardware level protocols.
when an http request is sent it is necessary to encapsulate it in packets of lower level protocols.
this process often involves calculating checksums copying data and referencing data bu ers.
many such operations result in high energy consumption for even a single http request.
http also requires a signi cant overhead of extra data and messages to be sent when it makes a request.
in other words the size of the http data sent is not the only data transmission cost.
the overhead of an http request comes in three forms.
first each packet must contain a set of headers.
although each one of these is small by itself in total a typical http packet may contain anywhere from 200b to 2kb worth of headers.
second the establishment or disconnection of each http connection requires a multimessage handshake protocol at the underlying tcp layer.
to establish a connection requires a way tcp handshake and to disconnect requires a way handshake protocol.
for both handshake protocols the packets are typically empty so no useful http data is sent.
third each http api request also has tail energy which is independent from the size of the request.
tail energy occurs when the system keeps the network radio in the active state after an http request is nished.
this is typically done to attempt to reduce the high energy overhead of starting and shutting down the wireless radio.
although seemingly small the overhead of an http request can have a signi cant impact on its energy e ciency.
in prior work we found that downloading one byte of data via http consumed the same amount of energy as downloading bytes of data and downloading bytes of data only consumed twice the amount of energy as downloading bytes of data.
compounding the problem is that many modern apps only need to send small amounts of information to the server per request.
for example aprevious study found that of non video requests were below 10k bytes .
these insights motivate our decision to focus on http optimization and in particular our decision to focus on reducing the amount of unnecessary http connections.
.
overview of the approach the goal of our approach is to reduce the number of http requests made by a mobile app.
to do this we developed an approach to detect and bundle http requests that can be made together.
more speci cally our approach rst detects sequential http requests sessions shrss which are sequences of http requests in which generation of the rst request implies that the following requests will also be made and then merges these requests into one request.
an example of an shrs is shown in program .
here h1 h2 and h3 represent an shrs since after the generation of the rst request the other two will always be executed.
our approach attempts to detect such situations and rewrite the client side code to combine the requests where possible so that there are overall less http requests.
our approach can be roughly described as having three phases.
in the rst phase shrs detection our approach uses static analysis to identify all of the shrss in an application under test aut .
once these are identi ed the second phase bundling analysis analyzes the shrss to generate code that at runtime will be executed to facilitate the bundling of the http responses of an shrs.
the third phase optimization occurs at runtime.
in this phase a proxy intercepts the http requests and runs the bundling code to return all of the corresponding shrss responses.
we now explain each of these phases in more detail.
.
shrs detection the rst phase of our approach is responsible for detecting the shrss in an aut.
the input to the phase is the aut and the output is the set of identi ed shrss.
to perform the detection we rst de ne an intra procedural static analysis to identify shrss within a method and then use per method summaries to perform the analysis interprocedurally.
.
definition of an shrs we de ne an shrs as a sequence of http or https api invocations s hh1 h2 hnithat satisfy the following conditions .
for any hiandhj ifi j hiis post dominated by hj in the app s control flow graph cfg .
.
for any hiandhjwhere i j if there is another http api invocation h0on a path from hitohjin the cfg then h02s.
the rst condition guarantees that the execution of the rst http api invocation in simplies that the remaining invocations will be executed sequentially.
referring to the example shrs of h1 h2 and h3in method print html of program this represents the relationship that executing h1implies h2will also be executed.
the second condition ensures that the execution of http apis in an shrs will maintain the original server side state transitions when the requests are bundled.
to illustrate consider the print html 2501public void main 2f url url0 url6 initialize the session url0 new url urlconnection0 url0.openconnection parse urlconnection0.getinputstream h0 print html getcity close the session url6 new url http close urlconnection6 url6.openconnection parse urlconnection6.getinputstream h6 13g 14public void print html string city 15f url url1 url2 url3 url4 url5 urlconnection urlconnection1 urlconnection2 urlconnection3 query current weather url1 new url urlconnection1 url1.openconnection parse urlconnection1.getinputstream h1 query weather forcast url2 new url city urlconnection2 url2.openconnection parse urlconnection2.getinputstream h2 query location info url3 new url city urlconnection3 url3.openconnection parse urlconnection3.getinputstream h3 query the information about the city if cond 32f url4 new url urlconnection4 url4.openconnection parse urlconnection4.getinputstream h4 36g get the rate of the city url5 new url urlconnection5 url5.openconnection parse urlconnection5.getinputstream h5 41g program example code containing shrss.
method in program .
assume that each hncauses the server side state to be sn.
if line is true then server side state transition will be s1!s2!s3!s4!s5.
if line is false then the transitions are s1!s2!s3!s5.
without the second condition an shrs containing h1 h2 h3 h5 could be identi ed.
if these requests were bundled and line was true the server side would transition s1!s2!
s3!s5!s4.
here the transition s5!s4is incorrect.
note that our de nition of an shrs includes both http and https request invocations.
as we explain in section .
as long as the proxy is con gured with the correct cryptographic key our approach can properly handle https as well as http tra c. .
intra procedural analysis figure the post dominator tree in program we de ned an intra procedural analysis to detect shrss within a method.
the input of the analysis is a method mof the aut and the output tmis the set of shrss de ned within m. our approach begins by generating the post dominator tree p ofm.
the approach then creates a projection of p which we call p0 that contains only nodes that make http api invocations and edges that represent these invocations post dominance relationships.
figure shows the projection of the post dominator tree for method print html in program .
the approach then identi es the shrss by analyzing p0.
to do this the approach identi es maximal sequences of consecutive nodes in p0in which an edge enters at the beginning of the sequence and exits at the end without the possibility of branching except at the end.
these sequences are analogous to basic blocks in controlow graphs but are de ned over the projection of the post dominator tree.
for the purpose of de ning these sequences we consider all calls invocations to be non branching and ignore exceptional controlow.
the sequences identi ed by this analysis are returned as tm the shrss in the aut.
figure shows the shrss identi ed for program hh1 h2 h3i hh4i andhh5i in dotted boxes.
these are denoted as shrs shrs and shrs respectively.
although shrs 2andshrs 3are of size one and cannot be optimized based on intra procedural information they may be part of an shrs de ned interprocedurally so they are still tracked.
the sequences identi ed in this analysis satisfy both of the shrs conditions.
first since all http api invocations are in a sequence in the post dominator tree they maintain the rst condition.
second since a sequence of nodes i.e.
a basic block contains no branches except at the last node it guarantees that all nodes along the sequence are not interrupted by other http requests on the cfg.
.
inter procedural analysis our approach also analyzes the aut to identify shrss that are de ned inter procedurally.
an example of such an shrs ishh5 h6i.
to perform the analysis inter procedurally we extend our intra procedural analysis to use and generate per method summaries.
we analyze all methods of the aut in reverse topological order with respect to the aut s call graph cg .
this ensures that a method miis summarized before the approach analyzes another method mjthat calls mi.
cycles in the cg are handled by merging the individual methods cfgs and treating them as one method.
the summary for each method min the aut represents the sub tree of p0that represents shrss that post dominate the entry of m. the approach uses these shrss as the summary because they are guaranteed to be executed when mis invoked.
this sub tree which we call p00 is identi ed by analyzing p0 which was identi ed in the intra procedural analysis.
the approach identi es all shrss in p0on the path from the entry node to the exit node of m which by de nition are the shrss that post dominate the entry node.
referring to figure this is shrs 1andshrs .
h0 shrs1 shrs3 h6shrs0 shrs4 figure the summary of main in program to use the summaries the approach adds a preliminary step to the intra procedural analysis and modi es the sequence de nition.
first before generating p the approach replaces all invocations to summarized methods with 251the target methods summary.
the replacement process for an invocation i rst connects the predecessor of ito the entry node of the summary and the exit node of the summary to the successor of i then removes ifrom m s cfg.
next the replacement process reverses all edges within the summary and marks them as having come from the summary.
second the de nition of a sequence is modi ed as follows.
no two nodes may be present in a sequence if they are joined by an edge that came from a summary.
for all other purposes the nodes from the summary are treated as instances of an atomic http api invocation.
the purpose of these specially marked edges is to prevent shrss such ass3ands1 from being joined together once they are used in the calling method s context.
figure shows the result of the summary substitution on the cfg of the main method.
here the summary edge is shown as a dashed line and the two shrss that will be identi ed by the intra procedural analysis are shown as dotted boxes.
once the analysis has nished analyzing the root method in the aut s cg it takes the union of the tmfor all methodsmin the aut.
then it expands all summary nodes e.g.
shrs to their constituent http api invocations.
for the example in program the reported set of shrss is fhh0 h1 h2 h3i hh5 h6ig .
bundling analysis in the second phase of our approach the analyzer examines each shrs to calculate the needed bundling information and rewrites http api invocations so they will use the response bundles.
the inputs to the analyzer are the aut and the shrss identi ed in the detection phase.
the output is a bundler for each shrs in the aut and aut0 which is the original aut transformed to carry out the bundlings at runtime.
a bundler is a function that decides which http requests should be bundled for the shrs and is invoked at runtime by the proxy.
the bundler has two components the tester and the operator .
the tester is a set of regular expression patterns that match the url of the rst request in an shrs.
the operator calculates which http requests should have their responses bundled and is called when the tester matches a request.
the tester and operator are separated so that the proxy does not have to call the more heavyweight operator every time a new request arrives.
the analyzer rst rewrites the http api invocations in the aut and then analyzes the information provided as arguments to the invocation to generate both components of the bundler.
we explain details of the underlying analyses in the rest of this section.
.
string analysis an http request is composed of a target url a set of headers and parameters.
http is a string based protocol so if the developer provides these values then they are provided as strings or via functions that are ultimately mapped to strings.
therefore to identify the components of the http requests we use a string analysis tool violist to identify the values of the variables used as arguments to the various http api invocations.
violist uses a two phased analysis.
first it generates an intermediate representation ir of string operations for a given string variables at a point in an aut and then it applies custombuilt interpreters to the ir to generate a model of the possible string values it can have at runtime.
the analyzer needs two di erent types of string interpretations which can be easily handled by violist.
we summarize these below but more details are provided in the violist paper .
the rst type of interpreter which we call the safe interpreter si is one that provides a safe approximation of a string variable s possible values.
this means that the interpreter generates models that could be described as an over approximation of the variable s possible values.
the si handles loops by using the widen operation proposed by yu and colleagues to generate a safe finite state automaton fsa based model of the possibly in nite string values in a loop.
the si models any substring that cannot be resolved statically such as user input or les as any string i.e.
.
.
the second type of interpreter which we call the concrete interpreter ci provides precise approximations that may not necessarily be safe.
for example the ci unravels loops assuming an upper bound non the loop s iterations.
as with the si the ci also identi es substrings that cannot be resolved statically such as user input or les but represents these using placeholders with unique ids that correspond to the variables that could not be resolved.
these unique ids facilitate later comparisons of requests at runtime by the operator section .
.
rewriting http api invocations the rst step of the analyzer is to rewrite the aut so that all http api invocations can make use of the bundling invocation.
this is done by replacing each http or https api invocation in the aut with an agent http api aha which is a wrapper for the original invocation.
the aha is a static method call that takes the same parameters as its wrapped invocation along with a call site id csid that uniquely identi es each original invocation and returns the same type of response object as the wrapped invocation.
this design ensures that there is no impact of the optimization on other network related functionality.
at runtime the aha sends requests to the proxy instead of the original server and manages the unpacking and distribution of the bundled responses.
more details on the runtime behavior of the aut0are given in section .
.
.
generating the tester to generate the regular expressions for the tester the approach analyzes the arguments for the rst invocation in each shrs.
due to the de nition of the android network api string values are not supplied directly to the apis that make the network requests.
instead the string values are used to initialize url header and data objects that are then used as arguments for the network request.
to address this the analyzer uses standard alias analysis techniques to identify the allocation sites for the objects provided as arguments to the network requests.
then once the allocation or initialization site for the object has been found the analyzer uses the si to solve for the possible string values.
for example at line of program urlconnection getinputstream is the api that makes http requests but its parameter is the object urlconnection2 rather than the string.
the approach uses the alias analysis to gure out that the url for the http request at line is de ned at line and then performs the 252string analysis on the variables at line .
after that our approach uses the generated regular expression as the tester.
a safe approximation is preferred instead of a precise one so that the tester can automatically generate a pattern that will be guaranteed to recognize the incoming request.
since the models produced by the si are fsa based it is straightforward to convert them to regular expressions.
.
generating the operator to generate the bundling code of the operator the analyzer identi es the values of the arguments to the remaining invocations in the shrs.
the identi ed requests will be sent by the proxy when it receives the rst request in an shrs.
this process is analogous to the analysis done for the tester but uses the ci to solve for the string values.
the analyzer uses the ci because only shrss for which all requests can be solved precisely will be optimizable.
an over approximation is undesirable because it means the proxy will return additional spurious responses reducing energy savings.
the operator can solve requests precisely in two cases which we explain below.
for four of the ve apps used in the evaluation these two cases were su cient for all of the shrss.
case constant http request an http request is constant when there is only one possible value for the request information.
note that any of these values may itself be de ned by expressions e.g.
concatenation over multiple constant substrings as violist is able to evaluate string operations.
in general string values de ned via loops or unknown string data e.g.
les are not constant.
if a request is constant then the ci can precisely identify the string representation of the request and this is saved by the operator.
case decisive semi constant http request an http request is semi constant if values of the request information such as the url and parameters are simple combinations of constants and unknown variables such as user input.
once the values of all unknown variables are provided there is no ambiguity in the request that the http api invocation can make.
for example the ve http apis in the method print html of program are semi constant since their values are known once the value of the unknown variable city is provided.
we say a semi constant http api is decisive if its unknown variables are the same as the unknown variables of the beginning invocation in its shrs.
for example h2andh3are decisive semi constant requests because they have the same unknown variable city as the beginning invocation h1 in their shrs.
in our approach the analyzer rst detects decisive semiconstant http apis in an shrs with the following steps.
first the analyzer nds all non beginning http requests in an shrss that are semi constant.
this is done by parsing the ir generated by violist.
for an http api if the ir shows that the variables that represent its url elds in headers and parameters have no branches and loops the http api is semi constant.
we use this rule to check semiconstant http apis because the ambiguity of the url headers and parameters of an http api can only be from branches loops and unknown variables.
second for each of the semi constant http apis in shrss we compare its unknown variables against the unknown variables in the beginning invocation of its shrss.
if all the unknown variables are also in the beginning invocation the request is decisive.
at runtime the operator generates the concrete value of thedecisive semi constant requests by parsing the beginning request of the shrs.
the operator does this by using regular expressions to retrieve the values for the unknown variables and substituting them into the subsequent requests.
we take the shrs of h1 h2 and h3in program as an example.
for the conciseness of the paper we ignore the headers and parameters of the http apis since they are all constant in this case.
in the rst step our approach checks ifh2andh3are semi constant http apis since they are not the beginning http api invocations of any shrs.
the approach analyzes h2andh3and nds that their urls contain the unknown variable city but this part is not de ned in branches or loops.
thus both of them are semi constant http apis.
in the second step the approach compares the unknown variable city inh2andh3against the unknown variables in h1 which is the beginning invocation in the shrs of h2andh3 and nds that they are the same.
so the approach determines that h2andh3are decisive semi constant http requests.
finally the analyzer generates code for the operator that uses the regular expression to retrieve the value at runtime of the variable cityand puts this value into the request ofh2andh3.
all other cases for the requests that are not constant or decisive semi constant the analyzer does not generate bundling code directly.
instead it records the regular expressions describing the request information along with relevant relationships between the variables.
namely which ones are the same in di erent requests.
the analyzer generates these patterns using the same technique described in section .
.
the expressions and relationship information is then provided to the developer who may manually specify the form of the requests to be made and de ne bundles of requests.
operator customization our approach allows developers to further tune up the generated operator with domain speci c knowledge.
this tune up is useful to verify the correctness of the generated bundling rules and to achieve speci c trade o s during the bundling.
for example developers may want to avoid bundling an shrs if they think the bundling could introduce a noticeable latency to a certain critical http request in an shrs.
our approach exposes the rules of the generated operator to developers and the tune up can be done by directly adjusting the rules and generated code.
figure the runtime work ow of our approach.
.
runtime optimization the third and nal phase occurs when the aut0is executed.
at runtime the ahas inserted into the aut0redirect all requests to a proxy which then uses the bundlers to determine the requests that should be bundled together.
253the proxy sends these requests to the server bundles the responses and returns this bundle to the aut0 where they are unpacked and managed by the ahas.
this runtime work ow is shown in figure .
in this gure the dotted lines show the old work ow and the solid lines show the new work ow.
.
the agent http apis ahas the role of the aha is to carry out the client side operations of the optimization process while hiding the details of the optimization from the application.
when an aha in the aut0is invoked it carries out two steps.
first the aha checks if the response for the current request is already cached locally.
if so this means that the response was already retrieved by a previous http request in the same shrs and the aha directly returns the cached response.
if not the aha generates a bundle request and sends it to the proxy.
a bundle request is an http request that is identical to the original request but also contains two special header elds to identify the originating csid and the url of the original request.
second when the aha receives the bundled responses it unpacks the bundle returns the response for the originating request and then caches the responses for the remaining requests in the shrs.
.
the proxy the proxy carries out the server side part of the optimization process.
at runtime the proxy receives bundle requests identi es which responses should be bundled together and returns these to the client side.
to identify the responses that should be bundled together the proxy passes the url and csid contained in the bundle request s headers to the testers de ned by the proxy s bundlers.
if a tester determines that the request is the rst part of an shrs then the corresponding operator is used to identify the request information i.e.
urls and parameters of the subsequent invocations in the shrs.
these requests are then sent in sequence to the app s server.
the proxy then bundles these responses and returns them to the client where they are unpacked and managed by the ahas as described in the previous section.
the proxy should be deployed on the same machine or in the same local network as the server.
this is not a requirement for correct functionality but ensures a low latency connection to the original server and avoids any signi cant slow down due to network delays.
we do not expect that this type of deployment would be di cult since the owners or developers of the aut generally have control over the deployment of the app s server.
also to properly handle https the proxy also needs to use the same cryptographic signature as the original server.
.
maintaining server side states our approach has to maintain the server side states transitions during http bundling.
one challenge is to ensure the order of http api invocations in shrss maintain the server side state transitions.
this is addressed by our de nition of shrss which requires that requests in an shrs must be guaranteed to execute if the rst one executes i.e.
they post dominate the rst request.
another challenge is to distinguish http api invocations that have the same request information but from di erent http api invocations.
we need to address the second challenge becausetwo http api invocations may have di erent responses if they have the same request information but di erent server side states.
our approach addresses the second challenge by associating a unique csid to each http api invocation which will be passed between the client side and the server side.
whenever our approach needs to query the response for a certain http api invocation i.e.
from the cache in an shrs it always uses the csid along with the request information.
the server may impose global states for all clients.
for example two independent clients may modify a global counter of total active clients at the same time.
in this case bundling http apis in shrss may change the order of requests across di erent clients and get unexpected server side global states.
our approach does not impose any constraints in the case of global server side states because the order of requests across di erent clients are generally not guaranteed in most mobile apps.
even if we were to not bundle http requests in an shrss the requests could still return unexpected global states.
furthermore if the order of requests from di erent clients is important developers can still choose not to bundle the requests to avoid potential mistakes.
.
handling exceptions exceptions may interrupt the execution of shrss and introduce two challenges to our approach downloading responses for unreachable http apis and introducing unexpected server site states.
we take an example to explain these two challenges.
suppose there is an exception at line of program .
in this case h3will not be executed in the shrs.
however if we bundle the shrs of h1 h2 and h3at the location of h1 we will have two issues.
first the energy consumed by retrieving the response of h3is wasted.
second the expected server side state should have transition as s1!s2 but it actually has the transition as s1!s2!s3 since h3is also requested together with h1.
to address these two challenges we provide two options for developers.
the rst option the greedy option is to ignore the potential exception ow and bundle the shrss despite the possibility of them being interrupted by exceptions.
this option is applicable for cases in which exceptions rarely happen and there is no hard restriction on the server side states.
with the greedy option our approach can still optimize the energy for shrss in most cases.
the second option which is the safe option avoids bundling shrss that may be interrupted by exceptions.
this option should be used if the server side states need to be strictly maintained when there is an exception.
by using the second option our approach is safe and avoids any unexpected server side states and energy consumption of retrieving responses for unreached code yet it may miss some opportunities to bundle larger shrss.
.
ev aluation we evaluated our approach to determine how well it could perform in practice.
in our evaluation we considered energy savings required developer e ort for cases where the analysis could not be fully automated analysis time runtime overhead and the prevalence of shrss in marketplace apps.
our research questions are listed below rq how much energy could be saved by using bouquet?
rq how much manual e ort is needed to augment the bundler?
rq how long is the analysis time of bouquet?
rq how much runtime overhead is introduced by bouquet?
rq what is prevalence rate of shrss in marketplace apps?
.
implementation our approach is implemented as a tool bouquet that automatically detects shrss generates code to bundle http requests and rewrites the auts.
bouquet works for android apps.
we chose android because it is a widely used open source system but our approach is also applicable for other platforms such as windows phones and ios since the mechanism of making http requests is similar on these platforms.
to implement the aut instrumenter we used the apktool to unpack android apps dex2jar to convert dalvik bytecode of android apps to java bytecodes and the bcel library to replace the http api invocations with the ahas.
to implement the shrs detector and the analyzer we leveraged the soot framework to build analysis data structures such as the control ow graph and the call graph.
the proxy and the bundler in bouquet were implemented as a nodejs server app.
we used the express framework to handle the incoming http requests in the proxy.
in our experiments we deployed the proxy and the mockserver on the same machine which was a dell xps desktop running linux mint with an intel core i7 3ghz processor and 8gb memory.
the machine was connected to a local wifi router which was linked to the school network of the university of southern california.
the platform on which we ran our subject apps was a samsung galaxy s5 smartphone which was also connected to the same wifi router of the server.
.
subject apps to measure the energy saving of bouquet we selected ve apps that contained shrss.
to ensure the representativeness of our subjects we selected apps that used the two most common apis for making http requests in android which are urlconnection and httpclient and both the get and post methods of http requests.
these ve apps were selected from the google play marketplace apps that we analyzed for rq5.
the descriptions of our selected apps are in table where bytecode represents the size of an app in terms of the number of java bytecodes api represents which apis are used to make http requests in the app and method means which http method is used by the shrss in the app.
.
rq energy saving to answer this research question we used bouquet to optimize our subject apps.
then we measured and compared the energy consumption of both the optimized and unoptimized versions.
to have a full view of the energy saving of our approach we measured two types of energy savings the whole app energy saving and the shrss energy saving.
for the whole app energy saving we compared the energy consumption between the unoptimized and the optimized version of each app.
for the shrss energy saving we only compared the energy of the optimized and unoptimized http api invocations in each shrs.
.
.
protocol we measured the energy saving of bouquet when running on the ve subject apps.
our approach required us to deploy the proxy in the same network domain as the servers of the apps.
however we did not have access to the server side since our subjects were not open source apps.
to solve this problem we built a mock server to mimic the behavior of the servers of our subject apps and redirected the http requests of our subject apps to the mock server.
the mockserver was a nodejs based server that accepted the http requests from our subject apps and replied with previously recorded responses that were collected using a capture replay technique reran .
in our experiment we executed our apps with the minimal workload that could trigger each of the bundled http requests once.
we also captured and replayed this workload with reran to ensure that both versions of the app were run with the same interactions and timing.
this enabled us to avoid any variation in the measurements due to unstable or inconsistent interactions across the versions.
we handled the exceptions with the rst option described in section .
.
the energy savings of bouquet depend on the underlying network bandwidth and delay.
to measure the energy savings of bouquet under realistic network conditions we used a simulator newt developed by microsoft to simulate the network conditions of wifi 15m bandwidth 27ms delay lte .2m bandwidth 96ms delay and 3g 2m bandwidth 147ms delay networks.
the bandwidth and delay of our lte and 3g networks were the average values of the four major mobile carriers in the us att t mobile sprint and verizon .
unlike lte and 3g network which have a uniform quality of network service for all customers the bandwidth and delay of the wifi network is highly dependent on the customers internet plan.
in our evaluation the bandwidth and delay of wifi were pro led from the standard plan of time warner cable with a popular network speed tester .
the energy consumption was collected with our previous technique vlens with the monsoon power meter.
we used the vlens technique because it is able to isolate the energy consumption of individual http api invocations from other parts of a subject app s execution and eliminate idle state energy such as the energy consumed by waiting for user input.
note that eliminating idle state energy was important to have an accurate energy measurement for android apps.
the idle energy was not consumed by the the app itself but by the operating system.
including idle state energy in the total energy measurement could introduce signi cant inaccuracies in the measurements .
to account for random measurement error each of our subject apps was executed ve times enough to achieve statistical significance and the average number was taken as the nal result.
we also conducted a t test on the null hypothesis the energy consumption of an unoptimized version is not larger than the optimized version which was rejected.
we could use the t test because the random measurement error fol255table description of subject apps app description bytecode api method generated provided bobweather weather forecasting urlconnection get lirr train schedule checker httpclient post tapjoy rewards tracker urlconnection get alja news portal httpclient get pch lottery urlconnection get lowed a normal distribution in independent measurements.
finally we manually veri ed each execution to con rm that the optimized version of the aut behaved the same as the unoptimized version.
to verify this we monitored each workload and veri ed that the two versions of the app performed the same functions and returned the same answers.
.
.
result figure energy savings at the whole app level.
energy savings at the whole app level are shown in figure and the shrss level energy savings are shown in figure .
on average our approach achieved energy savings of and at the whole app level for wifi lte and 3g network respectively.
for the shrss level energy savings the average value for wifi lte and 3g were and respectively.
the p values were .
and .
for the whole app level energy saving and the shrs level energy savings respectively.
.
.
discussion the results showed that our approach was able to achieve signi cant energy savings across all three types of networks and at both the whole app and the shrs level.
the savings at the whole app level is particularly revealing because it emphasizes not only the energy savings that an end user could expect to see but also that these individual http invocations represent a signi cant source of energy consumption for a typical app.
so much so that the signi cant local reductions in energy consumption i.e.
for an shrs translate into large app level savings as well.
one interesting pattern in our results was that the energy savings for wifi were higher than those for lte and 3g at the whole app level.
however the same trend was not observed at the shrs level.
this was interesting because it indicated that under our con guration of wifi the ratio of the energy consumed by http requests to the total energy of the whole app was higher.
we hypothesized this was because our wifi con guration had the fastest network bandwidth which was not as energy e cient as slower netfigure energy savings at the shrs level work con gurations for small http requests.
in our experiments the size of our http requests were all between one to three kilobytes.
using a very large bandwidth to retrieve such a small amount of data may not reduce the response time signi cantly but force the network to consume much more power.
thus having a very fast network may in fact increase the ratio of http energy to the total energy.
.
rq manual effort in general our approach is fully automated and does not require any developer interaction except to con rm the identi ed optimizations.
in most cases developers using our approach will only need to check the completeness of the rules generated by the analyzer.
in some cases though as described in section .
an optimization cannot be fully automated and the developers need to complete the generated code with the assistance of the generated comments.
as an approximate measure of developer e ort we calculated how many lines and comments were generated by the analyzer and how many lines needed to be written by the developers.
we report these metrics because the bundlers were the only parts of the process that would require manual intervention by the developer.
the number of generated lines and comments re ects the e ort needed to learn and understand the bundlers and the number of lines needed to be written re ects the required e ort to create the bundlers.
to measure how many lines needed to be written we manually completed the bundling rules with our understanding of the test cases and reported the number of lines we had written for each test case.
the result is shown in the last two column of table .
the generated column reports the lines of code and comments that bouquet generated.
the provided column represents the lines of code that had to be created by us to complete the bundlers.
the language for these two columns was javascript of nodejs.
note that the manual e ort is to modify the generated code for the proxy there is no modi cation required for the apps with our approach.
256table analysis time s app loading analysis convert rewrite total bobweather .
.
.
.
.
lirr .
.
.
.
.
tapjoy .
.
.
.
.
alja .
.
.
.
.
pch .
.
.
.
.
on average bouquet generated lines of code and comments for each test case.
the number of lines of written code was zero for four test cases and for bobweather.
this means that for out of of our test cases developers only needed to understand the generated code which was less than lines to ensure the correctness of the generated bundlers.
for bobweather we found that its string values that represented the urls of each http api invocation in the shrss had branches.
since our analyzer cannot predict which branch would be taken during runtime it could not automatically generate the code to bundle the shrss.
however the code we wrote for bobweather was straightforward.
it consisted of several regular expression operations without any loops or branches.
therefore we believe that the required amount of manual work for developers is reasonable.
.
rq analysis time to answer this research question we evaluated how much time was consumed by bouquet to detect shrss generate the optimized version of each subject app and generate the bundler.
to calculate this time we measured the execution time of each phase during the measurements for rq1 and then reported the average execution time.
the result of this measurement is shown in table .
the unit for all numbers is seconds.
the loading column is the time consumed by the soot framework to load android apps.
the analysis column is the time consumed by bouquet to detect shrss and generate bundling rules.
the convert column is the time used to convert dalvik bytecodes to java bytecodes with dex2jar.
the rewrite column is the time consumed by bouquet to replace the original http api invocations in android sdk with the ahas.
the total column is the sum of all other columns.
on average the total analysis time for our ve subjects was seconds.
on average of the total time was spent converting dalvik bytecode to java bytecode through dex2jar.
nevertheless all of our test cases could be analyzed and instrumented in less than .
minutes.
these results suggest that the analysis time of our approach would not be a barrier to its acceptance by developers.
.
rq runtime overhead in our approach runtime overhead may be introduced by the ahas.
compared to the original http apis the ahas may take longer to process the responses of http requests since they need to pack and unpack the bundled responses of the http requests.
it is important to know how much runtime overhead this may introduce.
to answer this research question we measured the total response time of all of the http api invocations in the unoptimized app and all of the ahas in the optimized app.
we only measured the total response time of http api invocations or ahas in shrss because ahas were the only sources of additional runtime overhead.we conducted the experiment with the same protocol as in section .
.
for each subject app we reported the ratio of the total http response time of shrss in the optimized version to the same metric for the unoptimized version.
the result is shown in figure .
figure the runtime overhead introduced by bouquet on average the http response time of shrss in the optimized versions was of the time in the unoptimized versions.
the average standard deviation of our measurement was .
the p values were all below .
.
this result was counter intuitive since it showed that the ahas did not introduce any extra runtime overhead but in fact reduced runtime overhead for the subject apps.
we studied this result and found that even though using ahas required extra time to process the bundled responses more time was saved due to http request bundling.
in our approach bundling http requests reduced the amount of data that was transmitted through the network so that it also reduced the time consumed to get the http responses.
in general most of the time spent making http requests was consumed by the network transmission instead of processing the responses.
thus in our experiment the time saved in network transmission easily dominated the extra processing time for response.
.
rq pervasiveness of shrss to answer this research question we carried out an empirical study on a large set of market apps to see how many of them contained shrss.
we collected market apps from the google play market representing di erent categories by using the google play crawler .
the sizes of our apps varied from several hundreds of bytes to megabytes.
we used the shrs detector of bouquet to parse the downloaded apps and reported how many of them had shrss.
we found that there were android apps containing shrss.
this was .
of the entire app pool that we downloaded.
note that for many of the apps it was not possible to have shrss because they had zero or just one http api invocation.
by excluding the apps which had less than two http invocations the percentage increased to .
.
as reported in a commercial report the number of apps in the google play store was above .
million as of july .
.
represents more than apps that could contain shrss.
note that we did not manually verify each result so these results only indicate an upper bound on the number of apps that could be optimized.
overall though these results show that there are potentially many shrss in real world apps and thus the impact of our tool could be high.
.
threats to v alidity external validity using only ve test cases may introduce threats to the external validity of our evaluation if the selected apps are not representative.
to make the selected apps representative we selected a set of apps that covered general patterns of the usage of http apis which were both common methods of http requests post and get and common apis that can make http requests.
furthermore we also selected apps with di erent sizes from to bytecodes.
in general we believe that our selected apps represent common usages of http apis in market apps.
the energy savings on the application level in our approach heavily depend on the network condition.
to avoid bias introduced by any one particular network we used a popular network emulator newt to simulate the common network speed and delay for wifi lte and 3g network.
these network con gurations were either set to the average value in the us or pro led from the standard network package of one of the common network service providers in the us.
therefore we believe that the network con guration represents typical network conditions for smartphone users.
internal validity the accuracy of our approach is guaranteed by the de nition of shrss which is based on the post domination relationship and basic blocks on the post dominator tree.
since the de nition of an shrs is purely based on the static information of the aut our approach can accurately detect each shrs.
however shrss are only a subset of http apis that could be optimized other http apis such as http apis across di erent event handlers may be also optimized with more sophisticated bundling techniques.
however these http apis are not de ned as shrss and are not addressed in our approach.
we will work on these other http apis that can be optimized in future work.
the energy measurement in our evaluation also depended on the workload for each app.
for example a longer workload can have a larger energy consumption.
to have a fair comparison between the unoptimized and optimized versions of apps we used reran to record and replay the identical workload on both the unoptimized and optimized version.
construct validity in the evaluation we used the lines of code that developers needed to read and write to approximate the manual workload of developers.
these metrics did not include the e ort to get the required expertise with the aut.
however as the users of our approach are the developers of the aut we assume that they would already have su cient expertise about the aut.
thus we believe the lines of code that developers needed to read and write are reasonable metrics to measure the expected e ort of developers.
.
related work optimizing the performance of http requests is a classic problem in browser and network design.
many approaches have been proposed to send http requests with less tcp connections such as http pipelining spdy and multiplexing in http .
.
similar to our technique these approaches optimize the performance of http requests by bundling multiple http request into one tcp connection.
however these techniques have been proposedto optimize parallel http requests such as ajax calls in web browsers.
they cannot be used directly for synchronized sequential http requests such as shrss in mobile apps because they do not account for the data dependencies in synchronized sequential http requests.
furthermore unlike these techniques our approach does not require any adaption of current protocols or system level infrastructure.
to optimize http energy consumption in mobile apps we made two preliminary studies which showed that bundling http requests could possibly save http energy.
however those studies did not investigate how to optimize http request energy automatically with static analysis techniques.
energy optimization for mobile apps is also well studied.
one group of energy optimization techniques detect resource leakage issues in mobile apps .
another group of techniques optimize the display energy consumption of mobile apps by using energy e cient color schemes.
researchers have also proposed several techniques to optimize the energy consumption of test cases for in situ testing .
nikzad and colleagues proposed an annotation language and middleware service that can schedule task on mobile apps in a more energy e cient way.
wang and colleagues proposed a framework to optimize energy for processors and memories .
despite the large body of research work in energy optimization of mobile apps none of these approaches targets optimizing the energy consumption of http requests.
besides energy optimization researchers have also proposed techniques for energy measurement and conducted empirical studies to nd potential areas to optimize the energy consumption of mobile apps .
this paper is inspired by the results in these studies.
however the measurement approaches and the empirical studies themselves do not propose techniques to optimize energy consumption for mobile apps.
gui and colleagues built models for the energy consumption of mobile ads .
.
conclusion and future work energy is critical for mobile devices.
current approaches for energy optimization do not address a signi cant source of energy consumption http requests.
in this paper we propose a technique to optimize energy consumption of http requests by bundling multiple http requests.
our approach uses static analysis to detect requests that can be bundled and then uses a proxy based technique to optimize the sending of the requests.
in our evaluation we found that .
of market apps that have at least two http apis can be optimized.
we also measured the energy saving of our approach on ve market apps.
in our experiment our approach averaged a energy reduction for the targeted requests and energy reduction at the application level.
these savings show that our approach can help developers to improve the energy e ciency of their apps.
in the future we will develop techniques to optimize more types of http requests.
.
acknowledgment this work was supported by nsf grant ccf to the university of southern california.
.