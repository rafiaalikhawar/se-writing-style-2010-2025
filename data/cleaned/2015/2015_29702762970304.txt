efficient detection of inconsistencies in a multi developer engineering environment andreas demuth institute for software systems engineering johannes kepler university linz austria andreas.demuth jku.atmarkus riedl ehrenleitner institute for software systems engineering johannes kepler university linz austria markus.riedl jku.atalexander egyed institute for software systems engineering johannes kepler university linz austria alexander.egyed jku.at abstract software developers work concurrently on di erent kinds of development artifacts such as requirements architecture design or source code.
to keep these development artifacts consistent developers have a wide range of consistency checking approaches available.
however most existing consistency checkers work best in context of single tools and they are not well suited when development artifacts are distributed among di erent tools and are being modi ed concurrently by many developers.
this paper presents a novel cloud based approach to consistency checking in a multi developer tool engineering environment.
it allows instant consistency checking even if developers and their tools are distributed and even if they do not have access to all artifacts.
it does this by systematically reusing consistency checking knowledge to keep the memory cpu cost of consistency checking to a small constant overhead per developer.
the feasibility and scalability of our approach is demonstrated through an empirical validation with partly industrial system models.
a prototype implementation implementation is available through the designspace engineering cloud.
ccs concepts software and its engineering !model driven software engineering keywords incremental consistency checking multi developer engineering model driven engineering .
introduction software engineering is an inherently collaborative discipline with developers working concurrently on a wide rangeofdevelopment artifacts requirements use cases design code and more.
to modify these development artifacts an equally diverse engineering tool landscape exists each tool usually specializing on speci c kinds of development artifacts e.g.
eclipse for source code ibm rational software architect for uml models .
each tool thus only presents a partial view of a software system .
after all developers often do not even need access to all engineering artifacts .
the software engineering landscape is characterized by the distributed and concurrent modi cation of these development artifacts by many developers.
this follows a familiar pattern typically developers download development artifacts to their local workstations i.e.
checkout and modify them there in private before nally uploading the changes to a shared repository for others to see i.e.
commit .
in so developers create a local environment where they modify development artifacts separately from the shared repository and where they only have access to a subset of all development artifacts those that can be modi ed by the tools they use.
for example the designer will use a modeling tool to modify the models while the programmer will use a programming tool to modify the source code.
inconsistencies arise if development artifacts contradict.
it is easy to see that inconsistencies are particularly hard to spot in situations where di erent developers modify development artifacts privately within di erent tools.
here existing work for consistency checking is lacking and e cient means for managing consistency is needed .
while many consistency checking approaches exist today e.g.
they do not focus on the multi developer tool problem.
these approaches either require complete local access to all development artifacts or they do not di erentiate between private and public knowledge during consistency checking which is contradictory to the situation of developers working in private.
for example it is hard for a designer working on a checked out design model to understand the consistency implications of private changes with regard to source code that is not locally available.
we refer to the checked out development artifacts as private working copies and there are as many such copies as there are developers tools working concurrently each having a partial view only and each reecting changes that developers made in private.
the base problem is that today it is not possible that the designers permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
receive feedback about inconsistencies between model and source code if the latter is not available locally.
in this paper we introduce a novel approach for consistency checking in a multi developer multi tool engineering environment.
our approach relies on the designspace engineering cloud infrastructure to maintain i a central public area that contains the entirety of development artifacts shared by all developers and ii as many private working areas as there are developers to re ect their individual not yet published modi cations.
changes that developers perform locally in their tools are instantly propagated to their respective private working areas in the cloud.
these changes are then instantly checkable against the public area therefore enabling a complete consistency checking.
the performance savings of our approach are the result of systematic reuse of consistency checking knowledge.
our approach does not have any expensive initialization costs and its bene t increases with the number of developers working concurrently.
to validate our approach we analyzed its computational and memory complexity.
furthermore to show its feasibility we developed a prototype and conducted an empirical evaluation to assess the scalability of our approach.
finally we discuss three partly industrial case studies in which we applied our infrastructure.
.
problem illustration and background this work builds on the model analyzer which is a single tool single developer consistency checker.
like most other consistency checking technologies it cannot provide a holistic consistency check across all development artifacts when a developer only has one development artifact available e.g.
source code or model to illustrate this we discuss a model of a video on demand vod system that is concurrently modi ed by two developers alice and bob.
note that when referring to elements of the example we will use the syntax name where type is a placeholder for the speci c uml type and name for its name.
.
initial state figure shows the complete public model of the vod system that both bob and alice are able to see.
the uml model consists of three diagrams a class diagram showing the entities display andstreamer a sequence diagram outlining the interaction among those two classes and a state chart depicting the state space of streamer .
we limit our illustration to uml for simplicity.
however the public model could also include requirements use cases source code and other development artifacts.
to express desired conditions that a model must satisfy consistency rules are used.
below we show three examples of consistency rules written in ocl that apply to uml models cr1 cr2 and cr3in listings and .
uml message m m. receiveevent .
covered f o r a l l l i f e l i n e l j l .
r e p r e s e n t s .
type .
ownedoperation e x i s t s operation oj o .
name m. name listing cr1 message must be de ned as an operation in the receiver s class.
d display st streamer stream .
draw .
wait .
a sequence diagram stopped playingstream wait .
.
b state space diagram display stop play draw streamer stream pause .
.
c class diagram figure current public version uml transition t l e t c l a s s i f i e r b e h a v i o r e d c l a s s i f i e r s e l f .
owner .
oclastype region .
statemachine .
context in c l a s s i f i e r .
oclistypeof class implies c l a s s i f i e r .
oclastype class .
ownedoperation e x i s t s o operation jo .
name s e l f .
name listing cr2 action of statechart must be an operation in the owner s class.
uml class c a l l parents of uml class c l e t a l l p a r e n t s set uml c l a s s i f i e r in not allparents i ncl u des c listing cr3 no circular inheritance.
each consistency rule is written for a speci c context and the rule must be evaluated for each instance of this context.
since we focus on uml in this illustration the context is a speci c uml element.
cr3 with the context uml class checks whether a given uml class is part of a circular inheritance.
for cr3 in the class diagram in fig.
we nd two uml class instances display and streamer and thus two evaluations of cr3 are necessary one for each class.
we will refer to such an evaluation as consistency rule instance cri throughout the rest of the paper.
similarly cr1 and cr2 check whether messages in sequence diagrams and transitions in statecharts have names that correspond to operations in the class diagrams i.e.
a message action must have an equally named operation in a class .
figure depicts the entire uml model and thus any consistency checker applicable to uml models would be able to determine its consistency with regard to the three consistency rules.
for example the model analyzer would rst identify the cris needed by searching for all uml model instances of the context elements and instantiating a cri for every instance found.
for the vod example seven cris are needed three instantiations of cr1 corresponding to the three messages in the sequence diagram 591cri.
.
for stream cri.
.
for draw and cri.
.
for wait two instantiations of cr2 corresponding to the two transitions in the statechart diagram cri.
.
for the transition wait and cri.
.
for stream and two instantiations of cr3 corresponding to the two classes in the class diagram cri.
.
for display and cri.
.
for streamer .
except for cri.
.
and cri.
.
all instances are consistent.
cri.
.
is inconsistent because there exists no operation in the class diagram for wait in the statechart diagram.
similarly cri.
.
is inconsistent because there exists no operation for the wait message in the sequence diagrams.
.
multi developer consistency checking consider now that alice and bob modify the uml model separately.
each developer checks out the model to his or her local workstation that runs a modeling tool and a consistency checker.
normally the public model would not only have a uml model but also other kinds of development artifacts such as requirements use cases.
in analogy let us assume that there are two modeling tools involved and alice uses a modeling tool that can only modify class and state chart diagrams whereas bob uses a modeling tool that can modify all three kinds of diagrams.
thus alice and her consistency checker only has partial knowledge available.
note that in the following we append the starting letter of the developer s name to the consistency rule instances to distinguish them e.g.
cri.
.
.b is bob s private consistency rule instance of cri.
.
.
.
.
adaptations by bob bob modi es his private working copy of the uml model by adding a feature in order to stream movies a user must rst connect to the streamer .
bob thus makes the following changes consecutively an operation called connect is added to the streamer in the class diagram a start state and transition is added in the state chart diagram and a connect message is added to the sequence diagram.
furthermore bob decides to resolve the two inconsistencies cri.
.
and cri.
.
by renaming the pause in the class diagram to wait .
the new state of bob s working copy is depicted in fig.
.
these changes alter the state of the uml model and thus have implications on the cris.
incremental consistency checkers such as the model analyzer are able to react to changes in a ne grained manner without re evaluating the entirety of the model.
the model analyzer de nes the concept of ascope which is a set of elements that if changed should trigger the re evaluation of cris.
this set is created at the rst evaluation of the cri and is simply the list of model elements accessed during the evaluation of the cri on the uml model.
only changes to these accessed elements can display stop play draw streamer stream wait connect .
.b .
.b a class diagram stopped playingconnect stream wait .
.b2.
.b2.
.b b state chart diagram d display st streamer connect .
.b stream .
.b draw .
.b wait .
.b c sequence diagram figure bob s private version cause the cri state to change.
a cri is thus re evaluated if an element in its scope changes details are discussed by egyed .
please note that most incremental consistency checker have similar concepts e.g.
critical node impact matrix .
the rst change triggers a re evaluation of cri.
.
.b and cri.
.
.b because a new operation was added to the class streamer which may a ect their results.
however the re evaluation did not cause the cris to change their state i.e.
change from consistent to inconsistent or vice versa .
the cris cri.
.
.b and cri.
.
.b need to be re evaluated as well.
furthermore the second and third change each require a new cri cri.
.
.b and cri.
.
.b respectively because they introduce new uml model elements whose types match the context of a consistency rule cr2andcr1 respectively .
this consistency check is indeed necessary.
finally the renaming of pause to wait in the class diagram a ects nearly all instances of the interaction diagram except .
.b and all instances of the state chart amounting to cri evaluations in total.
this is because the changed name could a ect any dened transition in the state chart or any operation called on streamer in the interaction diagram.
indeed this change does resolve the inconsistency cri.
.
.b .
in fact all inconsistencies are resolved at this point and a new feature connect is added.
.
.
adaptations by alice alice also wants to resolve the inconsistency between the class diagram and the state chart.
unaware of bob s work she does so in a di erent way by renaming the wait to pause .
the state of her working copy is depicted in fig.
.
this change resolves the inconsistency and requires the re evaluation of cri.
.
.a .
however recall that alice s tool does not have available the entire uml model.
this demonstrates a situation where a tool and its corresponding consistency checker does not have access to all development artifacts which 592is the norm .
her local consistency checker nds that she indeed removed the inconsistency with the state chart.
however her local consistency checker cannot know about the inconsistency with the interaction diagram which remains i.e.
there is still no wait for the streamer .
.
problem statement the model analyzer like other existing consistency checking approaches su ers from incomplete knowledge in private working copies.
the following issues exist incomplete information.
approaches such as the model analyzer or clime are capable of checking private working copies e ciently and incrementally.
however they require all development artifacts to be available locally which is not often the case in multi developer multi tool development scenarios and should also not be the case just for the sake of complete consistency checking and separation of concerns.
no support for private working copies.
approaches that allow for incomplete local knowledge e.g.
do not support the idea of private adaptations i.e.
every change a developer performs is immediately considered public .
this limits the applicability of those approaches because not every developer would like changes to be publicly visible immediately i.e.
trial and error .
.
goal to address the problems described in section our goal is to develop an infrastructure that is capable of checking the impact of changes performed by many concurrently working developers in private i.e.
many private work areas with respect to publicly available knowledge i.e.
one shared public area .
the infrastructure s computational e ort and memory consumption should be scalable and it should not replicate all development artifacts to all private working areas.
.
approach our approach to scalable consistency checking in a multideveloper multi tool environment combines the advantages of version control systems private working areas and incremental consistency checkers.
our solution systematically reuses computed consistency checking knowledge and provides complete consistency checking for all developers at all times.
stopped playingstream pause .
.a2.
.a a state chart diagram display stop play draw streamer stream pause .
.a3.
.a b class diagram figure alice s private version tooltool adapter observes communicatespwa m model cribaseversion .
.
.tooltool adapter observescommunicatespwa model cri baseversionversion model cripublic area nn ... .
.1figure cloud .
overview figure depicts an overview of our approach.
the cloudbased infrastructure is depicted on the right hand side of fig.
.
the infrastructure maintains a version history of all public development artifacts and their corresponding consistency data public area .
the cris are thus persisted alongside the development artifacts which is a key factor of our approach.
the version history is negranular similar to the version control of resource description framework rdf or operation based version control of emf .
to represent arbitrary development artifacts we use a uni ed representation which we will refer to simply as the model .
in this uni ed representation individual elements of development artifacts and their properties are subject to version control .
the left hand side of fig.
depicts development tools used by developers rectangles labeled as tool .1the cloud maintains private work areas pwa pwa1topwam to capture the di erences between the development artifacts in the tools and the shared public development artifacts in the cloud.
it is important to note that we do not expect development tools to run within the cloud as developers typically use them on their local workstations.
however pwas do reside in the cloud together with the public area.
there are as many pwas as there are development tools used by developers.
each pwa re ects what its developer has changed in its respective tool as compared to the public area.
this is achieved by the means of tool adapter s depicted as grey colored polygons that integrate the various tools with the cloud based infrastructure2.
tool adapters support a typical svn style work ow i.e.
check out update commit and most importantly they communicate development artifact changes made by developers in tools to their respective pwas in the cloud to ensure that the pwas are always up to date.
a tool is typically only concerned with the development artifacts that it can edit e.g.
a modeling tool may not edit source code .
yet to perform a complete consistency check a consistency checker needs access to all development arti1as proof of concept we already support a wide range of such tools such as eclipse for source code ibm rsa microsoft excel and visio eplan creo elements pro generated ecore editors.
2for more information on tool adapters refer to demuth et al.
.
593modelelement id integer alive boolean property name stringdatatype stringbooleanfloatinteger properties value figure model element facts.
while pwas re ect the ongoing works of their corresponding developers tools.
placing a pwa in the cloud provides it with access to all public version controlled development artifacts.
therefore by extension a consistency checker operating on the pwas in the cloud has access to all development artifacts private and public.
this satises the basic requirement for complete consistency checking.
however this alone does not guarantee scalability.
simply executing the model analyzer or any other consistency checker in pwas in the cloud would lead to unnecessary cri evaluations and unnecessary memory consumption because each pwa might replicate same similar consistency information.
consider the problem illustration again where after obtaining the model both private working areas of alice and bob have available local copies of their cris to reect their private state of consistency.
for example neither bob s nor alice s changes a ected the third consistency rule circular inheritance .
thus cri.
.
.a b andcri.
.
.a b were initially needlessly evaluated by both alice s and bob s consistency checker.
to address this issue each pwa not only maintains the of the model with respect to the base version i.e.
pwa.
model but also its corresponding consistency i.e.
the added modi ed removed cris stored in pwa.
cri .
whenever a developer modi es a development artifact the consistency checker re evaluates the a ected cris.
when cris change then they are stored as cri deltas in the pwa which constitutes the di erence between the tool s consistency state and public version s consistency state.
the version controlling of consistency data also avoids expensive initial batch consistency checking as the cri can be checkedout together with the artifacts.
.
unified representation before we discuss the intrinsics of our approach we need to discuss how development artifacts are stored in the cloud and how this allows us to integrate development tools with our infrastructure.
as previously mentioned development artifacts e.g.
models source code are translated to a unied representation called model .
a simpli ed metamodel for this uniform representation is depicted in fig.
.
a model element has a unique id.
furthermore the boolean ag alive indicates whether the model element is alive or not i.e.
whether it has been deleted or not .
moreover model elements may have a variable number of properties which are key value pairs.
values of properties are either of basic data types such as boolean integer float and string or