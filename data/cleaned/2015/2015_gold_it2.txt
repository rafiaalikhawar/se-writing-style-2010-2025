generalized observational slicing for tree represented modelling languages nicolas e. gold n.gold ucl.ac.uk department of computer science university college london gower street london wc1e 6bt ukdavid binkley binkley cs.loyola.edu department of computer science loyola university maryland baltimore md usamark harman mark.harman ucl.ac.uk department of computer science university college london gower street london wc1e 6bt uk syed islam syed.islam uel.ac.uk school of architecture computing and engineering ace university of east london london e16 2rd ukjens krinke j.krinke ucl.ac.uk department of computer science university college london gower street london wc1e 6bt ukshin yoo shin.yoo kaist.ac.kr school of computing korea advanced institute of science and technology daejon republic of korea abstract model driven software engineering raises the abstraction level making complex systems easier to understand than if written in textual code.
nevertheless large complicated software systems can have large models motivating the need for slicing techniques that reduce the size of a model.
we present a generalization of observationbased slicing that allows the criterion to be defined using a variety of kinds of observable behavior and does not require any complex dependence analysis.
we apply our implementation of generalized observational slicing for tree structured representations to simulink models.
the resulting slice might be the subset of the original model responsible for an observed failure or simply the sub model semantically related to a classic slicing criterion.
unlike its predecessors the algorithm is also capable of slicing embedded stateflow state machines.
a study of nine real world models drawn from four different application domains demonstrates the effectiveness of our approach at dramatically reducing simulink model sizes for realistic observation scenarios for out of cases the resulting model has fewer than of the original model s elements.
ccs concepts software and its engineering dynamic analysis extensible markup language xml software testing and debugging keywords slicing orbs simulink matlab observational slicing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn .
.
.
.
reference format nicolas e. gold david binkley mark harman syed islam jens krinke and shin yoo.
.
generalized observational slicing for tree represented modelling languages.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction executable models are widely used in software engineering as well as other engineering domains to prototype communicate reason about and simulate complex systems.
two reasons for their widespread use are that they support the representation of and permit engagement with larger and more complex domains than would be tractable using traditional lower level programming languages.
nonetheless models are still plagued by familiar problems caused by their complexity.
for example model comprehension can easily become a challenge as model size grows.
as such there is a need for analytical techniques that can address problems such as test case generation fault localization impact analysis slicing and clone detection techniques that mirror those developed for programs.
one particular challenge borne of the implicit size of the systems captured by models is a need for techniques such as program slicing or perhaps model slicing that can extract from a large model those elements that pertain to the computation e.g.
a fault of interest.
such techniques help to uncover the causes of the inevitable errors found when modeling complex systems.
example model slicing techniques include those based on dependence analysis and model projection .
this paper presents a new method tree observational slicing tree orbs for dynamically slicing models where the only prerequisite is that the model is represented using a tree structured representation e.g.
xml .
tree orbs is inspired by orbs an observation based slicing technique for traditional programming languages.
it is capable of slicing away parts of a model not required to capture a specified behavior.
in addition to behaviorsesec fse september paderborn germany n.e.
gold d. binkley m. harman s. islam j. krinke s. yoo specified using explicit parts of the model e.g.
the values flowing from one component to another the specified behavior can also be a property of the output e.g.
the presence of a particular tone from a music simulation model or even of the execution itself e.g.
a warning from the run time environment rather than the model .
in this paper we focus on a widely used product for modeling that uses a tree structured representation mathworks simulink part of the matlab software suite.
simulink provides a graphical simulation environment in which complex discrete and continuous systems can be constructed and simulated under a range of experimental conditions.
simulink models have been the subject of research for various model analysis techniques including test case generation and fault localization clone detection and quality assessment metrics .
although simulink is our focus here the algorithm is not tied to simulink and has been subsequently successfully applied to other xml based representations e.g.
srcml .
as an example application of tree orbs consider using it with a system for finding test data that triggers a fault.
one such tool for simulink described by holling pretschner and gemmar is 8cage .
the combination of 8cage and tree orbs provides the ability to undertake automated end to end test case generation and model reduction for fault localization.
given a fault of interest the first step runs 8cage which produces test data that triggers the fault.
then using this data tree orbs can produce a reduced model that includes only those components that contribute to the production of the fault.
in support of such applications this paper makes the following contributions observational slicing a generalization of observationbased slicing that supports different types of observation and criteria.
an algorithm tree orbs for observational slicing of treestructured representations.
an implementation of tree orbs for xml based languages such as simulink xml orbs .
a case study that demonstrates the utility of tree orbs by exhibiting the end to end fault localization scenario outlined above.
empirical studies that demonstrate the application operation and characteristics of xml orbs applied to a collection of simulink models in some cases including stateflow .
background .
slicing programs and models program slicing is a technique for deleting parts of a software system that are irrelevant to a chosen slicing criterion .
there are many forms including static dynamic quasi static conditioned amorphous and syntax preserving .
by focusing on the criterion slicing has found many applications including testing debugging maintenance re engineering reuse comprehension and refactoring .
the present paper is inspired by a recently introduced form of dynamic slicing known as observation based slicing which dynamically slices multilingual systems using speculativedeletion of system elements as the slicing operation.
such deletions are checked against observations with respect to the behavior as specified by the criterion.
those deletions for which there are no observable changes for the criterion are accepted while those that have an observable effect are discarded so the corresponding program elements are retained and the speculative deletion is rejected .
observation based slicing has the advantage that it can capture dependencies overlooked by previous slicing techniques which fail to account for observation preferring some more abstract dependence model .
observation based slicing produces inherently smaller slices than static slicing because it is based on dynamic observation but it can also produce smaller slices than traditional dynamic approaches because of its focus on observation rather than dynamically traversed statically defined dependence .
one important feature of the orbs implementation of observationbased slicing is the way that focusing on deleting lines instead of statements liberates the slicing algorithm from the need for detailed and thus expensive and brittle semantic analysis lines can be deleted and the effect simply observed a property from which orbs derives its language independence.
furthermore using only speculative lexical deletion is language independent thereby orbs is able to slice systems expressed in multiple languages.
in contrast such multilingual slicing is a considerable challenge for existing dependence analysis based slicing techniques.
however hitherto observation based slicing has only been applied to programs not to models.
.
slicing simulink this paper presents the first tree based observational slicing technique and reports on experiments with its implementation using a collection of matlab simulink models.
a simulink model which is saved textually as an xml file or files if stateflow is included is visually represented as a diagram with functional blocks possibly encapsulating sub systems connected by lines representing the flow of data during simulation.
we treat the xml file s as the model s source code .
associated with the model are a range of parameters governing the way the simulation is run and how the model interacts with external devices files and the underlying matlab workspace.
simulink models can interface with stateflow state machines which then share data.
there are several existing approaches to slicing simulink models but none of them uses observational slicing leaving open the question as to what extent the advantages reported for observation based program slicing extend to observational model slicing.
of course an xml file could be regarded as line based source code to which the original orbs implementation of traditional observation based slicing could be applied.
however this approach would be suboptimal as it would not take advantage of the tree based nature of xml where whole sub trees can be pruned rather than individual lines.
without sacrificing language independence but exploiting the tree structure of xml we introduce a tree based observational slicing algorithm tree orbs.
we implement the algorithm for simulink models and evaluate this on a collection of real world simulink models.
unlike non observational alternatives the resulting slices are fully executable.
thus they can be loaded intogeneralized observational slicing for tree represented modelling languages esec fse september paderborn germany matlab simulink and used in place of the original.
our implementation can slice stateflow state machines as part of a simulink model.
a generalized framework for observation based slicing the concepts of static dynamic and observation based slicing work well for traditional programming languages e.g.
c java where variables and statements are well defined.
for other programming languages and criteria the definitions of slicing and the corresponding implementations must be changed accordingly.
instead of giving yet another specific definition we generalize observation based slicing to accommodate different observations that can be made over a program.
the original definition of an observation based slice is based on comparing execution trajectories thus trajectory observation based slice anobservation based slice sof a program pon a slicing criterion c v l i composed of variable v line l and set of inputs i is any executable program with the following properties the execution of pfor every input iinihalts and produces a sequence a trajectory of values v p i v l for variable vat line l. scan be obtained from pby deleting zero or more statements from p. the execution of sfor every input iinihalts and produces a sequence of values v s i v l for variable vat line l. i iv p i v l v s i v l .
in this definition the execution is observed using the trajectory of values that a variable or set of variables produces for a specific input.
more generally one can envision an observer o p i that extracts from program psome subset of the behavior the behavior of interest for a given input i. furthermore the observed behavior need not be exactly matched and thus rather than equality the relation between the behavior of the original program and its slice need only be related by a matching relation r. using oandr generalized observational slicing can be defined as follows generalized observational slice ageneralized observational slice sof a program pon a slicing criterion c o r i composed of an observer o a matching relation r and a set of inputs i is any executable program with the following properties the execution of pfor every input iinihalts and produces the observed behavior o p i .
scan be obtained from pby deleting zero or more elements from p. the execution of sfor every input iinihalts and produces the observed behavior o s i .
i io s i ro p i .
in the above definition the program pcan be any executable entity and the observer ocan be any observation made about p. a simple instantiation defines the observer o p i as the output of a program pwhen pis run on each input i i. if the matching relation r is equality then the corresponding generalized observational slice s ispafter unused code w.r.t.
the set of inputs i is removed.
dynamic slicing can also be defined as an instance of generalized observational slicing the trajectory of values of a variablevat a location lfor input ito program pisv p i v l as defined for trajectory observation based slicing.
given the criterion c v l i for a trajectory observation based slice the observer iso p i v p i v l and the matching relation ris equality for the generalized observational slice.
as a third example consider a test suite twhere each test case t t includes a model input tiand an expected output.
one can define a test focused version of generalized observational slicing in which o p ti is the observation of whether or not ppasses test case t. the matching relation can either be strict where all tests must yield the same result for the slice sand the original program p in which case the matching relation ris equality.
alternatively the matching relation can be relaxed where all tests that the original program ppasses must also be passed by the slice s but any test that the original program pfails is allowed to be passed by s. let i ti t t andx i bepass orfail ando p i x ti .
the strict matching relation is equality ris and the relaxed matching relation is r pass pass fail fail fail pass .
a similar generalization extended the orbs algorithm to slice picture description languages where when the sliced program is rendered it produces a specified pattern the criterion .
using generalized observational slicing matching the specific pattern is captured by an observer othat checks if the pattern exists in the rendered image using equality for the matching relation r. the actual implementation uses a template matching score capturing how well the rendered image matches the specified template the observer o and the matching relation is less or equal than so that the rendered slice can match the template better but no worse than the rendered original picture description .
generalized observational slicing is better suited for models than the original definition of observation based slicing because models do not necessarily have the concepts of variables or lines locations .
moreover we can instantiate the definition of generalized observational slicing for models in a similar way to traditional programs.
examples include a traditional slice.
for a given element eof model p observer oextracts the trajectory of values produced for an input iateand the matching relation r is equality.
program specialization.
the observer oextracts all output of model pfor input iand the matching relation r is equality.
in this case the slice is a variant of pspecialized to i. for example ifiinvolved the computation of distances in meters then the slice would work for is specialized to the subset of inputs that use meters.
fault localization.
the observer oextracts some subset of the warning and error output from the model execution environment when executing model pon input i and the matching relation is either equality and thus the same errors must be produced or non empty subsequence in which case at least one of the errors must be produced.
non termination removal.
the observer oextracts some subset of the output or the warning and error output of the model execution environment for the execution of model pfor input i and the matching relation is prefix thus allowing the slice to continue executing where phas entered an infinite loop or abnormally terminated.esec fse september paderborn germany n.e.
gold d. binkley m. harman s. islam j. krinke s. yoo we will make use of the flexibility in generalized observational slicing in defining tree orbs the algorithm for tree structured representations and its implementation xml orbs which we use to slice simulink models under various observations.
model slicing this section presents our algorithm for slicing models and then describes details of the implementation.
to begin with figure presents the tree orbs algorithm which satisfies the definition of generalized observational slicing for tree structured representations.
the algorithm adopts a similar overall approach to orbs but differs in its deletion target selection and traversal strategy in order to support tree structures.
it takes five inputs although the final input is optional.
these five include the model to be sliced m the slicing criterion consisting of an observer o a matching relation r and a set of inputs i. the observer executes the candidate slice and returns the result of the observation for a specific input.
finally the optional input is a start node that specifies the subtree at which the algorithm should start the default start node is the root node .
the algorithm uses several auxiliary functions delete removes the subtree rooted at component cfrom the tree representation of model m.children returns the children of component c. finally append deqeue and empty are straightforward queue operations.
the algorithm begins by saving the observations that result from executing model musing each input.
this output forms the oracle against which subsequent executions are compared.
like orbs tree orbs then repeatedly passes over the nodes of the tree attempting to delete nodes until no further deletions are possible.
on each iteration it traverses the tree in breadth first order children are appended traversed left to right in a breadth first greedy traversal .
the processing of each component cof the tree speculatively deletes the subtree rooted at cto produce a candidate slice.
the subtree rooted at cis permanently deleted if the observations for all inputs match the oracle.
otherwise c s children are appended to the breadth first worklist.
if no deletions are made during an iteration the slice is complete.
similar to traditional orbs the deletion order has an impact.
treeorbs produces a minimal slice however there may be other minimal slices the full state space is therefore not traversed .
based on the original orbs implementation we implemented the tree orbs algorithm to work with xml represented models and refer to the resulting implementation as xml orbs.
it uses a mixture of shell scripts and python code to set up projects for analysis and undertake the slicing.
to improve efficiency xpath axes can be supplied to identify the start node and a stop list.
the default start node is the root of the tree.
the stop list specifies node types that the slicer should ignore it is empty by default.
the stop list can be used to instruct xml orbs not to attempt to delete nodes of a specific type which is useful for example to prevent positional properties from being removed.
finally in addition to model input each input i iincludes environmental inputs and execution settings.
applying xml orbs to simulink models requires some additional configuration to enable xml orbs to start matlab andtreeorbslice m o r i n input model m the criterion consisting of observer o matching relation r and inputsi and a start node n output a slice s ofmforc o r i foreach i i vi o m i repeat nothingdeleted true q append empt y queue while empty q c deqeue q m delete m c deletable true foreach i i v o m i ifvi rv deletable false ifdeletable m m nothingdeleted false else q append q children c until nothingdeleted return m figure tree orbs algorithm simulink execute models and retrieve trajectories.
a typical configuration merely requires defining an observer e.g.
by an execution script that exposes values of properties of interest to treeorbs .
our implementation uses matlab scripts to prepare the workspace execute the model and extract values for treeorbs.
an observer can be as simple as a statement printing a value of interest.
the matching relation can be a simple equality test e.g.
trajectories must be identical or more complex e.g.
filter error logs and check subset containment .
the advantage is that the core algorithm does not need to be modified for different properties or tree structured languages a line oriented domain specific language would be more appropriately sliced by original orbs .
anexecuter class in the xml orbs script provides an api through which application specific execution environments can be managed.
matlab scripts are used to provide the bridge between xml orbs and the model thus forming part of the model instrumentation .
owing to the comparatively long start up time for matlab simulink with each model execution one version of theexecuter class actively manages a running matlab instance restarting it only when a crash or a timeout occurs.
although this fast executer offers significant runtime savings over the generic version some models exhibited non deterministic behavior under this executer despite having deterministic behavior when used with the generic executer perhaps due to some internal persistent state within simulink .
recall that the generalized framework requires model evaluation to terminate for all i i. this requirement cannot be guaranteed even when simulation start and end times are specified because a crash may occur causing matlab to drop back to the interactivegeneralized observational slicing for tree represented modelling languages esec fse september paderborn germany shell and thus appear not to halt.
to account for this possibility a conservative timeout value is used.
it is assumed that any execution taking longer than the timeout is non terminating and thus the current model is not a viable slice.
case study as a case study we consider the application of xml orbs to the problem of fault localization using the example provided by holling pretschner and gemmar .
this example was used to illustrate their technique for test case generation the 8cage model described in table .
their algorithm is able to construct test cases that induce particular faults at selected blocks in a simulink model the values for the specific test cases used are described in a video accompanying their paper .
they identify three faults in the model an absolute value overflow a division overflow and a threshold violation.
from these they generate inputs to trigger each fault.
in the following we demonstrate how our approach is used to reduce the 8cage model to the sub model responsible for the failures.
since this is an experiment relying on execution properties the introduction of failures xml orbs is configured to use an observer that extracts warnings produced by the execution environment.
key to this application is that xml orbs produces executable slices.
for each of the three scenarios one per fault 8cage produces a set of inputs that trigger the corresponding fault.
executing the model with each of these inputs generates a list of warnings.
we apply xml orbs with a strict matching relation so that the slice will generate the same list of observed warnings for each input.
the results are shown in table under the heading slices for all failures with strict matching relation.
block count andxml lines refer to the number of elements of the diagram model remaining the total elements count is the sum of these plus the number of systems in the model there is always one but there may be more if additional subsystems exist .
these are measured directly by counting the appropriate nodes in the xml file defining the block diagram.
note that the model used for threshold violation has one additional block and line compared to the original model because an assertion block was added to instrument the model.
the percentages show for each model element counted the amount of the original model deleted by slicing.
for the first and the third scenarios the reduction in total elements is around while for the the middle scenario division overflow the reduction is almost .
the percentages of deleted blocks are slightly lower while the percentages for the deleted xml lines are slightly higher.
this indicates that average block complexity is lower in the slice which is in part because the slice retains some rather simple blocks in order to remain executable.
the numbers for the absolute overflow slice and the threshold violation slice are very similar suggesting that the slices may be similar.
however a visual inspection revealed that the two slices are very different and share only blocks of the blocks in the original model .
it turns out that each scenario generates additional warnings that indicate failures beyond those considered by holling et al.
.
in each scenario there are three such warnings.
therefore we also applied xml orbs with a relaxed matching relation for each of the nine individual failures.
the relaxed matching relation allowstable slice size and percent reduction for the slices of the system studied by holling et al.
using xml orbs with the test cases produced by 8cage .
block xml total count lines elements original model slices for all failures with strict matching relation absolute overflow slice division overflow slice threshold violation slice slices for specific failures with relaxed matching relation absolute overflow slice absolute overflow slice absolute overflow slice division overflow slice division overflow slice division overflow slice threshold violation slice threshold violation slice threshold violation slice the slice to generate fewer warnings but does not permit additional warnings.
in addition the specific failure of interest must be generated by the slice.
for each of the nine failures the slice is smaller as shown in table under the heading slices for specific failures with relaxed matching relation.
for the absolute overflow scenarios the reduction is slightly greater.
the three different warnings generated in this scenario are all overflow warnings from a similar region of the model.
therefore the slices only differ slightly.
the situation with the three division overflow scenarios is similar the three warnings are again from a common area of the model and thus yield similar reductions.
it is interesting to note that the third slice is the same as the strict slice the one that retains all three failures indicating that it contains the other two as subslices.
finally the three generated warnings in the threshold violation scenario show greater difference because one of the warnings comes from a completely different area of the model.
this leads to threshold violation slice being larger than and very different from slices and .
all three slices are much smaller than the strict slice where use of the strict matching relation forces the slice to keep both areas of the model.
close inspection of slices and reveals that they are almost identical to the division overflow slices and .
figure shows the original model and the slices produced by xml orbs for the three specific failures considered by holling et al.
to save space we have rearranged the layout of the original .
the figure aims to show the general reductions of the model rather than focusing on detail.
in each slice the significant reduction in the number of model elements is visually evident.
in particular the complexity of the division overflow slice is reduced to the point where an engineer can quickly comprehend the cause of the failure.
note that all the slices include blocks that are required to ensure the slice is executable.
this accounts for the handful of isolated blocks seen in the figure.
in addition it is also visually evident that theesec fse september paderborn germany n.e.
gold d. binkley m. harman s. islam j. krinke s. yoo tmpmtr1raw tmpmtr2raw3 tmpmtrlastvalid tmpconvert tmpmtrnorm c normconstant normalizemtr1 normalizemtr2 switch switch1 tmpconvert tmpmtrfail c failconstant min1 tmpconvert tmpmtrmin c minconstant tmpconvert tmpmtrmax c maxconstant min2 max1 max2or outofrange1 or outofrange2z1 unit delay z1 unit delay1 switch2 switch3and useoldsignalz1 unit delay2 z1 unit delay3 tmpout2 tmpmrtfail add divide constant u abs tmpdiffout subtractz1 unit delay4 u abs1 switch4 relational operator1 switch5 relational operator2 divide11 constant1 nodivbyzeroconvert data type conversion qy qu vy vu ey eu shift arithmetic4 tmpmtrlastfail tmpmtr1raw tmpmtr2raw3 tmpmtrlastvalid tmpconvert tmpmtrnorm c normconstant normalizemtr1 normalizemtr2 switch switch1z1 unit delay z1 unit delay1 switch2 switch3and useoldsignalz1 unit delay2 z1 unit delay3 tmpout2 tmpmrtfail add divide constant u abs tmpdiffout subtract switch44 tmpmtrlastfail original absolute overflow slice tmpmtr1raw tmpmtr2raw3 tmpmtrlastvalid tmpout2 tmpmrtfail relational operator2 divide11 constant1 nodivbyzeroconvert data type conversion qy qu vy vu ey eu shift arithmetic4 tmpmtrlastfail tmpmtr1raw tmpmtr2raw3 tmpmtrlastvalid tmpconvert tmpmtrnorm c normconstant normalizemtr1 normalizemtr2 switch switch1z1 unit delay z1 unit delay1 switch2 switch3and useoldsignalz1 unit delay2 z1 unit delay3 add divide constant4 tmpmtrlastfail u check static upper bound division overflow slice threshold violation slice figure slices for the example system of holling et al.
using test cases generated by 8cage .
absolute overflow slice and the threshold violation slice share a large common part of the model where blocks are shared.
figure shows a more detailed illustration of part of the observational slice for the threshold violation criterion.
it shows two switch blocks where xml orbs has removed the incoming trigger for both blocks xml orbs also removed the upper input of switch1 .
the trigger input determines the state of the switch.
the incoming triggers act like the predicate of an ifstatement and cause a control dependence as they decide which incoming signal reaches the outgoing signal.
the removal of these two inputs is a red flag to an engineer trying to diagnose the fault.
in both cases xmlorbs was able to remove the incoming trigger because the failure is caused when the two switches are in their default states it iserrantly not necessary to flip the switches with a change of the incoming trigger.
in comparison a static slicer would clearly be unable to remove the incoming trigger due to the static dependence of the block s output on all three incoming signals.
moreover a dependence based dynamic slicer would not be able to remove the incoming trigger s connection because it computes the dynamic slice by removing from the static slice those dependences that are never executed.
alas in this example the dependences are executed and thus would be included in the dynamic slice.
in short the ability to remove executed but unnecessary dependences allows xml orbs to remove large portions of models such as the one shown in figure that a static or dynamic slicer could not.generalized observational slicing for tree represented modelling languages esec fse september paderborn germany 1tmpmtr1raw2tmpmtr2raw3tmpmtrlastvalidtmpconvert tmpmtrnorm cnormconstantnormalizemtr1normalizemtr2 0switch 0switch1z1unit delayz1unit delay1 0switch2 0switch3anduseoldsignalz1unit delay2z1unit delay3adddivide2constant4tmpmtrlastfail u 199check static upper bound figure detail of the observational slice for the threshold violation criterion evaluation to evaluate xml orbs we undertook an empirical investigation using a range of models from various sources to determine how effective xml orbs is in slicing simulink models and to consider the characteristics of the slicing process.
the models used in the test corpus come from a variety of sources and domains and are of various sizes.
they include realistic models and some small illustrative examples.
table summarizes the models their characteristics the criteria used and their type.
test cases were identified in various ways.
for some models e.g.
8cage the test cases and criteria were identified by others as described in section for others they were supplied with the model e.g.
the campus energy modeling library tests and demos and the remainder were created with the model e.g.
for the set of illustrative models we created a model implementation of danicic and howroyd s montreal boat code .
in each case the output was either provided alongside the test case or where it was difficult to determine the outcome the entire set of workspace variables produced was captured.
in each case a model s suitability for inclusion in the corpus was determined by manual inspection to understand something of its operation many of these models are in domains in which we do not have expertise the data required to initiate simulation and what might be considered important aspects of the resulting trajectory.
minor modifications e.g.
the inclusion of toworkspace blocks or assignment of values to workspace variables in start up scripts were made in a few cases to enable the automatic start up and capture of model data and suppression of the interactive guis.
the models were also checked to ensure that they exhibited deterministic behavior under at least one of the two execution regimes available the generic executer that starts a fresh matlab simulink session with each execution or the fast executer that manages an ongoing matlab simulink instance as a subprocess only restarting it when a crash or timeout occurs.
finally the experiments were undertaken using the xml orbs implementation described above on a macbook pro .
ghz intel core i7 with 16gb ram ssd storage and running os x version .
.
.
all models were run using matlab release 2015b in combination with python scripts and instrumentation in matlab and xml orbs itself.
each model analysis was executed four times and the results e.g.
timings averaged where appropriate.
.
results and discussion this section presents the results from the test corpus including those presented as part of the case study above .
the true slice is an undecidable minimal slice.
slice size is the well established and widely accepted metric to measure slice precision.
the case study has already shown how observational slicing is precise with respect to requiring those dependencies that are actually required to capture the slice.
here we consider the resulting slice sizes.
this can be measured in a number of ways using the various model elements blocks lines systems subsystems layers .
measurements can be made either via simulink s metrics api although this does not capture all the elements of interest such as the lines excluded furthermore metric counts vary between matlab versions for the same model or in terms of the raw xml.
we present metrics as measured using xpath queries on the xml represented block diagram.
table shows the original and sliced sizes of each model.
for the 8cage scenarios table only shows the slices for all failures with the strict matching relation table shows the other nine slices .
the slice sizes are given as absolute sizes and as a proportion of the original program for each of the size metrics reported.
in terms of total number of model elements the sizes range from a slice that includes of the original model fourier synth 3s to slices than have removed almost every element aeroradar .
the latter situation can occur when simulink blocks have default values that are output in the absence of input.
if the default value happens to coincide with the oracle then the remainder of the model may be deleted and still produce the oracle trajectory.
excluding the illustrative model executions leaves twenty realistic execution scenarios the twelve 8cage scenarios the three mathworks simulink examples and the five models from the campus energy modeling project .
for almost half of these scenarios nine of the twenty the resulting slice contains less than of the original model s elements.
note that it is not possible to directly compare the results of xml orbs to other static or dynamic slicers even if they would be available to us for two reasons.
first many of the criteria that we used cannot be mapped to traditional slicing criteria and second xml orbs is the only simulink slicer that guarantees that its slices are executable.
execution characteristics are shown in table .
the table shows the number of iterations xml orbs does before no more deletions are possible the number of times a model is executed after a deletion has been attempted and the elapsed and cpu time needed.
it is interesting to note that in no case does the number of iterations exceed four suggesting that there is limited dependence ordering that is not explicitly captured by the line connections additional iterations are required where the deletion order differs from the dependence order for example a use must be deleted before the corresponding definition .
also the majority of the models only need two iterations which means that all possible deletions occur during the first iteration.
the final iteration is in one sense superfluous in that it becomes final because nothing more can be deleted and thus it has no effect on the slice size.
however it must be completed to ensure that slicing is actually complete.
the results do not indicate any obvious correlation between size execution time type of observer or number of executionsesec fse september paderborn germany n.e.
gold d. binkley m. harman s. islam j. krinke s. yoo table corpus of models used.
model description source type test cases criterion type sum productstandard slicing example e.g.
authorsc hand translated into simulinksingle n trajectory values montreal boatstandard slicing example e.g.
authorsc hand translated into simulinksingle composite trajectory values delorder cross block dependency example authorsc hand translated into simulinksingle no params trajectory values fourier synth fourier synthesis model authors simulinkmultiple seconds of audio outputtrajectory property audio power at f hz aeroradar conceptual model of atc radar mathworks simulink examplessimulink default valuestrajectory values aerotrimlin autopilot control trimming traj.
values properties powerwindow car power window demonstration trajectory values 8cage published large model holling et al.
simulink from the 8cage video execution property runtime warnings constant power power source tester campus energy modelling project simulink models supported by other librariesdefault values derived from the supplied test scriptsassertions ev electric vehicle tester assertions ev charging vehicle charging tester trajectory values weather weather testers trajectory values pvwatts pv watts ssc co simulation trajectory values table slice size results of xml orbs applied to the test corpus.
original model sliced model model test casexml block countxml linesxml systemstotal model elementsxml block countxml linesxml systemstotal model elements sum product n montreal boat composite case delorder default fourier synth0 1s 2s 3s 3s aeroradar default values aerotrimlin default values powerwindow default values 8cageabsolute overflow division overflow threshold violation constant power single phase values ev default values ev charging default values weather default values pvwatts default values required.
the only correlation that can be seen is for 8cage in the division overflow scenario more is deleted with fewer attempted executions and in less time compared with the others.
observing the implementation when running suggests that the proportion of crashes and timeouts increases in later iterations.
this is to be expected as less of the model is deletable in each iteration.
while the current version of treeorbs may not be suitable for interactive debugging owing to long run time it could be integrated into overnight integration testing automatically generating sliced models from failed tests for inspection the following day.
.
stateflow existing slicers for simulink do not fully handle the dependencies induced by and within stateflow elements of a model.
by working on the tree structured xml xml orbs is able to correctly and precisely slice stateflow elements and the constituent state diagrams with respect to the test suite either alone or as part of slicing the containing simulink model.
since simulink currently stores the stateflow portions of the diagram in a separate file one need only direct xml orbs to slice this file instead or as well as the main block diagram.
the results shown in table sliced only the maingeneralized observational slicing for tree represented modelling languages esec fse september paderborn germany table performance metrics resulting from applying xml orbs to the test corpus.
model test case iterations executionsavg elapsed time s avg cpu time s sum product n .
.
montreal boat composite case .
.
delorder default .
.
fourier synth0 1s .
.
2s .
.
3s .
.
3s .
.
aeroradar default values .
.
aerotrimlin default values .
.
powerwindow default values .
.
8cageabsolute overflow .
.
division overflow .
.
threshold violation .
.
constant power single phase values .
.
ev default values .
.
ev charging default values .
.
weather default values .
.
pvwatts default values .
.
block diagram treating any stateflow models present as simply a simulink block.
table shows slicing results for three models that contain stateflow elements where the slicer was directed to slice both the simulink and stateflow files two examples from the original test corpus and the other coin developed by the authors specifically to evaluate stateflow slicing .
in two cases the slicer can remove the stateflow entirely in the other it can reduce the size of the state machine.
the slices arising from these analyses are thus more precise with respect to the test suite than those produced without slicing the stateflow elements.
.
threats to validity as with any study of dependence analysis techniques the empirical results could be enhanced by further research on additional subjects.
to avoid unnecessary external threats to the validity of the findings in terms of generalizability we have drawn upon a variety of sources of simulink models including previously published work and both large and small model sizes for a variety of different domains.
in terms of construct validity minor changes have been made to models in order to instrument these as is standard with system analysis work.
this instrumentation is entirely independent of the existing model computation merely playing the role of data collection allowing us to report our results.
related work program slicing was introduced by weiser and developed substantially through the 1980s and 1990s particularly targeting static slicing.
this culminated in industrial tools based on the widelyused system dependence graph sdg algorithm .
it remains a topic of interest to the present day .
static program slicing produces a slice that is correct for all possible program executions and thus has similarities with the cone of influence computation .
dynamic slicing was introduced to tailor slices to a particular program execution .
most of these algorithms are based at least in part on static dependenceanalysis.
for example the first of agrawal and horgan s four dynamic slicing algorithms removes from the static slice those elements not executed on a particular program execution.
observation based slicing was recently introduced as a form of dynamic slicing where the slice need only respect those dependencies actually observed a dependence is observed when its removal leads to the computation of different values at the slicing criterion.
basing slice computation purely on observation has far reaching implications for the underlying algorithms.
for example a particular problem in dynamic slicing is caused by control dependence which must be pre computed statically.
whenever a statement is included in a dynamic slice all predicates on which the statement is control dependent are commonly included together with all statements on which the predicate dynamically depends.
even when the predicate never changes its outcome a dynamic slice tends to include it.
an observational slice can remove the predicate and all statements on which only the predicate depends.
observation based slicing algorithms can also cater for different languages and multilingual systems whereas the white box dependence analysis used by all previous slicing approaches forms a barrier to multilingual slicing.
this combination of language independence and faithfulness to dependences actually observed during execution has led to increased recent interest in multilingual and observation based slicing techniques .
although our work is observational it is also concerned with model slicing which presents different challenges to the more widely studied paradigm of program slicing.
model slicing has become a recent topic of interest in its own right because of the importance and prevalence of software models .
much of the work on model based slicing has focused on uml models .
in the remainder of this section we describe model based slicing approaches that specifically target simulink models since these are most closely related to our own observational simulink slicer.
there are three key challenges for simulink dependence computation esec fse september paderborn germany n.e.
gold d. binkley m. harman s. islam j. krinke s. yoo table slice size results of xml orbs applied to combined simulink stateflow examples.
original model sliced model model test casesimulink xml elementsxml statesxml transitionsxml data nodestotal model elementssimulink xml elementsxml statesxml transitionsxml data nodestotal model elements aeroradar default powerwindow default coin reject .
.
because the model is a data flow model control flow is implicit rather than explicit as it is in programming languages making the precise computation of control dependence non trivial see reicherdt and glesner .
there are hidden data dependences beyond those represented by the signal lines that connect blocks .
simulink models can include multiple embedded stateflow models that have a separate syntax and semantics thus simulink slicing is inherently multilingual.
fortunately the unique properties of observational slicing allow it to address all three of these challenges.
most of the work on slicing simulink models computes static slices and therefore is less suitable for applications like fault localization that require the precision of dynamic or observational slicing.
reicherdt and glesner introduced one of the earliest static simulink slicers based on conditional execution contexts to capture control dependence but it does not handle stateflow models with the result that it does not apply to many real world simulink models.
subsequently sridhar and srinivasulu introduced a static simulink slicer that does handle stateflow models but assumes the absence of parallel states which also limits real world applicability.
pantelic et al.
were the first to incorporate into a static simulink slicer the data dependences due to implicit signal flow involving data stores and goto from blocks .
more recently gerlitz and kowalewski presented a flow sensitive static slicer for simulink models but this also does not handle stateflow models limiting its real world applicability.
the most closely related work to our observational simulink slicer is that on dynamic simulink slicers of which only two exist.
the dynamic simulink slicer contained in the fault localization tool of liu et al.
computes dynamic slices as the intersection of the static slice and the coverage information on executed elements.
this approach mirrors the initial dynamic program slicing algorithm of agrawal and horgan applied to simulink models.
simply intersecting the static slice with the executed elements can lead to overly large slices as was also found by agrawal and horgan for dynamic program slicing motivating them to develop more sophisticated dynamic program slicing algorithms.
furthermore this approach computes so called closure slices which may fail to compile.
for liu et al.
closure slicing was sufficient for fault localization but it is inadequate for many other slicing applications that require compilable or executable slices.
the second dynamic simulink slicer is contained within the proprietary simulink design verifier package slicing tool .
it can compute static simulink slices by determining dependencies between blocks signals and model components.
moreover the static slice can be refined limited to the elements executed duringa simulation .
however this is a commercial tool for which the algorithms used are not publicly available in the peer reviewed literature.
nevertheless while simulink s slicer aims to produce executable slices the documentation is quite clear that it makes no guarantees that the resulting slice will be executable.
by its nature xml orbs guarantees the production of executable slices.
in comparison with this previous work our approach computes fully executable observational slices that are precise with respect to the chosen test suite capture all implicit hidden dependencies dynamically traversed by the test suite and slice the dependencies induced by stateflow.
moreover all previous slicing approaches restrict the slicing criteria and thus none offer the flexibility of the generalized observational slicing framework.
conclusions and future work we have introduced the first observational slicing algorithm for models using a tree based approach that retains observation based slicing s language independence.
we applied our tree oriented slicing algorithm to simulink models demonstrating the ability to significantly reduce model size.
we evaluated the approach on nine real world simulink models including models from previous publications and modeling projects in the public domain.
in the evaluation the resulting model had fewer than of the original model s elements in out of scenarios with a mean value of of the original in the same scenarios .
additionally we presented three examples where stateflow was explicitly sliced in combination with simulink.
so led to even greater size reduction.
the case study presented in section demonstrates the utility of tree orbs when combined with other approaches to identify observations of interest.
the model size reductions are clear and substantial for the case study and other models.
future work will include investigating heuristic approaches to reducing the computational cost applying tree orbs to other executable modeling languages investigating applications of treeorbs to reactive systems parallelising the implementation and investigating the effect of slicing on model complexity.