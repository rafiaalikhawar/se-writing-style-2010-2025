hal id hal submitted on sep hal is a multi disciplinary open access archive for the deposit and dissemination of scientific research documents whether they are published or not.
the documents may come from teaching and research institutions in f rance or abroad or from public or private research centers.l archive ouverte pluridisciplinaire hal est destin e au d p t et la diffusion de documents scientifiques de niveau recherche publi s ou non manant des tablissements d enseignement et de recherche fran ais ou trangers des laboratoires publics ou priv s. t racking the software quality of android applications along their evolution geoffrey hecht benomar omar romain rouvoy naouel moha laurence duchien t o cite this version geoffrey hecht benomar omar romain rouvoy naouel moha laurence duchien.
t racking the software quality of android applications along their evolution.
30th ieee acm international conference on automated software engineering nov lincoln nebraska united states.
pp.
.
hal tracking the software quality of android applications along their evolution geoffrey hecht1 omar benomar2 romain rouvoy1 naouel moha2 laurence duchien1 1university of lille inria france 2universit e du qu ebec a montr eal canada geoffrey.hecht inria.fr benomar.omar courrier.uqam.ca romain.rouvoy inria.fr moha.naouel uqam.ca laurence.duchien inria.fr abstract mobile apps are becoming complex software systems that must be developed quickly and evolve continuously to fit new user requirements and execution contexts.
however addressing these requirements may result in poor design choices also known as antipatterns which may incidentally degrade software quality and performance.
thus the automatic detection and tracking of antipatterns in this apps are important activities in order to ease both maintenance and evolution.
moreover they guide developers to refactor their applications and thus to improve their quality.
while antipatterns are well known in object oriented applications their study in mobile applications is still in its infancy.
in this paper we analyze the evolution of mobile apps quality on versions of popular android applications downloaded from the google play store.
for this purpose we use a tooled approach called p aprika to identify object oriented and 4android specific antipatterns from binaries of mobile apps and to analyze their quality along evolutions.
keywords android antipattern mobile app software quality.
i. i ntroduction software evolve over time inevitably to cope with the introduction of new requirements to adapt to new environments to fix bugs or to improve software design.
however regardless of the type of changes performed the software quality may deteriorate as a result of software aging .
software quality declines along evolutions because of the injection of poor design and implementation choices into software.
code smells and antipatterns are symptoms of such bad choices .
additionally the introduction of antipatterns may affect software maintainability increase the change proneness the fault proneness and the complexity of software modules.
therefore the existence of antipatterns in software is a relevant indicator of its quality.
the research community recognized this issue and proposed several techniques to detect code smells and antipatterns .
most of them are concerned with identifying possible deviations from object oriented oo principles such as functional decomposition and encapsulation.
despite the availability of software development kits for mobile apps specific code smells and antipatterns may still emerge due to the limitations and constraints on resource like memory cpu or screen sizes.
mobile apps may also exhibit oo code smells and antipatterns such as blob class which may decrease their quality as they evolve.
to the best of our knowledge most of the proposed techniques and methods for code smells and antipatterns detection in mobile applications do not involvelarge empirical data to give a genuine picture of the issue rather they detect antipatterns on a single version of few specific open source systems .
this is all the more true in the case of techniques for android applications as the research field is in its infancy.
also oo antipatterns and mobile specific ones are rarely studied together in order to assess the software quality of android applications.
regarding software quality along software evolutions most techniques are based on the analysis of variation of software metrics over time.
for instance studies have been performed on the distribution of bug introduction to software along its evolutions or on an aggregation of metrics as a quality indicator .
however these techniques were not applied to mobile applications.
in this paper we present a fully automated approach that monitors the evolution of mobile apps and assesses their quality by considering antipatterns.
to this end we propose a software quality estimation technique based on the consistency between software artifacts size and oo and android antipatterns.
to identify these antipatterns from android applications we use a metrics based detection technique.
rather than evaluating each application independently our approach leverages the whole dataset to detect and evaluate the evolution of antipatterns in each application.
the antipatterns detection and quality tracking are automatic processes included in p aprika our tooled approach.
typically we intend to answer the two following research questions rq1 can we infer software quality evolution trends across different versions of android applications?
rq2 how does software quality evolve in android applications?
the rationale behind our approach is the close relationship between antipatterns and software artifacts size.
a recent large empirical study showed that most antipatterns are introduced at the creation of software artifacts.
the same study indicates that some antipatterns are introduced as a result of several changes performed on software artifacts along evolutions.
based on these findings we propose to study the variations between software artifacts sizes and the number of antipatterns contained in them.
typically we intend to track the lack of correlation between the number of antipatterns and the software size along evolutions.
our study is based on a dataset made of android applications and versions.
we choose popular applications from the google play store in order to be representative of complex and up to dateapplications.
however most of these applications are not opensource.
thus it was necessary to detect the antipatterns at the bytecode granularity.
in this way our approach could be used by both developers and app store providers to track the apps quality evolution at both global and local scales.
the main contributions of this paper are an approach to track and evaluate the quality of android apps along their evolutions via the detection of antipatterns the observation of particular relationships between these antipatterns in the case of mobile applications the identification of 5quality evolution trends and their possible causes inferred by the analysis of our dataset and finally an empirical study involving over version on which we apply our tooled approach.
this paper is organized as follows section ii gives a brief background on android apps and bytecode based techniques.
section iii discusses different contributions related to our work.
our automatic tooled approach p aprika is detailed in section iv.
the results of the application of our approach are presented in section v. section vi concludes the paper.
ii.
b ackground on android package and bytecode this section provides a short overview of the specificities ofandroid application package apk and dalvik bytecode.
android apps are distributed using the apk file format.
apk files are archive files in a zip format which are organized as follows the file androidmanifest.xml describes application metadata including name version permissions and referenced library files of the application the directory meta inf that contains meta data and certificate information an asset and a res directory containing noncompiled resources a lib directory for eventual native code used as library a resources.arsc file for precompiled resources and a .dex file containing the compiled application classes and code in dexfile format .
while android apps are developed using the java language they use the dalvik virtual machine as a runtime environment.
the main difference between the java virtual machine jvm and the dalvik virtual machine is that dalvik is register based in order to be memory efficient compared to the stack based jvm .
the resulting bytecode compiled from java sources and interpreted by the dalvik virtual machine is therefore different.
disassembler exists for the dex format and tools to transform the bytecode into intermediate languages or even java are numerous .
however there is an important loss of information during this transformation for all the existing approaches.
for instance additional algorithms have to be used to infer the type of local variables or to determine the type of branches as for while and ifconstructions are replaced by goto instructions in the bytecode .
some dependencies are also absent from the dex files resulting in phantom classes which cannot be analyzed without the source code.
and of course the native code included in the lib directory cannot be decompiled with these tools.
it is also important to note that around of all the mobile apps distributed on the google play store are obfuscated in order to prevent reverse engineering.
theproguard tool used to obfuscate code is even pre installed on the beta of android studio provided by google to replace eclipse adt .
it is likely that code obfuscation will be even more common in the future.
with obfuscation most classes and methods are renamed often with just one or two alphabetical characters leading to the loss of most of lexical properties.
fortunately the application structure is preserved and classes from the android framework are not renamed thus allowing to retrieve some information from the classes that inherit them.
iii.
r elated work in this section we discuss the relevant literature about analysis and antipatterns detection in mobile apps and related work on software evolution.
mobile apps are mostly developed using oo languages such as java or objective c. since their definition by chidamber and kemerer oo metrics have gained popularity to assess software quality.
numerous works validated oo metrics to be efficient quality indicators .
this has lead to the creation of tooled approaches such as decor or iplasma which use oo metrics to detect code smells and antipatterns in oo applications.
most of the code smells and antipatterns like long method orblob class detected by these approaches are inspired by the work of fowler and brown et al.
.
these approaches are compatible with java but since they were mostly developed before the emergence of mobile apps they are not taking into account the specificities of android apps and are not compatible with dex bytecode.
with regard to mobile apps linares v asquez et al.
used decor to perform the detection of 18different oo antipatterns in mobile apps built using java mobile edition j2me .
this large scale study was performed on apps and shows that the presence of antipatterns negatively impacts the software quality metrics in particular metrics related to fault proneness.
they also found that some antipatterns are more common with certain categories of java mobile apps.
specifically in android apps verloop used popular java refactoring tools such as pmd or j deodorant to detect code smells like large class orlong method in opensource software.
they found that antipatterns tend to appear at different frequencies in classes that inherit from the android framework called core classes compare to classes which are not called non core classes .
for example long method was detected twice as much in core classes in term of ratio.
however they did not considered android specific antipatterns in both of these studies.
the detection and the specification of mobile specific antipatterns are still considered as open issues.
reimann et al.
propose a catalog of 30quality smells dedicated to android.
these code smells are mainly originated from the good and bad practices documented online in android documentations or by developers reporting their experience on blogs.
they are concerning various aspect like implementations user interfaces or database usages.
they are reported to have a negative impact on properties such as efficiency user experience or security.
we chose to detect some of these code smells with our approach which are presented in section iv d. we selected antipatterns that can be detected bystatic analysis and despite code obfuscation.
reimann et al.
are also offering the detection and correction of code smells via the r efactory tool .
this tool can detect the code smells from an emf model.
the source code can be converted to emf if necessary.
however we have not been yet able to execute this tool on an android app.
moreover there is no evidence that all the antipatterns of the catalog are detectable using this approach.
concerning the analysis of android apps and the study of their specificities the samoa tool allows developers to analyze their mobile apps from the source code.
the tool collects metrics such as the number of packages lines of code or the cyclomatic complexity.
it also provides a way to visualize external api calls as well as the evolution of metrics along versions and a comparison with other analyzed apps.
they performed this analysis on 20applications and discovered that they are significantly different from classical software systems.
they are smaller and make an intensive usage of external libraries which leads to a more complex code to understand during maintenance activities.
ruiz et al.
analyzed android packages to understand the reuse of classes in android apps.
they extract bytecode and then analyze class signatures for this purpose.
they discovered that software reuse via inheritance libraries and frameworks is prevalent in mobile apps compared to regular software.
xu also examined apks of 570applications and determines that developer errors are common in manifest and permissions.
he also analyzed the apps code and observed that java reflection and code obfuscation are widely used in mobile apps making reverse engineering harder.
he also noticed the heavy usage of external libraries in its corpus of analyzed apps.
nonetheless antipatterns were not considered as part of these studies.
much work has been done concerning the assessment of software quality throughout the evolution of oo nonmobile applications.
zhu et al.
monitor software quality throughout the evolution by considering three different modularity views package structural and semantic.
they assess software quality by computing the deviation trends between the considered modular views to indicate on quality evolution.
the idea behind their approach is that if the considered different views are well aligned then software quality is good.
they studied the quality evolution of three open source java systems.
zhang and kim propose to study software evolution quality by monitoring the number of defects using statistical process control spc and control charts c charts .
they examined over 60c charts representing different eclipse and gnome components and identified 6common quality evolution patterns.
the quality evolution patterns serve as indicators of symptomatic situations that development teams should address.
for instance the roller coaster pattern which represents large variations of defect numbers suggests that software quality is unstable and that better management and planning is required to ensure high and consistent quality.
tufano et al.
conducted a large scale empirical study to investigate the code smells introduction by developers by analyzing the change history of software projects.
the authors aim at identifying how code smells are introduced in software along its evolutions.
their major findings are that most code smells are introduced when files are created and new features are developed or existing ones are enhanced.
van emden and moonen propose an approach to detect codesmells in java programs.
they distinguish between two type of smells primitive smells which are detected directly from code and derived smells which are deduced from the context.
the detected antipatterns are then presented to the developers for inspection and quality assurance using visualization.
in this approach the developers are left with the responsibility of assessing the quality by analyzing the visualization.
our approach provides the developers an estimation of software quality based on antipatterns.
unlike the above mentioned contributions and regardless of software quality along evolutions some studies analyze software evolution to abstract higher level information with the purpose of comprehension.
barry et al.
propose a method to identify software evolution patterns.
the pattern identification is based on software volatility information.
v olatility is approximated by computing the amplitude dispersion and periodicity of software changes at regular intervals in the software history.
each period is defined by a volatility class and sequence analysis is applied to reveal similar patterns in time.
xing and stroulia present an approach for understanding evolution phases and styles of object oriented systems.
the authors use a structural differencing algorithm to compare changing system class models over time and gather the system s evolution profile.
the resulting sequence of structural changes is then analyzed to gain insight about the system s evolution.
finally benomar et al.
investigate the automatic detection of software development phases by studying software evolutions.
they use a search based technique to identify software evolution periods having similar development activities.
search heuristics such as development rate importance and type of changes are used to define and understand software evolution.
our proposed approach aims at identifying hotspots in terms of software quality along evolutions.
we consider the analysis of mobile apps evolution and apply a novel approach to detect antipatterns which we use to estimate the software quality.
the proposed approach is automatic and takes as input versions of mobile apps and monitors their quality along evolutions.
iv.
p aprika a tooled approach to detect software anti patterns in this section we introduce the key components of p aprika our tooled approach for analyzing the design of mobile apps in order to detect software antipatterns.
a. overview of the approach paprika builds on a four step approach which is summarized in figure .
as a first step p aprika parses the apk file of the mobile app under analysis to extract some metadata e.g.
app name package and a representation of the code.
additional metadata e.g.
rating number of downloads are also extracted from the google play store and passed as arguments.
this representation is then automatically visited to compute a model of the code including classes methods attributes as a graph annotated with a set of raw quality metrics cf.
section v .
as a second step this model stored into a graph database cf.
section iv c .
the third step consists in querying the graph to detect the presence of commonantipatterns in the code of the analyzed apps cf.
section iv d .
paprika is built from a set of components fitting these steps in order to leverage different analyzers databases or antipatterns detection mechanisms.
each analyzed apk is automatically stored into the database.
thus the database can contains a version history for each analyzed application.
finally the last step use this version history to compute a software quality evolution score cf.
section iv e .
b. step collecting metrics from application artifacts input one apk file and its corresponding metadata.
output a p aprika quality model including entities properties and metrics.
description this steps consists in generating a model of the mobile app and extracting the raw quality metrics from an input artifact.
this model is built incrementally while analyzing the bytecode and complemented with properties collected from the google play store.
from this representation paprika builds a model based on eight entities app class method attribute variable externalclass and externalmethod .externalclass andexternalmethod represents entities from the java api the android framework or third party libraries.
the properties described in table i are attached as attributes to these entities while they are linked together by the relationships reported in table ii.
table i. l ist of paprika properties .
name entities comments name all name of the entity app key all unique id of an application rating app rating on the store date download app apk download date date analysis app date of the analysis package app name of the main package size app apk size mb developer app developer name category app category in the store price app price in the store nb download app number of downloads from the store parent name class for inheritance modifier class public protected orprivate variable method type variable object type of the variable full name method method name class name return type method return type of the method position argument argument position in the method signature table ii.
l ist of paprika relationships .
name entities app owns class app class class owns method class method class owns attribute class attribute method owns argument method argument extends class class implements class class calls method external method uses method variable paprika proceeds with the extraction of metrics for each entity.
the 34metrics currently available in p aprika are reported in table iii.
p aprika supports two kinds of metrics oo and android specific .
boolean metrics are used to determine different kinds of entities whereas integers are used for counters or when the metrics are aggregated.
contrary to the properties metrics often require computation or to processthe bytecode representation.
for example it is necessary to browse the inheritance tree in order to determine if a class inherits from some android framework specific fundamentals classes which include activity represents a single screen on the user interface.
activity may start others activities from the same or a different application service is a task that runs in the background to perform long running operations or to work for remote processes content provider manages shared data between apps broadcast receiver can listen and respond to system wide broadcast announcements from the system or other apps application is used to maintain a global application state.
some composite metrics such as classcomplexity require more computation based on other raw metrics thus they are computed at the end of the process.
implementation we use the s oot framework and its dexpler module to analyze apk artifacts.
s oot converts the dalvik bytecode of mobile apps into a s oot internal representation which is similar to the java language.
s oot can also be used to generate the call graph of the mobile app.
this model is built incrementally by visiting the internal representation of s oot and complemented with properties collected from the google play store.
then p aprika proceeds with the extraction of metrics for each entity by exploring the soot model.
in order to optimize performance and to reduce execution time these steps are not executed sequentially but in an opportunistic way while visiting the s oot model.
compared to traditional approaches for antipattern detection using bytecode analysis instead of source code analysis raises some technical issues.
for example we cannot directly access widely used metrics such as the number of lines of codes or the number of declared locals of a method.
therefore we use abstract metrics that are approximations of the missing ones like the number of instructions to approximate the number of lines of code.
moreover as mentioned previously many applications available on android markets are obfuscated to optimize size and make reverse engineering harder.
most methods attributes and classes are therefore renamed with single letters.
thus we cannot rely on lexical data to compute some quality metrics and we have to apply some bypass strategies.
for instance to determine the presence of getters setters we are not observing the method names rather we focus on the number and types of instructions as well as the variables accessed by the method.
c. step converting paprika model as a graph model input a p aprika quality model with entities properties and metrics.
output a software quality graph model stored in a database.
description we aim at providing a scalable solution to analyze mobile apps at large.
we also wants to keep an history of each version analysis.
therefore we use a graph database as a flexible yet efficient solution to store and query the app model annotated with quality metrics extracted by p aprika .
since this kind of database is not depending on a rigid schema the p aprika model is almost as it is described ingraph dbapk paprika model metadatastep model generation construct modelextract metricsstep antipattern detection determine thresholdsexecute queries graph model antipattern queries detected antipatterns step model conversion convert entitiesconvert metrics step software quality evolution computation build estimation modelcompute quality score software quaity evolution fig.
.
overview of the p aprika approach to detect software antipatterns in mobile apps and analyze their evolution.
table iii.
l ist of paprika metrics name type entities comments numberofclasses oo app numberofinterfaces oo app numberofabstractclasses oo app numberofmethods oo class depthofinheritance oo class integer value minimum is .
numberofimplementedinterfaces oo class numberofattributes oo class numberofchildren oo class classcomplexity oo class sum of methods complexity integer value couplingbetweenobjects oo class chidamber and kemerer integer value lackofcohesioninmethods oo class lcom2 integer value isabstract oo class method isfinal oo class variable method isstatic oo class variable method isinnerclass oo class isinterface oo class numberofparameters oo method numberofdeclaredlocals oo method can be different from source code numberofinstructions oo method related to number of lines in source code numberofdirectcalls oo method numbers of calls made by the method numberofcallers oo method numbers of called made by other methods cyclomaticcomplexity oo method mccabe integer value isgetter oo method computed to bypass obfuscation issetter oo method computed to bypass obfuscation isinit oo method constructor issynchronized oo method numberofactivities android app numberofbroadcastreceivers android app numberofcontentproviders android app numberofservices android app isactivity android class isapplication android class isbroadcastreceiver android class iscontentprovider android class isservice android class the previous section.
all p aprika entities are represented by nodes their attributes and metrics are properties attached to these nodes.
the relationships between entities are represented by one way edges.
implementation we selected the graph database n eo4j and we used its java embedded version.
we chose n eo4j because when combined with the c ypher query language it offers good performance on large scale datasets especially when embedded in java .
furthermore n eo4j is also able to contain a maximum of 235nodes and relationships which match our scalability requirements.
finally n eo4j offers a straightforward conversion from the p aprika quality metrics model to the graph database.
d. step detecting anti patterns from graph queries input a graph database containing a model of the mobile apps to analyze and the antipatterns queries.
output software antipatterns detected in the applications.
description once the model loaded and indexed by the graph database we use the database query language to detect common software antipatterns.
entity nodes which implementsantipatterns are returned as results for all analyzed applications.
the results are grouped by versions.
implementation we use the c ypher query language to detect common software antipatterns as illustrated in listings and .
all oo antipatterns are detected using a threshold to identify abnormally high value from others commons values.
to define such thresholds we collect all the values of a specific metric for the whole dataset and we identify outliers.
we use a tukey box plot for this task.
all values superior to the upper whisker are considered as very high whereas all values inferior to the lower one are very low.
the upper border of the box represents the first quartile q1 whereas the lower border is the third quartile q3 the distance between q1 and q3 is called the interquartile range iqr .
the upper whisker value is given by the formula q3 iqr which is equal to15for the number of methods in our example for blob class as described in listing .
it means that if the number of methods exceeds then it is considered as an outlier and can be tagged as a class containing a high number of methods.
by combining the three thresholds we are able to detect blob classes.
the usage of this statistical method allows us to set thresholds that are specific to the input dataset consequentlyresults may vary depending on the mobile apps included in the analysis process.
thus the thresholds are representative of all applications in the dataset and not only the currently analyzed application.
currently p aprika supports 7antipatterns including android specific antipatterns blob class blob oo a blob class also know as god class is a class with a large number of attributes and or methods .
the blob class handles a lot of responsibilities compared to other classes.
attributes and methods of this class are related to different concepts and processes implying a very low cohesion.
blob classes are also often associated with numerous data classes.
blob classes are hard to maintain and increase the difficulty to modify the software.
in p aprika classes are identified as blob classes whenever the metrics numbers of attributes number of methods and lack of cohesion in methods arevery high .
the cypher query for this antipattern is described in listing .
listing .
c ypher query to detect a blob class.
match cl class where cl.lack of cohesion in methods and cl.number of methods and cl.number of attributes return cl long method lm oo long methods are implemented with much more lines of code than other methods.
they are often very complex and thus hard to understand and maintain.
these methods can be split into smaller methods to fix the problem .
p aprika identifies a long method when the number of instructions for one method is very high.
complex class cc oo acomplex class is a class containing complex methods.
again these classes are hard to understand and maintain and need to be refactored .
the class complexity is calculated by summing the internal methods complexities.
the complexity of a method can be calculated using mccabe s cyclomatic complexity .
member ignoring method mim android in android when a method does not access to an object attribute it is recommended to use a static method.
the static method invocations are about faster than a dynamic invocation .
p aprika can detect such methods since the access of an attribute by a method is extracted during the analysis phase.
the c ypher query for this antipattern is described in listing .
this request explores node properties to return non static methods that are not constructors and relations to detect methods that are not using any class variable nor calling other methods.
such detected methods could have been made static to increase performance without any other consequences on the implementation.
listing .
cypher query to detect member ignoring method.
match m method where not has .
is static and not has m.is init and not m variable and not m method return mleaking inner class lic android in java nonstatic inner and anonymous classes are holding a reference to the outer class whereas static inner classes are not.
this could provoke a memory leak in android systems .
given that the p aprika model contains all inner classes of the application and a metric to identify static class is attached to classes leaking inner classes are detected by a dedicated query in p aprika .
ui overdraw uio android the android framework api provides two methods in the canvas class cliprect quickreject to avoid the overdraw of non modified part of the ui.
the usage of these method is recommended by google to increase app performance and improve user experience .
thus we are using the data stored in p aprika database external api calls to detect views which not use one of these methods.
heavy broadcast receiver hbr android similarly to services android broadcast receivers can trigger anr when theironreceive methods perform lengthy operations .
therefore we are using the same heuristic to detect them.
e. step computing software quality using anti patterns input the android application detected antipatterns.
output evolution of software quality score throughout the mobile applications versions.
description this step consists of scoring each version of the mobile application.
the score serves as an estimation of the mobile app quality in a particular version.
our estimation of software quality is based on the consistency between applications size and the number of detected antipatterns.
typically we compute a quality score for each version of the application and track the values of the score along the entire history of the application successive versions .
implementation to compute our software quality score we first build an estimation model using linear regression.
the linear regression model represents the relationship between the number of antipatterns and the size of an application.
the linear regression is computed by minimization of squared residuals.
the number of classes is used at explanatory variable forblob r .
lm r .
cc r .
mim r .
.
the number of inner classes is used for lic r .
.
the number of views and the number of broadcast receivers are respectively used for uio r .
and hbr r .
.
then the software quality score of an application at a particular version with a value for the number of antipatterns and a value of size is computed as the additive inverse of the residual.
a larger positive residual value suggests worst software quality because it means that the current observed version of the application has more antipatterns with respect to its size than the norm linear regression .
conversely a larger negative residual value implies better quality because of the lower number of antipatterns in the current observed version.
figure ilustrates how the quality score is estimated from the linear regression computed from our dataset.
additionally software quality score at any version is computed as an aggregation of the software quality scores of the preceding versions.
the aggregation is performed by computing the average of previous versions scores.
hence thefig.
.
example of residuals for linear regression used for quality estimation.
effect of past versions is propagated along the evolution of the application.
the scores are computed for each antipattern.
v. e mpirical study a. dataset as mentioned before this study is based on a large dataset of android applications downloaded from the google play store.
the fact that p aprika operates on the applications binaries allowed us to gather a wide variety of android applications.
the only challenge we had in data collection was to find a sufficient number of versions of applications so that our tracking of software quality makes sense.
we consider 106android applications that differ both in internal attributes such as their size and external attributes from the perspective of end users.
our tooled approach p aprika is used to track software quality of android applications.
to this end we collected several versions of each applications to form a total of 568versions which we used to estimate software quality.
these apps were collected between june and june from the top of each category of the google play store.
each app has a minimum of 20versions.
the detailed list of versions is located at we present the empirical data from different viewpoints to illustrate the diversity of our dataset.
category we classify the downloaded applications according to the category they belong to.
all the 24categories of google play store are represented in our dataset.
figure shows the number of applications per category.
for example twitter app belongs to the category social in the google play store.
also the proportions revealed by figure are representative of those found in the store.
in particular we notice that the majority of apps belong to one of four categories social comunication productivity andphotography .
ranking we describe our dataset from the end users rankings viewpoint.
the distribution of applications according to their ranking is presented in figure .
we observe that most of the applications are ranked above around and values follow a normal distribution.
applications ranking scores are based on a likert scale and thus are computed as the mean of ordinale type values.
although this is not desirable from measurement theory perspective these scores give app wallpaper books and reference business comics communication education entertainment finance game health and fitness lifestyle media and video medical music and audio news and magazines personalization photography productivity shopping social sports tools travel and local weather category05101520 appnumber of apps per categoryfig.
.
distribution of the android application with regards to their category.
some insight about the feeling of end users towards these applications.
.
.
.
.
.
.
.
.
.
.
.
.
ranking0510152025 appsnumber of apps per ranking fig.
.
distribution of the android application with regards to their ranking.
download the number of downloads of android application is also a good indicator of its popularity among endusers.
our dataset includes applications that vary in number of downloads.
the number of downloads is one of the metrics that characterizes android applications in the google play store and is advertised as a token of popularity among end users just as the ranking score.
an interesting finding about applications downloads is its correlation with the application size.
figure plots the average number of classes in applications versus the number of downloads.
this suggests that larger applications are more popular probably providing more valuable features to the endusers compared to small apps.
this observation also supports the claim that mobile applications are becoming complex software systems.
versions the number of versions of an application may indicate its maturity and the more versions the more stable reflected in the appreciation of end users.
however we can only collect information about relative time of versions their order in time basically and no information of the absolute time or the interval periods between versions.
therefore we cannot speculate on the relationship between frequency of releases10000 downloads050010001500200025003000350040004500average classesaverage number of classes per download categoriesfig.
.
average number of classes in applications per number of downloads.
and end users ranking scores.
size the android applications analyzed in this study vary in sizes.
among all the versions considered the sizes in terms of number of classes range from 8to over classes.
in general larger applications have more versions better ranking scores and are more downloaded.
we also calculated the size in terms of special classes such as number of activities number of views etc.
b. analysis results we applied p aprika on all the mobile apps and generated evolution graphs for each application and each antipattern.
overall we analyzed over 700graphs representing the evolution of the quality scores discussed in section iv.
as suspected the evolution of quality varies from one application to another and thus there is no general trend that reveals itself across all applications.
this is due to the disparity between mobile apps in terms of antipatterns and size ratios.
for instance c amera app has 75mim antipatterns per class on average while t odocalendar planner app has 5mim antipatterns per class.
however we could observe relationships across different antipatterns evolution scores and report some evolution trends of mobile apps quality.
relationships between antipatterns our estimation of quality is based on the correlation between software antipatterns and software entities.
some antipatterns have better correlation with the number classes in mobile apps such a blob others are more closely related to the number of views e.g.
uio the number of inner classes e.g.
lic or the number of brodcast receivers e.g.
hbr .
we observe that software evolution graphs based on antipatterns which correspond to the same type of software entities are similar.
the type of software entity with which an antipattern is correlated comes directly from the antipattern definition.
here we consider that antipatterns lmandmim are correlated to classes although in reality they are correlated to the methods of classes.
this approximation is supported by the correlation score computed between number of classes and lmandmim antipatterns 8for both antipatterns .
figure illustrates the similarity of the evolution score for blob cc lmandmim antipatterns for the i moapp.
notice that the quality scores drop and rise in the same manner.
20406080100120140160cc 020040060080010001200mim version100200300400500600700800900lm version01020304050blobcom.imo.android.imoimfig.
.
software quality scores of i moapp based on blob cc lmand mim antipatterns.
in some special cases we observe that the quality score based on blob and the one based on ccorlmevolve in opposite manner.
figure shows the evolution of the quality scores based on blob and on lmfor r etro camera app.
this situation happens when blob antipattern absorbs cc and or lmantipatterns.
often a blob class is also a complex class cc and contains long complex methods lm .
such classes tend to reduce the complexity of surrounding classes cc as well as reducing the length of their methods lm .
0100200lm version0102030405060blobcom.onemanwithcameralomo fig.
.
software quality scores of r etro camera app based on blob and lmantipatterns.
in the case of quality scores based on lic uio and hbr the evolution trends are different.
these antipatterns are correlated to inner classes views and broadcast receivers which are special types of classes.
they heavily depend on the mobile app implementation and hence have different evolutionary paths than the rest of the application.
in particular the number of views and the number broadcast receivers do not necessarily change during large periods of the evolution.
quality evolution trends from the analysis of software quality evolution graphs of the apps and antipatterns considered in our study we have established 5major quality evolution trends to answer rq1 can we infer software quality evolution trends across different versions of android applications?a constant decline in general application size increases along evolutions and new antipatterns are introduced.
this evolution trend implies that no action has been done to fix the introduced antipatterns.
hence quality declines because new antipatterns are introduced without fixing older ones.
this is the most encountered quality evolution trend and can be present for either part of the application s evolution or for the entire evolution.
figure shows the constant decline in quality based on lm antipattern.
version800 quality scorecom.picsart.studio fig.
.
software quality scores of p icsart app based on lm antipattern.
b constant rise despite the fact that application size evolves along evolutions there are situations where its evolution seems controlled and less arbitrary.
such situations where development teams follow rigorous programming standards and where software evolution is well structured exhibit a constant increase in quality over time regardless of changes to applications size.
for example f lipboard app size is changed twice in the 26considered versions on versions 19and but it remains constant otherwise.
figure depicts the constant rise in software quality.
version363840424446485052quality scoreflipboard.app fig.
.
software quality scores of f lipboard app based on cc antipattern.
c stability this evolution trend represents periods where software quality is constant.
the ratio of introduced antipatterns versus application size is comparable along several consecutive versions.
usually this trend appears during a finite period such as in the first 10versions of firefox app in the lic based quality shown in figure .
version120 020quality scoreorg.mozilla.firefoxfig.
.
software quality scores of f irefox app based on lic antipattern.
d sudden decline there are cases where the quality score drops abruptly at a particular version.
it indicates a turning point in the evolution of the mobile app and is accompanied by a large variation in application size.
this drop in quality at a certain version is propagated to the following versions and quality remains low as shown in figure .
the rapid decline in quality score of e vernote app happens in versions 5and then quality stabilizes but stays low until version 10to start a constant rise trend.
version75 quality scorecom.evernote fig.
.
software quality scores of e vernote app based on blob antipattern.
e sudden rise it represents the inverse of the previous trend d and is characterized by a rapid increase in quality score.
figure illustrates the sudden rise trend in lic antipattern based quality of s kype app at version .
similarly we observe the propagation of the good quality to successive versions constant good quality .
the rapid increase in quality occurs at the same time of major application size change.
this suggests that developers perform refactorings to improve the code structure and enforce solid programming principles which reflects on quality.
c. case study twitter this section presents the quality evolution analysis of twitter app as an example of how we can utilize our tooled approach p aprika to answer rq2 how does software quality evolve in android applications?
version20406080100120quality scorecom.skype.raiderfig.
.
software quality scores of s kype app based on lic antipattern.
twitter app is given a ranking score of 1by end users.
also it has been downloaded over 100mtimes which indicates its high popularity.
one question worth asking how does t witter quality evolved over time?
to this end we applied p aprika on the 75versions of the app collected.
on the one hand we investigate the changes in terms of number of classes that t witter app undergoes during its evolution.
figure plots the number of classes per version.
from the size information we observe several situations of interest which we will use throughout this case study.
first there is a large addition of classes from version 9to12 from about 530to over .
second the app size constantly rises from versions 19to47and from versions 48to74.
however there is a size drop in the middle of this growth in both cases versions 31and59 which suggests minor refactorings.
finally t witter app size declines drastically at version from about to below .
this implies that major refactorings were performed at version .
version010002000300040005000 classescom.twitter.android fig.
.
size changes of t witter app during evolution.
on the other hand we analyze the evolution of the quality scores computed by p aprika .
for instance figure presents the cc antipattern based quality score per version.
we focus on what happens to quality at the situations of interest of app size explained before.
first the large addition of classes to the app after version 9corresponds to a rise in quality which indicates that new additions occurred with better design thatimproved quality.
this amelioration continues until version when quality starts a constant decline trend.
this coincides with the minor refactorings performed at that version as shown in figure .
the same pattern happens again at version which is consistent with the app size situations.
finally the sudden drop in size at version 48enhanced the quality.
this indicates that many antipatterns problems were resolved while these major refactorings.
the quality keeps rising until the following refactorings at version 59as mentioned before.
version25 05101520quality scorecom.twitter.android fig.
.
software quality scores of t witter app based on cc antipattern.
vi.
c onclusion and future work in this paper we introduced p aprika a tooled approach to monitor the evolution of mobile apps quality based on antipatterns.
the process is fully automatic and takes as input mobile apps in the form of android application packages.
paprika is robust to code obfuscation and identifies antipatterns from applications bytecode.
the antipattern detection is based on software metrics computed by the tool.
we consider 3object oriented antipatterns and 4android antipatterns.
the detected antipatterns are utilized in the evaluation of mobile apps quality.
first we empirically compute a baseline of software quality from the large set of mobile applications collected.
then the quality of a mobile app is estimated as the deviation from the baseline.
in this manner we analyze the evolution of a mobile quality by propagating the quality at a particular version to its subsequent versions.
we believe that our tooled approach could be useful for both android app developers and app store providers since p aprika can help them to evaluate the quality of one or thousands of app versions.
as future work we intend to analyze the evolution of external attributes of mobile apps and investigate their potential correlation between mobile apps quality.
an external attribute of mobile apps could be the end users impressions.
we would use sentiment analysis to track the evolution of end users feelings towards apps along with apps quality evolution.