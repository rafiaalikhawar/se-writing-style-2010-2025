edinburgh research explorer suggesting accurate method and class names citation for published version allamanis m barr et bird c sutton c suggesting accurate method and class names.
in proceedings of the 10th joint meeting on foundations of software engineering.
acm pp.
.
digital object identifier .
.
link link to publication record in edinburgh research explorer document version peer reviewed version published in proceedings of the 10th joint meeting on foundations of software engineering general rights copyright for the publications made accessible via the edinburgh research explorer is retained by the author s and or other copyright owners and it is a condition of accessing these publications that users recognise and abide by the legal requirements associated with these rights.
take down policy the university of edinburgh has made every reasonable effort to ensure that edinburgh research explorer content complies with uk legislation.
if you believe that the public display of this file breaches copyright please contact openaccess ed.ac.uk providing details and we will remove access to the work immediately and investigate your claim.
download date .
aug. 2025suggesting accurate method and class names miltiadis allamanis earl t. barr christian bird?
charles sutton school of informatics dept.
of computer science?microsoft research university of edinburgh university college london microsoft edinburgh eh8 9ab uk london uk redmond wa usa m.allamanis csutton ed.ac.uk e.barr ucl.ac.uk cbird microsoft.com abstract descriptive names are a vital part of readable and hence maintainable code.
recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names.
however suggesting names for methods and classes is much more difficult.
this is because good method and class names need to be functionally descriptive but suggesting such names requires that the model goes beyond local context.
we introduce a neural probabilistic language model for source code that is specifically designed for the method naming problem.
our model learns which names are semantically similar by assigning them to locations called embeddings in a high dimensional continuous space in such a way that names with similar embeddings tend to be used in similar contexts.
these embeddings seem to contain semantic information about tokens even though they are learned only from statistical co occurrences of tokens.
furthermore we introduce a variant of our model that is to our knowledge the first that can propose neologisms names that have not appeared in the training corpus.
we obtain state of the art results on the method class and even the simpler variable naming tasks.
more broadly the continuous embeddings that are learned by our model have the potential for wide application within software engineering.
categories and subject descriptors d. .
coding tools and techniques general terms algorithms keywords coding conventions naturalness of software you shall know a word by the company it keeps.
j. r. firth .
introduction language starts with names.
while programming developers must name variables parameters functions classes and files.
they strive to choose names that are meaningful and conventional i.e.
consistent with other names used in related contexts in their code base.
indeed leading industrial experts including beck mcconnell and martin have stressed the importance of identifier naming in software.
finding good names for programming language constructs is difficult poor names make code harder to understand and maintain .
empirical evidence permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse august september bergamo italy copyright acm x xxxxx xx x xx xx ... .
.suggests that poor names also lead to software defects .
code maintenance exacerbates the difficulty of finding good names because the appropriateness of a name changes over time an excellent choice at the time a construct is introduced can degrade into a poor name as when a variable is used in new context or a function s semantics changes.
names of methods and classes are particularly important and can be difficult to choose.
h st et al.
eloquently captured their importance methods are the smallest named units of aggregated behavior in most conventional programming languages and hence the cornerstone of abstraction .
semantically distinct method names are the basic tools for reasoning about program behaviour.
programmers directly think in terms of these names and their compositions since a programmer chose them for the units into which the programmer decomposed a problem.
moreover method names can be hard to change especially when they are used in an api.
when published in a popular library method naming decisions are especially rigid and poor names can doom a project to irrelevance.
in this paper we suggest that modern statistical tools allow us to automatically suggest descriptive idiomatic method and class names to programmers.
we tackle the method naming problem the problem of inferring a method s name from its body or a class from its methods .
as developers spend approximately half of their development time trying to understand and comprehend code during maintenance alone any progress toward solving the method naming problem will improve the comprehensibility of code leading to an increase programmer productivity .
in previous work we introduced the naturalize framework which learns the coding conventions used in a code base and tackles one naming problem programmers face that of naming variables by exploiting the naturalness or predictability of code .
however the method naming problem is much more difficult than the variable naming problem because the appropriateness of method and class names depends not solely on their uses but also on their internal structure their body or their set of methods.
an adequate name must describe not just what the method is but what it does.
variable names by contrast can often be predicted solely from a few tokens of local context for example it is easy to predict the variable name that follows the tokens for int .
because method and class names must be functionally descriptive they often have rich internal structure method names are often verb phrases and class names are often noun phrases.
but this means that method and class names are often neologisms that is names not seen in the training corpus.
existing probabilistic models of source code including the n gram models used in naturalize cannot suggest neologisms.
these aspects of the method naming problem severely exacerbate the data sparsity problem faced by all probabilistic language models because addressing them by building models that consider more context necessarily means that any individual context will be observed less often.
therefore the method naming problem requires models that1 private void createdefaultshader string vertexshader literal 1 string fragmentshader literal 2 shader new shaderprogram vertexshader fragmentshader if shader.iscompiled false throw new illegalargumentexception literal 3 shader.getlog figure a method from libgdx scameragroupstrategy .
a programmer named it automatically naming it requires inventing a neologism a very hard inference problem.
our subtoken model understands that its name should start with create and suggests createshaders .
can better exploit the structure of code taking into account long range dependencies and modeling the context surrounding their definitions more precisely than at the token level while minimizing the effects of data sparsity.
this paper tackles the method naming problem with a novel neural logbilinear context model for code inspired by neural probabilistic language models for natural language which have seen many recent successes .
a particularly impressive success of these models has been that they assign words to continuous vectors that support analogical reasoning.
for example vector king vector man vector woman results in a vector close to vector queen .
although many of the basic ideas have a long history this class of model is receiving increasing recent interest because of increased computational power from gpus and because of more efficient learning algorithms such as noise contrastive estimation .
intuitively our model assigns to every identifier name used in a project a continuous vector in a high dimensional space in such a way that identifiers with similar vectors or embeddings tend to appear in similar contexts.
then to name a method or a class we select the name that is most similar in this embedding space to those in the function body.
in this way our model realizes firth s famous dictum you shall know a word by the company it keeps .
this slogan encapsulates the distributional hypothesis that semantically similar words tend to co occur with the same other words.
two words are distributionally similar if they have similar distributions over surrounding words.
for example even if the words hot and cold never appear in the same sentence they will be distributionally similar if they both often co occur with words like weather and tea .
the distributional hypothesis is a cornerstone of much work in computational linguistics but we are unaware of previous work that explores whether this hypothesis holds in source code.
earlier work on the naturalness of code found that code tends to repeat constructs and exploited this repetition for prediction but did not consider the semantics of tokens.
in contrast the distributional hypothesis states that you shall recognize semantically similar tokens because they tend also to be distributionally similar.
indeed we qualitatively show in section that our context model produces embeddings that demonstrate implicit semantic knowledge about the similarity of identifiers.
for instance it successfully distinguishes getters and setters assigns function names with similar functionality like grow andresize to similar locations and discovers matching components of names which we call subtokens likeminandmax and height andwidth .
furthermore to allow us to suggest neologisms we introduce a new subtoken context model that exploits the internal structure of identifier names.
in this model we predict names by breaking them into parts which we call subtokens such as get create and height and then predicting names one subtoken at a time.
the subtoken model automatically infers conventions about the internal structure of variable names such as an interface starts with an i or an abstract class starts with abstract .
our subtoken model also learns conventions like prefixing names of boolean methodswith isorhas.
this model also allows us to propose neologisms by proposing sequences of subtokens that have not been seen before.
consider figure our subtoken model builds and explores an embedding space that allows it to suggest createshaders which is usefully close to the name a programmer actually chose.
our contributions follow we introduce a log bilinear neural network to model code contexts that unlike standard language models in nlp integrates information from preceding succeeding and non local tokens.
we are the first to apply a neural context model to the method naming problem and we demonstrate that our models can accurately suggest names for the simpler variable naming problem they improve on the state of the art and for class and method naming our best model achieves f1 scores of on method names and on class names when required to predict names for of method and class declarations.
additionally our subtoken model that can suggest previously unseen names achieves an f1 of when required to suggest names for of the classes.
example suggestions to illustrate our model s capabilities we present a few examples of names suggested by the model for quantitative results see section .
when evaluated on libgdx a graphics library for android and asked to suggest a name for the variable that programmers had named islooping although its confidence was low our model has learned that the name should start with is.
for multipart method names like getpersistentmanifoldpool it understood getwas a likely prefix suggesting it with confidence and that manifold was important assigning its inclusion a probability of and even included getmanifoldpool among its top five suggestions.
on shorter agglutinations like setpad it performed better all five top ranked suggestions started with set four of its suggestions included the root pad and it ranked setpad the actual name third.
its handling of class names was similar.
it learned that the name of an exception class should end with exception and inferred that the names of action and test subclasses should end in action andtest .
a particularly interesting suggestion our model made that caught our eye was androidaudio for the class androidmusic .
use cases our suggestion model can be embedded within a variety of tools to support code development and code review.
during development suppose that the developer is adding a method or a class to an existing project.
after writing the body the developer may be unsure if the name she chose is descriptive and conventional within the project.
our model suggests alternative names from patterns it learned from other methods in the project.
during code review our model can highlight those names to which our model assigns a low score.
in either case the system has two phases a training phase which takes as input a training set of source files e.g.the current revision of the project and returns a neural network model that can suggest names and a testing or deployment phase in which the input is a trained neural network and the source code of a method or class and the output is a ranked list of suggested names.
any suggestion system has the potential to suffer from what we have called the clippy effect in which too many low quality suggestions alienate the user.
to prevent this our suggestion model also returns a numeric score that reflects its degree of confidence in its suggestion practical tools would only make a suggestion to the user if the confidence were sufficiently high.
.
neural context models of code in this section we introduce four language models of code starting with the n gram model to build intuition.
then we introduceneural probabilistic language modelling and follow it with two novel models that specifically designed for method naming refine the underlying neural model our logbilinear context model which adds context and features and subtoken context model which adds subtokens and can be used to generate neologisms.
language models lm are probability distributions over strings of a language.
these models assume that we are trying to predict a token tgiven a sequence of other tokens c c0 c1 cn that we call the context .
lms are very general for example if the goal is to sequentially predict every token in a file as a n gram model does then we can take t ymandc ym n 1ym n ym .
alternately for the method naming problem we can take tto be the identifier token in the declaration that names the function and cto be a sequence that contains all identifiers in the function body.
obviously we cannot store a probability value for every possible context so we must make simplifying assumptions to make the modeling tractable.
different lms make different simplifying assumptions.
.
background to build intuition we begin by reviewing the n gram lm which is a standard technique in nlp and speech processing and which has become increasingly popular in software engineering .
the n gram model assumes that all of the information required to predict the next token is contained within the previous n tokens i.e.
p y1 ym m m 1p ymjym ym n .
to specify this model we need in principle a table of vnnumbers where v is the number of possible lexemes that specifies the conditional probabilities for each possible n gram.
these are the parameters of the model that we learn from data.
there is a large literature on methods for training these models which basically revolve around counting the proportion of times that token ymfollows ym ym n .
however even when n 4orn we cannot expect to estimate the counts of all ngrams reliably as the number of possible n grams is exponential in n. therefore smoothing methods are employed which generally modify the count of a rare n gram y1 ynto make it more similar to the count of a shorter suffix y2 yn whose frequency we can estimate more reliably.
this procedure involves the implicit assumption that two contexts are most similar if they share a long suffix.
but this assumption does not always hold.
many similar contexts such as x y versus x z might be treated very differently by a n gram model because the final token is different.
logbilinear models neural lms address the challenge that the simple n gram model has by making similar predictions for similar contexts.
they predict the next token ymusing a neural network that takes the previous tokens as input.
this allows the network to flexibly learn which tokens like int provide much information about the immediately following token and which tokens like the semicolon provide very little.
unlike an n gram model a neural lm makes it easy to add general long distance features of the context into the prediction we simply add them as additional inputs to the neural net.
in our work we focus on a simple type of neural lm that has been effective in practice namely the log bilinear lm lbl .
we start with a general treatment of loglinear models considering models of the form p tjc exp sq t c t0exp sq t0 c intuitively sqis a function that indicates how much the model likes to see both tandctogether the expfunction maps this to be always positive and the denominator ensures that the result is a probability distribution.
this choice is very general.
for example if sqis a linear function of the features in c then the discriminative model is simply a logistic regression.
logbilinear models learn a map from every possible target tto avector qt2rd and from each context cto a vector rc2rd.
we interpret these as locations of each context and each target lexeme in addimensional space these locations are called embeddings .
the model predicts that the token tis more likely to appear in context c if the embedding qtof the token is similar to that rcof the context.
to encode this in the model we choose sq t c r cqt bt where btis a scalar bias which represents how commonly toccurs regardless of the context.
to understand this equation intuitively note that if the vectors rcandqthave norm then their dot product is simply the cosine of the angle between them.
so sq and hence p tjc is larger if either vector has a large norm if btis large or if rcandqthave a small angle between them that is if they are more similar according to the commonly used cosine similarity metric.
to complete this description we define the maps t7!qtand c7!
rc.
for the targets t the most common choice is to simply include the vector qtfor every tas a parameter of the model.
that is the training procedure has the freedom to learn an arbitrary map between tandqt.
for the contexts c this choice is not possible as there are too many possible contexts.
instead a common choice is to represent the embedding rcof a context as the sum of embeddings of the tokens within it that is rc jcj t 1ctrct where rct2rdis a vector for each lexeme that is included in the model parameters.
the variable tindexes every token in the context c so if the same lexeme occurs multiple times in c then it appears multiple times in the sum.
the matrix ctis a diagonal matrix that serves as a scaling factor depending on the position of a lexeme within the context.
this allows for example a lexeme s influence onc s position to depend on how close it is to the target.
the d non zero values in ctfor each tare also included in the model parameters.
each lexeme vhas two embeddings an embedding qvfor when it is used as a target and an embedding rvfor when it appears in the context.
to summarize logbilinear models make the assumption that every token and every context can be mapped in a d dimensional space.
there are two kinds of embedding vectors those directly learned i.e.
the parameters of the model and those computed from the parameters of the model.
to indicate this distinction we place a hat on rcto indicate that it is computed from the model parameters whereas we write qtwithout a hat to indicate that it is a parameter vector that is learned directly by the training procedure.
these models can also be viewed as a three layer neural network in which the input layer encodes all of the lexemes in cusing a of vencoding the hidden layer outputs the vectors rctfor each token in the context and the output layer computes the score functions sq t c and passes them to a softmax nonlinearity.
for details on the neural network representation see bengio et al.
.
to learn these parameters it has recently been shown that an alternative to the maximum likelihood method called noise contrastive estimation nce is effective.
nce measures how well the model p tjc can distinguish the real data in the training set from fantasy data that is generated from a simple noise distribution.
at a high level this can be viewed as a black box alternative to maximum likelihood that measures how well the model fits the training data.
we optimize the model parameters using stochastic gradient descent.
we employ nce for all models in this paper.
.
logbilinear context models of code now we present a new neural network a novel lbl lm for code which we call a logbilinear context model .
the key ideavariable isdone qisdone rcontextrd sq r context qisdone bisdonefeatures boolean in methodbody final rboolean rin methodbody rfinal rcontext f2ftcrf jitj i2it 8k k jkj 0ckrti kcontexts final boolean isdone false c 2rfinal c 1rboolean c1r c2rfalse while !isdone c 2r c 1r!
c1r c2r figure visual explanation of the representation and computation of context in the d dimensional space as defined in equation the final paragraph of section .
explains the sum over the itlocations.
each source code token and feature maps to a learned ddimensional vector in continuous space.
the token vectors are multiplied with the position dependent context matrix ciand summed then added to the sum of all the feature vectors.
the resulting vector is the d dimensional representation of the current source code identifier.
finally the inner product of the context and the identifier vectors is added to a scalar bias b producing a score for each identifier.
this neural network is implemented by mapping its equations into code.
is that logbilinear models make it especially easy to exploit longdistance information e.g.when predicting the name of a method it is useful to take into account all of the identifiers that appear in the method body.
we model long distance context via a set of feature functions such as whether any variable in the current method is named addcount whether the return type of the current method isint and so on.
the logbilinear context model combines these features with the local context.
as before suppose that we are trying to predict a code token t given a sequence of context tokens c c0 c1 cn .
we assume thatccontains all of the other tokens in the file that are relevant for predicting t e.g.tokens from the body of the method that tnames.
the tokens in cthat are nearest to the target tare treated specially.
suppose that toccurs in position iof the file that is if the file is the token sequence t1 t2 then t ti.
then the local context is the set of tokens that occur within kpositions of t that is the setfti kg for k k k k6 .
the local context includes tokens that occur both before and after t. the overall form of the context model will follow the generic form in and except that the context representation rcis defined differently.
in the context model we define rcusing two different types of context local and global.
first the local context is handled in a very similar way to the logbilinear lm.
each possible lexeme vis assigned to a vector rv2rd and for each token tkthat occurs within ktokens of tin the file we add its representation rtk into the context representation.
the global context is handled using a set of features .
each feature is a binary function based on the context tokens c such as the examples described at the beginning of this section.
formally each feature fmaps a cvalue to either 0or1.
maddison and tarlow use a similar idea to represent features of a syntactic context that is a node in an ast.
here we extend this idea to incorporate arbitrary features of long distance context tokens c. the first column of table presents the full list of features that we use in this work.
to learn an embedding we assign each feature function to a single vector in the continuous space in the same way as we did for tokens.
mathematically let fbe the set of all features in the model and let fc for a context c be the set of all features fwith f c .
then for each feature f2f we learn an embedding rf2rd which is included as a parameter to the model in exactly the same way that rtwas for the language modeling case.
now we can formally define a context model of code as a probability distribution p tjc that follows the form and where rc rcontext where rcontext is rcontext f2ftcrf 8k k jkj 0ckrti k where as before ckis a position dependent d ddiagonal contextmatrix that is also learned during training1.
intuitively this equation sums the embeddings of each token tkthat occurs near tin the file and sums the embeddings of each feature function fthat returns true i.e.
for the context c. once we have this vector rcontext just as before we can select a token tsuch that the probability p tjc is high which happens exactly when r context qtis high in other words when the embedding qtof the proposed target tis close to the embedding rcontext of the context.
figure gives a visual explanation of the probabilistic model.
this figure depicts how the model assigns probability to the token isdone if the preceding two tokens are final boolean and the succeeding two are false .
reading from right to left the figure describes how the continuous embedding of the context is computed.
following the dashed pink arrows the tokens in the local context are each assigned to d dimensional vectors rfinal rboolean and so on which are added together after multiplication by the c kmatrices that model the effect of distance to obtain the effect of the local context on the embedding rcontext .
the solid blue arrows represent the global context pointing from the names of the feature functions that return true to the continuous embeddings of those features.
adding the feature embeddings to the local context embeddings yields the final context embedding rcontext .
the similarity between this vector and embedding of the target vector qisdone is computed using a dot product which yields the value of sq isdone c which is necessary for computing the probability p isdonejc via .
multiple target tokens up to now we have presented the model in the case where we are renaming a target token tthat occurs at only one location such as the name of a method.
other cases such as when suggesting variable names require taking all of the occurrences of a name into account .
when a token tappears at a set of locations it we compute the context vectors rcontext separately for each token ti for i2it then average them.
when we do this we carefully rename all occurrences of tto a special token called self to remove tfrom its own context.
.
subtoken context models of code a limitation of all of the previous models is that they are unable to predict neologisms that is unseen identifier names that have not been used in the training set.
the reason for this is that we allow the map from a lexeme vto its embedding qvto be arbitrary i.e.without learning a functional form for the relationship so we have no basis to assign continuous vectors to identifier names that have not been observed.
in this section we sidestep this problem by exploiting the internal structure of identifier names resulting in a new model which we call a subtoken context model .
1note that kcan be positive or negative so that in general c c2.the subtoken context model exploits the fact that identifier names are often formed by concatenating words in a phrase such as getlocation orsetcontentlengthheader .
we call each of the smaller words in an identifier a subtoken .
we split identifier names into subtokens based on camel case and underscores resulting in a set of subtokens that we use to compose new identifiers.
to do this we exploit the summation trick we used in rcontext .
recall that we constructed this vector as a sum of embedding vectors for particular features in the context.
here we define the embedding of a target vector to be the sum of the embeddings of its subtokens.
lettbe the token that we are trying to predict from a context c. as in the context model ccan contain tokens before and after t and tokens from the global context.
in the subtoken model we additionally suppose that tis split up into a sequence of msubtokens that is t s1s2 sm where smis always a special end subtoken that signifies the end of the subtoken sequence.
that is the context model now needs to predict a sequence of subtokens in order to predict a full identifier.
we begin by breaking up the prediction one subtoken at a time using the chain rule of probability p s1s2 smjc m m 1p smjs1 sm c then we model the probability p smjs1 sm c of the next subtoken smgiven all of the previous ones and the context.
since preliminary experiments with an n gram version of a subtoken model showed that n grams did not yield good results we employ a logbilinear model p smjs1 sm c expfsq sm s1 sm c g s0expfsq sm s1 sm c g as before sq sm s1 sm c can be interpreted as a score which can be positive or negative and indicates how much the model likes to see the subtoken sm given the previous subtokens and the context.
the exponential functions and the denominator are a mathematical device to convert the score into a probability distribution.
we choose a bilinear form for sq with the difference being that in addition to tokens having embedding vectors subtokens have embeddings as well.
mathematically we define the score as sq sm s1 sm c r subcqsm bsm where qsm2rdis an embedding for the subtoken sm and rsubcis a continuous vector that represents the previous subtokens and the context.
to define a continuous representation rsubcof the context we break this down further into a sum of other embedding features as rsubc rcontext rsubc tok in other words the continuous representation of the context breaks down into a sum of two vectors the first term rcontext represents the effect of the surrounding tokens c both local and global and is defined exactly as in the context model via .
the new aspect is how we model the effect of the previous subtokens s1 sm 1in the second term rsubc tok.
we handle this by assigning each subtoken sa second embedding vector rs2rdthat represents its influence when used as a previous subtoken we call this a history embedding .
we weight these vectors by a diagonal matrix csubc k to allow the model to learn that subtokens have decaying influence the farther that they are from the token that is being predicted.
putting this all together we define rsubc tok m i 1csubc irsm i this completes the definition of the subtoken context model.
to sum up the parameters of the subtoken context model are a the target embeddings qsfor each subtoken sthat occurs in the data b the history embeddings rsfor each subtoken s c the diagonal weight matrices csubc mform mthat represent the effect ofdistance on the subtoken history we use m yielding a gramlike model on subtokens and the parameters that we carried over from the logbilinear context model d the local context embeddings rtfor each token tthat appears in the context e the local context weight matrices c kandckfor k k k k6 and f the feature embeddings rffor each feature f c of the global context.
we estimate all of these parameters from the training corpus.
although this may seem a large number of parameters this is typical for language models e.g.
consider the v5parameters if vis the number of lexemes required by a gram language model.
how can we handle so many parameters?
the reason is simple in the era of vast publicly available source code repositories like github and bitbucket code scarcity is a thing of the past.
generating neologisms a final question is given the context c how do we find the lexeme tthat maximizes p tjc ?
.
previous models could answer this question simply by looping over all possible lexemes in the model but this is impossible for a subtoken model because there are infinitely many possible neologisms.
so we employ beam search see russell and norvig for details to find thebtokens i.e.
subtoken sequences with the highest probability.
.
source code features for context models in this section we describe the features we use to capture global context.
identifying software measures and features that effectively capture semantic properties like comprehensibility or bug proneness is a seminal software engineering problem that we do not tackle in this paper.
here we have selected measures and features heavily used in the literature and industry.
for instance control flow is indisputably important we selected cyclomatic complexity despite its correlation with code size to measure it.
the first column of table defines the features we used in this work.
in the table variable type tracks whether the type is generic its type after erasure and if the type is an array its size.
contained methods and sibling methods exclude method overloads and recursion.
the features of a target token are its target features we assign a rfvector to each of them this vector is added in the left summation of equation if a feature s indicator function freturns for a particular token.
although features are binary we describe some like the modifiers of a declaration the node type of a ast etc.
as categorical.
all categorical features are converted into binary using a of k encoding.
for methods we include cyclomatic complexity clipping it to and treating it as categorical.
when features do not make sense for a particular token like the cyclomatic complexity of a variable the feature s function simply returns zero.
.
methodology the core challenge of solving the method naming problem from code is data sparsity.
our guiding intuition is that source code contains rich structure that can alleviate the sparsity problem.
we therefore pose the following question how can we better maximally exploit the structure inherent to source code?
this question in turn leads us to the research questions rq1 .
can we identify and extract long and short range context features of identifiers for naming?
rq2 .
do identifiers contain exploitable substructure?
answering both of these questions in the affirmative we turn our attention to exploiting the resulting naming information here we ask if this new information is sufficiently rich to allow us to accurately suggest names.
more concretely rq3 .
can we accurately suggest method declaration names looking only at the context of the declared method?
rq4 .
can we do the same for class i.e.type names?table evaluation projects java .
ordered by popularity.
name git sha description elasticsearch d3e10f9 rest search engine android universal image loader 19ce389 android library spring framework 2bf6b41 application framework libgdx 789aa0b game dev framework storm bc54e8e distributed computation zxing 71d8395 barcode image processing netty 3b1f15e network app framework platform frameworks base f19176f android base framework bigbluebutton 02bc78c web conferencing junit c730003 testing framework rxjava cf5ae70 reactive jvm extensions retrofit afd00fd rest client clojure f437b85 programming language dropwizard 741a161 restful web server okhttp 0a19746 http spdy client presto distributed sql engine metrics 4984fb6 metrics framework spring boot b542aa3 app framework wrapper bukkit f210234 mincraft mod api nokgiri a93cde6 html xml css parser in reference to the first two research questions we describe the features that we use and how we capture substructure in the next section.
we then definitively answer these research questions by comparing our approach with previous techniques for suggesting variable names on a broad software corpus.
there is little to no research that tackles the second two research questions to compare against.
nonetheless we use an n gram model as a point of comparison for naming methods and classes to demonstrate the performance of our approach as that model has performed the best for variable naming in the past and we hypothesize is reasonable for these new naming tasks.
the rest of this section describes our experimental setup and methodology.
data we picked the top active java github projects on january 22nd .
we obtained the most popular projects by taking the sum of the z scores of the number of watchers and forks of each project using the github archive.
starting from the top project we selected the top projects excluding projects that were in a domain that was previously selected.
we also included only projects with more than collaborators and more than commits.
the projects along with short descriptions are shown in table .
we used this procedure to select a mature active and diverse corpus with large development teams.
finally we split the files uniformly into a training and a test set.
methodology we train all models on the train sets formed over the files of each project.
to evaluate the models for each of the test files and for each variable all identifiers that resolve to the same symbol method declaration or class declaration we compute the features and context of the location of the identifier and ask the model to predict the actual target token the developer used which is unknown to the model as in allamanis et al.
.
in the use cases we consider see section models that are deployed with a confidence filter that is the model will only present a suggestion to the user when the probability of the top ranked name is above some threshold.
this is to avoid annoying the user with low quality suggestions.
to reflect this in our evaluation we measure the degree to which the quality of the results changes as a function of the threshold.
rather than reporting the threshold which is not directly interpretable we instead report the suggestion frequency which is the percentage of names in the test set for which the model decides to make a prediction for a given threshold.
to measure the quality of a suggestion we compute the f1 score and the accuracy for the retrieval over the subtokens of each correct token.
thus all methods are given partial credit if the predicted name is not an exact match but shares subtokens with the correct name.
f1 is the harmonic mean of precision and recall and is a standard measure because it conservative as a harmonic mean its value is influenced most by the lowest of precision and recall.
we also compute the accuracy of each prediction a prediction is correct when the model predicts exactly exact match the actual token.
when computing the f1 score for suggestion rank k we pick the precision recall and f1 of the rank l kthat results in the highest f1 score.
because this evaluation focuses on popular projects the results may not reflect performance on a low quality project in which many names are poor.
for such projects we recommend training on a different project that has high quality names but leave evaluating this approach to future work.
alternatively one could argue that because we measure whether the model can reproduce existing names the evaluation is too harsh if a predicted name does not match the existing name it could be equally good or even an improvement.
nonetheless matching existing names in high quality projects as we do still provides evidence of overall suggestion quality and compared to a user study an automatic evaluation has the great advantage that it allows efficient comparison of a larger number of different methods.
finally during training we substitute rare identifiers subtokens and features i.e.those seen less than two times in the training data with a special unktoken.
during testing when any of the models suggests the unktoken we do not make any suggestions that is theunktoken indicates that the model expects a neologism that it cannot predict.
for the subtoken model during testing we may produce suggestions that contain unksubtokens.
in the unlikely case that a context token ti k ti i.e.is the same token we replace ti kwith a special s elftoken.
this makes sure that the context of the model includes no information about the target token.
training parameters we used learning rate d minibatch size dropout generated 10distractors for each sample for each epoch and trained for a maximum of 25epochs picking the parameters that achieved the maximum likelihood in a held out validation set the of the training data .
the context size was set to k 6and subtoken context size was set to m .
before the training started parameters were initialized around with uniform additive noise scaled by .
the bias parameters bwere initialized such that p tjc matches the empirical unigram distribution of the tokens or subtokens for the subtoken model .
all the hyperparameters except for dwere tuned using bayesian optimization on bigbluebutton for method declarations.
the parameter dis special in that as we increase it the performance of each model increases monotonically assuming a good validation set with diminishing returns.
also an increase in dincreases the computational complexity of training and testing each model.
we picked d 50that resulted in a good trade off of the computational complexity vs.performance.
.
identifier representation first we evaluate our model qualitatively by visualizing its output.
all of the models that we have described assign tokens features and subtokens to embeddings which are locations in a d dimensional continuous space.
these locations have been selected by the training procedure to explain statistical properties of tokens but it does not necessarily follow that the embeddings capture anything about the semantics of names.
to explore this question we examine qualitatively whether names that appear semantically similar to us are assigned to similar embeddings by visualizing the continuous embeddings assigned to names from a few projects.
this raises the immediate difficulty of how to visualize vectors in a d dimensional space.
fortunately there is a rich literature in statistics and machine learning about dimensionality reduction methods that map high dimensional vectors to two dimensional vectors while preserving important properties of the original space.there are various ideas behind such techniques such as preserving distances or anglesfigure a 2d non linear projection using t sne of embeddings of method names appearing in method declarations in the elasticsearch project.
similar methods have been grouped together even though the model has no notion of the textual similarity of the method names for example the assert like methods on the left or the new array methods on the right.
between nearby points or minimizing the distance between each point and its image in the 2d space.
classical techniques for dimensionality reduction include principal components analysis pca and multidimensional scaling.
we will also employ a more modern method called t sne .
figure displays the vectors assigned to a few method names from a typical project elasticsearch .
each point represents the qvector of the indicated token.
to interpret this recall that the model uses the qtvectors to predict whether token twill occur in particular context.
therefore tokens tandt0with similar vectors qt andqt0are tokens that the model expects to occur in similar contexts.
these embeddings were generated from the logbilinear context model that is without using subtokens so the model has no information about which tokens are textually similar.
rather the only information that the model can exploit is the contexts in which the tokens are used.
despite this we notice that many of the names which are grouped together seem to have similar functions.
for example there is a group of assertxxxx methods on the left hand side.
especially striking is the clump of construction methods on the right hand side newdoublearray newintarray newlongarray and so on.
it is also telling that near this clump the names grow and resize are also close together.
analysis reveals that these names do indeed seem to name methods of different classes that seem to have similar functionality.
our previous work indicates that developers often prefer such entities to have consistent names.
additionally we examine the nearest neighbors of tokens in the d dimensional space.
this type of analysis avoids the risk inherent in any dimensionality reduction method that important information is lost in the projection from ddimensions to 2d.
table shows some identifiers on a different project clojure for each identifier giving a list of other identifiers that are nearest in the continuous space.
the nearest neighbors of a token tare those tokens vsuch that the inner product of the embeddings that is q tqv is maximized.
we choose this measure because it most closely matches the notion of similarity in the model.
again we are using the logbilinear context model without subtoken information.
we again see that the nearest neighbors in the continuous space seem to have similar semantic function such as the triple fieldname methodname and classname or the names returntype typ and type .
table takes this analysis a bit further for the subtoken model.
this table shows the nearest nearest neighbors those pairs of tokens or subtokens that are closest in the embedding space out of all possible pairs of tokens.
on the left column we see pairs of close neighbors from the feature based bilinear context model without subtokens.
these contain many similar pairs such as width andheight .
it is striking how many of these pairs contain similar subtokens even though this model does not contain subtokens .
moving to the subtoken model the right column of table shows pairs of subtokens that are closest in the embedding space.
the model learns that pairs like numerals minandmax and heightandwidth should be placed near to each other in the continuous space.
this is further evidence that the model is learning semantic similarities given only statistical relationships between tokens.
we can also attempt to be a bit more specific in our analysis.
in this we are inspired by mikolov et al.
who noticed that adding together two of their embeddings of natural language words often yielded a compositional semantics e.g.embedding paris embedding france embedding vietnam yielded a vector whose nearest neighbor was the embedding of hanoi .
to attempt something similar for source code we consider semantic relationships thatpairs of identifiers have with each other.
for figures and we project the d dimensional embeddings to 2d using pca rather than t sne.
although a technical point this is important.
unlike t sne pca is a linear method that is the mapping between the d dimensional points and the 2d points is linear.
therefore if groups of points are separated by a plane in the 2d space then we know that they are separated by a plane in the higher dimensional space as well.
figure shows the embeddings of all pairs of setter and getter methods for the project netty .
the subtoken model did not generate these models so the model cannot cluster these tokens based on textual similarity.
nevertheless we find that getter and setter tokens are reasonably well separated in the continuous space because they are used in similar contexts.
in figure we match pairs of variable names in the libgdx project in which one name the plural name equals another name the singular name plus the character s. the java convention that collection objects are often named by plural variable names motivates this choice.
although this mapping is more noisy than the last we still see that plural names tend to appear on the left side of the figure and singular names on the right.
from this exploration we conclude that the continuous locations of each name seem to be capturing semantic regularities.
readers who wish to explore further can view the embeddings at http groups.inf.ed.ac.uk cup naturalize .
even though the continuous embeddings are learned from context alone these visualizations suggest that these embeddings also contain to some extent semantic information about which identifiers are similar.
this suggests that local and global context do provide information that can be represented and exploited that is semantically similar names are used in similar contexts.
this is evidence pointing towards an affirmative answer to rq1 .
it is especially striking that we have consistently found that nearby tokens in the continuous space tend to share subtokens even when the model does not include subtoken information.
the right column of table reinforces this point since it shows that when we do use the subtoken model nearby pairs of subtokens in the continuous space seem to be meaningfully related.
this provides some evidence for an affirmative answer to rq2 .
finally it can be objected that this type of analysis is necessarily subjective.
when backed and validated by quantitative analysis get setfloat setbyteset settimemillis setshortsetintsetchar setdoublesetlongsetall setbooleansetreceivebuffersizegetoptiongetsolinger setsolinger setoptiongetreceivebuffersize setsendbuffersizegetsendbuffersize settrafficclassgettrafficclass setsotimeoutsetbackloggetsotimeout getbytessetbytesgetbacklog getdiscardthreshold setdiscardthreshold getvalue setvaluegetlonggetint getboolean getbyte setmediumgetchar getmedium getdoublegetfloat getshort getrawresult setrawresultgettimemillisgetall setcharsetgetcharset setmaxsizegetmaxsizegetfilenamegetcontenttypegetcontenttransferencoding setcontenttypesetfilename setcontenttransferencodingfigure a 2d linear projection using pca of the embeddings of setters and getters for netty method declarations.
matched getter setting pairs are connected with a dotted line.
the embeddings seem to separate setters from the getters.
table examples of nearest neighbors in the continuous space for variable names in clojure .
ordered by higher inner product q t1qt2where t1is in the first column and t2in the second.
identifier nearest neighbors ordered by distance fieldname classname methodname target method methods returntype sb typ type methodname t keyvals items seq form rest valornode params paramtype ctor methodname args arg however this analysis provides visual insight gained from looking at the embedding vectors.
thus we complement this qualitative analysis with a more quantitative one in the next section.
.
ev aluation in this section we quantitatively evaluate the performance of the neural model on the data set answering all the rqs.
variable naming renaming variables and method invocations has been previously shown to achieve good performance using ngram lms.
figure shows the performance of the baseline n gram model along with the performance of the other neural models for variable names.
for low frequency of suggestions high confidence decisions the neural models overperform the n gram based suggestions.
this is expected since such models perform better than plain n gram models in nlp .
additionally the features give a substantial performance increase over the models that lack features.
the subtoken model performs worse compared to the token level model for suggestion frequencies higher than .
this is to be expected since the subtoken model has to make a sequence of increasingly uncertain decisions predicting each subtoken sequentially increasing the possibility of making a mistake at some point.
for suggestion frequencies lower than the performance of the subtoken model is slightly better compared to the token level model thanks to its ability to generate novel identifiers.
thus we positively answer rq1 andrq2 .
we computed table over only three classes because of the cost of retraining the model one feature at a time.
looking at table for variable names one may see how each feature affects the performance of the models over the baseline neural model with no features at rank k .
first we observe that the features 2we chose five because subitizing the ability to count at a glance actionvalue values pointsoffset countflag contactjoystickshader texture descriptor pathfile parametername regioncolor argargs vecarray shape pointresult boundsbutton actormodelid nodemeshpartdisposable materialattributes testpositionconfig hints assetobjectlinebuffer itemitemsmode emitter instanceinstancesassetslightsval key listenerlistenersrunnablefilesrunnablesrenderables cache celltilevectors charactereffectcolors row emittersflags handlevals pagesglyphsparamsface annotation fieldannotationscaches layers controllers spritesprites trianglemodes processorhintframe toucheventskeyframes constraintsimageregions pagemethodtextures controllerviewportsnames viewporthandlescontent contacts modelsconstraintframebuffer paramlocation pixelsunits attachment rectextensionframes extensions keysactorscolumns columnpadshapesrows results vectorrenderableshadersattributeframebuffers renderbuffers buffers positionsattachmentssamplers arrays unitsampler layer nodescontents descriptorsparts methods fieldsresourcetilesetsresourceslocations objectscounts buttons keyeventsbit effectsmeshpartskeyframe animation materialspart animationsdisposablestiles tokens tokenpathsglyph loaderpads rects keyevent toucheventparametersoffsets testssectionvecs sections processors loadersbound imagesactions lines tilesetconfigs pixel lightjoystickstriangles facesbits charactersfigure a 2d linear projection using pca of the embeddings of singular and plural names in libgdx .
pairs are connected with a dotted line.
the embeddings mostly separate singular and plural names.
we expect most of the plural variables to refer to collections of objects whose names appear in singular.
table closely related sub tokens for libgdx variables.
the top pairs that have the highest q t1qt2are shown.
for the subtoken model some numeral pairs e.g.
are omitted.
feature model subtoken camera cam padbottom padleft height width dataout datain swig class localanchora localanchorb min max bodya bodyb shape collision framebuffers buffers left right worldwidth worldheight camera cam padright padleft touch key jarg7 jarg6 end start spritebatch batch loc location help mostly at high suggestion frequencies.
this is due to the fact that for high confidence low suggestion frequency decision the models are already good at predicting those names.
additionally combining all the features yields a performance increase suggesting that for variable names only the combination of the features gives sufficiently better information about variable naming.
method declaration naming accuracy we now attempt to use the neural model for suggesting method names using only features available during the declaration of a method.
surprisingly the neural model is exceptionally good at predicting method declaration names.
figure 7a shows the performance of the models on all method declarations excluding any method declarations that are method overrides.
we exclude overrides so as to avoid giving the models credit for predicting easy names like tostring .
when we include overrides the performance of all models improves.
to exclude method overrides we remove methods that contain the override annotation as well as those methods that we can statically determine as method overrides.
the graphs in figures 7a show that the neural models are substantially better at suggesting method names compared to the n gram language model.
adding features increases the performance of the models indicating that the model is able to use non local context to make better predictions.
naturally the performance degrades handles 5objects and because short term memory is usually 2is the size of human short term memory.table absolute increase in performance for each type of feature compared to the normal and subtoken models with no features at suggestion frequency and at suggestion frequency for rank k .
averages from clojure elasticsearch andlibgdx chosen uniformly at random from our corpus.
if a model does not produce suggestions at a given frequency it is not counted in the average.
the vocabulary of an identifier e.g.method name are all the subtokens of that identifier.
featureabsolute f1 increase absolute accuracy increase simple subtoken simple subtoken variables ast ancestors .
.
.
.
.
.
.
.
method class superclass and interface subtokens .
.
.
.
.
.
.
.
declaration modifiers .
.
.
.
.
.
.
.
variable type .
.
.
.
.
.
.
.
all .
.
.
.
.
.
.
.
method declarations ast ancestors .
.
.
.
.
.
.
.
cyclomatic complexity .
.
.
.
.
.
.
.
fields subtokens .
.
.
.
.
.
.
.
class superclass and interfaces subtokens .
.
.
.
.
.
.
.
method implementation subtokens .
.
.
.
.
.
.
.
declaration modifiers .
.
.
.
.
.
.
.
return type .
.
.
.
.
.
.
.
sibling methods .
.
.
.
.
.
.
.
number of arguments .
.
.
.
.
.
.
.
thrown exceptions .
.
.
.
.
.
.
.
all .
.
.
.
.
.
.
.
type declarations field subtokens .
.
.
.
superclass and interface subtokens .
.
.
.
contained methods subtokens .
.
.
.
all .
.
.
.
.
.
.
.
.
.
.
.
suggestion frequency0.
.
.
.
.
.0suggestion f1ngram no features features subtoken figure evaluation of single point suggestions for variables at rank k 1averaged across all projects.
the features and nofeatures models lack sufficient confidence to make suggestions at the higher suggestion frequencies.
slightly as the prediction confidence decreases.
interestingly the token level models are unable to make any suggestions beyond a suggestion frequency of .
for all other tokens the token level methods return the special unktoken indicating that the models expect a neologism which they cannot predict.
in contrast the subtoken models sustain a good f1 score even for large suggestion frequencies.
this is due to the fact that the subtoken models learn naming conventions at the subtoken level capturing linguistic patterns such as that specific functions may contain various subtokens e.g.get set has is.
table shows a full list of the effect that each feature has on the performance of the neural models at rank k .
as expected the return type the subtokens of the class where the method is declared in and the subtokens of the variables and method invocations inside that method provide the most substantial performance increases.
based on these results we conclude that we are able to suggest accurate method names and that our suggestions are better than previous approaches.
we therefore answer rq3 in the affirmative.
class definitions accuracy in the previous section the performance of the neural model on suggesting names for method declarations was shown.
in this section we evaluate the neural modelwhen making suggestions for class definitions.
figure 7b shows the performance of the n gram language model and the neural models for class name definitions.
in contrast to the previous models the token level models cannot make any suggestions always suggesting the unktoken.
however the subtoken model is able to make suggestions even at high suggestion frequencies maintaining an f1 score of more than outperforming the n gram model.
thanks to the ability of the subtoken model to suggest neologisms the subtoken level model is able to suggest class definition names that it has never seen before with a good f1 score.
table shows that the subtokens of the superclass and interfaces that a type is implementing are informative about the name of the class.
additionally when combining all the available features we get a significant increase in f1 score.
thus we answer yes to rq4 as well we are able to suggest accurate type class names.
.
related work naming in software engineering naming in code has achieved a fair amount of research attention.
there has been prior research into identifying poorly named artifacts.
h st and stvold developed a technique for automatically inferring naming rules for methods based on the return type control flow and parameters of methods.
using these rules they found and reported naming bugs by identifying methods whose names contained rule violations.
arnaoudova et al.
presented a catalog of linguistic anti patterns in code that lead to developers misunderstanding code and built a detector of such anti patterns .
binkley used part of speech tagging to find field names that violate accepted patterns e.g.the field create mp4 begins with a verb and implies an action which is a common pattern for a method rather than a field .
our work is complementary as we make suggestions for names when naming bugs are found anti patterns occur or naming rules are violated.
de lucio et al.
attempted to automatically name source code artifacts using lsi and lda and found that this approach doesn t work as well as simpler methods such as using words from class and0.
.
.
.
.
.
.
.
suggestion frequency0.
.
.
.
.
.0suggestion f1ngram no features features subtoken a method declarations excluding overrides.
.
.
.
.
.
.
.
.
suggestion frequency0.
.
.
.
.
.0suggestion f1ngram subtoken b class type declarations.
figure evaluation of single point suggestions for declarations at k .
overriden method declarations are easier to predict so we exclude them.
the features model achieves the best f1 scores for method declarations but lacks confidence at higher suggestion frequencies where the line stops .
in contrast the subtoken model achieves a good f1 score for all suggestion frequencies for method names and is the only model to accurately suggest class names.
method names .
many studies of naming have also been conducted giving us insight into its importance.
butler et al.
found that flawed identifier names those that violate naming conventions or do not follow coding practice guidelines are related to certain types of defects .
later they also examined the most frequent grammatical structures of method names using part of speech tagging .
lawrie et al.
and takang et al.
both conducted empirical studies and concluded that the quality of identifier names in code have a profound effect on program comprehension.
liblit et al.
explored how names in code combine together to form larger phrases that convey additional meaning about the code.
.
arnaoudova et al.
studied identifier renamings showing that naming is an important part of software construction.
additionally in a survey of developers they found that about of developers think that recommending identifiers would be useful.
these studies highlight the importance of our work by being able to suggest quality names or parts of names.
as method and class names are expected to indicate their semantics they can be viewed as a special case of code summarization .
haiduc et al.
showed that nl text summarization does not work well for code and such techniques must be adapted to be effective.
they later developed summaries that are used to improve comprehension .
sridhara et al.
used idioms and structure in the code of methods to generate high level abstract summaries.
while they don t suggest method names they discuss how their approach may be extended to provide them .
sridhara also showed how to generate code summaries appropriate for comments within the code e.g.as method headers .
for more work in this area eddy et al.
provide a survey of code summarization methods .
we note that most studies and approaches in this area focus on names of variables fields and methods.
although some examine all identifiers in the code we are unaware of any work that focuses on type class names as we do.language models in software engineering probabilistic models of source code have been applied in software engineering.
hindle et al.
and ngyuen et al.
used n gram models to improve code autocompletion.
allamanis and sutton present an application of code n gram models at scale.
maddison and tarlow built a more sophisticated generative model of source code using log bilinear models that reflects the syntactic structure of the code.
although the machine learning principles we use are similar their model differs significantly from ours because their purpose is to build models that generate source code rather than improve existing code.
in other words our model is discriminative rather than generative.
mou et al.
use a convolutional neural network to classify code from programming competition problems.
karaivanov et al.
combine lms with static program analysis to suggest method calls and fill in gaps.
other applications of probabilistic source code models are extracting code idioms and code migration .
closely related to this work is our previous work where we infer formatting and naming conventions using n gram lms to suggest natural renamings.
raychev et al.
present a discriminative probabilistic model to predict types and names of variables in javascript.
in contrast our current work introduces a log bilinear model that greatly improves on the n gram lm especially on method and class naming proposing neologisms by taking into account subtokens and non local context.
other applications of neural logbilinear models neural logbilinear models have been used in nlp for lms and describing images with nl .
log bilinear models have been shown in nlp to produce semantically consistent and interesting vector space representations embeddings .
notable systems include word2vec and glove .
in contrast to these approaches we use a rich notion of non local context by incorporating features specific to source code while we produce similar vector space models for method names variables and types.
additionally we present a novel sub token model.
related to our subtoken model is the work of botha and blunsom that integrate compositional morphological representations of words into a log bilinear lm but the morphological features are only used in the context of an lm.
.
conclusion we introduced the method naming problem that of automatically determining a functionally descriptive name of a method or class.
previous work on automatically assigning names focuses on local variables and relies on relatively local context.
naming methods is more difficult because it requires integrating non local information from the body of the method or class.
we presented a first solution using a log bilinear neural language model which includes feature functions that capture long distance context and a subtoken model that can predict neologisms names that did not appear in the training set.
the model embeds each token into a high dimensional continuous space.
continuous embeddings of identifiers have many other potential applications in software engineering such as rejecting commits whose names violate project conventions exploration of linguistic anti patterns such as a getter starting with set and feature localization.
finally a problem similar to method naming arises in nlp namely the problem of generating a headline from the text of an article .
it is possible that models similar to ours could shed light on that problem as well.
.