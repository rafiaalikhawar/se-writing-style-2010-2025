get rid of inline assembly through verification oriented lifting fr d ric recoules s bastien bardin richard bonichon laurent mounier and marie laure potet cea list paris saclay france firstname.lastname cea.fr univ.
grenoble alpes.
verimag grenoble france firstname.lastname univ grenoble alpes.fr abstract formal methods for software development have made great strides in the last two decades to the point that their application in safety critical embedded software is an undeniable success.
their extension to non critical software is one of the notable forthcoming challenges.
for example c programmers regularly use inline assembly for low level optimizations and system primitives.
this usually results in rendering state ofthe art formal analyzers developed for c ineffective.
we thus propose ti na the first automated generic verification friendly and trustworthy lifting technique turning inline assembly into semantically equivalent c code amenable to verification in order to take advantage of existing c analyzers.
extensive experiments on real world code including gmp and ffmpeg show the feasibility and benefits of ti na.
index t erms inline assembly software verification lifting formal methods.
i. i ntroduction context.
formal methods for the development of high safety software have made tremendous progress over the last two decades with notable success in regulated safety critical industrial areas such as avionics railway or energy.
y et the application of formal methods to more usual non regulated software for safety or security currently remains a scientific challenge.
in particular extending the applicability from a world with strict coding guidelines and disciplined mandatory validation processes to more liberal and diverse development and coding practices is a difficult task.
problem.
we consider here the issue of analyzing mixed code focusing on the use of inline assembly in c c code.
this feature allows to embed assembly instructions in c c programs.
it is supported by major c c compilers like gcc clang orvisual studio and used quite regularly usually for optimization or to access system level features hidden by the host language.
for example we estimate that of debian packages written in c c directly or indirectly depends on inline assembly with chunks containing up to instructions while of the top rated c projects on github contains inline assembly according to rigger et al.
.
as a matter of fact inline assembly is a common engineering practice in key areas such as cryptography multimedia or drivers.
however it is not supported by current state of the art c c program analyzers like klee or frama c possibly leading to incorrect or incomplete results.
this is a clear applicability issue for advanced code analysis techniques.given that developing dedicated analyzers from scratch is too costly the usual way of dealing with assembly chunks is to write either equivalent host code e.g c c or equivalent logical specification when available.
but this task is handled manually in both cases precluding regular analysis of large code bases manual translation is indeed time consuming and error prone.
the bigger the assembly chunks are the bigger these problems loom.
goal and challenges.
w e address the challenge of designing and developing an automated and generic lifting technique turning inline assembly into semantically equivalent c code amenable to verification.
the method should be verification friendly the produced code should allow good enough analyses in practice informally dubbed verifiability independently of the underlying analysis techniques e.g.
symbolic execution deductive verification or abstract interpretation widely applicable it should not be tied to a particular architecture assembly dialect or compiler chain and yet handle a significant subset of assembly chunks found in the wild trustworthy the translation process should be insertable in a formal verification context without endangering soundness as such it should maintain exactly all behaviors of the mixed code and provide a way to show this property.
v erifiability alone is already challenging indeed straightforward lifting from assembly to c keeping the untyped byte level view does not ensure it as standard c analyzers are not well equipped to deal with such low level c code.
scarce previous attempts do not fulfill all the objectives above.
vx86 is tied to both the x86 architecture and deductive verification while the recent work by corteggiani et al.
focuses on symbolic execution.
none of them addresses verifiability or trust.
at first sight decompilation techniques may seem to fit the bill.
y et as they mostly aim at helping reverse engineers correctness is not their main concern.
actually existing decompilers frequently produce decompilation that fails to achieve full functional equivalence with the original program .
some recent works partially target this issue schwartz et al.
d on o t demonstrate correctness they instead measure a certain degree of it via testing while schulte et al.
use a correct bydesign but intractable possibly non terminating search based method.
again none of them study verifiability.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
proposal.
we propose ti na taming inline assembly the first automated generic verification friendly and trustworthy lifting technique for inline assembly.
the main insight behind tina is that by focusing on inline assembly rather than arbitrary decompilation we tackle a problem both more restricted simple control flow smaller size and better defined interfaces with c code no dynamic jumps paving the way to powerful targeted methods .t i na relies on the following key principles recent binary code lifters translating binary opcodes to generic low level intermediate representations ir provide minimalist architecture agnostic and well tested irs adapted to our goal while direct byte level lifting severely hinders current c analyzers verifiability is enhanced by dedicated transformations refining the raw original ir with c like abstractions such as explicit variables arithmetic data manipulation structured control flow etc.
trust relies on translation validation validating each translation a more tractable option than full translator validation which reduces the trust base to a usually simpler checker .
here this checker requires to prove program equivalence a notoriously hard problem1.
we propose a dedicated equivalence checking algorithm tailored to our processing chain.
contributions.
in summary this paper makes the following contributions a new cooperating toolchain allowing formal verification of programs mixing inline assembly and c based on an original combination of novel and existing components sec.
iv addressing verifiability and trust issues a new principled method lifting inline assembly to highlevel c amenable to further formal analysis built upon simplification steps sec.
v countering clearly identified threats to verifiability sec.
ii the automated validation of said method to make the lifter trustworthy via a new dedicated program equivalence checking algorithm taking advantage of our transformation process to achieve both efficiency and high success rate with a limited trust base sec.
vi thorough experiments sec.
vii of a prototype implementation on real world examples to show its wide applicability all debian gnu linux .
x86 assembly chunks some arm gcc and clang and its substantial impact on different verification techniques on samples from gmp ffmpeg alsa and libyuv .
discussion.
this work targets assembly chunks as found in real world programs we lift and validate of all assembly chunks from linux debian .
table i and benefit a range of state of the art verification tools and techniques sec.
vii b .
still system and floating point instructions are currently considered out of scope.
especially floats are not tackled here 1recall that general software verification problems including program equivalence are undecidable.
y et software verification tools do exist and have been proven useful in practice.since handling them well is a challenge in itself for the whole toolchain lifter solver verifier see the extended discussion in sec.
viii.
also ti na s implementation targets c since this is the principal language used for low level programs but the method itself would work unchanged on similar imperative languages like ll vm.
finally though some prior work has addressed code lifting for verification it is worth noting that verifiability has never been explicitly addressed so far.
ii.
c ontext and motiv a tion consider the code snippet of fig.
1a extracted from udpcast sources.
it consists of the x86 assembly code itself here cld rep stosl together with a specification linking c variables to registers and declaring inputs outputs and clobbers i.e.
registers or memory cells possibly modified by the assembly chunk .
the compiler upon encounter of such an extended assembly chunk may use this specification for example during register allocation.
however it is fully blind to the rest of the information e.g.
mnemonics and will forward the chunk as is until code emission.
annotation.
the code in fig.
1a is suffixed by a specification written in a concise constraint language gcc clang syntax in zones separated by lines it first describes allocation constraints for output variables .
c d0 specifies that variable d0should be assigned to register ecx .
d d1 specifies that variable d1should be assigned to register edi then lines detail inputs a eax holds sizeof fd set sizeof fd mask is held in the register described in ecx and the one described in edi holds read set fds bits finally the whole memory memory can be assigned.
this basically tells the compiler to flush its memory cache before entering the chunk.
informal semantics.
the code cld rep stosl has the following informal semantics put the direction flag dfto0 then fill ecx double words from the edi pointer with the value from eax.
intel s manual explains that dfdrives the sign of the increment when dfis0 the sign is positive.
tina produces the code in fig.
1c the loop from the informal semantics is there but the lifter optimized away see sec.
v elements like df eax oredi.
running the analyzers.
if we try to run industrial strength c code analyzers on this code we observe erratic behaviors klee stops with an error message frama c on the other hand warns that clobber list contains memory argument.
assuming no side effect beyond those mentioned in output operands .
this message is clear but the behavior incorrect the keyword memory stipulates that all memory may be assigned but framac simply ignores it.
this small example shows that a single line of assembly may throw off these tools.
of course one may manually rewrite the chunks into semantically equivalent c code then use c analyzers but this is error prone and not authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
usr include i386 linux gnu sys select.h 2typedef long int fd mask usr include i386 linux gnu sys select.h 5typedef struct fd mask fds bits f d set socklib.c int udpc prepareforselect int socks int nr fd set read set int maxfd do int d0 d1 asm volatile cld rep stosl c d0 d d1 a sizeof fd set sizeof fd mask read set fds bits memory while return maxfd a original version in eax 0x00000000 ecx sizeof fd set sizeof fd mask edi read set fds bits df ifecx then break eax edi df?edi edi ecx ecx out b low level semantics socklib.c 2int udpc prepareforselect int socks int nr fd set read set int maxfd int d0 int d1 fd mask tina 4 unsigned int tina 3 tina 3 sizeof fd set sizeof fd mask tina 4 read set fds bits unsigned int tina ecx tina begin 1 tina ecx tina 3 while 0u !
tina ecx tina 4 tina 3 tina ecx tina ecx tina end 1 return maxfd c ti na generated version figure running examplescalable.
with ti na we are able to automatically generate the code of fig.
1c illustrative of our code transformations see sec.
v and automatically validate it trustworthy .
we can then formally show with frama c using abstract interpretation or deductive verification that the code indeed verifies the informal semantics laid out before verification friendly .
identified threats to verifiability.
straightforward lifting from assembly to c keeping the untyped byte level view does not ensure verifiability as standard c analyzers are not well equipped to deal with such low level c code.
for example we cannot prove with frama c that a basic lifting of fig.
1a meets its specification.
we identify main threats to verifiability t1.
low level data explicit flags including overflows or carry bitwise operations masks low level comparisons byte level memory t2.
implicit variables variables in the untyped byte level stack packing of separate logical variables inside large enough registers t3.
implicit loop counters index structures indexed by loop counters at high level are split into multiple low level computations where the link between the different logical elements is lost.
experiments in sec.
vii b demonstrate that a straightforward encoding b asic fails to get the best of any analysis symbolic execution abstract interpretation or deductive verification.
properties of inline assembly.
tina exploits the following properties specific to inline assembly p1.
the control flow structure is limited only a handful of conditionals and loops hosting up to hundreds of instructions p2.
the interface of the chunk with the c code is usually given programmers annotate chunks with the description of its inputs outputs and clobbers with respect to its c context p3.
furthermore the chunk appears in a c context where the types and possibly more are known this kind of information is sought after in decompilers using heuristics whereas we only need to propagate it here.
all in all the above points show that lifting assembly chunks is actually an interesting sub problem of general decompilation both simpler and richer in information and thus significantly more amenable to overall success.
iii.
b ackground a. inline assembly we focus here on inline assembly in c c code as supported bygcc and clang .
masm microsoft macro assembler has a different syntax but works similarly.
assembly chunks in the gas syntax of gcc have two flavors basic and recommended extended see fig.
.
basic assembly allows the insertion of assembly instructions anywhere in the code.
they will be emitted as is during the production of the assembly file.
in this case compilers authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
asm volatile movdqa b xmm0 n t movdqa xmm0 a n t a basic version asm movdqa xmm0 n t movdqa xmm0 n t m a m b xmm0 b extended version figure assembly chunks basic extended versions assume the chunk has no effect on its c scope preventing safe interactions between assembly and c code yet that does not stop developers from using it when the implicit context looks safe.
in fig.
2a it is implicitly assumed that no optimization will occur on global variables aand band that xmm registers are not used by default.
extended assembly.
extended assembly allows in addition the description of the interactions with c through its inputs outputs and clobbers i.e.
registers or memory cells whose value is rewritten by the chunk .
such annotations work like a printf string format as shown in fig.
2b some assembly operands may be replaced by placeholders referring to a list of c operands.
the syntax requires binding c operands to location constraints as in fig.
1a and 2b.
constraints may also specify more than one location and let the compiler choose the best way to place this operand.
common placement constraints include rto bind to a general register mto bind to a memory address ito an immediate value and gwhich means r mori .
operands may be read only for inputs or write only for outputs with the modifier.
a read write operand is created either by linking an input to the same location as an output sizeof fd set sizeof fd mask in fig.
1a or by using the modifier instead of .
without special modifiers compilers assume read only operands are consumed before write only operands are produced so that these may share the same locations.
the clobber list may also contain keywords like memory arbitrary memory cells may be read and or written and cc conditional flags will be changed .
the specification of inputs outputs and clobbers stands as a contract between the chunk and the compiler.
compilers are totally blind to what actually happens inside the chunk relying on the contract and will not warn about mistakes inside the chunk.
forgetting to list an input or a clobber is an easy mistake that can result in code which does not behave as expected.
adoption.
the use of inline assembly is pretty widespread we estimate that of debian packages written in c c directly or indirectly depends on inline assembly.
it includes major projects like gmp and ffmpeg rigger et al.
actually reports that of the top rated c projects on github uses inline assembly.
we further estimate that of the chunks found in debian jessie .
used in sec.
vii a serve an optimizing purpose with an average size of approximately instructions and up to .
inline assembly is often used in conjunction with c macros or inlineable functions to be specialized by the compiler at each location.b.
binary code lifters binary code lifters are the cornerstones of modern binarylevel analyzers.
they are used to abstract the different binary instruction set architectures isa and formats into a single intermediate representation ir .
we rely on the ir of b insec called dba other irs are similar.
its syntax is shown in fig.
.
inst lv e goto e if e then goto e else goto e lv var n e cst lv unop e binop e e e?e e unop uext n sext n extract i..j binop arith bitwise cmp concat arith udiv urem sdiv srem bitwise shl shr sar cmp negationslash u u s s figure low level ir for binary code dba is a minimalist language comprising only two types of elements bitvector values and memory and three instructions assignments jumps and conditionals.
y et this is enough to encode the functional semantics of major isas including x86 and arm .
binary lifters provide specialized decoders for supported architectures in the same spirit that a compiler has one code emitter per supported architecture.
lifters are then used in disassembly algorithms to try to recover the semantics of the binary program.
we use them to disclose the semantics of compiled assembly chunks.
iv .
t aming inline assembl y an overview tina lifts inline assembly to semantically equivalent c taking advantage of properties p1 p3.
this original process consists mainly of two new phases verification friendly lifting and validation detailed respectively in sec.
v and vi.
first let us discuss the overall approach as schematized in fig.
.
compilation.
we compile the source code for the target architecture with debug information .
since we control code compilation we also include all contextual data that can help to reconstruct c code e.g.
variable names and types.
initial low level ir lifting .
we now start the translation per se by lifting the code back to the ir level.
the use of binary code may seem gratuitous at first sight.
this is however the best place to start working since assembly chunks are totally instantiated and embedded in their context register names and memory locations have been resolved by the compiler.
debug information here allows to locate the assembly chunk in the compiled code.
transformation into high level c .
we then lift the ir back to c through a combination of dedicated passes aiming at refining the low level ir with high level information sec.
v .
the end result is a c only code where assembly chunks have been substituted by a lifted c code amenable to verification.
this step is original.
validation .
the validation phase starts by recompiling the pure c code without optimization in order to preserve authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
c asm object code irtransforma tions c object code ircompila tion debugir lifting irinsertion compilation debug ir l ifting equiv alence ok remove?lifting valida tionhighlighted elements discussed in sec.
vi about the trust base.
figure overview of ti na the code structure our validation technique depends on it.
we locate the binary code corresponding to the lifted code once more and get back its ir representation.
we now possess two distinct ir pieces this one and the one from the first compilation.
we will aim to prove their semantic equivalence in sec.
vi.
this step is original.
we have implemented a prototype of tina leveraging existing tools frama c for c source code manipulation parsing localization c injection b insec ir lifting smt solvers integration and the dw arf debug format to pass information to binaries with the compiler.
v. f rom low level ir to high level c the goal of this lifting phase is to recover verifiable c code preserving the semantics of the original assembly chunk.
the transformations at ir level mitigate the identified threats to verifiability sec.
ii and reinforce each other sec.
vii .
type verification propagation.
to lift assembly code back to c chunk operations on bitvectors and memory need to be mapped to c operations on integers signed unsigned and pointers.
to this end we propagate types from the interface into the ir operations.
ir types can either be addresses typed pointers or values signed or unsigned with an associatedsize .
type information is further synthesized using forward propagation and constraints imposed on operands by low level operations.
this step also guarantees that inputs and outputs types are respected.
the lifter gives concrete c types using the type size information from dw arf.
high level predicate recovery threat t1 .
low level conditionals use flags zero zf sign sf carry cf oroverflow of set by previous instructions.
in most situations they have little meaning on their own and the way they are computed hampers understanding the purpose of the condition.
this pass applies djoudi et al.
s recent technique based on semantic equivalence proved by smt solvers.
it substitutes the low level condition built on flags by a more readable arithmetic comparison.
for example this phase recovers if ecx goto label instead ofif zf sf of goto label from the assembly snippet decl ecx jg label .
register unpacking threat t2 .
assembly chunks often contain optimizations exploiting data level parallelism in order to use the full capacity of the hardware by packing multiple value inside a bigger one fitting inside a machine register.
for instance loading byte characters inside an integer ismore efficient than four smaller loads.
the concepthas been exacerbated with single instruction multiple data extensions providing vectorized registers up to bits.
the issue here is that such packed code has very low level semantics masks shifts etc.
.
our novel register unpacking method uncovers the independent variables stored in a container thus preventing packed arithmetic from destroying the abstractions of the analyzers.
the method amounts to splitting registers into independent variables whose size depends on the uncovered usage rewrite the code accordingly and then clean up unused variables and code and rebuild higher level chunks through dedicated simplifications.
the principle is the following if a subpart of a variable is read in the code e.g.
extract .. eax then this subpart is likely to correspond to a logical entity.so we generate a fresh variable for this entity receiving the restricted value and replace each such extraction by this new variable.
to avoid the need for a fixpoint until every variable extraction is replaced we perform the replacement eagerly in steps a forward pass where each assignment of 2kbits is split into multiple fresh assignments of 2ibits wherei k for instance eax will be split into al ah eax 16 23 eax 24 31 ax eax 16 31 eax at the same time each variable restriction extract i..jvar corresponding to one of the newly generated variables is replaced by this new variable a final pass of dead code elimination removes each unused freshly generated variable.
note that subparts may overlap with each other for instance al axand eax share common parts but we found that most of the time only one of them survives the final step.
thus the size of the produced code does not increase much in the end.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
finally we also rely on the fact that expression propagations together with concatenation extraction simplification will automatically reconstruct bigger sized variables from concatenation of smaller sized ones e.g.
axhalf word from aland ahbytes .
in fig.
the chunk loads two char in a register before adding them using the hand lprefixes to access them.
without register unpacking the lifter uses bitmasking making the code more complex than its clear initial intent .
extern const unsigned char src unsigned char sum asm movzxw k0 n t addb h0 b0 n t q sum m src a sourceunsigned char tina ah unsigned char tina al0 unsigned char tina al1 tina begin 0 tina al0 src tina ah src tina al1 tina ah tina al0 sum tina al1 tina end 0 b lifting with unpackingunsigned int tina eax0 unsigned int tina eax1 tina begin 0 tina eax0 src src tina eax1 0xffffff00 tina eax0 0xff 0xff tina eax0 0xff tina eax0 sum 0xff tina eax1 tina end 0 c lifting without unpacking figure register unpacking expression propagation threats t1 and t2 .
we draw inspiration from compiler optimization techniques to devise a novel dedicated simplification mechanism geared toward our needs.
in particular we can afford very aggressive simplifications small code size w.r.t.
standard compilation setting but we have to address particular kinds of low level instructions coming from ir translation .
our method originally combines eager expression propagation coupled with dedicated lowlevel simplifications and a posteriori control to revert fruitless propagations when no simplification rule has been triggered.
eager expression propagation relies on the idea that more expression propagation raises more opportunity for further simplifications by dedicated rules.
y et systematic propagation can yield an exponential blowup of the code under analysis rather than the desired simplifications.
to mitigate this problem we propose eager propagation coupled with a posteriori control to revert fruitless propagation.
the algorithm works as follows as a preliminary step a data flow analysis collects all symbolic values terms associated to each pair name program point used in the ir code first we unconditionally propagate symbolic values in a first pass but save a reverse map for each propagated expression in case the propagation is not fruitful second we expect simplification rules described below tosimplify the whole expression third we identify expressions not yet simplified by syntactically comparing the terms before and after simplification and revert back the propagation on such case thanks to the reverse map a posteriori control finally we cleanup the code by filtering out unused variables dead branches and dead code.regarding simplification rules we use a mixture of standard and dedicated simplification rules standard for typical integerlevel properties and dedicated for more low level aspects.
here is a representative incomplete subset of these rules where x denotes the size of the expression x diamondmathany binary operator c a condition c kis a constant.
associativity commutativity re ordering x a arrowhookleft a x constant propagation modular arithmetic arrowhookleft arrowhookleft standard algebraic simplifications identity neutral absorbing and inverse elements etc.
x arrowhookleft x x arrowhookleft x x arrowhookleft x x arrowhookleft x arrowhookleft x x arrowhookleft x x x arrowhookleft x x x arrowhookleft ternary expression simplification c?x x arrowhookleft x c?x y arrowhookleft c?y x true ?x y arrowhookleft x false ?x y arrowhookleft y c?true false arrowhookleft c c ?false true arrowhookleft c ternary expression development x diamondmath c?y z arrowhookleft c?x diamondmathy x diamondmathz c?w x diamondmath c?y z arrowhookleft c?w diamondmathy x diamondmathz two complement arithmetic abstraction x arrowhookleft x extract x x arrowhookleft x s0 uext n c arrowhookleft c?
1n 0n sext n c arrowhookleft c?
1n 0n concatenation uext x y x concat y x arrowhookleft concat y x uext x k x shlk arrowhookleft concat x 0k concat 0k x arrowhookleft uext k x x extraction concatenation simplification extract .. x x arrowhookleft x concat extract i..j x extract j ..k x arrowhookleft extract i..k x extract i..j concat x y when j y arrowhookleft extract i..j y extract i..j concat x y when y i arrowhookleft extract i y ..j y x fig.
shows how the addition of rewrite rules exposes the intended semantics of a branchless absolute value computation.
cltd sign extend eax in edx xor edx eax complement eax if eax sub edx eax add one to eax if eax a branchless absolute value implementation tmp sext 64eax edx extract ..63tmp arrowhookleft edx eax s0?
0xffffffff eax eax edx arrowhookleft eax eax s0?
eax0 eax eax eax edx arrowhookleft eax eax s0?
eax eax b ir transformations figure expression propagation loop normalization threat t3 .
this pass aims at highlighting the relations between the current iteration of the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
loop and the variable values.
we especially look for affine relations of the form a x bwherexis the loop iteration counter.
we indeed found out that tools much prefer to analyze for int i i n i t c instead offor char t t t t n t t c .
assembly code though is more likely to have the second form.
we thus transform each self incrementing decrementing variables of the form v i while ... ... v v k in order to get code more amenable to analysis.
the transformation is done in up to steps rebasing replaces the initial value iby and each occurrence of the variable vbyi v rescaling replaces the increment kby and each occurrence of the variable vbyk v merging unifies the transformed variables with the loop iteration counter.
for example in fig.
1c the byte level affine relation between the counter ecx lifted as tina ecx and the moving pointer edi based at tina 4 i sedi tina 4 tina 3 ecx the code is lifted as tina 4 tina 3 tina ecx to take pointer arithmetic into account tina 4is an int pointing to bytes long values in x86 .
vi.
v alida tion for our translation to be trustworthy we use a two pronged approach we try to prove the semantic equivalence of the code prior to lifting with the lifted c code if this fails we rely on intensive random testing fuzzing to increase the level of trust in the lifted c code.
block based semantic equivalence.
the lifting process of sec.
v strives to preserve the isomorphism of the controlflow graphs based on basic blocks between the initial assembly chunk and its lifted c representation over their dba ir representation.
this property allows us to tackle the equivalence proof at basic block level.
the proof of equivalence proceeds as follows s1.we check the isomorphism of the control flow graphs extracted from the two lifted programs .
since we deal with deterministic labeled directed graphs this check is immediate and usually succeeds.
ti na is actually very careful during simplifications and recompilation to preserve the control flow structure see details below .
for the isomorphism check we track the relation between the heads of ir basic blocks and the corresponding emitted c code thanks to c labels and debug line information.
if the check succeeds we go to s2 otherwise we on fuzzing in practice sec.
vii a the latter has never happened.
s2.once we know the two control flow graphs are isomorphic we try to demonstrate the pairwise equivalence of corresponding vertices .
this allows to avoid directly dealing with loops.
each pairing of basic blocks is translated to logical formulas for which we ask smt solvers if inputs are identical can outputs be different?
if all queries are unsatisfiable then equivalence is proven otherwise we use our .taming simplifications.
in order to help the equivalence proof succeed ti na passes were designed to preserve the controlflow graph structure and to be traceable .
for the first goal simplifications never modify jump instruction except for trivial dead branch elimination and the lifter avoids inserting branches with lazy constructions such as or ternary operators.
for the second goal when a simplification changes the input output relation of a basic block it records the changes w.r.t the old ones and these properties will be added to the assumptions of s2.
for instance in fig.
the expression propagation records that eax holds the value 0for the entire chunk.
it will then be used during s2to prove the equivalence of the loop body where the register no longer exists in the generated part .
what could go wrong?
while ti na uses simplifications and lifting passes tailored to make the block based semantic equivalence algorithm possible the recompilation step is blind to this requirement and may therefore threaten it.
the s1 check may fail if the compiler modifies the control flow graph for example if some elements outside of the assembly chunk render a branch dead or a loop unrollable.
in fig.
1c since sizeof is known at compile time clang o1 unrolls the loop making the isomorphism check fail.
the s2 query may fail if the compiler moves parts of the computation across basic blocks changing the relation between inputs and outputs.
it may happen during code motions like loop invariant code motions.
in this case the graph isomorphism still holds but the relation between basic blocks is lost.
gcc funroll loops partially unrolls times the loop body in fig.
1c leading to a failed equivalence query.
to avoid such problems we recompile the code without any optimization o0 .
note that smt checks never time out in our experiments sec.
vii probably due to the naturally small size of blockbased queries.
however we can imagine that code showing hard to reverse behaviors such as cryptographic hash functions could make the s2 query fail.
trust base.
v alidation allows to increase the confidence in the lifting process using components as the trust base the binary code lifter the compiler and the solver.
all are well tested software and the last two are part of the trust base of most modern source level verification tools anyway.
furthermore while we trust the compiler debug information we argue that the compilation process itself is not part of the trusted base assembly chunks are untouched by it and validation will very likely catch errors during re compilation.
besides further mitigation includes systematic testing of assembly chunks vs. their ir representation and using multiple compilers and or solvers.
vii.
e xperiment al ev alua tion we evaluate our implementation of ti na on research questions rq1 how applicable is it on assembly chunks found in the wild?
rq2 how do off the shelf program analyzers behave on lifted code?
rq3 what is the impact of each optimization?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i applicability on debian .
jessie distribution gcc .
x86 arm total big100 alsa ffmpeg gmp libyuv alsa ffmpeg gmp libyuv assembly chunks trivial out of scope rejected relevant lifted v alidated average max size lifting time s v alidation time s a. wide applicability rq1 we run our prototype on all assembly chunks found in the linux debian .
distribution for x86 i.e.
chunks distributed over packages and functions.
as chunk distribution is not smooth we also fix subsets of samples one with the biggest chunks and another with all chunks from key major projects exploiting low level optimizations gmp ffmpeg alsa and libyuv .
table i sums up the results of lifting with ti na.
table ii applicability by compiler x86 gcc .
gcc .
clang .
assembly chunks relevant lifted v alidated we exclude trivial empty or unused out of scope and rejected chunks.
out of scope chunks include those with floating point operations os level hardware instructions or hardware based crypto primitives like aes.
rejected chunks are those deemed unsafe because they do not respect their interface.
y et we activate options in our tool to specifically regard accessing flags xmm registers or memory as safe allowing to consider extra chunks as relevant notably in ffmpeg .
the statistics of table i report on the tool s behavior with these settings.
on in scope chunks ti naperforms extremely well with chunks lifted and fully validated no resort to testing this amounts to of all chunks found for a negligible cost .7s per chunk on average .
the biggest chunks are a little less successful as they have a fair amount of unhandled floating point instructions.
ti na works equally well on major projects for arm orx86 and with gcc orclang onx86 table ii confirming its genericity.
b. adequacy to formal verification tools rq2 rq3 we select tools representing popular formal techniques currently used in the industry klee for symbolic execution bug finding and frama c with its ev a plug in for abstract interpretation runtime error verification andwp plug in for deductive verification functional correctness .
experiments on both symbolic execution and abstract interpretation use functions out of from the key projects in sec.
vii a selected due to the ease of automatically generating the initial contexts for both analyses.
for all tools we also report the observed differences using a basic lifter and different optimization levels o1 high level predicate recovery o2 o1 register unpacking o3 o2 expression propagation and o4 o3 loop normalization .
note that o4 is ti na.
table iii impact of ti na lifting strategies on klee lifting none basic o1 o2 o3 o4 functions analyzed w o blocking3 functions covered remove aggregate time n a 115s 115s 110s 103s 105s paths all functions .4m .5m .8m .6m .6m .6m symbolic execution.
we perform our experiments with klee which at present does not handle inline assembly chunks and stops upon meeting one except for a very few simple cases such as assembly level rotations.
this fact can sometimes prevent the adoption of symbolic execution .
table iii summarizes our findings.
rq2 first klee alone can analyze only few functions as almost any block of assembly stops the analysis and none of them is fully path covered.
adding lifting allows to analyze all considered functions to completely path cover of them and to explore significantly more paths within the same analysis budget .
.
the lifting strategy rq3 does not impact the functions that klee can fully cover but ti na optimizations considerably speed up code exploration enabling to cover significantly more paths than basic lifting in the same amount of time.
this is explained by ti na produced code being higherlevel with fewer instructions and local variables thereby accelerating smt solving.
note that control flow structure and thus total number of paths does not change.
moreover each optimization step brings some degree of improvement.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the major improvement gaps here are brought by register unpacking o2 and expression propagation o3 .
as expected loop normalization o4 has no impact as symbolic execution simply unrolls loops.
additional experiments demonstrates that high level recovery o1 has also a substantial impact on the analysis removing it leads to .4m explored paths vs .6m in full ti na .
abstract interpretation.
we use the frama c ev a plugin.
frama c has limited support for inline assembly based on interfaces translating them into logical assigns annotations for modified variables safely interpreted in ev a and wp as non deterministic assignments.
table iv sums up the results for rq2 .
lifting the assembly code with ti na almost always reduces the number of alarms in the common c code .
this follows from the better precision of the analysis since modified variables in the lifted code are now accessible.
in half the cases we observe a precision gain on function return values .
most functions with return values or initial c alarms show such improvements.
table iv impact of ti nao ne v a function with alsa ffmpeg gmp libyuv total returns non void better return values initial c alarms alarm reduction in c new memory alarms positive impact the lifted c code also contains new alarms which we could not detect before and should be taken into account usually out of bounds or other memory accesses .
we also found some possibly buggy behaviors sec.
vii d .
for short we observe positive impact from ti na w.r.t.
nonlifted code on of the functions more precision reducing alarms from over approximations of inline assembly or new memory alarms in lifted code .
table v impact of lifting strategies on ev a lifting functions none basic o1 o2 o3 o4 without any alarms remove with asm memory alarms n a errors remove emitted c alarms emitted asm alarms n a total alarms table v additionally shows the impact of the lifting strategy rq3 .
compared with basic lifting each additional optimization increases the quality of the lifted code fewer asm and total alarms and the precision of the analysis more functions without alarms fewer memory alarms more errors including loop normalization which allows finer approximations of loop fixpoints widening .
ti na o4 thus significantly improvesall these aspects.
moreover the produced alarms are more precise possible buffer overflows such as a ffmpeg index access are now recognized as errors and not mere alarms.
additional experiments demonstrates that removing any of the optimization steps leads us quite far from the whole chain result.
table vi impact of ti na lifting strategies on wp lifting function none basic o1 o2 o3 o4 saturated sub remove ok ok ok ok ok saturated add remove remove ok ok ok ok log2 remove remove remove remove ok ok mid pred remove remove ok ok ok ok strcmpeq remove remove remove remove ok ok strnlen remove remove remove remove ok ok memset remove remove remove remove ok ok count remove remove remove remove ok ok max element remove remove ok ok ok ok cmp array remove remove remove remove ok ok sum array remove remove remove remove ok ok sumsquareerror remove remove remove remove ok ok weakest precondition calculus.
we use the deductive verification frama c plug in wp .
we take assemblyoptimized functions excerpts from ffmpeg gmp libyuv libgcrypt and udpcast others adapted from optimized assembly snippets and translated examples from acsl by example .
functional specifications and loop invariants are manually inserted before verification as usual for wp based methods we do not insert any other annotation.
moreover recall that without lifting assembly chunks are correctly overapproximated by non deterministic assignments to the modified c variables.
table vi details our results.
the unlifted code does not require invariants no c level loops while lifted codes all require identical invariants as they share the same controlflow structure.
a quick glance at table vi shows that rq2 while wp without lifting never succeeds and basic lifting is far from enough ti na does allow to prove the functional correctness of all functions .
the simple over approximations of assembly chunks provided by frama c without lifting are not sufficient to prove properties as strong as functional correctness.
regarding optimization steps rq3 it turns out that loop normalization o4 has no direct impact since the user must provide manual loop invariants.
on the other hand all other steps are complementary table vi and crucial removing only one of them yields at best a success rate.
c. conclusion experiments show that our code lifting method is highly practical debian .
in scope blocks are lifted and validated that it has a positive and significant impact on all formal verification tools considered allowing them to effectively handle code with inline assembly and finally that full ti na o4 is needed to facilitate further code analyses as less refined lifting yields poorer analyses.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
interestingly all analyses do not behave the same w.r.t the optimization chain symbolic execution mostly takes advantage of register unpacking and expression simplifications abstract interpretation is sensitive to the optimization steps and weakest precondition calculus strongly requires all of them but loop normalization which is already granted by user supplied loop invariants.
d. epilogue post analysis considerations we found compliance issues during our experiments.
most have no impact with current compilers but may induce bugs out of compiler changes maintenance or code reuse.
while evaluating verifiability we ran into 6potential buffer overflows hidden in assembly chunks.
for example a ffmpeg function accesses index 1of its input buffer this is actually reported in the comments.
all errors initially reported by framac ev a were also reproduced with klee.
after determining and adding relevant logical preconditions we were able to show the absence of runtime errors in the reported corrected functions.
besides we were able to prove with frama c wp the functional correctness of functions from the debian distribution code base including sumsquareerror assembly instructions .
viii.
d iscussion a. threats to validity benchmark representativeness.
the considered code base is quantitatively and qualitatively representative of the use of inline assembly it is extensive and comprises highly popular and respected projects.
we mainly experiment on gcc and x86 but our experiments on arm and clang show our results also hold in these settings.
still we obviously miss closed source software and code which relies on microsoft s c compiler different assembly syntax .
y et there is no reason to believe it would behave differently.
verification methods.
we consider three of the most popular verification techniques symbolic execution abstract interpretation deductive verification representative of the major classes of analysis both in terms of goal bug finding runtime error checking and proving functional correctness and underlying core technologies domain propagation constraint solving path exploration first order reasoning .
also we rely on wellestablished verification tools each applied in several successful industrial case studies.
thus we reckon that our experiments support our claim regarding the general verifiability of the codes ti na produces.
b. limitations our lifting has two main limitations hardware related instructions and floating point operations.
since we aim to lift assembly chunks back to c the support of hardware related instructions cannot be achieved outside of modeling hardware in c as well for example neither dba ir nor c can make direct reference to hardware interrupts.
here we probably cannot do better than having two approximated c models of hardware instructions one for over and one for under approximations.
while not necessarily that difficult for reasonable analysis precision this is clearly a manpowerintensive task.
the float limitation is primarily due to the lack of support in b insec .
adding such support is also manpower intensive but not that hard.
y et the real issue is that efficient reasoning over floats is still ongoing scientific work in both program analysis and automated solvers e.g.
theory support is new in smt lib only solvers in the relevant category of smt comp .
as such it threatens our validation part and most program analyzers would not be able to correctly handle these lifted floats anyway.
despite these limits we still lift and validate of assembly chunks of a standard linux distribution .
finally our technique is amenable to a certain extent to standalone assembly code or even binary code decompilation.
however this case can quickly deteriorate to the usual difficult problem of lifting an arbitrary program.
especially dynamic jumps or large size complicated cfg would probably yield serious issues.
ix.
r ela ted work though some prior work has addressed code lifting for verification it is worth noting that verifiability has never been explicitly addressed so far.
we hereafter review approaches partly related to our method.
assembly code lifting and verification.
maus proposes a generic method simulating the behavior of assembly instructions in a virtual machine written in c. this work was used by the v erisoft project to verify the code of an hypervisor consisting of mixed low level code.
maus technique relies on vcc to write and prove verification conditions regarding the state of its machine.
while we strive to produced high level code maus virtual code contains all low level code details including flags.
further work by schmaltz and shadrin aims only at proving the abi compliance of the assembly chunks.
this method is however restricted to masm and the windows operating system.
ti na here applied to gcc inline assembly is independent of the assembly dialect by leveraging binary level analyzers and is applicable to a wider range of architectures.
fehnker et al.
tackle the analysis of inline assembly for arm architecture using a model checking based syntactic analysis to integrate c c analyses with inline assembly.
this solution is however limited by its purely syntactic basis first it is restricted to one single inline assembly dialect second it loses the soundness properties we target.
losing soundness may be an appropriate practical trade off but not when targeting sound formal analyses.
corteggiani et al.
also use code lifting within their framework.
however their end goal is to perform dynamic symbolic analyses on the produced lifted code.
sec.
vii b shows that such very targeted lifting may not be enough for other formal analyses.
moreover correctness of the translation is not addressed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
myreen et al.
targets verification of pure assembly code.
the translation corresponds to our basic lifter yet the approach proves the initial lifted ir is semantically equivalent to a very detailed isa model.
this paper then targets verification at the level of assembly code but requires code annotations and interactive proving.
our proposal targets the lifting of inline assembly within c for general verification purposes is geared at ensuring the verifiability of the produced code and its validation establishes the correctness of the ir transformations producing the final extracted c code.
decompilation.
decompilation tackles the challenge of recovering the original source code or a similar one from an executable.
this goal is very difficult and requires hard work to find back the information lost during compilation .
despite significant recent progress decompilation remains an open challenge.
still it is used to enhance program understanding e.g.
during reverse engineering.
as such correctness is not the main concern for example it does not always need produce compilable source code.
soundness is addressed by two recent works.
schulte et al.
use search based techniques to generate source code producing byte equivalent binaries to the original executable.
this technique when it succeeds ensures soundness by design but it is only applied to small examples with limited success.
brumley et al.
on the other hand use testing to increase trust in their lifted code.
we do draw inspiration from some decompilation techniques for type reconstruction .
even though we do not construct types that are not derived from inputs it helps in strengthening our type system.
recovering the instructions and cfg of the code under analysis is a big challenge in decompilation especially for adversarial codes like malware.
the regularity and patterns of managed codes allow a very good recovery in practice b y unsound methods yet without any guarantee.
inline assembly chunks have more limited behaviors clear control flow no dynamic jumps and the fact that we control compilation makes it a non issue for us.
binary level program analysis.
for more than a decade now the program analysis community has spent significant efforts on binary level codes either to analyze source less programs malware cots or to check the code that is really running.
the efforts have mainly been concerned with safe high level abstraction recovery and invariant computation.
several generic binary lifters have been produced reducing complex isas to a small set of semantically well defined primitives.
though well tested more trust could be achieved if lifters were automatically derived from something akin to arm s formal specifications .
mixed code problems.
morrisett et al.
have proposed typed assembly language to ensure memory and control flow integrity in low level assembly.
patterson et al.
have exploited the idea to mix low level code with functionallanguages.
we borrow some elements to propagate types between c and inline assembly.
translation validation and code equivalence.
in order to achieve safe lifting we use translation validation a technique also used in compcert register allocation .
our formal needs thus rely on well established and tested tools here smt solvers usable as blackboxes instead of a full formal proof of the whole lifting chain.
program equivalence checking is considered a challenging verification task.
dedicated approaches start to emerge like relational weakest precondition calculus for proof or relational symbolic execution for bug finding .
x. c onclusion we have presented ti na a method enabling the analysis of c c code mixed with inline assembly by lifting the assembly chunks to equivalent c code.
this method is the first to generate well structured c code amenable to formal analysis through a dedicated principled succession of transformations geared at improving the verifiability of the produced code .
to boot translation validation builds trust into the lifting process.
thorough experiments on real world code show that tina is widely applicable of in scope chunks from linux debian jessie .
are validated and that its semantic transformations positively and significantly impact popular verification techniques.