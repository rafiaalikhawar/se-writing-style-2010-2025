deuce a lightweight user interface for structured editing brian hempel justin lubin grace lu and ravi chugh university of chicago brianhempel justinlubin gracelu rchugh uchicago.edu abstract we present a structure aware code editor called deuce that is equippedwithdirectmanipulationcapabilitiesforinvokingautomated program transformations.
compared totraditional refactoring environments deuceemploys a direct manipulation interface thatistightlyintegratedwithinatext basededitingworkflow.in particular deucedraws i clickable widgets atop the source code thatallowtheuserto structurallyselect theunstructuredtextfor subexpressionsandotherrelevantfeatures and ii alightweight interactive menu of potential transformations based on the currentselections.weimplementandevaluateourdesignwithmostly standardtransformationsinthecontextofasmallfunctionalprogramminglanguage.acontrolleduserstudywith21participants demonstrates that structural selection is preferred to a more traditional text selection interface and may be faster overall once users gainexperiencewiththetool.theseresultsaccordwith deuce s aim to provide human friendly structural interactions on top of familiar text based editing.
ccs concepts softwareanditsengineering integratedandvisualdevelopmentenvironments human centered computing human computer interaction hci keywords structured editing refactoring direct manipulation acm reference format brian hempel justin lubin grace lu and ravi chugh.
.
deuce a lightweight user interface for structured editing.
in icse 40th internationalconferenceonsoftwareengineering may27 june3 gothenburg sweden.acm newyork ny usa 11pages.
introduction plain text continues to dominate as the universal format for programsinmostlanguages.althoughthesimplicityandgenerality oftextareextremelyuseful thebenefitscomeatsomecosts.for noviceprogrammers theunrestrictednatureoftextleavesroom for syntax errors that make learning how to program more difficult .for expert programmers manyediting permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
vastmajority fallwithin specific patterns that could be performed more easily and safely by automated tools.
broadly speaking two lines of work have respectively sought to address these limitations.
structuredediting.
structurededitors suchasthecornellprogram synthesizer scratch maloney et al .
resnicketal .
andtouchdevelop reducetheamountofunstructuredtextusedtorepresentprograms relyingonblocksandothervisualelementstodemarcatestructuralcomponentsofaprogram e.g.
aconditionalwithtwobranches and afunctionwithanargumentandabody .operationsthatcreateand manipulate structural components avoid classes of errors that may otherwiseariseinplaintext andtext editingislimitedtowithin well formed structures.
structured editing has not yet however becomepopularamongexpertprogrammers inpartduetotheir cumbersome interfaces compared to plain text editors monig et al .
as well as their restrictions that even transitory evolving programs always be well formed.
textselection basedrefactoring.
analternativeapproachinintegrated development environments ides such as eclipse is to augment unrestricted plain text with support for a variety of refactorings .insuch systems theusertext selectssomethingofinterestintheprogram anexpression statement type orclass andthenselectsatransformation either from a menu at the top of the ide or in a right click pop up menu.
this approach provides experts both the full flex ibility of text as well as mechanisms to perform common tasks more efficiently and with fewer errors than with manual low level text edits.
although useful this workflow suffers limitations the text selection mechanism is error prone when the item to select islong spanning a non rectangularregion or requiring scrolling .
alltransformationsmustrequireasingle primary selection argument and any additional arguments are relegated to a separate configuration wizard window.
thelistoftoolsistypicallyverylong evenintheright click menu where tools that are not applicable to the primary selection are filtered out making it hard to identify invoke and configure a desired refactoring mealy et al .
murphy hill et al.
vakilian et al.
.
evenwhenatransformationhasnoconfigurationoptionsor whenthedefaultsareacceptable asisoftenthecase the user must go through a separate configurationwizardtomakethechange.theusermust furthermore navigatetoanotherpanewithintheconfigurationwizardto preview the changes before confirming them.
ourapproach.
ourgoalistoenableaworkflowthatenjoysthe benefits of both approaches.
specifically programs ought to be acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden brian hempel justin lubin grace lu and ravi chugh represented in plain text for familiar and flexible editing by expertprogrammers andtheeditingenvironmentoughttoprovide automatedsupportforavarietyofcodetransformationswithout deviating from the text editing workflow.
in this paper we present a structure aware editor called deuce that achieves these goals by augmenting a text editor with i clickable widgets directly atop the program text that allow the user tostructurallyselect theunstructured textfor subexpressionsand other relevant features of the program structure and ii a contextsensitive tool menu with previews based on the current selections.
structuralcodeselection.
ratherthanrelyingonkeyboard based text editsforselection oureditordrawsdirectmanipulationwidgetstostructurallyselect itemsinthecodewithasinglemouse click.
in particular holding down the shift key transitions the editor into structural selection mode.
in this mode the editor draws a box which resembles a text selection highlight around the code item below the current mouse position.
clicking the box selects the entiretextforthatcodeitem eliminatinganypossibilityforerrorand reducingthetimeneededtoselectlong non rectangularsequences of lines.
furthermore this interface naturally allows multiple selection evenwhenitemsarefarapartinthecode.structuraltext selection helps address concerns and above.
context sensitive menu with previews.
because structural selection naturally supports multiple selection we address concern by showingonlytoolsforwhich allnecessaryargumentshavebeen selected reducingthenumberoftoolsshowntotheusercompared to a typical right click menu.
hovering over a result description previewsthechanges andclickingaresultchoosesit.fortoolswithfewconfigurationoptions webelievethepreviewmenuprovidesa lightweight way to consider multiple options while staying within the normal editing workflow helping to address concern .
the resulting workflow in deuceis largely text driven but augmentedwithautomatedsupportforcodetransformations e.g.
to introducelocalvariables rearrangedefinitions andintroducefunction abstractions that are tedious and error prone e.g.
because of typos namecollisions andmismatcheddelimiters allowingthe usertospendkeystrokesonmorecreativeanddifficulttasksthat are harderto automate.the name deucereflects thisstreamlined combination of text and mouse based editing.
contributions.
this paper makes the following contributions wepresentthedesignof deuce acodeeditorequippedwith structuralcodeselection alightweightdirectmanipulationmechanismthathelpstoidentifyandinvokeprogramtransformationswhile retaining thefreedom andfamiliarityof traditional text based editing.
our design can be instantiated for different programming languages and with different sets of program transformations.
.
we implement deucewithinsketch n sketch a programming environment for creating scalable vector graphics svg images.mostofthefunctionalprogramtransformationsinour implementation are common to existing refactoring tools but two transformations move definitions andmake equal are to the best of our knowledge novel.
.
to evaluate the utility of our user interface we performed acontrolled user study with participants.
the results show that compared to a more traditional text selection based refactoring interface structural code selection is preferred and may be faster for invoking transformations particularly as users gain experience with the tool.
our implementation videos of examples and user study materials are available at in the next section we introduce deuce with a few short examples.
overview examples example .
despite the inten tion of the followingprogram the redsquare definition usesdifferent valuesfor the widthand height of therectangle the fourth and fifth arguments respectively to the rectfunction .
the user chooses deucecode tools rather than text edits to correct this mistake.
the user presses the shift key to enter structured editing mode and then hovers over and clicks the two constants 120and to select them the selected code items are colored orange in the screenshotabove.basedontheseselections deuceshowsapop up codetoolsmenuwithseveralpotentialtransformations.the make equal by copying tool would replace one of the constants with the other thusgeneratingasquare.however suchaprogramwould require two constants to be changed whenever a different size is desired.
instead the user wishes to invoke make equal withsingle variableto introduce a new variable that will be used for both arguments.hoveringoverthismenuitemdisplaysasecond level menu shown above with tool specific options in this case the names of four suggested new variable names.
the user hovers over the second option which shows a preview of the transformed code shown on the right .
theuserclickstochoosethesecondoption.
noticethat thenumber rather than waschosen tobe thevalueofthenewvariable w.whereasthetoolprovidedconfiguration options for the variable name it did not provide options for which value to use this choice was made by the implementor of themake equal code tool not by the deuce user interface.
example2.
consider the following program that draws two circles connectedbyaline.alldesignparametersandshapeshavebeenor ganizedwithinasingletop level connectedcircles definition.to makethedesignmorereusable theuserwants connectedcircles to be a function that is abstracted over the positions of the two circles.
the user hovers over and clicks the defkeyword and selects thecreate function from definition tool shown in the screenshot .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
deuce a lightweight user interface for structured editing icse may june gothenburg sweden inresponse createfunctionrewrites the definition to be a function shown on the right and previous uses of connectedcircles are rewritten to appropriate function calls not shown .
theorderofargumentstothefunctionmatchtheorderofdefinitions in the previous program but that order was unintuitive the coordinates of the startandendpoints were interleaved.
to fix this asshownabove theuserselectsthelasttwoargumentsand thetarget position i.e.the space enclosed by a blue rectangular selection widget between the first two and selects the reorder arguments tool so that the order of arguments becomes startx starty endx and endy notshown .callsto connectedcircles are again rewritten to match the new order not shown .
example .
intheprogrambelow theuserwouldliketoorganize all design parameters and shapes within the single logodefinition.
the user hovers over and selects the five definitions on lines through as well as the space on line and selects the move definitions tooltomovethedefinitionsinside logo.thetransformationmanipulatesindentationanddelimitersappropriatelyinthe final code not shown .
deuce design and implementation inthissection weexplainthedesignof deuceinmoredetail.first we define a core language of programs where various structural features can be selected.
then we describe a user interface that displays active transformations based on the set of structural se lections.
finally we describe a set of general purpose program transformations that are provided in our current implementation.
little.
tomakethediscussionofourdesignconcrete wechoose to work with a small functional language called little defined in figure1.a littleprogramisasequenceoftop leveldefinitions the last of which is called main.
notice that all sub expressions sub patterns definitions both at the top level and locally via let program defx0e0 def main e e c x pe e1e2 letpe1e2 casee p1e1 p c x expressions e e patterns p p figure syntax of little.
the orange boxes and blue dots identify features for structural selection.
editorstate code program selections set selection activestate active notyetactive inactiveoptions nooptions stringoption stringresult description string code program codetool name string requirements string active editorstate activestate run editorstate options list result figure code tool interface.
and branches of caseexpressions are surrounded in the abstract syntaxbyorangeboxes thesedenote codeitems thatwillbeexposed forselectionanddeselectionintheuserinterface.inaddition there aretarget positions denoted by blue dots before and after every definition expression andpatternintheprogram.targetpositions are abstractwhitespace betweenitemsintheabstractsyntaxtree which will also be exposed for selection.
codetoolinterface.
eachcodetoolmustimplementtheinterface infigure2.atoolhasaccesstothe editorstate whichcontainsa program and the setof structural selection s within it.
based on theeditorstate theactivepredicatespecifieswhetherthetoolis active readytorunandproduce resultoptions notyetactive couldbe activeifgivenmorevalidselections or inactive invalid based on the selections .
for example move definitions is notyetactive if the user has selected one or more definitions but no target position.
when invoked via run a tool has access to theeditorstate and configuration options namely an optional string.thisstrategysupportstheubiquitous renametool.amore full featured interface may allow a more general set of configu ration parameters the challenge would be to expose them usinga lightweight user interface.
in our implementation all transformations besides renamerequire nooptions .
each resultis a new programand a description of the changes.
thisapi betweenthe userinterface andcode toolimplementationsisshallow inthesensethatacodetoolimplementationcan do whatever it wants with the selection information.
a framework for defining notions of transformation correctness would be a useful line of work but is beyond the scope of this paper.
currently code tools must be implemented inside the deuceimplementation.
designing a domain specific language for writing transformations would be useful but is also beyond the scope of this paper.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden brian hempel justin lubin grace lu and ravi chugh figure example target positions.
implementation in sketch n sketch.
we have chosen to implementourdesignwithin sketch n sketch chughetal .
hempel and chugh2016 an interactiveprogramming system for generatingsvgimages.whereas sketch n sketch providescapabilitiesfordirectlymanipulatingthe outputofaprogram deuce provides capabilities for directly manipulating the codeitself.
direct code manipulation is particularly useful for a system like sketch n sketch for a couple reasons.
first while the existing output directedsynthesisfeaturesin sketch n sketch attemptto generate program updates that are readable and which maintain stylisticchoicesintheexistingcode thegeneratedcodeoftenrequires subsequent edits e.g.to choose more meaningful names to rearrangedefinitions andtooverridechoicesmadeautomatically byheuristics deuceaimstoprovideanintuitiveandefficientinterface for performing such tasks.
furthermore by allowing users to interactivelymanipulatebothcodeandoutput weprovideanother step towards the goal of direct manipulation programmingsystems identified by chugh et al .
.
these two capabilities direct manipulation of code and output are complementary.
sketch n sketch iswritteninelm browser.
the project uses the ace text editor for manipulating littleprograms.
thesecondreasonforthename deuceis that it extends ace.
we extended sketch n sketch to implement deuce ourchangesconstituteapproximately9 000lines of elm and javascript code.
the new version v0.
.
is available at .
user interface thegoalsofouruserinterfaceare first toexpose structural code selection widgets corresponding to the code items and target positionsina littleprogram and second todisplayaninteractive menu of active transformations based on the set of selections.
so that the additional features provided by deucedo not intrude on the text editing workflow we display structural selection widgets when hovering over the code box only when the user is holding down the shift key.
hitting the escape key at any time deselects all widgets and clears any menus returning the editor to text editingmode.thisallowstheusertoquicklytogglebetween editing modes during sustained periods in either mode.
when not using the shift modifier key the editor is a standard monospace code editor with familiar unrestricted access to general purpose text editing features.
.
.
structural code selection.
the primary innovation in our designistheabilityto structurally select concretesourcetextcorresponding to code items and target positions from the abstract syntax tree of a program.
codeitems.
ourcurrentimplementationdrawsaninvisible bounding polygon around the source text of each expression whichtightlywrapstheexpressionevenwhenstretchedacrossmultiple lines.thesepolygonsserveasmousehoverregionsforselection with the polygons of larger expressions drawn behind the smaller polygonsforthesubexpressionssuchthatallpolygonsforchildexpressions partially occlude those of their parents.
because complex expressions in littleare fully parenthesized it is always unambiguousexactlywheretostartandendeachpolygon andthereare alwayscharacterpositionsthatcanbeusedtoselectanarbitrary subexpression inthe tree.similarly we createbounding polygons for all patterns and definitions.
whenhoveringoveraninvisibleselectionpolygon deucecolors thepolygontoindicatethatithasbecomethefocus.itstransparency andstyleisdesignedtoresemblewhatmightotherwisebeexpected for text selection cf.the screenshots in .
clicking a polygon selectsthecodeitem makingitvisibleevenafterhoveringaway.
hovering the mouse back to the polygon and clicking it again deselects the code item.
target positions.
theuserinterface alsodrawspolygonsforthe whitespacebetweencodeitemsforselectingtargetpositions.figure left shows how our implementation draws whitespace polygonsslightlytotheleftofthebeginningofaline anduntiltheend ofalineeveniftherearenocharactersonthatline.figure3 center shows whitespace polygons with non zero width even when there are no whitespace characters between adjacent code items.
another concern is that many target positions in the abstract syntax from figure describe the samespace between code items.
for example the expression on line of figure contains both an after 50and before 70position.
because such target positions between adjacent items are redundant our implementation draws only one whitespace polygon.
this polygon is not selected in any of the screenshots.
a more interesting case is for the code items def p e and let p e thereisbothanafter ptargetandabeforeetarget.toallocatethewhitespacebetween pande wetakethe following approach.
the space up to the first newline if any isdedicated to afterp the remaining is for before e. if there is no newline thenwedonotexposeanyselectionwidgetforbefore e. for comparison notice howthe whitespacefrom theend ofline to beginning of line in figure right is split into two polygons but the whitespace from the end of line to the beginning of line in the figure left is not.
in other settings it may be worthwhile to consider alternative approaches to the design decisions above.
.
.
displaying active code tools.
severalprogramtransformations may be activebased on the items and targets that are selected.wedesignandimplementalightweightuserinterfacefor identifying invoking and configuring activetransformations.
pop uppanel.
whentheuserhasenteredstructurededitingmode by pressing shift and selected at least one item we automatically authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
deuce a lightweight user interface for structured editing icse may june gothenburg sweden displayamenuneartheselecteditems.theuserhasalreadypressed akeytoenterthismode soourdesigndoesnotrequirearight click to display the menu.
the user can drag the pop up panel if it is obstructingrelevantcode.weoftenmanuallyre positionedpop up menus to make the screenshots in fit better in the paper.
hoverpreviews.
eachtoolinthemenuhasalistof results which appear in a second level menu when hovering the tool name.
each second levelmenuitemdisplaysthe description ofthechange and hovering over it previews the new codein the editor.
clicking theitemconfirmsthechoiceandclearsall deuceselections.when there are few results i.e.configuration options this preview menu provides a quick way to consider the options rather than going through a separate configuration wizard.
for tools that requiremultipleandnon trivialconfigurations however theeditor could fall back on separate tool specific configuration wizards our current implementation of deuce does not support this.
.
program transformations we have implemented a variety of programtransformations shownontheright.
while we believe these transformations form a useful set of basic tools for com mon programming tasks we do not ar gue that these constitute a necessary orsufficient set.
one benefit of our design is that different sets of transformations such as refactorings for class based lan guages refactorings for functionallanguages thompsonandli transformations that selectively changeprogrambehavior reichenbach et al.
and task specific transformationsthatdonothavecommon recognizable names steimann and von pilgrim canbeincorporatedanddisplayed to the user within our interface.
we limit ourdiscussion below to transformations that are not implemented in existing refactoring tools.
the supplementary appendices describeothertransformations but these details are not necessary to understand the rest of the paper.
makeequalwithsinglevariable.
whenmultipleconstantsand anoptionaltargetpositionareselected the makeequalwithsingle variabletransformationintroducesanewvariable boundtooneof the constants and replaces all the constants with the new variable.
this has the effect of changing the program to make each of these valuesequal.thetransformationattemptstosuggestmeaningful names based on how the selected expressions appear in the pro gram.
for example from because the numbers 120and80 are passed as the fourth and fifth arguments respectively to thefunction def rect fill x y w h ... the suggested names include wandh.
the user is asked to choose a name.
the valueitself inthiscase 120or80 isnotasimportant theintention is that the values vary at once by a single change so to keep the number of results small the transformation does not ask the user to choose which value to use for the variable.move definitions.
because of nested scopes and simultaneous bindings i.e.tuples therearemanystylisticchoicesaboutvariable definitions when programming in functional languages.
the move definitions transformation takes a set of selected definitions and a single target position and attempts to move the definitions tothe target position.
if the target position is before an expression ane w let bindingisaddedtosurroundthetarget.whitespaceis addedorremovedtomatchtheindentationofthetargetscope.if thetargetpositionalreadydefinesalistpattern thentheselected definitionsareinsertedintothelist.ifthetargetpositiondefines asinglevariable thenalistpatterniscreated.incaseswherethe intendedtransformation wouldcapture variableusesor movedefinitions above their dependencies errors that are easy to make when using text edits alone the transformation makes secondary edits alpha renamingvariablesandmovingdependencies tothe programtoavoidtheseissues.ourimplementationof movedefinitionsalso provides options for whether or not to collapse multiple definitions into a single tuple and also provides support for rewriting arithmetic expression definitions as an alternative way to deal with dependency inversion issues.
user study we designed and implemented deucewith the goal to incorporate structurededitingwithinatext basedprogrameditor.inthissection wedescribeauserstudydesignedtomeasurethedegreeto which we were successful.
besidesthetwonovelmechanismsinouruserinterfacedesign structuralcodeselectionandcontext sensitivepreviewmenus that wewishtoevaluate thereareseveraladditionalfactorsatplay.first many users may not have extensive experience with functionalprogramming languages especially the custom littlelanguage supportedinourimplementation.second ourimplementationprovidessomefamiliartransformationsbutsome particularlythose involving targetpositions are not.furthermore someusers may prefertousetext editingratherthanstructurededits evenwhen the latter can be used.
these factors make it hard to perform a directcomparisonbetweenourimplementationof deuceandan existing system such as eclipse.
to mitigate these factors we designed a study that compared deucewith a baseline version of the system with features designed to emulate the traditional text select based interface de scribed in .
we then designed tasks to be completed in both versions and withouttext edits to measure the effect of the new deuceuserinterfacefeaturescomparedtothebaselineones.below wedescribethedifferentconfigurationsofoursystem ourstudy procedures and our results.
.
system configurations recall that tools may be activeornotyetactive based on one or more selected items and target positions figure .
traditional mode text select mode .
to form the traditional mode of the tool which we called text select mode in the user studymaterials weimplementedfourinteractionsseparatefrom the workflow described in and .
to invoke code tools.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden brian hempel justin lubin grace lu and ravi chugh a codetoolsmenu.
theeditordisplaysacodetoolsmenuatthe top of the window with a list of all transformations available in the system this menu is akin to the source and refactor menusin eclipse.
the user selects a tool from this menu without first selecting anything in the program.
then the editor displays a tool configuration panel that displays tool specific instructions.
tool configuration panels which appear in all four interactions of traditional mode are discussed below.
b text selectsingleargument codetoolsmenu.
thisinteraction islikeinteraction a exceptthattheuserfirst text selectsanitem ortargetinthecode.likeeclipse text selectingrequirestheentire item to be selected possibly with trailing or leading whitespace.
our implementationprovides moregenerous text selectionmechanisms e.g.largest containing expression smallest surrounding expression butthestricterversionisusedinthestudybecauseitis more similar to existing approaches .
also like eclipse all tools are displayed and enabled in the code tools menu even if the tool is inactive based on the selection.
c text selectsingleargument right clickmenu.
afterfirsttextselectinganitem asininteractionb theuserright clickstotrigger a pop up menu that displays onlyplausible tools activeor notyetactive .
a similar workflow is provided by eclipse.
returning to example from the screenshot on the right shows the right clickmenuaftertext selectingthe 120constant.
by comparison notice how this right click menu displays more tools notyetactive tools in addition to activeones .afterthetextselectionis made theeditordrawsanorangebox as withdeucewidgets to identify the selection.
d cursor select single argument right click menu.
for atomic code items i.e.constants and variables the user implicitly selects theitembyright clickingonthetoken ratherthantext selectingit totriggertheright clickmenu asininteractionc.again asimilar workflow is provided by eclipse.
tool configuration panels.
each of the four interactions above trigger toolconfiguration panels which display therequirements string that explains howtoinvokethetool.theuserselects any additional arguments by hovering over and clicking structural selection widgets.
that is structural selection widgets are notaccessible to make the primary selection but they areused to makeallremainingselectionsinatool configuration panel.
the screenshotabove shows the configuration panel after text selecting a s above and then selecting 80and a target position using structural selection.becausethetoolrequirementsaresatisfied thepaneldisplays the list of results each of which can be hovered to preview the change before selecting it.deucemode box selectmode .
thisconfiguration calledboxselect mode in the user study materials isolates the new deuce features.
to review the user holds down the shift key then hovers overandclicksoneormorestructuralcodeselectionwidgets.when atleastonewidgetisselected thepop uppreviewmenudisplays the list of activetools.
thereisnocodetoolsmenuatthetopoftheeditorinthismode even though the full version of our tool not used by participants inthestudy does thelistoftoolnamesanddescriptionsintool configurationpanels whichare notaccessiblein deucemode can help understand unfamiliar transformations.
combinedmode.
ourlastconfigurationcombinestraditionaland deuce modes with all interactions described above.
.
questions and procedures we sought to address several questions iseithermodemoreeffectivefor a completingtasks b rapid editing or c achieving more with fewer transforms?
is either mode preferred by users?
in which cases?
toanswerthesequestions wedesignedthefollowingirb approved controlleduserstudywith21undergraduateandgraduatestudents from the university of chicago.
we recruited users by sending emails to public mailing lists offering a monetary incentive of for participating in the two hour study.
prior experience with functional programming or sketch n sketch was not required.
each user attended an individual session and was given the option to use the laptop and mouse provided by us or their own devices.
theprimarycomponentsofthestudyincludedatutorialportion followedbyatasksportion.weconfiguredapared downversionof thesystemthatturnedoffall sketch n sketch featuresunrelated to the interactions being studied.
the tutorial and tasks were setup as a self guided progression of steps through the tool to be completed at the user s own pace.
in the description of the tutorial andtasksbelow allrandomchoicesweremadeindependentlyof other choices as well as across users.
our system logged user events to analyze the tutorial and tasks.
wealsorecordedvideooftheusersperformingthetasks formanual inspection in situations where the log information was insufficient or more difficult to process.
besides helping to get started and correctminorissuesunrelatedto deuce theuserstudyproctordid not answer any questions about deuceor the tasks.
to wrap up users answered questions about their programming background and experience using deuce in an exit survey.
tutorial.
the first part of the tutorial introduced ordinary textbased programming in little emphasizing that the syntax would not be too important for subsequent tasks.
themajorityofthetutorialintroducedthecodetoolsusingboth traditionaland deucemodes.thefirsttoolintroduced rename variable afamiliartooltomany wasexplainedusingallfiveinteractionmodes.butbecausethefourinteractionsintraditional mode are largely similar all subsequent tools introduced in the tutorial had only one set of instructions for traditional mode.
for all tools introduced a random choice was used to determine whether to explain traditional or deucemode first.
in total of the codetoolsinourimplementationweredemonstratedinthetutorial.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
deuce a lightweight user interface for structured editing icse may june gothenburg sweden table1 overviewofthefourhead to headandtwoopen endedtasks.
locisnon blanklinesofcodeinthestartingprogram.
name loc transforms example tool sequence with minimum number of transforms required one rectangle swap expressions move definition swap definitions two circles create function from definition reorder argumentsthree rectangles creating function by merging definitions rename four rings remove argument rename move definition add arguments four squares create function by merging definitions create function from arguments rename 5x lambda icon make equal with single variable 6x introduce variable rename to give a flavor of the tutorial example in is adapted from the steps that introduced the make equal tools.
in addition to toolspecific tutorial steps we also dedicated a step for more practice with target positions independent of a specific tool because the notion of target positions was likely to be unfamiliar.
tasks.afterthetutorial usersworkedonsix tasks eachadifferent programandalistofoneormoreeditstoperformusingcodetools.
for some tasks there were multiple different sequences of code tool invocations that could lead to the desired result.
the starting programsrangedfrom7to11linesofcodeandrequiredbetween 2and8toolinvocations atminimum tofinishthetasks.table1 outlinesthetasks.thetwocirclestaskwaspresentedasexample2 in .extendedtaskdescriptionscanbefoundinthesupplementary appendices .
before every task the participant was given a read only reading period to understand the program before seeing the list of edits toperform.toemulateareal worldscenariowheretheprogrammer knows what to accomplish but may not quite remember all thesteps thetaskdirectionswerewritteninamorenaturalstyle without direct reference to tool names for example move the ringdefinitioninside target insteadof invoke move definition on the ringdefinition with a target position inside target.
eachofthefirstfourtasks head to headtasks wasperformed twice once each in traditional and deucemodes resulting in eighttrials.thefirstfourtrialscomprisedeachofthefourtasks in randomorderandwithoneofthemodesrandomlychosenpertrial.
forthenextfourtrials theorderoftaskswas again randomized each using the mode not chosen for the task in the first round.
after these eight trials the user performed each of the last two tasks open endedtasks onceusingthecombinedmode both traditionaland deucemodeswereavailableforuse tomix andmatch the two modes however they saw fit.
for each task comments showed what the desired final code should look like sometimes modulo minor whitespace differences.
the editor provided an indicator about whether the task was completed givingtheusertheoptiontogiveupatanypointifneeded.
there was also a maximum time limit of six and twelve minutes foreachhead to headandopen endedtask respectively withno indication about the time limit until and unless the user reached the two and four minutes remaining mark respectively.
.
results participants reported between and yearsof programming experience mean .
ofwhichbetween0and3yearsinvolvedfunctional programming mean .
.
participants reportedno prior functional programming experience.
participants reportedusingtoolsthatsupportedautomatedrefactoring eclipse intellij and pycharm all received multiple mentions .
partici pants reported some prior exposure to previous versions of the sketch n sketch project but none reported knowledge of the code tools presented in the study.
forthestudyitself 8usersbroughttheirownlaptop theremaining13usedours.15participantsusedamouse and6reliedontheir laptop strackpad.eachsessiontookameanof1hr44min range 1h 11m 2h27m .
usersspent between23 and66 minuteson the tutorial mean and20and65minutesonthetasks mean .
the remaining time was spent on introductory remarks and the exitsurvey.allusersattemptedalltasks.twotrialswerediscarded because of tool malfunction for a final total of head to head trials and open ended tasks suitable for analysis.
the tasks proved moderatelydifficult.
on average each participant successfully completed of the trials and open ended tasks within the time limits with users completing them all and user failing to completeany.
figure4 shows completion rates by task.
the one rectangle and lambda tasks had particularly low completionrates.basedonvideosoffailedattempts manyusersstruggled with choosing appropriate tools e.g.many chose introduce variablesrather than make equal and some chose inlinerather than movedefinitions inanattempttocreateatupledefinition.thetutorialwasnotsufficientforeveryonetorememberandunderstandall the tools needed for the tasks.
the task descriptions may have also presented obstacles e.g.for lambda the phrase define and use... along with def ... in the final code may have led some to use introduce variables which would then require several roundabout transformations to complete the task.
we believe these difficulties are largely independent of the user interface features.
we now address each of the research questions in turn.
is either mode more effective for completing tasks?.
figure breaks down completion rates for head to head tasks by mode.
be cause each was attempted twice to assess possible learning effects from already completing a task in the other mode figure alsodifferentiates between the user s first or second encounter with each task.
visually the data suggest that on the first encounter with a task traditional mode may better facilitate completion and isalsoabetterteacherforthesubsequentencounterwith deuce mode.
in contrast a first encounter with deucemode may be less helpful for the second encounter with traditional mode.
to control for learning effects a mixed effects logistic regressionmodel wasfitwith lme4 batesetal .
topredicttaskcompletionprobabilitybaseduponfixedeffect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden brian hempel justin lubin grace lu and ravi chugh 1rect 2circles 3rects 4rings 4squares lambda0 completion rate46.
.
.
.
.
.
figure task completion rates pooled over both modes.
1rect 2circles 3rects 4rings overall0 completion rate 12traditional deuce figure head to head task completion rates by mode and bysubject sfirst secondencounterwithtask.overlaidlinesindicated pooled completion rates.
predictors for the mode coded as or the trial number whetherthetrialwasthesecondencounterwiththetask 0or1 whether the participant used a mouse or whether the participant used their own computer or and the interaction of mode withthesecondencounter or1when deucemodeandasecond encounter .
to model differences inuser skill and task difficulty a randomeffectwasaddedforeachparticipantaswellaseachtask and a random interaction was added to model differences in the secondencounterdifficultypertask.reportedp valuesarebased on wald z statistics.
in the fit model the coefficient for mode was on the edge of significance p .
indicating that traditional mode did better facilitate task completion on the first encounter with a task.
given this deucemodeperformedbetterthanexpectedonthesecond encounter interactiontermp .
butnotenoughtoconfidently say thatdeucemode was absolutely better than traditional mode forthesecondencounter p .
.nootherfixedeffectcoefficients approached significance.
deucemode therefore seems to present a learning curve but may be just as effective as traditional mode once that learning curve is overcome.
this interpretation accords with the surveys participants wrote that traditional mode might be better for learning and participants including of the previous said deuce modewasbetterwhentheyknewthedesiredtransformation.how ever thedatamaybealternativelyexplainedif deucemodeonthe firstencounterisapoorteacher activelymisleadingusersonthe second encounter with traditional mode.
is either mode more effective for rapid editing?
among trials successfully completed the duration of each trial was measured from the start of configuration of the first refactoring to the end of the final refactoring.
the distribution of these timings is presented in figure scaled relative to the mean duration for each task.1rect 2circles 3rects 4rings overall01234rel time vs task mean 12traditional deuce figure head to head taskdurations for successfullycompleted trials scaled relative to the mean time per task.
again to tease out if any of these differences are significant from the same predictors described above two linear mixed effects modelswerefittopredict trialdurationand thelogarithm of trial duration i.e.considering effects to be multiplicative rather than additive .
percentile bootstrap p values for the fixed effect coefficientswerecalculatedfrom10 000parametricsimulate refit samples.1for the first encounter with a task traditional mode wasinsignificantlyfaster by13seconds p .
or9.
p .
.
however deucemode was on average seconds p .
or p .
faster for the second encounter with a task suggesting thatdeucemodemaybefasteronceusersbecomefamiliarwith the available tools.
most of the gain comes from less time spent inconfiguration after discountingallidle thinkingtimebetween configurations the model still reveals an second difference.
is either mode more effective for achieving more with fewer transforms?
todetermineifeithermodefacilitatedmoreefficient use of interactions the same mixed effects model was fit to predict the number of refactorings invoked during each successful trial as well as the number of undos.
on the first encounter with a task traditionalmodeaccountedforanaverageof2.0fewerrefactorings p .
and2.1fewerundos p .
butonthesecondencounter nosignificantdifferenceinnumberofrefactoringsorundoswas indicated.as asecondencounterwith deucemodeis fasterthan traditionalmode the speedgainthus appearstobeexplainedby faster invocations rather than fewer invocations.
is either mode preferred by users?
in which cases?
the two finalopen endedtasksallowedparticipantstomix and matchthe twomodesastheypleased.asshowninfigure7 onbothtasksthe overwhelming number of users performed a greater share of refactoringsusing deucemode.webelieveamainadvantageof deuce modeisthatitsimplifiestheconfigurationofrefactoringsthatrequire multiple arguments as the user may select all the arguments togetherbeforechoosingatransformationfromashortmenu.in traditional mode the workflow is stuttered the user must select a singleargument right clicktochooseatransformation thenselect theremainingarguments.however forarefactoringrequiringonly a single argument traditional mode is more streamlined a usermay simply select the desired transformation immediately afterright clicking on the first argument.
thus for single argumentrefactorings deucemode s advantages may be limited.
a breakdownofmodeusagebypopulartools figure8 lendssupportto 1see authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
deuce a lightweight user interface for structured editing icse may june gothenburg sweden t d 4squares051015 participants t d lambdat d overall figure7 distributionofuserpreferencesfortraditionalvs.
deuce modes as measured by the ratio of refactorings per formed by the user in each mode on the open ended tasks.far left represents all traditional mode refactorings far right indicates all deuce mode refactorings.
the con fidence interval for the mean preference across all users isindicated via percentile bootstrapping samples .
mean proportion of user s refactoringsrename make equal with single variable introduce variable s add argument s create function from arguments move definition s inline definition s create function by merging definitions create function from definitiontraditional deuce figure8 modeusagefortoolsusedbyatleasthalfofpartici pantsontheopen endedtasks.deucemodeispreferredformost tools.
stars indicate differences significant at the level via percentile bootstrapping samples .
this hypothesis.
for the most commonly used tool rename which always takes only a single argument participants used traditional anddeucemodeswithroughlyevenfrequency.mostothertools showed strong preferences towards deucemode with the notable exception of create function by merging definitions .
because the foursquarestaskrequiredinvokingthistoolwithfourexpressions according to the hypothesis users should prefer deucemode.
the videos revealed that several users were unable to discover how tostructurallyselectafunctioncall whichrequiredhoveringon the open parenthesis not demonstrated in the tutorial .
several of these users were however able to invoke the tool by text selecting a function call or by starting from the full code tools menu.
subjectively theconcludingsurveyaskedwhether deuceortraditional mode worked better for each head to head task measured on a point scale from text select mode worked much better to box selectmodeworkedmuchbetter .foreachparticipant a randomchoicedeterminedwhichmodeappearedateachendofthescale.asshowninfigure9 onaverageasimilarmodestpreference for deuce mode was expressed for each task.t d 1rect051015 responses t d 2circlest d 3rectst d 4ringst d overall figure surveyed subjective preference for traditional vs.deuce modes for the head to head tasks.
the confi dence interval for the mean preference across all users isindicated via percentile bootstrapping samples .
on the free response portion of the survey several explanations weregivenforthispreferencefor deucemode.3participantsappreciated the ability to select multiple arguments other participants appreciated selecting all arguments before selecting a tool other participant appreciated the smaller menu of refactorings and otherparticipantappreciatedtheeaseofstartingarefactoringby clicking code objects rather than having to create a text selection.
altogether usersdemonstratedastrongobjectiveandmodest subjectivepreferencefor deuceovertraditionalmode suggesting thatdeuceaccomplishesitsgoaltoprovideamorehuman friendly interface to identify configure and invoke refactorings.
limitations.
there are several threats to the validity of our experimental setup.
one is that our emulation of traditional features mayhavebeenlesseffectivethanthosefeaturesinexistingtools.
another is that the participants may have felt compelled to use deucemode which could likely have been deduced to be more novel than traditional mode more during the open ended tasks andpronounceapreferenceforitinthesurvey becausetheparticipantsweredrawnfromthesameacademiccommunityasthe authors.anotheristhatparticipantsusedthetoolinheterogeneous environments different computers and browsers configured with differentscreensizesandmousesettings.performanceonthetasks may have also been affected by the presence of the user study proctor and video recording device.
according to self reported assessments participants were relatively unfamiliar with functional programming andwith refactoring tools sothe results maydiffer for users with more extensive experience.
finally our results were obtained on small programs and tasks in a prototype language.future improvements.
there are opportunities to improve our implementation of deuce.
first to reduce the learning curve it wouldbeworthaddingmoreexplanatoryfeatures e.g.inatutorial orwithinthetoolwhentheuserselectscertainkindsofitemsfor thefirsttime particularlyforunfamiliartransformations e.g.move definitions and for unfamiliar user interface features i.e.target positions .enablingthefullcodetoolsmenumayalsohelpbecause ofthedescriptionsofrequirementsinthetoolconfigurationpanels cf.the deucemode discussion .also to alloweasy corrections ofmisconfiguredrefactorings itwouldhelpifundorestoredthe previousselectionstateratherthanjustthepreviousversionofthe code we have since implemented this feature.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden brian hempel justin lubin grace lu and ravi chugh related work wedescribethemostcloselyrelatedideasinstructurededitingand refactoring.
ko and myers lee et al .
and omar et al .
provide more thorough introductions.
.
user interfaces for structured editing compared to traditional text selection and menus several alternativeuserinterfacefeatureshavebeenproposedtointegratestructured editing more seamlessly within the text editing workflow.
text selection.
murphy hill and black identify that text selection based refactoring is prone to error particularly for statementsthatspanmultiplelinesandthathaveirregularformatting.
they propose two prototype user interface mechanisms called selectionassistandboxview tohelp.withselectionassist theuser positions the cursor at the start of a statement and the entire statement is highlighted green to show what must be selected using normal text selection .
with box view the editor draws a separate panel next to the code editor that shows the tree structure of theprogramwithnestedboxes.whenselectingtextintheeditor the nested boxes are colored according to which code items are completelyselected.similarly theusercanselectanestedboxin the box view to select the corresponding text in the code.
in contrast our structural selection polygons are drawn directly atopthecode atoncehelpingtoidentify likeboxview andselect likeselectionassist whichaimstomitigatethecontextswitching overhead of box view identified by murphy hill and black .
drag and droprefactoring.
leeetal.
proposeatoolcalled dndrefactoring that eliminates the use of menus altogether.
they demonstrate how many common eclipse refactorings can beunambiguouslyinvokedwithadrag and dropgesturewithout the need for any additional configuration.
this is a compelling workflow for situations in which the user can a readily identify an intended refactoring based on a preconceived notion e.g.its name b unambiguously invokethe intended refactoring by a single source single target drag and dropgesture and c accept thedefault configuration of the refactoring.
it would be useful to add drag and drop gestures to deucefor transformations that satisfythesethreeconditions.however ouruserinterfacesupports situations when one or more of these three conditions fails to hold.
hybrid editors.
compared to fully structured editors several hybrid editor approaches augment text based programs with additional information.
barista is a hybrid java editorwhere structureviews canbeimplementedtopresentalternaterepresentationsofstructuralitemsinsteadoftext.forexample an arithmetic expression may be rendered with mathematical symbols a method may be accompanied by interactive documentation with input output examples and structures may be selectively collapsed expanded orzoomed.omaretal .
introduceasimilar notion to structure views called palettes where custom displays can be incorporated based on the type of a subexpression.
forexample a color palette can provide visual previews of different candidatecolor values anda regularexpressionpalette canshow input output examples for different candidate regular expressions.
in greenfoot program text is separated into structuralregionscalled frames whicharecreatedandmanipulatedwith text andmouse based operations that are orthogonalto the text editswithinaframe.codebubbles allows text fragments to be organized into working sets which are collections of code documentation and notes from multiple files that canbeorganizedinaflexibleway.outsideoftheviews palettes frames and working sets in the above hybrid editors the user has access to normal text editing tools.
our approach is complementary to all of the above in places where code fragments regardless of their granularity and their relationship to alternative or additional pieces of information are representedinplaintext weaimforalightweightuserinterfaceto structurally manipulate it.
refactoring with synthesis.
in contrast to direct manipulation indndrefactoring anddeuce raychev et al .
propose a workflow where the user starts a refactoring with text edits providing some of the changes after the refactoring and then asks the tool to synthesize a sequence of refactorings that complete the task.thistext basedinterfaceandthemouse basedinterfacesof dndrefactoring and deuce are complementary.
.
program transformations automated support for refactoring fowler griswold roberts et al .
has been aimed primarily at programs written in class based object oriented languages.refactoring for functional languages.
hare brown li thompson and li is a refactoring tool for functional languages such as haskell where features including first class functions i.e.lambdas local bindings tuples algebraic datatypes and type polymorphism lead to editing tasks that are different fromthosesupportedinmosttypicalrefactoringtoolsforobjectoriented programs.
our user interface could be incorporated by hareto expose the supported transformations with lightweight direct manipulation.
hareprovides a larger catalog of transformations than our current implementation of deuce.
however the detailsofour movedefinitions andmakeequal transformationsare to the best of our knowledge not found in existing tools.
conclusion basedonourexperienceandtheresultsofouruserstudy webelievedeucerepresents a proof of concept for how to achieve a lightweight integrated combination of text and structured editing.infuturework ourdesignmaybeadaptedandimplementedforfullfeatured programming languages and development environments incorporating additionalwell known transformations e.g.fowler thompson and li .
additional direct code manipulation gestures aswell as incremental parsing e.g.
the algorithm of wagner and graham used by barista could further help streamline and augment support for structured editing within an unrestricted text editing workflow.