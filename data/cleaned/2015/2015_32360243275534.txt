modeling and testing a family of surgical robots an experience report niloofar mansoor dept of computer science engineering university of nebraska lincoln lincoln ne nmansoor cse.unl.edujonathan a. saddler dept of computer science engineering university of nebraska lincoln lincoln ne jsaddle cse.unl.edubruno silva dept of computer science engineering university of nebraska lincoln lincoln ne bsilva cse.unl.edu hamid bagheri dept of computer science engineering university of nebraska lincoln lincoln ne hbagheri cse.unl.edumyra b. cohen dept of computer science engineering university of nebraska lincoln lincoln ne myra cse.unl.edushane farritor dept of mechanical materials engineering university of nebraska lincoln lincoln ne sfarritor unl.edu abstract safety critical applications often use dependability cases to validate that specified properties are invariant or to demonstrate a counter example showing how that property might be violated.
however most dependability cases are written with a single product in mind.
at the same time software product lines families of related software products have been studied with the goal of modeling variability and commonality and building family based techniques for both analysis and testing.
however there has been little work on building an end to end dependability case for a software product line where a property is modeled a counter example is found and then validated as a true positive via testing and none that we know of in an emerging safety critical domain that of robotic surgery.
in this paper we study a family of surgical robots that combine hardware and software and are highly configurable representing over unique robots.
at the same time they are considered safety critical and should have associated dependability cases.
we perform a case study to understand how we can bring together lightweight formal analysis feature modeling and testing to provide an end to end pipeline to find potential violations of important safety properties.
in the process we learned that there are some interesting and open challenges for the research community which if solved will lead towards more dependable safety critical cyber physical systems.
ccs concepts software and its engineering software defect analysis formal software verification model driven software engineering the first two authors contributed equally to this work.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
software product lines alloy testing and analysis cyber physical systems acm reference format niloofar mansoor jonathan a. saddler bruno silva hamid bagheri myra b. cohen and shane farritor.
.
modeling and testing a family of surgical robots an experience report.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
https introduction modern surgery is moving towards the cyber physical using robots controlled by surgeons from a console.
these systems have tightly interwoven hardware software controls with the hardware impacting which software is selected and the software constraining the limits of the hardware.
these robots can be configured in multiple ways for different types of surgeries and can use different physical and virtual components.
for instance they can perform dissections cautery or sew an entry wound closed.
they can be used for general cardiac and or gynecologic surgeries and on different types of patients.
in essence such systems can be viewed as a family of robots i.e.
a software product line leading to hundreds if not thousands of possible configurations that may be used by a surgeon to satisfy his or her personal preferences.
yet these systems are also safety critical and if they do not interact in a reliable and safe manner with the end user the surgeon this can lead to potentially severe consequences.
current approaches to assuring safety critical systems include using model based techniques formal methods architecture based safety analysis and techniques based on real world types and type checking .
the majority of these approaches however are subject to a common limitation they are intended to ensure safety in a single system but fail to be cognizant of the commonality and variability in the system i.e.
ensuring the dependability of a highly configurable safety critical cyber physical system.
other research has examined testing cyber physical product lines however that work does not address the safety critical esec fse november lake buena vista fl usa mansoor saddler silva bagheri cohen farritor figure system components involved in arm movement.
aspects of the system.
there has also been research on test generation for product lines using lightweight formal analyzers such as alloy however this thread of work again does not address safety critical properties of the system.
last proctor et al.
proposed an architecture description language extension for aadl for connected medical devices.
this can reason about medical apps in general however it does not directly provide support for our use case dependability cases for families of safety critical devices such as surgical robots.
in this paper we set out to understand the challenges and feasibility of assuring the safety of cyber physical product lines.
we use an open source highly configurable research prototype for a miniature surgical robot that formed the foundations for a commercialized product in a proprietary format currently under fda approval.
with its open source software this family of surgical robot systems provides a valuable learning playground for us to explore.
motivated by the surgical robot family we present an approach to ensuring the safety of a system family by constructing both feature and formal models and performing an automated analysis of the models followed by a guided yet narrowly scoped testing phase on concrete family instances.
two essential elements that distinguish our approach from prior efforts at safety analysis are as follows family level reasoning by identifying commonality and variability in the system and explicitly modeling them in analyzable specification languages we are able to perform family wide reasoning that would be difficult to achieve using static analysis or testing.
for example our analysis can explore all possible systems in which a particular type of robot arm is being installed and check whether the use of that robot arm along with any other software hardware components can lead to a violation of a safety property.
guided testing on concrete instances while rigorous and exhaustive analyses of a formal yet abstract model of the system family can help pinpoint potential property violations one more step is needed to confirm the identified violations are indeed realistic.
in particular we support the formal analysis with targeted testing of the concrete system to verify whether the identified property violation can result in practical issues.
the counter examples produced by the formal reasoning are leveraged at this step to guide the testing on concrete family instances.
the contributions of this work are an end to end case study to validate an important physical property for a family of surgical robots demonstration of a potential synergy betweena lightweight formal approach and feature modeling techniques for a safety analysis of a family of a surgical robots a set of lessons learned and discussion of future directions for assuring cyber physical product lines.
in the next section we present the family of robots followed by our dependability case section .
we then discuss our findings in section and end with conclusions and future work.
overview of the surgical robots family the advanced surgical technologies laboratory at the university of nebraska lincoln unl is one of only a handful of institutes in the world developing in vivo surgical devices.
the latest developments include miniature in vivo surgical robots for use in robotic laparo endoscopic single site r less surgery procedures .
these miniature surgical robots are small do not need a dedicated customized surgical suite or infrastructure have reusable disposable tools that are familiar to surgeons and can be operated locally or remotely from a small console that includes haptic feedback and a screen that virtualizes robotic positioning.
the robots that have been developed include multiple modules and plugins for different types of hardware control.
this includes different robot arms some of which have haptic feedback and some that do not.
different solvers control the physical movements of the arms tool position tracking simulation video voice communication etc.
the source code that controls the physical aspects of the robot includes both a physical and simulation environment.
it is written in c and is available as open source .
we show the overall architecture of the robot system in figure .
physical components the primary device that is given to the surgeons to control the robot arm movements is a geomagic touch device .
there can be either one or two of these devices depending on the number of robot arms.
touch is a motorized device that applies force feedback to the user s hand allowing the surgeon to feel virtual objects and producing true to life touch sensations as the user manipulates the 3d objects on the screen .
the programmable pedals are assigned to clutch and home position functions to enable disable these functions in the control software.
the robot arm is the other physical component of the system which has a number of motor controllers to which the software layer sends serial data to move the robotic arm.
each robot arm can have a number of joints and each joint has an angle limit.
each robot arm is also connected to an end effector that can perform 786modeling and testing a family of surgical robots an experience report esec fse november lake buena vista fl usa physical robotsalloy modelfeature modelcounter examples software layerset of products simulationphysicaltestingfm sliceinformstatic analysisreverse engineerbounded verificationtest case generation figure overview of our process a specific task in surgery such as shears for cutting or a cautery hook for use after cutting.
software components the geomagic touch software component provides a connection between the physical geomagic touch device and the software system.
the system receives its coordinates from the geomagic touch endpoint and sends the coordinates to other components.
the kinematics software component contains a set of kinematic models which are specific to the hardware being used i.e.
the arm .
they use inverse kinematic solvers for different arms of the robots.
the solvers receive the coordinates from the robotapp component and calculate the joint angles for each joint of the robot arm and send them back to the robotapp component.
the robotapp component which contains a set of plugins employs the model view view model pattern.
the use of this pattern facilitates the separation of the development of the graphical layout of the user interface from the development for the back end logic of the application.
a set of plugins are loaded when the software is used so that the robotic arms can be controlled.
the other components also interact with a set of plugins.
for instance the geomagic touch software component interacts with thegeomagictouch plugin which facilitates sending the coordinates to the other plugins such as a solver plugin.
a solver plugin sends the coordinates to the correct solver for a chosen robot arm while receiving the joint angles from the kinematics component.
there are also other plugins in the system that manipulate the input in other different ways.
some of the plugins are necessary such as clutch and homeposition and some of them are only loaded for specific states or actions such as grasperlimits .
the robot control component is used to abstract a specific set of motors control modules and robot specific parameters.
it handles control and data services to discover control configure and read motor control modules.
the communication component provides a mechanism that facilitates the robot computer communication supporting serial communication and sending the robot commands as serial data to the robot.
building a dependability case we set out to build a dependability case for the family of robots with the aim of understanding the feasibility and challenges.
we selected a critical property of one specific safety feature of the robot that is important in practice.
it is a property that ensures the safety of the patient by guaranteeing the surgeon is always aware of the position of the arm within the patient.
if violated the implications are twofold.
first it means that the arm may extend into unsafe regions of the patient cavity.
second if the arm is extended to its maximum position and torque continues this couldpotentially lead to a hardware failure.
we do not specify the manner in which the surgeon is notified i.e.
via haptic feedback or via visual messaging .
more specifically the property being enforced is arm movement safety property during the surgery procedure as the surgeon moves the control device the actual position of the robot arm should be the same position that the surgeon articulates in the control workspace and he she should be notified if the arm is pushed outside of its physical range.
this property is enforced by a robot controller system consisting of hardware and software components which monitors and drives the system s physical components.
our dependability case spans the controller system as well as the physical modules involved in the arm movement.
.
process figure shows an overview of the process that we used to build our dependability case.
we incorporate both a lightweight formal analysis using alloy.
at the same time we reverse engineered a feature model and superimposed these two together to identify sets of products that potentially violate the specified property.
we then applied testing using the simulator we did not implement physical hardware testing at this stage to validate the counter examples found using the alloy models.
the last step would be to instantiate and validate these test cases on the physical system.
we leave that as future work.
alloy models.
we now describe a formal model for the surgical robots family in alloy a lightweight formal specification language based on a first order relational logic with an analysis engine that performs bounded verification of models.
there are three main reasons that motivate our choice of alloy for this study.
first its flexible core backed with logical and relational operators makes alloy an appropriate language for declarative specification of systems and properties to be checked i.e.
assertions .
second its effective module system allows us to split the overall complicated family model among several tractable modules.
such a well structured module system not only facilitates modeling and integrating different aspects of the system but also enables compositional analysis of the system components.
third its backend analysis engine i.e.
the alloy analyzer provides an automated analysis for checking assertions and generating counter examples.
to carry out the analysis we start by defining a common alloy module that models the fundamentals for the family of surgical robots and the constraints that every family instance must obey.
technically speaking this module can be considered as a meta model for the family of surgical robots.
listing partially outlines the meta model module.
the complete version of all alloy models that appear in this paper are available at the project website .
the essential element types are defined as top level alloy 787esec fse november lake buena vista fl usa mansoor saddler silva bagheri cohen farritor 1abstract sig geomagictouch i n p u t one coordinate f o r c e hapticfeedback 5abstract sig robotapp i n c l u d e s some p l u g i n 8abstract sig r o b o t c o n t r o l o u t p u t set armangle abstract sig s o l v e r f a m i l y c a l l s one kinematicmodel abstract sig kinematicmodel s o l v e r r e s u l t c o o r d i n a t e armangle abstract sig armangle abstract sig c o o r d i n a t e abstract sig armtype a n g l e l i m i t set armangle set of a l l the arm angles that are l e s s than limit i n v e r s e k s o l v e r one kinematicmodel abstract sig robotarm armside one side armmodel one armtype e f f e c t o r t y p e one e f f e c t o r t y p e outputs should be in the range of solverresult f a c t o u t p u t c o n s t r a i n t a l l o r o b o t c o n t r o l .
o u t p u t one a getarmangle kinematicmodel c o o r d i n a t e o a return the angles produced from a s p e c i f i c coordinate fun getarmangle one armangle s .
s o l v e r r e s u l t for each coordinate there e x i s t s a set of angle in the solver r e s u l t f a c t a n g l e c a l c u l a t i o n a l l c c o o r d i n a t e some a armangle s kinematicmodel c a ins .
s o l v e r r e s u l t listing excerpts from an alloy specification for the family of surgical robots.
signatures geomagictouch solverfamily robotcontrol kinematicmodel armangle coordinate armtype robotarm .
note that these signatures are defined as abstract meaning that they cannot have an instance object without explicitly extending them.
containment relations e.g.
between geomagictouch and coordinate are defined as alloy relations.
the fact outputconstraint specifies that the robotcontrol output armangle s should be produced by a solver in the system and the fact anglecalculation specifies that the solver transforms each coordinate to a set of arm angles.
to create individual family instances we extract information about each specific system and extend its corresponding element type in the meta model.
we then state the property that the model is expected to satisfy as an alloy assertion.
this property is formally specified as alloy assertion armanglecorrect in listing .
predicate producedfeedback describes when the force should be produced and when the hapticfeedback should be enabled.
the assertion then relies on theproducedfeedback predicate to state that all the output angles produced by the solver fall into the set of angle limits.
the alloy analyzer then explores all possible behaviors of the system and identifies a counter example if any that corresponds to a violation of the assertion.
the analysis is exhaustive but bounded up to a user specified scope on the size of the element types.1pred producefeedback o u t p u t r o b o t c o n t r o l .
o u t p u t o u t p u t not in armtype .
a n g l e l i m i t some n o t i f i c a t i o n geomagictouch .
f o r c e n o t i f i c a t i o n h a p t i c s e n a b l e d a s s e r t i f the arm angle i s in the set of armangle limit 6a s s e r t armanglecorrect 7a l l a r o b o t c o n t r o l .
o u t p u t a not in armtype .
a n g l e l i m i t i m p l i e s producefeedback listing assertion on the arm movement safety property.
feature models.
we conducted a series of interviews with the robot developers focusing on retrieving domain knowledge.
we lacked documentation on how the family was constructed.
therefore we needed to understand the necessary and optional components of each robot extract constraints and dependencies and map this to features.
we used featureide as our tool for creating the final model which allowed us to reason about slices of the product line .
from interviews we learned the robot is to be a combination of two sets of configurable hardware components namely arm types and effectors on the ends and configurable software components.
the software components are collectively called plugins an array of plug and play configurable elements that can be used interchangeably to drive all arm types and effectors in specific ways.
we describe our findings in more details in the next section.
testing.
our approach for testing the surgical software relies on microsoft codedui plugin a tool for testing user interfaces.
it is capable of generating test cases based on manual interactions with the gui.
it can replay the tests though it is not able to reverse engineer the interface to create a model of the system.
codedui generates test cases automatically but the generated code is tightly coupled and if modifications are made they will be discarded after building the project.
therefore there is a need to extract the most relevant pieces of code such as how to navigate between interfaces the input values and to verify assertions.
we have extracted the code generated by codedui into an auxiliary class and refactored it creating a class encapsulating the most important functionality of a test case which is then used as a template.
individual robot classes can call this class and it will perform the following steps load configuration go to solver plugin and select arm type go to the controller and input values to move the arm go to the solver and verify the output.
with all this information it is then possible to generate a replayable test case for individual robots as they will follow the same steps only varying in the solver type of robot arm and input values.
.
results we present our results and describe our challenges for each part of the process next.
finding alloy counter examples.
as we built the alloy model to search for a counter example we used guidance primarily from static analysis.
in order to cover the space of products of this robotic system we needed to develop different models for each different robotic arm.
this resulted in alloy models.
the necessary features for the alloy models include the arm type solver geomatic touch haptic feedback and two plugins created to manipulate inputs from geomagic touch named clutch andhomeposition .
each 788modeling and testing a family of surgical robots an experience report esec fse november lake buena vista fl usa figure feature model runtime configurations model actually represents different products from the robot family rather than a single robot.
however this fact was not obvious as we built the analysis.
since the undefined features were not part of the static analysis and did not contribute to the counter example they do not appear in the alloy model.
however we cannot be sure that the analysis is precise and leaving out some features may in fact mean that we have over or under approximated the existence of the counter examples see our discussion below in testing .
we did find a counter example for each of the models that did not include the haptic feedback feature.
the robots that do use haptic feedback do not lead to this counter example i.e.
the haptics feature of the system provides physical feedback to the surgeon anytime he or she tries to move the arm beyond its maximum range.
we next discuss the results of the feature modeling and its mapping back to these counter examples.
feature model.
figures and show the feature model that we developed from two different perspectives.
the full feature model is too large to show so we have elided some features in each figure.
our full feature model in an xml format can be found on our project website .
in total with cross tree constraints there are potential surgical robots supported by this system.
figure shows the high level features arm type effector load time configuration options runtime configuration plugins .
in this figure we focus on the runtime configuration plugins in particular we show the branch of the feature model that includes the haptic feedback last leaf on right .
figure shows the breakout for the armtype and effectors.
the arm type was further broken down during modeling because the developers pointed out that only arm types are currently in active use.
the other are physical arms that are no longer figure feature model armsused.
however since this distinction is based solely on domain knowledge and discussion with developers it is not reflected in the alloy models.
for the alloy models all arm types were modeled because the code is still active and discovered during static analysis.
the feature model also has multiple cross tree constraints not shown .
these were determined via both discussion with the developers and by studying the code and configuration panels as selections are made.
this was a challenging and iterative part of the process.
it turns out that there is a highly constrained hierarchy between the hardware and software.
each arm type uses a single solver and each arm type either has haptic feedback or not.
other constraints include physical limits of the graspers for instance.
most of these are hard coded into the software which means when any arm type is selected in featureide we immediately have a small slice of the product containing only of the products.
however there are still products that must be tested for each counter example if we are to confirm the existence of the faulty property.
we discuss this next.
testing.
five of the robot arms led to the counter example fivedofsolver fourdof needle frankenvrep sevendofsolver and tombot .
to validate that these are not exhibiting false positives we built concrete test cases for each and observed the output.
a failing test case shows that the arm location stays fixed at the same point once it is pushed out of range.
a correct behavior shows a negative value in simulation when this occurs.
we confirmed this by also testing the robots that did not exhibit the counter example.
our first problem for testing stemmed from the fact that each of the alloy configurations represents a set of robots robots .
we used the robot simulation mode for testing however the simulator does not capture some of the hardware components that lead to the larger number of robots.
for instance there are five different effectors that provide physical movements such as shearing cautery grasping etc.
these are related to the robot hand which sits below the arm and are not part of the simulator and do not impact the solver output which is needed for the counter example to change.
we therefore ignored the features that do not impact the arm extension and or impact whether or not the feedback is produced and tested only a single instance for each set of products.
this created a savings for us in terms of number of tests however the validity of this approach is dependent on the quality of our static analysis.
the features that we were not able to capture in our simulation include arm side left or right effector type different effectors and specific modules to move the hand which are related 789esec fse november lake buena vista fl usa mansoor saddler silva bagheri cohen farritor to the effectors clamp close expand open wrist rotate effector bend .
the behavior of grasper limit and scale plugins is not captured in our simulation of the system either as they do not affect the output angles of the robot arm.
for the five robots that we were able to simulate we selected a range of input values angles on the console.
as is common with configurable software the configuration layer is orthogonal to the input layer.
we did not have an automated generation tool.
we selected values from a range that we expected would push the robot beyond a valid extension point i.e.
we used domain knowledge to help us find the important boundary values .
using this approach we were able to confirm that the counter examples do exist and the robot can be pushed outside of its limit with no feedback returned.
as the robot goes out of range in the systems without haptic feedback the arm simply stops moving and records the same position over and over again once it reaches its limit.
interestingly one robot tombot printed a message to the debug console telling the developer that the arm was out of range.
theoretically this could be passed to the physician console but it is not propagated so this information is lost when the robot is used outside of the debugging environment.
lessons learned we present our lessons learned next.
architecture plays a large role and can help analysis.the way a system is designed and implemented has a significant impact in conducting a safety analysis.
while dependencies among the various robot software components and the external components made it challenging to get the software running and working its modular plug in based nature helped us achieve a clear understanding of the system and the event flow between various components which in turn facilitates the process of creating the dependability case.
developers should consider the family of products.
one of the challenges we faced in concretizing counter examples and validating them was the unavailability of the configuration files for the entire surgical robot family.
we only had access to the configurations for a small subset of robot instances that were currently being used by the engineers working with the system.
to check the property for the rest of the robotic arms we needed to create new configuration files which involved a tedious process of loading and validating each of necessary plugins for a particular arm.
we need methods to map feature models to alloy.
our two views of the family of robots alloy and feature models differed in their granularity and focus.
the feature model included both hardware and software and had some arbitrary divisions e.g.
the arm types where as the alloy model contained only the code based features that led to the counter example.
however together they tell the full story of our robot and its potential safety properties.
new methods are needed to merge these disparate models together.
conclusions and future work in this paper we presented an experience report working with a cyber physical safety critical software product line a roboticsurgery system.
we used both lightweight formal analysis and feature modeling to reason about a counter example that allows the arm to move outside of range without providing feedback and the variability across the product line.
we then applied testing to validate the counter examples discovered.
while our alloy models and feature models overlap they are extracted using two different approaches and hence differ in granularity.
this led us to synthesize several lessons learned and propose that researchers can use those to develop novel techniques for merging feature and alloy models for modularizing their architectures and for more easily discovering configurations for all necessary products.
future work includes expanding our properties adding more rigorous testing and building physical test platforms.
acknowledgement we thank l. cubrich for his help with domain knowledge and for providing us with an open source robotic surgery code base.
this work was supported in part by an nsf epscor first award a university of nebraska collaboration initiative seed grant and awards ccf ccf and ccf from the national science foundation.