experiences from designing and validating a software modernization transformation alexandru f. iosif laz ar it university of copenhagen afla itu.dk juha erik savolainen danfoss power electronics juhaerik.savolainen danfoss.comahmad salim al sibahi it university of copenhagen asal itu.dk krzysztof sierszecki danfoss power electronics ksi danfoss.comaleksandar s. dimovski it university of copenhagen adim itu.dk andrzej w asowski it university of copenhagen wasowski itu.dk abstract software modernization often involves complex code transformations that convert legacy code to new architectures or platforms while preserving the semantics of the original programs.
we present the lessons learnt from an industrial software modernization project of considerable size.
this includes collecting requirements for a code to model transformation designing and implementing the transformation algorithm and then validating correctness of this transformation for the code base at hand.
our transformation is implemented in the txl rewriting language and assumes specifically structured c code as input which it translates to a declarative configuration model.
the correctness criterion for the transformation is that the produced model admits the same configurations as the input code.
the transformation converts c functions specifying around a thousand configuration parameters.
we verify the correctness for each run individually using translation validation and symbolic execution.
the technique is formally specified and is applicable automatically for most of the code base.
keywords experience report functional equivalence program transformation symbolic execution.
i. i ntroduction the panelists of the ase conference listed the growing size and complexity of legacy code as one of the key challenges of the software industry.
software modernization is an important contender among the measures to address this challenge.
however relatively little literature is available about software modernization projects especially in the safety critical domain.
we present experiences from a research partnership around an industrial software modernization project between it university of copenhagen and danfoss power electronics1 a global producer of components and solutions for controlling electric motors driving various machinery.
this particular modernization project involves a configuration tool used to adapt danfoss frequency converters to a particular application.
the configuration tool consists of thousands of c functions for accessing and validating the configuration parameters.
the configurator code base is undergoing a modernization process where each parameter function must be converted from imperative c code to a declarative specification.
all the compute a result either the value of the parameter or a boolean value checking its accessibility and validity .
the declarative form of a function is an expression that must compute the same result as the original imperative code.
the code modernization is done automatically by applying a transformation implemented in the rule based transformation language txl on each function individually.
it performs a sequence of syntactic replacements gradually eliminating c preprocessor directives local variables c control statements and leaving behind a pure i.e.
side effect free expression.
the execution of a txl transformation can only catch trivial errors revealed by a syntactic analysis of the code enforcing constraints through pattern matching .
this does not guarantee that the semantics of the source program is preserved.
in the danfoss case determining the semantic equivalence is a decidable problem due to certain properties of the programs the execution always terminates the code fragments do not contain inline assembler code and they generally employ a small subset of c .
we assessed that symbolic execution is mature enough to handle this task efficiently.
we implemented a lightweight wrapper which compiles both the input and the output of the transformation and employs the symbolic executor klee to assert program equivalence.
klee produces a set of path conditions that represent distinct execution paths of the two programs along with their return values as symbolic formulas.
if it fails to establish the equivalence of the return values of any execution path then it outputs the path condition and a counter example.
our contributions are a synthesis of experiences from the design of a non trivial modernization transformation for a real project.
designing and implementing a transformation validation technique for this case study which produces counterexamples if two programs are not equivalent.
lessons learnt from using the validation technique in the case study including an analysis of the kind of errors that have been identified.
to the best of our knowledge this is the first analysis of transformation errors extracted from an industrial project of this scale and complexity functions or lines of input1configuration config selectedconfigparameter 2option opt selectedoptionparameter 3bool result false 4switch config case config1 if opt option1 result true break default result true break return result fig.
an example input program.
selectedconfigparameter config1 selectedoptionparameter option1 ?true false fig.
the output program after the transformation.
code of which error cases were found at transformation time error cases were found at verification time and were successfully verified .
ii.
e xample we illustrate our technique for modernizing a function and validating its correctness by using a simple example.
the example is a simplified and anonymized version of a real function from the danfoss code base.
the input program given in fig.
is a constraint enforcing function.
it checks that the input variables selectedconfigparameter and selectedoptionparameter have correct values with respect to each other and to some constants config1 and option1 .
we need to turn this program in a declarative constraint that must preserve the names of the input variables and must compute the same truth value as the imperative program.
syntactically the input program consists of a switch statement with two cases where one of them contains an inner if statement.
the program returns the value stored in the variable result .
the corresponding declarative c expression obtained by running the txl transformation is produced in several steps the switch statement is replaced with a nested ifelse conditional statement.
a series of simplifications are performed on the conditional statements so we end up with a straightforward control flow.
the conditional statement is finally reduced to a ternary expression of the form e1 ?
e2 e3 .
even for such a small example checking that the transformation has preserved the semantics of the input program is non trivial.
we use klee to symbolically execute both the input and transformed output program to obtain all possible symbolic execution paths.
then the input and output programs are compared for equivalence by checking whether there are1 selectedconfigparameter config1 ?
selectedoptionparameter option1 true fig.
the expected output.
corresponding matches between the obtained path conditions.
if there exists a path condition in one program for which no matching path condition is generated in the other then klee reports the corresponding path as a counter example i.e.
as a witness of an execution that is possible in one program but not in the other.
for example the path condition selectedconfigparmeter config selectedoptionparameter option1 result true is generated for the input program in fig.
1but not for the transformed program in fig.
which shows that these two programs are not semantically equivalent.
by investigating the counter example we are able to determine the expected output program shown in fig.
.
we were also able to trace the transformation rules that were applied to the input program and successfully diagnosed which rule produced erroneous output.
the erroneous rule was an if statement simplification rule which tried to simplify nested if statements correctly but forgot to take the else branch into consideration.
the verification technique was therefore very useful in accurately tracking the places in which bugs occur and an experienced transformation specialist would be able to fix this issue relatively swiftly.
iii.
r esearch methodology we followed the general framework of action research .
the study can also be seen as an exploratory case study whose objective is to establish the feasibility of solving a concrete industrial problem.
a. study description objective to establish the feasibility of transforming a large body of configuration code from an imperative implementation in c to a declarative model in a manner that is automatic trustworthy andcost effective .
the cost effectiveness is understood as being cheaper than reimplementing the code from scratch.
the study is exploratory as only the problem statement is known initially.
the researchers have access to the input c code and to three danfoss engineers architects knowledgeable about the code the context and the use case.
the study combines engineering transformation development and research designing semantically sound transformations and validating them .
the case has been initiated as a pilot project for larger modernization activities in the same organization.
the first study proposition is to establish that freely available transformation and validation tools are sufficiently mature to execute this modernization process.
the second study proposition of greater interest from a research point of view is to explain what kind of errors might appear in transformation projects involving complex code even if implemented by experienced model transformation developers and language specialists.
2the case the input code consists of c functions from a configuration application.
these functions encode dependencies visibility constraints and default values of approximately one thousand configuration parameters of a frequency converter.
the use of c as opposed to c is modest.
no object oriented aspects are used except for member access and limited encapsulation.
most functions have straightforward control flow without goto statements loops and recursion.
the most common statements are conditional branching and switch statements.
the rare forloops all have a constant number of iterations.
other constructs include variable declarations and usage of local variables in arithmetic and comparison expressions calls to pure functions for instance for converting physical units and casts between different types both c style casts and static cast s .
there are few