the ide as a scriptable information system dimitar asenov dept.
of computer science eth zurich switzerland dimitar.asenov inf.ethz.chpeter m ller dept.
of computer science eth zurich switzerland peter.mueller inf.ethz.chlukas vogel ergon informatik ag zurich switzerland lukas.vogel ergon.ch abstract software engineering is extremely information intensive.
every day developers work with source code version repositories issue trackers documentation web based and other information resources.
however three key aspects of information work lack good support i combining information from di erent sources ii exibly presenting collected information to enable easier comprehension and iii automatically acting on collected information for example to perform a refactoring.
poor support for these activities makes many common development tasks time consuming and error prone.
we propose an approach that directly addresses these three issues by integrating a exible query mechanism into the development environment.
our approach enables diverse ways to process and visualize information and can be extended via scripts.
we demonstrate how an implementation of the approach can be used to rapidly write queries that meet a wide range of information needs.
ccs concepts software and its engineering !integrated and visual development environments software maintenance tools information systems !information integration human centered computing !visualization keywords code queries software visualization refactoring .
introduction software development is an information intense activity.
while programming and designing software developers ask a wide variety of questions and seek information from numerous sources such as the source code itself analysis tools version control information issue trackers documentation project wiki pages and community resources.
in trying to meet their information needs developers are faced with three issues.first developers often need to combine information from more than one source but tool support for piecing information together is lacking .
for example in order to understand a performance regression it is useful to combine information from the source code code structure and control ow the version control system recent commits and changes to a ected code performance analysis tools runtime measurements and an issue tracker bugs associated with relevant commits .
in situations that require diverse information developers are forced to manually connect the di erent pieces of information which is an error prone and time consuming process.
such an information search is also tedious to re ne as this usually requires the developer to manually repeat a part of the process.
second tools most often present information in a xed form.
for example searching results in a list of matches querying a program with ferret results in a hierarchical tree view.
such one size ts all presentations are not always a good match for a developer s speci c information need but there is very little or no exibility for customizing the presentation in existing tools.
this could hinder the comprehension of the results and makes domain and project speci c visualizations impossible.
third even after a developer nds the information they need they often have to take action manually.
for example to understand how a set of methods are called one has to manually set breakpoints or insert print statements.
repeatedly performing an action manually is time consuming error prone and frustrating.
while some tools support automation e.g.
jungl and rascal for refactoring they cannot integrate arbitrary information sources and are usually limited to certain modi cations of source code.
to address these three issues we designed a query system that integrates directly with the integrated development environment ide .
we make the following contributions i an approach for querying information within an ide which enables the integration of diverse information resources exible result presentations extensibility via scripts and automated execution of actions.
ii an implementation of the approach in the open source envision ide .
iii an evaluation of the applicability of the system in a number of use cases with diverse information needs.
a video demonstrating our system can be seen at youtu.
be kyarkuuy9ra.
an extended version of this paper contains additional examples python scripts and details of our implementation.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
.
motivating examples we will introduce our approach on two practical examples.
.
investigating a regression suppose that a developer is investigating a recently reported regression where the incorrect behavior occurs after a speci c button is pressed.
the developer needs to know what code is executed in the button handler and what recent changes might a ect this code.
with current tools the developer will likely rst explore what code is being called from the button handler and manually correlate that to recent changes.
in particularly hard cases it might pay o to design a speci c test case for this regression and run a binary search on the version repository in order to nd the o ending commit e.g.
using git bisect .
both of these approaches are time consuming due to ine ective ways of combining source code information the call graph with version information what changed recently .
our approach o ers an alternative solution.
the developer can select the handler of the button in the source code bring up a query prompt and type callgraph nodes changes c nodes the callgraph query returns the nodes methods in the callee graph of the currently selected method.
the bug is likely among these methods but there may be many of them.
to narrow down the search the methods are piped into the changes query which returns only those methods from its input that have changed in the last ve commits.
after the query is executed the remaining methods will be highlighted helping the developer to more quickly nd the issue.
enabling this work ow are three key components of our approach i acontext sensitive query prompt that enables developers to type and combine queries ii diversequeries that can access arbitrary resources such as the source code or version repository and iii aunified data format that enables queries to be combined in order to re ne searches.
.
heatmap of code execution imagine that a developer wants to get a visual overview of the often executed parts of the code to gain a general understanding of which classes are relevant for performance.
thus it is preferable to see frequently executed methods in a broader context.
pro ling tools typically provide timing information in the form of a chart graph or a list.
however none of these presentations ts the developer s need in this example as the code around performance critical methods is also important.
this is one example where the presentation of information is critical for understanding and where our approach s support for exible visualizations can help.
the developer could for example export the timings to a csv le and use a query to import it into the ide and visualize the results importprofilecsv profile .csv heatmap the rst time they do this they will have to write the importprofilecsv python script about lines that reads the csv le into the data format understood by our system.
the data is piped into the heatmap query which highlights di erent parts of the code with a color in the red green spectrum based on the value of a number .
this example illustrates two more essential components of our approach iv integration with a scripting language carmodel lang java .
carmodel bufferedreader io java .
.
ioexception io java .
.
inputstreamreader io java .
.
main args string void throws ioexception line separator string getproperty system .
line.separator border char length int unref obj created int menu stringbuffer new stringbuffer car carmodel new carmodel create the menu append menu .
for i int i border char length i append append menu .
line separator .
simulate car usage append append menu .
line separator .
create unreferenced objects append append menu .
line separator .
q quit append menu .
line separator append menu .
for i int i border char length i display the menu println out system .
.
carmodel started line separator menu println out system .
.
tostring menu .
println out system .
.
choose an option in bufferedreader new bufferedreader new inputstreamreader in system .
input string trim readline in .
.
accept input for the desired option println err system .
.
wrong option input trim readline in .
.
continue input length input .
isdigit character .
charat input .
intvalue valueof integer .
input .
simulatecarusage car break new carmodel for i int i unref obj created i println out system .
.
unref obj created unreferenced objects of carmodel has been created break println err system .
.
wrong option input trim readline in .
.
for equalsignorecase input .
q carmodel wheel i new wheel for i int i i simulatecarusage car carmodel void rollup window left car .
.
.
start engine car .
.
rev engine car .
.
align wheel car .
.
stop engine car .
.
engine engine new engine wheel wheel new wheel door left new door door right new door engine bufferedreader io java .
.
ioexception io java .
.
inputstreamreader io java .
.
start void println out system .
.
start the car.
rev void println out system .
.
rev the engine.
stop void println out system .
.
car stopped.
wheel bufferedreader io java .
.
ioexception io java .
.
inputstreamreader io java .
.
align void println out system .
.
tires aligned.
window bufferedreader io java .
.
ioexception io java .
.
inputstreamreader io java .
.
rollup void println out system .
.
rollup the window.
rolldown void println out system .
.
rolldown the window.
door bufferedreader io java .
.
ioexception io java .
.
inputstreamreader io java .
.
open void println out system .
.
open close void println out system .
.
close window window new window figure a heatmap overlayed on top of a visual presentation of code showing a few classes and methods .
the heatmap is visualized as a set of translucent overlays on top of methods each overlay has a color in the spectrum between red and green indicating how often a method was executed.
similar visualizations are also possible in traditional text based ides e.g.
using line or le highlights.
allowing easy extension to new information resources and customized queries and v flexible visualizations which enable task speci c display of information helping comprehension.
.
approach our goal was to design a system that is highly expressive and extensible by the user in order to satisfy a wide range of information needs.
the architecture of our system is shown in fig.
.
below we discuss each component in detail.
.
query execution model the core of our approach is the ability to compose and execute queries .
this functionality is provided by the execution engine which enables queries to be connected in a network directed acyclic graph where the edges represent data ow.
such a network of queries is illustrated in fig.
.
each query has a context which is the ast node e.g.
a method on which the query was invoked.
a query has two additional ways to access information.
first a query may be connected to the output of other queries via any number of required or optional inputs which comprise the inter query data exchange .
for example a query might receive on its input a set of method ast nodes and output their names as a set of strings.
the data owing between queries uses a uni ed format see sec.
.
.
second a query may access that is read and modify external resources see sec.
.
.
such as the program s source code e.g.
to perform a refactoring call a method of the ide e.g.
to access the ast or show a message or use a rest service e.g.
to create a bug report .
a query is executed only after all of its inputs are read.
when a query is run it can perform arbitrary computation which typically includes accessing external resources and computing outputs.
once a query has nished executing its outputs are forwarded to any downstream queries.
445query prompt data exchangevisualizationnativequeries scripts execution enginefigure the architecture of our system.
using a query prompt a developer can invoke and combine queries.
queries can access diverse information resources make computations and produce visualizations and can be either native or implemented via scripts.
a uni ed data exchange format facilitates the cooperation between multiple queries.
an execution engine orchestrates query execution and the information ow between queries.
.
query types in principle a query can perform arbitrary computation.
however to facilitate composition we divide queries into three types resource access visualization andoperator .
below we de ne each type and explain how we designed corresponding queries in order to improve usability.
.
.
resource access resource access queries are used to read and modify resources external to the execution engine.
they connect a network of queries to the ast and external tools and data.
a resource access query can be a source of data for other queries.
for example a query may read the contents of a le and provide it as inputs to other queries for processing.
a resource access query may also modify external data .
for example it could create a new record in a database or modify the program.
there is no limit on what resources a query may access common ones are the program ast the version repository the issue tracker les and on line services.
to facilitate composability we designed resource access queries according to the following guidelines.
first a resourceaccess query provides access to only one resource.
this restriction allows accessing one resource without imposing requirements on another.
second complex resources are accessed by multiple queries which enables each query to focus on a particular aspect of the resource.
for example when reading the program s ast one query is used to select nodes while another provides controlow information.
third when integrating tools that have a command line interface we created queries with a similar interface.
this enables developers to transfer some of their existing knowledge from the terminal command to the query.
for example in a query that accesses a git repository commits can be speci ed by commit id branch name or reference like the gitcommand allows.
a noteworthy resource available through resource access queries is the ide itself.
a query may call available ide apis 1the git logo by jason long and icons made by freepik from www.
aticon.com are licensed by cc by .
.
inter query data exchangeexternal data access queryx i0 i1o0figure a query network with seven interconnected queries.
queryx is shown in detail.
it has two inputs i0 which is the union of two outputs from other queries and i1 which is unused here and one output o0 which is duplicated .
to get information or to perform ide functions.
for example most ides maintain a code model that provides easy access to the program s ast.
such queries are not limited to extracting information.
depending on available ide apis queries might be used for navigation between code fragments setting breakpoints running tests displaying warnings or errors and refactoring code.
.
.
visualization visualization queries are used to render information on the screen .
di erent visualization queries can be used to render the same piece of information in di erent ways in order to better match the speci c information needs of the developer.
for example we support three ways to visualize relations between code elements i show the relations using a textual notation useful for a dense summary ii highlight on screen all code elements that appear in the relations useful when searching for particular patterns iii show the relations using arrows between code elements useful when exploring call graphs or data ow.
some visualizations are provided by the underlying ide while others could be done via external tools.
common visualizations in ides are highlighting a program fragment showing a list or a tree of result entries and displaying error messages and warnings.
more visual ides could even provide a map of the code that enables intuitive arrow overlays to explore connections between elements or even a heatmap visualization similar to fig.
.
our approach imposes no limit on how information can be visualized.
if an ide exposes general drawing routines a query could use those to implement an entirely custom visualization.
some ides provide a built in html rendering engine which could be used to easily and quickly implement new ways for visualizing information.
using a combination of html5 and javascript it is even possible to create interactive visualizations as we demonstrate in sec.
.
.
this high degree of exibility is indispensable for domain and project speci c visualizations.
we designed visualization queries according to the following guidelines in order to make them easier to use.
first each available visualization mechanism has its own query which makes it clear what will appear on the screen when it is invoked.
second visualizations impose as few require446ments on the input data as possible so that one visualization can be easily swapped for another.
third if a visualization query is not explicitly provided but there is unconsumed data at the end of a query network execution a visualization is automatically chosen based on the structure of the result.
this frees developers from having to always explicitly specify a visualization that could be automatically inferred.
.
.
operator operator queries operators are used to perform internal computation for example to re ne results.
operators do not access any external resources but rather help filter and combine data in complex query networks.
they work solely with the uni ed data format which we discuss in sec.
.
.
as operators work with sets and relations they naturally map to operations from set and relational algebra such as union intersect select and join.
building on these primitives we have also pre de ned more elaborate operators in order to simplify common cases.
for example in sec.
.
we demonstrate the reachable operator which lters out elements unreachable from a starting point via a relation in essence a combination of transitive closure and selection.
such a convenience operator is very useful in answering reachability questions which are very common .
.
inter query data exchange to enable query composition all queries communicate using a simple uni ed structure for exchanging data.
this uni ed exchange structure is a set of tuples because it is su ciently expressive and provides a simple mental model for developers to work with.
each input and output of a query is a set of tuples and each tuple consists of an arbitrary number of named elements.
the names of elements within a single tuple have to be unique.
the elements of a tuple may be strings integers and