modular verification of interrupt driven software chungha sung university of southern california los angeles ca usamarkus kusano virginia tech blacksburg v a usachao wang university of southern california los angeles ca usa abstract interrupts have been widely used in safety critical computer systems to handle outside stimuli and interact with the hardware but reasoning about interrupt driven softwareremains a difficult task.
although a number of static verification techniques have been proposed for interrupt driven software they often rely on constructing a monolithic verification model.furthermore they do not precisely capture the complete ex ecution semantics of interrupts such as nested invocations ofinterrupt handlers.
to overcome these limitations we proposean abstract interpretation framework for static verification of interrupt driven software that first analyzes each interrupt han dler in isolation as if it were a sequential program and thenpropagates the result to other interrupt handlers.
this iterative process continues until results from all interrupt handlers reach afixed point.
since our method never constructs the global model it avoids the up front blowup in model construction that hampers existing non modular verification techniques.
we have evaluated our method on interrupt driven applications with a total of22 lines of code.
our results show the method is able toquickly and more accurately analyze the behavior of interrupts.
i. i ntroduction interrupts have been widely used in safety critical embedded computing systems information processing systems and mobile systems to interact with hardware and respond to outside stimuli in a timely manner.
however since interrupts may arrive non deterministically at any moment to preempt the normal computation they are difficult for developers to reason about.
the situation is further exacerbated by the fact that interrupts often have different priority levels high priority interrupts may preempt low priority interrupts but not vice versa and interrupt handlers may be executed in a nested fashion.
overall methods and tools for accurately modeling the semantics of interrupt driven software are still lacking.
broadly speaking existing techniques for analyzing interrupts fall into two categories.
the first category consists of techniques based on testing which rely on executingthe program under various interrupt invocation sequences.
since it is often practically infeasible to cover all combinationsof interrupt invocations testing will miss important bugs.
the second category consists of static verification techniques such as model checking whichrely on constructing and analyzing a formal model.
during the modeling process interrupt related behaviors such as preemption are considered.
unfortunately existing tools such as icbmc need to bound the execution depth to remain efficient which means shallow bugs can be detected quickly but these tools cannot prove the absence of bugs.
in this paper we propose a static verification tool geared toward proving the absence of bugs based on abstract interpretation .
the main advantage of abstract interpretation isthe sound approximation of complex constructs such as loops recursions and numerical computations.
however although abstract interpretation techniques have been successfully applied to sequential and multithreaded software they have not been able to precisely model the semantics of interrupt driven software.
at the high level interrupts share many similarities with threads e.g.
both interrupt handlers and thread routines may be regarded as sequential programs communicating with others via the shared memory.
however there are major differences in the way they interleave.
for example in most of the existing verification tools threads are allowed to freely preempt each other s execution.
in contrast interrupts often have variouslevels of priority high priority interrupts can preempt lowpriority interrupts but not vice versa.
furthermore interrupts with the same level of priority cannot preempt each other.
thus the behavior manifested by interrupts has to be viewed as a subset of the behavior manifested by threads.
to accurately analyze the behavior of interrupts we develop intabs a n iterative abstract interpretation framework for interrupt driven software.
that is the framework always analyzes each interrupt handler in isolation before propagating the result to other interrupt handlers and the per interrupt analysis is iterated until results on all interrupt handlersstabilize i.e.
they reach a fixed point.
thus in contrast to traditional techniques it never constructs the monolithic verification model that often causes exponential blowup up front.
due to this reason our method is practically more efficient than these traditional verification techniques.
the intabs framework also differs from prior techniques for statically analyzing interrupt driven software such as the source to source transformation based testing approach proposed by regehr the sequentialization approach used by wu et al.
and the model checking technique implemented in icbmc .
for example none of these existing techniques can soundly handle infinite loops nested invocations of interrupts or prove the absence of bugs.
although some prior abstract interpretation techniques over approximate of the interrupt behavior they are either non modular or too inaccurate e.g.
by allowing too many infeasible store toload data flows between interrupts.
in contrast our approach precisely models the preemptive scheduling of interrupts to identify apparently infeasible data flows.
as shown in fig.
by pruning away these infeasible data flows we can drastically improve the accuracy of the overall analysis.
intabs provides not only a more accurate modeling of the interrupt semantics but also a more efficient abstract interpretation framework.
we have implemented intabs in a static .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research206 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
interrupt driven program queryabstract interpretation of each interruptinvariants feasibility checking z datalog rulesdatalog factspropagating results to other interrupts fig.
.
intabs iterative verification framework for interrupt driven programs.
analysis tool for c c programs which uses clang llvm as the front end apron for implementing the numerical abstract domains and z for checking the feasibility of data flows between interrupts.
we evaluated intabs on interrupt driven applications with a total of lines of c code.
our experimental results show that intabs can efficiently as well as more accurately analyze the behavior of interrupts by removing a large number of infeasible data flows between interrupts.
in summary the main contributions of our work are a new abstract interpretation framework for conducting static verification of interrupt driven programs.
a method for soundly and efficiently identifying and pruning infeasible data flows between interrupts.
the implementation and experimental evaluation on a large number of benchmark programs to demonstrate the effectiveness of the proposed techniques.
the remainder of this paper is organized as follows.
we first motivate our approach in section ii by comparing it with testing model checking and abstract interpretation tools designed for threads.
then we provide the technical background oninterrupt modeling and abstract interpretation in section iii.
next we present our new method for checking the feasibility of data flows between interrupts in section iv followed by our method for integrating the feasibility checking with abstractinterpretation in section v. we present our experimental evaluation in section vi.
finally we review the related work in section vii and conclude in section viii.
ii.
m otiv ation we first use examples to illustrate the problems of prior techniques such as testing model checking and thread modular abstract interpretation.
then we explain how our method overcomes these problems.
consider the example program in fig.
which has three interrupts irq h irq l andirq m .
the suffix his used to denote high priority lfor low priority and mfor medium priority.
interrupts with higher priority levels may preempt interrupts with lower priority levels but not vice versa.
inside the handlers there are two variables xandy which are set to 0initially.
among the three assertions the first two may fail while the last one always holds.
a. testing testing an interrupt driven program requires the existence of interrupt sequences which must be generated a priori.
inirq h ... assert y irq l x assert x irq m y x assert x fig.
.
an example program with three interrupt handlers and assertions.
irq h irq m irq l irq mirq h irq lcase0 case1 irq lirq mirq h case3irq lirq h irq m case2 fig.
.
some possible interrupt sequences for the program in fig.
.
fig.
for example since the interrupt handlers have different priority levels we need to consider preemption while creating the test sequences.
since a high priority interrupt handler may preempt at any time the execution of a medium or lowpriority interrupt handler when irq l is executing irq h may be interleaved in between its instructions.
fig.
shows four of the possible interrupt sequences for the program.
specifically case0 is the sequential execution of the three handler functions case1 shows that irq h preempts irq m followed by irq l case2 is similar except thatirq l executes first and then is preempted by irq h followed by irq m and case3 is the nested case where irq l is preempted by irq m and then by irq h. the main problem of testing is that there can be too many such interrupt sequences to explore.
even if we can somehow guarantee that each interrupt handler is executed only once the total number of test sequences can be enormously large even for small or medium sized programs.
b. model checking model checking tools such as cbmc may be used to search for erroneous interrupt sequences e.g.
those leading to assertion violations.
for instance in the running example all assertions hold under the sequences case0 and case2 in fig.
.
this is because although irq h preempts irq l they access different variables and thus do not affect the assertion conditions while irq m checks the value of xafter assigning 1t ox.
incase1 however the execution order of the three interrupt handlers is different thus leading to an assertion violation inside irq h .
more specifically irq m is preempted by irq h at first.
then after both completes irq l is executed.
so the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assert y y initialized value y from irq m assert x x from irq l x from irq m assert x x from irq l x from irq mfeasible infeasible fig.
.
some possible store to load data flows during abstract interpretation.
change of ymay affect the read of yinirq h leading to the violation.
finally in case3 both of the first two assertions may be violated because the check of xinirq l and the check of yinirq h can be affected by irq m s own assignments of xandy.
although bounded model checking can quickly find bugs e.g.
the assertion violations in fig.
the depth of the execution is often bounded which means in practice tools such as icbmc cannot prove the absence of bugs.
c. abstract interpretation abstract interpretation is a technique designed for proving properties e.g.
assertions always hold.
unfortunately existing methods based on abstract interpretation are mostly designed for threads as opposed to interrupts.
since threads interact with each other more freely than interrupts these methods are essentially over approximated analysis.
as such they may still be leveraged to prove properties in interrupt driven programs albeit in a less accurate fashion.
that is when they prove an assertion holds the assertion indeed holds but when they cannot prove an assertion the result is inconclusive.
for the running example in fig.
for instance existing abstract interpretation techniques such as min e designed for analyzing threads cannot prove any of the three assertions.
to see why let us first assume that interrupt handlers are thread routines.
during thread modular abstract interpretation the verification procedure would first gather all possible pairs of load and store instructions with respect to the global variables as shown in fig.
where each assertion has two possible loads.
specifically the load of yinirq h corresponds to the initial value 0and the store in irq m .
the load of xinirq l corresponds to the stores in irq l and irq m .
the load of xinirq m corresponds to the stores in irq l andirq m. since these existing methods assume that all stores may affect all loads they would incorrectly report that all three assertions may fail.
for example it reports that the load of xinirq m may incorrectly read from the store x inirq l despite that irq l has a lower priority and thus cannot preempt irq m .
in contrast our new method can successfully prove the third assertion.
specifically we model the behavior of interrupts with different levels of priorities.irq m if ... y y assert x irq l ...y ... assert y irq h if ... x x assert y fig.
.
an example program with three interrupt handlers where the first two assertions alway hold but the last assertion may fail.
due to the different priority levels certain store to load data flows are no longer feasible as shown by the stores marked by red boxes in fig.
these two stores have lower priority than the corresponding load in the assertions.
d. abstract interpretation for interrupts modeling the priority levels alone however is not enough for proving all assertions because even without preemption a low priority interrupt may affect a high priority interrupt.
consider the first red box in fig.
.
although y fromirq m cannot affect the load of yinirq h through preemption if irq h is invoked after irq m ends ycan still get the value thus leading to the assertion violation.
therefore our new verification procedure has to consider all possible sequential interleavings of the interrupt handlers as well.
now consider the program in fig.
which has three interrupt handlers irq m irq l andirq h .
in these handler functions there are two global variables xandy which are set to 0initially.
among the three assertions the first two always hold whereas the last one may fail.
for ease ofcomprehension we assume the computer hardware running this program provides the sequentially consistent memory .
note that irq m has two stores of y one inside the conditional branch and the other outside and irq h has two stores of x one inside the conditional branch and the other outside.
with prior thread modular analysis all three assertions may fail because the store y inirq m may be interleaved right before the assertions in irq l andirq h .
furthermore the store x inirq h executed before irq m may lead to the violation of the assertion in irq m .
in contrast with our precise modeling of the interrupt behavior the new method can prove that the first two assertions always hold.
specifically the assertion in irq l holds because even if it is preempted by irq m the value of yremains .
similarly the assertion in irq m holds because even if it is preempted by irq h the store x post dominates the store x meaning the value of xremains 1afterirq h returns.
in contrast the assertion in irq h may fail if irq h preempts irq m right after the conditional branch that sets yto0.
this particular preemption is feasible because irq h has a higher priority than irq m. therefore our new method has to consider not only the different levels of priority of all interrupts but also the domination and post domination relations within each handler.
it decides the feasibility of store to load data flows based on whether a load has a dominated store whether a store has a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i comparing intabswith testing and prior verification methods on the programs in fig.2and fig.
.
property testing model checking bounded abs.
int.
for threads intabs for interrupts new assertion in fig.
irq h violation violation warning warning assertion in fig.
irq l violation violation warning warning assertion in fig.
irq m bogus warning proof assertion in fig.
irq m bogus warning proof assertion in fig.
irq l bogus warning proof assertion in fig.
irq h violation violation warning warning run0 stmt1 stmt2 run1 stmt3 stmt4 possible traces for interrupts stmt1 stmt2 stmt3 stmt4 stmt1 stmt3 stmt4 stmt2 possible traces for threads stmt1 stmt2 stmt3 stmt4 stmt1 stmt3 stmt4 stmt2 stmt1 stmt3 stmt2 stmt4 fig.
.
the interleavings after stmt1 allowed by interrupts and threads.
post dominated store and whether a load store pair is allowed by the priority levels of the interrupts.
we present the details of this feasibility checking algorithm in section iv.
to sum up the main advantages of intabs over state of theart techniques are shown in table i. specifically testing and bounded model checking tools are good at detecting bugs e.g.
assertion violations but cannot prove the absence of bugs whereas thread modular abstract interpretation tools are good at obtaining proofs but may report many false positives i.e.
bogus warnings .
in contrast our new abstract interpretation method is significantly more accurate.
it can obtain more proofs than prior techniques and at the same time can significantly reduce the number of bogus warnings.
iii.
p reliminaries in this section we describe how interrupt driven programs are modeled in our framework by comparing their behavior to the behavior of threads.
then we review the basics of prior abstract interpretation techniques.
a. modeling of interrupts we consider an interrupt driven program as a finite set t t1 ... t n of sequential programs.
each sequential program ti where i n denotes an interrupt handler.
for ease of presentation we do not distinguish between the main program and the interrupt handlers.
globally sequential programs in t are executed in a strictly interleaved fashion.
each sequential program may access its own local variables in addition it may access a set of global variables through which it communicates with the other sequential programs in t. the interleaving behavior of interrupts is a strict subset of the interleaving behavior of threads c.f.
.
this is becauseconcurrently running threads are allowed to freely preempt each other s executions.
however this is not the case for interrupts.consider the example program in fig.
which has two functions named run0 andrun1 .
if they were interrupts where run1 has a higher priority level than run0 then after executing stmt1 there can only be two possible traces.
the first one is for run1 to wait until run0 ends and the second one is for run1 to preempt run0 .
if they were threads however there can be three possible traces after executing stmt1 .
in addition to the traces allowed by interrupts we can also execute stmt3 inrun1 then execute stmt2 in run0 and finally execute stmt4 inrun1 .
the third trace is infeasible for interrupts because the high priority run1 cannot be preempted by stmt2 of the low priority run0.
since the interleaving behavior of interrupts is a strict subset of the interleaving behavior of threads it is always safe to apply a sound static verification procedure designed for threads to interrupts.
if the verifier can prove the absence of bugs by treating interrupts as threads then the proof is guaranteed to be valid for interrupts.
the result of this discussion can be summarized as follows theorem since the interleaving behavior of interrupts is a subset of the interleaving behavior of threads proofs obtained by any sound abstract interpretation over threads remain valid for interrupts.
however the reverse is not true a bug reported by the verifier that treats interrupts as threads may not be a real bug since the erroneous interleaving may be infeasible.
in practice there are also tricky corner cases during the interaction of interrupts such as nested invocations of handlers which call for a more accurate modeling framework for interrupts.
interrupts may also be invoked in a nested fashion as shown bycase3 in fig.
which complicates the static analysis.
here we say interrupts are nested when one s handler function is invoked before another s handler function returns and the third handler function is invoked before the second handler functionreturns.
such nested invocations are possible for example if the corresponding interrupts have different priority levels where the inner most interrupt has the highest priority level.
this behavior is different from thread interleaving with numerous corner cases it requires the development of dedicated modeling and analysis techniques.
b. abstract interpretation for threads existing methods for modular abstract interpretation are designed almost exclusively for multithreaded programs .
typically the analyzer works on each thread in isolation without creating a monolithic verification model as in the non modular techniques to avoid the upfront complexity blowup.
at a high level the analyzer iterates authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm local analysis of twith prior interferences i. function analyze local t angbracketleftn n angbracketright i s map from nodes to states w n0 set of nodes to process while n w do w w n ifnis a shared memory read of variable vthen s tfunc n s n unionsqi v else s tfunc n s n for all angbracketleftn n prime angbracketright such that s negationslash subsetsqequals n prime do s n prime s n prime unionsqs w w n prime returns through threads in two steps analyzing each thread in isolation and propagating results from the shared memory writes of one thread to the corresponding reads of other threads.
let the entire program pbe a finite set of threads where each thread tis represented by a control flow graph angbracketleftn n angbracketright with a set of nodes n an entry node n0 and the transition relation .
each pair n n prime means control may flow from nton prime.
each node nis associated with an abstract memorystate over approximating the possible concrete states at n.w e assume the abstract domain e.g.
intervals is defined as a lattice with appropriate top latticetop and bottom elements a partial order relation subsetsqequal and widening narrowing operators to ensure that the analysis eventually terminates .
we also define an interference ithat maps a variable vto the values stored into vby some thread t. algorithm shows how a thread local analyzer works on t assuming some interferences iprovided by the environment e.g.
writes in other threads .
it treats tas a sequential program.
lets n be the abstract memory state at node n n0be the entry node of t andwbe the set of nodes in tleft to be processed.
the procedure keeps removing node nfrom the work list wand processing it until wis empty i.e.
a fixed point is reached .
if nodencorresponds to a shared memory read of variable v then the transfer function tfunc line assumes that n can read either the local value from s or the value written by another thread the interference i v .
the transfer function tfunc of an instruction ntakes some memory state as input and returns a new memory state as output the new memorystate is the result of executing the instruction in the given memory state.
otherwise if nis a local read in which case the transfer function tfunc uses the local memory state line as in the abstract interpretation of any sequential program.
the analysis result denoted s is an over approximation of the memory states within tassuming interferences i. the procedure that analyzes the entire program is shown in algorithm .
it first analyzes each thread computes theinterferences and then analyzes each thread again in the presence of these interferences.
the iterative process continuesuntil a fixed point on the memory states of all threads is reached.
initially smaps each node in the program to an empty memorystate .s primecontains the analysis results after one iteration of the fixed point computation.
the function i nterf returns the interferences of thread t i.e.
a map from some variable vtoalgorithm analysis of the entire program i.e.
a set of t s. function analyze prog p s map all nodes to s prime s repeat s s prime for allt pdo i unionmultitextinterf t prime s for eacht prime p t prime negationslash t s prime s prime unionmultianalyze local t i untils prime s function interf t angbracketleftn n angbracketright s i for alln ndo ifnis a shared memory write to variable vthen i v i v unionsqtfunc n s n returni all the abstract values stored into vbyt.
each thread tis analyzed in isolation by the loop at lines .
here we use unionmultito denote the join unionsq of all memory states on the matching nodes.
this thread modular abstract interpretation framework while more efficient than monolithic verification is potentially less accurate.
for example a load lmay see anyvalue written into the shared memory by a store seven if there does not exist a path in the program where lobserves s. this is why as shown in table i techniques such as cannot obtainproofs for the programs in fig.
and fig.
.
in the context of interrupt handlers with priorities it means that even infeasible store to load flows due to priorities may be included in the analysis thus causing false alarms.
in the remainder of this paper we show how to introduce priorities into the propagation of data flows between interrupts during the analysis thereby increasing the accuracy while retaining its efficiency.
iv .
f easibility of data flows between interrupts in this section we present our method for precisely modeling the priority based interleaving semantics of interrupts anddeciding the feasibility of store to load data flows between interrupts.
if for example a certain store to load data flow is indeed not feasible it will not be propagated across interrupts in algorithm .
more formally given a set of store to load pairs we want to compute a new m ustnotreadfrom relation such that mustnotreadfrom l s for any load land store s means if we respect all the other existing store to load pairs then it would be infeasible for lto get the value written by s. we have developed a datalog based declarative program analysis procedure for computing m ustnotreadfrom .
toward this end we first generate a set of datalog facts from the program and the given store to load pairs.
then we generate a set of datalog rules which infer the new mustnotreadfrom relation from the datalog facts.
finally we feed the facts together with the rules to an off the shelf datalog engine which computes the m ustnotreadfrom relation.
in our implementation we used the z datalog engine to solve the datalog constraints.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. inference rules before presenting the rules we define some relations dom a b statement adominates bin the cfg of an interrupt handler function.
postdom a b statement apost dominates bin the cfg of an interrupt handler function.
pri s p statement shas the priority level p. load l v lis a load of global variable v. store s v sis a store to global variable v. dominance and post dominance are efficiently computable within each interrupt handler not across interrupt handlers .
priority information for each interrupt handler and thus all its statements may be obtained directly from the program.
similarly l oad and s tore relations may be directly obtained from the program.
next we present the rules for inferring three new relations nopreempt covered load and i ntercepted store .
a nopreempt the relation means s1cannot preempt s2 where s1ands2are instructions in separate interrupt handlers.
from the interleaving semantics of interrupts weknow a handler may only be preempted by another handler with a higher priority.
thus nopreempt s1 s2 pri s1 p1 pri s2 p2 p2 p1 here pri s1 p1 meanss1belongs to a handler with priority p1 and pri s2 p2 meanss2belongs to a handler with priority p2.i fp 1is not higher than p2 thens1cannot preempt s2.
b covered load the relation means a load lof a variablevis covered by a store stovinside the same interrupt handler this is the case when soccurs before lalong all program paths.
this is captured by the dominance relation in the corresponding control flow graph covered load l load l v store s v dom s l c intercepted store the relation is similar to c overed load.
we say a store s1is intercepted by another store s2 ifs2occurs after s1along all program paths in the same handler.
intuitively the value written by s1is always overwritten by s2 before the handler terminates.
formally intercepted store s1 store s1 v store s2 v postdom s2 s1 finally the m ustnotreadfrom relation is deduced using all aforementioned relations including n opreempt covered load and i ntercepted store .
it indicates that under the current situation defined by the set of existing store to load data flows a load lcannot read from a store sin any feasible interleaving.
there are several cases first we say a load lcovered by a store in a handler i cannot read from a store sintercepted by another store in a handleri prime because lcannot read from susing any preemption or by running iandi primesequentially.mustnotreadfrom l s covered load l load l v store s v intercepted store s second we say a load lcovered by a store sin a handler i cannot read from any store s primethat cannot preempt i because the value of s primewill always be overwritten by s. that is since s primecannot preempt i it cannot execute in between sandl.
mustnotreadfrom l s covered load l load l v store s v nopreempt s l third we say that if a store sis intercepted in a handler i then a load lof the same variable that cannot preempt s cannot read from the value stored by s. this is because the store intercepting swill always overwrite the value.
mustnotreadfrom l s intercepted store s store s v load l v nopreempt l s b. the running examples to help understand how m ustnotreadfrom is deduced from the datalog rules and facts we provide a few exam ples.
for ease of comprehension we show in table ii how mustnotreadfrom may be deduced from i ntercepted store covered load and n opreempt .
since all stores are either in or outside i ntercepted store and all loads are either in or outside c overed load our rules capture the mustnotreadfrom relation between all stores and loads.
table ii mustnotreadfrom rules based on intercepted store covered load and priority intercepted store s notintercepted store s covered load l mustnotreadfrom l s not n opreempt s l possibly readfrom l s nopreempt s l mustnotreadfrom l s notcovered load l nopreempt l s possibly readfrom l s mustnotreadfrom l s not n opreempt l s possibly readfrom l s specifically if a store sis intercepted store and a load lis c overed load there is no way for the load to read from the store row and column .
if a load lis not c overed load and a store sis not intercepted store the load may read from the store by running sequentially or via preemption row and column .
if a load lis c overed load a store sis not i nter cepted store and the handler of the store can preempt the handler of the load the load may read from the store through preemption the first case at row and column .
however if the handler of the store cannot preempt the handler of the load it is impossible for the load to read from the store inthis case the load always reads from the store in the same interrupt handler the second case at row and column .
lastly if a load lis not c overed load a store sis intercepted store and the handler of the load cannot preempt the handler of the store the load cannot read from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the store since the value of the store is always overwritten by another store in the same handler the first case at row and column .
however if the handler of the load can preempt the handler of the store then the load can read from the store through preemption in between two stores the second case at row and column .
irq0 store x load x irq1 store x store x a c overed load i nter cepted storeirq0 store x load x irq1 ...store x b c overed load not i ntercepted store irq0 ... load x irq1 store x store x c not c overed load i ntercepted storeirq0 ...load x irq1 ...store x d not c overed load not intercepted store fig.
.
examples for each case in table ii.
fig.
shows concrete examples of the four cases presented in table ii where the figures correspond to the cases.
fig.
a represents the case at row and column in table ii and fig.
b represents the case at row and column .
in both programs only the interference between bold style statements are considered.
fig.
a shows an interference between c overed load and i ntercepted store .
since the load in irq0 is always overwritten by another store in it and a value of the first store inirq1 is always updated by a store in it the load cannot read a value from the store by preemption or running sequentially.
fig.
b shows an interference between c overed load and not i ntercepted store .
in this case if irq1 can preempt irq0 then the store from irq1 can occur between the store and the load in irq0 .
otherwise the load from irq0 cannot read a value from the store from irq1.
fig.
c shows an interference between not c overed load and i ntercepted store .
similarly if irq0 can preempt irq1 the load from irq0 can occur between the two stores from irq1 .
thus it is possible for the load to read a value from the first store in irq1 .
otherwise the load cannot read a value from the store by preemption of irq1 or running sequentially.
fig.
d shows an interference between not c overed load and not i ntercepted store .
here the load in irq0 can read a value from the store in irq1 by running sequentially or through preemption.
therefore it is possible for the load toread a value from the store as described at row and column in table ii.
to sum up we can use the three inference rules to determine infeasible store to load pairs for all these cases.
c. soundness of the analysis by soundness we mean the m ustnotreadfrom relation deduced from the datalog facts and rules is an underapproximation.
that is any pair l s of load and store in this relation is guaranteed to be infeasible.
however we do notalgorithm analysis of the entire program cf.
alg.
.
function interf t angbracketleftn n angbracketright t prime angbracketleftn prime n prime prime angbracketright s i for alln ndo ifnis a shared memory write to variable vthen i v i v unionmulti n tfunc n s n returni algorithm analysis of a single interrupt cf.
alg.
.
function analyze local t angbracketleftn n angbracketright i ... ifnis a shared memory read of variable vthen i unionsqtext n st s i v mustnotreadfrom l st s tfunc n s n unionsqi else s tfunc n s n ... attempt to identify allthe infeasible pairs because the goal here is to quickly identify some infeasible pairs and skip them during the more expensive abstract interpretation computation.
theorem whenever mustnotreadfrom l s holds the load lcannot read from the store son any concrete execution of the program.
the soundness of our analysis as stated above can be established in two steps.
first assume that each individual rule is correct the composition is also correct.
second while presenting these rules we have sketched the intuition behind the correctness of each rule.
a more rigorous proof can be formulated via proof by contradiction in a straightforward fashion which we omit for brevity.
v. t heoverall analysis procedure we now explain how to integrate the feasibility checking technique into the overall procedure for iterative analysis whichleverages the m ustnotreadfrom relation to improve performance.
specifically when analyzing each interrupt handler t we filter out any interfering stores from other interrupt handlers that are deemed infeasible thereby preventing their visibility tot.
this can be implemented in algorithm by modifying the function i nterf as well as the function a nalyze local defined in algorithm .
our modifications to i nterf are shown in algorithm .
that is when computing the interferences of t we choose to create a set of store state pairs instead of eagerly joining all these states.
by delaying the join of these states we obtain the opportunity to filter out the infeasible store to load pair individually.
for this reason we overload the definition of unionmulti to be the join unionsq of sets on matching variables.
next we modify the abstract interpretation procedure for a single interrupt handler as shown in algorithm .
the process remains the same as a nalyze local of algorithm except that when a load lis encountered line we join the state from all interfering stores while removing any that must not interfere with l as determined by the m ustnotreadfrom relation line .
the remainder of the modular analysis remains the same as in algorithm .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
irq0 b x assert b irq1 while ... x x fig.
.
a small example with a loop.
for example in fig.
a existing thread modular abstract interpretation methods would consider the two stores from irq1 for the load of xinirq0 .
in contrast we use algorithm to remove the pairing of the load in irq0 and the first store in irq1 since the load and the store satisfy the mustnotreadfrom relation.
similarly the pairing of the load of xinirq0 and the store of xinirq1 is filtered out when irq1 s priority is not higher than irq0 s priority as shown in fig.
b .
our method can handle programs with loops.
fig.
shows an example which has two interrupt handlers where irq1 has higher priority than irq0 .
note that irq0 loads xand stores the value into b. since xis initialized to the handler checks whether the value of bis0.irq1 has a loop containing two stores of x. first it stores the value 1and then the value .
using traditional thread modular abstract interpretation we would assume that x andx are all possible stores to the load of xinirq0 .
this would lead to a bogus violation of the assertion in irq0.
however in our analysis this bogus violation is avoided by using the post dominate relation between statements.
inside the while loop of irq1 x post dominates x meaning that x always occurs after x .
therefore using our datalog inference rules presented in the previous section we conclude that the store x cannot reach the load of xinirq0 .
thus it is impossible for the value 1to be stored in band then cause the assertion violation.
vi.
e xperiments we have implemented intabs our new abstract interpretation framework in a static verification tool for interrupt driven c programs.
it builds on a number of open source tools including clang llvm for implementing the c front end apron library for implementing the abstract domains and z for solving the datalog constraints.
we experimentally compared intabs with both icbmc a model checker for interrupt driven programs and the state of the art threadmodular abstract interpretation method by min e .
we conducted our experiments on a computer with an intel core i5 3337u cpu gb of ram and the ubuntu .
linux operating system.
our experiments were designed to answer the following research questions can intabs prove more properties e.g.
assertions than state of the art techniques such as icbmc and min e ?
can intabs achieve the aforementioned higher accuracy while maintaining a low computational overhead?
can intabs identify and prune away a large number of infeasible store load pairs?table iii benchmark programs used in our experimental ev aluation .
name description test small programs created to conduct the sanity check of intabs s handling of various interrupt semantics.
logger programs that model parts of the firmware of a temperature logging device from a major industrial enterprise.
there are two major interrupt handlers one for measurement and the other for communication.
blink programs that control led lights connected to the msp430 hardware to check the timer values and change led blinking based on the timer values.
brake programs generated from the matlab simulink model of a brake bywire system from v olvo technology ab consisting of a main interrupt handler and four other handlers for computing the braking torque based on the speed of each wheel.
usbmouse usb mouse driver from the linux kernel consisting of the device open probe and disconnect tasks with interrupt handlers.
usbkbd usb keyboard driver from the linux kernel consisting of the device open probe and disconnect tasks with interrupt handlers.
rgbled usb rgb led driver from the linux kernel.
we use initializationofledand rgbfunctions and the ledprobe function and check the consistency of the ledand rgbdevice values using interrupts.
rcmain linux device driver for a remote controller core including operations such as device register free check the device information and update protocol values.
we check the consistency of the device information and protocol values using several interrupt handlers.
others programs collected from linux kernel drivers for supporting hardware such as isa boards tco timer for i8xx chipsets and watch dog.
toward this end we evaluated intabs on interrupt driven c programs many of which are from real applications such as control software firmware and device drivers.
thesebenchmark programs together with our software tool have been made available online .
the detailed description of each benchmark group is shown in table iii.
in total there are lines of c code.
a. results table iv shows the experimental results.
columns show the name the number of lines of code loc the number of interrupt handlers and the number of assertions used for each benchmark program.
columns show the results of icbmc including the number of violations detected the number of proofs obtained and the total execution time.
columns show the results of min e s abstract interpretation method .
columns show the results of intabs our new abstract interpretation tool for interrupts.
since icbmc conducts bounded analysis when it detects a violation it is guaranteed to be a real violation however when it does not detect any violation the property remains undetermined.
furthermore since icbmc by default stops as soon as it detects a violation we evaluated it by repeatedly removing the violated property from the program until it couldno longer detect any new violation.
also note that since icbmc requires the user to manually set up the interrupt enabled points as described in during the experiments we first ordered the interrupts by priority and then set interrupt enabled points at the beginning of the next interrupt handler.
for example given three interrupts irq l irq m andirq h we would set the enabled point of irq l in a main function the enabled point of irq m at the beginning of irq l and the enabled point of irq h at the beginning of irq m. overall icbmc found violations while obtaining proofs.
min e s method which was geared toward proving properties in threads obtained proofs while reporting warnings authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv results of comparing intabswith state of the art techniques on 35interrupt driven programs .
icbmc min e intabs new name loc interrupts assertions violations proofs time s warnings proofs time s warnings proofs time s test1 .
.
.
test2 .
.
.
test3 .
.
.
test4 .
.
.
test5 .
.
.
logger1 .
.
.
logger2 .
.
.
logger3 .
.
.
blink1 .
.
.
blink2 .
.
.
blink3 .
.
.
brake1 .
.
.
brake2 .
.
.
brake3 .
.
.
usbmouse1 .
.
.
usbmouse2 .
.
.
usbmouse3 .
.
.
usbkbd1 .
.
.
usbkbd2 .
.
.09usbkbd3 .
.
.
rgbled1 .
.
.
rgbled2 .
.
.
rgbled3 .
.
.
rcmain1 .
.
.
rcmain2 .
.
.46rcmain3 .
.
.
i2cpca isa1 .
.
.
i2cpca isa2 .
.
.
i2cpca isa3 .
.
.
i8xx tco1 .
.
.
i8xx tco2 .
.
.
i8xx tco3 .
.
.
wdt pci1 .
.
.
wdt pci2 .
.
.
wdt pci3 .
.
.
total .
.
.
indicates the results contain bogus warnings because the technique was designed for threads not for interrupts.
many of which turned out to be bogus warnings.
in contrast our new method intabs obtained proofs while reporting warnings.
this is significantly more accurate than the prior techniques.
in terms of the execution time intabs took seconds which is slightly long than the seconds taken by min e s method and the seconds taken by icbmc.
b. infeasible pairs since intabs removes infeasible store load pairs during the iterative analysis of individual interrupt handlers it tends to spend extra time checking the feasibility of these data flow pairs.
nevertheless this is the main source of accuracyimprovement of intabs.
thus to understand the trade off we have investigated for each benchmark program the total number of store load pairs and the number of infeasible storeload pairs identified by our technique.
table v summarizes the results where column shows the total number of store load pairs column shows the number of infeasible pairs and column shows the percentage.
overall our datalog based method for computing the mustnotreadfrom relation helped remove of the loadstore pairs which means the subsequent abstract interpretationprocedure only has to consider the remaining of the load store pairs.
this allows intabs to reach a fixed point not only quicker but also with significantly more accurate results.
vii.
r elated work we have reviewed some of the most closely related work.
in addition min e proposed an abstract interpretation based technique for proving the absence of data races deadlocks and other runtime errors in real time software with dynamic priorities which is an extension of his prior work by adding priorities while targeting the osek autosar operating systems.
specifically it tracks the effectiveness ofmutex yield and scheduler state based on execution traces to figure out reachability while using priorities to make the analysis more accurate.
however the technique may not be efficient in terms of memory and speed since it needs to check all mutex yield and scheduler state to determine spurious interference through trace history.
furthermore it has not been thoroughly evaluated on practical benchmarks.
schwarz and m uller olm proposed a static analysis technique for programs synchronized via the priority ceiling protocol.
the goal is to detect synchronization flaws dueto concurrency induced by interrupts especially for data authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v results of total and filtered store load pairs using intabs.
name loc of pairs of filtered pairs filtered ratio test1 test2 test3 test4 test5 logger1 logger2 logger3 blink1 blink2 blink3 brake1 brake2 brake3 usbmouse1 usbmouse2 usbmouse3 usbkbd1 usbkbd2 usbkbd3 rgbled1 rgbled2 rgbled3 rcmain1 rcmain2 rcmain3 i2cpca isa1 i2cpca isa2 i2cpca isa3 i8xx tco1 i8xx tco2 i8xx tco3 wdt pci1 wdt pci2 wdt pci3 total races and transactional behavior of procedures.
however it is not a general purpose verification procedure and cannotprove the validity of assertions.
regehr et al.
proposedto use context sensitive abstract interpretation of machinecode to guarantee stack safety for interrupt driven programs.
kotker and seshia extended a timing analysis procedure from sequential programs to interrupt driven programs witha bounded number of context switches.
as such it does not analyze all behaviors of the interrupts.
furthermore the user needs to come up with a proper bound of the context switches and specify the arrival time for interrupts.
wu et al.
leveraged bound model checking tools to detect data races in interrupt driven programs.
kroening et al.
also improved the cbmc bounded model checker to support the verification of interrupt driven programs.
however they only search for a bounded number of execution steps andthus cannot prove the validity of assertions.
wu et al.
also proposed a source to source transformation technique similar to regehr it sequentializes interrupt driven programs before feeding them to a verification tool.
however due to thebounded nature of the sequentialization process the method is only suitable for detecting violations but not for proving the absence of such violations.
this limitation is shared by testing methods.
for example regehr proposed a testing framework that schedules theinvocation of interrupts randomly.
higashi and inoue leveraged a cpu emulator to systematically trigger interrupts to detect data races in interrupt driven programs.
however it may be practically infeasible to cover all interleavings of interrupts using this type of techniques.
wang et al.
proposed a hybrid approach that combines static program analysis with dynamic simulation to detect data races in interrupt driven programs.
although theapproach is useful for detecting bugs it cannot be used to obtain proofs i.e.
proofs that assertions always hold.
there are also formal verification techniques for embedded software based on model checking .
for example schlich and brutschy proposed thereduction of interrupt handler points based on partial order reduction when model checking embedded software.
v ortler et al.
proposed within the contiki system a method for modeling interrupts at the level of hardware independent c source code and a new modeling approach for periodically occurring interrupts.
then they verify programs with interrupts using cbmc which is again a bounded model checker.
this means the technique is also geared toward detecting bugs and thus cannot prove properties.
furthermore since it models the periodical interrupt invocation only the approach cannot deal with non periodic invocations.
datalog based analysis techniques have been widely used in testing and verification but none of the prior techniques was designed for analyzing the interleaving behavior of interrupts.
for example kusano and wang used datalog to obtain flow sensitivity in threads to improve the accuracy of thread modular abstract analysis for concurrent programs.
sung et al.
used datalogbased static analysis of html dom events to speed up atesting tool for javascript based web applications.
however the datalog rules used by these prior techniques cannot be used to reason about the behavior of interrupts with priorities.
viii.
c onclusions we have presented an abstract interpretation framework for static verification of interrupt driven software.
it first analyzes each individual handler function in isolation and then propagates the results to other handler functions.
to filter out the infeasible data flows we have also developed a constraintbased analysis of the scheduling semantics of interrupts with priorities.
it relies on constructing and solving a system of datalog constraints to decide whether a set of data flow pairs may co exist.
we have implemented our method in a softwaretool and evaluated it on a large set of interrupt driven programs.our experiments show the new method not only is efficient butalso significantly improves the accuracy of the results compared to existing techniques.
more specifically it outperformed both icbmc a bounded model checker and the state of the art abstract interpretation techniques.
ix.
a cknowledgments this material is based upon research supported in part by the u.s. national science foundation under grants ccf and ccf and the u.s. office of naval research under award number n00014 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.