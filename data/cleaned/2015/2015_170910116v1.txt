flow sensitive composition of thread modular abstract interpretation markus kusano virginia tech blacksburg va usachao wang university of southern california los angeles ca usa abstract we propose a constraint based flow sensitive static analysis for concurrent programs by iteratively composing thread modular abstract interpreters via the use of a system of lightweight constraints.
our method is compositional in that it first applies sequential abstract interpreters to individual threads and then composes their results.
it is flow sensitive in that the causality ordering of interferences flow of data from global writes to reads is modeled by a system of constraints.
these interference constraints are lightweight since they only refer to the execution order of program statements as opposed to their numerical properties they can be decided efficiently using an off the shelf datalog engine.
our new method has the advantage of being more accurate than existing flow insensitive static analyzers while remaining scalable and providing the expected soundness and termination guarantees even for programs with unbounded data.
we implemented our method and evaluated it on a large number of benchmarks demonstrating its effectiveness at increasing the accuracy of thread modular abstract interpretation.
ccs concepts software and its engineering !automated static analysis formal software verification keywords concurrency abstract interpretation invariant generation threadmodular reasoning interference datalog .
introduction although abstract interpretation has wide use in the analysis and verification of sequential programs designing a scalable abstract interpretation based analysis for shared memory concurrent programs remains a difficult task .
due to the large concurrent state space directly applying techniques designed for sequential abstract interpretation to interleaved executions of a concurrent program does not scale.
in contrast recent thread modular techniques drastically over approximate the interactions between threads allowing a more tractable but less accurate analysis.
their main advantage is that sequential abstract interpreters can be lifted to concurrent ones with minimal effort.
however they consider thread interactions in a flow insensitive manner given a system of threadsfa b cg for instance they assume acan observe all combinations of memory modifications from bandcdespite that some of these combinations are infeasible thereby leading to a large number of false alarms even for simple programs.
in this paper we propose the first constraint based flow sensitive method for composing sequential abstract interpreters to form a more accurate thread modular analysis.
though desirable no existing static method is able to maintain inter thread flow sensitivityconcurrent programthread modular abstract interpretationinvariants query z solver datalog interference feasibility checking figure w atts flow sensitive thread modular analysis.
with a reasonable cost.
the main advantage of our method is that through the use of a lightweight system of constraints it can achieve a high degree of flow sensitivity with negligible runtime cost.
here our goal is to prove the correctness of reachability properties of a program the properties are embedded assertion statements whose error conditions are relational expressions over program variables at specific thread locations.
another advantage is that our method can be implemented as a flexible composition of existing sequential abstract interpretation frameworks while retaining the well known benefits such as soundness and guaranteed termination as well as the freedom to plug in a large number of abstract domains .
figure shows an overview of our new method.
given a concurrent program our method returns a set of relational and numerical invariants statically computed at each thread location as output.
these invariants in turn can be used to prove the set of reachability properties of the program.
during the thread modular analysis we first apply a sequential abstract interpreter to each individual thread and then propagate their results across threads before applying these sequential abstract interpreters again.
the iterative process continues until a fix point is reached over the set of invariants.
during each iteration the abstract interpreter also communicates with a datalog engine to check if a thread interference or set of interferences data flow from global writes to reads is feasible.
if we can statically prove that the interference is infeasible i.e.
it cannot occur in any real execution of the program we skip it thereby reducing the analysis time and increasing accuracy.
in contrast to existing methods in this domain our analysis is flowsensitive for two reasons.
first we explore the memory interactions between threads individually by propagating their memory states along data flow edges without eagerly merging them through join operations as in prior techniques .
second we identify and remove the infeasible memory interactions by constructing and solving a system of lightweight happens before constraints.
these constraints horn clauses in finite domains capture only the causality ordering of the program s statements as opposed to complex relational numerical properties.
as such they can be solved by a datalogarxiv .10116v1 sep 20171bool flag false 2int x 3void thread1 x x flag true 8void thread2 bool b1 flag if b1 int t1 x if t1 !
error!
figure proving the error!
onl13is not reachable.
engine in polynomial time.
these two techniques together greatly reduce the number of false alarms caused by over approximating the global memory state across threads thereby allowing more properties to be verified compared to prior approaches.
consider the program in figure which has two threads communicating through the shared variables xandflag .
initially flag is false and xis .
thread only performs shared memory writes by setting xto and then to before setting flag to true.
thread only performs shared memory reads it reads the value of flag and if the value is true reads the value of x. note that the error!
at l13 is unreachable since for thread to reach l11 thread has to setflag to true atl6 beforel9is executed but in such a case l5 must have been executed meaning xmust have been set to .
prior static analyzers such as ferrara and min would have difficulty because their treatment of inter thread communication is flow insensitive .
that is if one thread writes to a shared variable at program location liand another thread reads the same shared variable at lj they model the interaction by adding a dataflow edge from litoljeven if the edge is infeasible or is only feasible in some program executions.
for example in figure no concrete execution simultaneously allows the flow of xfroml4to l11and the flow of flag froml6tol9.
in such cases these prior methods would lose accuracy because their way of modeling the inter thread data flow cannot differentiate between the feasible and infeasible data flow combinations.
in contrast our new method detects and eliminates such infeasible data flows.
for now it suffices to say that our method would report that the flow of xfroml4tol11cannot co exist with the flow of flag froml6tol9.
we will provide full details of our constraintbased interference analysis in section .
our method for checking the feasibility of inter thread data flows is sound when it declares a certain combination of interferences as infeasible the combination is guaranteed to be infeasible.
however for efficiency reasons our method does not attempt to identify every infeasible combination.
this is consistent with the fact that abstract interpretation in the context of property verification is generally an over approximation it can prove the absence of errors but does not aim to guarantee that all unverified properties have real violations.
as such the additional effort we put into our constraintbased interference analysis is a fair trade off between lower runtime overhead and improved accuracy.
this puts our method in a nice middle ground between the more heavyweight model checkers and the more scalable and yet less accurate static analysis techniques .
another perhaps subtle benefit of our method is that the sequential abstract interpreter only needs a lightweight constraint solver as a black box to query the feasibility of a set of interferences.
as such it provides a flexible and extensible framework allowing additional constraints deduction rules and decision procedures e.g.
solvers for symbolic numerical domains to be plugged in to further reduce the number of false alarms.
to make our method more efficient we also propose several optimizations to our interference feasibility analysis section we leverage control and data dependencies to group interferences before checking the feasibilityof their combinations and leverage property directed pruning to reduce the program s state space.
our method differs from the duet concurrent static analyzer of farzan and kincaid despite that both methods employ constraint based analysis since we aim at solving a different problem.
first our goal is to accurately analyze a concurrent program with a fixed number of threads whereas their goal is to soundly approximate the behavior of a parameterized program with an unbounded number of thread instances.
second our method is strictly thread modular we iteratively apply a sequential abstract interpreter to a set of control flow graphs one per thread and one at a time.
in contrast they analyze a single monolithic data flow graph of the entire concurrent program.
as a result their method is significantly less accurate than ours on non parameterized programs.
we illustrate the main difference between these two computational models i.e.
a set of per thread control flow graphs versus a monolithic data flow graph in section .
.
we implemented our method in a static analysis tool named watts for verifying reachability properties of multithreaded c c programs written using the posix thread library.
the tool builds upon the llvm compiler using the z fix point engine in z3 to solve datalog constraints and the apron library to implement the sequential abstract interpreter over numerical abstract domains.
we have evaluated our method on a set of benchmarks with a total of lines of code.
our experiments show that watts can successfully prove reachability properties compared to properties proved by duet and properties proved by the prior flow insensitive methods .
furthermore watts achieved a 28x increase in the number of verified properties with only a .4x increase in the analysis time.
in summary this paper makes the following contributions .we propose a flow sensitive method for composing threadmodular abstract interpreters into a more accurate static analysis procedure.
.we develop a lightweight constraint based framework for soundly checking the feasibility of inter thread interferences and combinations of interferences.
.we develop optimization techniques to improve the efficiency of our analysis by leveraging control and data dependencies and property directed pruning.
.we implement and evaluate our method on a large set of benchmarks and demonstrate its advantages over prior works.
.
motiv ating examples we present a series of examples showing applications of our new method compared to existing approaches.
.
thread modular abstract interpretation first figure provides an overview of prior works on threadmodular abstract interpretation .
these methods all use the same notion of interference between threads an interference is a value stored into shared memory at some point during the execution of a thread.
in figure there are three interferences all from thread the writes to xatl4andl5and the write to flag atl6.
these prior techniques analyze the program by statically computing the over approximated set of interferences for each thread .
initially the set of interferences in each thread is empty.
.each thread is independently analyzed in the presence of interferences from all other threads.
.the set of interferences in each thread is recomputed based on the results of the analysis in step .
.
steps are repeated until the interferences stabilize.
during the thread modular analysis step each thread keeps track of its own memory environment at every thread location.
thetable running prior approaches on figure .
thread thread iteration reachable interference reachable interference one ag f1g x f4 5g9 ?
two ag f1g x f4 5g9 ?
memory environment is an abstract state mapping program variables to their values.
to incorporate inter thread effects when a thread performs a shared memory read on some global variable q it reads either the values of qin its own memory environment or the values ofqfrom the interferences of all other threads.
these techniques rely on a flow insensitive analysis in that each read may see all values ever written by any other thread even if the flow of data is not feasible in all or any of the concrete program executions.
table shows the results of analyzing figure with prior threadmodular approaches .
column shows the two iterations.
columns and show the lines reachable after each iteration in the two threads.
columns and show the interferences generated after each iteration.
in the second iteration the interferences generated during the first iteration are visible thread is analyzed in the presence of the interferences generated by thread .
after two iterations the interferences stabilize which concludes the analysis.
unfortunately the result in table shows that thread can reach l12 where it reads the value of xeither from its own memory environment the initial value or from the interference of thread thereby allowing the error!
to be reached.
this is a false alarm the property violation is generated because the inter thread interferences are handled in a flow insensitive manner.
in this example to eliminate the false alarm one has to maintain a complex invariant such as ag true !
x which cannot be expressed precisely as a relational invariant even in expensive numerical domains such as convex polyhedra.
additionally in order to propagate such a relational invariant across threads as in they need to hold over all states within a thread.
otherwise interference propagation is inherently non relational.
specifically propagating the interferences on a variable xfirst requires a projection on x thus forgetting all relational invariants.
in contrast our method can eliminate the false alarm even while staying in inexpensive abstract domains such as intervals.
in particular our work shows that eagerly joining over all interference across threads is inaccurate and should be avoided as much as possible.
.
iterative flow sensitive analysis we propose instead to partition the set of interferences from other threads into clusters and then consider combinations of interferences only within these clusters.
in this way we effectively delay the join of interferences and avoid the inaccuracies caused by eagerly joining in existing methods.
for example if we assume the three interferences in figure fall into one cluster worst for efficiency but best for accuracy our analysis of the program would be as follows in the first iteration we apply per thread abstract interpretation and then compute the interferences for each thread these computations remain the same as in the first iteration of table .
in the second iteration however when analyzing thread at the point of reading flag there will be six possible cases due to the cartesian product of x f0 5gand ag f0 1g.
unlike prior approaches which eagerly join these cases to form x f0 5g ag f1 0g we analyze the impact of each case 6individually as follows corresponding to x ag corresponding to x ag corresponding to x ag corresponding to x ag corresponding to x ag and corresponding to x ag .
this leads to enough accuracy to prove the error!
is not reachable.
first when ag and the error!
cannot be reached since the branch at l10will not be taken b1isfalse .
second in the case of the first branch at l10will be taken but the branch guarding error!
will not since x meaning t1is also .
for the two remaining cases 5and our constraint based interference analysis section would show it is impossible to have bothx ag orx ag .
the intuition behind the analysis is that infeasible data flows cause a contradiction between program order constraints and dataflow edges.
specifically examining if line reads flag as1 and line reads xas4 then line is executed before line b1 true line is executed before line program order line is executed before line t1 and line is executed before line program order .
this leads to a contradiction since the above must happen before relationship forms a cycle meaning the combination cannot happen.
similarly 6is infeasible since the write of to flag implies the updates to xhave already occurred meaning x s initial value is not visible to thread .
at this point the only feasible interferences do not cause an error!
the program is verified.
to obtain the aforementioned accuracy we leverage the statically computed control and data dependencies to partition the set of interferences into clusters.
this can significantly reduce the number of cases considered during our thread modular analysis.
for example when a load of yisindependent of the subsequent load of x e.g.
the value loaded from yhas no effect on the load of x the thread would have two unconnected subgraphs in its program dependence graph .
unconnected subgraphs create a natural partition of loads into clusters thereby significantly reducing the complexity of our interference feasibility checking.
this is because we only need to consider combinations of interferences within each subgraph.
we will show details of this optimization in section .
.
control flow versus data flow graphs our method also differs from duet a concurrent static analyzer for parametric programs .
although duet also employs a constraint based analysis its verification problem is significantly different.
first it is designed for soundly analyzing parameterized concurrent programs where each thread routine may have an unbounded number of instances.
in contrast our method is designed to analyze programs with a fixed number of threads with the goal of obtaining more accurate analysis results.
second duet relies on running an abstract interpreter over a single data flow graph of the entire program whereas our method relies on running abstract interpreters over a set of thread local controlflow graphs.
the difference between using a set of thread local control flow graphs and a single monolithic data flow graph can be illustrated by the following two threaded program x tmp x .
in the monolithic data flow graph representation there would be cyclic data flow edges between the read and write of xacross threads as well as an edge from the write of xto itself.
as a result applying a standard abstract interpretation based analysis would lead to the inclusion of tmp 1as a possible value despite that in any concrete execution of the program the end result is either tmp 1ortmp assume that x 0initially .
our method in contrast can correctly handle this program.
.
background we provide a brief review of abstract interpretation based static analysis for sequential and concurrent programs.
for a thorough treatment refer to nielson and nielson and min .
.
sequential abstract interpretation an abstract interpretation based static analysis is a fix point computation in some abstract domain over a program s control flow graph cfg .
the cfg consists of nodes representing program statements and edges indicating transfer of control between nodes.
due to their one to one mapping we interchangeably use the term statement and node.
we assume the graph has a unique entry.
the analysis is parameterized by an abstract domain defining the representation of environments in the program.
an environment is an abstract memory state.
the purpose of restricting the representation of memory states to an abstract domain is to reduce computational overhead and guarantee termination.
for example in the interval domain each variable has an upper and lower bound.
for a program with two variables xandy an example environment is x y .
with properly defined meet u and join t operators a partial order w as well as the top and bottom ?
elements the set of all possible environments in the program forms a lattice.
in the interval domain for example we have t and w .
each statement in the program is associated with a transfer function taking an environment as input and returning a new environment as output.
the transfer function of statement stfor some input environment ereturns a new environment e0 which is the result of applyingstine.
consider the above example of interval domain forxandyagain.
the result of executing the statement x x y in the above example environment would be the new environment x y .
for brevity we will not define all the transfer functions for a programming language explicitly since the main contributions of this work are language agnostic.
as an example however consider the statement t load x which copies a value from memory to a variable.
its transfer function can be represented as e e t x wheree is the result of evaluating stin the environment e. conceptually it takes an input environment and returns a new environment where tis assigned the current value of x. algorithm sequential abstract interpretation.
function seqabsint g the control flow graph env n is initialized to ifn2entry g else to?
wl entry g while9n2wl wl wlnfng e transfer n env n for alln02succs g n such thate6venv n0 env n0 env n0 te wl wl fn0g return env the standard work list implementation of an abstract interpretation based analysis is shown in algorithm .
the input is a controlflow graphg where entry g is the entry node and succs g n is the set of successors of node n.env is a function mapping each nodento an environment immediately before nis executed.
the initial environment associated with the entry node means that all program variables can take arbitrary values e.g.
x y for integer variables.
the initial environments for all other nodes are set to?
the absence of values .
the work list wl is initially populated only with the entry node of the control flow graph.
the fix point computation in algorithm 1is performed in the while loop a node n2wl is removed and has its transfer function executed resulting in the new environment e. the function transfer takes a node nand the environment env n as input and returns the new environment e result of executingninenv n as output.
if a successor of the node nhas a current environment with less information than e as determined by 6v then it is added to the work list and its environment is expanded to include the new information lines .
the process proceeds until the work list is empty i.e.
all the environments have stabilized.
standard widening and narrowing operators may be used at line to guarantee termination and ensure speedy convergence.
.
thread modular abstract interpretation next we review thread modular abstract interpretation an iterative application of a sequential abstract interpreter on each thread in the presence of a joined set of interferences from all other threads.
since a thread modular analysis never constructs the product graph of all threads in the program it avoids the state space explosion encountered by non thread modular methods .
first we make a slight modification to the previously described sequential abstract interpretation algorithm the per thread abstract interpretation must consider both the thread local environment and the interferences from other threads.
here an interference is an environment resulting from executing a shared memory write.
let seqabsint modified g i be the modified abstract analyzer which takes an additional environment ias input.
the environment irepresents a joined set of interferences from all the other threads.
we also modify the transfer function transfer n env n of shared memory read as follows for t load x where xis a shared variable we allow tto read either from the thread local environmentenv n or fromi the interference parameter.
for example if the thread local environment before the load statement contains x and the interference parameter contains x we would have t t .
algorithm thread modular abstract interpretation.
function thread modabsint gs the set of cfgs te ?
i ?
repeat i0 i for allg2gs i ffeje2i g0 g02gs andg06 gg.sec.
.
env seqabsint modified g i te te env for all n e 2te ifnis a shared memory write in g2gs i g i g ttransfer n e untili i0 return te algorithm shows the thread modular analysis procedure.
the input is the set gsof control flow graphs one per thread.
the output te is a function mapping the thread nodes nodes in all threads to environments.
during the analysis each thread local cfg ghas an associated interference environment i g the environment is the join of all environments produced by shared memory writes in the threadg.
due to their one to one correspondence we will use thread and its control flow graph interchangeably.
inside the thread modular analysis procedure both teandiare initially empty.
then the sequential abstract interpretation procedure is invoked to analyze each thread g2gs.
the environment i line is the join of all interfering environments from other threads.
the sequential analysis result env is a function mapping nodes ingto their corresponding environments.
with a slight change ofnotation we use te env line to denote the join of environments fromteandenv on their matching nodes.
let aandbbe sets of pairs of the form f n e g thena bdenotes the join of environments on the matching nodes.
after analyzing all the threads lines we take the results te and compute the new interferences for each thread g the new environment i g is the join of all environments produced by the shared memory writes lines .
the analysis repeats until the interferences stabilize i i0 meaning that environments in all node te also stabilize.
again standard widening and narrowing operators may be used to ensure speedy convergence.
overall the thread modular analysis is an additional fix point computation on the set of interferences relative to sequential analysis with the same termination and soundness guarantees .
.
flow sensitive thread modular analysis in this section we present our new method for flow sensitive thread modular analysis.
for ease of comprehension we shall postpone the presentation of the constraint based feasibility checking until section while focusing on explaining our method for maintaining inter thread flow sensitivity during thread modular analysis.
.
the new algorithm before diving into the new algorithm notice that the reason why algorithm is flow insensitive is because all environments from interfering stores of other threads are joined line prior to the thread modular analysis.
furthermore within the thread modular analysis routine seqabsint modified the combined interfering environment i is joined again with the thread local environment during the application of the transfer function at each cfg node.
such eager join operations are the main sources of inaccuracy in existing methods.
first inaccuracy arises from the join operation itself it tends to introduce additional behaviors e.g.
t .
second a thread is allowed to see any combination of interfering stores even if some of them are obviously infeasible e.g.
section figure .
to avoid such drastic losses in accuracy we need to make fundamental changes to the thread modular analysis procedure.
for each thread g2gs instead of defining its interference as a single environment we use a set of pairs n e wherenis a cfg node of a shared memory write and eis the environment after n. for each shared variable read instead of it reading from the eagerly joined set of environments we maintain a set lis l f n e g where each n e represents an interfering store and the store s interfering environment.
for each thread g2gs instead of representing the interferences from all other threads as the join of the interfering environments line algorithm we represent them as a set icof interference combinations eachic2icis a distinct combination of the store to load flows for all l2loads g .
algorithm shows our new analysis in the remainder of this section we shall compare it with algorithm and highlight their differences.
there are two main differences.
first the interferences are represented as a set of pairs of store statements and their associated environment line .
we modify to be the join of environments of pairs with matching nodes across two sets.
recall that if aand bare sets of pairs of the form f n e g thena bdenotes the join of environments on the matching nodes.
second we compute the seticof feasible and non redundant interference combinations store to load flows for a thread line and analyze a thread in the presence of each combination individually lines .
that is for each call to the sequential abstract interpreter seqabsintmodified as the second parameter instead of passing the join ofalgorithm flow sensitive thread modular analysis.
function thread modabsint flow gs the set of cfgs te ?
i ?
repeat i0 i for allg2gs ic interference combo feasible g i for allic2ic .sec.
env seqabsint modified g ic te te env for all n e 2te ifnis a shared memory write in g2gs i g i g ftransfer n e g untili i0 return te function interference combo feasible g i ic ?
ves f n e j n e 2i g0 g02gs andg06 gg for alll2loads g lis l f sdummy eself g iflis not self reachable for all n e 2ves ifloadvar l store var n lis l lis l f n e g else .handling loads in loops for all n e 2ves if loadvar l store var n musthappen before l n lis l lis l f sdummy e g es cartesian product lis .sec.
for allic2es ifquery .isfeasible ic .sec.
ic ic ficg return ic interferences from all other threads we pass each ic2icto map every load to an interfering store individually.
.
the interference combinations inside interference combo feasible g i we compute the seticof feasible interference combinations.
here loads g is the set of shared variable reads in thread g loadvar l is the variable used in the load instruction l and store var s is the variable stored to in the store instruction s. we first compute the set ves of interferences from other threads line each pair n e 2ves is a store and environment from a thread other than g. then we pair each load l2loads g with any corresponding store in ves lines the result is stored in liswhich maps each load instruction lto a set of stores in the form of n e pairs.
the special pair sdummy eself indicates the thread should read from its intra thread environment.
for now ignore lines since they are related to the handling of loops we discuss how loops are handled during the computation of interference combinations in the next subsection.
next the function cartesian product takes lis as input and returns the complete set of interference combinations from lis l1 lis lk .
to make what we have explained so far clearer consider an example program with two threads g1and g2.
threadg1has two loads loads g1 fl1 l2gsuch that loadvar l1 xandloadvar l2 y. threadg2has three interfering environments two on x s1ands2 with associated environments e1ande2 respectively and another s3 ony with environmente3.
assume we are currently analyzing g1in the presence of interferences from g2.we first use the set iof interferences to collect the interferences fromg2inves f s1 e1 s2 e2 s3 e3 g. next we compute lisfor the two loadsfl1 l2gin threadg1.
we pairl1with the two interferences on xfroms1ands2 and pairl2with the single interference on yfroms3.
using to denote a list of items we represent the result as lis l1 and lis l2 .
without any optimizations the resulting cartesian product es lis l1 lis l2 would contain the following items ic1 fhl1 s1 e1 i hl2 s3 e3 ig ic2 fhl1 s2 e2 i hl2 s3 e3 ig ic3 fhl1 sdummy eself i hl2 s3 e3 ig ic4 fhl1 s1 e1 i hl2 sdummy eself ig ic5 fhl1 s2 e2 i hl2 sdummy eself ig ic6 fhl1 sdummy eself i hl2 sdummy eself ig for each combination ic2es we check if it is feasible lines the infeasible combinations will be filtered out and the result ic is returned.
we discuss how we determine the feasibility of an interference line in section .
continuing with the algorithm s description on line the sequential abstract interpretation seqabsint modified takesgand eachic2icas input and returns a node to environment map env as output.
during this per thread analysis the transfer function of a load uses only icto determine the environment to use.
when a loadl1is being executed if the special item hl1 sdummy eself iis inic the load reads from its own thread local environment at l1 if the remote store environment hl1 s e iis inic the load also reads from the remote environment e. at this point we have improved the prior work algorithm to avoid inaccuracies from over approximations caused by the eager join over all interferences.
the cost for this accuracy is explicitly testing each of the combinations of potential interferences.
however we have not presented our methods for clustering and pruning section as well as checking if any of the combinations are infeasible section .
by applying such optimization techniques we cannot only drastically reduce the overhead of running the abstract interpretation subroutine but also increase the accuracy.
.
handling loops since a load within a loop may execute many times the number of stores it could read from may be infinite.
to guarantee termination we join all the interfering stores that may affect a load in a loop with the environment within the thread at the time of the load.
by this we conservatively treat all these feasible interferences in a flow insensitive manner for loads within loops.
specifically lines perform the join of interferences for loads within a loop.
for a given load all stores on the same variable that must not happen after the load are considered we will further discuss the happens before constraints in section .
for these conflicting stores all of the environments are joined together on a single dummy node sdummy .
in the end each self reachable load has a single joined environment.
consequently during the cartesian product computation it will have a single interference.
within the sequential abstract interpreter the load merges the threadlocal environment and this single interfering environment.
however even in such case our new method is more accurate than the prior work.
consider the example in figure .
thread executes a load in a while loop running an arbitrary number of times concurrently with thread before creating thread .
because of the thread creation there is a must happen before edge between the load in thread line and the write in thread to x. when constructing the interference combinations for the load in thread l there are three potential stores s10 s11 ands14for the writes toxon lines and respectively.1int x 2void thread1 create thread2 while int t1 x create thread3 9void thread2 x x void thread3 x figure example handling loops in thread modular analysis.
when considering s10 the condition on line of our new algorithm is true since s10does not always happen after l and similarly for s11 .
therefore lis l is assignedfsdummy e10ginitially where e10is the environment at s10.
next lis l is assigned fsdummy e10te11g.
finally for s14 since it must happen after l it is not added to lis.
when computing the cartesian product there is only a single load with a single location store pair so there is only one interference combination.
for this example the analysis results in t1being or .
the value of 10written by thread is excluded using the musthappen before constraint.
so although multiple interfering stores are merged for the single load within the loop the accuracy of the analysis is still higher than prior flow insensitive analyses.
.
correctness our method in algorithm is a form of semantic reduction of the interferences allowed by the prior flow insensitive approach in algorithm .
specifically the input environment to a load instruction in algorithm is the join of the set s f ngwhere is the intra thread environment and nare environments from interfering stores.
the semantic reduction operator we use in algorithm is to apply the transfer function of the load to each element ofsindividually relative to all other loads i.e.
the cartesian product .
therefore the correctness of our algorithm directly follows the correctness argument in .
additionally we remove infeasible interferences combinations lines which does not affect the soundness of the algorithm.
in the case of loops the transfer function of a load can be executed more than once each execution of the transfer function may use a different interference so using the same semantic reduction operator would have resulted in a potentially infinite number of interference combinations.
in this case we conservatively merge all the feasible interferences into a single value.
correctness of this treatment directly follows the correctness of algorithm .
in the case of aliasing our algorithm can be lifted to use the output of any sound alias analysis by considering each alias set as a single variable it is a standard technique to handle aliasing in static analysis.
in such case our algorithm would operate on these alias sets instead of on the individual program variables.
.
constraint based feasibility we now present our procedure for eliminating infeasible combinations of interferences.
we revisit algorithm to show its integration with our new thread modular analysis procedure.
removing infeasible interferences from the thread modular analysis significantly reduces computational overhead and increases accuracy.
however the main problem is that the feasibility checking has to be conducted efficiently for such an optimization to be useful.
therefore our goal is to make the checking both sound andefficient .
by sound we mean that if the procedure determines a combination is infeasible then it is truly infeasible.
by efficient we mean that the procedure relies on constructing and solving a system of lightweight constraints i.e.
horn clauses in finite domains whichcan be decided using a datalog engine in polynomial time.
algorithm constraint based feasibility checking.
pos program order constraints gs q uery .add pos function query .isfeasible ic permutation of interferences cs reads from constraints ic q uery .add cs res query .satisfiable q uery .remove cs returnres algorithm shows the high level flow of our feasibility analysis procedure.
initially we traverse the set gsof control flow graphs to compute a set pos of constraints representing the order between statements which must hold on all possible executions of the program.
we initialize the constraint system with these orderings by calling q uery .add pos .
during the execution of algorithm lines for each ic2ic we compute a set csofreads from constraints which must be enforced in order to realize the interference combination ic.
we add them to the system as well by calling q uery .add cs .
our constraint analysis then using a set of deduction rules expands upon these input constraints to generate more constraints.
we invoke query .satisfiable to check if the constraint system is satisfiable.
the deduction rules are designed such that if the system is not satisfiable then icis guaranteed to be infeasible.
in the remainder of this section we go into each of these steps in detail.
.
the program order and the reads from constraints to check the simultaneous feasibility of pos andcs we first compute the dominators on a thread s cfg.
given two nodes mand nin a graphg mdominatesnif all paths from the entry of gton go throughm.
then we define the following relations dominates is the dominance relation on a thread s cfg m n 2dominates meansmdominatesn.
notreachable from is reachability on a thread s cfg m n 2notreachable from means nodemcan not be reached from noden.
thcreates is a parent child relation over threads p n sta thcreates ifpis thread creation point and nstais the child thread s start node.
thjoins is a parent child relation over threads p n end thjoins meanspis a thread join on a child thread with node nend as exit.
l v 2isload meanslis a load of variable v. s v 2isstore meanssis a store to variable v. reads from is obtained from the combination icunder test l s 2reads from if the loadlis reading from the store s. all these relations can be computed from the given set gsof controlflow graphs efficiently .
furthermore they are defined over finite domains sets of nodes or variables which means constraints built upon these relations are efficiently decidable.
.
deduction rules for checking feasibility figure shows the deduction rules underlying our feasibility analysis.
if a contradiction is reached after applying the rules to the input constraints the interference combination is guaranteed to be infeasible.
for brevity we only present the intuition behind these rules.
detailed proofs can be found in our supplementary material.
rules and create the must happen before relation mhb where m n 2mhb means node mmust happen before node n under the current interference combination ic.
rule is simply the transitive property for the must happen before relation.
m n 2dominates m n 2notreachable from m n 2mhb m n sta 2thcreates m n sta 2mhb m n end 2thjoins nend m 2mhb s2 v 2isstore l v 2isload s1 v 2isstore l s1 2reads from s1 s2 2mhb l s2 2mhb a b 2mhb b c 2mhb a c 2mhb a b 2mhb a b 2mustnotreadfrom l1 v 2isload l2 v 2isload s2 v 2isstore l1 s1 2reads from l1 s2 2mhb s2 l2 2mhb l2 s1 2mustnotreadfrom figure rules used by our interference feasibility analysis.
s1 v s2 v l l v figure example application of rule .
first ifmdominatesnin a cfg since moccurs before non allprogram paths mmust happen before n rule .
we check if ncan reachmto ensure that even if mdominatesn mcan never subsequently occur after n e.g.
ifnis in a loop .
similarly since a thread cannot execute before it is created or after it terminates thcreates and t hjoins also map directly to mhb rule .
rule captures the scenario of two stores overwriting each other as shown in figure .
here one thread has stores s1ands2 and a second thread has one load l.reads from l s1 is represented by the dashed edge flow of data from s1tol.mhb s1 s2 is represented by the solid edge from s1tos2.
given the two previous relations the rule deduces the relation mhb l s2 represented by the red dotted edge.
the implication is that for load lto read from the first store s1 lmust happen before the second store s2.
the intuition behind this rule is that if s2executes before l then s2would overwrite the value of s1 making it impossible for lto read the value of s1.
note that this must happen before constraint is only considered for ic the current combination of interferences it does nothold globally across all executions of the program.
rule introduces the mustnotreadfrom relation.
for a load store pair l s 2mustnotreadfrom if in the current interference combination lcannot read from s. rule prevents a thread from reading an interference after it has been over written shown in figure .
the first thread has a store s1 and the second thread has load l1 stores2 and then load l2.
again mhb relations are represented by solid edges reads from l1 s1 is represented by the dashed edge and mustnotreadfrom l2 s1 is represented by the red dotted edge.
conceptually the rule captures the situation when a value is read from an interference l1 l1 s followed by a modification of the same memory location that was loaded s2 s l1 followeds1 s l1 l1 s s2 s l1 l2 l2 s figure example application of rule .
l4 x l9 b1 flag l5 x l11 t1 x l6 flag true figure input and implied constraints for figure .
by a load of the same location l2 l2 s .
intuitively since the interfering value was just overwritten it cannot be loaded again.
therefore the pair l2 s1 is added to m ustnotreadfrom .
finally our constraint analysis does not try to identify all infeasible combinations for efficiency reasons.
however the framework is generic enough to allow new rules and other types of constraint solvers to be plugged in easily to refine the approximation.
.
the running example we revisit the example in figure to illustrate our feasibility checking for one interference combination figure .
our goal is to decide if reads from l9 l6 andreads from l11 l4 can co exist.
initially our constraint system would have the solid edges from the mhb relations which represent the program order constraints and the dashed edges from the reads from relations which represent the current interference combination ic.
first we can deduce mhb l11 l5 by applying rule if l11 does not happen before l5 l5would overwrite the value of x preventingl11from reading from l4.
this deduced mhb relation is represented by the red dotted edge in the figure.
next we can deduce a must happen before relation between l9andl6by applying rule twice.
that is mhb l9 l11 mhb l11 l5 implies mhb l9 l5 followed by mhb l9 l5 mhb l5 l6 implies mhb l9 l6 .
the result is represented by the red dotted edge from l9tol6.
at this point we have a contradiction since b1 flag musthappen before flag true b1cannot read the value of true rule .
so this interference combination is proved to be infeasible.
there are more implied edges in figure for clarity we show only those relevant to the check.
.
optimizations with clustering and pruning to reduce the number of interference combinations we apply dependency based clustering analysis and property directed pruning.
consider the program in figure the main thread creates two children in the function thr with arguments 5and10 respectively.
thethr function performs a store to x line based on the value passed as an argument v .
at the load of xin the thr function the value may come from the initial value from the main thread line or from the other thread thr line .
this results in three combinations of loads in thr to be tested on every iteration.
however the reachability of error!
does notdepend on the value loaded from x since the error condition t1 only de 1int x 2void thr int v int t1 v int t2 x x t1 t2 if t1 error!
9int main thread create thr thread create thr x thread exit figure example property directed redundancy pruning.
thread int t1 v int t2 x x t1 t2 if t1 main thrd create thr thrd create thr x thrd exit error!
figure the program dependence graph for figure .
pends on the argument passed to thr.
as such the load of xis immaterial to the property.
we can formally capture this notion of immateriality using control and data dependencies .
intuitively a statement sis data dependent on tif the value oftmay affect the computation of s. for example in figure the statement t1 vis data dependent on the input parameter v. on the other hand a statement lis control dependent on m if the execution of maffects the reachability of l. for example theerror!
statement in figure is control dependent on the evaluation of the predicate t1 .
the composition of the control and data dependency relations is the program dependence graph .
note that in concurrent programs the dependency graph may span across multiple threads due to the flow of data from shared memory writes to reads.
next we show two applications of the program dependence graph for optimizing our overall algorithm.
.
property guided pruning first we create the backward slice on every property in the program.
the backward slice with respect to a property scontains all the statements involved in the computation of s theorem .
.
as an example the program dependence graph for figure is shown in figure .
dashed edges are control dependencies and solid edges are data dependencies.
the backward slice on the error!
statement is also shown the dotted nodes are nodes not contained in the slice.
all computations involving xcan be ignored since the slice shows that they are irrelevant to the property being verified.
during our analysis the transfer function of a statement not on the backward slice is the identity .
and any load not on the backward slice is ignored when computing interference combinations.
.
dependency guided clustering second during the generation of combinations of interferences we do not always consider the cartesian product across all sets of loads.
instead we group loads together to form cluster and only generate interference combinations within each cluster.
consider the program in figure .
initially xandyare zero the first thread sets them to one and the second thread checks the property that they are both greater than or equal to zero.
the backward slice on assert x contains lines and .
the backward slice on assert y contains lines and1int x 2int y 3void thread1 x y 7void thread2 int t1 x int t2 y assert x assert y figure example dependency guided clustering.
.
without optimization in algorithm the loads on xandyboth have two potential environments to read from the interfering store and the environment within the thread.
in total there are combinations leading to four abstract interpreter executions.
the backward slices on properties in the program form disjoint subgraphs e.g.
a graph with the operations on xand those on y. the interference combinations in the subgraphs can be considered independently requiring only max interpreter executions.
.
experiments we implemented our method in a software tool named watts designed for verifying multithreaded programs represented in the llvm intermediate language.
all experiments were performed on c programs written using posix threads.
we used the apron library for implementing the sequential analyzer over interval and octagon abstract domains and the datalog solver in z3 z for solving the causality constraints.
we evaluated watts on two sets of benchmark programs.
the first set consists of some multithreaded programs from svcomp .
the second set consists of linux device drivers from and .
in all benchmark programs the reachability properties are expressed in the form of embedded assertions.
table shows the characteristics of these programs including the name the number of lines of code loc the number of threads and the number of assertions.
in total our benchmarks have lines of code and assertions.
for the device driver benchmarks in particular since assertions are not included in the original source code we manually added these assertions.
we performed all experiments on a computer with gb ram and a .
ghz cpu.
although we used the benchmarks from the verification problem targeted by our method is significantly different.
duet assumes each device driver is a parametric program whereas our method analyzes programs with a finite number of threads.
as shown in section our method using a set of control flow graphs as opposed to a monolithic data flow graph is often more accurate.
during experiments we ran both watts andduet on all benchmarks with our assertions.
watts verified more properties than duet whereas duet did not verify any property not verified by watts .
the result shows that duet s abstraction for infinite threads leads to loss of precision.
therefore in the remainder of this section we do not directly compare w atts with d uet.
instead we focus on comparing our method with the prior threadmodular approaches .
for evaluation purposes we implemented both methods in watts the flow insensitive analysis of algorithm and the flow insensitive analysis of algorithm .
table shows the results of comparing algorithm and algorithm in the interval abstract domain.
column shows the name of each benchmark.
columns show the result of running algorithm .
columns show the result of running algorithm without using the feasibility checking.
columns show the result with the feasibility checking.
columns show the result with clustering pruning optimizations.
for each test case tm.
is the run time in seconds and verif.
is the number of verified properties.
the last row shows the sum of all columns.
compared to the flow insensitive approach columns ourtable statistics of the benchmarks in our experiments.
name loc threads properties source thread01 created create01 created create02 created sync01 sync02 intra01 created dekker1 fk2012 added asserts keybisr ib700 01 added asserts ib700 02 added asserts ib700 03 added asserts i8xxtco 01 added asserts i8xxtco 02 added asserts i8xxtco 03 added asserts machz 01 added asserts machz 02 added asserts machz 03 added asserts mix 01 added asserts mix 02 added asserts pcwd 01 added asserts pcwd 02 added asserts sbc 01 added asserts sc1200 01 added asserts sc1200 02 added asserts smsc 01 added asserts smsc 02 added asserts sc520 01 added asserts sc520 02 added asserts wfwdt 01 added asserts wfwdt 02 added asserts wdt added asserts wdt977 01 added asserts wdt977 02 added asserts wdt pci added asserts wdt pci02 added asserts pcwdpci 01 added asserts baseline flow sensitive method columns can already achieve a 12x increase in the number of verified properties from to without employing the lightweight constraint based feasibility checking.
this demonstrates the benefits of delaying the join operation across threads.
furthermore the significant increase in accuracy comes at the modest .5x increase in run time.
with the constraint based feasibility checking a more significant improvement can be observed columns there is a 28x increase in the number of verified properties from to compared to the prior flow insensitive approach.
furthermore the large increase in accuracy comes with only an .6x increase in run time.
finally with the optimizations from section our method improves further columns .
compared to the prior flow insensitive approach columns our method only has a .4x increase in the runtime overhead but with a 28x increase in number of verified properties.
compared to the version of our method without optimizations columns the version with optimization finishes the entire analysis .4x faster.
additionally the optimized version finishes slightly faster than the non constraint based approach columns while able to verify .4x as many properties.
note that across all experiments the number of verified properties are strictly increasing e.g.
the flow sensitive approach with optimizations verifies all the properties of the flow insensitive approach and more.
at most we were able to verify properties.
those we missed largely were due to cross thread synchronization which was not captured by our constraint analysis.
in addition to the results in table we also performed experiments using the octagon abstract domain.
we observed little increase in accuracy as a result of this change indicating that the propertiestable experimental results in the interval domain.
flow insensitive flow sensitive f. s. const.
f. s. opt.
name tm.
s verif.
tm.
s verif.
tm.
s verif.
tm.
s verif.
thread01 .
.
.
.
create01 .
.
.
.
create02 .
.
.
.
sync01 .
.
.
.
sync02 .
.
.
.
intra01 .
.
.
.
dekker1 .
.
.
.
fk2012 .
.
.
.
keybisr .
.
.
.
ib700 01 .
.
.
.
ib700 02 .
.
.
.
ib700 03 .
.
.
.
i8xxtco 01 .
.
.
.
i8xxtco 02 .
.
.
.
i8xxtco 03 .
.
.
.
machz 01 .
.
.
.
machz 02 .
.
.
.
machz 03 .
.
.
.
mix 01 .
.
.
.
mix 02 .
.
.
.
pcwd 01 .
.
.
.
pcwd 02 .
.
.
.
sbc 01 .
.
.
.
sc1200 01 .
.
.
.
sc1200 02 .
.
.
.
smsc 01 .
.
.
.
smsc 02 .
.
.
.
sc520 01 .
.
.
.
sc520 02 .
.
.
.
wfwdt 01 .
.
.
.
wfwdt 02 .
.
.
.
wdt .
.
.
.
wdt977 01 .
.
.
.
wdt977 02 .
.
.
.
wdt pci .
.
.
.
wdt pci02 .
.
.
.
pcwdpci 01 .
.
.
.
total .
.
.
.
being verified are mostly on inter thread concurrency control behavior and therefore a more sophisticated representation of numerical relations over the program variables does not offer more advantages.
for brevity we omit the result table for the octagon domain.
in the past introducing flow sensitivity to static analysis often results in scalability issues e.g.
however this is not the case for our method.
figure shows our experiments on a parametrized program named i8xx tco where the run time of our method grows only moderately with the increase in program size.
here the x axis is the number of threads of the program and the y axis is the run time.
the optimized method has slightly lower runtime than the least accurate flow insensitive approach.
furthermore our method enjoys an almost linear growth in the execution time indicating it is more scalable than the other methods.
.
related work there is a large body of work on the static analysis and formal verification of multithreaded programs but none of these existing methods can obtain flow sensitivity in thread modular analysis with a reasonable run time cost.
for brevity we discuss only those that are most relevant to our new method.
the interested reader can see rinard for a survey of early work.
thread modular abstract interpretation was introduced by ferrara and min .
as shown their approaches eagerly joined interferences and considered them flow insensitively thus30 number of threadsruntime s flow insensitive flow sensitive f.s.
constr.
f.s.
constr.
opt.
figure runtime overhead versus number of threads.
introducing inaccuracies.
our method avoids such drawbacks.
ferrara also introduced models designed specific for the java memory model to remove certain types of infeasible interferences in anad hoc fashion.
our constraint based feasibility checking in contrast is more general and systematic and can handle transitive must happen before constraints as well as other constraints both within and across threads.
min introduced an extension to their prior thread modular analysis to compute relational interferences.
this allows for relations between variables to be maintained across threads thereby bringing more accuracy than using non relational interferences.
however as we have explained earlier this technique is orthogonal and complementary to our new method.
farzan and kincaid introduced a method to iteratively construct a monolithic data flow graph for a concurrent program.
however their technique as well as similar methods designed for parametric programs targets the problem of verifying properties in a concurrent program with an unbounded number of threads.
as we have shown earlier our new method is often significantly more accurate than these existing methods.
thread modular approaches have been applied to model checking and symbolic analysis .
there are also works on verifying concurrent software using abstraction and stateless model checking .
however these approaches in general are either heavyweight or under approximative and therefore are complementary to our abstract interpretation based approach.
.
conclusions we have presented a flow sensitive method for composing standard abstract interpreters to form a more accurate thread modular analysis procedure for concurrent programs.
our method relies on constructing and solving a system of happens before constraints to decide the feasibility of inter thread interference combinations.
we also use clustering and pruning to reduce the run time overhead of our analysis.
we have implemented our method in a software tool and evaluated it on a large set of multithreaded c programs.
our experimental results show that the new method can significantly increase the accuracy of the thread modular analysis while maintaining a modest run time overhead.
.