harnessing evolution for multi hunk program repair seemanta saha university of california santa barbara email seemantasaha cs.ucsb.eduripon k. saha mukul r. prasad fujitsu laboratories of america inc. rsaha mukul us.fujitsu.com abstract despite significant advances in automatic program repair apr techniques over the past decade practical deployment remains an elusive goal.
one of the important challenges in this regard is the general inability of current apr techniques to produce patches that require edits in multiple locations i.e.
multi hunk patches.
in this work we present a novel apr technique that generalizes single hunk repair techniques to include an important class of multi hunk bugs namely bugs that may require applying a substantially similar patch at a number of locations.
we term such sets of repair locations as evolutionary siblings similar looking code instantiated in similar contexts that are expected to undergo similar changes.
at the heart of our proposed method is an analysis to accurately identify a set of evolutionary siblings for a given bug.
this analysis leverages three distinct sources of information namely the test suite spectrum a novel code similarity analysis and the revision history of the project.
the discovered siblings are then simultaneously repaired in a similar fashion.
we instantiate this technique in a tool called h ercules and demonstrate that it is able to correctly fix bugs in the defects4j dataset the highest of any individual apr technique to date.
this includes multihunk bugs and overall bugs which have not been fixed by any other technique so far.
index t erms automatic program repair multi hunk patches code similarity i. i ntroduction the past decade has seen significant research activity on automatic program repair apr techniques .
these techniques bear the promise of helping automate the otherwise laborious process of debugging and patching bugs.
however this promise is yet to be realized in terms of practical deployment of apr techniques.
one reason for this is perhaps the relatively limited classes of bugs that current state of the art apr techniques can correctly fix .
in particular with one notable exception most apr techniques are designed to target single hunk bugs bugs with patches confined to a single contiguous chunk of code at a single location.
however the vast majority of bug patches span multiple hunks.
for instance of the bugs in the defects4j dataset and of bugs in the bugs.jar dataset require multi hunk patches.
several previous works have acknowledged the challenges of multi hunk repair .
any simple minded expansion of the search space to explore general multi hunk patches would clearly explode the repair search space.
this work was done when the author was an intern at fujitsu laboratories of america inc.given a buggy program p failing at least one test in a test suite t an apr tool implicitly or explicitly searches a space sof possible mutations to pfor one that allows the mutated program to pass all tests in t. in this work we propose an apr technique that targets a specific but important class of multi hunk repair problems.
our solution is broadly inspired by insights from two bodies of research.
the first is research on detecting and using code clones .
this research shows that code clones are plentiful in programs.
typically and as much as of a subject system can be comprised of cloned code .
further replication of bugs through code clones is a common phenomenon.
up to of code clones contain bugs with of bugs found in code clones being replicated bugs .
the second body of work is apr techniques themselves the vast majority of which directly or indirectly exploit the plastic surgery hypothesis the ingredients for a repair can be obtained from existing code .
this can take the form of using program transformation schemas which define the repair space derived from a corpus of existing patches .
alternatively repair ingredients such as program elements expressions statements or whole snippets can be mined from existing code and re purposed for creating a patch .
these two bodies of work point to the phenomenon that it is plausible to find similar looking pieces of code across a project bearing similar kinds of bugs and warranting similar patches.
our work exploits this general insight as well.
our proposed method generalizes single hunk repair techniques to include bugs that may require applying a substantially similar patch at a number of locations i.e.
a multi hunk patch.
we term the underlying set of repair locations as evolutionary1siblings similar looking code instantiated in similar contexts that are expected to undergo similar changes over the lifetime of the codebase.
it is important to note as established in rq1 section vi a that these evolutionary siblings are not simply code clones in the traditional sense.
further our approach is orthogonal to use of the plastic surgery hypothesis which involves mining existing code donor for abstract schemas or concrete ingredients from which to compose the present repair the donee i.e.
a donor donee relationship.
by contrast our proposed analysis seeks to find evolutionary 1we use evolution as a metaphor for the environment i.e.
context of a piece of code in addition to the changes it undergoes over its lifetime.
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
siblings exposed by the current bug which can be repaired simultaneously and in a similar fashion.
this is in principle independent of the actual technique used to perform the repair and quite compatible with a donor donee repair mechanism.
the key to our approach is to be able to accurately identify evolutionary siblings for a given bug.
this presents the following technical challenges challenge evolutionary siblings are not simply code clones.
thus further analysis is required to expose the desired sibling relationships.
challenge the spectrum generated by the test cases may not expose or even cover all the sibling instances.
missing some of the siblings can produce a partial repair at best.
challenge any imprecision in identifying these siblings can be potentially fatal to identifying a successful repair.
again an under approximation can produce a partial repair at best.
also it is simply not computationally feasible to search the power set of an over approximate set of potential siblings.
at the heart of our proposed method is an analysis that uses three distinct sources of information to accurately identify evolutionary siblings suitable for repair for the bug at hand.
first it uses the test spectrum to implicate one or more of the siblings to provide a starting reference for the sibling identification.
second it identifies all siblings of the reference sibling that have syntactic similarity but also semantic similarity of their context.
this is done using a code similarity analysis that combines syntactic similarity with a limited scope data flow analysis to enforce similarity of the semantic context for identified siblings.
this code similarity analysis may in principle identify potential siblings that are outside the scope of the test spectra.
this is an essential feature of our analysis that compensates for the weakness and incompleteness of typical test suites.
developers may often not add test cases witnessing the bug for each of the siblings but rather only for some or only one of them.
third our method uses the revision history information to further enforce that the siblings thus identified bear a similar history of changes.
this third feature discards false positives that are not necessarily siblings in a co evolutionary sense.
once evolutionary siblings are identified they can be handed off to any repair algorithm that should enforce simultaneously generating a substantially similar repair modulo namespace variations for all siblings.
in principle any traditional repair tool could be suitably retrofitted to perform this part.
we have implemented the proposed technique in a tool hercules2and evaluated it on the widely used defects4j dataset.
in our experiments h ercules was able to correctly fix bugs the highest of any single apr technique so far.
this includes multi hunk bugs and overall bugs which have not been fixed by any other technique so far.
it is noteworthy that although not specifically discussed in or the implementations of acs and simfix are in fact capable of performing simple instances of multi2our tool kills multi location bugs like the mythical hercules killed the multi headed monster hydra.hunk repair.
the bug repair counts reported in and include such bugs.
specifically these tools perform multihunk repairs when there are separate test cases separately implicating each bug location.
then the tool simply iteratively repairs these bugs independently one after another.
this potentially increases the search space exponentially in the number of locations but still turns out to be viable for the simplest instances.
by contrast our approach is much more general exploiting the sibling relationship to keep the search space effectively the same as a single location patch.
it also patches locations not covered by the test spectrum.
angelix also performs multi hunk repairs but again it does not exploit any relationship between the patched locations.
the main contributions of this paper are t echnique an apr technique generalizing traditional single hunk repair to bugs that may require applying a substantially similar patch at a number of locations analysis an analysis implementing accurate detection of evolutionary siblings in service of the above repair goal t ool an instantiation of the proposed repair technique in a tool h ercules evaluation an evaluation of h ercules on the defects4j dataset the rest of the paper is organized as follows.
section ii presents basic background material to orient the reader followed by a motivating example illustrating our approach in section iii.
section iv presents our proposed approach in detail.
sections v and vi present our experimental set up and evaluation respectively.
section vii discusses the limitations of our approach.
followed by a dicussion of related work in section viii.
section ix concludes the paper.
ii.
t erminology terminology definition in this paper we consistently use the following terminology and definitions.
single vs. multi hunk bugs.
single hunk bugs require program edits insertions deletions or modifications at a single location or a set of contiguous locations.
multi hunk bugs require program edits at multiple non contiguous locations.
repair location.
a program statement that we want to modify delete or insert a new statement.
it should be noted a repair location may or may not be the actual buggy location.
repair schema.
an abstract program transformation template such as adding a null checker or inserting a method invocation to a given repair location.
candidate patch.
a concrete modification to a program realized by instantiating a repair schema.
repair space.
the pool of generated candidate patches.
the size of the repair space refers to the number of generated candidate patches.
plausible patch.
a plausible patch is one that simply passes all test cases in the test suite.
it should be noted that a plausible patch may still be incorrect because the test suite may provide an incomplete specification.
correct vs. incorrect patch.
we classify a patch as correct if it is semantically equivalent to the developer provided patch authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
based on a manual examination.
this is consistent with the definition used in previous work .
an incorrect patch is a patch that is not correct.
generate and v alidate repair approach search based repair approaches or so called generate and validate g v approaches start with a buggy version of the program a testsuite with at least one failing test case revealing the bug and one passing test case and a set of repair schemas or program mutations to use to repair the program.
a typical g v technique operates using the following basic steps step fault localization.
this step produces a ranked list of repair locations.
this step is typically realized using spectrum based fault localization sbfl techniques such as tarantula zoltar and ochiai .
step generate candidate patches.
the repair approach examines each repair location in the fault localization list and applies each of the repair schemas on this statement one at a time in some order to produce potential candidate patches .
the order of repair schemas may be decided using genetic algorithms random choice heuristically or using a machine learned model .
step selection of candidate patches and validation.
each candidate patch is evaluated against the test suite and if it passes is output as a plausible patch.
this step which is computationally expensive is generally optimized by first ranking candidate patches and selecting only a few of them for validation.
the validation step is further optimized by first testing a candidate patch against a subset of the suite e.g.
only failing tests before executing the complete suite.
iii.
m otiv ating example in this section we provide a brief overview of our approach with a motivating example presented in figure .
the example is a real world bug fix in apache commons math jira official bug id math which is also a bug instance math in the popular defects4j dataset.
the bug report says that brent optimizer was not always reporting the best point.
as we can see in figure the assigned developer made two similar modifications at two locations to fix the bug and the modifications are not trivial.
previously the method was returning an object instancecurrent from two locations but actually they should be a method call best current previous isminim at each location.
now we discuss how h ercules fixes this bug while overcoming the research challenges outlined in section i. the repair locations may not be part of code clones.
from the developer s patch we can easily observe that although the statements at the repair locations are the same they are not code clones in a traditional sense.
this is because the respective statements around the repair locations do not match.
generally clone detection tools try to get a good tradeoff between the number of minimum statements tokens in a code snippet to be a clone to avoid producing a lot of false positives.
certainly we can detect clones at a statement level.
however in that case we would get many false positives.
for our example if we search the entire code base using return current we will get instances.
furthermore if we abstractthe identifier which is indeed required for multi hunk bugfix since the identifier names may vary in two snippets of code and search return x we will get many more similar statements.
therefore it is evident that the statement level similarity does not work here.
on the other hand if we use any traditional clone detection that uses a sliding window approach to detect clones using adjacent context these repair locations will not be part of any detected clone snippets.
in order to overcome the aforementioned problem h ercules uses the notion of semantic context instead of the syntactic neighborhood.
specifically h ercules uses reaching definition analysis section iv b3 to extract statements within the method boundary on which the statement at the repair location has a data flow dependence.
the extracted statements represent the semantic context of the repair location statement.
this mechanism also allows h ercules to associate a variable sized context with a repair location.
then hercules performs a deeper statement level ast analysis to determine syntactic similarity between the set of repair locations combined with their respective semantic contexts.
for example figure presents two contexts for two repair locations highlighted by blue and orange color.
for both hunks the context statements are physically far from the corresponding repair location.
even more interestingly they are interleaved.
for the first hunk the repair location is line number but its reaching definition is at line number .
for the second hunk its reaching definition line number is lines away from the repair location line number .
however after h ercules extracted the semantic context the two resulting code snippets become similar although not identical declaration vs. assignment .
however h ercules concludes that the both return statements are used in similar context based on the ast analysis.
weak specification and spurious repair locations.
it is well known that test suites typically do not cover every program location.
this issue has specific ramifications for multi location bug fixing.
for instance in the current example the failing test case covers the second location but not the first location.
therefore any repair tool that solely relies on test cases for identifying repair locations cannot generate the complete correct patch.
on the other hand if we apply program transformations in all the similar locations identified from the previous step it may not be appropriate either.
in order to find true evolutionary siblings h ercules extracts the revision history of the target repair locations and analyzes whether these lines were revised independent of one another.
for our example although the first repair location is not covered by any test case its revision history shows it was never modified independent of the second location.
this allows h ercules to confidently apply similar changes to both locations.
rich repair space.
another general limitation of g v approaches is dealing with an enormous number of candidate patches.
the number of candidate patches increases exponentially with the number of repair locations.
for example there are more than repair expressions that are valid in each repair location.
these repair expressions can be plugged into authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
univariate brentoptimizer.
java public class brentoptimizer extends baseabstractunivariateoptimizer univariatepointvaluepair current new univariatepointvaluepair x isminim ?
fx fx current new univariatepointvaluepair u isminim ?
fu fu if checker !
null if checker.converged iter previous cur rent return current return best current previous isminim else default termination brent s criterion .
return current return best current previous isminim iter fig.
the fix for math defects4j id with program context the program transformation schemas resulting in thousands of candidate patches.
even if we are fortunate enough to determine the correct program transformation and api call which itself is very difficult there can be valid concrete invocations of method call for different combinations of parameters.
for two locations the number of candidate patches would be .
these statistics illustrate the enormity of the repair space for multi hunk bug fixes and show why a naive approach would not work in such scenarios.
in order to overcome this problem h ercules employs a strategy of simultaneous repair of evolutionary siblings.
furthermore inspired by other existing approaches such as prophet and elixir h ercules uses machine learning techniques to rank and prune most of the candidate patches.
iv .
h ercules a. an overview figure presents the basic workflow of h ercules .g i v e n that there is a bug in a program p h ercules takes the source code of pwith its version history a test suite t with at least a failing test case and optionally a bug report and generates a correct single hunk or a multi hunk patch that fixesp in a successful run.
hercules works in four major steps to mutate pand eventually to generate a patch.
in the first step h ercules uses a spectrum based fault localization sbfl technique to identify potential repair locations.
for a given repair location in the second step h ercules identifies evolutionary siblings definition iv .
by leveraging reaching definition section iv b3 and version history analysis section iv b4 .
if such evolutionary siblings are found this step also produces the mapping between similar variables and objects among the evolutionary siblings.
it is worth noting that h ercules can also repair one hunk bugs.
therefore if a evolutionarysibling is not found for a particular repair location the rest of the steps are continued with only one repair location.
in the third step h ercules abstracts all the mapped variables and objects in all the repair locations and instantiates repair schema simultaneously.
after the patches are applied the abstract variables are reverted back to their original variables.
in the final step h ercules selects the top ncandidate patches for validation.
h ercules repeats these steps for each repair location by sbfl until a plausible patch is generated or timed out.
in summary h ercules adds a novel step in the repair process that is not available in any conventional g v approaches section ii .
we refer this step as repair localization i.e.
identifying the evolutionary siblings if they exist that require changes together to fix the bug.
b. identification of evolutionary siblings in this work by evolutionary siblings we mean the repair locations that are similar have used in a similar context have similar evolution history and at least one of the repair locations has been exercised by the fault reproducing test cases.
our motivating example in section iii already showed that a traditional clone detector is not sufficient to identify evolutionary siblings.
the fact is further supported by our results in section vi a. h ercules works in three steps to find evolutionary siblings.
since code matching especially at the ast level is expensive h ercules lazily applies the tree similarity algorithm first at the repair location level.
then only for similar repair locations h ercules extracts the relevant context and again applies the tree similarity algorithm for context.
finally h ercules leverages version history to find the evolutionary siblings with high confidence.
in the subsequent sections we concretely define evolutionary siblings and describe each aforementioned step in more detail.
preliminaries hercules represents and manipulates programs as abstract syntax trees ast to analyze programs authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
overview of h ercules .
and to instantiate repair schemas.
although the ast representation is standard its relevant terms and assumptions vary based on usage and thus deserve a concrete definition in our context.
in this section we formally define all the important terms in our context.
definition iv .
.
an abstract syntax tree ast is an ordered tree t where each node n represents a program element a method or a statement .
tis a tuple of g x r m where gis a context free grammer xis a finite set of nodes in the tree ris the root node and mmapsrto its each children.
we also assume that for each node there exists the following methods type n returns the type of a repair expression such as int or double kind n returns the kind of ast node such as statement or method invocation parent n returns the parent node of n andchildren n returns that children of n. it should be noted that the number of children nodes in nvary based on kind n for example a binary expression always has two children whereas a block may have an arbitrary number of statements.
furthermore we can also assume that all the subtrees under tare also asts for simplicity e.g.
an ast at statement level.
however in this case parent r negationslash null .
definition iv .
.
program spectra s is a set of ast nodes ns1 ns2 .. n sn such that nsi s kind nsi statement and exercised by the failing test cases.
definition iv .
.
arepair location rl is an ast node ns wherekind ns statement at a location l. definition iv .
.
context of relevance crl is a set of statements ns1 ns2 .. n sp rl with respect to a repair location rl such that nsi cr1 nsi rl true where is a reaching definition function.
definition iv .
.
edit history of a repair location hrl is a sequence of ast edit operations also known as program differences dci dcj ..d ck wheredci rl ci rl ci andcidenotes the ithcommit in version history.
definition iv .
.
evolutionary siblings erl with re spect to a repair location rlare a set of repair locations rl rl1 rl2 .. r ln such that rl sand rl rli e crl crli t1 hrl hrli t where and are two similarity functions and t1andt2are two user defined thresholds.
step identification of similar repair locations in order to find the evolutionary siblings erl with respect to rl first we compute the similarity between rland each location ri in program spectra s. the intuition is that if the repair locations do not match there is no reason for analyzing their context and version history.
to this end we apply zhang and shasha tree distance algorithm to compute the similarity between two candidate repair locations rlandri.
however we introduce our own notion of similarity when comparing two ast nodes n1andn2.
kind compatibility.
n1andn2are kind compatible if kind n1 andkind n2 have a super class or sub class relationship.
for example a variable access a n array access or a method invocation returning a value are of similar kind since all of them are expression type.
however a return statement and a throw statement are not kind compatible.
type compatibility.
n1andn2are type compatible if type n1 andtype n2 have either a super class or subclass relationship or satisfies the implicit type casting criteria defined by the language.
name similarity.
we extract the name of n1andn2 and use levenshtein distance algorithm to compute textual similarity.
it is worth noting that due to kind compatibility similar but various kind of program constructs can be mapped to each other.
for example one developer may use area length width whereas another may use area table.getlength table.getwidth .
although a human can easily understand that length and table.getlength represent similar data in terms of asts they are quite different.
h ercules is able to find such similarity which is important in dealing with object oriented programming language.
finally we use algorithm to determine whether n1and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm ast node similarity input two ast nodes n1andn2 output similar true false ?
mapping of elements m astnode similarity n1 n2 s1 kindcompatibility r1 r2 ifs1 true then s2 typecompatibility r1 r2 ifs2 true then s3 compute name sim r1 r2 ifs3 threshold then returntrue end if end if end if returnfalse n2are similar and eventually zhang shasha algorithm to determine whether rlandriare similar.
in the case of similar rlandri we create a one to one node level mapping between the similar nodes in rlandri.
step determining the relevance of repair locations step certainly would remove most of the irrelevant repair locations.
however there may be still a lot of false positives since any two random statements can be similar at a statement level especially small statements.
therefore h ercules enhance the analysis with program context to make sure that the repair locations are indeed similar and used in a similar context.
significance of program context.
program context i.e.
surrounding code around a target location has been used in many software engineering tasks including program repair .
to determine program context the number of statements around the repair location is one of the important parameters.
while a small context 1statement may not be sufficient to capture the developers intent a large context 10statements may be difficult to generalize.
to find evolutionary siblings using adjacent program context is even further challenging since many of them are not clones in a traditional sense as discussed in section iii .
extraction of program context.
in order to overcome this challenge unlike other repair tools that use a fixed size adjacent context h ercules uses a variable size noncontiguous relevant context definition iv .
.
more specifically h ercules uses reaching definition based analysis within a method boundary to extract only relevant context even though those statements are far away from the repair location.
in compiler theory a reaching definition for a given statement rl is the closest earlier statement riwhose target variable can reach rlwithout an intervening assignment.
we use algorithm to extract the relevant non contiguous repair context for a given repair location rl .
in words we first extract all the variable accesses from rl.
then for each variable access we determine the statement that satisfies the reaching definition property based on data flow analysis.
wealgorithm extract relevant context input a repair location rl source code sc output set of statements representing context crl extract relev ant context rl sc v extract variable accesses rl crl rl for each vinvdo rlv reaching definition v crl crl rlv end for if crl then crl clr previous statement rl end if crl sortbylinenumber crl returncrl take a union of all the statements obtained from the analysis sorted by the line number to form the context crl.i fcrl contains only rl we add previous statement of rlincrl.
analysis of program context.
once the program context for each repair location pair rl rli is extracted h ercules applies the same tree matching algorithm from the previous step to determine whether the context are similar and the node mappings are still consistent.
if they are similar h ercules marks them as potential evolutionary siblings.
step revising evolutionary siblings leveraging v ersion history since the accuracy of identifying evolutionary siblings is a direct impact on the repair we further leverage version history to revise them.
there may be two potential scenarios.
one some repair locations in the candidate evolutionary siblings identified in step are independent of each other.
two some true evolutionary siblings are not in the list due to weak test specification.
our insight is that true evolutionary siblings may have a similar evolution history i.e.
they went through similar ast operations in the past.
therefore version history may be helpful two mitigate both problems.
lets assume that we have three candidate evolutionary siblings rl1 rl2 rl3 .
in order to revise the list with confidence hercules first identifies all the commits c1 c2 .. c n where the candidate repair locations were edited.
then it extracts the differences in each commit before and after the changes at the ast level insertion deletion and modification .
h ercules further investigates each commit to identify if there are any other similar repair locations that have been also changed with the candidate siblings applying step .
if h ercules finds any similar repair locations r4 r5 it analyzes their context as well applying step .
if the results of both steps are positive h ercules adds such repair locations in the list of candidate evolutionary siblings.
therefore for this example h ercules would get five candidate siblings.
however even if h ercules adds some plausible siblings in this phase it can safely discard them during validation section iv d if they introduce any regression failure authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to eventually generate a correct patch.
finally h ercules removes the repair locations that do not have the similar evolution history based on the edit operations.
h ercules passes the final evolutionary siblings along with the mapping of similar nodes among the repair locations to the next step for the generation of candidate patches.
it should be noted that in the whole process of finding evolutionary siblings h ercules applies ast matching algorithm lazily in several steps.
it is indeed possible to find all the evolutionary siblings in the entire code base and then analyze their version history.
however this approach would be inefficient.
c. generation of candidate patches in this step h ercules generates a single or multi hunk patch depending on the results from the previous step.
for a single repair location rl h ercules follows the traditional patch generation approach i.e.
it instantiates a select repair schema ifractur with the repair expressions in scope.
however for multiple repair locations rfractur rl rl1 .. r ln where evolutionary siblings are involved h ercules instantiates the selected repair schema at an abstract level.
more specifically given a group of repair locations rfractur and a mapping between similar ast nodes in rfractur denoted by m rfractur h ercules abstracts all repair locations to remove the differences due to various identifier names.
then the same repair schema ifracturis instantiated at the abstract level at each repair location simultaneously.
once the transformation ifracturis applied h ercules generates the concrete candidate patches by reverting the original variables using m rfractur .
therefore the repair space generated by h ercules may have both single or multihunk patches.
it is worth noting that due to simultaneous repair schema instantiation h ercules keeps the repair space comparable to the repair tools that only focuses on generating single hunk patch.
d. ranking of candidate patches and v alidation once the candidate patches are generated h ercules can use any ranking models heuristic based or machine learning based proposed in the existing repair tools to rank the candidate patches and selects top ncandidate patches for validation one at a time.
during the validation phase for each candidate single or multi hunk patch h ercules first runs the failing tests and if they pass h ercules runs the regression tests.
if the regression test suite pass h ercules stops and reports that patch as a final patch.
v. e xperimental setup a. implementation hercules is a g v style repair tool implemented in java.
it includes a spectrum based fault localizer as well as a source code and version history analyzer.
h ercules also implements a mechanism for applying repair schemas simultaneously at several locations to effect multi hunk repairs.
inspired by previous well known program repair tools h ercules includes repair schemas such as checking null pointercheck changing and inserting method invocation changing and inserting ifconditions and so on.
further it incorporates a machine learning based patch ranking model similar to elixir .
for the details of each of the repair schemas and the ranking model of candidate patches the reader is referred to the corresponding papers .
we also implement several baseline versions of h ercules to demonstrate the effectiveness of its various components section vi d .
b. dataset we used the popular defects4j dataset to evaluate hercules specifically the five subjects math lang chart time and closure.
c. training hercules since h ercules uses a machine learning technique to rank and prune candidate patches for validation we train hercules with real world bugs.
in order to train h ercules we used another publicly available real world bug dataset bugs.jar.
there are real world bugs in bugs.jar taken from eight well known large apache projects.
among them apache commons math is common to both defects4j and bugs.jar .
therefore we removed apache commons math from our training set to keep the training and testing datasets mutually exclusive.
d. research questions rq1 how effective is h ercules for repair localization through evolutionary sibling detection compared to traditional clone detection?
rq2 how effectively does h ercules generalize the traditional single hunk repair strategy of apr tools to perform both single hunk as well as multi hunk repair?
rq3 how effective is h ercules in repairing programs compared to state of the art program repair tools?
rq4 what is the contribution of various components in h ercules to its overall bug fixing capability?
e. experimental configurations we ran all the experiments on a cluster of virtual machines vm where each vm was configured to have double core .6ghz processor and 4gb memory.
we used ubuntu .
lts operating system and java .
there are several configuration parameters in h ercules as well.
h ercules used threshold value .
for determining tree similarity iterated through top repair locations and selected candidate patches per repair schema.
we set a time out of hours following the recently introduced repair tool simfix .
vi.
r esults a. rq1 effectiveness of hercules for repair localization vs. a traditional clone detector motivation.
the main contribution of h ercules is that it enables fixing a specific but prominent class of multi hunk bugs by accurate repair localization which is in turn achieved through the detection of evolutionary siblings.
therefore it is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i effectiveness of h ercules and deckard for repair localization patch type bugs approach correct proportion single hunk h ercules deckard multi hunk h ercules deckard total h ercules deckard important to evaluate how effective h ercules is in detecting evolutionary siblings especially compared to a traditional clone detection tool since if a clone detector can detect all the evolutionary siblings accurately we do not need any sophisticated repair localization.
experiment.
in order to make a meaningful comparison we first identify all the relevant bugs in defects4j for this experiment.
here by relevant bugs we mean all the bugs that involve either only a single hunk patch or ones with a multi hunk patch but similar edits in all hunks.
the rest of the bugs are by definition out of scope and will only add noise to the experimental results.
this gave us bugs in total single hunk bugs and multi hunk bugs.
recall from section iv b that for a given buggy location the objective of repair localization is to identify all the relevant locations where similar changes are required to repair the bug correctly and completely.
therefore in an ideal case if we point a clone detector or h ercules to an actual buggy line i.e.
an input location it should return only one repair location the input location itself for a single hunk bug and all the nrelevant repair locations including the input location for an n hunk bug.
to this end we ran the repair localization component of hercules and an established clone detector deckard on all the bugs in defects4j with respect to their actual buggy locations or the one with the highest fault localization rank for a multi hunk bug .
for deckard we set the minimum number of tokens to approximately two lines of code following .
results.
from table i we see that h ercules identified the repair locations correctly for out of bugs whereas deckard found the correct locations only for out of bugs.
on closer inspection we see that deckard performed even poorer on multi hunk bugs which is the main target of repair localization than single hunk bugs.
it detected correct repair locations for only bugs while h ercules correctly localized out of of these bugs.
even for single hunk bugs deckard correctly localized only of the instances compared to h ercules s .
in both single hunk and multi hunk instances deckard produced false positives as well as false negatives.
the reason is simply that many of the target repair locations are not clones in a traditional sense like our motivating example in figure and beyond the scope of deckard s purely syntactic fixedcontext clone detection.
by contrast h ercules s specialized evolutionary sibling analysis which combines severaltable ii effectiveness of h ercules correct incorrect subject math lang time chart closure total hercules hercules sh fig.
distribution of multi hunk bugs in our study orthgonal sources of information is far more accurate and hence indispensible for the application at hand i.e.
multihunk program repair.
b. rq2 effectiveness of hercules in generalizing singlehunk repair to combined single hunk and multi hunk repair motivation.
in rq1 we demonstrated that h ercules is effective in detecting evolutionary siblings.
the current experiment evaluates how well this repair localization translates into the end goal of producing correct patches not just for multi hunk instances but also single hunk patches.
experiment.
we first create a baseline named h ercules sh that has all the repair schemas in h ercules but only performs single hunk repair.
then we ran both h ercules and h ercules sh on all the bugs described in rq1.
results.
as presented in table ii h ercules generates correct patches and incorrect patches while h ercules sh generates correct patches and incorrect patches as well.
a deeper look into the results reveals that h ercules fixed single hunk bugs and multi hunk bugs.
by comparing the results with h ercules sh we observe that h ercules lost one single hunk bug due to incorrect simultaneous repair.
surprisingly h ercules does not generate any additional incorrect patches due to multi hunk repair.
the reason is that in multi hunk repair since program changes happen in two or more repair locations the probability of detecting regression bugs by the test suite increases significantly.
even if a test case detects regression in one repair location out of n the whole candidate patch is discarded.
an analysis of the distribution of multi hunk bugs and patches in terms of number of hunks offers some interesting observations.
as presented in figure h ercules fixed a variety of multi hunk bugs ranging in size from hunks to as large as hunks.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii statistics of patch generation by various techniques correct incorrect subject math lang time chart closure total hercules simfix capgen jaid elixir ssfix acs c. rq3 effectiveness of hercules vs. state of the art program repair tools motivation.
in rq2 we demonstrated that h ercules is effective in fixing multi hunk bugs as well as single hunk bugs.
in this section we evaluate the effectiveness of h ercules with respect to the state of the art program repair approaches.
experiment.
we choose six of the most recent java apr tools simfix capgen jaid e lixir ssfix and acs as representative of the state of the art.
since all these tools have already been evaluated on defects4j we simply take the results from the respective papers.
results.
table iii presents the number of correct and incorrect patches generated by various tools.
from the results we see that h ercules generated correct patches which is the most among all tools.
it fixes more patches than the next best tool simfix.
since simfix and acs have also the ability to fix multihunk bugs we investigated the results at the level of individual bugs.
we found that h ercules fixes unique multi hunk bugs that simfix and acs cannot fix.
furthermore if we consider all the bugs h ercules fixed unique bugs that no existing approaches could fix.
overall the results demonstrate that h ercules advances the state of the art significantly.
d. rq4 contribution of v arious components of hercules motivation.
evaluations in the previous rqs demonstrate that h ercules overall outperforms existing tools.
the next experiment evaluates the contribution of various features of hercules to its overall bug fixing capability.
experiment.
in order to investigate the contribution of various components we create three versions of h ercules .
hercules fixed context uses a fixed number of lineswbefore and after the buggy location as its context rather than the semantic context.
for this version we experimented with w and reported the best results.
hercules minus history ignores the version history in repair.
hercules incr implements an incremental repair strategy where there is no notion of evolutionary siblings.
each location is fixed independently one after another as long as each successive repair decreases the number of failing tests.
this strategy broadly mimics the one implemented in simfix and acs .table iv comparison among variants of h ercules approach number of correct patches hercules hercules fixed context hercules minus history hercules incr we run this experiment only for the bugs that h ercules correctly fixed.
results.
table iv presents the aggregated results in terms of number of correct patches.
from the results we observe that when we used a fixed size context h ercules lost bugs.
similarly version history was crucial in fixing six bugs correctly.
finally the results further show that when hercules does not leverage the information of evolutionary siblings i.e.
works in an incremental fashion it cannot fix bugs.
in summary the results demonstrate that all the features of h ercules contributed in fixing multi hunk bugs.
vii.
l imitations t hreats to validity scope of multi hunk repairs.
our current technique addresses only a specific class of multi hunk repairs namely ones with substantially similar patches for each hunk.
while this does boost the successful repairs by almost compared to the baseline tool future research needs to address other classes of multi hunk bugs the vast majority of which are still out of scope for h ercules or any other apr tool.
accuracy of version history analysis.
our version history analysis can be impacted by noise in the revision history introduced by major structural changes to the repository such as to the directory or package structure or other systemic refactoring changes.
we use several heuristics to compensate for such disruptions and manually inspected the history of a few sampled bug instances to verify the accuracy of the heuristics.
however we cannot guarantee the soundness of the analysis.
generalizability of the results.
our evaluation was only carried out on the defects4j dataset which is a widely used benchmark for program repair research.
however the dataset s subject systems cannot capture the wide variety of java applications and their bugs.
further validation of this technique on other subjects should necessarily be done in future.
further our current repair results depend on the capabilities of the baseline repair tool on which our multi hunk repair technique is implemented.
although our baseline apr tool is quite competitive with the state of the art using a different or improved apr tool such as simfix for example could change or improve the results.
lastly our technique has been instantiated for java program repair but could in principle be applied to c c program repair as well.
but its efficacy in that setting remains to be investigated.
viii.
r elated work automatic program repair.
a decade of research has generated a rich body of work on program repair summarized in two excellent recent surveys .
with the notable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
exception of angelix apr research so far does not target multi location bugs which is our main focus.
however apr research most related to h ercules s approach can be classified into techniques that mine existing code or patches for repair fragments e.g.
variables expressions statements or complete code snippets etc.
learn abstract repair spaces e.g.
program transformations from existing patches and can produce multi hunk patches.
apr mining repair fragments genprog which pioneered this area uses genetic search on a space of repair mutations formed by code snippets copied from elsewhere in the program.
rsrepair and ae follow genprog using random and deterministic search respectively instead.
scalpel transplants code snippets mined from a donor application to repair bugs in a donee application.
codephage also performs transplantation but targets missing ifcondition related bugs.
acs performs if condition repairs using predicates mined from github.
searchrepair mines repair fragments using a semantic search based on smt formulas and constraint solving.
ssfix performs the same search using a general purpose search engine.
simfix also searches for a donor snippet but further uses a mined space of abstract schemas to prune the search.
prophet and elixir do not directly mine repair artifacts but rather use a corpus of existing patches to train a classifier which is then used to rank the space of concrete patches.
as a whole the above techniques search for compatible code fragments or features thereof to contribute to the repair of the bug at hand i.e.
a donor donee relationship.
by contrast h ercules s search for similar code is used to find a set of evolutionary siblings that can be repaired concurrently.
apr learning abstract repair spaces par first used this approach defining its repair space using a set of10specialized repair templates manually derived from human written patches.
relifix uses specialized repair schemas customized for software regression errors.
historydriven repair prioritizes its pool of candidate repairs based on the frequency of occurrence of the repair in a corpus of past human written patches.
tan et al.
propose a blacklist abstract repair space defined by a set of anti patterns to curb the generation of incorrect patches.
genesis automatically extracts a set of repair schemas for specific classes of bugs by solving an optimization problem on the set of previous patches for each bug class.
capgen mines a set of frequently occurring ast level transformations from a corpus of previous patches and uses them for repair.
our contribution is fundamentally orthogonal to the above body of work in that our identification of evolutionary siblings seeks to identify where the repair should be performed while the above informs how the repair at a given location should be performed.
apr multi hunk repair so far angelix is the only apr tool to specifically target multi hunk patches.
it generates a symbolic oracle for potential changes to the top k locations given by fault localization and then independently synthesizes patches for each location from the oracle.
although not specifically described in the implementations of acs and simfix are in fact capable of performing simple instances of multi hunk repair.
specifically when there are distinct test cases separately implicating each of many bug locations the tool independently repairs these bug locations one after another using the number of passing tests as a progress metric.
our key contribution is that we employ sibling relationships between locations to significantly cut down the search space by repairing locations simultaneously localize the repair more accurately and can even repair locations not directly implicated by the test spectrum.
code clone detection.
our work is broadly inspired by research on code clone detection and extraction of code clone genealogies.
deckard nicad and ccfinder are some of the popular clone detectors.
kim et al.
were the first to extracted and analyze clone genealogies across multiple revisions of a software system to understand the evolution of code clones.
however as demonstrated in rq3 the evolutionary siblings that form the basis of our approach may or may not be traditional code clones.
systematic edits.
our approach is also inspired by research on systematic edits with lase and r ase being the most advanced tools in this area.
the key idea in this research is to learn a common abstract edit script from a few examples instances of it which is then replicated at target locations in the code also identified using the learned edit script.
h ercules also shares the notion of similar edits at multiple locations.
however we do not rely on examples for identifying sibling locations.
ix.
c onclusion automatic program repair techniques have made significant advances over the past decade.
however practical deployment remains an elusive goal.
one of the significant obstacles to achieving this goal is the inability of current apr techniques to produce multi hunk patches.
in this work we presented a novel apr technique that generalizes single hunk repair to encompass a specific but significant class of multi hunk repair problems namely ones that require applying a substantially similar patch at a number of locations.
we term such sets of repair locations as evolutionary siblings similar looking code instantiated in similar contexts that are expected to undergo similar changes over time.
we proposed a novel analysis to accurately identify a set of evolutionary siblings for a given bug.
this analysis combines three orthogonal sources of information namely the test suite spectrum a novel code similarity analysis that compares both syntactic and semantic features and the revision history of the project.
we implemented this technique in a tool h ercules and demonstrated that it is able to correctly fix bugs in the defects4j dataset the highest of any individual apr technique to date.
this includes multi hunk bugs and bugs which have not been fixed by any other technique so far.
we see this contribution as a small but important step on the road to achieving practical deployment of apr tools.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.