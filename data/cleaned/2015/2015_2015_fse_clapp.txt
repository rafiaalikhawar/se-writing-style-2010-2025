clapp characterizing loops in android applications yanick fratantonio uc santa barbara usa yanick cs.ucsb.eduaravind machiry uc santa barbara usa machiry cs.ucsb.eduantonio bianchi uc santa barbara usa antoniob cs.ucsb.edu christopher kruegel uc santa barbara usa chris cs.ucsb.edugiovanni vigna uc santa barbara usa vigna cs.ucsb.edu abstract when performing program analysis loops are one of the most important aspects that needs to be taken into account.
in the past many approaches have been proposed to analyze loops to perform different tasks ranging from compiler optimizations to worst case execution time wcet analysis.
while these approaches are powerful they focus on tackling very speci c categories of loops and known loop patterns such as the ones for which the number of iterations can be statically determined.
in this work we developed a static analysis framework to characterize and analyze generic loops without relying on techniques based on pattern matching.
for this work we focus on the android platform and we implemented a prototype called clapp that we used to perform the rst large scale empirical study of the usage of loops in android applications.
in particular we used our tool to analyze a total of loops found in android applications.
as part of our evaluation we provide the detailed results of our empirical study we show how our analysis was able to determine that the execution of .
of the loops is bounded and we discuss several interesting insights related to the performance issues and security aspects associated with loops.
categories and subject descriptors d. .
security and protection keywords android static analysis loop analysis .
introduction over the past few decades there has been an explosion in the development and application of program analysis techniques to achieve a variety of goals.
program analysis has been used for compilation and optimization purposes for studying a variety of program properties for detecting bugs vulnerabilities malicious functionality and ultimately for understanding program behavior.when performing program analysis one of most important aspects that needs to be taken into account are loops .
loops are undoubtedly one of the most useful and essential constructs when writing programs.
however they are also one of the most challenging ones to handle in fact even answering the simplest questions e.g.
is a given loop going to terminate?
is in the general case undecidable.
loops also have particular importance when applying program analysis for optimization or security purposes.
one important observation is that in certain scenarios operations in a loop might have a greater impact than operations which are not part of any loop.
in fact consider as an example an operation that is performance intensive e.g.
a gui related operation while this functionality might not constitute a problem when executed only occasionally it could be deemed as problematic when executed multiple times within a loop.
similarly in the case of security consider a le deletion operation this operation is not dangerous per se however it could be deemed as such when the same functionality is executed within a loop as the application might have the potential to wipe all of the user s data.
another relevant scenario is a malicious application that implements and executes an in nite loop with the aim of draining the device s battery.
while this malicious functionality might not constitute a serious issue for the average user it might have disastrous effects when the application is used in security critical scenarios e.g.
by a soldier in the battle eld .
in the past much research has been focused on the analysis of loops.
for example research done in the context of compiler level optimizations has focused on the analysis of loops to understand for example whether it is possible to unwind their execution a process known as loop unrolling .
in this scenario the goal is to optimize a program s execution speed at the expense of its binary size.
another thrust of research has focused on worst case execution time wcet analysis which aims to statically determine how many times a loop can be executed in the worst possible case .
this analysis is particularly relevant for the design of real time systems where it is critically important to determine a conservative time estimate of when a given function will terminate its execution so that it is possible to know when its output can be considered as valid and thus ready to be consumed.
while these approaches are powerful they focus on handling only very speci c types of loops e.g.
the ones for which all the relevant information is statically known and they would consider as out of scope all loops that do not satisfy speci c requirements.
for example consider a loop for which the number of iterations directly depends on the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
687size of a list since in the general case the size of a list cannot be statically known this loop cannot be properly analyzed by existing approaches.
for this work we developed a generic loop analysis framework based on static analysis to characterize loops under many different aspects.
in particular we focus on the android platform for which a vast amount and variety of applications are available.
android is fundamentally an event driven system and the execution of an application should be mainly driven by the underlying system.
however loops within the main application are opaque to the framework and it is not possible to control them without using performance intensive ne grained dynamic monitoring systems.
these observations make loops a particularly interesting and relevant construct to be studied in the context of the android platform.
we implemented our static analysis techniques in a tool called clapp .clapp works directly on dalvik bytecode and it therefore does not rely on having access to the application s source code.
at its core our analysis extracts detailed information about the operations that in uence and control the number of iterations of a loop and the operations that constitute the loop s body.
this is achieved by combining several static analysis techniques such as loop identi cation backward dataow analysis on use def chains selective abstract interpretation and code reachability analysis.
the key advantage of our approach is that it is completely generic and can be applied to any kind of program.
moreover our approach does not rely on the identi cation of known cases through techniques based on pattern matching.
we used clapp to perform the rst large scale empirical study to characterize under many different aspects the usage of loops in android applications.
in particular we analyzed android applications which cumulatively contained loops.
as part of our evaluation we analyzed the results of our static analysis system to gain insights related to many interesting aspects of the usage of loops in android applications.
as one of the rst analysis steps we perform bound analysis which consists in the identi cation and characterization of what kinds of operations control the number of iterations for a given loop.
more in general we try to characterize if loops are bounded and how often interestingly our system was able to determine that the execution is guaranteed to terminate for .
of the loops.
we also found that it was possible to statically estimate the number of iterations in the worst case only for .
of all loops this suggests that existing loop analysis techniques might be applicable only in a very limited number of cases.
as a second step we perform body analysis which consists in characterizing what kinds of operations are performed for each iteration of the loop.
the results from bound and body analysis are then combined to increase the precision of the analysis and to gain even more insights.
these results are used as a basis for studying the different use cases for writing loops in android applications and more in general to study the usage of loops under two main perspectives performance andsecurity .
first we evaluated the performance aspect and we determined whether loops are written according to the official guidelines provided in the android documentation.
for example we identi ed cases in which developers do not use appropriate constructs e.g.
iterators when iterating over a list which are known to provide a non negligible performance bene t. as another example we study whether performanceintensive operations in a loop are executed within the contextof the main ui thread in which case the user might perceive the gui as stuck and the operating system might consider the app as non responsive.
as another interesting aspect we identi ed several cases in which the java compiler itself misses important optimizations.
we also found that developers often code loops in a risky way for which a small mistake might suddenly lead to the introduction of an in nite loop.
second we evaluated loops from the security perspective and we highlighted cases where high risk operations are executed in loops hence increasing the potential for damage or loops for which the number of iterations depends on a component external to the application e.g.
network data depending on the threat model such external components could be controlled by an attacker to perform for example a denial of service attack through the introduction of a long running potentially in nite loop in the application.
in summary this paper makes the following contributions we developed a generic loop analysis framework based on static analysis to characterize the usage of loops in android applications.
our framework aims to analyze generic loops and it does not rely on techniques based on pattern matching.
we implemented our static analysis in a tool called clapp and we used it to perform the rst large scale empirical study to characterize the usage of loops contained in android applications.
our prototype operates directly on dalvik bytecode and therefore it does not rely on the application s source code.
the results of our large scale analysis offer interesting insights such as why and how software developers implement loops in android applications.
moreover we show how it is possible to automatically identify problematic loops for what concern both the performance and the security aspect.
.
loops characterization our analysis aims at extracting as much information as possible about loops.
in particular our analysis rst identi es all loops in a given application and then focuses on the loop control aspect i.e.
how is the number of the loop s iterations controlled?
on the loop body aspect i.e.
which are the actions performed by each loop s iteration?
and on the dependency between these two aspects.
to determine how a loop is controlled the analysis rst identi es which are the conditional instructions that can directly in uence whether the loop s execution terminates.
then our analysis performs for each register used by these conditional instructions a combination of backward slicing and selective abstract interpretation to reconstruct how the registers values are initialized and evolve during the execution of each iteration of the loop.
we characterize the loop s body by determining which framework api functions could be possibly invoked as part of each loop s iteration.
this analysis is inter procedural and it works by analyzing the inter procedural call graph of the application.
additionally our analysis takes into account the relationship between the operations performed in the loop and how the loop is controlled.
this allows for a more comprehensive characterization of loops.
in fact as an example consider a loop that is bounded by the value returned by an api function call in the general case it is impossible to characterize how this value changes during each loop s iteration.
however in some cases it is possible to establish that the api function call s return value would not change if for example the loop s 688bound analysis clapp preliminary analyses body analysis control flow graph bytecode ir ssa call graph class hierarchy loop identification exit paths identification expression tree construction selective abstract interpretation reachability analysis termination analysis large scale empirical study security analysis performance analysis android appfigure overview of our loop analysis framework.
1public void f list l ... bool skipfirst ... int startidx i startidx skipfirst ?
for i startidx i l. size i elem e l.get i if e null break processelem e figure a sample program containing a loop.
body is only constituted by math related operations.
for this reason we extract additional information from the body of the loop and we combine them with information extracted during the bound analysis step to determine for example if the value returned by a given api function call can be assumed to be constant.
as two concrete examples consider the list.size and string.length methods if the body of the loop does not perform any signi cant operations on these objects their return values will not change after each iteration of the loop.
in certain cases this additional information is critical to prove a given loop s termination.
.
static analysis framework this section discusses the details of our static analysis framework whose overview is shown in figure .
as input the framework takes the apk le of an android application an apk is the archive format used in android to deliver applications code and resources and it extracts its dalvik bytecode a register based representation of the program that is executed by the so called dalvik virtual machine dvm .
then the analysis performs several steps based on static analysis that extract detailed information about the control and body aspects of each loop.
these results are then post processed to perform for example bound analysis and to gain insights related to the performance and security aspects.
the remainder of this section describes in details all these analysis steps.
throughout our description we will use the snippet of code in figure 2as a running example.
.
preliminary analysis steps the analysis begins by performing several preliminary steps.
these steps have the goal of extracting the information on top of which our loop analysis framework is built.
first the dalvik bytecode dex of the application is parsed and disassembled.
for this step we rely on androguard to convert dalvik bytecode into easily accessible python objects.
after this step we compute the control flow graph cfg and we lift the bytecode to an internally developed intermediate representation ir that is more suitable for performing static analysis.
one of the main features of this ir is that it comes in static single assignment ssa form .
figure 3shows the cfg and the bytecode representation in ssa form corresponding to the example in figure .
after this step we perform class hierarchy analysis cha which reconstructs the inheritance relationship among all classes and interfaces de ned in the application and the android framework.
the last of these preliminary steps is the computation of a coarse over approximation of the inter procedural call graph.
this is performed by rst identifying all the invoke bytecode instructions in the application code base.
then for each of them the analysis rst determines the set of possible dynamic types of the object receiving the method invocation this is done by using the results from the cha step and other type related information and then it simulates the dynamic dispatch mechanism to compute all possible targets.
.
loop identification after these preliminary steps our analysis proceeds to identifying all loops in the given android application.
to do this we implemented the algorithms proposed by wei et al.
.
in the context of our work a loop is represented as a set of basic blocks.
among these basic blocks the analysis then identi es the header which can be seen as the entry point of the loop.
more formally the header is the basic block that dominates the execution of all the other blocks belonging to the loop.
the algorithm proposed by wei et al.
can also identify and correctly handle nested loops.
in our work nested loops are treated exactly as non nested loops with the only difference that we annotate which inner loop belongs to which outer loop.
for our example in figure 2and3 the loop header is b4and the body is constituted by b4 b5 and b6.
list l new arraylist new instance r0 arraylist invoke r0 arraylist init skipfirst ... move r1 ... if skipfirst if eqz r1 b1 startidx move r2 goto b3 b0 startidx move r3 merging possible values of startidx r4 phi r2 r3 for i startidx ... ... move r5 r4 merging possible values of i from inside outside the loop r7 phi r5 r10 for ... i l.size ... invoke r0 list size i move result r6 if ge r7 r6 b7 b2 b1 b3 elem e l.get i invoke r0 r7 list get move result r8 if e null break if eqz r8 b7 loop body ... for ... ... i move r9 add r10 r7 r9 goto b4b4 b5 b6 return void b7 figure annotated controlow graph of the function in figure .
the loop header is b4 and the loop s body is constituted byb4 b5 and b6.
exit paths identi cation.
the next step is to identify all possible exit paths .
we de ne an exit path as a set of conditional instructions or conditions that need to be satis ed so that the execution of the loop terminates.
naturally a loop might have multiple exit paths.
for example the snippet of code in figure 2has two exit paths fi l.size g fi i.size e null g. to determine all exit paths we rst identify all basic blocks belonging to the loop s body for which at least one of their successors is a basic block that is notpart of the loop.
these are the basic blocks that contain conditional instructions i.e.
if bytecode instructions directly guarding the loop s exit.
then the analysis computes all control dependence paths to each of these basic blocks from the loop header by using the algorithm proposed in .
the resulting set of paths constitutes all possible loop exit paths.
for our example in figure the exit paths are f if ge r7 r6 g f !if ge r7 r6 if eqz r8 g. .
loop control characterization one of the main aspects that our analysis characterizes isthecontrol aspect.
that is we are interested in characterizing which are the factors that control the number of iterations of the loop to determine for example if it is possible to statically guarantee that the loop eventually terminates.
this analysis step operates on the exit paths identi ed as part of the previous preliminary steps.
depending on the number of exit paths and their type we label a loop as simple orcomplex .
in particular we consider a loop as simple if it has only one exit path constituted by only one condition.
in other words a loop is simple if there is only one if bytecode instruction that determines whether the loop should terminate its execution or perform another iteration.
instead all loops that have more than one exit path or that have only one exit path but multiple conditions are considered as complex.
given this de nition the loop in figure 2is considered complex since it has two different exit paths.
note that it is possible that a loop might not have any explicit exit path in these cases the loop is labeled as potentially in nite .
we discuss this last case in section .
.
.
overview from a high level point of view our analysis works by characterizing each if bytecode instruction independently.
more precisely our analysis works by rst determining which are the relevant registers for each of these instructions and by then analyzing how the registers values are initialized and how they evolve during the iterations of the loop.
this is done by rst reconstructing the expression tree that encodes how the value contained in a register is updated after each iteration and by then performing selective abstract interpretation to extract some relevant properties.
this information is then used to establish if it is possible to statically determine whether the condition speci ed in the if instruction will be eventually satis ed in other words if it possible to determine whether the loop will terminate and to characterize which kind of operations in uence the control.
these analysis steps are described in section .
.
.
.
and .
.
.
the described analysis steps focus on the analysis of a single if instruction which is enough to characterize simple loops.
for complex loops the analysis rst studies all the relevant if instructions independently and then it combines the extracted information together as explained in section .
.
.
.
.
expression trees for each if bytecode instruction the analysis rst determines used registers and reconstructs the operations that update their values after each iteration.1in particular the analysis creates for each register an expression tree that encodes how the register is updated after each iteration.
speci cally each node of the tree is characterized by a type of operation e.g.
scalar addition and by its operands which in turn can be a value e.g.
a scalar value the return value of a method invocation or another expression tree.
the expression trees computed by our analysis are intraprocedural and they are obtained by performing a backward traversal of the use def chains provided by the ssa form .
it is important to note that since we work with an ir in ssa form each assignment to a dalvik register will produce a new register in the ssa form.
thus in our representation each register is associated with one and only one expression tree.
1in dalvik bytecode conditional instructions have either one or two registers as their operands.
in case the conditional instruction has only one register the comparison is implicitly performed against the value zero.
690r7 phir5 r4 phir2 r3 r10 r7 r9 2figure expression tree associated with register r7of the function fde ned in figure 2and .
the suffix identi es a cyclic dependency in the tree in fact the next value of r7depends on the current one.
note that while performing the backward traversal the analysis will inevitably encounter loops in the use def chains.
intuitively a loop in the use def chain encodes the fact that a register s value depends on a previous version of itself.
our analysis handles these cyclic dependencies by not continuing the exploration of registers that have already been processed i.e.
those registers that are already present in a path from the root of the expression tree to the current node .
of course the analysis will annotate the non explored registers with a special ag so that the subsequent analysis step i.e.
the selective abstract interpretation can properly handle this situation.
as an explanatory example on what the output of this step looks like we report in figure 4the expression tree associated to register r7.
.
.
selective abstract interpretation the next step of the analysis consists in performing selective abstract interpretation on top of the expression trees computed for each register.
in particular this analysis step annotates each node of the expression tree to characterize how the value of a given register is initialized how it evolves during each iteration and the trend of the value which consists in studying whether the value a register can assume isbounded regardless on the number of iterations.
the result of this step is an annotated expression tree.
in the remainder of this section we rst describe our annotation system and we then discuss how these annotations are computed.
an annotation for a node consists of a set of labels.
we now de ne each of these labels we discuss the possible values they can assume and for each of them we provide both an intuitive and formal de nition.
in this section we will use the notation rx nto indicate the value assumed by the register rxafterniterations of the loop.
statically bounded.
this label can be set to true orfalse depending on whether the value stored in the target register rxcan be statically determined as bounded.
in other words this ag is set to true if it is possible to statically extract two values 2such that 8n rx n .
fixed.
this label can be set to true orfalse depending on whether the value of the target register rxdoes not change during the execution of the loop.
formally this ag is set to true if the analysis can guarantee that 8n rx n .
note the difference from the previous case the value must exist but it is not required to be statically computable.
this label is set to true for any register that is de ned outside the loop since their value is guaranteed to not change during the loop s iterations in fact the ssa form guarantees that a register can be de ned only once and in case of a re assignmentwithin the loop s body a new register would be created.
sign.
this label can be set to one of the following values positive zero negative orunknown .
this label encodes information related to the sign assumed by the register s value.
for example the label will be set to positive if the analysis is able to determine that 8n rx n .
instead if the analysis cannot determine the sign of the value this label is set to unknown .
value trend.
this label indicates how the value of a register rxevolves at the limit .
in particular this label indicates whether it is possible to guarantee through static analysis that a value will eventually increase ordecrease that a value is bounded or that a value will be eventually zero .
concretely this label will be set to one of the following values increasing .this indicates that the register s value willeventually increase .
intuitively this implies that given a sufficient number of iterations the value in the target register will necessary be greater than any arbitrary value.
formally the following condition needs to be satis ed 9n rx n .
note that this de nition is weaker than the classic de nition of monotonically increasing .
this is intentional as in most cases our weaker de nition is enough to extract useful properties about the bound of the loop.
decreasing .similar to the previous case this indicates that the value in the register will eventually decrease .
formally 9n rx n .
bounded .this indicates that the value assumed by the given register is bounded .
intuitively this indicates that there exist two values such that it is guaranteed that the value of the register will always be between them .
formally 28n rx n .
note that this value indicates something different than the statically bounded label.
in fact the values 2must exist but they are not required to be statically computable.
eventually zero .
this indicates that the value of the register will be eventually zero .
formally 9n rx n .
unknown ?
.this indicates that our analysis cannot precisely determine the trend of this register s value.
this labeling system proved to be really powerful and generic.
in fact as our evaluation shows this mechanism allowed us to characterize a very large number of loops without having to rely on techniques based on pattern matching.
we chose this speci c set of labels as they are helpful in modeling and capturing the common behavior and evolution of the registers values that play a key role in controlling the number of iterations in a loop.
for example loops are often controlled by a variable that starts from a given value and increases at each iteration e.g.
the loop in figure .
in this case our analysis will be able to capture exactly this property by assigning the value increasing to the value trend label.
as we will discuss in the next section this aspect of our work plays a key role when determining whether the number of loop iterations is bounded.
we also note that some of the labels are introduced speci cally to precisely model known api functions that are often used in android.
for example the eventually zero value is helpful when modeling the return value of the iterator.hasnext api method that under certain assumptions see section .
is known to eventually return false or zero .
we are now ready to discuss and explain how these labels are computed for each node of the expression tree.
the system rst assigns an initial label for each node in the tree without 2in the context of this paper we do not consider the possibility of integer over ows.
691children i.e.
leaf nodes .
for example a register that is set by the const r5 bytecode instruction which moves the constant in register r5 will be annotated with the statically bound andfixed labels set to true the sign label set to positive and the value trend label set to bounded .
when such precise information is not available our analysis takes into account the operations performed within the body of the loop to extract more precise meaningful labels.
one common case is when a relevant register is set to the return value of a known framework api function.
for example if a register is set to the return value of the list.size api function the analysis rst determines whether the list could be modi ed during the execution of each iteration and if not possible the analysis is able to set the value trend label to bounded .
more in general the analysis combines information about the control and the body of the loop.
this aspect of our analysis is described in section .
.
note that the computation of the initial values is more challenging when the tree contains cyclic dependencies.
for example consider the register r7in figure the value that r7will assume during the next loop iteration depends on the value assumed during the current one.
this makes the analysis challenging especially when computing the value for the value trend label.
in fact in order to set this label to for example the increasing value the analyzer must rst prove that one of the next values assumed by a given register will be greater than the current value.
the analysis is able to reconstruct this relation by identifying cyclic dependencies in the expression trees and by determining for example whether the next version is the result of the addition of the current version and a quantity known to be positive as for register r7in the example of figure .
in this case this would be enough to prove that the register s value will eventually increase .
this analysis step is implemented by iteratively propagating the information available from the leaves to the root of the tree until convergence is reached.
note that we called this analysis step selective abstract interpretation because we are actually performing abstract interpretation where the abstract domain is represented by our annotation system by only considering those instructions that are relevant for the loop s bound analysis i.e.
the ones that appear in the associated expression trees.
once the initial values are computed for all the leaves propagating these labels throughout the entire tree is conceptually trivial.
this is achieved by iteratively merging for each node the labels associated to their children nodes.
the merge operation for all the annotations labels i.e.
statically bounded fixed sign and bound analysis is trivially implemented through a set of tables one for each operand that specify what the output label should be given two labels as input.
for example the addition of two registers that are known to be positive is positive.
as another example consider a register that at each iteration is set to the subtraction of a register whose bound analysis label is set todecreasing and a register whose value is known to be positive clearly the bound analysis label associated to the addition node will be set to decreasing as well.
.
.
characterizing conditional instructions once all registers of a given conditional instruction are properly annotated it is conceptually simple to characterize it.
for example the value trend labels of the registers can be used to determine whether the loop is guaranteed to terminate if the rst register is known to increase andthe second register is known to be bounded ordecreasing then it is easy to see that the conditional instruction will be eventually satis ed and hence that the loop will eventually terminate.
in some cases it is even possible to statically determine the number of iterations in the worst possible case.
this is done by consulting the statically bounded labels of each register.
moreover the information encoded in the expression trees can be used not only to perform bound analysis but also to determine whether a given conditional instruction depends on the return value of speci c methods elds or other factors.
this additional information is useful to characterize which categories of api functions control the number of iterations of a given loop.
.
.
generalization to complex loops all analysis steps described so far focus on the characterization of a single conditional instruction.
we now discuss how our analysis can be generalized to complex loops.
for what concern the bound analysis our analysis proceeds by considering all exit paths and it reconstructs a boolean formula that represents the combination of all of them.
then our system minimizes the boolean formula by applying well known simpli cation techniques and converts it to a canonical representation.
at this point our analysis determines whether a given complex loop is guaranteed to terminate according to the following two observations the conjunction of two conditions is eventually satis ed if and only if both the conditions are known to be eventually satis ed the disjunction of two conditions is eventually satis ed if either one of the two conditions is eventually satis ed .
by following these simple rules our analysis is able to characterize complex loops as well.
as an explanatory example for the loop in figure the minimized boolean formula that represents all exit paths is i l.size i i.size e null .
thus the analysis can establish that the loop will terminate since the variable i stored in r7 is known to eventually increase while l.size stored in r6 is known to be a xed value.
.
loop body characterization this section discusses how our analysis characterizes the behavior and the body of a given loop.
from a high level point of view our analysis aims to determine the set of framework api functions that might be possibly invoked intra and inter procedurally within the context of a loop s iteration.
to do that the analysis rst considers all basic blocks that belong to the body of the loop.
then it identi es allinvoke bytecode instruction and for each of them the previously computed inter procedural call graph is consulted.
for each potential target the analysis proceeds according to the following algorithm if the target is a framework method then this method is added to the set of framework methods that could be potentially invoked alternatively if the target method is a method de ned within the application the analysis adds to the set of possible targets all the methods that are directly or indirectly reachable by traversing the call graph.
as the next step each framework method is associated with a ne grained label that indicates what type of operation it performs.
these labels are assigned according to a manuallywritten con guration le which speci es which label should be assigned to which method.
to compile this con guration le we started by consulting the results from pscout and susi and then we augmented their results and annotations by consulting the android documentation.
our con guration le currently speci es about entries.
note 692table breakdown of the results related to the characterization on loops control aspect.
simple complex no exit paths total bounded risky unknown potentially in nite890 non supported total table number of loops controlled by various categories of framework apis.
category of apinumber of invocations iterators parsing gui related input output data structure crypto information gathering user data access network polling peripherals status that each entry often describes multiple methods through the usage of regular expressions.
section 4reports the details about the labels currently supported by our analysis.
.
dependency between control and body in some circumstances to assign a precise control label as the ones described in section .
to the return value of a method it is necessary to characterize the operations performed in the body of the loop.
for example consider a loop bounded by the list.size api method.
in many cases the size of the list will not change after each iteration.
however it could be possible that the loop s body modi es the list thus changing its size.
similarly consider the example of theiterator.hasnext api method.
the hasnext method is known to return zero when no more items can be processed which under normal conditions is eventually going to happen.
however if the body of the loop does not invoke the iterator.next api method to process the current item in the list the hasnext api method will never return the value zero thus functionally creating an in nite loop.
for this reason we extended our static analysis framework so that the actions in the body are taken into account when characterizing the return value of some known api functions.
for example when a loop is bounded by the list.size api method our analysis veri es that there is no path within the body of the loop that might invoke a method to modify the list if that is the case the analysis will label the return value of the size api method as a xed value.
similarly for the hasnext example our analysis veri es that all possible paths invoke the next method in which case the analysis will be able to label the return value of thehasnext api method as eventually zero .
as part of the process our analysis also performs a conservative intra procedural on demand alias analysis step to determine whether the body of the loop operates on the same ordifferent object than the one used for control.
this simple but effective technique proved to signi cantly improve our results both in terms of precision and performance.
.
empirical study in this section we discuss how we used our static analysis framework to perform the rst large scale empirical study on why and how android applications make use of loops.
first we describe the dataset we used for our study.
then we discuss the results of the bound and body analysis by also including several insights related to the performance and security aspects.
.
dataset to build our dataset we considered the applications collected by the playdrone project .
essentially playdrone is a crawler for the official google play store and it has been used to crawl more than one million applications between and .
we opted to use this dataset because it is the most representative source of android apps that spans over the entire market and because this dataset is publicly accessible.
for our experiments we selected at random a subset of applications.
these applications span over several categories on the market store and they contain hundreds to several thousands methods depending on the complexity of the application and the libraries they include.
.
overall results among the applications selected for the experiments our prototype was able to successfully analyze .
of them.
the analysis of the remaining applications did not terminate before the timeout was reached given the size of the dataset and the complexity of the analysis we opted to enforce a timeout of minutes for the analysis of each application .
for the applications that were successfully processed our tool identi ed and analyzed a cumulative total of loops and a total of api framework methods that could potentially be invoked in these loops.
on average analyzing each application took .
seconds and analyzing each loop took .
seconds.
.
loop control and bound analysis in this section we will discuss the results of our analysis that are related to how the number of iteration of each loop is controlled.
as a rst aspect our analysis identi ed .
simple loops i.e.
loops with only one exit path with one condition and .
complex loops i.e.
loops with one or more exit paths with several exit conditions .
for the .
remaining loops our analysis determined that there was no exit path associated to it.
we discuss this case later in this section see the potentially in nite paragraph .
as another interesting statistic we found that .
of the loops contain at least one nested loop.
another important aspect that our analysis helps characterizing is related to the following question how often it is possible to statically determine whether a loop can be guaranteed to terminate?
table 1reports the details about the different categories of our results.
in particular it shows the breakdown of the bound analysis with respect to the complexity of the loop.
the remainder of this section discusses the different analysis results.
bounded loops.
our analysis was able to determine that of the loops are guaranteed to terminate indicated 693with bounded in the table .
this constitutes an interesting result as these loops correspond to a substantial portion .
of the analyzed loops.
in fact it shows that even if determining whether a loop terminates is an undecidable problem in the general case it is possible to provide an answer in a surprisingly high number of cases.
another interesting aspect is that the method annotations and alias analysis described in the previous sections were critical to prove termination for loops.
moreover our tool identi ed .
loops for which the number of iterations in the worst case can be statically determined.
note that most existing techniques only focus on this small set of loops categories which indicates the need for more generic loop analysis techniques like the one proposed in this paper.
risky loops.
our analysis identi ed .
loops that are implemented in a risky way indicated as risky in the table .
with the term risky we refer to loops implemented so that independently from whether they terminate or not a subtle change in the loop s body might cause the loop to become in nite.
as a clarifying example consider the loop for i i !
i ... this loop will iterate exactly four times.
however a modi cation to how the variable iis updated could suddenly introduce an in nite loop.
a much safer yet equivalent alternative to implement the loop in example would be to convert the different than comparison !
to a less than comparison .
loops with unknown bound.
for .
of the loops our analysis was not able to determine whether the execution is bounded or not indicated as unknown in the table .
one of the root causes for which our static analysis framework cannot determine whether a loop is bounded or not is constituted by the fact that the number of iterations of a loop can be in uenced by the return value of a method invocation.
in cases the number of iterations is controlled by the return value of the invocation of a method implemented in the application.
alternatively the loop could be controlled by the value returned by a framework api function.
as part of our experiments we explored which categories of api functions are controlling the execution of loops more often.
the most frequent entries are reported in table .
unsurprisingly the most common api functions are those that associated with iteration and parsing.
however other results are more interesting for example our analysis identi ed cases where a loop is directly controlled by network related api functions.
although this is innocuous in most scenarios a loop that depends on an external component might have several security related implications which we discuss at the end of this section.
potentially in nite and non supported loops.
a minor portion of the loops in total were classi ed as potentially in nite .
for these loops our analysis determined that there was no explicit exit path in their controlow graph.
clearly this property indicates that a loop might be an in nite loop but of course it is not necessarily the case.
in fact these loops might have implicit exit paths implemented by means of exceptions or by means of concurrently modifying values in different threads.
these two aspects are not supported by our prototype thus making it currently impossible to discern whether a loop is actually in nite or not.
nonetheless we believe these loops represent cases of poorlyimplemented functionality regardless on whether they are in nite or not.
in fact in these cases the loop s termination condition is implemented in a different place than the loop it self and this decreases the readability of the code.
moreover the android framework is fundamentally event driven and it offers to a developer a plethora of callback based mechanisms to avoid implementing loops whose termination condition istriggered from a thread different than the one executing the loop.
to make things worse aggressive power savings in android often pause and later resume an application potentially rendering these loops in nite if not carefully implemented.
finally our analyzer was not able to analyze loops the reason being that they rely on switch like bytecode instructions instead of the simpler if bytecode instruction which our prototype currently does not fully support.
of course the analysis can be easily extended to handle these cases as well which is left as future work.
performance aspect.
our analysis can be useful to identify potential missed opportunities for performance related optimizations.
in particular our analysis determined that for loops .
of the total the body of the loop repeatedly invokes an api function whose return value does not change after each iteration nor has side effects.
for example this situation arises when a developer writes a loop to iterate over the items of a list by using an index variable that goes from zero to the size of the structure if the structure is not modi ed the return value of the size api method would not change after each iterations and hence its return value could be cached.
this kind of situations can arise for two reasons.
first it might be a developer s mistake she could write a loop that invokes an api function within the body of a loop instead of invoking it just once before the loop s rst iteration.
in this case the value could have been cached.
second it could be that the compiler itself does not have enough information to determine whether the return value of the api function is going to change or not.
hence it has no other choice than invoking the api function for every iteration.
although our analysis is not precise enough to identify all missed opportunities hence it might be affected by false negatives the number of problematic loops we identi ed is already non negligible.
moreover we believe these optimizations could lead to important performance boosts since they would prevent the invocation of framework api functions.
as another observation we note that in all these cases it would have been possible to use one of the known java constructs such as iterators which are known to improve the performance.
speci cally on the android platform index based iterations are known to be slower than by using iterators explicitly or implicitly through the enhanced for each syntax.
this aspect is speci cally mentioned in the performancerelated tips in the official android documentation .
security aspect.
the analysis on how the number of iterations is controlled can be used to gain insights related to the security aspect as well.
in fact loops could be intentionally written to be in nite loops so to make the device unusable and drain its battery.
our loop control analysis helps in highlighting these problematic cases by identifying potentially in nite loops that do not have any explicit exit paths or whose exit conditions do not seem to be satis able.
as we already mentioned most of these loops in practice do terminate.
however as the number of warnings only represents the .
of the total number of loops we believe it is worth it to check them manually.
at the very least these cases might indicate a poorly implemented loop thus deserving human attention anyways.
694table breakdown of the number of loops that can possibly invoke a method with a given semantic.
invoked within loopinvoked within ui main thread alarm android speci c audio bluetooth camera concurrency crypto data structure device settings exception face detector garbage collector gui device data iterators intent internals input output keyguard log multithread network nfc object comparison parsing phone power manager privileged operation process random re ection resource sensor sms speech strictmode related string telephony usb userdata video vpn webkit wifi another interesting aspect related to security is that we identi ed some loops whose number of iterations depends from a factor external to the application itself.
for example we identi ed loops that depend on network input.
in certain scenarios this external dependency might cause issues depending on the threat model the attacker might have a chance to alter network data and create an in nite or at the very least a very long running loop by sending properly crafted data to the device.
.
loop body and behavior analysis as we discussed in section .
our analysis characterizes the operations performed by the body of the loop by determining the framework api functions that could potentially be invoked from within the loop body.
this is done by both considering the class hierarchy analysis to conservatively take into account the dynamic dispatch mechanism and by consulting the inter procedural call graph.
then our system associates a semantic label to the reached framework methods according to the manually written policies described in section .
.
table 3reports how many loops have been found to possibly invoke a method with a given semantic label.
our results show that in most cases developers make use of loops to invoke low risk apis.
for example they use loops to perform simple iterations over app speci c objects iterators perform cryptographic operations crypto generating random numbers random parsing data parsing iterating over different data structures data structure .
thus the majority of loops appear to be innocuous.
loops also use android speci c methods identi ed in table 3by the following labels android specific face detector device data user data .
however as we will discuss in the following paragraphs we also found that a non negligible portion of loops might invoke several apis that in an event driven system like the android platform can impact both performance and security.
finally our analysis found that .
loops do not invoke any framework api functions.
after manual investigation of few samples we found out the most common case to be one of the following either the loop performs some sort of mathematic computation or it updates application speci c objects elds.
performance aspect.
every android application is executed by several threads one ui thread which takes care of handling user interaction and several other non ui threads.
since the ui thread is in charge of executing the interactive part of an application blocking tasks such as i o operations or network connections should always be executed in a non ui thread.
otherwise is speci cally discouraged by the official guidelines for android developers .
this is because android has strict time constraints on ui threads if a ui thread is not ready to handle a ui action then the application will be terminated with the infamous application not responding anr error message .
this aspect is so problematic that a recent version of android introduced strictmode which is quoting the official documentation a developer tool which detects things you might be by accident and brings them to your attention so you can x them.
in particular it is often used to catch accidental disk or network access on the application s main thread.
however this mechanism can be explicitly disabled by an android application.
for example to allow the invocation of network related apis within the ui thread an application can invoke android.os.strict mode threadpolicy builder!permitnetwork .
to analyze this potentially problematic aspect we implemented a simple analysis step to determine whether a given loop could be executed within a ui thread.
in particular this step performs reachability analysis starting from a given method and it proceeds backward until the entry points are reached.
then the analysis ags a loop as potentially executed within a ui thread if at least one of these entry points is a method known to be associated to the 695gui i.e.
activity.oncreate .
note that this analysis step might be affected by imprecisions.
nonetheless we believe this to be an interesting experiment.
the breakdown of our results is reported in table .
for example our analysis identi ed that loops could potentially invoke network related api functions network of which might be invoked within a ui thread.
more importantly our analysis identi ed loops that explicitly invoke at least one strictmode related api function within a ui thread and thus could create performance related issues.
we note that although these loops are not malicious they do not follow the suggested guidelines and hence we think it is interesting to report them.
security aspect.
the security relevance of the invocation of an api function can increase depending whether it is executed within the context of a loop the mere fact that a method can be invoked multiple times makes a given operation intrinsically more dangerous.
for instance a single invocation of the file.delete method which can be used to delete a le is practically innocuous however if this method is executed within a loop then the application has suddenly the capability to wipe out the phone s data and thus should be considered as suspicious or at least should be inspected by an analyst.
our analysis comes in handy because it provides detailed labels for a loop body indicating the kind of operations it can perform.
thus these labels can be used to identify suspicious loops.
a very interesting example we found is the following our analysis identi ed loops that repeatedly invoke the android.os.debug!isdebuggerconnected framework method.
this method is used to check whether the application is being debugged or not.
however this very same api function can also be used by a malicious application to avoid debugging and it should thus be considered potentially suspicious.
.
related work previous research has been focused on automatically analyzing loops in programs using techniques similar to the ones we used but with different goals.
speci cally loop analysis has been often used for worst case execution time wcet analysis whose goal is to determine the maximum length in time of the execution of a given functionality.
clearly the analysis of loops plays a key role when precisely estimating the worst case time and several approaches have been proposed in the past.
speci cally uses a pattern base approach to determine the upper bound of the number of iterations for speci c classes of program loops.
other approaches such as achieve the same goal by using program analysis and abstract interpretation similarly to what we implemented in this work.
different approaches have been proposed too.
for instance develops an approach based on dataow and compares it with the approach used by ait an automatic tool to detect timing behavior of safety critical software showing strengths and weaknesses of both.
other works focus on designing compilation passes to optimize the compilation of loops.
for instance many tools focus on analyzing loops to automatically rewrite them to exploit parallelism both in cpus and gpus .
refer to for an introduction to loop optimization techniques used respectively in gcc and llvm.
the tool we developed uses some of the techniques presented in these works but with a different goal.
our goal is not to precisely measure a program sexecution time nor to improve code compilation but to automatically identify problematic cases of loop usage to help developers or the market scale vetting process of applications.
in addition we use our tool to perform a large scale analysis of android applications to automatically obtain insights about why and how loops are currently used by developers.
although it is an undecidable problem in the general case previous research also focused on automatically verifying loops termination in programs written both in c and java .
our tool can also be used to detect non terminating loops however our goal is much broader.
in fact we designed our analysis to be more generic and to this end we relaxed the requirement of exactly understanding the number of iterations of a given loop.
in this way our analysis is able to extract interesting insights even for loops whose number of iterations cannot be precisely computed by using static analysis.
static analysis has been also extensively used to automatically detect a variety of risky programming practices and vulnerabilities e.g.
in android applications.
however to the best of our knowledge our work is the rst to speci cally focus on automatically analyzing problems related to loops which given the eventdriven nature of android play a key role when analyzing applications.
in addition static analysis has been also used to identify malware in the android ecosystem e.g.
.
although our tool does not focus speci cally on malware detection it can be used to identify speci c malicious behaviors such as time consuming or non terminating loops exhausting device s resources or device s battery that are not within reach of current generic malware detection systems.
.
conclusions in this paper we presented clapp a tool to automatically extract information about many aspects of loops such as how they are controlled and their body and behavior.
for this work we developed our analysis for the android system and we performed the rst large scale study on how and why loops are used in android apps.
in particular we used our tool to analyze loops contained in distinct android applications and we discussed several insights related to the performance and security aspects.
in the future we envision clapp to be used to help developers in identifying incorrectlyprogrammed loops and to assist the market scale application vetting process by pinpointing applications containing suspicious or risky loops that should be manually investigated.
.