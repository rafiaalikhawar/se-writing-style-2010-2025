improving model based test generation by model decomposition paolo arcaini charles university in prague faculty of mathematics and physics czech republic arcaini d3s.mff.cuni.czangelo gargantini dipartimento di ingegneria universit degli studi di bergamo italy angelo.gargantini unibg.itelvinia riccobene dipartimento di informatica universit degli studi di milano italy elvinia.riccobene unimi.it abstract one of the well known techniques for model based test generation exploits the capability of model checkers to return counterexamples upon property violations.
however this approach is not always optimal in practice due to the required time and memory or even not feasible due to the state explosion problem of model checking.
a way to mitigate these limitations consists in decomposing a system model into suitable subsystem models separately analyzable.
in this paper we show a technique to decompose a system model into subsystems by exploiting the model variables dependency and then we propose a test generation approach which builds tests for the single subsystems and combines them later in order to obtain tests for the system as a whole.
such approach mitigates the exponential increase of the test generation time and memory consumption and compared with the same model based test generation technique applied to the whole system shows to be more e cient.
we prove that although not complete the approach is sound.
categories and subject descriptors d. .
testing and debugging d. .
software program veri cation formal methods model checking general terms veri cation keywords test case generation model based testing state explosion problem abstraction the work was partially supported by charles university research funds prvouk.
.
introduction model based test generation by model checking is a wellknown technique that allows automatic generation of test cases from models by exploiting the capability of model checkers to return counterexamples .
model checkers are tools that explore the reachable state space of a model and return a counterexample if a property of interest is violated in some state.
in the context of model based testing once the testing requirements or testing goals are represented by suitable temporal logic predicates called test predicates tests are generated by forcing the model checker to build counterexamples upon violation of test predicates negation.
although completely automatic this technique su ers from the state explosion problem i.e.
the size of the system state space grows exponentially with the number of variables and the size of their domains and it could become intractable.
finding a test in an enormous state space is still a challenge.
much of the research in model checking over the past years has involved developing techniques for dealing with this problem in the context of property veri cation however several of these abstraction techniques like counterexample guided abstraction are not suitable for test generation .
indeed they can guarantee validity of a property in the original model if the property is veri ed in the abstract model but they may not guarantee to nd the right counterexample if the property is false.
other classical abstractions like slicing or reduction techniques like nite focus that soundly reduces a state machine transform the original speci cation to a smaller one for which it may be easier to nd the desired tests however they may miss parts of the system speci cation that are necessary for building the tests.
our goal was to investigate a possible solution in the context of those abstraction techniques for test generation that following the divide and conquer principle are based on system or property decomposition.
since model checkers su er exponentially from the size of the system decomposition brings an exponential gain and allows to test large systems.
in this paper we present a technique for system decomposition and a test generation approach where tests for the whole system are built as combination of tests generated for the subsystems.
the idea was inspired from our previous work in although the techniques we propose here for model decomposition and test building are di erent.
a comparison is discussed in sect.
.
we here assume that models from which test cases shall be derived are given as transition system formal speci cations.our approach is based on the following intuitions.
given a system model a variable dependency graph can be de ned on the base of variable updates given by the model assignments.
dependency induces an equivalence relation on the set of model variables and therefore variables can be partitioned into equivalence classes representing the strongly connected components of the variables dependency graph.
according to the variables decomposition in strongly connected components the transition system can be decomposed in a set of subsystems that are linked each other by exposing the same dependency relation of the corresponding strongly connected components they are built on.
for each transition subsystem the model based testing approach by model checking can be used to automatically generate tests and at least in principle it should be more e cient than the same technique applied to the global system.
the question is how to exploit the test generation approach applied at subsystem level to build a test for the system as a whole.
for the way most coverage criteria for transition systems are de ned given a test predicate tpproduced from these criteria there exists at least a subsystem containing all the variables of tp.
the test generation for tpstarts generating a test over this subsystem.
this test is then extended by providing suitable test predicates to the other subsystems in order to build by merging the test generated for the subsystems a test for the whole system covering the original testing goal.
we here describe how decomposing a transition system into linked subsystems by exploiting the model variables dependency.
we then give the algorithm to automatically generate a test covering a given test goal for the global system by merging tests obtained for the subsystems by proving them with suitable testing goals.
we prove that the generation technique is sound even if not complete.
we discuss how to re ne the technique to increase its applicability even if completeness of the re ned technique is still di cult to achieve.
results of the technique application on a certain number of case studies are presented and these results are compared with those obtained by applying the same technique without system decomposition.
experiments show that a signi cant bene t is obtained in terms of time and memory.
note that our approach can be adapted to most state based methods as scr rsml e asms event b spin promela nusmv etc.
since they can be mapped to the formal notation used here.
the paper is organized as follows.
sect.
provides some basic de nitions of transition systems and brie y recalls the model based test case generation by model checking.
sect.
introduces all necessary concepts and de nitions regarding dependency of model variables variable dependency graph and system decomposition into dependent subsystems.
the algorithm for test generation is presented in sect.
where also soundness and completeness of the technique are discussed.
experimental results about applicability and gain achieved in test generation are presented in sect.
.
sect.
reviews related literature and sect.
concludes the paper.
.
basic definitions we assume that systems are modeled in terms of transition systems.
therefore we here provide some basic de nitions adapted from .
we also brie y recall the approach of automatic test generation from models by model checking and we introduce coverage criteria suitable for transition systems.
.
transition system specifications de nition .
transition system a transition system mis a tuplexa p ywhere ais a rst order structure representing the instantaneous con guration of the system.
ahas a rst order signaturegincluding a nite set of variables v tv1 v2 vnu a domaindvifor each variable vi relations and functions and an interpretation function.
the system state is uniquely determined by the values of the variables.
pis a program consisting of a sequence of next assignment sv1 e1 v1 n en beingv1 tv1 v1 nu the variables in the next state.
each eiis a term over g possibly containing variables of vandv1.
tv1 e0 vn e0 nuis the set of initial assignment s wheree0 ican contain only variables of v. termseiande0 iin next and initial assignments may contain conditional expressions.
we assume that gmay contain a prede ned function randompdq randomly returning a value taken from domain d. de nition .
computational step executing the programpin a statesconsists in evaluating terms e1 enin sand assigning the computed values to variables v1 vn obtaining the next state s1.
note that because of variables dependencies a set of assignments cannot be evaluated in any order.
for instance the assignments x1 y1andy1 xcan be evaluated only in one order.
we suppose that pand are well de ned and thus there always exists an order that permits to evaluate all the assigned terms i.e.
there are no combinatorial loops that is cycles of dependencies not broken by delays .
for example program p tx1 y1 y1 x1uis not well de ned since it contains a combinatorial loop among variables tx yu.
de nition .
system execution an execution of a transition system is a nite or in nite sequence of states s0 s1 snsuch that the initial state s0is obtained by evaluating the assignments in and each state si 1is obtained by executing the program pat statesi.
note that transition systems allow modeling nondeterministic systems.
because of the function random executing p twice from the same state smay lead to two di erent next states.
example .
consider a locker whose one digit combination is .
if the locker digit is correct the locker becomes un locked and then the handle can be open ed.
once the digit has been set to it cannot be changed.
the locker is modeled by the transition system m xa p yshown in code .
remark .
well known state based formal approaches as scr rsml e asms event b spin promela and nusmv can be represented as transition systems.
in some cases the mapping is straightforward while other approaches could require suitable conversions.signaturea v thandle locked digitu dhandle topen closedu dlocked boolean ddigit t0 9u programp handle1 iflocked then closed else randompdhandleq locked1 digit1 digit1 iflocked then randompddigitqelse digit initial state handle closed locked true digit code transition system example locker nusmv speci cations for example can be easily mapped to transition systems since in nusmv the initialization and the update of a variable vhave the same form of initial and next assignments of transition systems i.e.
v e0andv1 e .
asm speci cations instead require a certain transformation.
an asm model can be viewed in its simplest form as a set of transition rules of the form ifguard then updates endif where updates is a set of updates of locations of the model signature in order to describe an asm as a transition system we should collect for each location l all its updates and build a next assignment l1 elwhereelis a term containing conditional expressions built from the conditions that guard the updates of lin the asm model.
in scr each table can be easily represented as a conditional assignment.
scr events that are used as terms can be translated by using the primed values of variables.
for instance the event t x which means that xbecomes true is equivalent to x1 x. similar transformations can be devised for the other formalisms.
.
model based testing by model checking in model based testing the speci cation describing the expected behavior of the system is used for testing purposes.
de nition .
test a testis a nite system execution as de ned in def.
.
tests are usually generated for covering some desired system behaviors called testing goals formally represented by test predicates.
de nition .
test predicate atest predicate is a formula over the model and determines if a particular testing goal is reached.
the generation of testing goals is usually driven by some coverage criteria.
de nition .
coverage criterion acoverage criterion cis a function that given a formal speci cation produces a set of test predicates.
a test suite tssatis es a coverage criterioncif each test predicate generated with cis satis ed in at least one state of a test sequence in ts.
ascoverage criteria for transition systems we can identify value coverage i.e.
each value of each variable is covered and guard coverage criteria as decision coverage i.e.
each decision in pand in is covered both to true and to false condition coverage i.e each atomic condition in p and in is covered both to true and to false and modi ed condition decision coverage mcdc requiring that every atomic condition in a decision found in por in is shown to independently a ect the nal value of the decision.
example .
the value coverage criterion applied to the transition system shown in ex.
produces the following test predicates fphandle openq fphandle closedq fplockedq fp lockedq fpdigit 0q fpdigit 9q.
test generation by model checking.
a classical technique for model based test generation exploits the capability of model checkers to produce counterexamples .
given a test predicate tp the trap property tpis veri ed.
if the model checker proves that the trap property is false tp isfeasible then the returned counterexample shows how to cover tp.
we call the counterexample witness and we translate it to a test.
if the model checker explores the whole state space without nding any violation of the trap property then the test predicate is said unfeasible and it is ignored.
in the worst case the model checker terminates without exploring the whole state space and without nding a violation of the trap property i.e.
without producing any counterexample usually because of the state explosion problem.
in this case the user does not know if either the trap property is true i.e.
the test is unfeasible or it is false i.e.
there exists a sequence that reaches the goal and the problem of nding a suitable test for that case remains unsolved.
.
system decomposition variables of a transition system mcan be analyzed in order to discover their dependencies and detect the way the systemmcan be modularized in subsystems.
we here rst introduce the concepts of variables dependency dependency graph and set of strongly connected variables.
then we explain how to decompose a transition system.
de nition .
variable dependency given two variablesvi vjpvof a transition system we say that vidirectly depends on vjifvj primed or not primed occurs in eior in e0 i. we denote by dirdeppvqthe set of variables which v directly depends on.
de nition .
dependency graph we call dependency graph of a transition system mthe directed graph dg xv ey wherevis the set of variables of mandpv wqpe i vdirectly depends on w i.e.
wpdirdeppvq.
we say that vdepends on wif there exists a path from vtowindg.
the dependency is the transitive closure of the direct dependency.
note that the dependency graph can contain cycles even when a program is well de ned i.e.
it does not contain combinatorial loops.
for instance in a correct program that exchanges two variables xandyby the assignments x1 yandy1 x the two variables are both dependent on the other.handlescv locked digitscv figure variables dependency graph de nition .
strongly connected variables set given a dependency graph dg xv eyof a transition system m each strongly connected component of dgidenti es a strongly connected variables set scv .
any two variables in one scv depend one on the other.
intuitively they constitute a group of interdependent quantities.
furthermore some variables in an scv may also directly depend on some variables of other scvs.
de nition .
scv inputs given an scv c we identify with inpcq vpcdirdeppvqzctheinputs ofc.
inpcqrepresents the inputs ofcsince it identi es the direct dependencies not in c of the variables of c. example .
fig.
shows the dependency graph and the two scvs of the transition system introduced in ex.
.
variable handle directly depends on locked and depends on digit.
on the base of the decomposition of system variables in strongly connected variables sets we show how to decompose the transition system.
decomposition technique.
given a transition system m xa p yand its dependency graph dg we can build a subsystemmi xai pi iyofmfor each scv ciofdg where aiis the structure obtained from aby reducing the set of variables vtovi ciyinpciq picontains the next assignments of pfor the variables inci moreover for each variable vpinpciq picontains the next assignment of vinponly if dirdeppvq h otherwise it contains v1 randompdvq icontains the initial assignments in for the variables inci moreover for each variable vpinpciq icontains the initial assignment of vin only if dirdeppvq h otherwise it contains v randompdvq.
eachmiis a well formed transition system by construction next and initial assignments in piand iare well de ned and only contain variables of vi.
we now establish some dependency relations among subsystems.
these de nitions will be used in the next section for test building.
de nition .
linking variables given two subsystemsmiandmj we call linking variables the set of direct dependencies of variables in cifrom variables in cj i.e.
lpmi mjq inpciqxcj.
de nition .
subsystems dependency a subsystem midirectly depends on another subsystem mjiflpmi mjq h .
we denote by dirdeppmiqthe set of subsystems ofmwhichmidirectly depends on.v1 handle locked m1 v2 locked digit m2 locked figure subsystems dependency graph the subsystem dependency relation induces an acyclic dependency graph among subsystems.
example .
let us consider the transition system introduced in ex.
.
the subsystems obtained through decomposition arem1 xa1 p1 1y signaturea1 v1 thandle lockedu programp1 handle1 iflocked then closed else randompdhandleq locked1 randompdlockedq initial state handle closed locked true andm2 xa2 p2 2y signaturea2 v2 tlocked digitu programp2 locked1 digit1 digit1 iflocked then randompddigitqelse digit initial state locked true digit the linking variables are lpm1 m2q t lockedu.
the subsystem dependency graph is depicted in fig.
.
remark .
for the way miis built from m its behavior subsumes the behavior of mrestricted to variables vi.
however mimay expose further computations that do not correspond to any computation of m since some of the input variables of miininpciqare randomly initialized or updated and therefore they could assume values or sequences of values not allowed in m. we now provide some de nitions to trace back computations ofmfrom computations of its subsystems.
de nition .
state projection given a state sof a transition system and a set of variables l tv1 vku we denote by lpsqthe list of values of the variables lins i.e.
lpsq tvv1ws vvkwsu.
de nition .
sequence projection given a sequence s0 snof a transition system and a set of variables l the projection of with respect to lis de ned as lp q lps0q lpsnq.
de nition .
allowed sequence a sequence isallowed if there exists an execution 1ofmsuch that varp qp 1q being varp qthe variables occurring in .intuitively a sequence of states is allowed when it is a projection of a valid execution of the entire system m. an allowed sequence may not contain the values for every variable inm but still all the variables in correctly behave.
let be an execution of a subsystem miofm.
when is an allowed sequence?
theorem .ifdirdeppmiq h then is allowed.
proof.
if a subsystem mihas no dependencies its variables setvicorresponds to ci i.e.
inpciq h therefore since the initial and next assignments of variables in ciare the same of m all the sequences of miare allowed.
theorem .ifdirdeppmiq h and inpciqp qis allowed then is allowed.
proof.
ifmihas some dependencies then inpciq h .
the behavior of the variables in inpciqcorresponds to the correct behavior as in mby hypothesis.
since the other variables in ciare computed as in m the sequence is a projection with respect to the variables viof a valid execution ofm.
intuitively an execution of a subsystem miis allowed if eithermihas no dependencies i.e.
it is a leaf in the graph or its inputs represent an allowed behavior i.e.
they force mito behave as m. .
test generation by system decomposition we have seen how exploiting variables decomposition a transition system can be decomposed in a set of linked subsystems.
we show now how to apply the model based test generation approach by model checking to the single subsystems and how to merge the subsystems tests in order to obtain a test for the global system.
our technique works on test predicates of a particular class of coverage criteria called robust de ned as follows.
de nition .
robust criterion a coverage criterion cisrobust to decomposition i for each test predicate tp produced by coverm it exists at least one subsystem mi ofmsuch that varptpq vi.miis said compatible with tp.
most of the classical coverage criteria for transition systems including all those introduced in sect.
.
are robust.
from now on we assume that the test predicates are derived from robust criteria.
in case of fragile criteria techniques for merging subsystems can be applied but this is left as future work.
given a test predicate tpthat we like to cover for m we can use as starting point of our test generation technique the subsystemmicontaining all the variables of tp.miand its dependencies are su cient to generate a test able to cover tp if it exists .
if there exists more than one mi we choose the subsystem having fewer direct and indirect dependencies.
.
test generation algorithm our test generation algorithm requires that the subgraph consisting of miand its dependencies is a tree whose root ismi.
this requirement guarantees that each subsystem provides input values at most to only another subsystem.
if the graph were not a tree a subsystem may be required toinjection pressure waterpressure a original graph injection pressure waterpressure b merging upwardsinjection pressure waterpressure c merging downwards figure transforming a graph into a tree with injection as root i getwitness tp foreach mj in dirdep mi inputseq getinputseq i mi mj reqinputstp buildtestpredicate inputseq j generatetest mj reqinputstp i merge i j return test igeneratetest mi tp generatetestpart for mj finish?
truetruetruefalse figure control ow of the test generation algorithm provide di erent values to di erent subsystems at the same time so complicating our test generation approach.
if the subgraph does not have a tree structure we keep on merging adjacent subsystems among those reachable frommi untilmibecomes the root of a tree.
note that transforming a graph into a tree having mias root can be performed in di erent ways.
fig.
shows two possible ways of obtaining the tree merging the nodes upwards towards the desired root as in fig.
3b or merging the nodes downwards away from the desired root as in fig.
3c .
in the experiments executed for this paper we have adopted the latter approach.
however as future work we plan to avoid the transformation to a tree and to generate tests directly from the original dependency graph of subsystems.
the test generation for a test predicate tpis brie y visually represented in fig.
.
it consists in a recursive function generatetest that takes in input a subsystem miofm and a test predicate tpwhichmis compatible with.
the function generatetest returns as test an allowed sequence for covering tpover the composition of miand its direct and indirect dependent subsystems.
the main steps of the function are the following.
.it nds i a witness for tpinmiby using a model checker.algorithm test generation algorithm generatetest for a subsystem miand its test predicates tp require a subsystem mi require a test predicate tpformi ensure a complete test for miand its dependencies i getwitnessptp miq if i unfeasible then return unfeasible end if formjpdirdeppmiqdo inputseq getinputseqp i mi mjq reqinputstp buildtestpredicate pinputseqq j generatetest pmj reqinputstpq if j unfeasible j unknown then return unknown end if i mergep i jq end for return i .for each dependency mj it generates a partial test jby recursively calling itself.
the test jof the subsystemmjrepresents the input sequence inputseq to be given to mito exhibit the behavior shown by i.
.it nally merges the obtained tests with iin order to nd the nal test.
the translation of the input sequence inputseq to a temporal logic predicate to be used as test predicate is performed by the function buildtestpredicate .
the algorithm is precisely described in alg.
and explained in the following.
the algorithm traverses the dependency tree in pre order .
as rst step the generatetest function computes by means of function getwitness the test i si si nto cover the test predicate tpovermi line .
if the test is not unfeasible it computes all the direct dependencies ofmi line and for each mjof them it extracts from the test ithe input sequence inputseq for the linking variables l lpmi mjq tv1 vku see def.
using function getinputseq line inputseq lp iq rti0 i0 ku tin in kus applying function buildtestpredicate to the input sequence inputseq line it computes the test predicate reqinputstp formj de ned as ltl property as follows reqinputstp in0 xpin1 xp xpinnq qq being int k h 1vh it h t n and xthe next temporal connective.
note that reqinputstp is the ltl characterization of the input sequence inputseq .
the test predicate has that particular form to obtain a sequence j in the next step of the algorithm such that lp iq lp jqwithl lpmi mjq.
it recursively visits subsystem mj calling function generatetest using reqinputstp as test predicate line as a result if any it gets the test j sj sj nformjand its dependencies note that jisguaranteed to be as long as iby the test predicate construction.
if the returned test jis neither unfeasible nor unknown the test iismerged with jthrough function merge obtaining the sequence s0 sn line where sh si hysj h h n otherwise the test is unknown.
we call this technique strongtp .
another version of the technique will be described in the next section where the test predicate construction and the merging of the tests are modi ed.
example .
let us consider the transition system introduced in ex.
whose decomposition is shown in ex.
and the test predicate fphandle openq.
the test predicate is covered in m1by the test handle s1 0hkkkkkikkkkkj closeds1 1hkkkkkikkkkkj closeds1 2hkkkikkkj open locked true false false the input sequence is tlocked trueu tlocked falseu tlocked falseu.
the corresponding test predicate for m2 is locked xp locked xp lockedqq the test predicate is feasible in m2and covered by the test locked s2 0hk kik kj trues2 1hk kik kj falses2 2hk kik kj false digit the test 1y 2for the global system is as follows handle s0hkkkkkikkkkkj closeds1hkkkkkikkkkkj closeds2hkkkikkkj open locked true false false digit soundness and completeness a technique is sound if each produced test is an allowed sequence see def.
.
theorem .the strongtp technique is sound .
proof.
alg.
recursively visits all the direct and indirect dependencies of subsystem miand builds a test sequence for each subsystem.
by thm.
all the sequences produced at line for the subsystem with no dependencies are allowed these subsystems are leaves of the dependency graph the recursive visit stops when a leaf is reached .
if the leaves are reached all the sequences built at line for their ancestors are allowed by thm.
and the construction of the test predicate at line of the algorithm.
the merging of the sequences at line produces an allowed sequence because the common variables between subsystems are guaranteed to be equal.
to prove completeness of the technique we should prove that each test predicate that can be covered on the global system is also covered by the technique.
theorem .the strongtp technique is not complete.
proof.
as counterexample consider a variation of the ex.
in code where the next assignment of variable locked is modi ed as locked1 digit i.e.
the locker becomes unlocked only after the digit is observed to be and still consider fphandle openqas test predicate to cover.in order to cover some test predicates that are not covered by the strongtp technique in the following section we slightly modify the technique using a di erent and less binding version of the test predicate reqinputstp in formula and a di erent way of merging sequences at line of the algorithm.
.
weaktp technique technique strongtp requires that sequences built over the single machines have the same length by the test predicate construction and therefore that a given submachine mi receives from its dependencies the inputs it needs exactly when it requires them.
however it may be that the dependent subsystems may not be able to provide the required inputs exactly when requested but with some delay some states later .
we modify technique strongtp with technique weaktp in which dependent subsystems of mican produce tests jlonger than the test iproduced over mi and test iis extended to match the length of tests j. in this technique the test predicate built with function buildtestpredicate from the input sequence in formula at line of alg.
is de ned as ltl formula as follows in0sxupin1sxu pinn 1sxu innq q being int k h 1vh it h t n and sxu is a new temporal operator de ned as follows asxub a xpaubqwhere uis the until temporal connective.
asxubmeans that ais continuously true for at least one state untilbbecomes true.
the test j sj sj m computed at line of alg.
with the recursive call of function generatetest for covering the test predicate if feasible is at least as long as i i.e.
m n .
jcan be split in n sub sequences j j nhaving the same values for the linking variables in lpmi mjq tv1 vku i.e.
j j 0hkkkkkkikkkkkkj sj sj r1 in0 j 1hkkkkkkkikkkkkkkj sj r1 sj r2 in1 j nhkkkkkikkkkkj sj rn sj m inn where in all the states of each j t intholds and r1 r2 rn m. at line of alg.
sequences iand jmust be merged with function merge .
sequences can be merged only if some particular states of iarestutter prone .
de nition .
given a transition system m xa p y we call a state sstutter prone if by executing pfroms we can obtain s. for each subsequence j tlonger than one state i.e.
j t statesi tof sequence imust be stutter prone.
if this condition is not satis ed the algorithm returns unknown .
otherwise sequences iand jcan be merged as follows 0hkkkkkkikkkkkkj s0 sr1 1hkkkkkkkikkkkkkkj sr1 sr2 nhkkkkkikkkkkj srn sm j si hkkkkkkkkkkkkkkikkkkkkkkkkkkkkj sj 0ysi sj r1 1ysi j n si n hkkkkkkkkkkkkkikkkkkkkkkkkkkj sj rnysi n sj mysi n where t j t si t t n i.e.
for each shof each t sh sj hysi t. note that we can merge a state si tof i with all the states of j tin j sincesi tis stutter prone and therefore can be duplicated as many times as necessary.signaturea v thandle locked digit cmdu ...dcmd tup down noneu programp ... cmd1 randompdcmdq digit1 ifcmd upthenpdigit 1qmod elseif cmd down thenpdigit 9qmod initial state ... cmd randompdcmdq code modi ed running example example .
the proof of thm.
shows a test predicate for the global system that cannot be covered with technique strongtp since that technique requires locked to become false after one step the same test predicate instead can be covered with technique weaktp.
using the weaktp technique the test predicate built for m2 starting from the input sequence of the test for m1 see formula is locked sxup locked sxu lockedq the test predicate is feasible in m2and the obtained test is locked 0hkkkkkkkikkkkkkkj true true 1hk kik kj false 2hk kik kj false digit note that variable locked remains true in the rst two states and becomes false only in the third state.
therefore we require state s1 0of sequence see formula to be stutter prone since this is the case the technique is applicable.
the test 1y 2for the complete system is handle s1 hkkkkkkkkkkkkkkikkkkkkkkkkkkkkj closed closed s1 1hkkkkikkkkj closed s1 2hkkikkj open locked true true false false digit soundness and completeness theorem .the weaktp technique is sound.
proof.
if the technique returns a test it means that in sequence i si si nall the states required to be stutter prone are so.
therefore ican be extended to a sequence i si1 si1 m by duplicating the states required to be stutter prone such that for all the couples psi1 h sj hq the values of linking variables lpmi mjqare the same this is what we actually do in formula .
then the proof of thm.
already proves that the composition of two sequences iand jof equal length and with the same values for variables in lpmi mjqis correct.
theorem .the weaktp technique is not complete.
proof.
as counterexample consider the modi cation shown in code of the transition system described in ex.
a random variable cmd over domain dcmd tup down noneuis introduced to model the transformation of the variable digit that can be increased decreased of only one unit at a time.
fphandle openqis still the test predicate to cover.
the subsystems are as shown in fig.
.v1 handle locked m1 v2 locked digit m2 lockedv3 digit cmd m3 digit v4 tcmdum4 cmd figure modi ed running example dependency graph .
experiments the proposed technique is in principle more e cient than the model checking approach applied directly to the global system but it requires several assumptions like that the system is actually decomposed by using dependency among variables which may not hold in practice and the actual advantages must be experimentally checked.
we present here a series of experiments to validate our approach.
we have performed a set of experiments using a representative example of nusmv speci cations.
nusmv is a well known tool that performs symbolic model checking.
it allows the representation of synchronous and asynchronous nite state systems and supports model checking of temporal properties.
a nusmv speci cation describes the behavior of a finite state machine fsm in terms of a possible next state relation between states that are determined by the values of variables.
its language can be easily mapped to the formalism presented in sect.
.
.
furthermore speci cations written in asm statecharts event b scr rsml e and many other notations have been translated in nusmv in several previous works .
for these reasons we chose nusmv for evaluating our approach.
we have gathered nusmv speci cations including examples from the nusmv site and models we have used in the past for testing a static analysis tool .
then we have flattened all the models in order to eliminate modules and parameters.
we have reused the parser we have built for nuseen1 an eclipe based framework for nusmv.
to analyze the dependencies build the dependency graph and compute the strongly connected variables sets we have used a feature recently introduced in nuseen.
fig.
6a shows the sizes of the considered speci cations in terms on number of bdd variables for models because models having more than bdd variables are not included in the gure the majority of models have less than bdd variables but there are still models with more than variables.
our technique however works considering the speci cation variables therefore in fig.
6b we report the distribution of variables in the considered models for models because models having more than variables are not included in the gure the distribution slightly corresponds to the distribution of bdd variables.
we present here some research questions that guided our experiments.
how many systems are decomposable by dependency?
we have applied the decomposition technique presented in sect.
to all the models.
fig.
6c reports the number of variables for subsystem on average over all the models.
most of the models have on average less than variables for subsystem.
the ideal situation of each subsystem having only one variable occurs for models which originally have on average .
variables.
only models were completely decomposable by our technique.
on average every subsystem has 39th of the variables of the entire system.
the data shows that dependencies among variables can e ciently guide system decomposition.
how many dependency subgraphs are trees?
one major assumption of the algorithm presented in sect.
.
is that the subgraph including the subsystem miand all its dependencies is a tree.
we found that this is true in of all the subsystems we have examined.
in all the other cases the subgraph must be transformed in a tree by merging nodes as explained in sect.
.
.
the transformation may increase the complexity of the scvs and jeopardize the advantages of the decomposition the worst situation would be when all the subsystems except miare merged together causing a decomposition of the system only in half.
we have implemented a simple algorithm that merges scvs until no more undirected cycles are found and the subgraph becomes a tree.
we have then measured the number of vertexes and the average of number of variables in each subsystem.
we have found that on average the number of variables for subsystem raises from .
to .
while the number of subsystems decreases from to .
so the decomposition is less e cient but it is still able to reduce the system size by a factor around even for the of the cases in which the dependency subgraph is not already a tree i.e.
from an average of variables in the global system to an average of .
variables per subsystem .
does test generation actually benefit from system decomposition?
we experimented whether the technique presented in sect.
is really useful for test generation.
we took three nusmv speci cations bombrel the bomb release component of the ight control software of an attack aircraft sis a simpli ed speci cation of the control software for the safety injection component of a nuclear power plant and lock a simple digital lock that requires the insertion of the right sequence of numbers on di erent keypads in order to unlock .
fig.
shows the dependency graphs of the three case studies.
for each speci cation we made two versions v1 and v2 by increasing the size of the variables domains.
for instance insisthe domain of the variable waterpressure is from to in version v1 and from to in version v2.
for bombrel we choose two di erent test predicates.
the rst one simply requires to observe bombrelease set to on while the second one also requires that missdistance is at least the second test predicate has been built in a way that technique strongtp is not able to nd a test but technique weaktp is.
table reports the memory required and time took by the classical generation over the complete systems column complete and by the proposed generation over the decomposed subsystems column decomposition .
for each considered test predicate we have used the strongtp technique when possible otherwise we have used the weaktp technique this has always been applicable since all the states required to be stutter prone were so .
the gain di ers in the di erent speci cations this is due both to the considered test predicate and to the degree of decomposition of the system the more the variables are distributed among the subsystems the better it is .
using the proposed technique greatly diminishes a bbd variables b variables c variables for subsystem avg figure data about the models used in the experiments a bombrel b sis c lock figure dependency graphs for the case studies the required memory and time column in all the cases except in one case in which the use of memory is increased probably due to the higher complexity of the test predicate containing the sxu operator.
note that our technique might not be able to cover a test predicate that is feasible this may weaken the fault detection with respect to the model checking approach applied directly to the global system that however might also not be able to cover the test predicate for the state explosion problem .
nonetheless whenever our technique is complete the fault detection and the coverage provided by the test cases are the same as those obtained by using the model checking approach on the global system.
.
related work since our approach is based on model checking one may immediately think of reusing abstraction techniques introduced for formal veri cation.
for this reason we initially compare our work to the research done in the area of abstractions for property veri cation.
the cone of in uence coi technique reduces the size of the transition graph by removing from the model the variables that do not in uence the variables in the property one wants to check.
in coi is used to reduce the state space of ffsm models a variant of harel s statecharts models that could not be veri ed before have been veri ed successfully after its application.
coi works well also for test generation but only if the variables in the property to be veri ed have few dependencies.
for subsystems deep inside the dependency graph coi is unable to reduce the speci cation.
actually our technique subsumes coi since we also remove variables that are not necessary for covering a test predicate.
the data abstraction technique instead consists in creating a mapping between the data values and a small set of abstract data values the mapping extended to states and transitions usually reduces the state space but it may not preserve properties.
in a technique called cegaris presented to iteratively re ne an abstract model.
the technique assures that if a property is true in the abstract model so it is in the initial model if it is false in the abstract model instead the spurious counterexample may be the result of some behavior in the abstract model not present in the original model.
the counterexample itself is used to re ne the abstraction so that the wrong behavior is eliminated.
cegar is not suitable for testing indeed the returned counterexample usually does not contain all the variables since the abstraction removes speci cation parts and it may be spurious.
a technique for sequential modular decomposition for property veri cation of complex programs is presented in .
the approach consists in partitioning the program into sequentially composed subprograms instead of the typical solution of partitioning the design into units running in parallel .
based on this partition the authors present a model checking algorithm for software that arrives at its conclusion by examining each subprogram in separation.
they identify ending states in the component where the computation is continued in another component and some information passed to the next subprogram.
the algorithm then tries to formally prove the property in each component nding the necessary assumptions about the initial entering states of the component.
the algorithm proceeds backwards until it nds that the property is true in every sub component starting from any initial state of the system.
since the goal is formal verication the algorithm must check that the property holds inanystate while in our approach disproving a property is not enough since we want to nd a counterexample i.e.
a path leading to interesting states in which a suitable property is false.
moreover we decompose the entire system in subsystems that run in parallel and not sequentially.
there exist few abstraction techniques that are suitable for test generation.
reduction techniques like nite focus soundly reduce the original speci cation to a smaller one for which it may be easier to nd the desired tests.
finite focus maps variables with large or unbounded domains to a xed subset of possible values.
in this case the number of variablestable memory consumption bdd size and time seconds speci cation test predicate complete decomposition mem.
time technique mem.
time mem.
time max sum bombrel v1 bombrelease on .
strongtp .
bombrelease on missdistance .
weaktp .
bombrel v2 bombrelease on .
strongtp .
bombrelease on missdistance .
weaktp .
sisv1 safetyinjection on .
weaktp .
sisv2 safetyinjection on .
weaktp .
lock v1 unlock .
weaktp .
lock v2 unlock .
weaktp .
to be considered is not reduced but their domains are.
in order to avoid unsound counterexamples some constraints must be added and there is not guarantee that the speci cation is actually simpler than the original one.
moreover how to reduce domain sets may be a di cult task and no algorithm is given for that.
finite focus could be used also in conjunction with our approach when generating the tests for a single subsystem.
in general our technique is compatible with all the reduction abstractions.
an approach performing test generation by decomposing sequential programs called smart is presented in .
it proposes a sequential decomposition technique given a program calling several functions inside it these called functions are tested in isolation and complete tests are composed only at the end.
the main di erence with our approach is that tests for sub functions are not real tests but they are expressed as summaries using input preconditions and output postconditions and then re used when testing higherlevel functions.
the main advantage is that smart is both sound and complete compared to monolithic test generation while our approaches are only sound.
a disadvantage is that smart must maintain the summaries and it can solve them only at the end.
sometimes constraints on some inputs can not be expressed for instance a hash function and sometimes all the collected constraints are very hard to solve leaving some issues still open.
the approach we presented in shares with this work the idea of exploiting system decomposition to tackle the limitation of model based test generation by model checking.
it presents a technique to build test for decomposable by dependency asynchronous parallel ddap systems which are systems composed of several subsystems running in parallel and connected together in a way that the inputs of one subsystem are provided by another subsystem.
apart sharing the philosophical idea of tacking a problem by decomposing it into smaller problems the approaches di er on the way a system is decomposed on the class of obtained dependent subsystems that in are interleaving subsystems while here we have parallel subsystems and on the way a test for the whole system is built on the base of the tests for the subsystems concatenation of tests in merging of tests here .
in we proposed a test generation technique for sequential net s of abstract state machines asms which represent systems constituted by a set of asms such that only oneasm is active at a time.
given a net of asms a test suite for every asm in the net is built and then the tests are combined in order to obtain a test suite for the entire system.
the technique has been later extended in for handling the passing of information between subsystems.
apart the di erent notation the main di erence with this work is that in we suppose to already have the decomposed subsystems whereas here we propose a way to decompose the global system.
moreover in the subsystems run in sequence while here they run in parallel.
.
conclusions we have proposed a test generation approach by model checking that decomposes systems into dependent subsystems on the base of the system variables dependency.
such dependent subsystems coming from the system decomposition can be viewed as systems linked each other on the base of the variables dependency in a way that part of the inputs of one subsystem are provided by another subsystem.
therefore a test of the global system can be built by suitably merging tests of the single subsystems.
such approach permits to mitigate the state explosion problem of model checking since the time and the memory required to build a test for each subsystem is considerably less than the time and the memory required when considering the system globally.
the method has been proved to be sound but not complete and its e ciency w.r.t.
the same model based testing approach without system decomposition has been shown by a number of experiments on nusmv models.
currently we automatically build the dependency graphs but not the subsystems and the test predicates.
as future work we plan to completely automatize our approach and to consider test predicates possibly involving more than one subsystem.
this will allow us to perform a larger evaluation on more models across a variety of sizes.
moreover we plan to better investigate which is the best solution for merging the subsystems when their dependency graph is not a tree.
.