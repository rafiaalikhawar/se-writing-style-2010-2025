static window transition graphs for android shengqian yang hailong zhang haowei wu yan wang dacong yany and atanas rountev ohio state university columbus oh usa email yangs zhanhail wuhaow wang10 rountev cse.ohio state.edu ygoogle inc. mountain view ca usa email dacongy google.com abstract this work develops a static analysis to create a model of the behavior of an android application s gui.
we propose the window transition graph wtg a model representing the possible gui window sequences and their associated events and callbacks.
a key component and contribution of our work is the careful modeling of the stack of currently active windows the changes to this stack and the effects of callbacks related to these changes.
to the best of our knowledge this is the first detailed study of this important static analysis problem for android.
we develop novel analysis algorithms for wtg construction and traversal based on this modeling of the window stack.
we also describe an application of the wtg for gui test generation using path traversals.
the evaluation of the proposed algorithms indicates their effectiveness and practicality.
i. i ntroduction the explosive growth in the number of deployed smartphones and tablets has significantly changed the computing landscape.
the correctness security and performance of such devices is of paramount importance for many millions of users.
for software engineering researchers this raises high expectations for developing a comprehensive toolset of algorithms for understanding testing and verification of android software.
our focus is on a key component of such a toolset a static analysis to create a model of an application s graphical user interface gui .
such a model can be used for program understanding testing and dynamic exploration .
it could also potentially be a starting point for static data flow analyses for example for checking of security properties leak defects and other correctness properties .
we propose a particular form of a gui model for android a window transition graph wtg .
nodes in this graph represent windows and edges represent transitions between windows triggered by callbacks executed in the ui thread.
to allow the development of client data flow analyses based on the wtg graph edges are annotated with the sequences of callback methods invoked by the android platform.
these annotations capture event handling callbacks and window lifecycle callbacks .
technical challenges and insights.
the representation and analysis of these callback methods play a critical role in a static analysis for wtg construction and more generally control data flow analysis for android.
transitions between windows are triggered by such methods and during these transitions additional callbacks occur.
the current state of the art in static analysis for android is inadequate when it comes to represent such run time behavior.
for example we have seen various cases from real applications where an event handler may force the closing of the current window and itspredecessor window while at the same time opening a new window this leads to complicated interleavings of callbacks for the three windows.
as another example we have seen many cases where the return from a window does not come back to the predecessor but rather to another window displayed earlier.
in existing work including our own prior work there is no conceptual clarity on these possible run time behaviors and how they can be analyzed in a static control flow analysis.
we address this problem by clarifying the major elements of such behaviors with the help of the abstraction of a window stack .
the window stack generalizes the standard android notion of a back stack which stores the currently alive activities.
activities correspond to one category of windows.
our generalization captures additional categories of windows and models the changes to the window stack.
an important observation is that a single transition in the wtg can have complex effects on the window stack for example it can pop and or push windows all as part of the same wtg edge.
a major contribution of our work is the careful modeling of these stack changes and their related callbacks both the callbacks that trigger the stack changes and the callbacks triggered by them.
to the best of our knowledge this is the first detailed study of this important static analysis problem for android.
the combined analysis of callbacks and the window stack also provides a solution to an important related problem which sequences of window transitions are feasible?
one cannot consider all wtg paths since some such paths are provably infeasible.
we can draw an analogy with the sequences of calls returns in ordinary programs modeling the possible states of the call stack is a key concern in static analysis of call return sequences which in turn is an important component of interprocedural data flow analysis .
however the behavior of the window stack can be significantly more complicated.
our work provides a systematic identification of valid wtg paths and by trivial extension valid call return sequences which is a critical prerequisite for future developments in interprocedural data flow analysis for android.
as an exemplar client we have developed a test generation tool in which valid wtg paths naturally correspond to test cases.
contributions.
the contributions of this work are definition of the window transition graph wtg as a gui model for understanding testing dynamic exploration and static checking of android applications static analysis for wtg construction employing careful modeling of the interplay between callbacks and the window stack algorithm to identify valid paths in the wtg based on modeling of window stack changes test generation tool based on the wtg and experimental evaluation of the proposed algorithms.ii.
a ndroid behavior and itswtg r epresentation a. relevant android features figure contains an example derived from the apv pdf viewer .
for simplicity the code and its description omit a number of non essential details.
the example illustrates windows e.g.
choosefileactivity gui widgets e.g.
filelistview and event handlers e.g.
onitemclick .
windows.
subclasses of android.app.activity are used to define activities which are core application building blocks.
choosefileactivity openfileactivity options and about from figure are such classes execution starts from an instance of choosefileactivity which shows a file list.
an activity displays a window containing several gui widgets.
a widget also referred to as a view is an instance of a view class .
in figure variables that refer to widgets include filelistview list of files l the same list item individual list element aboutitem optionsitem both are elements of a menu as described below and btn a button .
we also consider the two other common categories of android windows menus and dialogs.
instances of menu classes represent short lived windows associated with activities options menus and widgets context menus .
in figure openfileactitivy has an options menu initialized by oncreateoptionsmenu to contain menu items aboutitem andoptionsitem .
a dialog is an instance of a subclass of android.app.dialog .
both menus and dialogs are used for modal events that require users to take an action before they can proceed .1we will use win to denote the set of all run time windows activities menus and dialogs and view for the set of all run time widgets in these windows.
a menu dialog takes control temporarily for a simple interaction with the user and its lifetime is shorter than activity lifetime.
the last activity that was displayed before a menu or a dialog was displayed is considered to be the owner activity of this menu dialog.
in the running example the options menu is owned by openfileactivity .
there are more general cases for example in openfileactivity there exists a button not shown in figure for which a long click event opens a context menum1 in which a menu item can be clicked to open a dialogd1asking for a page number in the pdf file if an incorrect number is entered d1shows another dialog d2with an error message.
in this example openfileactivity is the owner activity of m1 d1 andd2.
the lifetime of a menu or a dialog is contained within the lifetime of its owner activity.
events.
eachw2win can respond to several events.
widget events are of the form e wherev2view is a widget and tis an event type e.g.
vcould be a button and tcould be click .
we also consider five kinds of default events .
event back corresponds to pressing the hardware back button which typically but not always returns to the window that triggered the current window.
event rotate shows that the user rotates the screen which triggers various gui changes.
for example if the currently active window is a dialog this dialog is destroyed its underlying activity is also destroyed and the activity but not the dialog is recreated and redisplayed.
event home abstracts a scenario there the user 1such windows are common for example in our experiments more than half of window transitions involved menus and dialogs.1class choosefileactivity extends activity implements onitemclicklistener arraylist filelistentry filelist listview filelistview lifecycle callbacks void oncreate ... filelistview.setonitemclicklistener this other lifecycle callbacks ondestroy onstart onrestart onstop onresume onpause widget event handler callback void onitemclick listview l view item int p filelistentry entry filelist.get p file file entry.getfile if !file.exists return intent in new intent openfileactivity.
class initialize intent based on file startactivity in 18class openfileactivity extends activity menuitem aboutitem optionsitem lifecycle callbacks oncreate ondestroy etc.
void oncreateoptionsmenu menu menu aboutitem menu.add item optionsitem menu.add options void onoptionsmenuclosed menu menu ... widget event handler callback void onoptionsitemselected menuitem item if item aboutitem startactivity new intent about.
class if item optionsitem startactivity new intent options.
class this .finish 33class options extends activity implements onclicklistener button btn void oncreate btn.setonclicklistener this void onclick view v startactivity new intent about.
class this .finish 40class about extends activity ... fig.
.
example derived from the apv pdf reader .
switches to another application and then resumes the current application e.g.
by pressing the hardware home button to switch to the launcher and then eventually returning to the application.
event power represents a scenario where the device is put in low power state by pressing the hardware power button followed by device reactivation.
event menu shows the pressing of the hardware menu button to display an options menu or a click to display the hidden parts of an action bar .
a default event will be represented as e 2win fback rotate home power menug wherewis the currently active window.
we will use event to denote the set of all widget events and default events.
callbacks.
eache2event triggers a sequence of callbacks that can be abstracted as .
here ciis a callback method and oiis a run time object on whichciwas triggered.
we focus on two categories of callbacks.
widget event handler callbacks respond to widget events.
figure shows three examples.
method onitemclick handles click events for items of list filelistview .
the call at line registers the activity with a listener for such events.
the list the item being clicked and its position in the list are provided as parameters to the callback.
method onoptionsitemselected handles clicks for items in the options menu and takes the clicked item as a parameter.
method onclick at lines responds to clicks on btn.lifecycle callbacks are used for lifetime management of windows.
these methods are of significant interest to developers e.g.
in order to avoid leaks .
there are seven kinds of lifecycle callbacks for activities as indicated in figure .
for example creation callback oncreate indicates the start of the activity s lifetime and termination callback ondestroy indicated end of lifetime.
menus and dialogs can also have create terminate callbacks for example oncreateoptionsmenu and onoptionsmenuclosed in figure .2we will use abstract names create and destroy to represent these create terminate callbacks.
similarly start pause will denote corresponding callbacks in activities and if applicable in dialogs and menus.
let cback be the set of all lifecycle and widget event handler callbacks.
b. motivation and related work section ii c describes the window transition graph wtg our proposed static representation of window transitions and callbacks.
each node corresponds to a window and each edge represents a window transition labeled with a callback sequence.
figure shows the wtg for the running example.
why this static representation?
a number of challenging software engineering problems for android can be addressed with static analyses where the modeling of control flow plays a critical role.
a few examples include checking of security properties e.g.
detection of energy defects e.g.
leak defects e.g.
data races e.g.
and other correctness checking e.g.
.
for example common battery drain defects no sleep and missing deactivation can be stated as properties of callback sequences.
these sequences could potentially be derived from wtg paths.
prior work defines a data flow analysis to identify relevant api calls e.g.
gps is turned on and to search for no sleep paths along which corresponding turn off release calls are missing.
for this work the order of callbacks is of critical importance but their solution lacks generality and precision and may even involve manual efforts by the user.
some dynamic analyses of energy defects also consider paths in which a sensor e.g.
the gps is not put to sleep appropriately often because of mismanagement of lifecycle callbacks.
a static approach to identify such code paths requires callback ordering information and the wtg can provide this information.
another example is static taint analysis for android.
representative algorithms such as do not model soundly all callback interleavings and do not employ the control flow validity constraints captured in our work.
future work could investigate whether such analyses benefit from the wtg representation.
yet another example is static detection of resource leaks.
such leaks are often the result of improper resource management under event callback sequences including events such as rotate home and back .
developing static leak detectors requires callback sequences which could be obtained from the wtg.
in addition to defect detection the wtg is directly applicable for gui model construction for program understanding testing and dynamic exploration .
in section iv we describe a test generation tool we developed based on the wtg using traversals of valid wtg paths.
2there is a related callback onprepareoptionsmenu for simplicity it is not discussed here but our implementation handles it.related work.
despite the critical importance of analyzing statically the possible gui behaviors of an android application the current state of the art lacks a systematic and comprehensive solution.
for example an activity transition graph is constructed in to guide run time gui exploration but the underlying static analysis uses conservative assumptions about gui related control flow and does not model the changes to the window stack.
other work that creates static gui models e.g.
also lacks generality and representations of the window stack.
our earlier work considers analysis of callbacks and determines ordering constraints between them.
however it also does not provide a comprehensive solution it considers only a limited subset of lifecycle callbacks it does not represent the interleavings of callbacks from multiple windows as illustrated in table i it does not model the window stack e.g.
it assumes that each back event will return to the previous window it does not handle the owner close operations described shortly it does not consider rotate home and power events.
other work that analyzes possible callbacks in android e.g.
has similar or even more significant limitations.
to the best of our knowledge the proposed static analysis is the first comprehensive solution to the important problem of modeling the possible window callback sequences in an android gui.
c. modeling of window transitions opening and closing of windows.
each callback could open a new window or close an existing one.
consider the following scenario when an exit button in an activity ais clicked the corresponding event handler opens a new dialog dto ask the user to confirm the exit.
when the dialog s yes button bis selected its handler hcloses both the dialog as well as its owner activity a and control returns back to some prior activitya0.
at each event various callbacks occur.
for example clicking btriggers .
our goal is to model statically such behavior and the related changes to the window stack.4note that we focus on the behavior of the main thread i.e.
ui event thread of the application analysis of multiple threads e.g.
as done in or of control flow across applications is not being considered.
additional limitations of the approach are discussed in section iii d. there are various api calls to open and close windows.
for example a call to startactivity opens a new activity and a call to finish closes an existing one.
similarly calls to show anddismiss can create and destroy a dialog.
these will be represented with abstract operations open w andclose w wherewis the window being created destroyed.
we have never encountered an example of an execution of a callback method cthat opens more than one window and thus we assume that any path through ccontains at most one open w operation.
operations close w may also be triggered during an execution ofc.
the two common patterns are self close andownerclose .
in a self close cis associated with a window wandc s execution issues close w an example is shown at line of figure .
another example is onoptionsitemselected 3since our approach is tightly coupled with android specific semantics it is unlikely that it will be relevant beyond android code.
4the discussion assumes android version .
some earlier versions have slight variations in certain sequences of callbacks.table i. s ome window stack changes and corresponding callback sequences .
stack event handler open close stack changes callback sequence a none none a open a0 pusha0 a0 a close a popa a close a open a0 popa push a0 a0 a implicit close a popa a implicit close a open a popa push a a implicit none none a implicit none none a implicit open m pushm a open m pushm a open d pushd a m close m popm a m close m open a0 popm push a0 a0 a m close m close a popm popa a m close m a open a0 popm a push a0 a m implicit close m popm a m implicit close m a popm a open a m pusha m a m implicit close m popm a d open a0 pusha0 associated with the options menu m the semantics of menuitem click event handlers includes an implicit menu self close operation close m that does not appear in the code.
in ownerclose operations if cis associated with a menu mor a dialogd it may issue close a for the owner activity a. for example the path at lines in figure has an open operation followed by owner close at line and then an implicit self close.
note that the actual opening closing of windows as well as the related lifecycle callbacks happen only after the callback issuing the open close operations has completed.
for example after lines are executed and onoptionsitemselected completes menu mand its owner a openfileactivity are closed activity a0 options is opened and the following callbacks are observed .
the ordering of open and close operations in a callback s execution path typically does not affect the outcome of its execution.
behavior of the window stack.
the window stack represents the set of currently alive windows.
the window that currently interacts with the user is on top of the stack.
due to space limitations we describe the case where open and close operations appear only in widget event handler callbacks.
our algorithms and implementation also handle common cases where such operations occasionally appear in lifecycle callbacks.
the window stack starts a single element the starting activitya.
the creation of this initial state is associated with the lifecycle callback sequence to initialize a .
at any moment of time the window w2win at the top of the stack determines the possible events that could be triggered by the user.
these include widget events wherev2view is a widget defined by wandtis the event type as well as default events such as etc.
when a widget event is triggered callback is invoked.
hereh2cback is the corresponding event handling method invoked on that same widget v. ifhtriggers a self close operation wis popped from the window stack.
if in addition htriggers an owner close operation the owner activity is also popped from the top of the stack.5finally ifhopens a new window this window is pushed on top of the stack.
5since the lifetime of a menu dialog is contained within the lifetime of its owner closing an owner implies that all owned windows have been closed.some of these scenarios are summarized in table i. the first column describes the stack state with the currently visible window on top.
we use aanda0to denote activities m to denote an options menu and ddenote a dialog.
only a representative sample of cases are described additional details on the scenarios captured by our algorithm are presented elsewhere .
in several rows the event handler is listed as implicit because it is defined by the android platform semantics and not by the application code.
column open close shows the window open close operations triggered by the event handler.
the corresponding changes to the window stack are shown in the next column.
after these changes are applied the new stack top becomes the visible window.
the first four rows represent an event for a widget vin an activitya.
if the window stack changes rows the callback sequences interleave lifecycle callbacks for aand the activity a0which becomes the new stack top.
the implicit handlers for default events also may trigger stack changes for example rotating the screen destroys aand then recreates it on top of the stack row .
rows present scenarios for an options menum owned by an activity a. the widget events are of the form with handlers hillustrated byonoptionsitemselected in the running example.
the implicit close m operation in his explicitly represented in the table.
row corresponds to lines in the running example and row represents the effects of lines .
window transition graph.
the wtg is defined as g win e with nodes w2win and edgese2e win win .
here we use win andview to denote sets of static abstractions of run time windows and widgets while previously these sets denoted the actual run time entities .
there are various ways to define such static abstractions.
we use the approach from which creates a separate a2win for each activity class together with appropriate m d2win for its menus and dialogs and abstractions v2view for their widgets i.e.
defined in layout xml files and then propagates them similarly to interprocedural points to analysis but with special handling of android api calls.
labels e!event indicate that the window transition represented by an edge could be triggered due to a particular event.
labels e!
fpush popg win annotate ana1 choosefileactivitye1 item click a2 openfileactivitye2 item clicke3 back m optionsmenu a2 e4 menu e5 back e6 home a3 aboute7 aboutitem click a4 optionse9 optionsitem clicke12 back e8 back e10 back e11 btn click a window transition graph e e e e e e e1 1e7 popm pusha3 e2 pusha2 2e8 popa3 e3 popa2 5e9 popm popa2 pusha4 e4 pushm 9e10 popa4 e5 popm 16e11 popa4 pusha3 e6 popm 18e12 popa3 b edge labels fig.
.
wtg for the running example.
edge with a sequence of window stack operations push w andpop w .
finally e!
win view cback shows the sequence of callbacks for the transition.
the meaning of an edge e w1!w2is as follows suppose that the currently visible window is w1 i.e.
it is on top of the window stack .
if event e is issued by the gui user the processing of this event may trigger the stack changes described by e resulting in a new stack top element w2.
during these changes the callback sequence e is observed.
example.
figure shows the wtg for the running example.
to simplify the figure edges w!wforrotate andhome events are not shown.
since edges for power are very similar to the ones for home they are not shown either.
the back event edge from the starting activity a1 which returns control back to the android platform is also not shown.
each eiis labeled with its triggering event ei .
edgee1represents the case when the pdf file does not exist line in onitemclick and the event handler returns without opening a new window.
the table shows the associated stack changes as well as row numbers from table i describing the callback sequences e .
two acyclic paths reach a3 p e2 e4 e7andp0 e2 e4 e9 e11 wherepproduces a window stack a1 a2 a3 andp0produces a1 a3 .
edgese8ande12correspond to possible next edges along pandp0 respectively.
note that if e8is appended to p0 the path is invalid it represents a stack a1 but the end node of the path is a2 which violates the property that the current window is on top of the window stack.
similarly e12cannot be appended to p. our graph construction creates both e8ande12 while our subsequent path traversal avoids the infeasible paths p0 e8andp e12.algorithm constructinitialedges 1foreachw2win do foreach widget event with callback forwdo ifmayopennone then addedge w w foreach open w0 2open do addedge w w0 ifwis an activity awith options menu mthen addedge a m addedge w w 10foreach menu and dialog w2win do findowner w 12ifwis an activity athen addedge a a addedge a a addedge a a 16ifwis an options menu mwith ownerathen addedge m m addedge m a addedge m a 20ifwis a context menu mwith ownerathen 22ifwis a dialogdwith ownerathen iii.
wtg c onstruction algorithm the static analysis algorithm to construct the wtg takes as input all w2win v2view and for each w the possible widget events and their corresponding event handler callbacks .
this information is computed by an existing static analysis described in .
given this input the algorithm proceeds in three stages.
in the first stage initial edgeseare constructed and annotated with trigger event labels e .
this stage requires analysis of open w operations in event handlers as well as modeling of default events rotate home power and menu .
since close w operations are not accounted for in this stage some of the resulting edges have incorrect target nodes.
in the second stage the initial edges are extended to include push pop sequences e and callback sequences e .
this requires analysis of self close and ownerclose operations.
in the third stage backward traversal of the graph is used to analyze the push pop sequences along traversed paths in order to determine the correct target nodes of edges that could not be resolved earlier.
a. stage open window operations and default events in stage helper function a ddedge w1 w2 ev represents the addition to the wtg of an edge from window w1to windoww2.
the edge is labeled with event ev a widget event wherevis an widget in w1 or a default event .
the first stage of the analysis applies algorithm .
for each window w in addition to w s widget events and their callbacks the algorithm requires two additional properties.
the first is a map open mapping each callback to the set of open w0 operations that could be triggered by paths in the callback s execution.
the second is a map mayopennone from to a boolean value true if the callback s execution could complete without triggering anya1 choosefileactivitye1 item click a2 openfileactivitye2 item click e3 back m optionsmenu a2 e4 menue6 home e5 back a3 aboute7 aboutitem click a4 optionse9 optionsitem clicke8 e12 back e11 btn click e10 backfig.
.
wtg after stage .
open w0 i.e.
there is an execution path without windowopen operations and false otherwise.
both of these maps can be computed using an approach from in which interprocedural control flow traversal of h and its transitive callees is performed to find calls such as startactivity .
algorithm considers each event and its callback.
if could be executed without opening a new window an edge w!wis created.
edge e1in figure illustrates this case the edge is created because there is a path in onitemclick through line in figure for which no windows are created.
we will refer to such edges as no open edges.
next each possibly opened window w0is considered.
at line an edge fromwtow0is created for event .
line handles default event menu for activities.
the edges created at lines and push a new window on top of the window stack and will be referred to as window open edges.
at line initial edges for back button events are created.
the targets of these edges as well as their callback sequences will not be known until stage .
next for each menu and dialogw its owner activity is determined by traversing backward the newly created window open edges using helper function f indowner .6finally default events rotate home andpower are handled.
this handling is consistent with the description in table i. the cases for context menus and dialogs are not shown but they are similar to those for options menus.
example.
figure shows the wtg for the running example after stage has completed.
the edge numbering is the same as in the final wtg from figure .
similarly to that earlier figure certain rotate home and power edges are not shown for simplicity.
edge e1is created because mayopennone is true for the corresponding event handler while e2shows that this handler could open a2.
the owner of misa2 and the home edge formreflects that.
the back event edges have incorrect targets that will be fixed later.
the back event edge fora3is labeled as e8 e12since eventually it will lead to the creation of two separate edges e8ande12.
6in general wcould have multiple owners e.g.
due to subclassing of activities the necessary algorithmic generalizations are straightforward.b.
stage close window operations in this stage the analysis first considers each edge efor a widget event and handler .
using the interprocedural control flow reachability analysis from hunder calling contextvis analyzed for self close operations e.g.
calls to finish andeis classified in one of three disjoint categories must not self close may self close and must self close.
if h under context vdoes not contain a path reaching a self close operation eis in the first category.
if some but not all paths reach a self close the second category applies.
if every path reaches a self close the edge is must self close.
in a similar manner classification is performed for ownerclose operations.
the analysis considers each menu and dialog wandw s owner activity a. for an edge e w!
for a widget event we can classify eas must not close owner may close owner and must close owner.
example.
in figure e7ande9are must self close due to the implicit close m inonoptionsitemselected .
edge e11is also must self close due to the call to finish at line in the running example.
if hypothetically this call were guarded by a conditional the classification would have been may self close.
the other two widget event edges e1ande2 are must not self close.
for owner close operations e7is mustnot close owner while e9is must close owner since under widget context optionsitem the handler definitely closes the owner activity a2 line in the running example .
this classification is used to create push pop labels e for the analyzed edges.
for example e9opensa4while definitely closingmand its owner a2 thus e9 popm popa2 pusha4.
algorithm provides some details on this process.
one important observations is that a single edge created by stage may be expanded into several edges with different e labels.
for example if hypothetically e11were mayself close it would expand to two edges from a4toa3 one labeled with pusha3 line in the algorithm and the other withpopa4 pusha3 line in the algorithm .
helper function expand edge e d takes an edge ecreated by stage and constructs an expanded version of it with e d. after stage the edges from stage are discarded.
some details of the processing are elided due to space limitations.
for example the handling of dialogs is similar to that of menus but with the additional possibility that a selfclose operation is not executed.
the handling of rotate home andpower events is consistent with the push pop sequences listed in table i and is not shown in algorithm .
after the algorithm completes all edges have labels e .
the labels created for the running example are shown in figure 2b.
at this point there is still a single back event edge for a3 labeled with popa3 stage creates two separate edges from it.
certain edges have incorrect targets and have to be processed by stage .
these edges do not open new windows but close existing ones namely edges for back events and no open edges that contain close operations.
in both cases the top of the stack after executing the edge is some yet unknown previously opened window.
the rest of the edges have correct target nodes and their callback sequences e can be determined at this time using the android semantic specification illustrated by table i. for edges e1 e2 e4 e6 e7 e9 e11from figure the callback sequences computed by stage arealgorithm expandedgeswithlabels 1foreachw2win do ifwis an activity athen foreach window open edge e a!w0do ifeis may must self close then expand edge e ifeis not must self close then expand edge e foreach no open edge e a!ado ifeis may must self close then expand edge e ifeis not must self close then expand edge e ifexistse a!mfor default event then expand edge e ifwis a menumwith ownerathen foreach window open edge e m!w0do ifeis may must owner close then expand edge e ifeis not must owner close then expand edge e foreach no open edge e m!mdo ifeis may must owner close then expand edge e ifeis not must owner close then expand edge e ifwis a dialogdwith ownerathen 28foreach edgew!wfor default event do expand edge e listed in figure 2b.
the rest of the edges in figure have incorrect target nodes and since e depends on the target of e their callback sequences cannot yet be determined.
c. stage backward analysis of the window stack edges with incorrect targets require further processing.
they are of the form e w!w with labels e containing nopush but at least one pop.
to identify the correct target of e stage performs a backward traversal from w using correct edges finalized in stage to examine all paths ending at w. this traversal is parameterized by a value k which defines the largest number of edges along any path being considered.
for each such path e1 e2 e n wheren kand the target node of enisw we need to consider the sequence of push pop operations e1 e2 en e and to decide whether this sequence represents valid run time behavior and what could be the top of the window stack after the sequence is executed.
example.
suppose that k 2and we consider e5 m!m in figure labeled with popm.
two paths ending at mneed to be examined e2 e4ande6 e4.
the edge labels for the first path including e5 s label are pusha2 pushm popm.
this is a feasible sequence whose execution is guaranteed to leavea2as the top of the stack.
thus e5should have a2 7an alternative would be to traverse all acyclic paths without a length limit.as a target and the analysis creates this corrected edge.
for the second path the edge labels including e5 are popm pushm popm.
although this is a feasible sequence it does not provide enough information to decide what would be the top of the stack after executing these operations and the analysis does not create any edges due to this path.
as another example consider edge e10 a4!a4.
fork the relevant path is e0 e2 e4 e9.
heree0is an implicit edge enteringa1 labeled with pusha1 this edge represents the triggering of the start activity a1by the android platform.
the sequence for e0 e2 e4 e9 e10ispusha1 pusha2 pushm popm popa2 pusha4 popa4.
this sequence leaves a1as the top of the stack.
thus e10should be redirected to a1 as shown in the graph in figure .
as a final example consider back event edge a3!a3.
pathe2 e4 e7 with this edge appended has the sequence pusha2 pushm popm pusha3 popa3.
thus this back event edge should have a2as target.
in the final graph from figure e8is this redirected edge.
another relevant path is e0 e2 e4 e9 e11 the sequence along the path appended with theback event edge is pusha1 pusha2 pushm popm popa2 pusha4 popa4 pusha3 popa3 which leaves a1 as the top of the stack.
in this case an edge from a3toa1 needs to be introduced e12from figure .
stage analyzes an edge e w!was follows.
a stack containing push andpop operations is maintained.
the stack is initialized with the reverse of e for all examples from above this is an operation popw.
backward traversal from w is performed limiting path length to at most kedges.
when an edgeeiis encountered during the traversal the reverse of its ei sequence is used to update the stack.
if popw0is seen it is just added on top of the stack.
if pushw0is encountered and the stack is not empty the top of the stack must be popw0 otherwise the path is infeasible and is ignored and popw0is removed from the stack.
if pushw0is observed when the stack is empty the traversal stops and w0is identifies as a possible target leading to a new edge w!w0.
example.
consider edge e10 a4!a4.
starting from a stack containing popa4 edgese9 e4 e2 e0are visited to produce the following sequence pusha4 popa2 popm pushm pusha2 pusha1.
operations pusha4andpusha2empty the stack.
since pusha1occurs for an empty stack edge e10 becomesa4!a1.
d. limitations the algorithm and its implementation have several limitations.
as discussed earlier control flow due to multiple threads or across multiple applications is not modeled.
the modeling of gui widgets and event handlers captures many commonly used android widgets but is not fully comprehensive.
furthermore custom window widget systems cannot be handled.
asynchronous transitions e.g.
due to timers and sensor events are not represented in the wtg.
the interprocedural intent analysis used to resolve open w calls considers only explicit intents as they are designed for use inside the same application .
more general intent analyses e.g.
could be used instead.
our analysis also does not model the different launch modes for activities .
due to these limitations some window transitions are missing for example for the apps used in our evaluation on average of the wtg nodes have no incoming edges.
while most of these limitations are orthogonal to the contributions of this paper they emphasize the need to advance the state of the art in static analysis for android and in particular the comprehensive modeling of android specific control flow and data flow.
e. path validity the analysis outlined in the previous sections does not ensure that each path represents a feasible run time execution.
consider again the final wtg after stage shown in figure .
paths p e0 e2 e4 e7andp0 e0 e2 e4 e9 e11 both reach node a3.
however pcannot be extended with edge e12because the corresponding edge labels would be pusha1 pusha2 pushm popm pusha3 popa3.
this leaves a2as the top of the window stack while the target node of e12is a1.
similarly if p0were extended with e8 the top of the stack would bea1while the target of e8isa2.
the wtg can be augmented with a path validity check which simulates the window stack along a given path of interest and decides whether the path is valid.
this is similar in spirit to classical interprocedural analyses where the sequence of calls and returns along a path is used to simulate the call stack in order to decide path validity .
a wtg edge may correspond to several push pop operations but the validity of these operations is still based on the same style of push pop matching as in traditional analyses.
as discussed in the next section one use of this validity check is during test generation to avoid the creation of unexecutable test cases.
path validity checks may also be needed for static checking of correctness properties in order to avoid analyzing infeasible paths that lead to false positives.
iv.
t estgeneration one possible application of the wtg is for model based test generation e.g.
.
to illustrate this use of the wtg we developed a prototype test generation tool.
the tool traverses certain wtg paths and for each path creates a test case implemented with the robotium testing framework .
for a pathp e1 e2 the event label ei is translated to corresponding robotium api calls to trigger the event.
some events may require additional input from the tester e.g.
to decide which item in a list to click.
since the static analysis solution is conservative it is possible that event ei may not be feasible at run time or even if it is feasible the target window ofeiafter the run time event is not as expected.
each test case includes run time checks to detect such scenarios and report the test case as infeasible.
one can consider various test generation schemes e.g.
leak testing in considers neutral effect cycles in a manuallyconstructed model .
in our proof of concept tool we use a simple path based approach.
starting from the implicit edge e0showing the invocation of the start activity we append m distinct edges to create a path p e0 e1 e m. a naive approach is to simply explore all such paths.
a more precise approach is to apply the validity check from section iii e each time the path is extended with a new edge.
the next section shows that this validity check which is based on our proposed tracking the push pop sequences can reduce substantially the number of test cases being generated.v.
e xperimental evaluation the wtg was constructed for the open source applications used in our prior work .
the first goal of the evaluation is to characterize the effects of different stages of the algorithm as well as its overall cost.
the second goal is to evaluate precision relative to a manually constructed model.
the third goal is to evaluate precision for the test generation from section iv.
the implementation is available as part of our public analysis toolkit .
a. algorithm for building the wtg table ii provides measurements of the number of wtg nodes and edges.
column stage shows the number of edges before considering any close window operations algorithm .
after stage the edges are expanded with push pop sequences based on analysis of close window effects.
column 2shows the increase due to this expansion.
one can observe that an edge from stage can often have several possible push pop sequences.
this indicates that an event handler may exhibit a variety of behaviors.
our analysis discovers such variations and represents them with separate edges algorithm .
we are not aware of any existing work that performs such detailed analysis of android event handlers.
the large number of edges for fbreader andxbmc is caused by a known limitation of our prior analyses both analyses use a context insensitive call graph based on class hierarchy analysis.
for example in fbreader two utility methods are responsible for over of the wtg edges.
both methods take parameters of an interface type which is implemented by classes.
class hierarchy resolution for calls on these parameters is highly imprecise.
more precise call graph construction is likely to solve this problem.
recall that some of the stage edges have incorrect target nodes.
column stage shows the number of edges after the correct targets have been determined.
this is achieved with backward path analysis based on a parameter kfor path length the column contains measurements for k .
column 3shows the size of the difference number of edges removed and added between the edge sets from stage and stage .
the backward path traversal combined with tracking of feasible push pop sequences along the path section iii c results in significant changes to the graph.
the next four columns show the effects of increasing the path length limit k. in general newly created edges require backward traversals of non trivial length.
thus one cannot consider just the edges entering a node wto determine the targets of stage edges w!
rather paths of length kreachingwmust be examined.
to the best of our knowledge ours is the first approach to perform such static modeling of possible transitions in android guis.
for most programs the graph stabilizes at k for the rest slightly larger values of k not shown here are needed.
the last column shows the running time of the analysis in seconds.
this measurement includes the time for the event handler analysis from which is invoked on demand inside our analysis.
overall the running times are suitable for practical use even though we have not made any significant effort to optimize the implementation.
however as indicated by the results for fbreader scalability limitations could be encountered for large wtgs.table ii.
wtg construction algorithm number of nodes edges and analysis cost .
application sloc nodes edges k time stage stage stage k k k k sec apv astrid barcodescanner beem connectbot fbreader k9 keepassdroid mileage mytracks notepad npr openmanager opensudoku sipdroid supergenpass tippytipper vlc vudroid xbmc table iii.
f easibility of wtg edges .
application wtg manual infeasible apv barcodescanner openmanager supergenpass tippytipper vudroid b. manual examination of wtgs for in depth evaluation of analysis precision we examined the wtg k for apv barcodescanner openmanager supergenpass tippytipper and vudroid .
these applications had the smallest numbers of wtg nodes and thus could be examined manually with reasonable effort.
column wtg in table iii replicates the stage measurements from table ii.
column manual shows the number of wtg edges that were manually confirmed to be feasible using run time test cases.
the last column contains the number of infeasible wtg edges.
the infeasibility was asserted by examining the source code.
in general the number of infeasible edges is small around across the six applications .
we determined the root causes of all infeasible edges.
in all cases the infeasibility was due to deficiencies in the earlier work on window widget modeling and event handler analysis .
if these existing static analyses were to be improved the wtg would achieve perfect precision.
these results highlights the need for continued advances in static analysis of gui structure and behavior for android applications.
still the small number of infeasible edges is a positive indicator that highlyprecise static gui models can be constructed automatically.
c. test generation recall that our prototype test generator considers paths p e0 e1 e m alleiare distinct and generates test cases from them.
heree0represents the invocation of the start activity by the android platform.
the numbers of paths for m and m are shown in table iv.
columns all contain the number of all paths while columns show the reduction in percent when the path validity check from section iii e isapplied.
for fbreader the number of paths with m 3was too large enumerate in reasonable time.
for several applications the path validity check reduces the number of test cases.
for example for m i.e.
test cases containing three gui events applications show reductions of26 or more.
such reductions indicate that statically we can eliminate significant numbers of infeasible test cases.
of course even if a path satisfies the static validity condition it could still result in an infeasible test case.
as indicated earlier due to deficiencies in prior static analyses some wtg edges and thus paths may be infeasible.
to understand better this infeasibility for the six applications studied in section v b we generated test cases from the statically feasible paths for m .
although the sequences of events implemented through robotium api calls are generated automatically some test cases still require manual effort for example for barcodescanner we need to manually set up a variety of actual barcode images to drive the different test cases.
due to this manual effort we did not consider larger values of m. the number of test cases with path validity is shown in column static in table v. we set up and executed all test cases indicated in this column.
the next column feasible shows the number of these test cases that were feasible at run time that is they could match the event sequence and target windows of the static path.
in barcodescanner the event handler analysis from leads to infeasible edges that make most of the test cases infeasible.
as described in the application processes eleven types of barcodes and the gui behavior subset of visible widgets and subset of handler effects differs based on the barcode type.
this variability cannot easily be modeled statically.
in openmanager the .
of infeasible test cases are due to inter application interactions.
when the main activity is invoked by another application rather than by the user that activity computes information about a file returns it to the invoking application and closes itself.
our analysis does not model the interactions between multiple applications and does not recognize that the activityclose operation happens under these conditions.
overall with the exception of one application the vast majority of staticallygenerated test cases are feasible at run time.table iv .
n umber of paths for test generation .
application m m all all apv .
.
astrid .
.
barcodescanner .
.
beem .
.
connectbot .
.
fbreader .
n a n a k9 .
.
keepassdroid .
.
mileage .
.
mytracks .
.
notepad .
.
npr .
.
openmanager .
.
opensudoku .
.
sipdroid .
.
supergenpass .
.
tippytipper .
.
vlc .
.
vudroid .
.
xbmc .
.
table v .
r un time feasibility of generated test cases .
application static feasible apv barcodescanner openmanager supergenpass tippytipper vudroid summary.
columns 2and 3of table ii indicate that event handlers can have complex behaviors and their transitions depend on non trivial sequences of preceding events.
our analysis is the first to model these features leading to improved static gui models and test case generation.
for six applications manual comparison with run time behavior indicates that the analysis achieves good precision.
vi.
r elated work control flow analysis for android.
the control data flow of android applications is driven by the gui and static analysis of this flow is an important problem.
one of the first related efforts is the scandroid analysis tool which employs control flow analysis and intent analysis in the context of a security analysis.
later work on related security problems also uses intent analysis and control flow analysis.
these techniques do not attempt detailed analysis of guirelated control data flow due to widgets and event handlers.
an activity transition graph used for run time gui exploration and based on has some similarities to our wtg.
this representation does not capture menus dialogs does not consider the general gui effects of event handlers e.g.
window close and the triggered callbacks and does not model the window stack and its state changes.
a similar model of activity transitions is used in an analysis of security sensitive behaviors .
this approach is much less comprehensive than ours in terms of both the model and the analysis algorithm.
the taint analysis in flowdroid models the effects of callbacks by creating an artificial main method.
the flow of control in this method encodes possible sequences of callbacks but does not account for the general gui effects ofevent handlers and does not represent control flow that spans multiple activities.
this approach cannot capture the callback sequences described in table i. control flow involving dialogs menus and window termination is also not captured.
a more comprehensive solution is available from our prior work where ordering constraints between callbacks are represented by a callback control flow graph.
this work provides event handler analysis for our wtg analysis to detect window open close effects of callbacks .
however this earlier approach does not represent the window stack the push pop sequences at transitions or the path feasibility based on these sequences.
it also ignores several categories of lifecycle callbacks cannot represent correctly the callback interleavings from table i does not handle operations that close the owner and does not represent the effects of rotate home and power .
an existing operational semantics for activities captures aspects of android control flow including callbacks and the activity stack but does not define gui static models or analysis algorithms.
various other static analyses aim to model the sequences of callbacks in android in the context of security analysis e.g.
gui model construction e.g.
race detection e.g.
leak analysis e.g.
and static checking e.g.
.
none of these techniques provide comprehensive behavior definition analysis for the key aspects of gui behavior widgets event handlers callback sequences and window stack changes.
we develop a more general approach for static analysis and representation of android gui behavior which provides a promising starting point for generalizing existing and future static analyses.
gui models for understanding and testing.
reverse engineering of gui models is well developed in prior work e.g.
and has more recently been used for android e.g.
.
the models are usually constructed through dynamic exploration.
as results from indicate a static approach could produce more comprehensive models of course at the expense of potential infeasibility.
for the purposes of program understanding hybrid static dynamic techniques are the most promising.
existing examples of such techniques may benefit from our static gui models including the path validity check which could be beneficial for dynamic gui crawling.
finite state machines and similar models for gui testing have been used widely e.g.
and various test generation schemes can be employed e.g.
.
techniques have been proposed to improve the generated test cases e.g.
and it may be possible to integrate them with wtg based test generation.
vii.
c onclusions a representation of window callback sequences is a foundation for static analyses for android.
one can draw an analogy with the interprocedural control flow graph a key representation for traditional static analysis.
we propose the wtg as a similarly important static model for android and develop algorithms for its construction and traversal.
in the future it is important to generalize this work to handle more comprehensive control flow in android applications.