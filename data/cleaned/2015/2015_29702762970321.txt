mining input grammars from dynamic taints matthias h schele saarland university saarland informatics campus saarbr cken germany hoeschele cs.uni saarland.deandreas zeller saarland university saarland informatics campus saarbr cken germany zeller cs.uni saarland.de abstract knowing which part of a program processes which parts of an input can reveal the structure of the input as well as the structure of the program.
in a url for instance the protocol http the host and the path path would be handled by different functions and stored in different variables.
given a set of sample inputs we usedynamic tainting to trace the data flow of each input character and aggregate those input fragments that would be handled by the same function into lexical and syntactical entities.
the result is a context free grammar that reflects valid input structure.
in its evaluation our autogram prototype automatically produced readable and structurally accurate grammars for inputs like urls spreadsheets or configuration files.
the resulting grammars not only allow simple reverse engineering of input formats but can also directly serve as input for test generators.
ccs concepts software and its engineering !input output dynamic analysis theory of computation !grammars and context free languages social and professional topics !software reverse engineering applied computing !document analysis keywords input formats context free grammars dynamic tainting fuzzing .
introduction since the invention of the turing machine a program is typically described as a machine that input and output a string of symbols.
the set of such strings that the machine accepts or produces is called a language.
the field of formal language theory long has studied the structural aspects of such languages using formal languages like regular expressions or context free grammars to exactly specify the language.
the practical importance of such formal languages cannot be overstated.
in programming languages software systems computer networks or general software development formal languages and equivalent automata diagrams are among the foo bar lorem ipsum fragment ftp bob ftp.example.com oss debian7.iso figure sample url inputs url protocol authority path authority host protocol http ftp userinfo host port path n query foo bar lorem ipsum ref figure grammar derived by autogram from java.net.url processing the inputs in figure .
optional parts are enclosed in brackets regular expression shorthands are enclosed in .
.
.
.
most frequently used methods to specify inputs and outputs and consequently regular expressions and grammars are an essential part of computer science curricula.
in this paper we present a novel practical method that given a set of program runs with inputs automatically produces a contextfree grammar that represents the language of the inputs seen.
the resulting grammar facilitates understanding of the input structure can serve as a base for automated test generation by feeding it into a producer and can be used by a computer to parse decompose and analyze other inputs.
here is an example.
java.net.url is a java class that parses a uniform resource locator url into its constituents.
assume a program pthat uses java.net.url to parse the urls given in figure .
given the program pand these inputs our autogram prototype automatically produces the grammar shown in figure which pretty accurately reflects the structure of the urls processed.
how do we obtain this grammar?
the key idea is to dynamically observe how input is processed in a program.
we instrument the program with dynamic taints that during execution tagging each piece of data with the input fragment it comes from.
now if some function of the program processes only a part of the input or if a part or a value derived from it is stored in a variable then this part becomes a syntactical entity .
in our example the method java.net.url.set eventually stores the url components as parsed in the java.net.url class.
figure shows the taints from the original input as its parts are being passed as arguments to java.net.url.set .
the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
java.net.url.set param protocol param host param port param authority param userinfo param path param query param ref setfield protocol setfield host setfield port http user password http user password user password command foo bar lorem ipsum fragment http java.net.url.set figure dynamic tainting in autogram .
at the end of url parsing java.net.url.set is invoked with parameters such as protocol http host orport .autogram instruments the program such that each input character is associated with its position in the input.
this taint propagates to derived values and variables as the input is processed asjava.net.url.set stores its arguments in object attributes their taints propagate along.
protocol part of the url http and ftp in our inputs is passed as argument for the protocol parameter and later stored in an object attribute of the same name .
this both identifies the protocol part and gives the entity a readable and meaningful name.
the arguments host andport thus also lead to entities in the grammar.
if a part processed by a function subsumes smaller parts we introduce a rule that composes the part out of its subparts.
this is how the authority entity is composed of smaller parts such as host or the optional userinfo orport see in figure how the authority argument is just an aggregation of its smaller parts.
not all entities decompose into smaller fragments though since java.net.url never stores or handles user and password separately we retain a single entity userinfo likewise queries or hostnames would not be further decomposed.
after assigning entities and their hierarchy we use a regular expression learner to generalize multiple terminals into matching automata thus the host entity becomes a string of lowercase letters and dots.
our approach thus results in grammars as shown in figure grammars with significant impact in software development .
the grammar gives humans immediate and detailed insights into the structure of inputs thereby facilitating reverse engineering of input formats as well as manually writing valid test inputs.
to value this contribution simply consider figure and assess how such knowledge automatically produced could facilitate reverse engineering.
.
the grammar can immediately be used by test generators to produce high numbers of varied and valid inputs thus facilitating automated robustness testing and fuzzing.
while the grammars produced may overgeneralize a real host name for instance may not contain two consecutive dots which is not reflected in our grammar this is not a major concern in test generation as invalid inputs would be rejected by the program just as a compiler may reject syntactically valid but semantically invalid programs.
.
the grammar vastly simplifies the creation of parsing programs that decompose existing inputs into their constituents.
note though that our grammar may overspecialize and may require human inspection and or adjustment.
for instance in figure the port andquery entities for instance reflect the respective single values seen so far these would be generalized either by providing additional sample inputs or by having a human adjust the respective rules.the contributions of this paper are as follows.
to the best of our knowledge the present work is the first to automatically derive a context free input structure from given inputs making use of aprovided processing program to derive lexical and syntactical structure as well as entity names.
this is in contrast to related work section which does not make use of existing programs and therefore has to rely on additional lexical or structural hints.
minor contributions include our method to associate processed data with positions in the program input section as well as our grammar synthesis from jointly processed entities including deriving entity names from variable and function identifiers section .
section evaluates our autogram prototype in terms of accuracy and completeness where we use it to parse and produce yet unseen inputs respectively on a set of common input formats.
we close with conclusion and future work in section .
.
background autogram joins three areas language induction tracking input origins and data tainting.
language induction.
languages play a crucial role in software both in programs as in data.
the wikipedia page on file formats lists more than commonly used file formats which is likely only a small fraction of the many proprietary data formats used by programs all across the world.
given these many languages it is only natural that researchers have thought about how to reverse engineer languages from given inputs.
the field of language induction has provided a multitude of approaches to infer languages and patterns from mostly natural language text for a comprehensive overview we recommend the textbook by de la higuera .
the vast majority of approaches however focuses on regular languages.
the single exception is the work by sakakibara which infers context free grammars from given strings if given skeletons i.e.
some form of structural hints.
by leveraging program executions autogram is able to construct such hints and decompose the input into its structure.
input origins.
to the best of our knowledge relating input fragments to code fragments that process it was first suggested by clause and orso for their penumbra work .
their idea is to track inputs as they propagate during execution and if some function fails they would be able to identify those inputs that the function uses and therefore would be responsible for the failure.
penumbra computes such origins only 721for specific variables though whereas autogram tracks the entire input as it is being processed.
data tainting.
autogram relies on dynamic tainting to identify the origins of data fragments and track their flow during program execution.
dynamic tainting allows us to precisely identify which parts of a programs input are read stored and processed at any point in time.
the dynamic tainting as implemented in autogram is inspired by phosphor a portable implementation of dynamic taint analysis based on bytecode instrumentation of all classes including the java api.
in contrast to phosphor however autogram can taint arbitrary values including primitives and internalized strings with string origin descriptions which consists of arbitrary long lists of input regions.
all in all we are not aware of an approach that would use a mapping between input and locations processing them to derive structural input descriptions let alone context free grammars as with autogram .
.
tainting input characters the tainting framework of autogram is inspired by the phosphor work.
it is based on bytecode instrumentation that in constrast to phosphor does not modify method signatures and uses separate shadow memory to store taint information for local variables stack values and arrays.
this separation and the usage of an unmodified version of asm make it easier to combine it with additional instrumentation and to make it interoperable with uninstrumented code.
our implementation can also add shadow information to