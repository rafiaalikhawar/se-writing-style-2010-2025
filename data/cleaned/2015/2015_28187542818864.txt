an empirical study on real bug fixes hao zhong yzhendong suy department of computer science and engineering shanghai jiao tong university china yuniversity of california davis usa zhonghao sjtu.edu.cn su ucdavis.edu abstract software bugs can cause significant financial loss and even the loss of human lives.
to reduce such loss developers devote substantial efforts to fixing bugs which generally requires much expertise and experience.
various approaches have been proposed to aid debugging.
an interesting recent research direction is automatic program repair which achieves promising results and attracts much academic and industrial attention.
however people also cast doubt on the effectiveness and promise of this direction.
a key criticism is to what extent such approaches can fix real bugs.
as only research prototypes for these approaches are available it is infeasible to address the criticism by evaluating them directly on real bugs.
instead in this paper we design and develop b ugstat a tool that extracts and analyzes bug fixes.
with b ugstat s support we conduct an empirical study on more than real world bug fixes from six popular java projects.
comparing the nature of manual fixes with automatic program repair we distill findings which are further summarized into four insights on the two key ingredients of automatic program repair fault localization and faulty code fix.
in addition we provide indirect evidence on the size of the search space to fix real bugs and find that bugs may also reside in non source files.
our results provide useful guidance and insights for improving the state of the art of automatic program repair.
i. i ntroduction over the past decades software has permeated into almost every economic activity and is boosting economic growth from many perspectives.
at the same time like any other manmade artifacts software suffers from various bugs which lead to incorrect results deadlocks or even crashes of the entire system.
when this happens in a critical application it can cause great loss of money or even human lives.
for example zhivich and cunningham report that the software of a hospital miscalculated the proper dosage of radiation for patients.
in this accident at least eight patients died.
to improve the quality of software it is desirable to fix as many bugs as possible.
the long battle with software bugs began ever since software existed.
it requires much effort to fix bugs e.g.kim and whitehead report that the median time for fixing a single bug is about days.
it has been actively studied to reduce the effort of fixing bugs.
a recent research direction is to investigate automatic approaches to fixing bugs see section v for a detailed discussion .
a typical approach in this direction first locates faults of a program and then mutates the located faulty code with predefined operators until the program passes all the test cases.
in this paper we refer to this line of research asautomatic program repair which complements traditional approaches e.g.
since it has the potential to deal with a variety of different bugs.
research in this direction has alreadyproduced promising results.
for example le goues et al.
reported that their approach was able to automatically fix out of bugs.
however many people question the positive results.
existing approaches e.g.
seem to be able to fix only simple bugs due to various limitations.
for example table of kim et al.
lists their ten templates to fix bugs which are all quite simple.
as existing empirical studies e.g.
show that it requires much expertise and time to fix bugs many researchers doubt the reported positive results.
for example at icse monperrus criticized kim et al.
s recent work and discussed a number of issues concerning this research direction.
the preceding criticism shows that the research community has limited knowledge on the nature of bug fixes.
although empirical studies exist to understand bug fixes see section v for details only one analyzed the links between the nature of bug fixes and automatic program repair.
furthermore the empirical study focuses on only one aspect of automatic program repair namely the search space of fixing bugs most questions raised by monperrus are still open.
for example how many bugs could be fixed by automatic program repair?
which parts should be focused upon to further improve the state of the art?
it is important to carefully design an empirical study to answer these questions and its results will benefit future research in this direction benefit .
the results will provide insights on the potential of automatic program repair.
for example the results will reveal how many bugs can be fixed by simple changes.
as pointed out by monperrus existing approaches are effective in fixing this type of bugs.
as another example the results will reveal the essential operators to fix bugs.
if we compare these operators with an existing approach we may estimate the potential of the approach for fixing bugs.
benefit .
the results will provide insights on how to improve existing approaches.
for example the results will reveal the distribution of bug fixes and the required knowledge to fix each type of bugs.
future research may leverage such knowledge to fix more bugs.
as another example the results will reveal the nature of bug fixes and future work may be able to tune existing approaches to achieve their best performance.
benefit .
the results will provide insights on new research directions of fixing bugs.
for example the results will reveal how many bug fixes require modifications on only non source files.
follow up work may explore how to locate bugs in nonsource files and how to fix them with advanced techniques.
ieee acm 37th ieee international conference on software engineering .
european union ieee acm 37th ieee international conference on software engineering .
european union ieee acm 37th ieee international conference on software engineering .
european union icse florence italy despite the preceding benefits it is difficult to conduct such an empirical study due to the following challenges challenge .
it is difficult to collect the bug fixes for the empirical study.
first it needs a large number of bug fixes to ensure the representativeness of the results but many projects do not provide adequate data for analysis.
for example many projects on sourceforge1do not have a long active period so they provide limited bug fixes for analysis.
second kim et al.
point out that it needs high quality bug fixes to reduce superficial conclusions but many bug fixes are polluted.
for example although linux has a long active period its bug fixes are intertwined with other types of commits e.g.new features .
although tian et al.
propose an approach to identifying bug fixes for linux its precision is relatively low due to the difficulty in accurately identifying bug fixes.
challenge .
it is challenging to implement the support tool.
it is infeasible to analyze a large amount of bug fixes manually so it is desirable to implement a support tool for analysis.
to save space a bug fix typically consists of only buggy files and modified files instead of the whole project.
as a result the tool should be able to compare and analyze partial code.
to address the two preceding challenges we collect highquality bug fixes and implement a tool called b ugstat that automatically extracts compares and classifies bug fixes.
with the support of the tool we conduct the first empirical study to investigate the aforementioned research questions.
this paper identifies the following key insights fault localization.
our results show that it is reasonable to assume that it needs to fix only several files to fix a bug findings and .
current fault localization approaches can deal with of source files at the most finding .
to deal with more source files researchers should consider multiple faulty lines findings and and the data dependence among faulty lines finding .
faulty code fix.
our results show that it is reasonable for automatic program repair to focus on modified source files findings and .
the existing approaches can potentially fix of source files finding but their effectiveness in practice may be further reduced since it is difficult to decide the faulty lines of a bug and the interference among multiple bugs is serious finding .
to fix more bugs researchers can focus on mutation operators of several most common modified code elements finding api knowledge finding the frequency of repair actions finding multiple faulty lines finding their data dependence finding and multi language programming finding .
the search space.
combining the results of martinez and monperrus with our results in figure we find that automatic program repair can potentially fix only half of the buggy files due to the huge space of searching correct repair shapes finding .
the potential is further reduced since even after such a shape is found the effort to find its concrete edits is nontrivial finding .
bugs.
our results show that about of bugs reside in non source files finding and the bug prediction models should consider non source files findings and .
most of these files are configuration files and natural language documents finding .
even in source files there are many bug fixes on non code elements such as comments finding .
ii.
m ethodology this section describes the dataset used in our empirical study and our research questions.
to answer these research questions we should analyze thousands of bug fixes.
to reduce the effort of manual inspection we have developed the b ugstattool to identify and classify bug fixes.
a. dataset table i lists the subject projects used in our study.
aries2 is a set of java components that enable an enterprise osgi application programming model.
cassandra3is a distributed database management system that handles large amounts of data across commodity servers.
derby4is a relational database.
lucene5is an information retrieval library and solr6is an enterprise search platform that is built on lucene.
as lucene and solr share the same source code repository it is difficult to determine whether a commit belongs to lucene or solr.
we put the results of the two projects into a single row.
mahout7is a machine learning library.
all the projects are from the apache software foundation8 and most apache projects carefully maintain the links between bug reports and bug fixes.
wu et al.
reported that even simple heuristics achieved almost the same precision and recall with their proposed sophisticated technique when they identified bug fixes for the apache projects.
we select the apache projects so that we can focus on the study rather than the techniques to identify bug fixes.
column loc lists lines of code.
to ensure the reliability of our results we selected both median and large projects.
the total lines of code add up to more than one million.
we collected the dataset in february .
cassandra changed its source code repository from svn9to git10in december .
as b ugstatretrieves commits from only svn repositories for cassandra it retrieved the data before the repository was changed.
all the projects in table i have source code repositories.
for each project in table i b ugstatretrieves all the commits from its source code repository.
each commit has a message.
we inspected the messages and found two types of bugs bugs reported through issue trackers which we call reported bugs and those not reported to issue trackers which we icse florence italytable i dataset name locbug commit f i t n k aries .
.
cassandra .
.
derby .
.
lucene solr .
.
mahout .
.
total .
.
f fixed bugs in bug reports.
i bugs whose fixes are identified by issue number t total commits n bug fix commits that are identified by issue number k bug fix commits that are identified by keywords.
callon demand bugs.
to identify fixes of the two types we define the following two criteria .
issue number.
all the projects in table i have their issue trackers to track various issues e.g.
bugs improvements new features tasks and sub tasks .
each reported issue has an associated issue number.
if a change of an issue is committed programmers often write its issue number to the message of the commit.
for example in cassandra a commit s message says implement multiple index expressions.
patch by jbellis reviewed by nate mccall for cassandra .
the benefit of the practice is that it is easy to track the issue.
in the issue tracker the page of the issue11lists useful information e.g.
its description the discussions among programmers and the relations to other issues .
in the apache projects when writing issue number to messages programmers typically use the name number pattern where name denotes the name of a project and number denotes the issue number.
b ugstat uses the pattern to extract issue number and checks the issue tracker to determine whether a commit is a bug fix.
in the above example as cassandra is a sub task bugstatdetermines that the commit is not a bug fix.
in table i column bug lists the results with the issue number criterion.
initially the resolution of a reported issue is unresolved and is changed to fixed after programmers fix the issue.
programmers may not fix some issues since they resolve these reports as invalid andduplicate.
programmers may have different opinions on some reported issues and change them to other categories.
for example a reported bug can be changed as a new feature request.
for the bug column subcolumn f lists the number of bug reports that are resolved as fixed subcolumn i lists the number of bug reports whose bug fixes are identified by issue number and subcolumn is calculated asd f. the result shows that the issue number criterion identifies fixes for of the reported bugs so our study reflects the nature of the majority.
b ugstat is similar to existing approaches e.g.
.
the difference is that bugstatchecks the issue tracker to determine whether an issue number indicates a bug while other approaches assume that every issue number indicates a bug.
.
keyword.
issue trackers do not store all the bug fixes.
in some cases programmers may bypass issue trackers especially when they believe that a change is trivial.
when they commit a change programmers may write a message to describe the fix.
for example in aries the message of a com11 says fix broken service registration listener .
b ugstat determines a commit as a bug fix if its message contains words such as bug or fix .
the preceding commit was identified as a bug fix since its message contains the keyword fix .
the heuristic is simple and a number of previous studies e.g.
used the same technique to extract bug fixes.
in table i column commit lists the results using the two criteria.
for this column subcolumn t lists the number of retrieved commits subcolumn n lists the number of bug fixes that are identified by issue number subcolumn k lists the number of bug fixes that are identified by keywords and subcolumn is calculated asn kt.
our result shows that about of commits are bug fixes.
in addition as shown in subcolumns i and n a reported bug has two commits on average and an on demand bug has one commit by definition.
if it is necessary we treat the two types of bugs differently when we investigate our research questions.
b. research questions rq1.
to what extent are bugs localized section iii a ?
as the first step automatic program repair leverages fault localization techniques to locate the faulty line.
wong and debroy show that most fault localization approaches assume that each buggy source file has exactly one line of faulty code.
however if a bug has multiple lines of faulty code the impacts of these lines may depend on each other.
in this study we analyze the fault distribution of real bugs.
the results provide insights on locating faults.
rq2.
how complicated is it to fix bugs section iii b ?
after a faulty line is located automatic program repair mutates the faulty line to generate candidates and uses genetic algorithm e.g.
or random search e.g.
to select candidates until a candidate passes all the test cases.
these approaches are effective in fixing a faulty line but may be ineffective in fixing multiple faulty lines especially when such lines are relevant.
in this study we analyze data dependence among faulty lines to investigate the complexity of fixing bugs the results provide insights on fixing bugs.
rq3.
what operators are essential section iii c ?
when fixing bugs automatic program repair uses predefined operators to mutate faulty code.
the operators are quite important since they decide how many and which bugs can be fixed.
current automatic program repair uses quite limited operators.
for example although kim et al.
achieved better results than previous approaches their approach relies only ten templates to mutate code.
although it is widely icse florence italy0 .
.
.
.
number of modified source filespercent of corresponding bugs aries cassandra derby lucene solr mahout totalreported bugs .
.
.
.
.
.
number of modified source filespercent of corresponding bugs aries cassandra derby lucene solr mahout total on demand bugs fig.
.
the fault distribution at the bug level.
known that existing approaches use incomplete operators it is challenging to make improvements.
in this study we analyze the operations to fix real bugs.
the results provide insights on designing more comprehensive operators.
rq4.
what is the importance of apis section iii d ?
api knowledge is useful in various programming tasks e.g.
coding and migrating code .
our previous work shows that careless programmers may introduce api related bugs.
however current automatic program repair does not leverage api knowledge and thus is ineffective in fixing apirelated bugs.
in this study we analyze how many bug fixes are related to apis.
the results provide insights on the importance of api knowledge for fixing bugs.
rq5.
what kinds of files are modified section iii e ?
we notice that many bugs are not related to source files and such bugs could not be fixed by current automatic program repair techniques.
it is desirable to understand where such bugs reside so we could investigate their nature and explore corresponding repair approaches.
in this study we analyze the types and the distribution of modified files when programmers fix real bugs.
the results provide insights on fixing bugs that do not reside in source files.
rq6.
how many files are added or deleted section iii f ?
automatic program repair only modifies source files but programmers may also add or delete files to fix real bugs.
thus existing approach may be insufficient in fixing certain bugs.
in this study we analyze the distribution of added and deleted files when programmers fix real bugs.
the results provide insights on fixing the corresponding bugs.
we implement b ugstatto reduce the manual effort and it uses changedistiller to compare source files and ppa to parse partial code.
iii.
e mpirical results a. rq1 fault distribution we calculate the number of modified files for each bug fix and figure shows the distribution.
its horizontal axes show the number of modified source file and its vertical axes show the percentage of the corresponding bugs.
the results lead to the following findings finding .
in total programmers did not modify any source files to fix about of reported bugs and about of on demand bugs.
yin et al.
show that both open source and commercial projects contain many errors in configuration files and xiong et al.
propose an approach to fix such errors.
in this study we find bug fixes in configuration files.for example a bug report of solr12says that the released code did not compile since the compiler s configuration file did not set the paths correctly.
the modified lines are as follows tarfileset dir .. lucene prefix lucene excludes build ... our previous work detects errors in documents.
in this study we find bug fixes in documents.
for example a bug report of lucene13says that the online user guide did not display correctly and the modified line is as follows !doctype... ... xhtml1 dtd xhtml1 transitional.dtd !doctype... ... html4 loose.dtd researchers have proposed models to predict buggy source files for a bug report.
as source files are quite different from non source files it needs nontrivial extension to predict buggy non source files.
in addition as non source files are typically not executable it needs nontrivial extension for fault localization to locate faulty lines for non source files.
section iii e shows that some modified files are in programming languages other than java.
as b ugstatparses java code it considers only java code as source files.
finding .
in total programmers modified one or more source files to fix about of reported bugs and more than of on demand bugs.
the number of buggy files for a bug is an important parameter for fault prediction models e.g.
.
our results show that the percentage of bugs decreases rapidly with the increasing number of modified source files and the percentage of on demand bugs decreases even faster.
it is reasonable to set the value of the parameter to be four or less since more than of bugs have fewer than four modified source files.
we further analyzed the modified locations of each modified source file.
the underlying tool changedistiller produces a set of repair actions from two compared source files.
a repair action is a pair a e where ais an action such as add delete update and move and eis a code element.
for actions bugstat considers add as additions delete as deletions andupdate andmove as modifications.
to understand bug fixes we often need statement level changes.
for example it requires different knowledge to fix ifstatements and return statements although modified internal code elements are the same e.g.variables .
for each repair action inside a statement bugstatreplaces its code element with the statement and icse florence italy1 .
.
.
.
.
.
number of repair actions percents of corresponding modified files aries cassandra derby lucene solr mahout totalfig.
.
the fault distribution at the file level.
it ignores repair actions on the same statement.
a code element may not have a parent statement e.g.
modifier andjavadoc .
b ugstat does not change repairs on these code elements.
in addition when programmers fix a bug they often modify the test code to reproduce the bug.
as repair actions on test code are more like implementing new features b ugstatignores these repair actions.
for each of the remaining modified files we calculate its number of repair actions and figure shows the results.
its horizontal axis shows the number of repair actions and its vertical axis shows the percentage of the corresponding modified files.
we have the following finding finding .
in total programmers made a repair action to fix less than of source files.
wong and debroy claim that most fault localization approaches assume that each buggy file has exactly a faulty line.
as these source files fit the assumption existing approaches have the potential to locate their faulty lines.
however their effectiveness in practice may be limited for two reasons.
first a faulty line may not appear in traces so fault localization approaches cannot locate it.
for example code comments are not executable and will not appear in traces although they may contain errors.
as another example fixing bugs sometimes requires changing modifiers.
in particular a bug report of solr14says that the visibility of a method should be changed.
the original code is as follows public abstract query parse ... the fixed code is as follows protected abstract query parse ... as many tools instrument only method bodies line will not appear in their traces.
second an added or deleted code element may have multiple lines see section iii c for details .
for example adding a method is considered a single repair action.
current automatic program repair cannot add a method effectively since a method may contain many lines.
finding .
in total programmers made at least two repair actions to fix more than of source files.
digiuseppe and jones conducted an empirical study to explore the influence of multiple faults on fault localization approaches.
their results show that fault localization approaches are effective in locating at least one faulty line but the ranks of the remaining faulty lines are low.
they suggest that programmers may use fault localization to locate and fix faulty lines one bye one.
the suggestion works for humans but may not apply to automatic program repair for two reasons.
first automatic program repair needs to rerun test cases to aries cassandra derby lucene solr mahout total .
.
.
.
.
.
.
.
.
c2 c3 c4fig.
.
the category for fault complexity.
guide the bug fix process.
digiuseppe and jones show that the interference among multiple faults is serious and such interference may negatively impact the search algorithms.
second it may be insufficient to mutate a single line to fix bugs.
for example a bug report of solr15says that an exception was thrown due to the misuse of java reflection.
in particular three methods use java reflection to call the methods ofclob and one method has the faulty lines as the following method m clob.getclass .
getdeclaredmethod getcharacterstream if modifier.ispublic m.getmodifiers f ... return reader m.invoke clob g if the getcharacterstream method is defined in the superclass of clob line will throw an exception since clob does not define the method.
the fixed code is as follows return clob.getcharacterstream it is reasonable for programmers to fix the bug from a faulty line but it can be difficult for automatic program repair to fix the bug since fault localization approaches typically do not report the line range of a bug.
qi et al.
use different fault localization approaches to locate the faulty lines for automatic program repair.
their results are consistent with our results since they find that the best technique for humans is not the best technique for automatic program repair.
still more research is needed to fully understand such influence since their study does not analyze low level details e.g.
the inference of multiple faults .
research exists e.g.
to recover the links between test cases and multiple bugs but additional research is needed to locate multiple faults and fault ranges especially for automatic program repair.
automatic program repair uses machine learning algorithms such as genetic algorithm and random search to guide the bug fix process.
martinez and monperrus mine two repair models ct and ctet from bug fixes.
the two mined repair models are the probability distributions of repair actions e.g.
inserting a statement at different granularity.
their results show that the space of searching repair shapes explodes when the length of repair actions is more than four or eight for the two models respectively.
here a repair shape is a set of repair actions.
the two repair models are built on changedistiller and the granularity of changedistiller is between ct and ctet.
if we adjust the repair models to the granularity of changedistiller the maximum number may be between four and eight.
figure shows that about half of the buggy files have more repair actions.
in addition even after a icse florence italyjavadoc expressionstatement returnstatement modifier methoddeclaration breakstatement throwstatement variabledeclarationstatement ifstatement fielddeclaration switchcase singlevariabledeclaration block modification addition deletionaries expressionstatement methoddeclaration returnstatement throwstatement variabledeclarationstatement modifier javadoc breakstatement ifstatement singlevariabledeclaration switchcase fielddeclaration continuestatement modificatin addition deletion cassandra expressionstatement javadoc methoddeclaration returnstatement fielddeclaration breakstatement ifstatement modifier continuestatement switchcase throwstatement variabledeclarationstatement modification addition deletion derby javadoc expressionstatement returnstatement methoddeclaration modifier breakstatemen switchcase throwstatement variabledeclarationstatement assertstatement block fielddeclaration ifstatement singlevariabledeclaration modification addition deletion lucene solr javadoc expressionstatement returnstatement variabledeclarationstatement methoddeclaration modifier throwstatement fielddeclaration ifstatement singlevariabledeclaration modification addition deletion mahout javadoc expressionstatement returnstatement methoddeclaration modifier breakstatement switchcase throwstatement fielddeclaration variabledeclarationstatement ifstatement block singlevariabledeclaration continuestatement modificatoin addition deletion total fig.
.
the distribution of repair actions.
correct repair shape is found it is still nontrivial to synthesize the concrete fix.
as a result we estimate that current automatic program repair cannot fix more than half of the buggy files due the large search space to synthesize fixes.
b. rq2 fault complexity based on the fault complexity we classify modified source files into four categories a single repair action c1 nondata dependent repair actions c2 data dependent repair actions c3 and mixture repair actions c4 .
b ugstatputs a repair action into a set of data dependent repair actions if its code element contains a variable and the variable has data dependence on variables in that set.
as shown in figure programmers made a single repair action to fix about of source files.
these source files fall into the c1category.
current automatic program repair is effective in fixing bugs in this category.
we calculated the number for the other three categories and figure shows the results.
its vertical axis shows the subject projects and its horizontal axis shows the percentages of the three categories.
the results lead to the following findings finding .
as shown in figures and programmers made multiple non data dependent repair actions to fix about of source files the c2category .
as these repair actions are not data dependent it may be feasible to apply the repair actions one by one when fixing bugs.
for example a bug report oflucene16says that an exception was thrown if a resource was closed and a submitted patch is as follows swapsearcher newsearcher boolean success false try f swapsearcher newsearcher success true gfinally f ... g public void close throws ioexception f swapsearcher null public synchronized void close throws ioexception f if currentsearcher !
null f ... swapsearcher null g in the first diff hunk of the patch programmers placed a statement inside a try statement.
in the second diff hunk of the patch programmers put a statement into an ifstatement.
as the two faulty lines have no data dependency it may be feasible for existing approaches to fix them one by one.
finding .
in total as shown in figures and programmers made data dependent repair actions to fix more than of source files the c3andc4categories .
for example a bug report of mahout17says that a function got broken over time and the faulty lines were as follows if r f if index o.index f return icse florence italy133 gelse if index o.index f return g return gelse f return r g when ris zero the preceding code returns a wrong value.
to calculate the correct value programmers should understand the relation among r o.index and index.
the modified lines are as follows if r !
f return r gelse f return o.index index g it should be more difficult for programmers to fix source files in this category than the c1andc2categories since they have to consider the nodes that depend on each other.
however the added complexity may be an opportunity for automatic approaches.
for example a fault localization approach may use the data dependencies to locate relevant faulty lines of a located faulty line and automatic program repair could use the data dependencies to prune its search space.
c. rq3 mutation operator as the underlying tool changedistiller is built on the eclipse s java model18 the code elements of extracted repair actions follow the apis of eclipse19.
we find that the underlying tool has special strategies to extract repair actions onblock andmethoddeclaration .
for example it counts adding or deleting a method as an addition or a deletion onmethoddeclaration but it counts only modifying a method name as a modification on methoddeclaration .
it does not count modifications inside a method e.g.
the modifier the parameters and the statements in the method body as a modification on methoddeclaration but counts them at finer levels.
here as a method may have complicated structures current program repair may not add a method effectively although it is counted as a repair action.
as discussed in section iii b non data dependent repair actions follow quite different patterns from data dependent repair actions and current automatic program repair is effective to apply only non data dependent repair actions.
to eliminate the interference between the two types of repair actions and to provide valuable findings for the state of the art this study focuses only on non data dependent repair actions.
by definition javadoc modifier breakstatement and continuestatement have only non data dependent repair actions.
all the other code elements have both data dependent and non data dependent repair actions.
the nature of code elements affects their ranks.
for example pan et al.
show that a large portion of bug fix patterns are related to ifstatements.
in our study we find that most repair actions onifstatements are data dependent.
as a result its rank is low.
the results show that automatic program repair should overview summary.html .
.
.
.
.
number of api repair actionspercent of corresponding modified source files aries cassandra derby lucene solr mahout totalfig.
.
the distribution of api repair actions.
leverage data flow analysis to effectively apply repair actions on this code element.
we calculated the number of repair actions on each code element and figure shows the results.
its vertical axis shows the names of code elements.
to save space we do not present code elements whose repair actions are less than .
its horizontal axis shows the number of repair actions with the categories such as additions deletions and modifications.
the results lead to the following findings finding .
in total repair actions on javadoc rank the first.
in the eclipse s java model javadoc denotes the comments between code.
programmers modified these code comments since they contain errors or become inconsistent with the implementation.
there exists research to address this problem.
for example our previous work detects documentation errors e.g.outdated code names in comments .
as another example tan et al.
and zhong et al.
infer formal rules from code comments and check the rules against the implementation to detect inconsistencies.
although the problem has been explored there may still be space for improvement since there are many modifications on javadoc.
finding .
the repair actions on a code element typically increase with its complexity.
for example in eclipse s java model expression is complicated since it has a rich set of subclasses20.methodinvocation is one of its subclasses and it may invoke complicated api methods.
by definition each expressionstatement has at least an expression node and each returnstatement can have an expression node.
as the inside nodes are complicated the repair actions on the two types of statements rank the second and the third in total.
in contrast breakstatement andcontinuestatement are relatively simple so the repair actions on the two types of statements are much fewer.
finding .
the actions on code elements follow two patterns.
first the modifications on a code element increase with its complexity.
for example expressionstatement is more complicated than breakstatement as discussed before.
thus as shown in figure the former statement has more modifications than the latter statement.
in fact all the modifications of the latter statement are to move from one line to another since it has no internal structures.
second additions on a code element are more than deletions.
when bugs are introduced a careless programmer may forget some statements and may also add unwanted statements.
our results org eclipse jdt core dom expression.html icse florence italytable ii the distribution of modified files aries cassandra derby lucene solr mahout total java java java java java java xml txt out txt xml txt mdtext py properties xml changelog xml xml sql html out xml properties sql show that the former case is more common than the latter case.
automatic program repair could use the two patterns to prune its search space when they mutate the faulty code.
d. rq4 api knowledge the underlying tool ppa parses and resolves full names of code elements.
b ugstat considers a repair action as an api repair action if the full name of its code element indicates that the code element is declared by third party api libraries.
if ppa fails to resolve the full name for a code element b ugstatconservatively classifies the corresponding repair action into the non api category.
figure shows the distribution.
its horizontal axis shows the number of api repair actions and its vertical axis shows the percentage of corresponding modified source files.
based on the results we have the following findings finding .
in total programmers did not make any api repair actions to fix half of the source files.
the results explain why current automatic program repair is able to fix many bugs without api knowledge.
by definition some code elements e.g.
javadoc modifier breakstatement and continuestatment do not contain api elements so repair actions on these code elements are not related to apis.
the repair actions on some other code elements have limited relation to apis.
for example in figure swithcase requires constants.
if a constant in api libraries passes the type check it may be used to fix bugs in swithcase.
finding .
in total programmers made at least one api repair action to fix the other half of source files.
we find that complicated code elements tend to have more api repair actions.
for example as discussed before expressionstatement is complicated and we find many api repair actions on this code element.
in particular a bug report of cassandra21says that it fails to read saved files and the faulty line is as follows in new objectinputstream ... line is an expressionstatement .
this statement calls objectinputstream to read files but the files are saved with incompatible apis.
to fix the bug programmers choose another api and the modified line was as follows in new datainputstream ... robillard et al.
show that various approaches have been proposed to mine specifications for api libraries.
as mined specifications describe legal api usage they may be useful to fix api related bugs.
an interesting point to note is that mined specifications describe the usage of only several api elements according to our previous work e.g.
.
in figure a file has fewer than five api repair actions on average.
the results indicate that an api usage typically involves only several api elements.
e. rq5 file type for modifications we calculated the file types of all the modified files and table ii shows the distribution.
in table ii we use the suffices of file names to denote file types.
to save space we do not present file types that are less than .
based on the results we have the following findings.
finding .
the most common modified files are java source files and the other files are much fewer.
the result is not surprising since all the studied projects are in java.
however we have noticed something interesting when we compare the results with results in figure .
figure shows that programmers did not modify java source files to fix at least of the bugs.
as a result on average programmers modified fewer files when a bug did not involve java source files than when it did.
the result indicates that the dependency among java source files may be higher than that among other files e.g.configuration files .
finding .
the two most common modified non source files are configuration files and natural language documents.
the names of the most found configuration files end with xml or properties and we find three typical types of such files.
the first type defines the parameters of build tools e.g.
ant22 and one such example is presented in finding .
the second type defines runtime parameters.
for example a bug report of cassandra23says that committing log can cause write pauses.
to fix the bug programmers modified code and enlarged the following old parameter commitlogsyncperiodinms commitlogsyncperiodinms the modified line was as follows commitlogsyncperiodinms commitlogsyncperiodinms the third type defines parameters of third party tools.
for example many programmers use findbugs24to detect bugs and the tool has a configuration file to enable specific checks.
we find that the programmers of mahout added several lines to the findbugs configuration file to enable a check match bug pattern se no suitable constructor match icse florence italy0 .
.
.
.
number of added source files percent of corresponding bugs aries cassandra derby lucene solr mahout totaladditions for reported bugs .
.
.
.
number of deleted source filespercent of corresponding bugs aries cassandra derby lucene solr mahout total deletions for reported bugs .
.
.
.
number of added source filespercent of corresponding bugs aries cassandra derby lucene solr mahout total additions for on demand bugs .
.
.
.
number of deleted source filespercent of corresponding bugs aries cassandra derby lucene solr mahout total deletions for on demand bugs fig.
.
additions and deletions.
the names of most found natural language documents end with html or txt .
these documents are manuals tutorials and change logs.
the results highlight the importance of fixing bugs in configuration files and natural language documents.
finding .
some modified source files are in programming languages other than java for two reasons.
first a project may be implemented in multiple programming languages.
for example cassandra is a database and its programmers implement a python driver.
a bug report25says that the driver did not parse queries correctly.
to fix the bug programmers modified one faulty line of the cursor.py file cfamily re re.compile ... re.i re.m the modified line was as follows cfamily re re.compile ... re.ignorecase re.multiline re.dotall second a project may implement an interface for a programming language.
for example derby is a database that supports queries in sql and its programmers use sql queries as test cases.
a bug report of derby26says that when an error code was returned when a query casted date totimestamp.
to reproduce the error a programmer added a line to the cast.sql file select cast t as timestamp from tab1 on this line tis a column of table tab1 and the type of t istime and the cas.out file recorded the output ij select cast t as timestamp from tab1 error cannot convert types time to timestamp .
the two situations highlight the importance of fixing bugs in multiple programming languages.
as automatic program repair has been evaluated on only a limited number of programming languages such as c and java it may require significant improvement to fix bugs in other programming languages.
for example it is challenging to instrument sql queries to collect their executed traces.
without such traces it is infeasible to use fault localization to locate faulty lines in such queries.
.
rq6 additions and deletions we calculated the number of added and deleted files for each bug fix and figure shows the distribution.
its horizontal axes show the number of added or deleted source files and its vertical axes show the corresponding percentage.
based on the results we have the following finding finding .
in total programmers did not add any files to fix more than of the bugs and they did not delete any files to fix more than of the bugs.
hattori and lanza analyze the nature of commits and they find that the size of a commit is associated with the type of the commit.
in particular tiny commits are more related to bug fixes and large commits are more related to new features.
our result reflects another nature of commits namely at the file level modifications may be more related to bug fixes.
as most bug fixes require only modifying files it is reasonable for automatic program repair to focus on mutating files to fix bugs.
g. threats to validity the threat to internal validity includes the defects in the underlying tools that we use.
changedistiller may produce infeasible edit scripts and ppa may wrongly resolve code elements.
to reduce this threat we reported our found defects and if they are not fixed we tried to fix them by ourselves.
the threat could be further reduced by developing more advanced tools.
the threat to external validity includes our selected subjects.
although we analyzed thousands of bug fixes in total the selected projects may still be limited and are all for java.
it is likely that most our findings still hold in other programming languages but the specific numbers may be different.
for example although the repair actions on a code element increase with the complexity of its usage finding in other programming languages the ranks of code elements will be different since other programming languages may define quite different code elements.
to reduce this validity our study should be replicated in future work by using subjects in other programming languages.
icse florence italyiv.
d iscussions and future work bug definitions.
practitioners and researchers can have different definitions of bugs.
herzig et al.
claimed that at least of reported bugs are not bugs but features.
even researchers may have different definitions of bugs.
for example in our previous work we reported our detected documentation errors as bugs and programmers accepted and fixed them as bugs.
however by the definition of herzig et al.
our detected errors are documentation requests but not bugs.
the different definitions lead to quite different results.
in our study we follow the pragmatic definition of practitioners i.e.
those issues that are reported and fixed as bugs.
the benefit is that the results reflect the reality of practice and practitioners do not need to read all the definitions to understand our results.
more factors of automatic program repair.
we have focused on the major factors of current automatic program repair and due to space limit we certainly miss some factors that are also relevant.
for example the domain knowledge of compilers tool chains programming models multi programming and concurrent and the low level knowledge of operating systems and hardware are essential to fix some bugs.
murphy hill et al.
present various factors when programmers manually fix bugs.
in addition luo et al.
show that bugs can not be easily reproducible or verifiable which introduces extra barriers to automatic program repair.
in future work we plan to conduct studies to investigate the importance of these factors.
manual fixes vs. automatic fixes.
neither manual fixes nor automatic fixes are perfect.
although yin et al.
show that manual fixes can be incorrect our results are still reliable since most fixes are correct.
at the same time a program fix may pass test cases but does not fix the real problem.
bird et al.
show that even manual fixes should be carefully examined so it is likely that the correctness of program fixes also needs to be verified.
although we agree with monperrus that understandability of patches is inessential in certain situations in most cases generated patches should be readable to humans or other programs for verification.
in addition although it is a practical way to mimic humans and it is a good way to understand the challenges by analyzing manual fixes we agree that there could be alternative ways to solve the problem.
for example computers can already beat the best human players in playing chess and the algorithm is quite different from humans since computers have much larger and more reliable memories and much stronger computational capabilities than most humans .
with advanced techniques it is conceivable that a computer algorithm may produce better patches than we humans do.
v. r elated work automatic program repair.
weimer et al.
proposed genpro a seminal work on automatic program repair.
le goues et al.
extended genpro and proposed new mutation and crossover operators.
kim et al.
manually inspected thousands of bug fixes and summarized ten templates as new mutation operators.
wei et al.
used mined invariants to fix bugs.
jin et al.
proposed new mutation operatorsand selectors that are designed to fix concurrent bugs.
all the preceding approaches define a limited number of simple repair shapes and rely on genetic algorithm to generate complicated repair shapes to fix complicated bugs.
qi et al.
show that random search is more effective than genetic algorithm to guide the bug fix process.
martinez and monperrus mine repair models from manual fixes and the mined repair models improve random search.
our study provides findings and insights to better understand and improve these approaches.
fault localization.
fault localization has been an extensive studied topic.
wong and debroy provided a comprehensive survey on this line of research.
most of the approaches e.g.
assume that each program has exactly one faulty location and a few recent approaches e.g.
start to explore the links between traces and multiple faulty locations.
our study shows that future research should further improve existing approaches to locate bugs in multiple locations.
empirical study on bug fixes.
various empirical studies exist to understand the nature of bug fixes.
yin et al.
show that bug fixes could introduce new bugs.
nguyen et al.
show that repetitiveness is common in small size bug fixes.
eyolfson et al.
show that the bugginess of a commit is correlated with the time to make the commit.
bird et al.
show that many projects did not carefully maintained the links between bug reports and bug fixes.
our empirical study has analyzed bug fixes to gain insights on automatic program repair providing a different research angle than previous studies.
thung et al.
manually examined bug fixes their results show that faults are not localized.
our results are largely consistent with their findings.
however our results are built on much larger samples since we analyzed bug fixes automatically.
in addition different from theirs our study is not limited to fault localization.
vi.
c onclusion automatic program repair shows promising results but its effectiveness on real world bugs has also been questioned and criticized.
directly evaluating tools from these efforts on real bugs may produce many trivial and negative results since they are still immature research prototypes.
instead we have conducted a large scale empirical study on thousands of realworld bug fixes from five popular projects.
we have compared how programmers fix bugs and how bug fix approaches are designed and distilled findings and four insights that we believe are useful to guide future research in this direction.