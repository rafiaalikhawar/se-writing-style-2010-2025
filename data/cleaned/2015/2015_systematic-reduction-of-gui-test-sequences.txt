systematic reduction of gui test sequences lin cheng zijiang yang western michigan university kalamazoo mi usachao wang university of southern california los angeles ca usa abstract graphic user interface gui is an integral part of many software applications.
however gui testing remains a challenging task.
the main problem is to generate a set ofhigh quality test cases i.e.
sequences of user events to cover theoften large input space.
since manually crafting event sequencesis labor intensive and automated testing tools often have poorperformance we propose a new gui testing framework to efficiently generate progressively longer event sequences while avoiding redundant sequences.
our technique for identifying theredundancy among these sequences relies on statically checking a set of simple and syntactic level conditions whose reduction power matches and sometimes exceeds that of classic techniquesbased on partial order reduction.
we have evaluated our method on java swing applications.
our experimental results show the new technique while being sound and systematic can achievemore than 10x reduction in the number of test sequences compared to the state of the art gui testing tools.
i. i ntroduction graphic user interface gui is an integral part of many software applications that monitor user actions such as keyboard and mouse events and respond by invoking listener functions.to test a gui application one must create tests to cover itsinput space where each test is a finite sequence of events.due to combinatorial blowup the number of sequences canbe astronomically large e.g.
up to 10for all length sequences of 10events if these events are enabled all the time.
thus the main problem is to generate a small subset of theseevent sequences while achieving the same testing effect as thecomplete set.
since manually crafting these sequences is labor intensive techniques have been developed to generate themautomatically .
unfortunately these existing techniques are neither systematic nor efficient i.e.
they often miss important event sequences and producemany redundant sequences.
to avoid these problems we propose a new test generation tool to construct progressively longer event sequences.
our tool has the advantage that during the sequence generation process it eliminates an event sequence only if the sequenceis guaranteed to be redundant i.e.
subsumed by some othersequences.
this is accomplished by a new type of reductiontechnique that differs from classic partial order reduction por methods .
our tool is also efficient in that it relies on a set of easily checkable condi tions to identify redundant sequences.
these conditions areexpressed in terms of the sequence of events as opposed tothe concrete program states.
thus they can be checked by a purely static analysis of the event flow of the gui application without executing the actual application.
fig.
shows the overall flow of our method.
the input consists of java byte code of the gui application and aguitargui application soot event flow graph efg static analysis result max.
length cobertura coverage report test casesredundant state reduction redundant sequence eliminationevent sequence generation fig.
.
systematic generation and reduction of gui tests.
bound on the sequence length.
the output is a set of eventsequences.
internally our method goes through several steps.first it leverages guit ar to reverse engineer an event flow graph efg of the application.
the efg shows the set of events enabled at any step of the execution as wellas the enabled events afterward.
then our method leverages soot to perform static analysis of the java byte code to compute dependencies over the events.
next it invokes ourcore algorithm which takes the efg the dependencies and abound as input and constructs the test sequences.
finally thesequences are executed on the actual gui application usingcobertura which measures the coverage.
compared to state of the art gui testing tools our method has two advantages.
first it is systematic meaning that useful test sequences are not excluded in anyad hoc fashion within the maximum sequence length our method eliminates a sequence only if it is provably redundant when in doubt it retains the sequence.
second our method isefficient in that it generates significantly fewer test sequencesthan prior techniques.
for instance when applied to theexample in fig.
prior techniques based on partial orderreduction can only remove redundant sequences whereasour method removes redundant sequences.
although arlt etal.
proposed a reduction technique that goes beyond por their tool still generates significantly more sequences for theexample in fig.
when the maximum length is set to 7and it generates and sequences respectively whereas our method generates only sequences.
we have evaluated our method on java swing applications consisting of lines of code in total.
theexperimental results show our new reduction technique is moreeffective it outperforms partial order reduction consistently .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research849 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
class modifyimagewindow extends jframe boolean convert false int angle void oncheckbox int cbvalue checkbox.getvalue convert cbvalue ?
true false void onslider int slidervalue slider.getvalue angle slidervalue print convert angle void onsave int anvalue angle if anvalue usersettings.rotationangle anvalue else assert bug crash if reached void onok if convert image.converttograyscale image null if angle image.rotate angle bug if image null else image.draw bug if image null fig.
.
the class modifyimagewindow defines event handlers oncheckbox onslider onsave and onok.
and significantly.
we also experimentally compared with stateof the art gui testing tools including gazoo and guit ar .
overall our tool achieves more than 10x reduction in the number of test sequences and significantlyreduces the corresponding test execution time.
to summarize this paper makes the following contributions we propose an automated gui testing framework forgenerating event sequences efficiently.
we develop a reduction technique to more effectivelyeliminate redundant sequences than prior techniques.
we use realistic applications to demonstrate the advan tages of our method over state of the art testing tools.
in the remaining sections we use motivating examples to illustrate the main ideas behind our method before formallypresenting the algorithm and our experimental results.
ii.
m otiv ation consider the java code in fig.
which controls a window that allows the user to modify an image by clicking the checkbox choosing an angle from the slider control and clicking theokbutton.
clicking the okbutton closes the window and thus disables all event handlers.
optionally the user may click thesave button to store the angle.
fig.
shows the event flow graph efg where nodes are events and edges indicate theset of events enabled in each step.
all four events are enabled initially.
however since clicking okcloses the window the node labeled okhas no outgoing edges.
to test all possible behaviors we must visit all reachable states and from each state invoke all enabled events at least once.
naively this can be accomplished by enumerating all event sequences in the efg up to a predefined length.cb start sl start okstart sa start fig.
.
event flow graph where cb sl sa andokdenote oncheckbox onslider onsave and onok respectively.
a. naive solution for the example in fig.
all possible states will be reached after invoking at most two events and then from each state invoking all enabled events will cover the state event combinations.
when the maximum sequence length is set to the number of event sequences will be as shown in fig.
.
the number is less than because clicking the okbutton ends the execution.
however some of these sequences are redundant.
for example sa sa ok covers the same behavior as sa ok they visit the same states and from these states they executethe same events.
this is because executing sadoes not change the program state.
here states are value combinations of thevariable convert and the predicate angle .
although angle is an integer variable the only thing matters in this application is whether angle .
thus there are four distinct states and where is the initial state.
fig.
shows the state transition graph stg where nodes are states and edges are events executed at the source states.specifically from the state if we execute sl the program goes to the state .
from the state if we execute cb the program goes to the state .
from the state if we executecbagain the program goes back to the state because clicking cbtwice or any even number of times reset the status of the check box.
finally at any of these four states ifwe click ok the execution ends in this sense okcan only appear at the end of an event sequence.
b. our new method as we have mentioned ideally we would like to execute each enabled event cb sl sa o rok at every reachable state and .
surprisingly to achieve this goal only a small subset of event sequences in the search tree offig.
need to be explored as shown by the reduced treein fig.
.
the yellow states are irredundant states solid bluelines are the irredundant sequences while blue states representthe backtracking points because they match some previouslyexplored states and thus do not need to be explored again.
initially the program is at state .
state can be reached via the sequence sl 0v i a cb and via cb sl .
thus we have brought the application to all four states.
next we execute each enabled event at every reachable state.
thenumber of sequences is not but because some of theshorter sequences are subsumed by longer ones.
specifically there is no need to execute cb sl o r cb sl from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 d32 d33 d34 d35 d36c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12b1 b2 b3 b4a1start cb slsa ok cb slsa okcbslsa okcbslsa ok cb slsaok cb slsaok cbslsaok cbslsaok cbslsaok cbslsaok cbslsaok cbslsaok cbslsaok fig.
.
the complete tree of event sequences of length 3for the gui application in fig.
and fig.
.
start end 11sa sl cbok saorsl cboksa slcb ok saorslcbok fig.
.
state transition graph where each state is a valuation of variable convert and predicate angle .
the initial state because they are already part of the longer sequences cb sl ok and sl ok .
however there are redundancies even among these event sequences.
for example since cbdoes not read from any of the two variables convert andangle executing cbfrom any of the four states would result in the same code coverage for the listener function of cb.
since cbis enabled at state there is no need to test cbat another state.
similarly since sareads only from angle executing sa from and or and would result in the samecoverage for the listener function of sa.
although slreads from both variables it overwrites angle before reading it and thus depends only on the value of convert.
due to this reason executing slfrom and or and would result in the same coverage for the listener function of sl .
finally since cbdepends on both variables it has to be executed from all four reachable states.
using this new notion of reduction we can generate the following event sequences while maintaining the same test coverage as the complete set of sequences.
t1 cb sl ok t2 cb ok t3 sl sa t4 sl ok t5 sa t6 ok c. comparison to existing techniques our reduction differs from techniques based on partial order reduction por which is a widely used idea for state spacereduction e.g.
in model checking and concurrency testing .
theidea of por has also been used to reduce the cost of testingevent driven programs .
that is when twosequences of events are equivalent permutations of each other only one of them will be tested.
however since por reliessolely on the theory of equivalent traces it can onlyidentify redundancy in event sequences of the same length.
in contrast our reduction goes beyond equivalent permutations it also can identify redundancy in sequences of differentlengths e.g.
as shown by sa sa ok and sa ok which are not permutations of each other.
indeed applying por tothe example in fig.
would produce sequences signifi cantly more than the sequences produced by our method.
compared to state of the art gui testing tools such as guita r and gazoo our method also has two advantages it does not skip useful test sequences and it often leads to fewertest sequences.
both guit ar and gazoo skip test sequences in an ad hoc manner to reduce their computational overhead which means they often miss important corner cases.
for instance below are the seven sequences t prime 1tot prime7 generated bygazoo for our running example t prime cb sl ok same as our t1 t prime2 cb cb ok equivalent to prefix t1 cb ... andt6 ok t prime3 sl sl ok equivalent to our t4 sl ok t prime cb cb sl equivalent to t3 sl ... t prime cb sl sl equivalent to t1 cb sl ... t prime6 sl sl sl equivalent to t3 sl ... t prime7 sl sl sa equivalent to our t3 sl sa all sequences generated by gazoo are subsumed by our sequences.
some are clearly redundant both t prime 6and t prime7are subsumed by our t3 and both t prime1andt prime5are subsumed by our t1.
in addition our sequences are not only fewer versus but also shorter which may translate to faster test execution.
second the sequences generated by gazoo does not cover all behaviors.
in particular they missed t2 cb ok and t5 sa both of which are useful test cases.
for example bug in fig.
line can be reached by sa and bug line can be reached by cb ok .
since gazoo failed to generate these two sequences it missed these bugs.
a more severe problem of gazoo and other existing techniques is that as the length increases the number of sequences grows exponentially.
for our running example when the maximum sequence length is set to ... the number of sequences generated by gazoo would be ... respectively as shown in fig.
whereas the number of sequences generated by our new method would remain .
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d1 d2 d3 d4d5 00d6 11d7 d8 d9 d10 d11 d12 d13 d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 d32 d33 d34 d35 d36c1 00c2 11c3 c4c5 c6 c7 c8 c9 c10 c11 c12b1 10b2 01b3 00b4a1 00start cb slsaok cb sl saokcbsl saok cbsl saok cb slsaokcb slsaok cbslsaok cbslsaok cbslsaok cbslsaok cbslsaok cbslsaok cbslsaok fig.
.
the reduced tree of event sequences of length from sequences to sequences and then to sequences.
maximum sequence lengthnumber of test sequencesour t ool gazoo fig.
.
the number of sequences generated by gazoo and our tool as the maximum sequence length increases.
reason is because our six sequences already cover all possible behaviors of this gui application as shown in fig.
.
d. stateless implementation at this moment one may have the impression that our new method relies on recording the states of the gui application at run time which is often how classic por techniques areimplemented in model checkers.
however this is not thecase.
our main contribution is using stateless techniques to identify the provably redundant sequences without executingthe gui application.
this is important because recordingconcrete states may be prohibitively expensive in practice.
thus we assume the state transition graph stg shown in fig.
is not available.
instead we rely on checking a set ofsufficient conditions under which two sequences are guaranteed to result in the same state.
furthermore we make sure that these conditions can be checked statically by inspectingonly the event sequences and event listener functions.
for example since sadoes not write to any variable executing it does not change the state.
therefore if an eventleading to the state sissa or any other event that does not modify state variables we know sis an already explored state.
consequently we can skip all event sequences starting froms.
similarly executing sl sl would lead to the same state as executing sl assuming that executing slalways returns the same set of non values for angle.in both cases we need not access the values of program variables.
instead we check for each event what are the variables it reads from or writes to and for any two events ifthey are causally dependent details in section v .
these statically checkable conditions are sufficient in that if they hold the corresponding sequences are guaranteed to be redundant.
in this sense our reduction never removes usefulsequences.
however these conditions are not necessary wedo not attempt to capture all redundant sequences because the overhead would be prohibitively high.
inherently this is atrade off between the pruning capability and the computational overhead.
thus it is important to assess how well our method perform in practice e.g.
does it reach or come close to theideal reduction?
in our experimental evaluation section vi we will demonstrate that our carefully designed sufficientconditions work well in practice.
iii.
p reliminaries a. gui application a gui application consists of a set cofcontainers such as windows panels and tabs a set wofwidgets such as labels buttons and check boxes and a set l oflistener functions associated with the widgets.
widgets are grouped by containers that host them and are elements ofinteraction allowing the user to interact with functional partsof the software code.
gui libraries such as java awt swingcontain a large collection of widgets and the default programlogic for manipulating them.
a listener l lis a function that may be invoked to respond to a user event.
some listeners are built in listeners provided by gui libraries while others are custom made they are written by the application developers.
for ease of presentation weconsider one listener per widget in the remainder of this paper.
thus triggering an event means executing the listener associated with the widget.
b. event flow graph the mapping between widgets and listeners of a given application may be reverse engineered using tools such asguit ar which leverages dynamic execution and the java accessibility feature to traverse an object and its children and execute their listeners.
the widget to listener mappingobtained in this way is represented by an event flow graph authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
efg which shows the set of events enabled at every step of the execution.
the efg is one of the inputs to test sequencegeneration tools including ours.
formally an event flow graph is a directed graph g efg e t where eis a set of events and tis a set of transitions between these events.
let e0 ebe the set of events enabled at the beginning of the gui execution.
from these initial events each subsequent transition evi e vj t where evi e vj e represents the fact that executing eviallows evj to be executed in the next step.
fig.
shows an example efg consisting of four events which corresponds to the listener functions in fig.
.
all fourevents are enabled initially and after executing any of the firstthree events all four events remain enabled.
however okis different in that executing this event would end the execution in the efg okdoes not have outgoing edges.
c. dependency relation since event listener functions may read from or write to shared variables they may impose dependency over events.in partial order reduction two events are consideredconflict dependent or simply dependent if they access the same variable and at least one of the accesses is a write.
in fig.
for example okdepends on cbandslbecause it reads from convert andangle written by the other two events.
based on this notion of dependency two event sequences are equivalent if they can be transformed to each other by repeatedly swapping the adjacent and independent events.
although this dependency relation has been widely used in model checking and concurrency testing it is often not accurate enough for dealing with events in gui applications.for example in fig.
one slevent and another slevent have overlapping read write and write write sets since theyboth read from and write to angle.
however the listener function of slalways overwrites the value of angle before reading from it which means the behavior of the second sl event s listener function does not depend on the value ofangle written by the first slevent.
in this sense we say these two events are not causally dependent.
causal dependency.
we rely on the refined notion of dependency namely causal dependency.
here two events ev e v2 eare causally dependent denoted ev1 e v2 rcd where rcdis the dependency relation if the execution of any one of them may affect the subsequent execution of the other.when two events are not causally dependent we say theyare causally independent.
causal dependency is more accurate than conflict dependency in that it reflects the actual impact ofone event over another.
in section v we shall explain how asimple static analysis of the event listener functions can helpdetermine whether two events are causally dependent.
iv .
s ystematic testgeneration we first present the baseline algorithm for generating test sequences with no reduction and then discuss how to inte grate por based reduction into the algorithm.a.
the baseline algorithm given the efg g e t and the causal dependency relation r cd algorithm excluding lines and generates all possible event sequences up to a predetermined length.
following the notation established in stateless model checking we use a stack named sto store the sequence of abstract states.
scontains the initial state s0at the beginning.
for each state s s w eu s es.enabled to denote the set of events enabled at s use s.selev to denote the event chosen to execute at s and use s.done to denote the set of all previously chosen events at s. the procedure e xplore first checks if the execution has ended i.e.
if s.size maxlength ors.enabled .i f either condition is met the while loop would be skipped.
then output sequence s is invoked to print the event sequence stored in s provided that sholds a complete execution indicated by s.selev null as opposed to the prefix of a longer execution.
otherwise it enters the while loop to execute a previously unexplored event set s.selev event and invoke e xplore recursively.
after all events in s.enabled are explored it exits the while loop.
at this moment s.selev will not be null meaning sholds the prefix of a longer sequence that has been printed .
consider the running example in fig.
.
applying algorithm with maxlength would explore the complete tree of sequences as shown in fig.
.
clearly some of these sequences are redundant and thus should be removed.toward this end we will present partial order reduction in the remainder of this section as well as our new redundancyremoval technique in section v. for now we note that compared to existing test generation tools such as guit ar and gazoo the main advantage of algorithm baseline is that it captures all possibleevent sequences the efg can produce up to the predefinedlength.
as such it does not miss useful test sequences.
b. partial order reduction the idea of partial order reduction originated from explicitstate model checking where the model checker needed to reduce the size of the state space to be searched.in this context a large number of algorithms were developed including stubborn set methods ample set methods and persistent set methods.
for a comprehensive review of these classicmethods refer to godefroid s book .
all these classicmethods rely on the same principle which is first classifyingthe execution traces into equivalence classes of permutations and then exploring one representative from each equivalence class.
since all traces from the same equivalence class lead tothe same system behavior covering all equivalence classes isthe same as covering all execution traces.
in fig.
for example the following sequences are considered equivalent ... cb sa ... and ... sa cb ... .
the reason is that cbonly writes to convert andsaonly reads from angle thus the execution order of these two events is immaterial.
if ... cb sa ... has been explored then ... sa cb ... can be skipped.
in algorithm we add lines and to show a particular implementation of por based on the sleep set .
specifi853 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm baseline test generation procedure with por.
let statestack s s0 s0.enabled initially enabled events and invoke explore s procedure explore s lets s.top if s.size maxlength then lets.done while event s.enabled s.done s.sleep do addevent tos.done lets prime next state s event set s.selev event lets prime.sleep e s.sleep eandevent are independent s.push s prime explore s addevent tos.sleep end while end if if s.selev null then output sequence s end trace s s print s.selev end if s.pop end procedure cally after an event e.g.
cbin fig.
is explored from a state s line it is put into the set s.sleep line .
when we explore another event e.g.
sa from s we check if the new event is independent of events in s.sleep .
if that is the case we carry the sleep set over to the next state s prime.
otherwise we drop it from s prime.sleep .
at any time in the future if the procedure e xplore attempts to execute a new event e.g.
cb that already exists in the sleep set e.g.
as in ... sa cb we skip the event because executing the event is guaranteed to reach a previously explored state.
although por is widely used it has a limitation.
that is por can only identify redundant sequences that are permutations of each other which implies these sequences have the same set of events it can never identifyredundancy in sequences such as sa sa ok and sa ok in fig.
because they have different lengths.
therefore weneed to develop a more powerful reduction technique.
v. t henewreduction technique we first explain the rationale behind our new reduction technique and then present our stateless implementation.
a. the new algorithm algorithm shows our method which is algorithm augmented with two modifications at lines and .
that is prior to executing an event line we check if the new state s primeis a previously explored state by analyzing the events stored in s s.selev s .
similarly prior to printing an event sequence line we check if it can be subsumed by other sequences.
both of these checks are designed to be conservative in nature meaning if they return true we can safely skip the corresponding states and sequences.
the subroutine redundant state takes the current state stack sand the next event evas an input.
recall that states insare abstract states that do not have concrete values of the variables.
instead we rely on the event sequence stored in theselev field of each s sto check if the next state has been explored.
thus our implementation is stateless.
similarly redundant sequence checks if the event sequence stored inscan be subsumed by other sequences.
consider our running example in fig.
.
the subroutine redundant state returns true when the current sequence inalgorithm new test generation procedure with reduction.
let statestack s s0 s0.enabled initially enabled events and invoke explore s procedure explore s lets s.top if s.size maxlength then lets.done ands.printed while event s.enabled s.done s.sleep do addevent tos.done if redundant state s event then lets prime next state s event set s.selev event lets prime.sleep e s.sleep eandevent are independent s.push s prime explore s end if addevent tos.sleep end while end if if redundant sequence s s then output sequence s end trace s s print s.selev end if s.pop end procedure procedure redundant state s ev ifnowrite samewrite covwrite gencovwrite then return true else return false end if end procedure procedure redundant sequence s s if s.selev negationslash s.printed irrelevantt ail extrasink causalindep then return true else s s add s.selev tos.printed return false end if end procedure splus the next event denoted event contains the following sequences cb state c1 cb state d5 sl state d6 sa state d7 ok state d8 not redundant sequence sa state c3 ok state c4 not redundant sequence cb state c5 sl state c6 sa state c7 not redundant sequence ok state c8 not redundant sequence cb state c9.
sl state c10.
sa state c11.
ok state c12.
state b3 not redundant sequence ok state b4 not redundant sequence that is we backtrack as soon as reaching any of the states c1 d5 c3 and b3 because redundant state shows they are already explored.
in addition except for six of these sequences redundant sequence proves they are subsumed by some shorter sequences.
among the six event sequences that are not redundant sa b3deserves further explanation since it is the only one that is the prefix of some longer sequences.
furthermore none of these long sequences extensions of sa w a s printed because they are redundant sequences themselves .
thus upon reaching line of algorithm we invoke output sequence to print it out.
to enable the printing of partial sequences such as sa b3 we add s.printed to record the set of events authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
printed at s. initially s.printed is empty line .
every time redundant sequence returns false which forces the current sequence to be printed we add s.selev tos.printed line .
thus only if s.selev negationslash s.printed line we allow redundant sequence to return true.
otherwise the current sequence would have already been printed as part of a longer sequence.
b. detecting redundant states now we present the sufficient conditions for detecting already explored states line of algorithm .
let sn 1andsnbe the last two states in the state stack s evn 1be the event chosen and executed at sn and evbe the event considered but not yet executed at sn.
we start with special cases nowrite and samewrite which are easier to understand before presenting the general cases.
nowrite .
the first sufficient condition for ev to result in a redundant state is as follows evn .write ev sn .enabled proof sketch as shown in fig.
a since evn .write we know executing evn 1does not change the state.
thus sn sn .
furthermore since ev sn .enabled the sequence ev1 ... e v n e v always exists and is shorter than ev ev1 ... e v n e v .
thus executing ev from swould not lead to any new program behavior.
samewrite .
the second sufficient condition for ev to result in a redundant state is as follows evn .write evn .read ev evn proof sketch first since ev evn we know the condition ev sn .enabled holds as well.
furthermore since evn .read evn .write the values read by ev and hence the values written by ev do not depend on the values written by evn .
in other words executing evmore than once results in the same state.
thus executing evfrom swould not lead to any new program behavior.
for example in fig.
... sl sl satisfies this condition.
although slreads from both convert andangle the read of angle is dominated by its own write to angle.
thus we do not consider angle as part of sl s read variable set.
consequently sldoes not causally depend on values written by the previous sl.
covwrite .
this is a generalization of the two previous cases.
in this case the sufficient condition for s ev to result in a redundant state is as follows evn .write ev.write evn .write ev.read ev sn .enabled proof sketch the first condition means evoverwrites all values written by evn the second condition means evn does not affect evvia shared variables and the third condition means evis enabled at sn 1as well.
therefore the shorter sequence ev1 ... e v n ev would lead to the same state as the longer sequence ev ev1 ... e v n e v .
thus we can safely skip the execution of evfrom s.s0start sn snevn 1ev ev a nowrite s0start sk si snev b generalizedcovwrite fig.
.
conditions for snto be a redundant state.
generalizedcovwrite .
this is a further generalization ofthe previous case.
let s ... s i ... s k ... s nbe the entire sequence of states currently in s where eviand evkare events selected at siandsk respectively and evis the event selected but not yet executed at sn.
the sufficient condition for ev to result in a redundant state is as follows i n. evi.write ev.write evi.write uniontext i k nevk.read evi.write ev.read evi si.enabled proof sketch as shown in fig.
b the current eventevoverwrites all values written by ev i. furthermore evi does not affect any of the subsequent events including ev.
furthermore since evi si.enabled there is a sequence ev1 ... e v i e vi ... e v n e v that is shorter and results in the same state as ev .
in this case executing evfrom swill not lead to any new program behavior because the next state can be reached by some shorter sequence.
c. eliminating redundant sequences now we present our sufficient conditions for detecting redundant sequences line of algorithm .
these reductions are complementary to por because they consider a sequenceas redundant if it is subsumed by some other sequences ofshorter length.
specifically in algorithm prior to generating the event sequence line we check if any of the following conditions is satisfied.
if the answer is yes we skip the sequence becausethe equivalent but shorter sequence would be generated.
irrelevantt ail .
the first sufficient condition for to be a redundant sequence is as follows.
let s ... s i ... s nbe the state sequence currently in s evibe the event selected at si and evnbe the event selected and executed at sn.
the sequence is redundant if i n such that parenleftbig evn.read uniontext i k nevk.write parenrightbig evn si.enabled proof sketch when the above condition is satisfied the last event evn selected and executed at sn is guaranteed not to depend on any value written by the preceding eventsev i ... e v n .
in such case ev ... e v n can be replaced by the two shorter sequences ev1 ... e v n and ev1 ... e v i e vn and thus can be skipped.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in our example cb sa has an irrelevant tail and thus can be replaced by the two shorter sequences cb and sa .
extrasink .
let s1 ... s i ... s j ... s nbe the state sequence in s eviand evjbe the events selected at siand sj respectively and evnbe the event selected and executed atsn.
the sequence is redundant if i j nsuch that eiandejdo not enable or disable any event executed after them and the following condition is met parenleftbig ei.write uniontext i k nek.read parenrightbig parenleftbig ej.write uniontext j k nek.read parenrightbig proof sketch the condition means neither einorejcan affect any event executed after them in s. furthermore skipping ei orejdoes not enable disable other events.
thus can be replaced by the shorter sequences ei and ej .
for example in fig.
cb ... sa ok has two extra sinks saandok.
therefore it can be replaced by the two shorter sequences cb ... sa and cb ... ok .
causalindependentwrite .
the third sufficient condition is related to causally independent writes.
let s1 ... s i ... s n be the state sequence in s evibe the event selected at siand evnbe the event selected and executed at sn.
the sequence is redundant if i n such that evidoes not enable disable any event executed after it in sand the following condition is met evn e vi negationslash rcd proof sketch first the above condition means evnis not causally dependent on evi.
in other words whether eviis executed at sidoes not affect the behavior of evn.
furthermore since evidoes not enable or disable any event executed after it there exist two shorter sequences ev1 ... e v n and ev1 ... e v i e vi ... e v n that subsume .
thus the event sequence can be skipped.
d. computing causal dependencies whether two events eviand evjare causally dependent i.e.
evi e vj rcd can be decided using a conservative static analysis of their listener functions.
the analysis isconservative in that if it says ev iis not causally dependent onevj the behavior of eviis guaranteed not to be affected byej.
however the analysis may not identify all causally independent event pairs due to limitations of static analysis.
we use soot to implement the static analysis.
we mark each java class member as classname.membername and consider all program variables.
first we compute foreach event listener function the set of read variables andthe set of write variables.
the difference between our read and write variable sets and those computed by conventional techniques is that we exclude from the read set variables that are overwritten before they are read.
specifically for each event listener function we parse the java byte code and initialize an empty write variable set.
for each basic block through which the data flows we takethe union of the in flow and out flow.
for each basic block where two data flows merge we take the intersection.
whenwe compute the read variable set if the variables read by a basic block is included in the previously computed flow set we ignore them because they have been overwritten by the method itself.
otherwise we add them to the read variable set.
after the aforementioned intra procedural analysis is completed we use an inter procedural program slicer similar to the one used by gazoo to compute the causaldependency relation r cd.
essentially the program slicer recursively adds variables read or written by the listener function as well as functions invoked by the listener function.
as an example consider the slevent in fig.
.
although both angle andconvert are read by the listener function since angle is overwritten before it is read it is excluded from the read set.
thus sl.read convert and sl.write angle and therefore sl sl negationslash rcd.
vi.
e xperiments we have implemented our method in a tool named guicat in which the following components are used guit ar for reverse engineering the event flow graph soot for conducting static program analysis and cobertura for executing test sequences on the gui application to obtain the coverage report.
our core algorithm for generating test sequences was implemented in lines of java code.for experimental comparison we implemented the algorithmin such a way that individual reduction techniques can beenabled and disabled.
thus we were able to compare the performance of the following configurations our baseline procedure as shown in algorithm baseline with por baseline with por plus the individual reductions presentedin section v and all reductions in algorithm combined.we also downloaded guit ar and gazoo and experimentally compared them with our tool on the same benchmark applications.
in both guit ar and gazoo the test sequence generation is model based.
that is they leverage the same efg as in our method but differ in how event sequences are constructed.in our method the construction starts from the initial statesand proceeds systematically but in guit ar and gazoo the construction may start from any node in the efg.
assuch their initial set of event sequences may not be feasible.
to make them feasible meaning they can be executed by the gui application guit ar and gazoo have to insert connecting events to these sequences.
in contrast our method can directly generate feasible event sequences.
our experiments were designed to answer two questions can our new method which soundly generates test se quences outperform state of the art gui testing toolssuch as guit ar and gazoo?
how effective is our semantic reduction technique and itsstateless implementation in identifying and eliminatingredundant sequences?
we used benchmark applications written using java swing.
their statistics are shown in table i. specifically columns and show the name of each application andthe number of lines of code loc respectively.
note thatthe locs of regextester and hashvcalc marked with asterisks are estimated by decompiling the java byte code due to lack authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i statistics of the gui benchmark applications .
name loc node edge description gazoov0.
example application taken from .
guess example crafted to illustrate scenarios similar to gazoov0.
gazoov0.
example application taken from .
ticketseller gui application taken from hashvcalc hash value calculator from sourceforge workout workout generator taken from payment payment form application from the example of squish regextester java regular expression tester from sourceforge addressbook address book application from the example of squish jnotepad notepad application from crossw ords dictionary application jgp gnu plot front end application from sourceforge calc student math calculator from sourceforge ce java class file editor from sourceforge terpspread java spreadsheet application rachota time management application from sourceforge and buddi financial management application table ii comparison of event sequence reduction .
name guicat our tool guit ar gazoo baseline por allnew tests time s tests time s tests time s tests time s tests time s gazoov0.
guess gazoov0.
ticketseller hashvcalc workout payment regextester addressbook jnotepad crossw ords jgp calc ce terpspread rachota buddi total of source code.
columns and show the size of the input efgs including the number of nodes and the number of edges.finally column provides a brief description of the natureof each application.
together the benchmark applications have lines of java code.
we performed all experiments ona computer with a .
ghz cpu and gb ram.
a. comparison of different methods in this experiment we compared the performance of our tool against guit ar and gazoo.
within our own tool we also compared three configurations baseline with por and with the full blown reduction.
table ii shows the results.
specifically column shows the name of each benchmark while the remaining columns are divided into the following groups the baseline algorithm denoted baseline baseline with por denoted por baseline with por plus our new reduction denoted allnew and the two existing tools.
for each method we show the numberof test sequences generated and the test generation time in seconds.
the last row sums up the numbers in each column.
following arlt et al.
we set the maximum sequence length to for all methods.
note that gazoo was not able to generate any test sequences for four applications because the tool was hard wired to produce sequences of dependentevents with length or longer but these four applications do not have sequences that meet the criterion.table iii effectiveness of different reduction techniques .
name por individual reduction in our tool allnew now samew covw gcovw irrtail extras cauind gazoov0.
guess gazoov0.
ticketseller hashvcalc workout payment regextester addressbook jnotepad crosswords jgp calc ce terpspreads rachota buddi total overall there is a significant reduction in the number of test sequences from baseline to por and another significant reduction to allnew.
this means our method is different from and complementary to por.
furthermore there are fewer sequences generated by our method allnew than guit ar and gazoo and the reduction is significant .3x over guit ar and .9x over gazoo .
the reduction is obtained despite that our method is sound whereas guit ar and gazoo may miss important corner cases as illustrated by our running example in section ii.
the reason why baseline had fewer test sequences than guit ar and gazoo was because as we have mentioned neither guit ar nor gazoo could guarantee their initial set of event sequences were feasible.
thus they had to insertconnecting events afterward which means the final sequences might not be strictly bounded by the maxlength.
therewere also no easy fixes that could force them to strictly adhere to the bound.
in contrast the sequences generated byour method were guaranteed to be feasible and within the maxlength.
the time taken by all test generation methods are more or less the same.
since they all work on the efg as opposedto executing the actual gui application the time is negligiblecompared to the time taken to execute the test sequence.
b. comparison of individual reduction techniques in this experiment we evaluated the effectiveness of the individual reduction techniques in our method.
table iii shows our results where column shows the name of each ap plication columns show the number of test sequencesgenerated by each reduction technique and the last columnshows the number of test sequences generated by all reductionstechniques combined.
por was used in conjunction of all theindividual reduction techniques.
the results show that each technique is effective compared to the baseline with por denoted por with improvement ranging from .
to e.g.
computed by cauind .
.
furthermore when combined they can achieve the largest reduction .
this not onlymeans each reduction technique makes its own contribution but also means they are complementary to each other.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv comparison of the test execution results .
name our tool new guit ar gazoo coverage tests coverage tests coverage tests ce terpspreads rachota buddi brevity we do not show the time taken by these individual methods but they are almost the same.
c. comparison of test execution results finally we compare the test execution.
since running test sequences generated by all methods on all applications takes a long time we only obtained results on four larger applications.table iv shows the results including the name the percentageof statements covered and the number of test sequences.
the results show all methods achieved a similar coverage.
the main difference is in the number of test sequences it is 995for our method for guit ar and for gazoo.
forbuddi the reduction is 430x it is sequences for our tool compared to 28k sequences for gazoo.
d. threats to v alidity we did not consider external dependencies imposed by remote network communication database access or the fileio.
therefore our method may miss useful event sequences in the presence of these external dependencies.
this limitation is shared by the other gui testing tools as well.
we didnot consider the diversity of data input either.
during ourexperiments the data input was generated by guit ar s replayer using its default setting to allow a fair comparisonof all tools.
however it was also the reason why the testingcoverage did not come close to .
same as guit ar and gazoo we focused on only one aspect of gui testing whichis the diversity of event sequences.
to improve further fuzzingor symbolic execution techniques may be needed to diversify input data we leave this for future work.
vii.
r elated work gui is an indispensable component of many software applications.
thus there has been abundant research on improving the efficiency of gui testing in various domains including desktop mobile andweb applications .
although techniques proposedin this work were implemented in guicat which is designed for testing desktop applications the underlyingprinciple may be applied to other types of gui applicationsand event driven programs in general.
gui testing is a complex process that requires efficient algorithms and implementation techniques in many differentaspects such as static program analysis dynamic model extrac tion deterministic replay and test case maintenance .
in this work we focus on event sequence generation only while relying on a number of existing toolssuch as guit ar soot and cobertura to offer an end to end solution.
however there is still room forimprovement in these other aspects.beside the work mentioned so far there are other gui testing techniques .
forexample earlier works create models of the softwarecode based on finite state machines but as pointed out in some of these techniques would not work well when themodel does not accurately reflect the actual code.
to avoid thisproblem yuan and memon propose to leverage feedbackfrom the execution of a seed test suite to generate new testcases.
such approach depends on the quality of the seed aswell as randomness during test execution.
our method is related to state space reduction techniques in explicit state and symbolic model checking but with someimportant differences.
in model checking existing methodsare either model based e.g.
relying on a state transition system where values of state variables areavailable or stateless where the model checker does not maintain states but instead dynamicallyexecutes the software.
in contrast our method is a hybridapproach that augments an abstract model the efg with dependencies derived from the software statically.
the efg is more abstract than the state transition system because it doesnot contain values of the program variables.
test sequence reduction has been studied in event driven programs to reduce the test execution cost.
inthis context partial order reduction por serves as a foundational technique for removing redundancy.however as shown in section ii as well as the experiments although por is effective in identifying redundancy among sequences of the same length it misses other redundant se quences.
in comparison our method is more effective since italso exploits redundancy among sequences of different lengths.
beyond test sequence generation an important problem is diversifying the input data.
several recent works have focused on this problem e.g.
by using model checking and symbolic execution .
however scalability remains a problem and thus there is still room forimprovement.
we will consider it for future work.
viii.
c onclusions we have presented a gui testing framework for efficiently generating event sequences while avoiding the redundant sequences.
our technique leverages both model driven testgeneration e.g.
the efg and static analysis of the actual software e.g.
the java bytecode .
it goes beyond partial order reduction by identifying redundancy not only among eventsequences of the same length but also among sequences ofdifferent lengths.
our experiments on java swing applicationsshow the new method significantly outperforms state of the art gui testing tools and the average reduction in the number of test sequences is more than 10x.
for future work we plan todevelop methods for diversifying input data to further improvethe testing coverage.
ix.
a cknowledgments this material is based upon research supported in part by the u.s. national science foundation under grants dge ccf and ccf as well as the u.s. officeof naval research under award number n00014 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.