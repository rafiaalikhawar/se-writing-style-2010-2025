string analysis for side channels with segmented oracles lucas bang1 abdulbaki aydin1 quoc sang phan2 corina s. p as areanu2 tevfik bultan1 1university of california santa barbara santa barbara ca usa bang baki bultan cs.ucsb.edu2carnegie mellon university moffet field ca usa sang.phan sv.cmu.edu3nasa ames research center moffet field ca usa corina.s.pasareanu nasa.gov abstract we present an automated approach for detecting and quantifying side channels in java programs which uses symbolic execution string analysis and model counting to compute information leakage for a single run of a program.
we further extend this approach to compute information leakage for multiple runs for a type of side channels called segmented oracles where the attacker is able to explore each segment of a secret for example each character of a password independently.
we present an e cient technique for segmented oracles that computes information leakage for multiple runs using only the path constraints generated from a single run symbolic execution.
our implementation uses the symbolic execution tool symbolic pathfinder spf smt solver z3 and two model counting constraint solvers latte and abc.
although latte has been used before for analyzing numeric constraints in this paper we present an approach for using latte for analyzing string constraints.
we also extend the string constraint solver abc for analysis of both numeric and string constraints and we integrate abc in spf enabling quantitative symbolic string analysis.
ccs concepts software and its engineering !formal software veri cation security and privacy !logic and veri cation keywords side channel analysis symbolic execution string constraints .
introduction since computers are used in every aspect of modern life many software systems have access to secret information such as nancial and medical records of individuals trade secrets of companies and military secrets of states.
con dentiality a core computer security attribute dictates that a program that manipulates secret information should notreveal that information.
this can be hard to achieve if an attacker is able to observe di erent aspects of program behavior such as execution time and memory usage.
side channel attacks recover secret information from programs by observing non functional characteristics of program executions such as time consumed number of memory accessed or packets transmitted over a network.
in this paper we propose an automatic technique for side channel analysis.
our technique uses symbolic execution for the systematic analysis of program behaviors under di erent input values.
furthermore we use model counting over the constraints collected with symbolic execution to quantify the leakage of the detected side channels.
we present specialized techniques for segmented oracle side channels in which an attacker is able to explore each segment of a secret for example each character of a password independently.
our technique can answer questions such as what is the probability of discovering a password in k runs or what is the leakage in the number of bits after k runs through side channels.
the widespread use of web based applications have resulted in a greater need for analysis techniques targeted at string manipulating programs to ensure better security.
however classic testing approaches such as guided blackbox and random testing are not capable of reliably detecting malicious behaviors simply because the domain of string inputs is too large.
in contrast symbolic execution can explore multiple inputs all at once through the systematic collection and solving of symbolic constraints.
a key challenge that we address in this work is to perform constraint solving and model counting e ciently over a combination of string and numeric constraints.
towards this end we investigate a set of complementary techniques for symbolic quantitative string analysis.
we implemented these techniques in the symbolic pathfinder spf tool .
our contributions can be summarized as follows singlerun side channel analysis using spf that computes the information leakage in terms of shannon entropy using probabilistic symbolic execution and listeners that track the observable values such as execution time le size or memory usage.
two types of multi run side channel analysis for segmented oracles based on a best adversary model.
the rst approach composes the adversary model and the function under analysis within a loop and conducts the multi run analysis on the composed system.
however this approach leads to path explosion.
we also present a second more efcient approach for multi run side channel analysis for segmented oracles that uses path constraints generated for only permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
a single run symbolic execution of the function.
we extend spf to enable analysis of java programs that manipulate strings using two approaches.
one of them traces the implementations of string manipulation functions and treats strings as bounded arrays of characters that are represented as bit vectors and checks satis ability of path constraints using the smt solver z3.
the second approach generates constraints in the theory of strings and uses the string constraint solver abc.
we use two model counting constraint solvers for computing information leakage.
one of them is a model counter for numeric constraints called latte which has been used for analyzing numeric constraints in spf before.
in this paper we extend the spf latte framework to the analysis of string constraints by viewing strings as arrays of characters.
we also integrate the model counting string constraint solver abc with spf.
we further implement an extension to abc that enables model counting for numeric constraints.
with this extension to abc can perform model counting for combinations of numeric and string constraints.
we conduct experiments on two side channel examples demonstrating the performance of di erent approaches.
our approach applies to functions which behave as segmented oracles.
for example time based segmented oracles can result from library functions that use early termination optimizations for string array and memory equality comparisons which are present in many programming languages including c c java python ruby php and node.js .
as described in these types of library functions have enabled real world segmented oracle attacks against the xbox operating system and the hash message authentication code hmac comparisons in the google keyczar cryptographic library and the open authorization standards oauth and openid .
we demonstrate the applicability of our approach given in section .
on a password veri cation function as an example of an early termination segmented oracle and this analysis applies equally well to the other examples just described.
on the other hand size based segmented oracles can arise from text compression functions resulting in leakage of con dential web session information by measuring the sizes of les and network communications .
we demonstrate our approach for this type of segmented oracles using lz77 compression .
although the approach we present in section .
requires an ordered traversal of the secret s segments which is the case for all the examples listed above we believe that in the future it can be generalized to handle oracles which do not require a speci c ordering of segments.
.
side channel analysis consider a password based authentication function.
the password checking function has two inputs a password which is secret and a user input which is public.
the function should compare the password and the user input and return true if the input matches the password and return false otherwise it should not leak any information about the password if the input does not match.
let us consider two password checking functions f1and f2whose implementations are shown in figures and respectively.
we assume that functions f1andf2are executed on inputs handl where we follow the typical notation used in the security literature hdenotes the high value i.e.
the secret password and ldenotes the lowvalue i.e.
the public input that the function compares with the password.public f1 char h char l for int i i h.length i if h !
l return false return true figure password checking function f1.
public f2 char h char l matched true for int i i h.length i if h !
l matched false else matched matched return matched figure password checking function f2.
both functions return true or false indicating if the input l matches the secret h .
note however that the functions may leak some information about the secret through side channels in this case an adversary may infer some information about the secret hby measuring the execution time as explained below .
in general let us assume that function f h l returns an observable valueowhich represents the side channel measurements of the adversary after executing f h l .
the observable value ocan be one of a set of observable values o. we assume that the observable values are noiseless i.e.
multiple executions of the program with the same input value will result in the same observable value.
for the functions f1andf2above let us use the execution time as an observable.
for function f1this will result in n observable values where nis equal to the length of h i.e.
o2 fo0 o1 o ng since function f1will have a di erent execution time based on the length of the common pre x ofhandl.
ifhandlhave no common pre x then f1will have the shortest execution time let us call this observable value o0 since the loop body will be executed only once assuming the password length is not zero .
if h andlhave a common pre x of one character and assuming that password length is greater than or equal to two then f1will have a longer execution time since the loop body will be executed twice let us call this observable value o1 .
in fact for each di erent length of the common pre x of handl the execution time of f1will be di erent.
let observable value oidenote the execution time of f1for the common pre x of size i. note that oncorresponds to the case where handlcompletely match where nis the length of the password.
on the other hand execution time of f2is always the same so f2does not have a side channel.
side channel analysis can be used to answer following type of questions are f1andf2leaking information about the secret through side channels and if so how much?
based on the above discussion we can see that f1is leaking information about heven when handldo not completely match.
by observing the execution time of f1 an adversary can deduce the length of the common pre x of handl.
f2on the other hand leaks no information through the side channel.
note that an attacker learns that his not equal to the value of l. however the information leakage forf2is pretty small compared to the information leakage byf1 which has the timing side channel .
for example assuming the secret is a four digit pin an attacker needs at most 104tries to guess the password using f2but at most tries usingf1 as the adversary can try to rst guess the rst 194digit in the pin then secod digit etc.
using the side channel information .
the question is can we formalize the amount of information leaked and can we automatically compute it?
.
entropy computation shannon entropy is a well known information theoretic concept for measuring the expected amount of information contained in a message.
the observables produced by a functionfcan be considered the messages that an adversary receives by executing f they correspond to messages about the secret.
hence we can use the shannon entropy to measure the amount of information conveyed by each execution off i.e.
the amount of information leaked by function f. we de ne the shannon entropy of a function fas h f x oi2op oi log2 p oi wherep oi is the probability of observing the value oiafter executingf.
in order to compute the shannon entropy we need to compute the probability of observing each value oi.
we can compute these probabilities using probabilistic symbolic execution with model counting .
symbolic execution se is a well known program analysis technique that executes the program on symbolic rather than concrete inputs and computes the program effects as functions in terms of these symbolic inputs.
symbolic execution also computes and maintains a path condition pc which is a conjunction of constraints over the symbolic inputs that characterizes those inputs that follow each path through the program.
in our analysis we perform symbolic execution where bothhandlare symbolic to systematically analyze all paths through the code.
in this way we collect each path condition and corresponding observable as an ordered pair oi pc i .
for example symbolic execution of function f1 results in a set of n path conditions each with a di erent time observation f o0 pc o1 pc on pc n g witho0 o o n and path conditions of the form pc h l pc h l h l pc h l h l h l ... pcn h l h l h l pcn h l h l h l each path condition pciencodes the fact that a pre x of the public input lmatches a pre x of the secret h. for example o1 pc indicates that the rst character in the public input matches the rst charter in the secret and the second character does not match.
for the largest observable we see that on pc n indicates that the public and private inputs match on all segments.
we can compute the probability p oi for each observable valueoi using model counting over the path conditions in the following way.
let ddenote the input domain i.e.
the set of possible values for handl assumed to be nite and letjdjdenote the size of the input domain.
we write jpcjto denote the number of solutions over dthat satisfy the path constraint pc.
we can compute jpcjusinga model counting constraint solver .
assuming a uniform distribution for handlthe probability of observing oiisp oi jpcoij jdjwhere the probability of the input value completely matching the password hisp on .
for function f2there are only two observable values through themain channel i.e.
the boolean values returned by the function and the corresponding path constraints are h l h l h l h l h l h l figure shows the shannon entropy computed for f1and f2as described above using probabilistic symbolic execution and model counting.
note that as the size of the password increases the entropy gets very close to for function f2.
so for a reasonable sized password f2does not leak information.
however for f1we observe that the information leaked remains around bit even if we keep increasing the length of the password.
independent of the size of the password f1leaks information about the rst digit of the password due to the timing side channel.
password lengthentropy bits f1 f2 figure entropy after a single guess for functions f1andf2 for password length ranging from to .
the analysis we presented above computes the amount of information leaked by a single execution of a function.
we can also easily determine the amount of initial information in the system by assuming that his picked using a uniform distribution from the domain dh.
then the amount of information in the system initially is h h x v2dh1 jdhj log2 jdhj log2 jdhj an execution of the function leaks the amount of information given by the shannon entropy of the function h f and the remaining entropy in the system is h h h f .
an interesting question to answer is the following how many tries would it take an adversary to gure out the password?
we can try to estimate the attack sequence length using the information leakage.
when the amount of information in the system reaches zero then we can conclude that the adversary has gured out the password.
based on the amount of initial information and the shannon entropy for the function we can try to estimate the amount of runs it would take an adversary to determine the secret.
however this analysis would not be accurate since an adversary could learn from previous tries and choose the l values accordingly based on earlier observations.
so except for the rst run the adversary would not pick the lvalues with a uniform distribution from the domain of l. in order to do a more precise analysis we need to model the adversary behavior.
we discuss how to do this for a particular class of problems called segmented oracles in the following section.
.
segmented oracles segmented oracle side channels provide observations about segments of the secret.
for example a segmented oracle side channel can provide an observable value such as execution time that enables an adversary to determine if the rst character of the secret value for example a password matches to the public value the input provided by the adversary .
in general a segmented oracle provides a distinct value for each matched segment such as the matching the rst character in the password matching the rst characters the rst characters etc.
note that for the function f1shown in figure execution time serves as a segmented oracle side channel.
the function terminates the execution immediately if it determines that the rst character of the secret does not match the input and the execution time increases linearly with the number of segments that match.
i.e.
by observing the execution time an adversary can gure out how many characters of the secret match the public input.
hence for the function f1 execution time acts as a segmented oracle side channel.
the function f1is a particular instance of an early termination optimized equality comparison.
it returns false as soon as it discovers a mismatch in order to avoid unnecessary comparisons.
this is a common programming pattern found in many library functions which results in segmented oracle timing attacks .
these vulnerabilities are remedied by implementing constant time functionally equivalent versions of those comparison functions that operate over sensitive data for example f2 in order to remove the timing side channel .
our approach provides a method for automatically quantifying the amount of information an advesary can gain by a function under a segmented oracle side channel attack indicating whether a constant time implementation is necessary.
now let us discuss the adversary model.
we are assuming that the adversary is runs a function fmultiple times with di erentlvalues but the secret hstays the same and is records the corresponding observables while trying to gure outh.
further we assume that the analyzed programs are deterministic i.e.
given handlvalues f h l returns one observable value owhich represents the observations of the adversary after executing f h l .
for segmented oracles the observable values consist of a set of values o2fo0 o1 o ng whereo0denotes no segments of the input l and secret h match oidenotesisegments of the secret match the input andondenotes the secret completely matches the input.
we call each execution of fa run.
so the adversary is generating a sequence of lvalues to run the program multiple times the intuition being that each run reveals some new information about the secret.
we can formalize the adversary as a function athat takes all the prior history as input which is a sequence of tuples where each tuple is a lvalue and the corresponding observable for the execution of functionfwith thatlvalue .
note that the hvalue is constant and does not change from one execution to the other.
we can model the whole system s a f where the adversaryagenerateslvalues for multiple executions of the functionfin order to determine the secret h as follows.
given the system s a f we may want to compute the probability of determining the secret after kruns i.e.
havingjseqj kwhensterminates.
or we may want to compute the information leakage i.e.
entropy for kruns.
one approach would be to analyze the system swithoutrestricting the adversary.
however this would take into account behaviors such as the adversary trying the same lvalue over and over again even though it does not match the secret.
when analyzing vulnerabilities of a software system we have to focus on the behavior of the best adversary.
procedure s a f initiallyseq nil repeat l a seq o f h l seq append seq hl oi until o on for the segmented oracles it is easy to specify the best adversaryab .
this adversary works as follows let hl1 o1i hl2 o2i hlk okibe the run history.
the adversary generates lk 1for thek 1st run as follows ifok6 ok 1andok oi then the adversary constructslk 1as follows 8j j i lk lk part oflthat already matched remains the same lk lk use a di erent value for the rst part that did not match in the last try and rest of the lk is randomly generated.
ifok ok then letmbe the smallest number where om okand letok om oi then the adversary constructs the lk 1as follows 8j j i lk lk part oflthat already matched remains the same and8j m j k lk lj use a di erent value then the values that have already been tried for the rst part that does not match and rest of the lk is randomly generated.
letskdenote the execution of the system s ab f where the function fis executed ktimes i.e.
jseqj k. we can ask the following question what is the probability of the adversary abguessing the password in exactly ktries?
note that execution of skwill generate observable sequenceso1 o2 okwhere for all t k ot oi ot oj j i. i.e.
since we are using the best adversary modelab the observable values in the sequence will be non decreasing.
the adversary will never produce a worse match than the one in the previous try.
another constraint for the observable sequences is that if onappears in a sequence then onis the last observable of the sequence since sterminates when onis observed.
we can calculate the probability of determining the password in exactly ktries as the probability of generating the observable sequences o1 o2 olwherel k observable values in the sequence are non decreasing and ol on.
letp o1 o2 ok denote the probability of skgenerating that particular observable sequence.
then we can compute the entropy for sk i.e.
the information leakage within the rstkruns as follows h sk x o1 o2 ol2seqkp o1 o2 ol log2 p o1 o2 ol whereseqkis the set of all non decreasing observable sequences that can be generated by the rst kiterations of s ab f .
for every sequence o1 o2 ol2seqk l k the observable values in the sequence are nondecreasing if onappears in the sequence then it is the last observable in the sequence and if ondoes not appear in the sequence then l k. .
multi run side channel analysis in this section we present two approaches to multi run analysis of segmented oracles.
the rst approach is intuitive and more general it is applicable to any adversary model.
however this approach requires the probabilistic symbolic execution of an adversary model which executes the program multiple times and thus it su ers from the path explosion problem.
to address this problem for the best adversary model we propose a more scalable approach with a novel computation of the leakage which requires the probabilistic symbolic execution on only one run of the program.
.
multi run symbolic execution our rst approach for multi run side channel analysis is described with the following two steps.
first we create a model of the attack scenario explained in section where an adversary can provide the low inputs and execute the program a number of times.
then we use probabilistic symbolic execution to explore all possible observations of the model and compute the probability for each observation.
shannon entropy and channel capacity of the leaks are easily derived from the probabilities.
in this work a model in our analysis is a java bytecode program written as a driver for the program under test.
since the secret hand the inputs of the adversary l1 lk are not known in advance they are modeled by symbolic variables in symbolic execution.
without any constraints onl1 lk this is a model for a very naive adversary who repeatedly tries to guess the secret with random values and learns nothing from the previous attempts.
to model an adversary who gains information through observing program executions and revises the input domain accordingly we use the assume guarantee reasoning in se to impose the constraints on the inputs.
we illustrate the approach by implementing a particular adversary model.
.
.
the best adversary model proceduresin figure depicts a driver modeling the best adversary described in section .
here an observation oiof the adversary indicates how many segments in the low input matched with the secret.
the adversary is allowed to make kexecutions of f h l but stops early if all the segments are matched i.e.
oi jhj.
the instruction assume implemented by the built in api debug.assume in spf is used to impose constraints on the inputs.
the best adversary is characterized by two sets of assumptions.
the rst set of assumptions re ect the fact that for the segment being search s the best adversary selects an input di erent from the ones in the previous executions.
when the adversary discovers more segments of the secret i.e.
whenoi oi she keeps these segments for the inputs of the following executions and moves on to search for the next segment.
this is modeled by the second set of assumptions in the procedure.
.
.
computation of information leakage in this approach the computation of leakage does not depend on any particular adversary model s a f i.e.
it can be applied to any model with any assumptions made by the adversary or even no assumptions at all.
for our analysis we extend classical symbolic execution to keep track of the assumptions asm in a symbolic path.
at a low level asm is implemented with exactly the sameprocedure s ab f vars s the current segment of hbeing searched b the rst time sis searched o0 o1 ok observations of the adversary begin s b o0 for alli2 f for allj2 lj g oi f h li if oi jhj freturng if oi oi f for allj2 f for alln2 fassume lj li g g s oi b i g g end figure adversary model data structure as the path condition.
when executing the instruction assume c symbolic execution updates the path conditionpc pc c and checks satis ability with a constraint solver.
symbolic execution advances to the next instruction if the updated pcis satis able and it backtracks otherwise.
our extension for symbolic execution updates asm asm conly when the updated pcis satis able.
thus there is no constraint solving overhead for asm .
we performs symbolic execution with our extension on the models a f to explore all possible observations.
each observation of sis a sequence of observations of f !oi ho1 o2 oniwhere n k. for each !oi we also obtain from symbolic execution the path condition pci that leads to that observation and the assumptions asm i on that path.
we denote by dh d1 d2 d kthe domains of h l1 l2 lk respectively.
the input space is then d dh d1 dk.
if there is no assumptions on the low inputs lican take any valuedi.
hence the search space of the adversary is d and the probability of observing !oiis computed by p !oi jpcij jdj in the case the adversary has some knowledge about the input modeled by the assumptions the revised domain of !oiisjasm ij and hence its probability is p !oi jpcij jasm ij bothjpcijandjasm ijare computed by model counting tools integrated in probabilistic symbolic execution.
we will discuss in more details about these tools in later section.
.
multi run analysis using single run symbolic execution as shown in the previous section we are able to compute the probabilities of observation sequences by performing a complete symbolic execution of a program which simulates the adversary strategy of repeated guessing.
however performing a complete symbolic execution over all iterations of adversary behavior can become prohibitively expensive.
therefore we seek to avoid this expensive computation.
in 197this section we describe how to compute the sequence probabilities using symbolic execution and model counting from only a single iteration of the adversary strategy by taking advantage of the segmented nature of observations which reveal the secret.
notation.
for a segmented oracle the low l and high h inputs are compared incrementally.
the nsegments of l andhare denoted by l l andh h respectively.
we write h for the slice of hfrom index i to indexj and similarly for l. we letdibe the domain size ofl or equivalently the domain size of h and we write d hd0 d1 d n 1ifor the vector of these domain sizes.
we will write di jto denote the subvector of dof indicesi throughj andqdfor the product of all elements of d. probability computation.
by performing a symbolic execution of a single run of f h l we can automatically generate the set of observables and corresponding path conditions f oi pc i i ng.
without loss of generality we assume an order of observables o0 o o n and we assume that the path conditions are in the form given below a generalization of the path conditions given in section .
path constraints of this form result from symbolic execution of comparison functions which utilize the early termination optimization programming pattern as described in section .
pci l h i j 0h l !
ifi n n j 0h l if i n due to the segmented nature of the comparison between landh we can consider the size of the domain difor each segment that is the number of possible values to which each segment can be assigned independently.
then each pcidetermines a combinatorial restriction on the set of d. in the case of pcnwhere each h l we have that for any of the divalues forl the value of h is constrained to a single value.
therefore the product of the domain sizes must be equal to jpcnj.
forpci i n we have that h l forj i and so for any of the divalues forl h is constrained to be a single value.
since h l for any of the divalues forl there are di possible values for h .
finally for j i there is no constraint on the relationship between l andh and so there are di possible values for each of them.
the combinatorial argument above can be summarized by the following system of equations qd jpcnjqd wi qdi n jpcij this system of equations can be solved for each wivia reverse substitution using the following recurrence di jpcij jpcnj qdi n once we have determined the domain sizes of the individual segments we are in a position to compute the probability any particular observation sequence.
let p !ojd be the probability of observation sequence !ogiven a vector of segment domains d. in addition we de ne d0 itobe the vector of domains constrained by pci.
that is d0 i h1 d i di d ni.
thenp !ojd can be computed recursively using the following logic base case if !o oiis a sequence of length the probability of oiis qd0 i qd that is the number of remaining possible inputs that are consistent with oi pc i out of the total number of inputs in the domain.
recursive case if !o ho1 o2 okiis a sequence of lengthkwe can think of it as o1followed by a sequence of length k .
then computing p !ojd reduces to computing the probabilities of p o1jd0 i and p ho2 okijd0 i and multiplying.
the above presented computation results in the same probabilities that are computed by a full probabilistic symbolic execution analysis of the adversary s complete attack behavior.
given the probabilities we can simply apply the entropy formula.
we have implemented both methods and experimentally veri ed that they produce the same results.
however the second method is signi cantly faster.
we discuss this in section containing our experimental results.
.
string constraints in this section we discuss our extensions to spf for string analysis and model counting.
our work is motivated by the extensive use of string manipulation in modern software applications.
some common reasons for using string manipulation are creation of documents in html or xml format runtime code generation creation of queries for backend databases validation and sanitization of user input.
in order to analyze modern software systems it is necessary to handle string constraints.
f!cj fjf fjf f c!s s jmatch s s jcontains s s jbegins s s jends s s ji iji i s!vjs js sjs sjs jreplace s s s jsubstring s i i jcharat i jtostring i i!vjn ji iji iji n jlength s jindexop s s figure string constraints we de ne the set of string constraints using the grammar shown in figure where cdenotes the basic constraints ndenotes integer values s2 denotes string values and vdenotes string and integer variables.
this constraint language can model complex string operations available in java and in many modern programming languages such as boolean matches string int indexof string int string substring int int string replace string string .
.
symbolic execution with strings we experimented with two approaches for handling of string operations in spf numeric encoding reduces string operations to numeric constraints string encoding maps string operations to string constraints.
all existing string solvers are limited in their capabilities of handling mixed integer and numeric constraints.
many of the current solutions to symbolic execution for strings support only a subset of such operations.
the approaches to model counting are even more limited.
we therefore implemented a numeric encoding approach in spf that uses the low level java implementations of the string classes and uses models only for the native calls in these methods.
this e ectively reduces all string operations to low level numeric operations over arrays of characters representing the strings .
the low level java implementations of string operations can thus be analyzed with spf and the generated numeric constraints can be handled with available solvers such as z3 .
furthermore o the shelf numeric model counting procedures for numeric constraints such as latte can be used.
this numeric encoding approach has the advantage that it is robust and general it can handle arbitrary combinations of numeric and string constraints but it can only analyze symbolic strings of xed length.
the second approach we implemented maps string operations directly to string constraints.
for this approach we built on spf s existing capabilities for symbolic execution over strings .
spf maintains an additional path condition that encodes directly operations from java string stringbuilder and stringbu er apis.
the constraints maintained by spf are built from string expressions described by the grammar in figure .
in this string encoding approach spf does not analyze the implementations of the string operations.
instead it builds string expressions based on the string operations and assumes the implementations are correct .
for example when if cmd.indexof is executed with symbolic value s1forcmd the method indexof is not actually executed inside spf but rather a symbolic string expression is created which can later appear in the symbolic string expressions and path conditions built by the analysis e.g.
symbolic constraint s1.indexof is added to the string pc.
we integrated the model counting string constraint solver abc to spf to support this string encoding approach.
.
.
automata based constraint solving automata based model counter abc is an automata based constraint solver that also supports model counting .
abc was originally developed for string constraint solving.
in this paper in order to support model counting both for numeric and string constraints and their combinations we extended abc to support numeric constraints.
below we explain how abc converts numeric and string constraints to automata.
string constraints.
given an automaton a letl a denote the set of strings accepted by a. given a constraint fand a string variable v our goal is to construct a deterministic nite automaton dfa a such thatl a jf v kwhere jf v kdenotes the set of strings for which fevaluates to true when substituted for the variable vinf.ab ab a b a b figure automata a for the string constraint x2 ab length x 1and b for the numeric constraint x y .
let us de ne an automata constructor function asuch that given a string constraint fand a variable v a f v is an automaton where l a f v jf v k. below we discuss how to implement the automata constructor function a. let us rst discuss boolean operators.
given a constraint f in order to construct a f v we can rst construct a f v and use automata complement to construct a f v wherel a f v l a f v .
for constraints in the form f1 f2andf1 f2 we can rst construct a f1 v anda f2 v .
then we can construct a f1 f2 v anda f1 f2 v using automata product where l a f1 f2 v l a f1 v l a f2 v andl a f1 f2 v l a f1 v l a f2 v .
automata constructor a c v for basic constraints ccan be implemented for each basic constraint type shown in figure as discussed in .
as an example consider the string constraintf x2 ab length x over the alphabet fa bg.
in order to construct a f x we rst constructa x2 ab x anda length x x and use automata complement and automata product operations to obtain the resulting automaton shown in figure a .
a constraint fmay have more than one variable.
in that case we use the same algorithm describe above to construct an automaton for each variable in f. if two variables appear in the same basic constraint we do a projection for each of them.
in a multi variable constraint for each variablev we would get an over approximation of the truth set a f v jf v k. we can eliminate over approximation by solving the constraint iteratively.
at each iteration we initialize eacha f v to automaton that is obtained in the previous iteration for the same v. we stop the iteration when there is no more change in any a f v .
note that using multiple variables one can specify constraints with non regular truth sets.
for example given the constraint f x y y jf x kis not a regular set so we cannot construct an automaton precisely recognizing its truth set.
in that case we put a bound on the number of iterations for constraint solver and return an over approximation of the truth set when the bound is reached.
numeric constraints.
in order to handle numeric constraints in abc we implemented the automata construction techniques for linear 199arithmetic constraints on integers .
the approach we use can handle arithmetic constraints that consist of linear equalities and inequalities and logical operations .
similar to string constraints the goal is to create an automaton that accepts solutions to the given formula.
however for numeric constraints it is necessary to keep relationships between integer variables in order to preserve precision.
for example given a numeric constraint such as x y we would like the automaton to recognize the tuples x y such that x y 2f g. if we separate the set of values for xandyand recognize the set forxand the set fory then we would get tuples such as which are not allowed by the constraint x y .
to address this we use multi track automata which is a generalization of nite state automata.
a multi track automaton accepts tuples of values by reading one symbol from each track in each transition.
i.e.
given an alphabet a k track automaton has an alphabet k. for numeric constraints we use the alphabet f0 1g.
the numeric automata accept tuples of integer values in binary form starting from the least signi cant digit.
we implement an automata constructor function afor numeric constraints such that given a numeric constraint f a f is an automaton where l a f jfk.
note that for numeric constraints a f accepts tuples of integer values one for each variable in the constraint f. each variable in fis mapped to a unique track of the multi track automaton that we construct.
the automata constructor afor numeric constraints handles the boolean operators the same way as the automata constructor for string constraints.
each basic numeric constraint is in the formpn i 1ai xi a0op0 where op2f g aidenote integer coe cients and xidenote integer variables.
the automata construction for basic numeric constraints relies on a basic binary adder state machine construction .
the state machine starts from a state labeled with the constant term a0.
it reads the rst binary digit of all the variables computes the result of the sum for the rst digit and the carry.
the next state is the state that corresponds to the new carry.
using each digit and the current carry it is possible to compute the next carry which de ne the transitions of the state machine.
accepting states are determined based on the operation op.
for example if the operation is then all the resulting digits should be equal to and the carry should also be .
so the state is accepting and all transitions that result in a non zero digit go to the sink state.
in order to handle negative values s complement representation is used.
as an example in figure b we show the multi track automaton that accepts tuples of integer values that satisfy the constraint x y the transitions are labeled with the digit for variable xon top of the digit for variable y .
.
model counting model counting for numeric path conditions using latte has been implemented in our previous work .
as model counting is expensive we perform several optimizations.
first the path condition pcis partitioned into independent components which can be solved separately pc c1 c2 cn where a variable xin a component cidoes not appear in any other component.
therefore jpcj ijcij.if a component ciis a set of linear integer constraints it is simpli ed and normalized further by using the omega library .
latte is then used on this normalized constraint to count the models of ci.
as we described above abc is an automata based constraint solver that give a constraint fconstructs an automatona f wherel a f jfk.
note that jfj jl a f j. so in order to count the number of solutions for a constraint f we need to count the number of strings accepted bya f .
counting the number of accepted strings by an automaton corresponds to counting the number of accepting paths .
for example consider the automaton for constraintf x2 ab length x shown in figure a .
in the language l a f we have zero strings of length 62l a f two strings of length fa bg three strings of length faa ba bbg and so on.
given an automaton a consider its corresponding languagel a .
letli a fw2 l a jwj ig the language of strings in l a with length i. thenl a s i 0li a .
the cardinality of l a can be computed as jl a j p i 0jli a j. note that the number of strings accepted by an automaton could be in nite in the presence of loops.
in applications of model counting such as probabilistic symbolic execution a model counting query is accompanied with a bound that limits the domain of the variable.
for string variables this is the length of the strings whereas for numeric variables it is the number of bits.
these correspond to the length of the accepted strings for our automata representation of string and numeric constraints.
computation ofjl a jwithin a bound can be done by constructing the adjacency matrix of the automaton based on its transition relation and then using matrix exponentiation to compute the number of accepting paths.
we rst add a new extra state to the automaton and connect each accepting state to this new state with transitions where is a new padding symbol that is not in the alphabet of a. the augmented dfa preserves both the language and count information of a. from this augmented dfa we construct the adjacency matrix twhere matrix entry ti jcorresponds to the number of transitions from state sito statesj.
let n denote the new state that was added.
we can compute jlm a jby computing the matrix tmby matrix exponentiation wherejlm a j tm n n .
moreover we can computep i mjli a jmy modifying the matrix tto matrix by adding a self loop to the new state that was added.
after that modi cationp i mjli a j tm n n .
note that this approach works both for numeric and string constraint automata.
hence using an automata based constraint solver provides a general approach to model counting.
.
experiments to validate the e ectiveness of our methods we rst evaluated abc by comparing it with latte.
next we compare the e ciency of using multi run vs. single run symbolic execution for computing the entropy after a sequence of observations.
lastly we have tested our side channel analysis on the password checking function described in section which is susceptible to a timing attack and a compression function which contains a side channel based on the size of the compressed output le.
password lengthtime s latte abc numeric abc string figure time comparison for computing single guess entropy using abc and latte.
.
timing performance of model counting symbolic pathfinder already contained an implementation of path constraint model counting using latte .
in addition we integrated abc in spf for counting solutions to path constraints.
our experiments show that abc and latte produce identical model counting results.
to compare running time we analyzed the password checking function.
we compare the end to end running time of performing symbolic execution collecting path constraints and performing model counting on all generated constraints in order to compute the information leakage of a single run by the adversary.
we nd that the implementation using abc is signi cantly faster than the previous implementation that uses latte.
as shown in figure for a xed alphabet size of we see that the running time increases with the password length for both abc and latte and that the abc numeric implementation is signi cantly faster with abc string second fastest and the latte implementation slowest.
however we do not claim that abc is faster than latte.
abc is implemented as a shared library in spf allowing for direct function calls to the model counter.
on the other hand in order for spf to pass constraints to latte they are rst preprocessed and simpli ed using the omega library and then saved to a set of les.
latte is then invoked on these les and the model counts are parsed back into jpf.
in order to make any claims about the relative e ciency of abc and latte we will need to do a comparison of the constraint model counting capabilities directly.
this is future work.
observation sequence lengthrunning time s single run se multi run se figure time for multi run and single run se.
the remaining experiments were conducted using abc numeric as the model counter due to the relative execution speed of the implementation within spf.
.
single and multi run symbolic execution as described in section we have given two methods for computing the entropy after the adversary makes kobservations performing symbolic execution over the k composition of the program under an adversary model section .
.
and performing symbolic execution over a single copy of theprogram and then using mathematical formula to infer the multi run entropies section .
.
we ran both analyses on the password checking example and as expected we see in figure that the multi run analysis takes much longer due to the exploration of many more paths generated by symbolic execution.
.
password checker we also present results on the timing analysis of the password checking function.
we present results only for multirun analysis using single run execution here as we have just described that it is much faster and produces the same results.
we rst describe results for a small con guration where we x the alphabet size to and the password length to .
we assume that the adversary can make kguesses and we compute the remaining entropy and the information leakage as shown in figure .
there are possible inputs forhgiving log264 bits for the initial entropy.
as the adversary makes more guesses the remaining entropy decreases from to .
indeed our analysis shows that the entropy is for k .
symmetrically we can see that the information leakage increases with more guesses from to indicating that all information about the secret is leaked after guesses.
thus we conclude that the adversary needs at most guesses to fully determine the secret.
we also analyzed a larger con guration.
for a password of length and an alphabet of size we incrementally increased the guessing budget of the adversary and determined that guesses are required to reveal bit of information.
this analysis took .
seconds.
observation sequence lengthentropy bits initial entropy leakage remaining entropy figure information leakage and remaining entropy for password checking function.
.
text concatenation and compression we further analyzed side channels that depend on the size of the output.
one example of such an attack is known as compression ratio info leak made easy crime .
the function concatsandcompress shown in figure accepts an input low which is controlled by the adversary concatenates it with a secret high value high and then uses the lempel ziv lz77 compression algorithm on the resulting string.
we do not show the code for lz77compress here as it requires approximately lines of java code.
public concatandcompress string low return lz77compress high.concat low figure a function with a size based side channel.
201the basic idea behind the attack is that if the adversary provides a value for lowthat does not have a common prex with high then there will be little compression.
however if low andhigh do share a pre x this will result in a higher compression ratio.
this is real world vulnerability that can be used to reveal secret web session tokens to a malicious user by observing compressed network packet size .
such a user is able to control input through say a web form which is later concatenated with session information and sent to the server.
for instance suppose the secret value high is the text sessionkey xb5du .
if the malicious user sets the value of low to be the text string sessionkey abcde he will observe less compression than if he sets low to be sessionkey xb5da .
in this way the attacker is able to make repeated guesses and incrementally learn more information about pre xes of the secret.
thus theconcatandcompress function acts as a segmented oracle with a side channel on the size of the output.
we apply our analysis to concatandcompress and we are able to compute the information leakage for a given budget on the number of guesses used by the adversary.
due to the complexity of the lz77 algorithm symbolic execution becomes more expensive than in the case of the password checking function.
for a secret of length and alphabet size single run symbolic execution generates path conditions leading to di erent observables.
for each observable oi we built the disjunction of all the pcs that result in oiand we used z3 to prove logical equivalence to the pc formulation in section .
.
using the single run method we then determined that the concatandcompress function leaks all information about the secret after executions by the adversary.
using abc numeric for model counting the total running time of this analysis is seconds.
we repeated this experiment using abc string as the model counter.
the same results took seconds to compute due to the complex nature of the string operations contained in the lz77 compression algorithm.
.
related work side channels attacks received signi cant attention in previous work .
kocher addresses timing attacks against cryptographic systems using statistical techniques treating the attack as a signal detection problem where the signal consists of the timing variation due to the target secret bit and noise results from measurement inaccuracies and timing variations in the unknown secret bits.
brumley and boneh further study timing attacks against openssl implementations and show how to extract private keys using similar testing techniques over multiple rounds of attacks on openssl based web servers running on a machine on a local network.
cacheaudit uses static analysis for cache side channels to derive formal quantitative security guarantees for a comprehensive set of side channel adversaries based on observing cache states traces of hits and misses and execution times.
quantitative measurement of information leakage has been an active are of research.
early work measured the number of tainted bits not an information theoretic bound.
most previous work quantify the leakage in one run of the program given a concrete value of low input.
single run analysis is addressed in where bounded model checking is used over the k composition of a program to determine if it can yield kdi erent outputs.further leakwatch estimates leakage in java program based on sampling program executions on concrete inputs.
k opf and basin present a multi run analysis based on an enumeration algorithm.
mardziel et al.
generalizes the work by considering probabilistic systems to account for secrets that change over time.
in previous work we give a formulation of multi run side channel analysis using symbolic execution and maxsmt solving.
the focus of that work is to synthesize the worst case attack for arbitrary side channels in the context of non adaptive attacks.
in contrast here we assume the worst case attack is known and it is adaptive i.e.
the attacker changes the public input based on the observations made so far.
further we give an e cient computation of leakage tailored to side channels with segment oracles for string manipulating programs.
there has been signi cant amount of work on string constraint solving however none of these solvers provide model counting functionality.
smc is the only other model counting string constraint solver that we are aware of .
abc is strictly more precise than smc.
namely smc cannot propagate string values across logical connectives which reduces its precision during model counting whereas we can handle logical connectives without losing precision.
we can also handle complex string operations such as replace that smc cannot handle.
abc builds on the automata based string analysis tool stranger determined to be the best string solver in terms of precision and e ciency in a recent empirical study .
an earlier version of abc was presented in .
in this paper we extended the functionality of abc to handle all string operations in java numeric constraints and the ability to perform model counting for numeric constraints.
further we integrated abc in spf.
.
conclusions we presented a symbolic execution approach for side channel analysis.
we illustrated our approach on side channels with segmented oracles and we gave an e cient computation of leakage over multiple attack steps.
our technique leverages satis ability checking and model counting over complex constraints involving both string and numeric operations.
in the future we plan to extend our side channel analysis with segmented oracles in the presence of noisy observations.
.