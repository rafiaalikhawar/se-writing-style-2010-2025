incrementally slicing editable submodels christopher pietsch manuel ohrndorf udo kelter software engineering group university of siegen germany fcpietsch mohrndorf kelterg informatik.uni siegen.detimo kehrer department of computer science humboldt university of berlin germany ftimo.kehrerg informatik.hu berlin.de abstract model slicers are tools which provide two services a finding parts of interest in a model and b displaying these parts somehow or extract these parts as a new autonomous model which is referred to as slice or sub model.
this paper focuses on the creation of editable slices which can be processed by model editors analysis tools model management tools etc.
slices are useful if e.g.
only a part of a large model shall be analyzed compared or processed by time consuming algorithms or if sub models shall be modified independently.
we present a new generic incremental slicer which can slice models of arbitrary type and which creates slices which are consistent in the sense that they are editable by standard editors.
it is built on top of a model differencing framework and does not require additional configuration data beyond those available in the differencing framework.
the slicer can incrementally extend or reduce an existing slice if model elements shall be added or removed even if the slice has been edited meanwhile.
we demonstrate the usefulness of our slicer in several scenarios using a large uml model.
a screencast of the demonstrated scenarios is provided at i. i ntroduction document slicers are tools which provide two services a finding interesting parts of an existing document and b displaying these parts in appropriate form or producing a new document which consists of these parts which is referred to as slice or sub document.
slicing of programs has a long tradition .
program slicers address a broad range of use cases where a program slice with certain properties is required.
they put most emphasis on service a for a given user specified slicing criterion they find related program fragments.
these slicers can be regarded as highly specialized query processors.
service b is of minor importance here.
with the advent of model based software development mbsd models rather than source code play the role of primary software artifacts.
many similar use cases as known from program slicing must be supported for model slicing.
model slicing is additionally often motivated by a different class of use cases where step b the construction of a new document is a main requirement and a big challenge.
one typical motivation are inefficient model checkers test suite generators etc.
in order to reduce run times they are applied to small slices or sub models rather than to a large complete model.
further motivations include transport of the slice and integration into other system models or independent editing of parts of a model.
these and similar motivations of model slicing are addressed by the slicer presented in this paper.from a more technical point of view producing a slice as a new model can be regarded as a function call slice aslice slice largemodel slcrit slcrit is the slicing criterion provided by the user.
internally the computation of the slice roughly proceeds as follows elementset rme select largemodel slcrit elementset extrme extend largemodel rme slice aslice createsl largemodel extrme the first task the selection determines the set rme of requested model elements more specifically the sets of nodes and edges of the abstract syntax graph of largemodel which must be present in the slice e.g.
all direct and indirect super classes of a given class x the sequence diagram named x of a system model or the set of model elements violating a given ocl inivariant.
in many cases finding these requested model elements can be expressed as a simple graph query using languages such as ocl xpath etc.
the set rme does not normally conform to the required properties of the slice e.g.
conformance to the meta model.
the second task the extension extends rme by further model elements to make it displayable and editable in standard visual editors for the given modeling language.
for example assume that rme comprises the elements of a sequence diagram of a large uml model and that label names of lifelines or messages are derived from class definitions.
then extrme must contain appropriate fragments of these class definitions.
a large number of model slicers has been developed.
most of them work only with one specific type of models notably state machines and similar types of executable models .
other supported model types include class diagrams feature models and meta models.
virtually all proposed slicers only support the selection task.
the selection function of these slicers typically exploits the semantics of the models.
this implies that these approaches cannot be transferred to model types which have different semantics or no execution semantics at all.
moreover they can only slice models with a certain degree of syntactic and semantic correctness i.e.
models which conform to all basic and many advanced but not always all constraints defined in their meta model.
the only well known more generally usable technique which also supports the second step of generating a new model .
c ieeease urbana champaign il usa tool demonstrations913 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is kompren which is actually a generator for model slicers.
a slicer generated by kompren transforms a large model into a smaller one the slice.
kompren does not provide taskspecific queries for finding interesting parts of a model based on a slicing criterion but provides only general querying facilities for models.
the user must implement the search for interesting parts and specify how to extend these parts to a valid model by using a dedicated domain specific language.
the user is responsible to guarantee that a slice exhibits all desired properties.
moreover slices are always created from scratch incrementally adapting a slice an indispensable feature for all use cases where slices are edited by developers is not supported.
in this paper we present a new generic slicer with the following novel features a it is integrated within a suite of other modeling tools which all assume a common notion of basic consistency of models which is basically given by the standard model editor.
technically we refer to this consistency level as effective meta model of the tool suite.
b our slicer guarantees that all slices produced conform to the effective meta model i.e.
they are editable with the standard model editor.
c our slicer does not need additional configuration data.
it automatically configures itself using configuration data available in our tool suite.
d technically our slicer is divided in two components a aserver which accesses the whole model and which can run on a powerful server hardware b a client which runs on a workstation maintains the slice and does not load or directly access the whole model.
e our slicer is incremental in the sense that a slice can be extended or reduced more specifically that arbitrary sets of model elements can be added to or removed from rme and the slice is automatically adapted.
this adaptation is fully automated if the slice is unchanged.
if the slice has been edited possible conflicts are resolved interactively.
ii.
p roblem motivation in this section we introduce a running example and motivate the problem of slicing editable sub models.
finally we give a formal definition of the notion of incremental slicing.
a. running example we will use the barbados car crash crisis management system bcms as our running example.
figure shows an excerpt of the whole system model describing the operations of a police and a fire department in case of a crisis situation.
the system is modeled from different viewpoints.
the class diagram models the static view of the system i.e.
its key entities and their relationships.
state machine and sequence diagrams model the dynamic view of the system i.e.
its runtime behavior.
the different diagrams are not as one might think independent in fact they depend on each other.
figure shows an excerpt of the uml meta model illustrating the interrelations fig.
.
excerpt of the system model of the bcms case study .
of the different diagrams based on the abstract syntax.
for instance a lifeline in a sequence diagram usually represents aproperty of aclass.
an operation of a class can be used as the signature of amessage s. green shaded part in figure .
analogously a callevent that is used by atrigger of atransition in a state machine diagram must refer to an operation of aclass s. red shaded part in figure .
b. extending the set rme assume a developer wants to extract a state machine or a part of it from the complete model.
in the abstract syntax graph asg of our model a state machine is basically a subtree of the containment tree which contains all states transitions etc.
of this state machine.
rme would thus be defined as the set of all asg nodes in this subtree.
if we simply copy this subtree into a new empty model then the resulting asg contains all nodes specified in rme but violates the multiplicity constraint of the reference event between trigger andcallevent because the callevent is not part of the state machine it is owned by the package but a mandatory neighbor .
callevents are typical examples of asg nodes which implement a relationship between two submodels.
they have no corresponding graphical object in the visual representation of these sub models and do not represent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
excerpt of the uml meta model.
a user level concept of the modeling language.
an average user is hardly able or willing to manually deal with these asg nodes.
without them however an asg can be considered corrupted and will not be processed by an editor or analysis tool s. section v for further scenarios .
the main aim of the extension of rme to a superset extrme is to add these technically required asg nodes.
c. incremental slicing a slice initially created for a set of requested model elements rmeoldcan turn out to be inappropriate most typically because additional model elements are desired or because the slice is still too large.
one option to get a better slice is to define a revised set rme namely rmenew to discard the old slice and to recompute the slice for rmenew.
this option does not work if the slice has been edited.
a better approach is thus to obtain a model patch which if applied to the current slice adds or removes model elements as desired.
if the slice is unchanged such a patch can be applied successfully without raising errors.
if it has been edited conflicts can occur which must be resolved appropriately.
there are two basic approaches for defining the new slice.
one approach is to use a new slicing criterion and to compute rmenewasselect largemodel slcrit new .rmeold andrmenew implicitly define the sets of additional and removable model elements addrme rmenewnrmeoldand remrme rmeoldnrmenew.
another approach is to let the user explicitly define the setsaddrme andremrme by a suitable user interface.
the resulting slice does not necessarily have a compact slicing criterion in the syntax accepted by the select function.
in both user interface designs incrementally adapting an existing slice boils down to an internal operation call aslice.incradapt addrme remrme the effect of the incradapt operation is conceptually as follows.
our current slice actually contains the elements extend rme old the new slice should contain the elements extend rme new .
the model patch which adapts the slice to rmenewmust thus effectively remove the elements removedme and add the elements addedme with removedme extend rme old nextend rme new fig.
.
added and removed model elements addedme extend rme new nextend rme old s. red and green bordered areas in figure .
note that elements in the set ret rme old extend rme new n rme new although specified as removable are retained because they are required in extend rme new s. dark gray part in figure .
iii.
b asic design decisions in this section we present basic design decisions of our approach.
we first introduce the distribution model of our tool architecture before we present the basic idea of creating a new slice and adapting an existing slice based on the principle of document patching.
a. distribution model if very large models are to be sliced for performance reasons it would be counter productive if the complete model is required to be available in the workspace or even to be loaded.
one basic design decision of our approach is therefore to separate between a client and a server s. figure which can be physically distributed over different machines.
the complete large model resides on the server typically in a centrally hosted model repository.
the slice exists in a local workspace at the client site.
complete modelslice1.
.
.
.
.
.server client fig.
.
logical separation of our model slicer into client and server parts.
b. creating a new slice a user requests the generation of a new slice sby specifying a set rme of requested model elements.
our approach is open to any method for determining this set.
our approach to construct sin the client is to a calculate a creating patch s on the server side b send it to the client and c apply it to the empty model .
the resulting slice scontains all model elements in extrme and thus the subset rme .
to that end a basic design decision is to exploit existing technologies for calculating and handling of consistencypreserving edit scripts a special form of model patches as it will be explained in more detail later.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
c. adapting an existing slice to adapt a slice s the client sends an invocation of s.incradapt addrme remrme to the server.
the server a determines the sets of elements removedme and addedme as defined in section ii c b constructs an adapting patch s s0 and c sends s s0to the client where it is applied to the current slice s which is transformed to s .
we utilize again consistency preserving edit scripts here.
by construction of our edit scripts updating an unmodified slice will never fail.
however if the slice has been edited in the client local changes can be in conflict with changes specified by the adapting patch.
this problem also occurs when local copies of models in workspaces are to be updated by changes checked in into a repository.
a solution to this problem which is based on the principle of model patching has been presented in .
this workspace update tool detects attempts to overwrite local changes and enables users to intervene and interactively handle the problem.
it can be seamlessly integrated with our approach to incremental model slicing.
iv.
i mplementation this section outlines the implementation of our approach focusing on the server side functionality for determining an extended model element set and for generating slice creating and slice adapting edit scripts.
we start by briefly recalling some basic background on consistency preserving edit scripts.
a. consistency preserving edit scripts our approach uses consistency preserving edit scripts as a special form of model patches.
an edit script m1 m obtained comparing two models m1andm2is a data structure which basically comprises a set of edit steps semiordered by an acyclic dependency graph in which the nodes are edit steps and the edges are dependencies between edit steps .
applying m1 m 2tom1yieldsm2.
an edit step is an edit operation supplied with concrete arguments.
in our approach edit operations are formally defined as in place transformation rules on the asg using the henshin model transformation language and system .
edit operations must be consistency preserving cpeos in the sense that they transform a model from one consistent state to another.
consequently an edit script based on cpeos constructs a consistent model.
each modeling language has its own set of cpeos we generate such a set from a meta model using the meta tool presented in .
the meta models we actually use reflect the actual consistency constraints enforced by the standard editor of an environment they are referred to as effective meta model.
the effective meta model differs from a perfect meta model as defined in language standards such as the uml by removing many complex constraints while all basic typing constraints and many multiplicities remain.
some multiplicity constraints may even be added .
for example the effective meta model of the uml modeling tool papyrus enforces all multiplicity constraints shown in figure .
it tightens the multiplicities for sendevent andreceiveeventto since a message must always have a send and a receive end to be graphically displayable.
due to such multiplicity constraints cpeos typically create or delete several asg nodes and related