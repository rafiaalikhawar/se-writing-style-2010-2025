inca a dsl for the definition of incremental program analyses tam s szab itemis germany delft university of technology netherlands tamas.szabo itemis.desebastian erdweg delft university of technology netherlands s.t.erdweg tudelft.nlmarkus voelter independent itemis germany voelter acm.org abstract program analyses support software developers for example through error detection code quality assurance and by enabling compiler optimizations and refactorings.
to provide real time feedback to developers within ides an analysis must run e ciently even if the analyzed code base is large.
to achieve this goal we present a domain speci c language called inca for the de nition of e cient incremental program analyses that update their result as the program changes.
inca compiles analyses into graph patterns and relies on existing incremental matching algorithms.
to scale inca analyses to large programs we describe optimizations that reduce caching and prune change propagation.
using inca we have developed incremental control ow and points to analysis for c well formedness checks for dsls and findbugs checks for java.
our evaluation demonstrates signi cant speedups for all analyses compared to their non incremental counterparts.
ccs concepts software and its engineering !automated static analysis data ow languages integrated and visual development environments keywords static analysis incremental computation domain speci c language language workbench .
introduction static program analysis is the basis of compiler optimizations and ide features such as error detection or behaviorpreserving refactorings.
program analyses trade o precision for runtime performance and memory use and there is a large body of research on techniques that enable increasingly precise and e cient analyses.
for example by giving up ow sensitivity and context sensitivity points to analysis can analyze millions of lines of java code in under a minute .
our work improves the performance of program analyses through incrementality when part of the code changes forexample through user edits we only reanalyze the changed part plus all the code whose analysis result depends on the changed results.
this way incremental program analysis can provide signi cant improvements compared to reanalyzing the whole code base from scratch.
such incremental analyses are useful in ides that perform real time analysis upon user edits and in continuous integration servers that continuously analyze an evolving code base.
we present inca a domain speci c language dsl for the de nition of e cient incremental program analyses as well as an optimizing compiler and a runtime system for inca.
conceptually inca represents computations as graph patterns on top of the abstract syntax tree ast of the analyzed program.
graph patterns express relationships between ast nodes for example to describe the control ow between individual statements of the analyzed program.
the inca compiler translates a user de ned program analysis into a set of interconnected graph patterns.
the inca runtime system maintains the analysis results incrementally by performing incremental graph pattern matching.
semantically a graph pattern describes a set of tuples that relate program entities.
however using graph patterns is di cult for many developers because instead of mapping input to output they construct tuples for related entities by splitting joining and ltering sets of tuples.
inca introduces pattern functions to abstract from graph patterns instead of operating on sets a pattern function takes a single input and either rejects it or computes a corresponding output.
this way a pattern function de nes what we call the primary linearization of the underlying graph pattern for example in the style of a forward or backward analysis.
our compiler translates pattern functions into regular graph patterns.
we have implemented inca on top of jetbrains mps 1an ide that relies on projectional editing where code changes occur in the form of user issued ast change requests.
this aligns well with incrementalization because each ast change triggers an incremental update of the analysis results.
the design and implementation of inca is independent of the analyzed language and we developed a generic architecture for the integration of inca into other ides.
to evaluate inca we implemented incremental analyses for c and java programs and measured their runtime performance.
for c we developed incremental control ow analysis ow sensitive points to analysis and domain speci c wellformedness checks.
for java we reimplemented findbugs analyses .
our evaluation shows that inca based incremental program analyses yield signi cant speedups without permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
3a 3a4213pthread mutex lock sensorlock int7temp7 7readsensor ... if7 outofrange temp 77log beyond7threshold7 d!
7temp pthread mutex unlock sensorlock figure a simple c program and its control ow introducing unacceptable memory or initialization overheads.
in summary we make the following contributions we introduce inca a language for the de nition of incremental program analyses that is independent of the analyzed language.
our compiler translates inca code into graph patterns section .
we implement compiler optimizations for inca that reduce the memory required for incrementalization and the time required for change propagation section .
we describe the runtime system of inca as a generic architecture that allows the integration of inca analyses into di erent ides.
technically the runtime system employs incremental graph pattern matching on the ast of the analyzed program section .
we develop three incremental analyses for c including an incremental ow sensitive points to analysis and reimplement findbugs analyses for java section .
we evaluate the memory and runtime performance of inca through extensive case studies on real world c and java software projects section .
we show that program analyses developed with inca provide real time feedback and scale to large code bases.
we reuse the incquery incremental evaluator in our system thus the core incremental evaluator is not our contribution.
there exist several incremental algorithms for a particular analysis and frameworks for a particular class of analyses in the literature.
in contrast to these solutions our analysis framework is not bound to a speci c class of analyses section and employs incremental graph pattern matching for program analysis as a novel approach.
.
incremental program analysis by example using control ow analysis for c as an example this section explains the problem of incremental program analysis and illustrates our solution.
control ow analysis ides and compilers use control ow analysis to reason about the execution order of statements in a program and as a building block for further analyses such as points to analysis.
the input of control ow analysis is the ast of the program and its output is a control ow graph cfg .
as an example consider the c program and its control ow in figure .
each node in the cfg represents a statement in the program.
a source statement is connected to a target statement in the cfg if there exists an execution trace in which the execution of the source statement immediately precedes the execution of the target statement.
note how control can ow from statement 3both to 3aand 4in figure depending on the condition of the ifstatement which is why the cfg contains edges from 3to3aand from 3to4.
the result of our control ow analysis is a set of cfg edges.
in this section we restrict ourselves to a subset of c with ifstatements and simple statements that entail a statement1 3a 4ifstatement3laststatementparentchild33asimplestmt1 3a 4csimplesrc2231trgcflow343a4src3trg33a221precedingstmt3beforeafter12324intcif4srctrg33a33a4figure computation graph of the cfg analysis evaluation sequential control ow such as assignments.
we de ne the relation cflow for the edges of the cfg and we compute it as the union of two helper relations.
csimple consists of those control ow edges src trg where srcis a simple statement that syntactically precedes trgin the source code.
cifconsists of control ow edges src trg that lead into or out of an ifstatement or its branches which is the case if a srcsyntactically precedes trgand srcis an if statement without an else part b srcis an ifstatement and trgis the rst statement of one of its branches or c srcis the last statement of one of the branches of an ifthat syntactically precedes trg.
in our example csimple has two elements and while cifhas three elements 3a 3a and .
the union of the two relations constitutes cflow .
evaluation with graph patterns to compute the elements of the relations csimple cif and cflow we need to traverse the ast and discover the relevant structural relations between the ast nodes and their attributes.
a natural representation of such computations is a graph pattern .
much like our informal description of the relations above a graph pattern describes sets of related entities through structural constraints on ast nodes and on instances of other graph patterns.
given a set of interconnected graph patterns we can compute their results by using a computation graph as illustrated in figure for our example.
a computation graph consists of two kinds of nodes each of which yields a set of related entities.
input nodes grey represent the ast structure directly do not perform any computation and do not depend on any other node.
in figure statement and precedingstatement are the only input nodes the former enumerates the nodes of type statement from the ast and the latter enumerates the pairs of statements where the rst statement syntactically precedes the other.
computation nodes white use the results of input nodes and other computation nodes to relate program entities.
for example node csimple uses information from node statement simplestatement and precedingstatement to identify statements related through simple control ow.
node cflow combines the results from two computation nodes to produce the complete cfg.
incremental control ow analysis we encode program analyses as graph patterns and computation graphs because this provides a good basis for incrementalizing the computation.
suppose the user modi es the analyzed program and adds an else branch 3bto the ifstatement as illustrated in 321ast of the program code 3a 3b incremental change updatestraverse a3a4213bxb c3pthread mutex lock sensorlock int7temp7 7readsensor ... if7 outofrange temp 77log beyond7threshold7 d!
7temp 7else7 77calibrate env temp ... pthread mutex unlock sensorlock 3src4343b233btrg43a3a321 4343b43aifstrg3b33a3 childparent33a33b 3a 3b 3a 3b statementifstatement3laststatementsimplestmtcsimplesrc2231trgcflowprecedingstmt3beforeafter12324ciffigure example analysis evaluation a example c program code after modi cation b cfg of the program code c computation graph for incremental evaluation figure .
this invalidates the old cfg.
using graph patterns and computation graphs instead of recomputing a new cfg from scratch we can incrementally update the existing cfg.
to this end computation graphs use memoization and perform incremental graph pattern matching when code gets changed we send change events to the input nodes of the computation graph.
the nodes then transitively propagate changes to all dependent computation nodes and trigger the reanalysis of changed program entities.
this way we avoid any reanalysis of unchanged parts of the program.
in our example the introduction of the else branch triggers the following changes in the computation graph cf.
figure addition of 3btostatement and simplestatement .
removal of from cifbecause ifstatement 3now has an else branch.
that is the conditional treatment is exhaustive and control is guaranteed to pass through one of the branches before reaching .
addition of 3b tocifbecause 3bis the rst statement of the else branch.
addition of 3b tolaststatement because 3bis the last statement of else branch of ifstatement .
addition of 3b tocifbecause 3b was added tolaststatement and 3precedes .
propagation of all changes from ciftocflow .
in our implementation based on projectional editing we receive change events for user issued ast changes directly from the ide.
fine grained ast change noti cations align perfectly with incrementalization and there is no need for a potentially costly parsing step to compute ast di erences.
after an ast change a projectional editor derives a new projection from the ast and displays it to the programmer.
a dsl for program analysis a dsl based on graph patterns is a good semantic basis for incrementally analyzing programs.
however programming with graph patterns is di cult because graph patterns operate on sets of related program entities using operations such as lter map and1 def cflow trg statement statement return csimple trg alt return cif trg def csimple trg statement simplestatement src precedingstatement trg assert src instanceof simplestatement return src def cif trg statement statement src precedingstatement trg assert src instanceof ifstatement return laststatement src alt src precedingstatement trg assert src instanceof ifstatement assert undef src.else return src alt assert undef precedingstatement trg parent trg.parent assert parent instanceof ifstatement return parent figure control ow analysis for a subset of c in inca cross product.
this is far removed from the usual way of de ning program analyses as forward or backward analyses .
additionally considerable anecdotal evidence at companies itemis and incquerylabs where developers use the incquery graph pattern language for commercial projects shows that developers would rather rely on more familiar core abstractions functions distinguishing input from output direction in the function body and assignments.
this experience was the main driver when we designed a dsl called inca which abstracts from graph patterns.
instead of operating on sets of program entities inca supports the de nition of program analyses using what we call pattern functions .
a pattern function is a linearized graph pattern it takes a single tuple of inputs and either rejects the input or produces a single tuple of outputs through a sequence of statements in the body of the pattern function.
semantically a pattern function corresponds to a graph pattern that relates the program entities that occur as either input or output.
in particular the separation of entities into input and output and the order of statements in the body of a pattern function are semantically irrelevant.
nevertheless linearization simpli es the de nition of program analyses.
since many di erent linearizations of the same graph pattern are possible we say a pattern function de nes the primary linearization of the underlying graph pattern.
we illustrate inca through the de nition of the control ow analysis for our subset of c where the linearization enables us to write the de nition in the style of a backward analysis.
figure shows the inca code that de nes the control ow analysis.
we show three pattern functions that follow the informal description of the corresponding relations above while the other helper functions are omitted.
function cflow takes a target statement trgand nds and returns the control ow predecessors of trgusing functions csimple and cif.
we write altto provide alternative results for a pattern function.
note that the functions are de ned over the mbeddr c dialect in this example.
the tight connection with the analyzed language makes it possible to use its types and language concepts in the inca code and to provide the usual 322ide features such as highlighting and proposals during the development of the analysis.
function csimple queries pattern precedingstatement fortrg.
the function can return multiple results but inca abstracts over this.
next csimple asserts that the predecessor of trgis indeed a simple statement.
if it is csimple yields this statement as a control ow predecessor.
otherwise csimple fails for trgand does not yield any output.
function cifis composed of three alternatives that compute the control ow when an ifstatement is involved.
inca provides direct access to the ast structure.
for example in the second alternative src.else represents the else branch of the if statement src.
as shown by cif inca also supports the language construct undef to ascertain that a given pattern function call does not yield any result or that an ast node is unde ned.
our compiler translates pattern functions into regular graph patterns but also analyzes the pattern functions to perform optimizations.
in particular our compiler determines which parts of an ast are irrelevant for an analysis and uses this information to prune the propagation of change noti cations and to reduce caching section .
.
incremental program analysis with inca in this section we discuss inca in greater detail.
speci cally we describe the syntax of inca and explain how we translate its syntactic constructs into graph patterns.
.
syntax of inca figure shows the syntax of inca.
we write afor a sequence ofaelements which includes the empty list.
amodule groups related pattern functions.
modules can import other modules to gain access to their public pattern functions.
functions are public by default but can be marked private to restrict their visibility to the containing module.
apattern function represents the primary linearization of a graph pattern.
a function takes a tuple of typed input parameters and either rejects the input or produces an output tuple.
a function may de ne multiple alternative linearizations for the same input.
each alternative consists of a sequence of statements ending with a return statement that de nes the output tuple.
an assignment statement binds variables to the components of a tuple.
an assertion statement aborts the computation and rejects the current input if the condition fails.
as conditions we support equality inequality ast node type membership ast node type exclusion and unde nedness testing.
anexpression can refer to a variable represent a value literal refer to a property of an ast node call another pattern function or compute the transitive closure of another pattern function.
for the transitive closure the called pattern function must take a single input and provide a single output.
the evaluation of such expressions yields all intermediate outputs but inca s syntax abstracts over this and permits the use as if there was only a single de nite output.
.
compilation to graph patterns the theory of graph patterns is well established and we de ne the semantics of inca through translation to graph patterns.
a graph pattern consists of pattern variables and constraints over these variables.
the constraints can refer to other graph patterns.
we use the following constraints module m module nimport nffg function f visdefn n t t a visibility vis private jpublic alternative a s statement s n ejassert cjreturn e condition c e eje!
ejeinstanceof tj enot instanceof tjundef e expression e njlje n jn e jn e literal l number jstring jenum jboolean type t ast node type from analyzed language name n name figure syntax of inca entity v t holds if variable vhas type t. relation l v1 v2 holds if there is an edge labeled l between variables v1and v2.
eq v1 v2 andneq v1 v2 hold if variables v1andv2 point to the same di erent element.
pc p v andnpc p v hold if the pattern paccepts rejects the tuple v. tc p v1 v2 holds if the transitive closure of the binary pattern pcontains the tuple v1 v2 .
alt p v holds if any of the patterns in paccepts the tuple v. we map inca constructs to graph pattern constraints as follows.
an inca variable becomes a pattern variable and a literal becomes a pattern variable with an eqconstraint.
a property access e.ntranslates to a constraint relation n e v where vis a fresh pattern variable that represents the result of the lookup.
a function call f e becomes a constraint pc f ev where vare fresh and represent the result of the call the notation evmeans concatenation .
for transitive closure we use the tcconstraint.
next we translate inca conditions to constraints.
equality and inequality straightforwardly translate to eqand neq constraints and node type membership test with instanceof becomes an entity constraint.
negative conditions require helper patterns and calls to them with npc.
the helper function contains an entity for a not instanceof while it contains the corresponding subpattern for the expression in case of an undef .
the function call with an undef is an exception because it is directly translated to an npc.
for statements we proceed as follows.
an assertion simply promotes the constraints of its condition.
an assignment matches up the variables on the left hand side with the variables that result from the expression on the right hand side.
we generate eqconstraints for the pairs of variables from the two sides.
to represent the output tuple of a function we use designated variables.
we handle a return statement as an assignment to these variables.
finally we collect the functions from a module and its transitively imported modules and generate graph patterns for the functions and their alternatives.
function input parameters become pattern variables viand we create designated pattern variables vofor the output tuple.
the type annotations on input and output of a function become entity constraints over vivo.
we combine the patterns pof a function s alternatives using an alternative constraint alt p vivo .
this translation process also shows the driving forces for the abstraction from graph patterns.
graph patterns are verbose because they require explicit variables for allintermediate expressions explicit entity for type constraints and helper patterns for negative conditions.
additionally they are nondirectional which is in contrast to the usual directional nature of program analyses.
323to achieve incrementality we reuse the incremental graph pattern matching implementation that is part of incquery but there are also many other alternatives for matching .
the expressive power of our program analysis language and of the core incquery engine is classi ed as fo lfp which stands for first order logic extended with the least fixed point operator.
we believe that this formalism is expressive enough for a wide variety of program analysis as we demonstrate in section .
.
compiler optimizations for inca the performance of inca depends on both the memory required for caching as well as the e ciency of change propagation in the computation graph.
in this section we describe compiler optimizations for inca that improve both of them.
our approach for performance improvement relies on the observation that the evaluation of a program analysis usually only depends on a relatively small part of an ast.
for incremental analysis this means that many ast changes do not a ect the analysis result and can be safely ignored.
we can use this observation to improve caching and change propagation.
there is no need to write a changed element to the input nodes of the computation graph if it is known to be irrelevant for the analysis.
this saves both memory and time because by discarding irrelevant input nodes we avoid subsequent change propagation in the computation graph which in turn also avoids caching of unneeded results.
to make use of this observation in practice we must be able to distinguish relevant from irrelevant changes.
to this end we have developed an analysis for inca programs that is an analysis of the program analysis code.
our analysis inspects the inca code to compute a conservative approximation of all changes that can a ect the result of the inca program.
we analyze each module of the inca program with its transitive imports separately because the inca compiler creates one computation graph for each module.
as a rst approximation of the relevant changes we can collect the declared types of all mentioned ast nodes from the functions.
for example consider again the control ow analysis in figure .
the inca code refers to ast nodes of type statement simplestatement ifstatement and elsepart via src.else .
since type statement is a supertype of the other two statement types a sound approximation is given by the set of changes that modify nodes of type statement orelsepart .
accordingly when incrementally executing the control ow analysis in the inca runtime system we can ignore changes to expressions function declarations and others.
note that the type information is not an additional assumption about the analysis it is part of the inca code.
the subtyping relationship between the ast node types is determined by the analyzed program s language.
using the declared types of ast nodes is a good starting point for optimization however it is rather imprecise.
to improve the e ectiveness of the optimization we can take type assertions instanceof into account to determine the actually relevant ast node types.
consider an excerpt of a points to analysis for c shown in figure .
function pointsto computes pairs of c variables for assignments of the form u v .
it uses function varinexpr to reject expressions that are not variables such as additions or multiplications and otherwise to extract the variable of an expression.
if we only consider the declared types and ignore type assertions we have to assume that a change to any node left globalvarref or localvarreffrom globalvar or localvarright addressofexprright.expr globalvarref or localvarrefto globalvar or localvarfigure identifying relevant ast node types in inca of type assignment var orexpression a ects the analysis result.
however we can apply the following reasoning to narrow the set of relevant changes in figure initially both variables left and right have type expression according to the properties of assignment .
the type assertion at line constrains the type of right to the more speci c type addressofexpr .
the function call in line calls varinexpr with a reference to the variable left.
function varinexpr has two alternatives the rst one restricting etoglobalvarref while the second one restricts it to localvarref .
expressions that satisfy neither restriction are rejected byvarinexpr .
so the call in line only succeeds and thus contribute to the analysis result if left is a globalvarref or a localvarref .
moreover the type of variable from must be globalvar orlocalvar .
the same reasoning applies to the function call at line forright.expr and variable to.
this reasoning shows that we only need to observe changes to statement nodes of type assignment to expression nodes of type adressofexpr globalvarref and localvarref and to variable nodes of type globalvar and localvar .
considering that for example the mbeddr dialect of c with its language extensions has more than di erent kinds of expressions our analysis can yield signi cant improvements for the memory and runtime performance of an inca analysis.
we empirically con rm this in section .
we now provide a detailed description of our interprocedural dataow analysis for inca programs traverse call chains we perform a depth rst traversal of the pattern function call graph starting at publicly visible functions.
the analysis is inter procedural that is we pass type information from the caller to the callee.
di erent call chains may result in di erent type constraints for parameters and variables thus we analyze all call chains separately.
type intersection during traversal for each alternative of a pattern function we collect the type constraints from assertions and function calls for each parameter and local variable.
an alternative can only succeed if each parameter and variable satis es all type constraints.
this corresponds to constructing the intersection of all type constraints for each parameter and variable.
324useridetransformsast changesoptimizationbased on static analysistraverseanalyzed program ast inca analysis codeincremental evaluatornavigatoranalysis resultprogram changesast changes reportrelevant ast chg.access astcomputesfigure architecture for integrating inca into ides type union a pattern function succeeds if at least one of its alternatives succeeds.
thus it is su cient if the parameters satisfy the type constraints of at least one alternative.
we approximate this by constructing the union of the type constraints for parameters and variables from all alternatives.
optimization the analysis result is the union of the type constraints for the di erent call chains.
only changes that a ect nodes of these types can a ect the analysis result.
we prune the propagation of irrelevant changes thus avoiding the computation and caching of irrelevant pattern matches.
as opposed to using a library for program analysis an advantage of specifying the program analysis as dsl code is that the analysis itself becomes analyzable which enables our optimization.
additionally our optimization is generic as it is not bound to the inca dsl for example it could be applied on the graph patterns as well.
.
technical realization and ide integration we elaborate on the architecture of inca s runtime system identifying components that enable integration of incremental program analyses into ides and explain their interactions.
.
overview figure shows the architecture for integrating inca into an ide.
the analysis code is an inca program that runs on the analyzed program.
as detailed in section .
our architecture requires that the ide translates user edits into ast change noti cations which trigger the incremental analysis.
the navigator is the entry point of the incremental analysis.
as an adapter between the ide and the incremental evaluator it gets noti ed about ast changes by the ide.
it also allows the evaluator to traverse the input ast during initialization of the computation graph.
later when the navigator receives an ast change noti cation it noti es the incremental evaluator about relevant ast changes as determined by our compiler optimization section .
since the navigator knows the ide internal ast representation it constitutes a language independent but ide speci c component.
the incremental evaluator is responsible for the incremental maintenance of the analysis results.
the component is independent of the ide and of the analyzed language.
the evaluator uses the navigator to navigate in the ast and to receive noti cations about ast changes this way the evaluator does not depend on the internals of the ide.
the incrementally maintained results of a program analysis can be used to inform the user about new errors or as part of a refactoring in the ide.
this connection closes the loop between the user and our system and shows how incremental analysis supports interactive development.
.
implementation for mps we instantiated the architecture for the meta programming system mps using incquery as the incremental evaluator.
both tools are available as open source software as is our implementation.
mps is an ide that uses projectional editing instead of a parser based approach.
when editing the program in a projectional editor every user edit for example inserting an operator directly corresponds to an ast change.
after an ast change a projectional editor renders new projection from the changed ast based on projection rules of the ast nodes and displays it to the programmer.
projectional editing is well suited for incremental program analysis because the user s edits directly correspond to incremental ast changes and no incremental parsing is necessary.
our system reuses the incremental graph pattern matching component of incquery.
this component realizes the computation graph presented in section .
the component expects the graph patterns to be speci ed using the java api psystem.3we implemented the inca compiler to translate graph patterns into a psystem speci cation.
after startup incquery uses the navigator to initialize its computation graph and to retrieve ast changes.
.
applicability in other ides the applicability of our solution is ultimately determined by the granularity of an ide s incremental change noti cations as the analyzed program changes.
we see three kinds of ides where our solution can be applied e ciently.
projectional ides like mps where code manipulations directly correspond to incremental ast change events.
graphical ides which like projectional ides also directly manipulate structures and can thus easily derive ast changes after a change.
finally textual ides that are backed by an incremental parser cf.
for example incremental parsers and the eco language workbench which relies on an incremental parser .
in this case the degree of incrementality that our approach can achieve depends on the granularity of the incremental ast di erences the parser can provide.
.
case studies to validate our approach we have used inca to implement three program analyses for mbeddr c and one program analysis for java.
mbeddr c is an extensible c dialect and ide for embedded software built on top of mps.
this section describes the program analyses and gives details about their implementation while section contains the performance evaluation.
we show only the most interesting parts of the implementations the full implementation is available online.
.
control flow analysis the introductory example in section already gave an intuition about control ow analysis.
the incremental construction of a control ow graph cfg is an important building block for incremental ow sensitive analyses such as the ow sensitive points to analysis described next.
these two analyses combined enable further precise analyses such as uninitialized read and unused assignment analysis.
we implemented an incremental control ow analysis that handles all of mbeddr c including conditionals if developerdocumentation psystem 325u vu vu xu vy vx vu xu v x yu vx y x u y v figure andersen s rules for points to analysis and switch loops for while and do while and jumps break andcontinue .
the implementation follows the style of the introductory example extending the cflow relation with further alternatives to handle all control statements.
the complete control ow analysis produces a cfg where the nodes not only represent statements of the program but also other control ow points like the alternative case branches of a switch statement or the else if parts of an ifstatement.
to this end we de ned an interface icfgnode as supertype for all nodes that can appear in the cfg.
we use this type in the points to analysis as well.
.
points to analysis our second case study is a points to analysis for mbeddr c. given a variable that stores a pointer the goal of a points to analysis is to identify the possible targets of the variable.
there is a vast amount of research in this area because the precision of points to analysis directly bene ts optimizations such as lock elision in a concurrent system and program analyses such as uninitialized read analysis.
we represent the result of a points to analysis as a relation pointsto from to which consists of those tuples where both from and toare variables and from potentially points totoat runtime.
a points to analysis is sound if pointsto is a conservative approximation of the actual targets of the variables.
a well known algorithm for computing the pointsto relation is andersen s algorithm .
it considers four basic kinds of assignments as shown in figure and derives the points to relation for the whole program from them.
our points to analysis in inca builds on andersen s rules but extends them in three ways.
first by implementing the analysis in inca we immediately improve the run time after code changes through incrementality.
second we add ow sensitivity by building on top of our incremental control ow analysis.
third we do not require the code to only use the four kinds of assignments in andersen s rules rather support all of mbeddr c except pointer arithmetics.
figure shows an excerpt of the points to analysis in inca.
we use three main pattern functions for ow sensitive points to analysis.
function pointstobefore n u computes the potential targets of variable ubefore the execution of node nof the cfg.
we compute pointstobefore by promoting the bindings of pointstoafter along the control ow graph.
function pointstoat n computes the e ect of node nin the form of changed bindings x y .
we describe function pointstoat in greater detail below.
function pointstoafter n u yields the potential targets of variable uafter the execution of node n. if there is no new binding at all at node n rst alternative or the new binding has no e ect on variable u second alternative pointstoafter retains the targets described by pointstobefore .
otherwise if node na ects variable u third alternative pointstoafter yields the new targets of u. a single cfg node can contain multiple assignments due to expression nesting as in x u y v .
function pointstoat n gathers all assignments that occur in node nand computes the corresponding points to tuples.
given an assignment we can extract the pointer variable ufrom the assignment s left hand side expression and the pointed to variable vfrom the right with andersen s rules.
however def pointstobefore n icfgnode u var var pred cflow n return pointstoafter pred u def pointstoafter n icfgnode u var var assert undef pointstoat n return pointstobefore n u alt x y pointstoat n assert x !
u return pointstobefore n u alt x y pointstoat n assert x u return y def pointstoat n icfgnode var var lhs rhs assignmentat n u varinexprleft lhs v varinexprright rhs return u v figure flow sensitive points to analysis in inca def varinexprleft lhs expression var return varinexpr lhs alt assert lhs instanceof derefexpr e lhs.expression u varinexprleft e n ancestorcfgnode lhs v pointstobefore n u return v def varinexprright rhs expression var assert rhs instanceof addressofexpr e rhs.expression return varinexpr e alt u varinexpr rhs n ancestorcfgnode rhs v pointstobefore n u return v alt assert rhs instanceof derefexpr e rhs.expression u varinexprright e n ancestorcfgnode rhs v pointstobefore n u return v figure extracting points to variables in inca depending on the side of the assignment the computation is di erent.
pointstoat calls varinexprleft to look up the pointer variable and varinexprright to obtain the pointedto variable and returns them as a new points to tuple.
function varinexprleft in figure computes the pointer variable of an assignment s left hand side expression.
if the expression is a plain variable reference function varinexpr from figure extracts the variable.
otherwise based on the fourth andersen rule figure a pointer dereferencing e requires the lookup of the points to targets of e. function varinexprleft calls itself recursively on eto handle multiple dereferencings e until nally reaching a plain variable.
we look up the points to targets of the dereferenced variable uby calling pointstobefore using ancestorcfgnode to retrieve the surrounding cfg node.
function varinexprright implements three alternatives corresponding to the rst three andersen rules in order .
the implementation for deref3261 def ci confused inheritance c class void assert c.isfinal true member c.member assert member instanceof field assert member.visibility instanceof protected figure findbugs ci confused inheritance in inca erencing second alternative is identical to varinexprleft and the other two alternatives are straightforward.
.
well formedness checks for mbeddr c we implemented four well formedness checks for mbeddr c and its language extensions.
while the control ow analysis and the points to analysis inspected each function declarations in separation our well formedness checks require global knowledge about the source code.
this case study shows that inca scales to support whole program analyses.
the checks are as follows cycle mbeddr c provides modules for organizing code.
this check detects cyclic module dependencies.
global this check detects con icting global variables with the same name across modules.
rec this check detects recursive functions by construction and inspection of a call graph.
in embedded systems with constrained memory the stack space required for recursive functions is often unacceptable.
comp mbeddr c supports interfaces and composable components.
this check detects components that fail to implement all functions declared by their interfaces.
.
findbugs for java findbugs is a suite of prede ned patterns to detect potential bugs in java code.
to show that our system is independent of the analyzed language we implemented findbugs analyses in inca for mps java dialect.
apart from a few language extensions this java language is identical to the original java language.
as an example we show the implementation of the ci confused inheritance rule in figure .
it detects final classes that have at least one protected eld.
since the class is nal it cannot be subclassed and the eld should be private or public.
the implementation runs incrementally thanks to inca.
.
performance evaluation in this section we present the performance evaluation of our system for the case studies introduced in section .
we answer the following questions q1 run time how does the run time of inca program analyses compare to their non incremental counterpart?
q2 memory how does the memory requirement of inca analyses compare to their non incremental counterpart?
q3 optimization impact how does our optimization section a ect the run time and memory requirements?
.
evaluation setup for each case study we start with an initial code base introduced below .
after the initial non incremental run of the analysis we programmatically make updates of the code base and run the analysis after each update.
each update consists of to random code changes such as duplicating a statement deleting a function renaming a variable or in troducing a new import.
this approach allows us to imitate how a user would modify the source code.
we measure the wall clock time of processing the initial code and of processing each update step.
for the memory measurement we call the garbage collector after each analysis run and measure the required heap memory.
we subtract the heap memory used before running the rst analysis to obtain the memory usage of our system.
we repeat each measurement ve times and discard the results of the rst and second run to account for java vm warm up.
as the rst benchmark we run the control ow and pointsto analysis on the toyota itc code4 a collection of c code snippets with intentional bugs to test the precision of static analysis tools.
the code base comprises about lines of c code.
we compare the performance of the incremental analyses to a non incremental ow sensitive points to analyses that was already available in mbeddr.
the two analyses produce exactly the same results on the benchmark.
the second benchmark was running the well formedness checks on a commercial smart meter software implemented in mbeddr c .
a smart meter is an electric meter that continuously records the consumption of electrical power calculates derived quantities and sends the data back to the utility provider for monitoring and billing.
the whole project comprises about lines of mbeddr c code.
for comparison we implemented non incremental well formedness checks in mps java that produce exactly the same results.
running the findbugs checks consituted the third benchmark we ran it on the java implementation of the mbeddr importer which is responsible for migrating legacy c code to mbeddr c. the importer comprises about lines of mps java code.
because of the mps java code base we would need to generate textualized java code after every code change to be able to use the original findbugs tool.
for our large code base this is impractical and thus for this benchmark we do not have a non incremental counterpart.
we ran the benchmarks on a bit osx .
.
machine with an intel core i7 .
ghz processor and gb of ram using mps version .
and java .
.
.
the raw data and the sequence of code changes are available online.
.
run time measurements q1 q3 figure a c show the results of our run time measurements.
for points to analysis and well formedness checks we show the results of the incremental and non incremental solutions using a logarithmic scale for findbugs we only show the incremental results on a linear scale.
box plots a and b immediately show that incremental program analyses in inca perform signi cantly better than non incremental analyses.
box plots a c also show that the optimization has a signi cant impact on the run time.
the following table summarizes the median run time data non inc. inc w o opt inc w opt init update init update points to a 8s 6s 2ms 6s 3ms w. form.
b 209ms 1s 8ms 2s 8ms findbugs c n a 5s 2ms 3s 7ms the initialization times especially for the optimized versions do not pose an unduly run time requirement considering that non inc inc w o opt inc w opt10 re analysis time ms log scale a points to run times non inc inc w o opt inc w opt1 re analysis time ms log scale b well formedness run times inc w o opt inc w opt0 re analysis time ms c findbugs run times of affected ast nodesreanalysis time ms g points to reanalysis times inc w o opt inc w opt230 290memory req.
mb d points to memory req.
inc w o opt inc w opt40 180memory req.
mb e well formedness memory req.
inc w o opt inc w opt90 130memory req.
mb f findbugs memory req.
of affected ast nodesreanalysis time ms h well formedness reanalysis timesfigure run time and memory measurements for the case studies loading large programs into mps also takes a few seconds.
after initialization incremental analysis without optimization achieves speedups of a 70x and b 2x compared to nonincremental analysis.
with optimization we even achieve speedups of a 249x and b 16x.
indeed the optimization accounts for an additional speedup of 10x for initialization and of 8x for change processing time.
inca and its optimization provide good runtime performance across analyses and for both analyzed languages.
figure g and h show the points to and well formedness analysis times as a function of the input change size the number of deleted or added ast nodes .
inca scales well because the plots remain roughly linear with increasing input change sizes.
we conclude q1 incremental program analysis with inca provides signi cant speedups of up to 249x compared to nonincremental analysis.
the analyses scale linearly with increasing input change sizes.
q3 the inca compiler optimization improves initialization time by 10x and change processing time by 8x.
.
memory measurements q2 q3 figure d f show the results of our memory measurements.
we measured the memory required by incrementality for each of the update steps and created the box plots from this data.
we summarize the median memory requirements in the following table inc w o opt inc w opt points to d 273mb 242mb well form.
e 163mb 50mb findbugs f 124mb 100mb the points to analysis is the most complex case study and it has the biggest memory requirement because its computation graph caches major part of the input ast to compute a complete cfg and to handle a large variety of assignments including nested ones.
the optimization helps to reduce the memory requirement with a b and c .
based on our experience with real world usage of mps the ide typically requires about 2gb of memory.
this meansthat the optimized analyses have a memory overhead of a b and c relative to mps.
we conclude q2 for real world scenarios incremental program analysis with inca requires an acceptable amount of additional memory for our most complex case study.
q3 the inca compiler optimization reduces the required memory by .
.
related work improving the performance of program analyses has attracted a lot of research because of their widespread use in compilers and ides.
in particular the use of incrementality to speed up program analyses has a long tradition.
specialized algorithms while we present a framework for incremental program analyses the manual enhancement ofspeci c program analyses to support incrementality is also subject to research.
yur et al.
propose an algorithm for incremental ow sensitive and context sensitive points to analysis .
the paper assumes that the cfg is maintained incrementally.
this in itself is a challenging problem which we address as part of our work.
saha and ramakrishnan propose an incremental ow insensitive points to analysis for a subset of c using logic programming .
lu et al.
present a context sensitive and eld sensitive points to analysis for java based on context free language reachability .
all of these approaches target only a particular analysis e.g.
points to analysis .
there are also many algorithms tailored speci cally to incrementally handle a class of analyses e.g.
dataow analyses .
inca goes one step further than those because it supports a wider spectrum of analyses dataow syntactic analyses such as well formedness findbugs as a language agnostic framework.
the previously mentioned algorithms come with their own incrementalization engine that could play the role of the incremental evaluator in our architecture although limiting expressivity to a particular class of analyses .
once embedded into our architecture their e ciency could be improved with our optimizations.
analysis frameworks several systems in model driven development incrementally reapply consistency rules on mod328els .
these systems are only incremental in the sense that they selectively reapply a ected consistency rules after a change once selected the rules run non incrementally on the whole input.
this form of incrementalization is not practical for complex program analyses or for large inputs.
in contrast our system incrementally reanalyzes only those program entities that are actually a ected by a change.
emf incquery is a framework for incremental queries over emf models .
like inca it is based on the incquery evaluator.
we have generalized emf incquery in several ways.
first we have designed the inca dsl for the description of program analyses that abstracts from graph patterns and supports more conventional descriptions as forward or backward analyses.
second we extended our runtime system with the dataow analysis based optimization whereas emf incquery requires manual registration of relevant parts of the metamodel.
third we describe an architecture that supports the integration with ides other than eclipse.
finally the focus of emf incquery is e cient model queries while we show that graph patterns can be used to implement program analyses that scale to real world programs.
wachsmuth et al.
introduce a language independent task engine for incremental name and type analysis in the spoofax language workbench .
evaluation starts by collecting analysis tasks which are executed in a second step.
when the analyzed program changes the task engine recollects analysis tasks and executes only the a ected ones.
inca in contrast is not limited to name or type analysis but supports a wider range of analyses.
arzt and bodden present an extension of the ifds framework that selectively re derives changed parts of a program s dataow graph upon program manipulation enabling incremental dataow analysis.
the ifds framework reduces dataow problems into a graph reachability problem and associates semantic information to program nodes whereas inca relates program nodes.
there are analyses e.g.
pointsto that can be cast as both but there are certain analyses that are not supported by either one of the frameworks.
for example inca cannot handle analyses that require the generation of runtime data e.g.
an interval for an interval analysis while ifds cannot handle the more syntactic analyses e.g.
well formedness or findbugs .
supporting semantic analyses in inca would require inca extensions to generate and incrementally maintain runtime data that is not in the ast.
however this is non trivial because such an extension must consider the trade o between the expressive power needed for computing derived data and the feasibility of incrementalizing these computations.
we investigate this direction in future work.
datalog based analyses the inca runtime system translates analysis code into graph patterns and we showed that the solution can scale to real world programs.
datalog a logic programming language used in deductive databases is often used as a de nition language of program analyses .
in fact incquery s graph patterns and datalog with strati ed negation and recursion share the same expressive power .
this suggests that datalog could replace incquery as the target language for inca and a corresponding incremental datalog backend could be used as the evaluator in our system.
however to the best of our knowledge there is only the commercial logicblox backend which employs incrementalization.
from the literature it is clear that logicblox scales to large inputs for from scratchanalyses but the performance of the incremental part is not documented.
while there are specialized algorithms for incrementalizing datalog queries we emphasise that our contributions build around an o the shelf evaluator.
also abstracting from the relational nature of datalog with inca helps language developers to deal with abstractions that they are usually already familiar with such as functions direction from input to output and assignments.
this is important because for dsls it is often infeasible to spend large efforts on program analyses a straightforward implementation approach is crucial.
the doop framework uses datalog and logicblox to de ne various ow insensitive points to analyses for java.
the authors of doop pose the question whether a high level language can be expressive enough to implement various program analyses.
they show that datalog is well suited for java points to analyses.
however our work shows that a high level language which can itself be analyzed is also useful for other kinds of syntactic analyses in a languageagnostic way.
we will experiment with extensions of inca for generating runtime data which would further extend the kinds of analyses that inca could support.
general purpose incrementalization i3ql makes incremental computations available as an embedded scala dsl using an sql like syntax.
its runtime system builds on relational algebra and applies optimizations known from database engines but unlike inca it does not detect and lter irrelevant program changes.
adapton is an mlstyle general purpose language for incremental self adjusting computations.
the runtime system of adapton tracks memory dependencies in order to retrigger computations when a change to a data structure occurs.
compared to our evaluation these tools were tested only on small programs with simple analyses and it is thus unclear whether they can scale to support complex program analysis of large code bases.
analysis dsls other researchers have proposed dsls for speci c program analyses but in contrast to inca do not provide incrementalization.
examples include the declarative dsl for cfg construction in the jastadd compiler the dataow rules of dcflow fact extraction with defacto and mps dsl for constructing dataow graphs.
.
conclusions we presented inca a dsl for the de nition and e cient evaluation of incremental program analyses in ides.
inca provides a declarative notation for analyses in the style of pattern functions that our optimizing compiler translates into graph patterns.
we demonstrated the applicability of inca by developing incremental program analyses for c and java.
our performance evaluation shows that inca provides signi cant speedups compared to non incremental analyses and acceptable memory overhead.
we plan to use inca in the future to enforce secure coding standards e.g.
misra cert in mbeddr.
these standards de ne well formedness rules which inca can check incrementally as the program is edited.
.
acknowledgement the authors would like to thank daco harkes johannes lerch and the members of the emf incquery team for feedback and useful discussions on this work.
this work was supported in part by oracle labs.
.