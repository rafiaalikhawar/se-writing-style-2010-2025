arxiv .03280v1 jul 2018adversarial symbolicexecutionfordetecting concurrency relatedcache timingleaks shengjianguo virginia tech blacksburg va usamengwu virginia tech blacksburg va usachaowang university of southern california losangeles ca usa abstract thetiming characteristicsofcache ahigh speedstorageb etween the fast cpu and the slow memory may reveal sensitive inform ation of a program thus allowing an adversary to conduct side channel attacks.
existing methods for detecting timing lea ks either ignore cache all together or focus only on passive leaks generated by the program itself without considering leaks tha t are madepossiblebyconcurrentlyrunningsomeotherthreads.i nthis work we show that timing leak freedom is not a compositional property a program that is not leaky when running alone may become leaky when interleaved with other threads.
thus we d evelop a new method named adversarial symbolic execution to detectsuchleaks.itsystematicallyexploresboththefeasib leprogram paths andtheir interleavings whilemodelingthecache and leverages an smt solver to decide if there are timing leaks.
we have implementedourmethodinllvmandevaluateditonasetofrea lworldcipherswith14 455linesofccodeintotal.ourexperi ments demonstrateboththeefficiencyofourmethodanditseffective ness in detectingside channel leaks.
ccs concepts security and privacy cryptanalysis and other attacks software and its engineering software verification and validation keywords side channel attack concurrency cache timing symboli c execution introduction side channel attacks are security attacks where an adversa ry exploits the dependency between sensitive data and non funct ional propertiesofaprogramsuchastheexecutiontime power consumption heat sound andelectromagnetic radiation .fortiming sidechannels inparticular thereare two mainsourcesofleaks variancesinthenumberofexecutedin structionsandvariancesinthecachebehavior.instruction ind ucedleaks are caused by differences in the number and type of instructio ns executedalongdifferent paths unless thedifferences are in dependent of the sensitive data they may be exploited by an advers ary.
cache induced leaks are caused by differences in the number o f cache hits and misses along different paths.
existingmethodsfordetectingtimingleaksorprovingthei rabsenceoftenignorethecachealltogetherwhilefocusingoni nstructioninduced leaks.
forexample chen etal.
used cartesianhoare logic toprovethetimingleakofaprogramiswithinabound antonopoulos et al.
used a similar technique that partitions .programp threadt2 concurrent programp programp threadt1 symbolic execution adversarial cache modelingsmt solving cache configurationcache timing leakageadversarial thread schedule figure1 flow of our cachetimingleakdetector s y.sc m.scsc.
the set of program paths in a way that if individual partitio ns areproved tobetimingattack resilient theentire program is also timing attack resilient.
unfortunately these methods ign ore the cache timingcharacteristics.evenfortechniquesthatco nsiderthe cache their focus has been on leaks manifested by the program itself when running alone without con sidering the cases when it is executed concurrently with some ot her benign oradversarial threads.
in this work we show side channel leak freedom as a security property is not compositional.that is a leak free progra m when running alonemaystillbeleaky whenit is interleaved witho ther threads provided that they share the memory subsystem.
thi s is the case even if all paths in the program have the same number and type of instructions and thus do not have instruction induced timing leaks at all.
unfortunately no existing method or to ol is capableof detectingsuch timingleaks.
we propose a new method named adversarial symbolic execution to detect such concurrency related timing leaks.
specific ally givenaprogramwhereonethreadconductsasecurity critic alcomputation e.g.
by calling functions in a cryptographic lib rary and another thread is either accidentallyorintentionally a dversarial our method systematically explores both paths in these thre ads and their interleavings.
the explorationis symbolic in tha t it covers feasible paths under all input values.
during the symbol ic execution we aim toanalyze thecache behavior relatedtosens itive datatodetecttiming leaks causedbytheinterleaving.
figure1showstheflowofourleakdetectornamed s y.sc m.scsc which takes the victim thread p a potentially adversarial thread p and the cache configuration as input.
if p is not given s y.sc m.scsccreates it automatically.
while symbolically executing the pr ogram s y.sc m.scscexploresallthreadpathsandsearchesforanadversarialin terleavingofthesepathsthatexposesdivergentcachebeha viorsin p.therearetwomaintechnicalchallenges.thefirstoneisass ociatedwithsystematicexplorationoftheinterleavedexecut ionsofa concurrentprogramsoasnottomissanyadversarialinterle aving.
the second one is associated with modeling the cache accurat ely whilereducingthecomputationalcost.
shengjian guo meng wu andchaowang toaddressthefirstchallenge wedevelopedanewalgorithmf or adversarially exploring the interleaved executions while mitigating thepath and interleavingexplosions .
specifically cache timing behaviorconstraints whichareconstructed onthefly duringsymbolicexecution areleveragedtopruneinterleavingsredu ndantfor detectingleaks and thusspeeduptheexploration.
to address the second challenge we developed a technique fo r modeling the cache behavior of a program based on the cache s typeandconfiguration aswellasoptimizationsofthesubse quent constraint solvingtoreduceoverhead.
foreach concurrent execution an interleaving of the threads denoted in sch where inis the sensitive data input and schis the interleaving schedule we construct a logical constraint t in sch for every potentially adversarial memory access t to indicate when it leads to a cache hit.then weseek twodistinctvaluesofthedatainput inandin for which the cache behaves differently t in sch nequal t in sch meaning one of them is a hit but the other is a miss and they are duetodifferences inthesensitive data input.
we have implemented our method in a software tool based on llvm and the klee symbolic virtual machine and evaluateditontwentybenchmarkprograms.thesesecurity criti calprogramsarecipherstakenfromcryptographiclibrariesinthe public domain they have lines of c codein total.since these programs are crafted by domain experts they do not have obvious timing leaks when running alone such as unbalanced branchi ng statementsorvariancesinlookup tableaccesses.however ourexperimentsofapplying s y.sc m.scscshowthattheymaystillhavetiming leaks whenbeing executedconcurrentlywith otherthreads.
to summarize wemake thefollowingcontributions weproposean adversarial symbolicexecution methodcapableofdetectingcachetimingleaksinasecurity criticalp rogram whenit runs concurrentlywithother threads.
we implement and evaluate our method on real world cipherprogramstodemonstrateitseffectiveness indetecting concurrency related timingleaks.
in the remainder of this paper we first motivate our work using several examples in section 2and then provide the technical backgroundinsection .wepresentourdetailedalgorithmsinsections4and5 whicharefollowedbydomain specificoptimizations insection 6toreducethecomputationaloverhead.wepresentour experimental results in section 7and review the related work in section8.finally wegive ourconclusions insection .
motivation inthissection weuseexamples toexplainthedifference bet ween self leaking and concurrency induced leaking.
.
a self leakingprogramand therepair figure2 a shows a program whose execution time is dependent of the sensitive variable k. it is a revised version of the running exampleusedin forwhichtheauthorsproposedtheleak free versionshowninfigure b .thetwoprogramshavethesameset ofinstructionsbutdifferinwherethehighlighted loadinstruction is located line 5in pand line9 in pr.
consider executing the two programs under a byte direct mapped cache with one byte per cache line as shown in figure .
thechoiceofone byte per cache line sameasin ismeant k is sensitive input char p unsigned char k char q load reg1 p if k load reg2 q else load reg2 q add reg1 reg2 store reg1 p k miss miss miss k miss miss hit a theleakyprogram p k is sensitive input char p unsigned char k char q if k load reg2 q else load reg2 q load reg1 p add reg1 reg2 store reg1 p k miss miss hit b theleak freeversion pr figure2 a program with cache timingleak cf.
.
q ......q q kp ......p p q bytes bytes figure3 thedirect mappedcache layout cf.
.
tosimplifyanalysiswithoutlossofgenerality.specifical ly the256bytearray pisassociatedwiththefirst256cachelines whilevariablekis associated with the th cache line.
due to the finite cachesize q has toshare thecache linewith p .
thereare twoprogram paths in p each withthree memoryaccesses load line load line or line and store line .
however depending on the value of k these three memory accesses may exhibit different cache behaviors thus causing d atadependent timing variance.
assume that k s value is executing pmeans taking the then branch and accessing p q andp .
the first access to p isacoldmisssincethecacheisemptyatthemoment.theaccess toq is a conflict miss becausethe cacheline shared by q andp is occupied by p as a result q evicts p .
the next access to p is also a conflict miss since the cache line is occupied by q .
all in all the cache behavior is miss miss miss fork .
thissequenceisalsouniqueinthatallothervalues of kwould produce miss miss hit as shown at the bottom of figure a .
thismeans p whenrunningalone leaksinformationabout k.for example uponobserving the delay caused by miss miss miss via monitoring anadversary mayinfer that k s valueis .
program pris a repaired version where the loadis moved fromline5toline9asinfigure b .thus the loadaccessing p atline9alwaysgenerates acoldmiss k oraconflictmiss k .
consequently the storeatline11isalways ahit.thus for allvaluesof k thecachebehaviorremains miss miss hit no informationof kis leaked.
.
new leak induced by concurrency although prisavalidrepairwhentheprogramisexecutedsequentially thesituationchanges whenitisexecutedconcurren tlywith char p unsigned char k char q if k load reg2 q else load reg2 q load reg1 p add reg1 reg2 store reg1 p unsigned char tmp load reg3 tmp ... figure4 concurrentprogram with side channelleak.
q ......q q kp ......p tmpp q p p q t1 tmpt2 figure5 interleaving andthecache layout.
other threads.
specifically if we use one thread t1 to execute pr while allowing a second thread t2 to run concurrently prmay exhibit new timingleaks.
figure4shows a two threaded program comprising t1and an adversarial t2that accesses a new variable tmp.
assume tmpis mapped to the same cache line as p .
then it is possible for t2tocauset1toleak informationof itssecret data.thereare various ways of mapping tmpto the same cache line as p e.g.
by dynamically allocating the memory used by tmpor invoking a recursive ornon recursive functionwithinwhich tmpisdefinedas a stack variable.
table1shows the six interleavings of threads t1andt2.
the lefthalfofthistablecontainsthreeinterleavingswhere t1tookthe thenbranchoftheif statement whiletherighthalfcontainsth ree interleavingswhere t1tooktheelsebranch.ineachcase thefour columns show the id the execution order the cache sequence of threadt1 andthevaluerangeof k.forexample in the storeat line is a cache hit because its immediate predecessor line already loads p into the cache.
since the last loadat line13comesfromthread t2 thecachebehaviorsequenceof t1is miss miss hit denoted m m h forbrevity.
table interleavingsandthread t1 s cachesequences.
id interleaving cache seq kid interleaving cache seq k m m h m m h m m h m m h m m h m m h m m m although context switches between the threads t1andt2may occur at any time in practice for the purpose of analyzing ca che timingleaks weassumetheyoccuronlybeforethe loadandstore statements.furthermore weonlyfocusonthesememoryacce sses when they are mapped to the same cache line e.g.
between the loadint2and statements that access p int1.we use figure 5to show details of .
the blue and orange rectangles represent the loadandstoreaccesses respectively and the red dashed poly line shows their execution o rder.
the first three loadoperations all cause cache misses whereas the laststorecould be a cache hit if k!
and a cache miss if k .
when k the four memory accesses would be q p tmp andp .
the first two trigger cold misses.
the third one tmp triggersaconflictmissasthecachelinewasoccupiedby p .
evicting this cache line would then lead to another conflict miss forthesubsequent storetop .
theexamplespresentedsofarshowthat evenforatiming le akfreeprogram t1 runningitconcurrentlywithanotherthread t2 maycauseittoexhibitnewtimingleaks.thisisthecaseeven ifthe twothreads t1andt2 arelogicallyindependent ofeachother.in other words they do not need to share variables or communica te through messages they can affect each other s timing behavi ors bysharing thesamecachesystem.
.
adversarial symbolicexecution thegoalofdeveloping anew symbolicexecutionmethodistod etect such timing leaks.
more specifically we are concerned w ith two application scenarios for s y.sc m.scsc depending on whether the adversarial thread t2 exists in thegiven program ornot.
case .
thread t2is given together with fixed addresses of the memoryregionaccessed by t2.inthis case t2isanintegral partof theconcurrentsystemthatalsocontainsthesecurity crit icalcomputationin t1.
since theonly source of nondeterminism is thread interleaving ourtoolaimstocheckiftheconcurrentsyste mitself has timingleaks.
case .
thread t2is not given but created by our tool and thus the addresses of the memory region accessed by t2are assumed to be symbolic.
this is when inside the cache layout of figure the address of tmpwould be made symbolic thus allowing it to be mapped to any cache line as opposedto be fixed to the 2nd line .
there are now two sources of non determinism thread interl eavingandmemorylayout.ourtoolexploresbothtocheckif t1may leak informationduetointerference from t2.
in the second case when t2executes a memory load instructiont for example the symbolic address addrmay be mapped to any cache line.
the purpose of having such aggressive advers arial addressing is to allow s y.sc m.scscto conduct a predictive what if analysis itsearches allpotentialmemorylayoutstocheck ifthere exists onethatallows t2tocausea timingleak.
the threat model we now review the technical background and present the threa t model which defines whatan adversary canorcannot do.
.
cache and thetiming sidechannels theexecutiontimeofaprogramdependsonthecpucyclestake n toexecutetheinstructionsandthetimeneededtoaccess mem ory.
the first component is easy to compute but also less important inpractice becausesecurity criticalapplicationsofte nexecutethe samesetofinstructionsregardlessofvaluesoftheirsensi tivevariables .incontrast leaksaremorelikelytooccurinthesecond component the time taken to access memory.
compared to the shengjian guo meng wu andchaowang timeneededtoexecuteaninstruction whichmaybe1 3clock cycles the time taken to access memory during a cache miss ma y betens oreven hundreds of clockcycles.
therearedifferenttypesofcachebasedonthesize associat ivity andreplacement policy.foreaseofcomprehension weusedi rectmappedcachewithlrupolicyinthispaper butothercachety pes may be handled similarly.
indeed during our experiments b oth direct mapped cache and way set associative cache were e valuatedand theyled tosimilar analysis results.
we assume the security critical program pimplements a functionc f k x wherekis the sensitive input secret xis the non sensitive input public and cis the output.
in block ciphers for example kwould be the cryptographic key xwould be the plaintext cwould be the ciphertext and fwould be the encryptionordecryptionprocedure.
let theexecutiontimeof pbe p k x .sincetheremaybemultiple paths inside p when referring to a particularpath p p we use p k x .
but if there is no ambiguity we may omit the detail and simply use k x .
wesay p is leak free if k x remains the same forallinput values.thatis x k1 k2.
k1 x k2 x herek1andk2aretwoarbitraryvaluesof k.sinceinpractice decision procedures e.g.
smt solvers are designed for checki ng satisfiability instead of proving the validity of a formula we try to falsify it bychecking theformulabelow x k1 k2.
k1 x nequal k2 x here we search for twovalues of kthatcanlead todifferences.
if the set of instructions executed by premains the same we only need to check whether k1 x and k2 x have the same numberofcachehitsandmisses.furthermore inourthreatm odel wheretheattackercanonlyobserve passively theexecuti ontime ofp butnotcontrolorobserve x wecanreducethecomputational cost by fixing a value xofxarbitrarily and then checking if k1 and k2 have thesame numberof cachehits and misses.
.
exampleofan attack now weshowaconcreteexampleofexploitingcachetimingle aks in concurrent systems.
thegoal is to illustratewhat an adve rsary may beabletoachieve in practice.
figure6showsatwo threadedprogram itscachemapping and thethread localcontrolflows.initially t2allocatesamemoryarea buf whose size matches the input.
although the input size may be arbitrary here we assume it is an integral multiple of e.g.
1024bytes input size .inthe while loop line14 t2reads bytes from input every time to fill buf.
thread t1tracks the progress idx oft2 line and repeatedlyretrieves byte data frombuftothearray out line5 .theencryptionon outinvolves the s box array sand a given key lines .
once the data is encrypted t1sends it out line .
when t1finds that bufruns out of data itsleeps for50ms line10 .
first we explain why the program has a timing leak.
we use a 32kbdirect mappedcachehereandseteachcachelineto64by tes.
the s box array shence maps to cache lines and the bufarray mapsto16cachelines.forbrevity weonlyfocusontheimpor tant arrays sandbuf while assuming other variables do not affect the cache mapping.
furthermore we assume sandbufshare one cache lineas highlighted infigure .uint8 t buf uint32 t size input size uint32 t idx uint8 t s 0x4b ... uint8 t out for int i i size if i idx memcpy out buf i for int j j j i out s write out ... else sleep ...... buf uint8 t malloc size while idx size memcpy buf idx read ... idx ...... ......s s s s s s s s buf buf ......buf buf ......64bytes 32kb j 645i idx 10i sizet1 1413idx sizet2 idx figure6 a two threadedencryption program.
thegraphinfigure 6showsaninterleavingof t1andt2 where thedottedredarrowrepresents acontextswitchafter t2executes thememcpystatement line while t1just reaches the for loop atline6.thetextabovethearrow means idx s valueis 960atthe moment indicatingthread t2hasjustaccessedthelast64bytesof bufat line14.
afterthecontextswitch t1entersthe for loop line6 andreads s at line .
note that the offset to s s base address depends on key thus different keys may make thread t1access different items of s. we pick two byte keys k1andk2which differ in the first eight bits for k1and for k2.
usingk1 threadt1first reads key ands .
the access to s would lead to a cache hit if iis greater than .
this is becauseafter the for loop lines finishes once i s is alreadymappedtocacheand no further accesses evict it.
in contrast with k2 threadt1loadss which maps to the cachelinesharedwith buf .
recallthat beforethecontextswitch t2justaccessedtheareastartingfrom buf idx buf .
consequently t1 s access to s causes a conflict miss because the shared cache line was occupied by buf.
thus we find a leak twokeys k1andk2 leadingtodivergentcachebehaviorsataprogram locationduetothread interleaving.
next we discuss how this leak may be exploited.
the leak is due to the sharing of cache between sandbuf which is crucial to our threat model.
in this program shas a fixed size while buf is dynamically allocated at run time based on the input data.
furthermore input size is a variable affected by the external input.
although the actual input size cannot be arbitrarily large i n practice for this exploit to work it only needs to be larger than the totalcachesize which is 32kb.
thus the attacker could mutate the input to alter the buffer size henceaffectingthememorylayout.furthermore reala pplications sometimes use relatively large fixed buffers.
for examp le in openssh thescpprogramhasa16kbbufferfor copy buflen andthesftpprogramhasa32kbbufferfor default copy buffer .
moreover openssh s sshbuf size max buffer fora socketchannelisaslargeas256mb.theselargebuffersallowroomforatt ackers toconstructthedesired cache layout.
cipher ctr mt.c ... for i i cipher threads i ...... pthread create ... thread loop ... ...... cipher ctr mt.c static void thread loop void x ...... for i i kqlen i aes encrypt q ctr q keys key ...... figure7 concurrency relatedcodein hpn ssh .
wehavefoundasimilarscenariointheopen sourceimplemen tationofhpn ssh whichisanenhancement ofopenssh by leveraging multi threading to accelerate the data encry ption.
figure7showsthecodesnippetdirectlytakenfromthehpn ssh repository on the left hand side are threads created to run the thread loop function shown on the right hand side which repeatedlycalls aes encrypt toencryptdatagivenbytheuser line .
by controlling the size and content of the data as well as the number of threads a malicious user is able to affect both t he memory layoutand thethread interleaving.
in our experimental evaluation section we will show that the aes subroutine from openssl indeed has cache timing leak s whichmaysubjecthpn sshtoattackscenariossimilartothe one illustratedin figure .
adversarial symbolic execution we first present the baseline algorithm for concurrent progr ams.
then weenhance it tosearch for cachetiming leaks.
.
the baselinealgorithm followingguoetal.
weassumetheentireprogramconsistsof afiniteset t1 ... tn ofthreadswhereeachthread ti i n is a sequential program.
withoutloss of generality we assu met1 is critical and any of t2 ... tnmay be adversarial.
let stbe an instruction in a thread.
let evente an bracketle ttid l st l an bracketri htbe an instance ofst wherelandl arethread locallocationsbeforeandafterexecutingst.agloballocation is atuple s an bracketle tl1 ... ln an bracketri htwhere each li isalocationin ti.dependingonthetypeof st anevent mayhave one ofthefollowingtypes event which is an assignment v.altl explwhere v.altlis a localvariableand explis anexpression in localvariables.
event whichisalocalbranchdenoted assume condl where thecondition condlis expressed in localvariables.
event which is a loadfrom global memory of the form v.altl v.alt afii10069.ital astoretoglobal memory of the form v.alt afii10069.ital expl ora thread synchronization operation.
foranif c else statement weuse assume c todenotethethenbranch and assume c to denote the else branch.
since cis expressedinlocalvariablesorlocalcopiesofglobalvariabl es events are local branching points whereas events are thread interleaving points.
both and events contribute to the state space explosionproblem.incontrast eventsarelocaltotheirownthreads.
detailsonhandlingoflanguagefeaturessuchaspointersan dfunction calls are omitted since they are orthogonal issues add ressed byexisting symbolicexecutiontools .
algorithm 1shows the baseline symbolic execution procedure thatfollowsthepriorwork exceptthat forthepurpose ofdetectingtimingleaks itconsiderstwoeventsas dependent also when they are mappedtothe same cacheline.
here anexecutio n ischaracterizedby in sch wherein k x isthedatainputandschis the thread schedule corresponding to a total order of eventse1...en andstackis a container for symbolic states.
each s stackisatuple an bracketle tm pcon branch enabled crt an bracketri ht wheremisthe symbolic memory pconis the path condition branchis the set of branching events enabledis the set of thread interleaving events and crtis theevent chosen toexecuteat s. algorithm baseline symbolicexecutionprocedure.
initially state stack stack starts y.sc m.scsc s0 with the initial symbolicstate s0.
1s y.sc m.scsc states 2begin 3stack.push s 4ifsisa thread local branchingpoint then fort s.branch ands.pcon tissatisfiable do s y.sc m.scsc nextsymbolicstate s t event end 8else ifsisa thread interleaving point then fort s.enabled do s y.sc m.scsc nextsymbolicstate s t event enhanced end 12else ifsisother sequential computation then s y.sc m.scsc nextsymbolicstate s s.crt event 14else terminate at s 16end 17stack.pop 18end 19nextsymbolicstate states eventt 20begin 21s.crt t 22s execute the event tinthe state s 23returns 24end atthebeginning thestack is emptyand theentry is theiniti al states0.then dependingonthetypeofthestate s wemayexecute alocalbranch line4 performacontextswitch line8 or execute a sequential computation line .
in all cases s y.sc m.scscis invoked again onthenew state.
sub procedure nextsymbolicstate takes the current state sand to be executed event tas input and returns the new state s as output s is the result of executing tats.
we omit details since theyareconsistentwithexistingsymbolicexecutionmetho ds .
also notethat in theprior work symbolic execution woulda llowinterleavings betweenglobal events onlyif theyhave data conflicts i.e.
they are from different threads accessing the same memory location and at least one of them is a write.
this is be cause only such accesses may lead to different states if they a re executed in different orders.
however in our case whether t hese events are mappedtothesame cacheline alsomatters.
.
enhanced algorithm weenhancethebaselinealgorithmtoarriveatalgorithm where themaindifferenceisintheinterleavingpoints.uponenter ingthe for loop at line we first check if an enabled event tmay lead to a timing leak by invoking divergentcachebehavior s t .
details of thesubroutinewillbepresented insection butatthehigh level it constructs a cache behavior constraint tand then searches for twovalues k1andk2 suchthat t k1 nequal t k2 .
sincedetectingsuchdivergentbehaviorsiscomputational lyexpensive priortoinvokingthesubroutine wemakesurethat event tindeed may be involved in an adversarial interleaving.
this is determined by adversarialaccess s t which checks if tcomes shengjian guo meng wu andchaowang from the critical thread t1and there exists a previously executedevent t s .crtwheres stackand thetwoevents tand t are mappedtothesame cacheline.
algorithm symbolic executionin s y.sc m.scsc initially state stack stack starts y.sc m.scsc s0 with the initialsymbolicstate s0.
1s y.sc m.scsc states 2begin ...... 4else ifsisa global memoryaccesspoint then fort s.enableddo ifdivergentcachebehavior s t then generate testcase terminateat s else s y.sc m.scsc nextsymbolicstate s t end end ...... 14end 16divergentcachebehavior states eventt 17begin 18ifadversarialaccess s t then t computet s cachehit constraint if k k suchthat t k nequal t k then returntrue 22end 23returnfalse 24end 26adversarialaccess states eventt 27begin 28iftisfromthe criticalthread then lets stackandt s .crt if t .tandt maymap tosamecache line then returntrue 32returnfalse 33end forourrunningexampleinfigure inparticular algorithm wouldexplorethefirstthreeinterleavingsintable 1beforedetectingtheleak.theprocessispartiallyillustratedbyfigure where eventst1 load q t2 load p andt3 store p belong tothread t1whereast4 load tmp belongs tothread t2.
assumet1executest1toreacht2andt2is aboutto execute t4 thiscorrespondstothefigureontheleft.atthismoment s.enabled t2 t4 .ift4isexecutedbefore t2 adversarialaccess s t2 would evaluatetotruebecause t2comesfromthecriticalthreadand p maybemappedtothesamecachelineas tmpaccessedby t4.however there is no timing leak at t2 because p differs from t1 s accessq meaning the cache behavior at t2remains the same forallvalues of k. ift2wereexecutedbefore t4 wewouldhavethesecondscenario in figure .
at this moment s.enabled t3 t4 .
ift4is executed aftert3 theinterleavingwouldbe whichdoesnothave timing leaks either.
but if t4were executed before t3 we would have the third scenario in figure whereadversarialaccess s t3 evaluates to true t3 k evaluates to falsefor k but to truefor k nequal1 k as shown in table leading to divergent cache behaviors in .
adversarial cache analysis our method for detecting divergent cache behaviors is as fol lows.
first it constructs the behavioral constraint for each mem ory access.
then it solves the constraint to compute a pair of sens itive values that allowtheconstraint toreturndivergent result s.p p q t1 tmpt2 p p q t1 tmpt2 p p q t1 tmpt2 figure8 the threeinterleavingsgeneratedby s y.sc m.scsc.
.
cache modeling recall that the entire program contains t1andt2 among other threads where t1invokes the critical computation and t2is potentiallyadversarial.
during symbolicexecution s y.sc m.scscconducts contextswitcheswhen loadorstoreinstructionsmaybemapped tothesame cache line.
here each interleaving pcorresponds to a data input inand a thread schedule sch.the data input is divided further into in k x wherekis sensitive secret and xis nonsensitive public .
whenever the value of xis immaterial we assumein k .
aninterleaving pisasequenceofmemoryaccessesdenoted p sch in a1 ... an whereschrepresents the order of theseaccesses and inrepresents thedata input.
eachai wherei denotes a memoryaccess.
pconi k is thepath conditionunderwhich aiis reached.
thus when pconi k istrue meaning aiisreachable wecheck ifaicanlead toacache hit i k denotestheconditionunderwhich aitriggersacache hit.
addridenotes thememoryaddress accessed by ai.
ta afii10069.ital addr is a functionthatreturns theunique ta afii10069.italofaddr.
line addr is a functionthatreturns thecache lineof addr.
thus we definethe cache hitcondition as follows i k logicalordisplay.
j i parenleftbig ta afii10069.ital addrj ta afii10069.ital addri l barex barexline addrl nequalline addri parenrightbig for each memory access ai s y.sc m.scsctraverses the preceding memoryaccesses intheinterleaving pto seeif any such ajmay result inaibeingacachehit.thisisdonebycomparingthetagof addri tothatof addrj ahitispossibleonlywhentwotagsarethesame.
furthermore any other memory access al between aiandaj mustnot evict thecache line occupiedby aj and hence ai .
this means forall j l i wehave line addrl nequalline addri .
ifaialways causes a cache hit or a miss it cannot leak sensitive information because it implies k1 k2.
i k1 i k2 .
in contrast if i k evaluates to truefor some value of kbut tofalse fora different valueof k then itis a leak.
.
leakage detection after constructing i k which is the cache hit condition for a potentially adversarial memory access ai we instantiate the symbolicexpressiontwice firstwithafresh variable k1andthenwith table cache relatedinformation of interleaving p. line ipconiaddri i cache 60k 127q false miss 91k 127p ta afii10069.ital p ta afii10069.ital q miss k 127tmpta afii10069.ital tmp ta afii10069.ital p parenleftbigta afii10069.ital tmp ta afii10069.ital q miss line tmp nequalline p parenrightbig k 127p ta afii10069.ital p ta afii10069.ital tmp miss parenleftbigta afii10069.ital p ta afii10069.ital p or line p nequalline tmp parenrightbighit another fresh variable k2.
we use an off the shelf smt solver to search forvaluesof k1andk2thatcanleadtodivergent behaviors.
precise solution.
thepreciseformulationis as follows k1 k2.
k1 nequalk2 i k1 nequal i k2 weneed toconductthis check at every memory access ai where i along the symbolic execution path p. if the above formula is satisfiable the smt solver will return values k1andk2of variables k1andk2 respectively.
two step approximation.
since computing both values at the same timeis expensive in practice wecantake twosteps first solve subformula k1.
i k1 to compute a concrete valuefor k1 denoted k1.
second solve subformula k2.
k1 nequalk2 i k1 nequal i k2 tocomputea concrete value k2fork2.
sincetheformulasolvedineachstepis almosttwice small er the solving timecan bereducedsignificantly.
furthermore a va lid solution k1andk2 is guaranteed tobea valid solutionfor the original formula as well.
however in general the two step appr oach is an under approximation when it fails to find any solution it is not a proofthat nosuch solutionexists.
to make the two step approach precise one would have to apply it repeatedly each time with a different k1computed in the firststep untilallsolutionsof k1iscovered.nevertheless weshall show throughexperiments that inpractice applyingitonc eis often accurateenough todetecttheactualleak.
.
the runningexample we revisit the example in figure 4to show how our approach detectsthe leak.recall that s y.sc m.scscwouldgenerate thesix interleavingsshownintable .foreachinterleaving table 2showstheline number line of every access ai path condition pconi memory addressaddri and thecache hit constraint i. inside the interleaving for instance uponreaching theloadofq at line the path condition would be k .
since it is the first memory access 0must befalse cache miss .
wewill recordthis memoryaddress for furtheranalys is.
nextisthe loadofp atline9.s y.sc m.scscbuilds 1andchecksits satisfiability.
since p and the preceding q correspond to different memory addresses the ta afii10069.italcomparison in 1returns false indicating a cache miss.
the loadat line accesses tmp.
sincetmpis different from any of the elements in arrays pandq theta afii10069.italcomparisons in 2returnfalse making a2a cachemiss.
similarly 3forthestoreatline 11is showninthelastrow of table2.itisworthmentioningthat 3onlycompares p addr3 1uint8 t sbox1 0x6f 0x3c 0x77 0xb7 0x2f 0x7b 0x5 f 0xc6 ... 2uint8 t sbox2 0x3d 0x4c 0x5f 0xb6 0xd1 0xff 0x3 e 0xed ... 3voidencrypt uint8 t block 4for uint8 t i i i block sbox1 block sbox2 figure9 examplecodefor accessings box lookuptables.
withtmp addr2 andp addr1 but not q addr0 becauses y.sc m.scscfindsthat iftheaccessto tmpdoesnotevictthecache lineusedbyitsprecedingaccess to p addr1 thelast storeto p addr3 mustbeacachehit s y.sc m.scscstopsheretoavoidfurther and unnecessary analysis.
differing from 0 1and 2 theconstraint 3depends on kdue to the constraint line p nequalline tmp .specifically 3 k istrue when k!
k and isfalsewhen k .
ins y.sc m.scsc two symbolic variables k1 k2will be used to substitutekinthesymbolicexpressionof 3 k toform 3 k1 and 3 k2 .
solving the satisfiability problem described by 3 k1 xor 3 k2 wouldproducetheassignment k1 0andk2 whichmakes 3 evaluateto trueand 3 evaluate to false.
optimizations symbolicexecution whenapplieddirectlytocipherprogra ms may have a high computational overhead because of the heavy use o f arithmetic computationsand look uptables in these progra ms. in this section wepresent techniques forreducingtheoverhe ad.
toward this end we have two insights.
first when conductin g cache analysis we are not concerned with the actual numeric al computationsinside the cipher unless they affect the addres ses of memoryaccessesthatmaydependonsensitivedata e.g.
ind icesof lookuptablessuchass boxes.second forthepurposeofdet ecting leaks as opposed to proving their absence we are free to und erapproximateas long as it does not diminish the leak detecti on capabilityof ouranalysis.
.
domain specific reduction by studying real world cipher programs we have found the co mputational overhead is often associated with symbolic indi ces of lookuptablessuch as theoneshownin figure .
here blockpoints to a byte storage area whose content depends on the cryptographic key thus the eight bytes are ini tializedwithsymbolicvalues.accordingly indicestothes bo xtables block at line are symbolic.
however not all memory accesses should be treated as symbolic.
for example the addre ss of block itself andtheaddressoflocalvariablessuchas ishould be treated as concrete values to reduce the cost of symbolic e xecution.
therefore we conduct a static analysis of the inter leaved executiontrace ptoidentifythesequenceofmemoryaccessesthat needtobekeptsymbolicwhileavoidingthesymbolicexpress ions ofotherunnecessary memoryaddresses.
also aprogrammayhavemultiples boxarrays like sbox1and sbox2infigure .twosuccessiveaccessesto sbox1andsbox2 at lines and cannot form a cache hit no matter what the lookup indicesare.therefore wedonotneedtoinvokethesmtsolve rto shengjian guo meng wu andchaowang checktheequivalenceofthesesymbolicaddresses.thiscan significantly cutdowntheconstraint solving time.
.
layout directed reduction anotherreductionisguidedbythememorylayout.inllvm me morylayout maybeextracted fromthe compilerback end after the code generation step.
recall that when analyzing a pair of po tentiallyadversarialaddresses weneedtocomparethemwitha llother addresses accessed betweenthemtobuildthecachebehavior constraint.
more specifically to check if a2is a cache hit because of a1along the execution a1 b1 ... bn a2 we need to check if anybi i n couldevict thecache line used by a1.
dueto the large value of nand often complex symbolic expression of bi theconstraint solving timecouldbelarge.
ourapproachinthiscaseistodirectlycompare a1anda2while postponingthecomparisonsto bi.thisisbasedontheobservation that inpractice thecachelineof a1canpossiblybeevictedby bi only if the differences between their addresses is the multip le of the cache size e.g.
64kb which may not be possiblein comp act cipherprograms.forexample ina64kbdirect mappedcache for b1toevictthe64 bytecachelineof a1 theiraddressdifferencehas to be216 64kb.
in a way set associative cache their address difference hastobe 16kb.furthermore intheevent that a2 has a cache hit due to a1 we can add back the initially omitted comparisons to b1 ... bntoundotheapproximation.
experiments we have implemented s y.sc m.scscusing the llvm compiler and cloud9 whichisasymbolicexecutionengineformultithreaded programs built upon klee .
we enhanced cloud9in three aspects.first we extended its supportfor multi threading b y allowing context switches prior to accessing global memory the o riginalcloud9only allows context switches prior to executing a synchronizationprimitive e.g.
lock unlock .second wema decloud9 fork new states to flip the execution order of two simultaneou sly enabled events when they maybemappedtothesame cacheline theoriginal cloud9doesnotcareaboutcachelines.third wemade cloud9recordtheaddressofeachmemoryaccessalongtheexecution so it can incrementally build the cache hit constrain t. based on these enhancements we implemented our cache timing leak detectorand optimizeditforefficient constraint solving.
aftercompilingtheccodeofaprogramtollvmbit code our s y.sc m.scsctool executes it symbolically to generate interleavings ac cording to algorithm .
the cache constraint at each memory accessisexpressedinstandardkqueryexpressionsdefinedink lee .
by solving these constraints we can obtain a concrete execu tion that showcases the leak including a thread schedule two in put valuesk1 k2and theadversarial memoryaddress.
.
benchmarks we evaluated s y.sc m.scscon a diverse set of open source cipher programs.
specifically the first group has five programs from a li ghtweight cryptographic system named felics which was designedforresource constraineddevices.thesecondgroup hasfour programs from chronos a real time linux kernel.
the third grouphasfourprogramsfromthegnulibrary libgcrypt while theremainingprogramsarefromthe libtomcrypt theopenssl and a recent publication .
they include multiple versions oftable3 benchmarkstatistics linesofccode loc andllvmcode ll sensitive key size ks andthememory accesses ma .
name loc llksmaname loc llksma aes 38424771fcrypt aes 14424788kv name camellia 301lblock cast5 79016909misty1 cast5 180piccolo chaskey 24863816242present des 8963rfc2268 des 029seed kasumi 350122416259twine khazad 83846316123twofish several well known algorithmssuchas aes anddes which are useful in evaluating the impact of cipher implemen tationsontheperformanceof s y.sc m.scsc.
table3shows the statistics of these benchmark programs.
the locandllcolumns denote the lines of c code and the correspondingllvmbit code.the kscolumnshowsthesizeofthesensitive input in bytes.
the maximum number of memory accesses onprogrampathsofeachbenchmarkisshowninthe macolumn which indicates thecomputationalcostof theprogram.
eachprograminthebenchmarksuitehasfrom194to1 429line s ofccode.intotal thereare14 455lines ofc code which com pile to lines of llvm bit code.
these numbers are consider ed substantial because ciphers are typically compact program s with highly computation intensive operations e.g.
due to the ir use of loops and lookup table based transformations.
for example the program named present has only lines of c code but memoryaccesses atruntime.
weanalyzedthesebenchmarkprogramsusingtwotypesofcach es direct mappedcacheandfour wayset associativecache.t hecache sizeis64kbwitheachcachelineconsistingof64bytes thus there are64kb 64b 1024cache lines which aretypical inmainstr eam computerstoday.
ourexperiments were designed toanswer two questions cans y.sc m.scscdetect cache timing leaks exposed by concurrently running a programwith otherthreads?
aretheoptimizations insection 6effective in reducingthe costof symbolicexecutionand constraint solving?
weconductedallexperimentswithubuntu12.04linuxrunnin gon acomputerwitha3.40ghzcpuand8gbram.forallevaluations weset thetimeoutthreshold to1 600minutes.
.
results obtained withfixed addresses table4shows our results obtained using fixed addresses in the cache layout case in section .
.
the first column shows the benchmarkname.thenextthreecolumnsshowtheresultofcom putingtheprecisesolutionforourcacheanalysisproblem.
thelast threecolumnsshow theresultofrunning thesimplified two step version wherethesolutionfor k1 k2.
k1 nequal k2 iscomputed intwosteps byfirstcomputingavalueof k1andthencomputinga valueofk2.ineach method weshowthenumber ofinterleavings explored .inter the number of leaky memory accesses det ected .test andtheexecutiontimeinminutes m .forthetwo stepapproach we alsoshow thenumber of leakage points detectedaf ter thefirststepand after thesecond step.
among these twenty programs we detected leakage points in four asefromopenssl desfromlibgcrypt fcryptfrom table4 resultsofleakdetectionwith fixedaddresses isthe program leakyw.r.t.the giventhread?
nameprecise two step .inter .test time m .inter .testtime m step1 step2 aes .
.
aes .
.
camellia .
.
cast5 .
.
cast5 .
.
chaskey .
.
des .
.
des .
.
fcrypt .
.
kasumi .
.
khazad .
.
kv name .
.
lblock .
.
misty1 .
.
piccolo .
.
present .
.
rfc2268 .
.
seed .
.
twine .
.
twofish .
.
chronos andkhazadfromchronos .wemanuallyinspected these four programs in a way similar to what is described in se ction3.
and confirmed that all these leakage points are realistic.
furthermore ourtwo stepapproachreturnedexactlythesa meresults as the precise analysis for all benchmark programs bu t in significantly less time.
we alsoconductedourexperiments using way set associative cache instead of direct mapped cache.
the results of these experiments are similar to the ones reported in table .
therefore we omit themfor brevity.
nevertheless the similarity is expected.
for example a 24bytes boxwouldbemappedto16consecutivecachelinesin directedmappedcacheaswellas wayset associative cache providedthat thecachesizeis 64kband thelinesizeis byte.theonlymi nor difference is that in the way set associative cache we need four adversarial memoryaccesses from thread t2to fullyevict a cache set.
but if we have already detected the first adversarial add ress sayaddr the remaining three could simply be addr cache size addr cache size andaddr cache size .thus thereisnosignificant difference fromanalyzing direct mapped cache.
.
resultsobtained withsymbolicaddresses the results shown in table 4are useful but also somewhat conservative.
a more aggressive analysis is to assume the adversarial threadt2mayaccess memoryregions whosecachelayoutis symbolic refer tocase 2in section .
.
table5shows the experimental results obtained using directmappedcache and symbolic addresses in thread t2 case in section2.
.thefirsttwocolumnsshowthebenchmarknameandthe maximum number of memoryaddresses accessed by an interleav ingatruntime.the precisecolumnshowstheresultofcomputing the precise solutionforour cache analysis problem.the two step columnshowstheresultofrunningthesimplifiedversion.in both cases wereportthetotalnumberofinterleavingsexplored bysymbolicexecution .inter thenumberofleakymemoryacces sesdetected .test and the total execution time in minutes m .
for two step thenumberofleakyaccesses isfurtherdividedintotwotable5 resultsofleakdetectionwith symbolic addresses is thegivenprogram leakyw.r.t.
anyadversarialthread?
name .accprecise two step .inter .testtime m .inter .testtime m step1 step2 aes .
.
aes .
camellia .
.
cast5 .
cast5 .
chaskey .
.
des .
.
des .
fcrypt .
.
kasumi .
khazad .
kv name .
.
lblock .
.
misty1 .
piccolo .
.
present .
.
rfc2268 .
.
seed .
twine .
.
twofish subcolumns theleakyaccessesdetectedafterthefirststep andthe leakyaccesses detectedafter thesecondstep.
the results show that for most of the benchmark programs the overhead of precisely solving our cache analysis is too h igh on nine of the twenty programs it could not complete within t he timelimit.incontrast ourtwo stepanalysis wasabletoco mplete nineteen out of the twenty programs.
in terms of accuracy ou r two stepapproachisalmostasgoodaspreciseanalysis ina llcompletedprograms theydetectedthesamenumberofleakagepo ints which indicate a possible combination of adversarial threa ds and memorylayoutthat cantrigger timingleaks.
our results also show that for the same type of cryptographi c algorithms such as aes different implementations may lea d to drastically different overhead.
for example we detected more leakagepointsinthe aesimplementationof chronos thanthat ofopenssl .however the aesofchronostookalmosttwiceas long for our tool to analyze.
for desthe implementations from libgcrypt andchronos we detected a slightly different numberofleakagepoints butthetimetakenissignificantly different .
minutes versus .
minutes .
in contrast for t he two versionsof cast5 wedetectedthesamenumberofleakagepoints inroughlythesameamount oftime.
forthebenchmarkwhere two step tookalongtime wefoundit isduetotheincreasing sizeofsymbolicconstraintswhichc onsist of the addresses in s box accesses.
typically the later a s b ox accessinaloop thelargeritssymbolicaddressexpressionwo uldbe.
intwofish s y.sc m.scsctimedoutbecauseitencounteredalargenumberof may be related event pairs i.e.
accessing thesa mes box butnot thesamecache line which madesmtsolving difficult.
.
discussion basedontheresults weanswer thetworesearch questions as follows.first s y.sc m.scscis abletoidentifycachetiming leaksinconcurrentprogramsautomatically.specifically using symbolicaddresses in the adversarial thread allows us to demonstrate the possi bility oftriggeringleaksinaconcurrentsystem whereasusing fixedaddresses in theanalysis allows ustoshowthatsuch leaks arem ore shengjian guo meng wu andchaowang practical.
second s y.sc m.scsc s performance optimization techniques areeffectiveinreducingthecomputationaloverhead which isdemonstratedona diverse set ofreal world cipher programs.
s y.sc m.scscsearches for sensitive inputs as well as an interleaving schedule that together trigger divergent cache behavior s. if an individual program path has a constant cache behavior e.g.
all the memory accesses refer to fixed memory addresses regardle ss of the value of the sensitive input then timing leaks are imp ossible.
by checking for and leveraging such conditions s y.sc m.scsccan reducethecomputationcostevenfurther.forinstance wit hnaive exploration s y.sc m.scscwould have generated interleavings for thebenchmarkprogramnamed kv name.however withtheabove analysis it doesnothave togenerate any interleaving.
in this example kv name s byte symbolic input only affects the branch conditions but does not taint any memory access ad dress.thus manypathsareexploredbysymbolicexecution.
however noleak is detectedonthese paths.
another exampleis chaskey which has a single programpath togetherwith1 380memoryaccesses onthispath.thesememo ry addressesareallindependentofthe16 bytesymbolicinput which means no leakage pointcanbefound by s y.sc m.scsc.
related work side channel leaks have been exploited in a wide range of sys tems .
for timing side channels in particular manyanalysisandverificationtechniqueshave beendeveloped.forexample chenetal.
proposedatechniquenamed cartesian hoare logic for proving that the timing leaks of a program are bounded.
antonopoulos et al.
proposed a similar method for proving the absence of timing channels it partit ions theprogrampathsinawaythat ifindividualpartitionsare proved to be timing attack resilient the entire program is also tim ing attack resilient.
however these methods only consider instructioninducedtiming whileignoring thecache.
in the context of analyzing real time systems there is a lar ge body of work on cache analysis with the goal of estimatingtheworst caseexecutiontime wcet .varioustechn iques includingabstractinterpretation symbolicexecution andinterpolation havebeenusedtocomputetheupperbound ofexecutiontimealongallprogrampaths.chattopadhyayet al.
also developed chalice to quantify information leaked through thecachesidechannel butthefocuswasondependenciesbet ween sensitive data and misses hits onthecpu s data cache.
doychev et al.
developed cacheaudit a toolrelying on abstract interpretation based static analysis to analyze cac he timing leaks.
wang et al.
developed cached an offline trace analysis tool for detecting key dependent program points in a cip her program that may be vulnerable to side channel attacks.
sung et al.
developed canal an llvm transformation that models cache timing behaviors for standard verification tools.
how ever these techniques handlesequential programs ortracesonly .
pasareanu et al.
developed a symbolic execution tool for reasoningaboutthedegreeofleakedinformation assuming theattackercantakemultiplemeasurements.
thetestinputthatc auses themaximumamountofleakageiscomputedusingmax smtsolv ing.
bultanetal.
developedtechniquesforquantifying informationleakedbystringoperations.theirmethodcanh andle bothsingleandmultipleruns itappliesprobabilisticsymbolic executiontocollectpath constraints ofa single runand the nusestheseconstraintstocomputetheleakageofmultipleruns.p hanet al.
alsodevelopedasymbolicattackmodelandformulatedthe problem of test generation to obtain the maximum leakage as a n optimizationproblem.
however inalltheseexistingmethods theprogramisassum ed tobesequential.incontrast s y.sc m.scscfocusesonconcurrency induced leaks.
although bartheet al.
proposedan abstractinterpretationtechniquebasedon cacheaudit totrackthecachestateof a program with concurrent adversary the adversary is a sepa rate process that tries to probe and set the cache states not a t hread.
furthermore users have to provide data inputs and interlea ving schedules whereas s y.sc m.scscgenerates them automatically.
stefanetal.
proposedaninstruction basedschedulingmechanism in information flow control systems running on a single cpu toavoidcachetimingattacksintroducedbyclassictim e based schedulers.therefore itis asystem level mitigationtec hnique.in contrast s y.sc m.scscfocuses on detecting whether a security critical program may leak sensitive information through the timing s ide channel duetointerference fromother threads.
our state space reduction in s y.sc m.scscis related to partial order reduction por in model checking but with an important difference.inclassicpor onewouldtypically selectrepresentativeinterleavingsfromequivalencecla sses which are defined based on standard data conflict and data depende nce relations.
however in s y.sc m.scsc they must be broadened to also include functionally independent events that may access the same cacheline.
so far s y.sc m.scscfocuses on cases where the adversarial thread flushesasinglecacheline.intheterminologyofside chann elanalysis this corresponds to first order attacks.
if on the other hand the adversarial thread is capable of flushing multiple cache lines it may be more likely to trigger timing leaks.
such cases woul d be called high order attacks.
we leave the analysis of high order attacksforfuturework.
besides leak detection there are side channel leak mitiga tion techniques that can generate countermeasures automatical ly e.g.
usingcompiler likeprogramtransformations orsmt solver based formal verification and program synthesis techniques.
however none of these emergingtechniqueswasdesignedfor orapplicableto cachetim ingside channels duetoconcurrency.
conclusions wehavepresentedasymbolicexecutionmethodfordetecting cache timing leaks in a computation that runs concurrently with an adversarial thread.
our method systematically explores both thread pathsandtheirinterleavings andreliesonansmtsolverto detect divergent cachebehaviors.ourexperiments showthatrealc ipher programs do have concurrency related cache timing leaks an d although it remains unclear to what extent such leaks are exploited in practice our method computes concrete data inputs and in terleaving schedules to demonstrate these leaks are realistic .
to the bestofourknowledge thisisthefirstsymbolicexecutionme thod fordetectingcachetiming side channel leaks duetoconcur rency.