understanding automatically generated patches through symbolic invariant differences padraic cashin carianne martinez westley weimer stephanie forrest arizona state university tempe az university of new mexico albuquerque nm university of michigan ann arbor mi abstract developer trust is a major barrier to the deployment of automatically generated patches.
understanding the effect of a patch is a key element of that trust.
we find that differences in sets of formal invariants characterize patch differences and that implication based distances in invariant space characterize patch similarities.
when one patch is similar to another it often contains the same changes as well as additional behavior this pattern is well captured by logical implication.
we can measure differences using a theorem prover to verify implications between invariants implied by separate programs.
although effective theorem provers are computationally intensive we find that string distance is an efficient heuristic for implication based distance measurements.
we propose to use distances between patches to construct a hierarchy highlighting patch similarities.
we evaluated this approach on over patches and found that it correctly categorizes programs into semantically similar clusters.
clustering programs reduces human effort by reducing the number of semantically distinct patches that must be considered by over thus reducing the time required to establish trust in automatically generated repairs.
i. i ntroduction overview.
developer trust is a major barrier to the deployment of automatically generated patches.
understanding the effect of a patch is a key element of that trust.
we propose to explain patches in terms of how they change formal program invariants.
we find that changes in invariants characterize patch differences and that implication based distances in invariant space can quantify patch similarity.
we also present a scalable string based approximation to implication distance.
automated patching.
many tools have been developed to improve the efficiency of software engineering but the process of patching code to repair bugs remains a dominant cost.
to address this issue many methods have been proposed to automate the patching process e.g.
and over the past decade automated software repair has been an active area of research.
generally these methods fall into two classes semantically sound methods that produce patches that are correct by construction and methods that generate random mutations and test them for correctness using a supplied test suite.
search based methods can be applied to legacy software even when they lack a formal specification they perform well on large code bases and they generalize across many classes of bugs.
however these methods have been criticized because they produce multiple patches that are correct only with respect to available tests.
patches that are not trusted are not de ployed .
initial industrial deployments have focused on aspects of automatic patching that are simple and easy for developers to assess and trust .
these issues suggest the need for methods that can reduce the cost of evaluating automatically generated patches as produced by search based methods.
our approach.
we propose to address this issue by incorporating formal methods into the repair process using them to show that automatically generated patches preserve certain aspects of required functionality and to highlight the key semantic changes implied by a proposed patch.
conceptually we achieve this by generating and comparing relevant program invariants for the original program and the proposed repair.
this comparison determines if the patched program violates an important known property of the original program and it identifies invariants that describe the repair s corrected functionality.
we thus avoid an impediment to using formal methods in search based program repair a buggy program is incorrect in at least some of its behavior and therefore does not currently represent a correct specification.
we use dynamic invariant generation to create a set of invariants logical formulae over program variables encoding relationships that are true on indicative runs one for the buggy program and one for each proposed repair.
since most software bugs are revealed through a failing input we use the failing tests together with the supplied test suite to generate invariants that are most relevant to the repair.
we group repairs into quasi equivalence classes using one of two distance metrics one based on logical implication and one based on syntactic comparison of the invariant sets.
each class is made up of invariant sets that are distance zero from each other under the chosen metric.
we use hierarchical clustering to highlight how the classes are related.
in addition we explicitly compare the invariants of each patch to those of the original buggy program.
this approach highlights the key semantic differences between the original program and each patch and it allows a developer to quickly consider multiple possible patches by evaluating only one element from each semantic class.
preliminary findings.
we hypothesize that dynamic invariants can detect changes within a program.
invariants are effective because functional correctness relates to the final result of a function rather than any specific implementation.
we propose the use of implication relationships between 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ssize a mp size ?
asize !
ssize a mp size ?
a tool patch ssize siz a ?
asize !
ssize siz a ?
b official patch if return ... gmpn cmp ap bp asize mpn cmp ap bp asize c tool patch fragment fig.
three patches for gmp which returns an incorrect answer from the gmp ext function.
sets of invariants to measure pairwise patch similarity and group invariant sets into quasi equivalence classes according to similarities between their implication relationships.
because it is expensive to compute implication distance we propose string distance as an effective approximation for implication distance.
a formulation involving levenshtein edit distance is significantly more scalable than a formal approach based on satisfiability modulo theories smt decision procedures.
we hypothesize this approach which we call p at c h part t o be efficient and effective.
ii.
m otiv a ting example this section considers candidate patches produced by two different program repair tools and shows how p a tch part identifies semantically meaningful clusters of patches and reports their semantic differences.
results of earlier studies of search based repair tool quality have been mixed.
some papers have identified flaws in particular examples of automatically generated patches .
we consider one of these latter cases here.
we take as an example one defect in the gnu multiple precision arithmetic library and two tool repairs referred to as tool and tool respectively .
the defect is located in the gcdext function and involves the incorrect resolution of gcd .
an incorrectly constructed conditional causes the return value to be .
we apply p a tch part to four versions of gmp the original buggy version and three patches from tool tool and the official human gmp developers .
in this instance the tool generated patch matches the developer version more closely than tool .
we used daikon to generate invariant sets for each variant.
figure shows the three different patches.
tool inserts a conditional in a helper function which causes it to always return bypassing most subsequent calculations including a later comparison predicate .
although this is sufficient to pass the given test suite the modified conditionals cause gcd to return incorrect results on other inputs.
the modification to the helper function could have additional consequencesnot immediately apparent to developers only considering the effects on the main gcd function.
tool and the official patch each update a conditional expression involving size comparisons.
this change causes ssize to be set to 0in the case where asize .
although these patches caused the smallest modifications to the program syntax it is not clear if they are ideal.
we used p at c h part with daikon produced invariant sets to partition the repaired program variants which produced three semantic classes.
p a tch part correctly isolates the buggy version in its own cluster and finds two semanticallydistinct clusters for the repairs one containing tool and the other containing tool and official patch.
p at c h part highlights key differences between the clusters.
for example in this case the invariant temp2.mp d !
a.mp d is a property of the tool patch but not the others.
the invariant indicates that the values of mp d members for temp2 anda always remain different formalizing the effects of that patch s return .
although the patches are syntactically distinct tool and the official maintainer patches generate identical sets of invariants.
a developer need only inspect two patches one from the tool cluster and one from the tool official cluster rather than all three.
note that non functional quality properties such as readability are not considered here the developer patch makes use of the siz macro while the tool patch uses its definition.
v arious approaches have been proposed for improving readability in search based methods we view readability concerns as orthogonal and focus on functional aspects of patch inspection and trust.
this example shows how p a tch part identifies semantic clusters of patches detects important differences between the original program and different repairs and reduces the number of candidate patches a developer must manually review.
iii.
t echnical approach we require an approach that is accurate enough to distinguish between different patches fast enough to be applied as part of a patch cycle and that requires minimal human intervention.
we present p at c h part a method for partitioning programs into semantic clusters which addresses these requirements.
a. patch partitioning pa tch part pa tch part takes as input a set of programs.
it then computes the pairwise semantic distance between them in invariant space and clusters the programs into semanticallysimilar classes based on those distances.
more specifically pat c h part constructs a set of pre conditions and postconditions for each function in each considered program uses off the shelf methods such as daikon to produce dynamically generated program invariants and then calculates the invariant distance between each program pair.
the dynamic invariants are generated from the test suite and the buginducing test case.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we consider two methods for computing the pairwise distance between sets of invariants formal implication between logical formulae and levenshtein edit distance between their string representations.
theorem proving using an smt solver determines whether one invariant is logically implied by another while levenshtein distance compares two sets of invariants syntactically.
finally we use hierarchical clustering to group programs based on a distance calculation.
b. implication distance semantic similarity between two programs can be captured by computing the logical similarity between their corresponding sets of program invariants.
we thus lift a comparison on sets of invariants to a comparison on programs.
we define the implication distance id between two programs a and b to be the cardinality of inv b t impinv a b where inv x t is the set of dynamic invariants generated from tracing program x on test suite t and impinv a b b b inv b t a minterms inv a t .a b where inv is a function mapping programs to generated invariants e.g.
such as via daikon and minterms is a function mapping sets of predicates to all subsets of a particular size.
we restrict minterms to a maximum size of three to minimize computation time following established best practices from predicate abstraction p. this size is known to be efficient while retaining enough information to prove program correctness.
our definition of id relaxes the standard notion of set difference from requiring logical equivalence to requiring only an implication relation.
intuitively the implication distance represents a measure of the number of invariants in program bthat are not implied by the invariants of program a. as a simple example of why we propose implication not equivalence to capture program relationships consider two programs each with a loop which increments a value x for i i n i x .
if for program a x at the start of the loop then we should find the invariant x 0at the end of the loop.
however if x initially in program b then we will find x 1post loop for binstead.
such programs are not strictly equivalent but the implication x x holds.
this definition allows us to use hierarchical clustering to partially order programs.
given the restriction to minterms we can directly compute id from its definition.
we consider all minterms of a given size and interate querying a prover to check implications.
we use the usual conjunction interpretation when determining if a set of predicates implies another predicate.
our implementation uses the z3 theorem prover to determine satisfiability our approach is thus sound with respect to that tool.
c. levenshtein edit distance a direct calculation of id requires many queries to an expensive external smt solver.
as an efficient approximation for id we propose a string distance measure between invariant sets.
levenshtein edit distance ld measures the number of character swaps additions and deletions needed to convertone string into another.
we map each invariant to a single logical alphabet symbol representing syntactically identical invariants with the same symbol.
for example x and x both map to the same symbol but x maps to a different symbol even though it is semantically equivalent not determining semantic equivalence is the heart of our efficient approximation.
we then compute the distance between the two induced strings of symbols.
the intuition behind this approximation follows from our use case of comparing multiple automated program repair patches.
most program repair patches are small and thus they leave the majority of the original program textually unchanged .
textually identical program fragments often yield invariants that are not just semantically equivalent but are directly syntactically equivalent cf.
.
thus an approximation based on syntactic equivalence has the potential to be more accurate in this use case than it would be in general.
d. hierarchical clustering we propose the use of the unweighted pair group method with arithmetic mean upgma clustering algorithm .
upgma takes as input a distance matrix and identifies clusters that minimize the average cluster diameter.
critically since the upgma algorithm does not require the distance matrix to be symmetric we can use either ld or id measurements to group programs.
a cluster of identical patches can be inspected for a functional trust assessment by inspecting any representative of it.
on the other hand the distances between clusters and the invariants on which they differ can communicate the effects of a patch to developers.
iv .
p reliminary resul ts we evaluated a prototype of p a tch part on a set of programs from the manybugs and programs from the defects4j benchmarks.
we used genprog patches for each c defect and arja patches for each java defect repair tools are often language specific but our approach is agnostic .
daikon was used to find dynamic invariants.
by computing the pairwise distances between individuals we are able to place patches into a hierarchy based on functional similarities.
for each program we studied candidate patches were easily distinguished from the original program and relatively few invariants differentiated the repairs from the original supporting our hypothesis that p at c h part can provide a concise assessment of the key semantic elements of a proposed repair allowing a developer to quickly check that a repair retains required functionality.
when a human generated repair is not available the intended use case for automated bug repair p a tch part can provide the developer with a small set of semantically distinct patches highlighting the semantic differences between them.
we found that levenshtein distance performs almost as well as implication distance for our use case.
however we do not attribute a measure of importance to each invariant and instead authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assume each invariant is equally meaningful.
an investigation of this assumption in this context is left to future work.
these preliminary results suggest that p at c h part can successfully categorise patches based on the invariants detected by daikon.
for each group of patches we can determine a hierarchy relationships with each layer of the hierarchy containing more patches and representing a broader more abstract set of features.
for most defect scenarios this led to a reduction of patch classification effort by approximately i.e.
even when requiring distance zero invariant sets the clusters were large enough to save developer inspection effort .
although these results are preliminary we expect this approach to find useful groupings among other patches.
v. r ela ted work the two most relevant areas of related work are broadly invariant detection and automated program repair.
for reasons of space we elide the rich literature on invariant detection our approach is agnostic our preliminary evaluation uses daikon and program repair our approach is agnostic the reader is directed to monperrus for a survey .
we focus on one particular related paper to place this work in context.
recent work by ding et al.
explored the use of invariants to measure diversity among patched programs in the context of a multi objective genetic algorithm.
their work uses invariants as part of the repair process to generate a wider diversity of repairs than those typically found by search based methods.
similar to p a tch part they rely on dynamically generated invariants.
in contrast however they measure the frequency with which invariants appear across different test cases and use that information to guide the repair.
our approach takes already produced repairs uses invariant information to guide human understanding does not rely on frequencies and proposes the levenshtein distance approximation to improve scalability.
vi.
c onclusion automated testing and repair methods are advancing rapidly and transitioning to industrial practice.
search based repair methods often produce many candidate patches which must be manually inspected and understood before being deployed.
by focusing on differences both among candidate patches and between patches and the original program our p a tch part approach offers an intermediate path that supports the use of formal invariants in settings without formal specifications.
by using an efficient string based distance measures on dynamic invariant sets p a tch part can detect and enumerate the relevant semantic differences between programs.
in our preliminary results the detected invariants correctly separated the original buggy program from patched programs that pass the failing test suite and in most cases semantically identical program variants were correctly placed in clusters.
providing the developer with this additional information should simplify the task of inspecting candidate repairs reducing that burden by about in our preliminary investigation.vii.
a cknowledgments the work reported here was partially supported by nsf ccf1908633 ccf1763674 afrl fa8750 afrl and darp a fa8750 19c .