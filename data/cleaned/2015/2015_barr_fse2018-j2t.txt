deep learning type inference vincent j. hellendoorn university of california davis davis california usa vhellendoorn ucdavis.educhristian bird microsoft research redmond washington usa cabird microsoft.com earl t. barr university college london london uk e.barr ucl.ac.ukmiltiadis allamanis microsoft research cambridge cambridge uk miallama microsoft.com abstract dynamically typed languages such as javascript and python are increasingly popular yet static typing has not been totally eclipsed python now supports type annotations and languages like typescript offer a middle ground for javascript a strict superset of javascript to which it transpiles coupled with a type system that permits partially typed programs.
however static typing has a cost adding annotations reading the added syntax and wrestling with the type system to fix type errors.
type inference can ease the transition to more statically typed code and unlock the benefits of richer compile time information but is limited in languages like javascript as it cannot soundly handle duck typing or runtime evaluation via eval .
we propose deeptyper a deep learning model that understands which types naturally occur in certain contexts and relations and can provide type suggestions which can often be verified by the type checker even if it could not infer the type initially.
deeptyper leverages an automatically aligned corpus of tokens and types to accurately predict thousands of variable and function type annotations.
furthermore we demonstrate that context is key in accurately assigning these types and introduce a technique to reduce overfitting on local cues while highlighting the need for further improvements.
finally we show that our model can interact with a compiler to provide more than additional type annotations with over precision that could not be inferred without the aid of deeptyper .
ccs concepts software and its engineering software notations and tools automated static analysis theory of computation type structures keywords type inference deep learning naturalness work partially completed while author was an intern at microsoft research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
reference format vincent j. hellendoorn christian bird earl t. barr and miltiadis allamanis.
.
deep learning type inference.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction programming language use in real world software engineering varies widely and the choice of a language often comes with strong beliefs about its design and quality .
in turn the academic community has devoted increasing attention to evaluating the practical impact of important design decisions like the strength of the type system the trade off between static compile time and dynamic runtime type evaluation.
the evidence suggests that static typing is useful hanenberg et al.
showed in a large scale user study that statically typed languages enhance maintainability and readability of undocumented code and ability to fix type and semantic errors gao et al.
found that having type annotations in javascript could have avoided of reported bugs and ray et al.
empirically found a modestly lower fault incidence in statically typed functional languages in open source projects .
at the same time some of the most popular programming languages are dynamically relatively weakly typed python propelled by interest in deep learning has risen to the top of the ieee spectrum rankings javascript js has steadily increased its foothold both in and out of web development for reasons including the comprehensive package ecosystem of nodejs.
achieving the benefits of typing for languages like js is the subject of much research .
it is often accomplished through dynamic analysis such as jalangi as static type inference for these languages is made complex by features such as duck typing and js s eval .
several languages including typescript ts have been developed that propose an alternative solution they enhance an existing language with a type system that allows partial typing allowing but not requiring all variables to have type annotations which can be transpiled back to the original language.
in this way ts can be used and compiled in the ide with all the benefits of typing and can be transpiled into plain js so that it can be used anywhere regular js can.
this lowers the threshold for typing existing code while unlocking at least partially the benefits of compile time type checking.esec fse november lake buena vista fl usa v. j. hellendoorn c. bird e. t. barr and m. allamanis figure loosely aligned example of javascript code and the typescript equivalent with corresponding type annotations.
while developers may benefit from typed dialects of js such as ts the migration path from js to ts is challenging as it requires annotating existing codebases which may be large.
this is a timeconsuming and potentially error prone process.
fortunately the growth of ts popularity in the open source ecosystem gives us the unique opportunity to learn type inference from real world data it offers a dataset of js like code with type annotations which can be converted into an aligned training corpus of code and its corresponding types.
we use this data to train deeptyper which uses deep learning on existing typed code to infer new type annotations for js and ts.
it learns to annotate all identifiers with a type vector a probability distribution over types which we use to propose types that a verifier can check and relay to a user as type suggestions.
in this work we demonstrate the general applicability of deep learning to this task it enriches conventional type inference with a powerful intuition based on both names and potentially extensive context while also identifying the challenges that need to be addressed in further research mainly established models in our case deep recurrent neural networks struggle to carry dependencies and thus stay consistent across the length of a function.
when trained deeptyper can infer types for identifiers that the compiler s type inference cannot establish which we demonstrate by replicating real world type annotations in a large body of code.
deeptyper suggests type annotations with over precision at recall values of often providing either the correct type or at least narrowing down the potential types to a small set.
our contributions are three fold a learning mechanism for type inference using an aligned corpus and differentiable type vectors that relax the task of discrete type assignment to a continuous real valued vector function.
demonstration of both the potential and challenges of using deep learning for type inference particularly with a proposed enhancement to existing rnns that increases consistency and accuracy of type annotations across a file.
a symbiosis between a probabilistic learner and a sound type inference engine that mutually enhances performance.
we also demonstrate a mutually beneficial symbiosis with jsnice which tackles a similar problem.
problem statement a developer editing a file typically interacts with various kinds of identifiers such as names of functions parameters and variables.
each of these lives in a type system which constrains operations to take only operands on which they are defined.
knowledge of the type at compile time can improve the code s performance andallow early detection of faults .
a stronger type system is also useful for software development tools for instance improving auto completion accuracy and debugging information.
although virtually every programming language has a type system type information can be difficult to infer at compile time without type annotations in the code itself.
as a result dynamically typed languages such as javascript js and python are often at a disadvantage.
at the same time using type annotations comes with atype annotation tax paid when adding type annotations navigating around them while reading code and wrestling with type errors.
perhaps for these reasons developers voted with their keyboards at the beginning of 21stcentury and increasingly turned to dynamically typed languages like python and js.
.
a middle ground type annotations have not disappeared however adding partial type annotations to dynamically typed programming languages has become common in modern software engineering.
python .x introduced type hints via its typings package which is now widely used notably by the mypy static checker .
for js multiple solutions exist including flow and typescript .
two of the largest software houses facebook and microsoft have invested heavily in these two offerings which is a testament to the value industry is now placing on returning to languages that provide typed backed assurances.
these new languages differ from their predecessors to extend and integrate with dynamic languages their type systems permit programs to be partially annotated 1not in the sense that some of the annotations can be missing because they can be inferred but in the sense that for some identifiers the correct annotation is unknown.
when an identifier s principal type is unknown these type systems annotate that identifier with an implicit any reflecting a lack of knowledge of the identifier s type.
their support for partial typing makes them highly deployable in js shops but taking full advantage of them still requires paying the annotation tax and slowly replacing anys with type annotations.
one of these languages is typescript ts a statically typed superset of js that transpiles to js allowing it to be used as a dropin replacement for js.
in ts the type system includes primitive types e.g.
number string user defined types e.g.
promise htmelement combinations of these and any.
ts comes with compile time type inference which yields some of the benefits of a static type system but is fundamentally limited in what it can soundly infer due to js features like duck typing.
consider 1we avoid calling these type systems gradual because they violate the clause of the gradual guarantee that requires them to enforce type invariants beyond those they get for free from js dynamic type system at runtime.deep learning type inference esec fse november lake buena vista fl usa the js code on the left hand side of figure the type for pmay be inferred from the call to createelement which returns an htmlelement .2on the other hand the type of csstext is almost certainly string but this cannot soundly be inferred from its usage here.3for such identifiers developers would need to add type annotations as shown in the ts code on the right.
.
type suggestion to the developer wishing to transition from the code on the left to that on the right in figure a tool that can recommend accurate type annotations especially where traditional type inference fails would be helpful.
this type suggestion task of easing the transition from a partially to a fully typed code base is the goal of our work.
we distinguish two objectives for type suggestion closed world type suggestion recommends annotations to the developer from some finite vocabulary of types e.g.
to add to declarations of functions or variables.
open world type suggestion aims to suggest novel types to construct that reflect computations in the developer s code.
as a first step to assisting developers in annotating their code we restrict ourselves to the first task and leave the second to future work.
specifically our goal is to learn to recommend the ca.
most common types from a large corpus of code including those shown in figure .
to achieve this we view the type inference problem as a translation problem between un annotated js ts and annotated ts.
we chose to base our work on ts because as a superset of js it is designed to displace js in developers ides.
thus a growing body of projects have already adopted it including well known projects such as angular and reactive extensions and we can leverage their code to train deeptyper .
we can use ts compiler to automatically generate training data consisting of pairs of ts without type annotations and the corresponding types for deeptyper s training.
here the fact that we are translating between two such closely related languages is a strength of our approach easing the alignment problem and vastly reducing the search space our models must traverse.4we train our translator deeptyper on ts inputs figure right then test it on js left or partially annotated ts files.
deeptyper suggests variable and function annotations consisting of return local variable and parameter types.
method to approach type inference with machine learning we are inspired by existing natural language processing nlp tasks such as part ofspeech pos tagging and named entity recognition ner .
in those tasks a machine learning model needs to infer the role of a given word from its context.
for example the word mail can be either a verb or a noun when viewed in isolation but when given context in the sentence i will mail the letter tomorrow the part of speech becomes apparent.
to solve this ambiguity nlp research has focused on probabilistic methods that learn from data.
2provided the type of ownerdocument isdocument which may itself require an annotation.
3grammatically it could e.g.
be number .
4vasilescu et al.
s work on deobfuscating js also successfully leverages machine translation between two closely related languages .tasks like these are amenable to sequence to sequence models in which a sequence of tokens is transformed into a sequence of types in our case .
specifically our task is a sequence of annotation tasks in which all elements stin an input sequence s1.
.
.snneed to be annotated.
therefore when approaching this problem with probabilistic machine learning the modeled probability distribution isp 0. .
.
n s0.
.
.sn where irepresents the type annotation ofsi.
in our case the annotations are the types for the tokens in the input where we align tokens that have no type e.g.
punctuation keywords with a special no type symbol.
although deriving type annotations has many similarities to pos tagging and ner it also presents some unique characteristics.
first our tasks has a much larger set of possible type annotations.
the widely used penn treebank project uses only distinct parts ofspeech tags for all english words while we aim to predict more than than types section .
.
furthermore nlp tasks annotate a single instance of a word whereas we are interested in annotating a variable that may be used multiple times and the annotations ought to be consistent across occurrences.
.
a neural architecture for type inference similar to recent models in nlp we turn to deep neural networks for our type inference task.
recurrent neural networks rnn have been widely successful at many natural language annotation tasks such as named entity recognition and machine translation .
rnns are neural networks that work on sequences of elements such as words making them naturally fit for our task.
the general family of rnns is defined over a sequence of elements s1.
.
.snasht rnn xst ht where xstis a learned representation embedding of the input element standht 1is the previous output state of the rnn.
the initial state h0is usually set to a null vector .
both xandhare high dimensional vectors whose dimensionality is tunable higher dimensions allow the model to capture more information but also increase the cost of training and may lead to overfitting.
as we feed input tokens to the network in order the vector x for each token is its representation while his the output state of the rnn based on both this current input and its previous state.
thus rnns can be seen as networks that learn to summarize the input sequence s1.
.
.stwith ht.
there are many different implementations of rnns in this work we use grus gated recurrent unit .
for a more extensive discussion of rnns we refer the reader to goodfellow et al.
.
in general translation tasks e.g.
english to french the length and ordering of words in the input and output sequence may be different.
rnn based translation models account for these changes by first completely digesting the input sequence then using their final state typically plus some attention mechanism to construct the output sequence token by token.
in our case however the token and type sequence are perfectly aligned allowing us to treat our suggestion task as a sequence annotation task also used for pos tagging and ner.
in this setting for every input token that we provide to the rnn we also expect an output type judgement.
since the rnn does not have to digest the full input before making type judgements using this precise alignment can yield better performance.esec fse november lake buena vista fl usa v. j. hellendoorn c. bird e. t. barr and m. allamanis var x var y x num num num embedding dim bi directional gru dim bi directional gru dim project to type vectors figure architecture of the neural network with an example input and output where connections between the layers at every token are omitted for clarity.
num is short for number and indicates a dummy type for non identifier tokens which have no type .
note how in deeptyper the two occurrences of xhave an additional custom connection to improve consistency in type assignment.
to a first approximation we can use an rnn for our sequence annotation task where we represent the type judgement context of the token stwith t ht.then to predict the type vector i.e.
a probability distribution over every type in the type vocabulary we use an output layer to project the hidden state onto a vector of dimension equal to the type vocabulary followed by a softmax layer to normalize it to a valid categorical probability distribution over types.
each component of the type vector is then pst exp t tr b exp t tr b where r is a representation learned for each type annotation t tr is the inner product of the two vectors and b a scalar bias for each annotation.
however this approach ignores all the relevant context to the right of st i.e.
information in st .
.
.sn.5for this reason we use an architecture called bidirectional rnns birnn which combines two rnns running in opposite directions one traversing the sequence forward and the other in reverse.
the representation of the context for a single token stbecomes the concatenation of the states of the forward left to right and reverse right to left rnns i.e.
we set tin equation to t hbi t h t h t the concatenation of the hidden state h t the forward rnn and h t the reverse rnn at position t. the network architecture we have described so far assumes that the annotations we produce for each token are independent of each other.
this tends to be true in natural language but is not the case for source code a variable may be used multiple times throughout the code but its true type remains the same as at its declaration.
if we were to ignore the interdependencies among multiple tokens our annotations might turn out inconsistent between usages of the same variable.
although the rnn might learn to avoid such inconsistencies in practice even long memory rnns such as grus have quite limited memory that makes it hard to capture such 5which is particularly important for this task consider annotating xinvar x .long range dependencies.6to address this problem we propose a consistency layer as an extension to the standard birnn where the context representation for the token stis t hbi t v t i v t hbi i where v t is the set of all locations that are bound to the same identifier as the one in location t. specifically we average over the token representations after the first bidirectional layer and combine these with the input to the second bidirectional layer as shown in figure .
by concatenating the output vector hbi twith the average representation of all the bound tokens we encourage the model to use long range information from all usages of the identifier.
thus the model learns to predict types based on both its sequentially local representation and the consensus judgement for all other locations where this identifier occurs.
we could restrict the non local part of equation to occurrences of the exact same variable only e.g.
by running a def use analysis but we found that it is very rare for two differently typed but same named variables to occur in the same file.
we chose instead to average over all identifiers with the same name as this can provide more samples per identifier.
figure shows the resulting network we call this model deeptyper .
design decisions.
our neural network encapsulates a set of design decisions and choices which we explain here.
using the birnn model allows us to capture a large potentially unbounded context around each token.
capturing a large context is crucial for predicting the type annotation of a variable since it allows our model to learn long range statistical dependencies such as between a function s type and its return statement .
additionally including the identifiers e.g.
variable names allows the model to incorporate probabilistic naming information to the type inference problem a concept that has not been well explored in the literature.
also it should be noted that viewing the input program as a sequence of tokens is a design decision that trades off the potential to use richer structural information such as asts dependency graphs for the advantage of using well understood models for sequence tagging whose training scales well with a large amount of data.
evaluation figure gives an overview of our experimental setup.
first we collect data from online open source projects section .
.
the second step is initializing and training the deep learner section .
finally we evaluate our approach against and in combination with a type inference engine and we discuss how to use the trained algorithm for general code fragments demonstrated through a web api.
we conclude this section with an overview of the hardware used and corresponding memory use and timing information.
.
objective as outlined in section the goal of this work is to suggest useful type annotations from a fixed vocabulary for javascript js and typescript ts code.
here we define useful type annotations as those that developers have manually added in the ts code and which we remove to produce our training data.
in ts there are 6attention mechanisms could be used to partially relieve this issue but this extension is left to future work.deep learning type inference esec fse november lake buena vista fl usa tokenscheckjsgithub api typescript compilertypes deep learnerweb api figure overview of the experimental setup consisting of three phases data gathering learning from aligned types and evaluation.
three categories of identifiers that allow optional7type annotations function return types function parameters and variables.
deeptyper learns to suggest these by learning to assign a probability distribution over types denoted a type vector to each identifier occurrence in a file.
to improve training we do not only learn to assign types to definition sites where the annotation would be added but to all occurrences of an identifier.
this helps the deep learner include more context in its type judgements and allows us to enforce its additional consistency constraint as described in section .
the model is presented with the code as sequential data with each token aligned with a type.
each token and type are encoded in their respective vocabularies see section .
as a one hot vector with a one at the index of the correct token type and zeros otherwise .
the type may be a deterministically assignable no type for tokens such as punctuation and keywords we do not train the algorithms to assign these.
given a sequence of tokens the model is tasked to predict the corresponding sequence of types.
at training time the model s accuracy is measured in terms of the cross entropy between its produced type vector and the true one hot encoded type vector.
at test time the model is tasked with inferring the correct annotations at the locations where developers originally added type annotations that we removed to produce our aligned data.
although the model infers types for all occurrences of every identifier because of the way it is trained we report our results on the true original type annotations both because this is the most realistic test criterion and to avoid confusion.
we evaluate the model primarily in terms of prediction accuracy the likelihood that the most activated element of the type vector is the correct type.
we focus on assigning non any types recall thatany expresses uncertainty about a type since those will be most useful to a developer.
we furthermore distinguish between evaluating the accuracy at all identifier locations including nondefinition sites as we do at training time and inferring only at those positions where developers actually added type annotations in our dataset.
for more details see section .
.
7here any is implicit if no annotation is added.
8in brief across all identifiers deeptyper reaches accuracies close to that of the compiler s type inference and a hybrid of the two was able to yield superior results.table statistics of the dataset used in this study.
category projects files tokens train held out test .
data data collection.
we collected the top starred open source projects on github that predominantly consisted of typescript code on february this is a similar approach to ray et al.
s study of programming languages .
each project was parsed with the typescript compiler tsc which infers type information possibly any for all occurrences of each identifier.
we removed all files containing more than tokens for the sequences to fit within a minibatch used in our deep learner.
this removed only a small portion of both files ca.
.
and tokens ca.
.
we also remove all projects containing only typescript header files which especially includes all projects from the definitelytyped eco system.
after these steps our dataset contains typescript projects with statistics listed in table .
our dataset was randomly split by project into training data held out or validation data and test data.
among the largest projects included were karma typescript a test framework for ts angular and projects related to microsoft s vs code.
we focus only on inter project type suggestion because we believe this to be the most realistic use of our tool.
that is the model is trained on a pre existing set of projects and then used to provide suggestions in a different new project that was not seen during training.
future work may study an intra project setting in which the model can benefit from project specific information which will likely improve type suggestion accuracy.
token and type vocabularies.
as is common practice in natural language processing we estimate our vocabularies on the training split and replace all the rare tokens in our case those seen less than times and all unseen tokens in the held out and test data with a generic unknown token.
note that we still infer types for these tokens even though their name provides no useful information to the deep learner.
to reduce vocabulary size we also replaced all numerals with all strings with s and all templates with a simple template none of which affects the types of the code.
the type vocabulary is similarly estimated on the types of the training data except that rare types again those seen less than times in the training data and unseen types are simply treated as any.
the number of tokens and types strongly correlates with the complexity of the model so we set the vocabulary cut off as low as was possible while still making training feasible in reasonable time and memory.
the resulting vocabularies consist of source tokens and types.
aligning data.
to create an oracle and aligned corpus we use the compiler to add type annotations to every identifier.
we then remove all type annotations from the ts code in order to create code that more closely resembles js code.
note that this does not always produce actual js code since ts includes a richer syntaxesec fse november lake buena vista fl usa v. j. hellendoorn c. bird e. t. barr and m. allamanis beyond just type annotations.
we create two types of oracle datasets from this translation all identifier data training we create an aligned corpus between tokens and types in which every occurrence of every identifier has a type annotation from the compiler.
this is the type of oracle data that we use for training.
this data likely includes more types than a developer would want to annotate since many could be inferred by the compiler.
gold annotation only data testing we align only the types that developers annotated with the declaration site where the annotation was added.
all other tokens are aligned with a no type .
this provides the closest approximation of the annotations that developers care about and serves as our test data.
.
experiments and models deeptyper .we study the accuracy and behavior of deep learning networks when applied to type inference across a range of metrics see section .
.
our proposed model enhances a conventional rnn structure with a consistency layer as described in section and is denoted deeptyper .
we compare this model against a plain rnn with the same architecture minus the consistency layer.
for our rnns we use dimensional token embeddings which are trained jointly with the model and two dimensional hidden layers implemented as a bi directional network with two grus each section .
this allows information to flow forward and backward in the model and improves its accuracy.
finally we use dropout regularization with a drop out probability of to the second hidden layer and apply layer normalization after the embedding layer.
as is typical in nlp tasks like this the token sequence is padded with start and end of sentence tags with no type as cues for the model.
we train the deep learner for epochs with a minibatch size of up to five thousand tokens requiring ca.
minibatches per epoch.
we use a learning configuration that is typical for these tasks in nlp settings and fine tuned our hyper parameters using our validation data.
we use an adam optimizer we initialize the learning rate to 3and reduce it every other epoch until it reaches 4where it remains stable we set momentum to e after the first minibatches and clip total gradients per sample to .
validation error is computed at every epoch and we select the model when this error stabilizes for both of our rnn models this occurred around epoch .
tsc checkjs.
in the second experiment we compare our deep learning models against those types that the typescript compiler tsc could infer after removing type annotations when also equipped with a static type inference tool for javascript named checkjs.9checkjs reads javascript and provides best effort type inference assigning any to those tokens to which it cannot assign a more precise type.
since tsc checkjs hereafter typically abbreviated checkjs has access to complete compiler and build information of the test projects while deeptyper is evaluated in an inter project setting our main aim is not to outperform checkjs but rather to demonstrate how probabilistic type inference can 9see checkjs by providing plausible verifiable recommendations precisely where the compiler is uncertain.
jsnice.
in our final experiment we compare the deep learner s performance with that of jsnice .
jsnice was proposed as a method to among others learn type annotations for javascript from dependencies between variables so we thought it instructive to compare and contrast performances.
a perfect comparison is not possible as jsnice differs from our work in several fundamental ways it focuses on javascript code only whereas our model is trained on typescript code with a varying degree of similarity to plain javascript it assigns a limited set of types includingnumber string object array a few special cases of object such as element anddocument and ?
unsure and it requires compiler information e.g.
dependencies scoping whereas our approach requires just an aligned corpus and is otherwise language agnostic.
.
metrics we evaluate our models on the accuracy and consistency of their predictions.
since a prediction is made at each identifier s occurrence we first evaluate each occurrence separately.
we measure the rank of the correct prediction and extract top kaccuracy metrics.
we evaluate the various models performances on real world type annotations the gold data .
unless otherwise stated we only focus on suggesting the non any types in our aligned datasets since inferring any is generally not helpful.
the rnn also emits a probability with its top prediction which can be used to reflect its confidence at that location.
this can be used to set a minimum confidence threshold below which deeptyper s suggestions are not presented.
thus we also show precision recall results when varying this confidence threshold for deeptyper .
finally we are interested in how consistent the model is in its assignment of types to identifiers across their definition and usages in the code.
let xbe the set of all type able identifiers that occur more than once in some code of interest.
for dt x n letdt x denote the number of types deeptyper assigns to x across all of its appearances.
ideally x x dt x indeed this is a constraint that standard type inference obeys.
like all stochastic approaches deeptyper is not so precise.
let y x dt x x x .
then the type inconsistency measure of a type inference approach like deeptyper that does not necessarily find the principal type of a variable across all of its uses is y x .
.
experimental setup the deep learning code was written in cntk .
all experiments are conducted on an nvidia geforce gtx ti gpu with 11gb of graphics memory in combination with an core intel i7 cpu with 32gb of ram.
our resulting model requires ca.
500mb of ram to be loaded into memory and can be run on both a gpu and cpu.
it can provide type annotations for reasonably sized files in well under seconds.
our algorithm is programmatically exposed through a web api figure that allows users to submit javascript or typescript files and annotates each identifier with its most likely types subject to adeep learning type inference esec fse november lake buena vista fl usa figure a screen shot of our web interface on the example from figure .
table accuracy results of various models where deeptyper includes the proposed consistency layer section and na ve assigns each identifier the mle distribution of types given that identifier from the training data.
model top k accuracy gold gold na ve .
.
plain rnn .
.
deeptyper .
.
confidence threshold.
all our code for training and evaluating deeptyper is released on results we present our results in three phases as per section .
.
we first study how well deep learning algorithms are suited for type inference in general and study the notion of consistency specifically.
then we compare deeptyper s performance with that of the typescript compiler plus checkjs showing furthermore how the models can be complementary.
finally we present a comparison and combination on plain js functions with jsnice which tackles a similar if narrower task.
.
deep learning for type inference we first show the overall performance of the deep learning models on the test data including both the plain rnn and our variant deeptyper which is enhanced with a consistency layer.
table shows the prediction accuracy top and of the true types w.r.t.
the models in the test projects on the gold dataset section .
.
we include a na ve model which assigns each identifier the type distribution that it has at training time.
this model achieves an acceptable accuracy without accounting for any identifier context giving us a notion of what portion of the task is relatively simple.
xuet al.
report a similar result for python code although we stress that this is not an implementation of their model see section .
deeptyper substantially outperforms it by including contextual information and achieves a top accuracy of nearly and top accuracy of over across the gold dataset.
.
.
consistency.
in table deeptyper yields higher prediction accuracy than the plain rnn.
as we stated in section we qualitatively found that the plain rnn model yielded poor consistency between its assignments of types to multiple usages of the same identifier.
we quantify this concern with the inconsistency metrictable accuracy on the most common and all other types with any included for reference type count top k accuracy top top top total .
.
others total .
.
any .
.
included only for reference suggesting any is typically not helpful to developers.
described in section .
.
by this metric the plain rnn assigns an inconsistent type .
of the time.
our consistency layer has the effect of taking into account the average type assignment for each identifier in a function and achieves a modest but significant consistency error reduction of around percentage points to .
.
importantly it does not accomplish this by sacrificing performance as it might by gravitating to common types but instead slightly boosts prediction accuracy as shown above.
this shows promise for further investigation into adding global information to these models section .
thus we use the deeptyper model in our experiments going forward.
.
.
performance characteristics.
a few common types account for most of the type annotations in the typescript data.
we study the discrepancies between the predictability of the most common types vs. the ca.
other types in table .
we also include prediction statistics of the any type for reference which was by far the most common type in the training data 10but was substantially less common among the real annotations shown here.
since all identifiers are implicitly typed as any unless another type is provided recommending this type is not clearly useful.
however developers do evidently explicitly annotate some identifiers as any so that accuracy on this task may still be useful for a type suggestion tool this deserves further investigation.
excluding any the top types account for most of the typed tokens.
among the most common types are the primitives string number andboolean as well as several object types array promise andhtmlelement .
as can be seen predicting the rarer types is substantially harder for deeptyper but it manages a usable top accuracy nonetheless.
this is especially true at locations where the model is most confident as we discuss next.
.
.
recommendation.
the deep learning algorithm emits a probability for each type assignment which allows the use of a threshold to determine which suggestions are likely to be correct section .
.
figure shows the trade off in precision and recall when varying this threshold.
precision first exceeds at a threshold of yielding a recall rate of ca.
.
at a threshold of precision exceeds at a still respectable recall rate of ca.
.
.
at this level deeptyper could add more than of the ca.
annotations we extracted across the test projects with very high precision.
10this indicates that a great many identifiers could not be typed more specifically by the compiler or were too rare to be included in the vocabularyesec fse november lake buena vista fl usa v. j. hellendoorn c. bird e. t. barr and m. allamanis .
precision recall figure recall vs. precision of deeptyper as a recommender on the test data subject to probability thresholds of the top suggestion that reflect the model s confidence.
.
conventional type inference we compare our results with those obtained by running the typescript compiler with checkjs see section .
on each project in the test corpus.
our main interest is a hybrid model when the compiler has access to each test project s complete build information its type judgements are sound although checkjs may contribute a small number of unsound heuristic predictions .
the cases where it is unsure and defaults to any are locations where the deep learner may be able to contribute since it understands what types are natural in various locations.
thus the hybrid model first assigns each variable its checkjs type.
when checkjs assigns any to an identifier and deeptyper is sufficiently confident in its suggestion the hybrid switches to deeptyper s suggested type.
per figure we use confidence thresholds of and .
to achieve a balance between high precision preferred in this setting and recall.
we also report as a percentage of all prediction points how often deeptyper correctly changes an any into a more specific type hits and how often deeptyper incorrectly suggests a type when checkjs was either correct or had soundly resorted to any misses .
crucially these misses arenotsources ofunsound ness!
in a proper suggestion tool any suggested type annotation can first be passed through the type checker and ruled out if it is unsound.
although this feedback loop was too costly to run for our automated evaluation we manually investigated several incorrect annotations and found that ca.
half of these could be ruled out by the compiler as unsound whereas the remainder was sound even if incorrect.
this includes cases where deeptyper s type was too broad htmlelement where htmlbuttonelement was expected or different from what the user expected but correct in the context like csstext number would be in figure .
thus we conclude that any tool based on our model need not introduce any unsound annotations and the misses column overstates how many incorrect annotations a user would actually encounter when also employing a type checker.
nonetheless the balance between hits and misses gives an indication of the precision effort trade off at various thresholds.
the top accuracy checkjs gives only one suggestion for the three models is shown in table which for reference also showstable accuracy of the three models where dt is deeptyper and cj is the typescript compiler with checkjs enabled on both datasets.
hits reflects when dt overrules cj and improves accuracy misses where it worsens accuracy.
setting specifies whether only checkjs any cases or all types can be overruled by deeptyper and the minimum confidence for deeptyper to act.
results for cj and dt by themselves are shown independent of threshold for clarity and are thus identical in their columns .
setting accuracy hits misses cj dt hybrid any .
.
.
.
.
any idem.
idem.
.
.
.
any .
idem.
idem.
.
.
.
all idem.
idem.
.
.
.
all idem.
idem.
.
.
.
all .
idem.
idem.
.
.
.
a second set of results where deeptyper is allowed to alter all type judgements not just anys when it is sufficiently confident.
although the models proved complementary on our training data checkjs could not to beyond deeptyper here on the real developer annotations at test time.
this strongly indicates that developers add annotations predominantly in those places where the type inference tool could not infer the correct type.
it also stresses the relevance of our tool in those cases where developers would need it most it yields a top accuracy of over and referring back to table a top accuracy of over .
furthermore the hybrid model proves useful at higher confidence rates by reducing deeptyper s incorrect types at a threshold deeptyper can contribute more than types with over precision to checkjs own type inference!
allowing deeptyper to correct all types vs. just any does not appear to be particularly more rewarding in terms of hits misses trade off.
in all cases setting a higher threshold tends to improve the true positive rate of deeptyper which is in line with the precision recall trade off seen earlier.
since developers migrating their code are most likely to appreciate very precise suggestions first deeptyper has the potential to be a cost effective aide.
.
comparison with jsnice jsnice was introduced as an approach for among others type inference on javascript using statistics from dependency graphs learned on a large corpus .
as discussed in section .
its approach is complementary to ours so we thought it instructive to compare their performance with that of deeptyper as well.
note that we are again using the original deeptyper model here not the hybrid model from the previous section.
because jsnice is available to use via a web form we manually entered javascript functions and recorded the results.
we selected javascript functions uniformly at random from public projects on github that were in the top javascript projects ranked by number of stars similar to ray et al.
.
to avoid trivial functions we selected functions that take at least one parameter and that return a value or have at least one declared variable indeep learning type inference esec fse november lake buena vista fl usa table comparison of deeptyper jsnice and hybrid of both across thirty randomly selected javascript functions.
correct partial incorrect unsure jsnice .
.
.
.
deeptyper .
.
.
.
deeptyper .
.
.
.
deeptyper .
.
.
.
hybrid .
.
.
.
hybrid .
.
.
.
hybrid .
.
.
.
their body.
thus each function requires two type annotations at the very least.
because the evaluation had to be performed manually we examined thirty javascript functions.11for each function we manually determined the correct types to use as an oracle for evaluation and comparison assigning any if no conclusive type could be assigned.
as a result we identified annotations on function return types local variables parameters and attributes of which were clearly not any types.
again we focus on predicting only the non any types since these are most likely to be helpful to the user.
cases in which jsnice predicted ?orobject and cases where deeptyper predicted any or was not sufficiently confident are all treated as unsure .
we again show results for various confidence thresholds for deeptyper across a slightly lower range than before to better match the unsure rate of jsnice and include another hybrid model in which deeptyper may attempt to correct any cases in which both jsnice was uncertain or did not annotate a type at all and deeptyper is sufficiently confident.
the results are shown in table .
at the lowest threshold deeptyper gets both more types correct and wrong than jsnice whereas at the highest threshold it makes no mistakes at all while still annotating more than one third of the types correctly.
jsnice made one mistake in which it assigned a type that was too specific given the context.12we also count partial correctness in which the type given was too specific but close to the correct type.
this includes cases in which both jsnice anddeeptyper suggest htmlelement instead of element .
overall deeptyper s and jsnice s performances are very similar on this task despite deeptyper having been trained primarily on typescript code using a larger type vocabulary and not requiring any information about the snippet beyond its tokens.
the two approaches are also remarkably complementary.
jsnice is almost never incorrect when it does provide a type but it is more often uncertain not providing anything whereas deeptyper makes more predictions but is incorrect more often than jsnice.
a hybrid approach in which jsnice is first queried and deeptyper is used if jsnice cannot provide a type shows a dramatic improvement over each approach in isolation and demonstrates that jsnice and deeptyper work well in differing contexts and for differing types.
when using a confidence threshold the hybrid model boosts the accuracy by .
points .
to .
while introducing 11the source of these functions and the functions themselves will be released after anonymity is lifted 12we found several more such cases among variables who s true type was deemed any and are thus not included in this table.no additional incorrect or partially correct annotations.
at the threshold the hybrid model is more than points more likely to be correct than either model separately while introducing fewer errors than deeptyper would by itself.
qualitatively we find that deeptyper particularly outperforms jsnice when the type is intuitively clear from the context such as for csstext in figure .
it expresses high confidence and corresponding accuracy in tokens who s name include cues towards their type e.g.
name for string and or are used in idiomatic ways e.g.
concatenation with another string or invokingelement related methods on htmlelement related types .
jsnice often declares uncertainty on these because of a possibly ambiguous type e.g.
string concatenation does not imply that the right hand argument is a string and other classes may have declared similarly named methods .
vice versa when jsnice does infer a type it is very precise whereas deeptyper often gravitates to a subtype or supertype especially any if a variable is used in several far apart places of the true type jsnice was highly accurate when it did not declare uncertainty and was able to include information such as dataflow connections from across the whole function regardless of size.
altogether our results demonstrate that these two methods excel at different locations with jsnice benefiting from its access to global information and deeptyper from its powerful learned intuition.
discussion .
learning type inference type inference is traditionally an exact task and for good reason unsound type inference risks breaking valid code violating the central law of compiler design.
however sound type inference for some programming languages can be greatly encumbered by features of the language design such as eval in js .
although the typescript compiler with checkjs achieved good accuracy in our experiments in which it had access to the full project it could still be improved substantially by probabilistic methods particularly at the many places where it only inferred any.
with partial typing now an option in languages such as typescript and python there is a need for type suggestion engines that can assist programmers in enriching their code with type information preferably in a semiautomatic way.
a key insight of our work is that type inference can be learned from an aligned corpus of tokens and their types and such an aligned corpus can be obtained fully automatically from existing data.
this is similar to recent work by vasilescu et al.
who use a javascript obfuscator to create an aligned corpus of real world code and its obfuscated counter part which can then be reversed to learn to deobfuscate although they did not approach this as a sequence tagging problem.
this type of aligned corpus e.g.
text annotated with parse tags named entities is often a costly resource in natural language processing requiring substantial manual effort but comes all but free in many software related tasks primarily because they involve formal languages for which interpreters and compilers exist.
as a result vast amounts of training data can be made available for tasks such as these to great benefit of models such as the deep learners we used.esec fse november lake buena vista fl usa v. j. hellendoorn c. bird e. t. barr and m. allamanis .
strengths and weaknesses of the rnn we have shown that rnn based models can learn a remarkably powerful probabilistic notion of types through differentiable type vectors.
this probabilistic perspective on types is a necessity for training these models and raises an interesting challenge at once the models can deliver a highly accurate source of type guesses while at the same time not being able to make any guar antees regarding the soundness of even its most confident annotations.
for instance if the rnn sees the phrase var x it may deem the clearly correct type number for x highly accurate but not truth i.e.
assign it a probability very close to .
a hybrid approach provides a solution when deeptyper offers plausible and natural type annotation suggestions the type checker can verify these thus preserving soundness similar to how a programmer might annotate code.
it is also interesting to ask if we can teach deep learning algorithms some of these abilities.
provable correctness is not out of the scope of these models as was demonstrated for neural program inference using recursion .
deeptyper s probabilistic nature also leads to an intriguing kind of type drift also visible in our web tool in which the probabilities in a variable s type vector change throughout its definition and use in the code even though its true type is fixed.
we partially mitigated this limited awareness of the global accuracy of its type assignments by equipping the model with information that is lexically far away and saw gains in consistency and performance.
still a substantial number of consistency errors remain allowing room for improvement over the deep learners used in this work if global and local optimization can be balanced.
such a combination need not come from deep learning alone the global model may be a symbiosis with a static type checker or a method such as conditional random fields .
.
extensions the aligned corpus in our work is one between typescript code and the types for each identifier in this code.
as such our work only scratches the surface of what this free rosetta stone could give!
type inference is only one step in the compilation process and many other parts of typescript s enhancements over javascript could be learned including type definitions classes public private modifiers etc.. even fully transpiling typescript to javascript can be used to create an aligned corpus although no longer token aligned and with a fair degree of boiler plate code that we may in due time be able to exploit to learn to convert entire files.
this methodology is not bound to our current language either an obvious extension is to partially typed python code but similar tasks in many languages e.g.
inferring nullity may well be highly amenable to a comparable approach.
related work type inference is a widely studied problem in programming language research.
inferring types for dynamic languages has become an important research area in light of the widespread use of languages such as javascript and python and recent moves to allow partial typing of these .
probabilistic type inference i.e.
the use of probabilistic reasoning for inferring types has received recent attention.
jsnice infersprimitive types of javascript code by learning from a corpus.
jsnice builds a dependency network among variables and learns statistical correlations that predict the type.
in contrast to this work our deep learner considers a much wider context than is defined by jsnice s dependency network and aims to predict a larger set of type annotations.
the work of xu et al.
uses probabilistic inference for python and defines a probabilistic method for fusing information from multiple sources such as attribute accesses and variable names.
however this work does notinclude a learning component but rather uses a set of hand picked weights on probabilistic constraints.
both these works rely on factor graphs for type inference while in this work we avoid the task of explicitly building such a graph by directly exploiting the interaction of a strong deep neural network and a pre existing type checker.
applying machine learning to source code is not a new idea.
hindle et al.
learned a simple n gram language model of code to assist code completion.
raychev et al.
developed a probabilistic framework for predicting program properties such as types or variable names.
other applications include deobfuscation coding conventions and migration .
vasilescu et al.
specifically employ machine learning to an aligned corpus within the same language using an obfuscator to learn de obfuscation of javascript .
their work is closely related to ours although our approach works both within typescript and can enhance javascript code into typescript code because the latter is a superset of the former.
furthermore our work learns to translate information between domains from tokens to their types whereas de obfuscation is only concerned with translation between identifiers.
conclusion our work set out to study to what extent type annotations can be learned from the underlying code and whether such learners can assist programmers to lower the annotation tax.
our results are positive we showed that deep learners can achieve a strong probabilistic notion of types given code that extends across projects and to both typescript and plain javascript code.
we also highlight their present flaws and hope to inspire research into further improvements.
even more promising is that deeptyper proved to be complementary to a compiler s type inference engine on an annotation task even when the latter had access to complete build information.
jointly they could predict thousands of annotations with high precision.
our tool is also complementary with jsnice on plain javascript functions which shows that our model is learning new different type information from prior work.
our findings demonstrate potential for learning traditional software engineering tasks type inference specifically from aligned corpora.