re factoring based program repair applied to programming assignments y ang hu the university of texas at austin huyang utexas.eduumair z. ahmed national university of singapore umair comp.nus.edu.sgsergey mechtaev university college london s.mechtaev ucl.ac.uk ben leong national university of singapore bleong comp.nus.edu.sgabhik roychoudhury national university of singapore abhik comp.nus.edu.sg abstract automated program repair has been used to provide feedback for incorrect student programming assignments since program repair captures the code modification needed to makea given buggy program pass a given test suite.
existing student feedback generation techniques are limited because they either require manual effort in the form of providing an error model or require a large number of correct student submissions to learn from or suffer from lack of scalability and accuracy.
in this work we propose a fully automated approach for generating student program repairs in real time.
this is achievedby first re factoring all available correct solutions to semantically equivalent solutions.
given an incorrect program we match the program with the closest matching refactored program based on its control flow structure.
subsequently we infer the input output specifications of the incorrect program s basic blocks from the executions of the correct program s aligned basic blocks.
finally these specifications are used to modify the blocks of the incorrect program via search based synthesis.
our dataset consists of almost real life incorrect python program submissions from students for an introductory pro gramming course at a large public university.
our experimental results suggest that our method is more effective and efficient than recently proposed feedback generation approaches.
about of the patches produced by our tool refactory are smaller than those produced by the state of art tool clara and can beproduced given fewer correct solutions often a single correct solution and in a shorter time.
we opine that our method is applicable not only to programming assignments and could be seen as a general purpose program repair method that can achieve good results with just a single correct reference solution.
index terms program repair programming education software refactoring i. i ntroduction program repair is an emerging technology that seeks to rectify program errors automatically thereby meeting a cor rectness criterion such as passing a test suite.
besides improving programmer productivity this technique can be applied to programming education.
particularly program repair has been applied to automated grading and providing hints about program errors .
in this work we propose a repair method where an incorrect program can be repaired with the help of this work was done by the first author at national university of singapore.
corresponding author.one or more correct reference solutions.
while our approach is general purpose in our experiments we focus on generating repair based feedback for incorrect programming assignments.
program repair has previously been used to provide feedback on incorrect student submissions for programming assignments .
the programming assignments are usuallysegments of code so the limited scalability of existing program repair techniques is not a concern.
however it has been observed from a corpus of programming assignments that student submissions are often severely incorrect .
this is in stark contrast to the competent programmer hypothesis that assumes code bases are largely correct.
since programming assignments are written by novice programmers and can be substantially erroneous they are a testbed to validate the effectiveness of program repair techniques.
since the submissions for programming assignments are often incorrect the search space of edits to be navigated for program repair can be verylarge even though the program might be small.
existing systems that repair incorrect programming assignments have significant drawbacks because of the manual effort involved underlying assumptions about the availability of correct solutions and scalability or accuracy concerns.
approaches like autograder assume the availability of anerror model that has to be provided manually.
efforts like sk p rely on neural networks to correct programs and suffer from low precision a recent work has extended neural reasoning with symbolic analysis .
however the accuracy of repairs typically remains low in such efforts.
refazer learns program transformation schema from past submissions and its performance critically depends on the quality and quantity of corpus available.
the recent works of clara and sarfgen compare an incorrect assignment with an available correct assignment.
such approaches assume the availability of a large number and diversity of correct solutions.
however this assumption often does not hold in practice e.g.
when a newly crafted assignment is given by an instructor.
technical contribution the main technical contribution of this paper is a fully automated program repair method for repairing incorrect student submissions for programming assignments.
while our technique can exploit the availability ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxb sf ohjoffsjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of a large number of correct solutions to perform better we only assume and require one correct reference solution.
ourapproach is to use re factoring rules to generate a correct solution with the same control flow as the incorrect program.
since the buggy program and the re factored correct programpossess the same or similar control flow we compare their basic blocks and generate candidate variable mappings between the two programs based on dynamic observations overtest executions and static analysis.
given such a variable mapping we formulate the program repair problem as judiciously synthesizing expressions at selected basic blocks to meet the given correctness criterion such as passing a test suite .
this synthesis problem is solved by efficient search based synthesis where a large space of expressions is efficiently navigated to construct minimal repairs.
the expressions considered for repairs of the basic blocks are obtained from expressiontemplates or by mutating existing expressions.
our refactory tool implementation of the above approach has been made available at conceptual contribution and results if we envision the feedback generation problem through means of automated pro gram repair as one of search space construction and traversal with the search space capturing the possible edits of the buggy program our solution enables a novel way to present and understand this search space.
this is the main conceptual contribution of the work and we believe this also leads to more superior experimental results as evidenced by our repair tool for actual python programs from a real student submission data set.
by separating the control flow matching obtained via refactoring from data flow matching achieved via search based synthesis we can construct small legible program repairs to be used as feedback to the students.
we evaluate our approachon a large data set of buggy student programs that was curated from five different python assignments offered during a first year university course credited by students.
our tool refactory achieves a higher repair rate smaller patch size and less overfitting when compared to state of the art tools such asclara .
to verify the generality of our approach and crafted refactoring rules we randomly sample an additional six assignments containing buggy student programs and observe similar results section vi .
in addition to the practical utility of our technique in feedback generation we believe that our viewpoint of cleanly partitioning the search space of editsby separating control flow matching from expression synthesis can be useful for automated program repair.
ii.
o verview fig.
gives a high level overview of our approach.
our approach takes three inputs a test suite t a buggy program pb and one or more correct programs c. our approach includes three phases which are elaborated in the following.
phase .
refactoring given a set of refactoring rules we conduct software refactoring on correct programs c t o generate additional correct programs with new control flow structures.
for example fig.
2a shows a correct program for the programming assignment sequential search which g17 g437 g336 g336 g455 g3 g87 g396 g381 g336 g396 g258 g373 g18 g381 g396 g396 g286 g272 g410 g3 g87 g396 g381 g336 g396 g258 g373 g400 g17 g367 g381 g272 g364 g3 g68 g258 g393 g393 g349 g374 g336 g87 g258 g410 g272 g346 g17 g367 g381 g272 g364 g3 g90 g286 g393 g258 g349 g396 g100 g286 g400 g410 g882 g94 g437 g349 g410 g286 g94 g410 g396 g437 g272 g410 g437 g396 g286 g3 g68 g258 g410 g272 g346 g349 g374 g336 g94 g410 g396 g437 g272 g410 g437 g396 g286 g3 g4 g367 g349 g336 g374 g373 g286 g374 g410 g94 g410 g396 g437 g272 g410 g437 g396 g286 g68 g437 g410 g258 g410 g349 g381 g374 g90 g286 g296 g258 g272 g410 g381 g396 g349 g374 g336 g115 g258 g396 g349 g258 g271 g367 g286 g3 g68 g258 g393 g393 g349 g374 g336 g94 g393 g286 g272 g349 g296 g349 g272 g258 g410 g349 g381 g374 g3 g47 g374 g296 g286 g396 g286 g374 g272 g286 g17 g367 g381 g272 g364 g3 g87 g258 g410 g272 g346 g3 g94 g455 g374 g410 g346 g286 g400 g349 g400 g94 g437 g272 g272 g286 g400 g400 g38 g258 g349 g367 fig.
overview of our approach outputs how many numbers in a sorted number sequence seq are smaller than x. to generate a correct program with new control flow we mutate the control flow of the correctprogram by adding an empty else branch to an ifbranch.
the refactored correct program is shown in fig.
2b.
phase .
structure alignment we perform structure matching for finding refactored correct programs which have the same control flow structure with the buggy program pb.i f we cannot find such programs pbmay have bugs in its control flow.
to fix such bugs we conduct structure mutation which edits the control flow structure of pbto that of closest refactored correct program in terms of tree edit distance.
phase .
block repair among all correct programs which have the same control flow structure with the buggy program we search for the correct programs which are the top k closestto the buggy program p b we set k 5in our experimental evaluation .
for any of these top k closest programs if we can construct a patch passing the given test suite t w eh a v e succeeded in repairing and hence generating feedback.
phase .
block mapping we build a mapping between basic blocks in a correct program pcand those of pbbased on the graph isomorphism of the control flow graph of pcand pb.
for example consider the buggy program in fig.
2c and the refactored correct program in fig.
2b where line are different basic blocks although line in the buggy program isempty we regard it as an empty basic block .
assume that b c i is the basic block in line iin the refactored correct program and bb iis the basic block in line iin the buggy program.
based on graph isomorphism we can get bi c mapsto bi b i .
phase .
v ariable mapping we build a variable mapping between the correct program pcand the buggy program pb using dynamic equivalence analysis dea and define use analysis dua .
in dea we collect the trace of each variable when running the correct and the buggy programs and then map two variables if they take the same values in the sameorder when running the same test.
for variables that are not mapped by dea we apply dua which maps two variables if the blocks where the first variable is defined used corresponds authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1def search x seq for iin range len seq if x seq return i return len seq a a correct program1def search x seq for iin range len seq if x seq return i else pass return len seq b a refactored correct program1def search e lst for jin range len lst if e l s t return j else return len lst c a buggy program1def search e lst for jin range len lst if e lst return j else pass return len lst d a fixed program fig.
example programs of the sequential search programming assignment from our dataset.
to the blocks where the second variable is defined used.
to illustrate these approaches consider building a variable mapping between the buggy program in fig.
2c and the refactored correct program in fig.
2b using the tests search and search .
table ia and table ib show all the variable traces collected using dea.
since the traces of eand xare the same and the traces of lst and seq are the same we get a variable mapping e mapsto x lst mapsto seq .
note that jand iare not mapped by dea because their traces are different.
then we execute dua that identifies that jand iare defined in line and used in line and line and the basic blocks in line in the buggy program correspond to the basic block in line in the correct program.
thus we map jtoi and finally obtain the variable mapping e mapsto x lst mapsto seq j mapsto i .
phase .
specification inference we generate a specification for each basic block in the buggy program pbby collecting inputs and outputs of each basic block in the correct program and using the variable mapping to translate them into the inputs and expected outputs of each basic block in the buggy program.
for instance consider the buggy basic block e lst in the buggy program.
we collect the inputs and outputs of its corresponding basic block x seq in the refactored correct program table ic .
then we replace the variables using the variable mapping e mapsto x lst mapsto seq j mapsto i to generate the specification of e lst .
phase .
block patch synthesis we use the input output specification derived in the previous step to check the correct ness of each basic block in the buggy program.
in the buggy program shown in fig.
2c the basic blocks in lines and do not satisfy their input output specifications and hence we deem them to be in need for repair.
we attempt to generate a patch for each incorrect basic block in the buggy program.
if the basic block in p bis empty we fix it based on the variable mapping and its corresponding basic block in the correct program pc.
for example consider the buggy basic block in line which is an empty basic block.
its corresponding basic block in the refactored correct program is return len seq .
based on the variable mapping e mapsto x lst mapsto seq j mapsto i w e replace the empty basic block in line of the buggy programwith a fixed basic block return len lst .
if the basic block in pbis not empty while its corresponding basic block in pcis empty we fix it by making it empty.
for example consider the incorrect basic block in line .
itscorresponding basic block in the refactored correct program is pass which is a key word to show it is an empty basic block.
we fix the basic block in line of the buggy program to pass .
if the basic block in pband its corresponding basic block inpcare both non empty then we synthesize a patch for the buggy basic block using its specification.
given a set of suspicious lines in a buggy basic block we insert holes to produce a partial program.
then we perform enumerativesynthesis with test equivalence analysis to fill the holes in the partial program.
we use two heuristics to generate expression candidates.
first we utilize expression templates i.e.
syntax patterns of expressions in correct programs.
for example given the expression x seq in the refactored correct program we can extract an expression template v0 v1 where v0 v1 v2are free variables.
using this template we can generate a candidate e lst .
we also generate expression candidates by mutating operators or variables of the expressions in the buggy program.
for example given the expression e lst in the buggy program we generate candidates e lst e lst e lst and j lst .
once the search space of candidate expressions is constructed we traverse them efficiently using an approach based on test equivalence analysis .
in this approach the candidate expressions are grouped together if they behave identically on the given input output examples these are the specification we derived earlier .
such an approach greatly contributes to the scalability of our technique since it helps to avoid traversing and checking the candidate patches one by one.
after generating patches for each basic block we combine them into a global patch and validate its correctness via the test suite.
fig.
2d shows the fixed program.
iii.
r efactoring and structure muta tion in this section we introduce refactoring rules for mutating the control flow structure of existing correct solutions to generate new semantically equivalent correct solutions with different control flow structures.
this step is necessary since the accuracy of repairing a given buggy program depends onfinding a correct program with similar control flow structure.
we designed generic rules based on the observation that the same algorithm can have syntactically dif ferent implementations.
for example although the two programs in fig.
behave equivalently and contain the same basic blocks the control flow structure of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
test inputs e lst j search search a v ariable traces of the buggy programtest case x seq i search mapsto search b v ariable traces of the correct programinputoutputx seq i false true3 true c inputs and outputs of x seq t able i motivating example of our approach.
1def func x if x return return a control flow cfx1def func x if x return else return b control flow cfy fig.
semantically equivalent programs with different control flow structures.
fig.
3a given as func start i fstart i fend func end differs from the control flow structure of fig.
3b given as func start i fstart i fend else start else end func end .
since there is potential to generate infinitely many correct variants using our refactoring rules we guide the search for closest refactored program using the following heuristic.
thecorrect programs are ranked based on their edit distance from the given buggy program.
rules are repeatedly applied on the closest correct program to generate new correct programs untila correct program with a matching control flow is found or a predefined maximum depth is reached or a timeout occurs.
as observed in our dataset of incorrect programs section v of them do not have a matching control flow structure in the correct submissions.
thus existing techniques such as sarfgen which rely on exact control flow matches cannot repair these programs.
we define a total of bi directional refactoring rules divided into five different categories which are listed in fig.
.
these rules transform control flow structures of our correct student programs after which only less than of the incorrect programs lack a matching correct program.
for these remaining incorrect programs structure mutation is used to borrow the missing control flow structure from the closest matching correct program.
a. existing conditional transformations this category of rules transform existing conditional statements.
the rules are presented in the form of abstract syntax tree ast transformations.
successor statements to a conditional jump the rule r a1in fig states that the block of statements swhich succeeds a conditional jump such as break continue return can occur either as a successor node to the ifblock or inside an else branch to the ifblock .
consider our earlier example listed in fig.
.
the program in fig.
3a respectively fig.
3b can be mutated to the program in fig.
3b resp.
fig.
3a on application of refactoring rule ra1 since the control flow of program cfx resp.
cfy matches with the control flow of rule cfa resp.
cfb .
conditional statement with conjunction anifstatement with the condition being a conjunction of c1and c2 can be rewritten as a nested if structure containing the conditions c1and c2individually using rule ra2.
b. new conditional transformations these set of rules introduce additional guards either around arbitrary statements or around existing conditionals.
introduce new ifconditionals in this rule rb1 w e introduce three types of ifconditional blocks.
fig.
4f adds a trivially true conditional guard around an arbitrary node s. fig.
4g introduces a trivially false conditional guard around an arbitrary block b .
fig.
4h introduces an arbitrary condition c 1around a pass no op statement.
the arbitrary block b respectively condition c are placeholders which can match and copy any corresponding block resp.
condition of incorrect program during the block mapping phase of our approach described later in section iv a. introduce new elif else branch the rule rb2introduces elif and else branching statements to an existing if conditional statement.
fig.
4j adds a trivially false elif branch containing arbitrary block b .
fig.
4k introduces an arbitrary c 1conditional elif branch around a pass no op statement.
fig.
4l adds an else branch containing pass statement.
c. loop guards these set of rules deal with introducing additional guards surrounding an existing loop structure.
introduce guard around for loop programs containing for statement which loops over an iterator such as list can be mutated into a new program structure by introducing guards around the loop targeting the case when iterator is empty fig 4m to fig 4n or non empty fig 4m to fig 4o .
introduce guard around while loop similar to previous rule guards can be introduced in programs which loop over an iterator using while loop targeting the case when iterator is empty fig 4p to fig 4q or non empty fig 4p to fig 4r .
d. while loop transformations these set of rules replace while loop structure with an equivalent conditional jump statement or vice versa.
conditional break inside while loop a program which loops until a condition c1is satisfied can be refactored into another program which loops indefinitely with a c1 conditional break instruction inside the loop s body .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
category a existing conditional transformations predecessor p ifcondition c basic block b1 jump instruction j1 successor s a predecessor p ifcondition c basic block b1 jump instruction j1 else successor s b rule ra1 successor statements to a conditional jump.predecessor p ifcondition c c2 block b1 successor s c predecessor p ifcondition c ifcondition c block b1 successor s d rule ra2 conditional expression with conjunction.
category b new conditional transformations p s e p iftrue s f p iffalse b 1s g p ifc pass s h rule rb1 introduce new ifconditionals.p ifc1 b1 s i p ifc1 b1 elif false b 2s j p ifc1 b1 elif c pass s k p ifc1 b1 else pass s l rule rb2 introduce new elif else branch.
category c loop guards p for iini1 b1 s m p iflen i1 for iini1 b1 s n p iflen i1 pass else for iini1 b1 s o rule rc1 introduce guard around for loop.p while i len i1 b1 s p p iflen i1 while i len i1 b1 s q p iflen i1 pass else while i len i1 b1 s r rule rc2 introduce guard around while loop.
category d while loop transformations p while c1 b1 s s p while true ifnot c break b1 s t rule rd1 conditional break inside while .p while c1 b1 return r1 s u p ifc1 b1 return r1 s v rule rd2 unconditional return inside while .p while c1 b1 break s w p ifc1 b1 s x rule rd3 unconditional break inside while .
category e loop unrolling predecessor p for iini1 b1 successor s y predecessor p for iinslice i len i1 b1 for iinslice i len i1 len i1 b1 successor s z rule re1 split a for loop by iterator slicing.
fig.
list of refactoring rules authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
unconditional return inside while loop awhile loop which contains an unconditional return jump can be replaced with an equivalent ifconditional statement since the block of statements inside the loop will be executed only once on successful satisfaction of the loop guard.
unconditional break inside while loop similar to the previous rule a while loop which contains an unconditional break jump can be replaced with an equivalent if conditional statement without the break statement .
e. loop unrolling iterator slicing afor loop iterating over a sequence can be split into two loops that iterate over two distinct sets of consecutive elements .
the operator slice i i1 i2 denoted as i returns a subsequence of the elements starting of iat index i1until index i2.
f .
structure mutation given a buggy program pb we first search for a program pc from the set of correct student submissions and their refactored variants such that pchas the same control flow structure as pb.
if no such match is found we attempt structure mutation that modifies the control flow structure of the buggy program pb.
first it searches for the closest program p prime cwrt controlflow structure from the set of correct programs and their refactored variants.
then it borrows a minimal number of control flow nodes such as if conditional or loop statements from p prime cinto pb in order to make their structure isomorphic.
unlike refactoring rules which mutates the control flow structure of correct programs while preserving semantic equiv alence structure mutation does not offer such guarantee.
iv .
b lock repair given a correct program pcthat has the same control flow structure as the buggy program pb we execute block repair algorithm to repair pb.
the algorithm consists of four stages.
first we construct a block mapping based on the isomorphism of the two control flow graphs cfg .
second we find a mapping between the variables of pband pc.
third we infer a correct specification for each basic block in pbfrom pc.
finally we synthesize a patch for each basic block of pb and combine all block patches into a global patch.
a. block mapping the goal of this stage is to find a mapping between the basic blocks of pband those of pc.
since pband pchave the same control flow structure their control flow graphs are isomorphic.
thus a block mapping is effectively an isomorphism between the two control flow graphs.
definition .
block mapping.
letg pc be cfg of p c with nodes bc i i ..nandg pb be cfg of p bwith nodes bb i i ..n. we define a block mapping b pc pb as a cfg isomorphism bc mapsto bb j1 ... bc n mapsto bb jn between g pc and g pb where j1 ... jn are different indexes from 1to n.b.
v ariable mapping the purpose of variable mapping is to identify how variables ofpccorrespond to the variables of pb.
definition .
v ariable mapping.
let x ... xmbe variables of the correct program p c and y1 ... ynbe variables of the buggy program p b. then xi1 mapsto yj1 ... xis mapsto yjs is a mapping of variables if i ... is ..n are different indices and j ... js ..m are different indices.
since there exist many possible mappings we apply dynamic equivalence analysis dea and define use analysis dua to filter out irrelevant mappings.
in dea we collect the variable traces collected on pband pc.
the trace of a variable in a test refers to the sequence of values that the variable takes during the test execution.
the intuition behind dea is that if a variable xinpctakes the same values in the same order as a variable yinpbduring each test execution then they represent the same user intent.in this case we say yis a variable candidate of x. definition .
mapped v ariable candidates in dea.
let x be a variable in p c ybe a variable in p b and t be a set of tests.m dea x represents a set of variable candidates in pbthat x can be mapped to.
we define y m dea x iff for each test t t the sequence of values that ytakes during the execution of p bwith t is the same as the sequence of values that x takes during the execution of p cwith t. in dua we assume that variables that are defined and used in the same manner are more likely to have the same user intent.
we get a set of variable candidates in pbwhich a variable in pccan be mapped to as follows.
definition .
mapped v ariable candidates in dua.
let d p x be the set of basic blocks in the program p where the variable x is defined u p x be the set of basic blocks in the program p where the variable x is used r be a variable in p cand s be a variable in p b.m dua r represents a set of variable candidates in p bthat r can be mapped to in dua.
we define s m dua r iff there exists a one one block mapping from d pc r tod pb s and there exists a oneone block mapping from u pc r tou pb s .
finally we rule out all invalid variable mappings that do not map the variable rinpcto any variable candidates in pb.
definition .
v alid v ariable mapping.
let ci1 mapsto bj1 ... cin mapsto bjn be a variable mapping between p cand pb.
we say that the variable mapping is invalid if and only if e ..n. bje nelementm dea cie m dua cie if no variable mapping is valid the block repair algorithm will report a repair failure on pb.
otherwise we enumerate all valid variable mappings one by one until the algorithm successfully infers a specification and synthesizes a patch.
c. specification inference first we analyze the correct program to extract a specification for each basic block.
this is done by running pc authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on our test suite tto collect input output state pairs of each basic block in pc.
here input state refers to the values of all variables before executing the basic block and output state refers to these values after executing the basic block.
definition .
specification.
let b be a basic block in a program p and t be the test suite.
the specification of b is defined as a set of input output state pairs angbracketleftij oj angbracketright j ... r where i jdenotes the input state and o jdenotes the expected output state of b given i jas the input state.
note that in the above definition we use a set of state pairs because each basic block can be executed multiple timesduring a test execution.
our algorithm infers a specification of a basic block b bbased on that of its corresponding basic block bcand the valid variable mapping m. definition .
specification inference.
let b cbe a basic block in the correct program p c and angbracketleftic j oc j angbracketright j ..rbe a specification of b c and b bbe the corresponding basic block in the buggy program p b and m be a valid variable mapping between p cand p b. a specification of b bis inferred as a set of input output state pairs angbracketleftib j ob j angbracketright j ..rsuch that y mapsto u ib j x. x mapsto u ic j x mapsto y m y mapsto u ob j x. x mapsto u oc j x mapsto y m d. patch synthesis before repairing a basic block bbinpb we verify the correctness of bbby collecting the inputs and their corresponding outputs of bband comparing them with the inputs and expected outputs in its inferred specification.
formally speaking we run pbon the test suite tto collect a set of inputoutput pairs angbracketleft ib j ob j angbracketright j ... zofbb.w es a y bbis incorrect if there exist angbracketleft ib u ob u angbracketrightand angbracketleftib v ob v angbracketrightsuch that ib v ib u ob v npropersubset ob u. for bbis incorrect we attempt to repair it.
if either bc orbbis an empty basic block we fix it either by generating an empty block as a patch of bbor using the valid variable mapping to translate bcto a patch of bb.
in other words we replace all variable names in bcwith their corresponding variable names according to the valid variable mapping.
ifbcand bbare not empty we use a program synthesis technique to generate a patch for bbbased on its specification.
given a set of suspicious lines we produce a partial program with holes inserted in buggy lines.
we generate expression candidates for each hole.
our goal is to fill holes with expressions that enable the block to satisfy the specification.
definition .
block patch synthesis.
let b be an incorrect basic block and l be a set of suspicious buggy lines in b. let p b l be a partial block that holes are inserted into all lines in l. let s lbe a set of expressions candidates for the hole in line l l. letc s1 ... sl l rbe a cost function.
our aim is to find a repair angbracketlefts1 ... sl angbracketright s1 ... slthat i can fill in p b l to pass the correct specification and ii c s1 ... sl l be minimal among all such basic blocks.
typically program repair techniques identify suspicious lines via statistical fault localization.
considering such tech niques may not be accurate on students submissions which are usually severely incorrect we enumerate the all subsets oflines in b bas sets of suspicious buggy lines in the ascending order of the number of lines until we find a patch.
a simple approach to generate a patch is to enumerate all block candidates by filling in holes in the partial block with all combinations of expressions.
however the search space might be huge suffering from a combinatorial explosion as the number of holes grows.
to mitigate this issue we performtest equivalence analysis when searching for a patch.
in a nutshell we partition candidates into test equivalence classes.
for each class only one representative patch is executed and verified thereby reducing the number of test executions.
definition .
test equivalence relation.
letbbe a set of block candidates and be an input output pair in the correct specification of b. an test equivalence relation on is defined as an equivalence relation b bthat if b b2 then b1and b 2both pass or fail .
the search space of expression candidates for each hole is constructed based on expression templates and operator vari able mutation.
an expression template is a syntax pattern where variable names in the expression are abstracted away i.e.
use a set of wildcards instead of the variable names .
expression templates are extracted from expressions in correct programs.
formally let e angbracketlefte ... en angbracketrightbe an expression where eidenotes i th token of e. let vbe a set of variable names.
an expression template of ecan be defined as a sequence of tokens angbracketlefte prime ... e prime n angbracketright where e prime i iffei v.g i v e n a set of variable names from the buggy program a space of candidate expressions is generated by assigning each wildcard with a unique variable name.
we also generate a space of candidate expressions by mutating operators or variable names of the suspicious ex pressions from the buggy program.
let e angbracketlefte ... en angbracketrightbe an expression where eidenotes i th token of e. we construct a space of candidate expressions by generating e prime angbracketlefte prime ... e prime n angbracketright where ej e prime jwhen j ... k k ... n and e prime kis such that ek nequale prime kand if ekis a variable then e prime kis another variable and if ekan operator then e prime kis another operator.
v. d a taset and experimental setup we choose clara one of the most recent and related feedback generation approach with publicly available implementation1 as the baseline to compare our approach against.
clara was evaluated on a similar dataset as autograder which consists of student attempts from mitx mooc .
however this dataset is not publicly available.
instead we evaluate both clara and our refactory tool on real student submissions collected from an introductory python programming course offered at the author s university national university of singapore .
this course was cred ited by students who had to attempt a large number of programming assignments throughout the entire semester.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
id descriptionavg.
lines correct incorrect cfg matchrepair rateavg.
time relative patch of code attempt attempt w o r w r taken sec size rps sequential search .
.
.
.
.
.
.
.
unique dates months .
.
.
.
.
.
.
.
duplicate elimination .
.
.
.
.
.
.
.
sorting tuples .
.
.
.
.
.
.
.
top k elements .
.
.
.
.
.
.
.
overall .
.
.
.
.
.
.
.
t able ii results on five programming assignments.
cfg match is the percentage of incorrect submissions for which correct submissions with matching control flow structure are found without refactoring w o r and with refactoring w r .
repair rate average time taken and relative patch size per assignment are shown for refactory and for clara in brackets .
students were allowed to submit multiple attempts only the last of which was graded.
on each attempt students receivedthe test suite evaluation results as feedback.
from these assignments we filter out those attempts that contain syntax errors or contain a single basic block trivial assignments or utilize python language features unsupported by implementation of refactory orclara such as lambda functions exception handling object oriented programming concepts .
after filtering 19assignments remain from which we selected 5assignments for an initial evaluation and crafting our refactoring rules.
totally.
correct submissions and incorrect student attempts form our dataset along with the instructor designed test suite and reference program.
this dataset is described in table ii.
our dataset and refactory repair tool are publicly released to aid further research .
to test the generality of our refactoring rules and block repair algorithm we report results on the remaining assignments containing correct submissions and incorrect student attempts as well.
all experiments are conducted using intelr circlecopyrtcoretmi7 cpu 8gb ram and ubuntu .
.
clara has an offline phase for clustering the correct programs for which we set a fiveminute timeout per assignment.
for the online phase clara and refactory are configured to run in a single thread mode with one minute timeout to repair each incorrect submission.
vi.
e v alua tion to evaluate the effectiveness of refactory we aim at answering the following research questions rq1 given a large number of correct submissions how effectively can refactory repair incorrect submissions?
rq2 given a small number of correct submissions how effectively can refactory repair incorrect submissions?
rq1 and rq2 investigate the applicability of our approach to assignments with different number of correct submissions.
existing data driven approaches such as clara and sarfgen are designed for assignments with a large number of correct submissions.
we use refactoring rules to generate new correct submissions which makes our approach applicable when only a small number of correct submissions is available.
to answer rq1 we evaluate refactory and clara on the entire dataset of correct programs.
to answer rq2 we them on downsampled dataset where the number ofcorrect submissions provided as input to these tools is variedfrom to only the reference program is used .
explanation of table ii table ii shows the results on our assignments selected for initial evaluation.
clara can generate repairs for .
of incorrect submissions consuming .
seconds on average per repair.
in comparison refactory can generate repairs for .
of incorrect submissions requiring .
seconds on average per repair.
which demonstrates that refactory can repair a significantly larger of incorrect submissions while requiring lesser amount of time.
this high repair rate of .
by refactory is made possible by our refactoring and structure mutation phase.
as seen from table ii only .
of incorrect programs have a matching correct submission with exactlt the same control flow structure.
by applying our refactoring rules we generatenew correct programs thereby increasing the cfg match to .
.
the remaining incorrect programs which do not have a cfg match with correct programs undergo structure mutation during online phase bringing our overall repair rate to .
.
in comparison almost a half of clara s failures occur due to exceeding the running timeout of min.
the remaining occur when clara is unable to find a matching correct submission with the same looping structure as incorrect submission.
we also report on relative patch size rps metric to further evaluate generated patches.
patch size is defined as the tree edit distance ted between the abstract syntax tree of given buggy program ast b and repaired program ast r generated by tool.
relative patch size rps as defined by clara normalizes the patch size with the size of original buggy program s ast.
rps ted ast b ast r size ast b as shown in table ii repairs generated by refactory have a smaller average rps compared to those generated by clara for majority of incorrect attempts which indicates that our repairs are smaller and hence more likely to help students in rectifying bugs in their incorrect attempts.
explanation of figure fig.
5a shows the average repair rate achieved by both tools for various sampling rate of correct submissions provided as input to the tools.
the repair rate of refactory is relatively consistent when the sampling rate is reduced while clara s repair rate drops significantly with decrease in sampling rate.
for example when sampling authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g19 g21 g24 g24 g19 g26 g24 g20 g19 g19 g54 g68 g80 g83 g79 g76 g81 g74 g3 g53 g68 g87 g72 g3 g8 g19 g21 g19 g23 g19 g25 g19 g27 g19 g20 g19 g19 g53 g72 g83 g68 g76 g85 g3 g53 g68 g87 g72 g3 g8 g53 g72 g73 g68 g70 g87 g82 g85 g92 g38 g79 g68 g85 g68 a average repair rate across various sampling rates of correct solutions.
g19 g21 g24 g24 g19 g26 g24 g20 g19 g19 g54 g68 g80 g83 g79 g76 g81 g74 g3 g53 g68 g87 g72 g3 g8 g19 g17 g19 g21 g17 g24 g24 g17 g19 g26 g17 g24 g20 g19 g17 g19 g20 g21 g17 g24 g55 g76 g80 g72 g3 g55 g68 g78 g72 g81 g3 g11 g86 g12 g53 g72 g73 g68 g70 g87 g82 g85 g92 g38 g79 g68 g85 g68 b average time taken to repair incorrect program across various sampling rates.
g19 g17 g19 g19 g17 g24 g20 g17 g19 g20 g17 g24 g21 g17 g19 g21 g17 g24 g53 g72 g79 g68 g87 g76 g89 g72 g3 g51 g68 g87 g70 g75 g3 g54 g76 g93 g72 g19 g17 g19 g19 g19 g17 g21 g24 g19 g17 g24 g19 g19 g17 g26 g24 g20 g17 g19 g19 g20 g17 g21 g24 g39 g72 g81 g86 g76 g87 g92 g53 g72 g73 g68 g70 g87 g82 g85 g92 g38 g79 g68 g85 g68 c density function of relative patch size.
fig.
performance comparison between clara and refactory .
rate is only the reference program is provided as input clara achieves less than repair accuracy due to its reliance on diverse correct programs compared to more than achieved by refactory due to its ability to generate new correct programs using refactoring rules.
fig.
5b shows the average time taken by both tools to repair a single program across different sampling rates.
clara s time cost is proportional to the sampling rate which highlights its scalability issue on dataset with a large number of correct submissions due to the increase in complexity of integer linear programming ilp .
since refactory selects the topk closest refactored correct programs with same control flow structure for repair generation it scales better than clara .
fig 5c compares the relative patch size rps of refactory against clara by plotting its density function.
this is obtained by defining independent random variables which represent the rps of a patch generated by refactory and clara for each assignment for each sampling rate.
then gaussiankernel density estimator is used to generate their probability density functions based on individual observation values.
formally let x t ... xt n denote the nobservation values of rps of a patch generated by a tool tacross all assignments and sampling rates.
we estimate the density function as f x nh summationtext.1n i 1k x xt i h where his a smoothing parameter andkrepresents a gaussian kernel function.
from fig.
5c the estimated density y axis of patches for refactory tool is higher compared to clara s when rps x axis is smaller than .
.
in other words the patches generated by our tool areconcentrated towards small rps.
results on full data set to demonstrate that our manually crafted refactoring rules do not over fit our initially selected five assignments reported in table ii we report additional results on the 14held out assignments refer section v .
on these new assignments our refactory tool achieves repair rate of .
on incorrect submissions within .4seconds on average and the generated repair s average relative patch size is .
.
in contrast clara can repair .
of7290 incorrect submissions in 15seconds on average with a relative patch size of .
.
furthermore our refactoring rules can improve the overall cfg match rate from .
w or to .
w r .
overall our tool achieves high accuracy with small patch size on the full set of assignments.
vii.
r ela ted work in this section we briefly review existing state of the art approaches targeting introductory programming assignments and clarify the novelties provided by our approach.
a. automated program repair the field of automated program repair where changes are suggested to the program source code for fixing observable errors and vulnerabilities has witnessed an explosive growth in recent years.
genprog uses search based techniques to navigate the space of edits so as to automatically find an edit where the edited program passes a given test suite.
learningor pattern based approaches have been successfully applied in program repair e.g.
finding patterns of human patches and using them in program repair or using machine learning techniques to rank patch candidates .
semfix and angelix extract specification from tests and use it to synthesize a patch.
refactory also uses specification inference however it differs in two key aspects.
first the specification is inferred from a correct solution that might have a different implementation and use different variable names.
to tackle this we apply automatic refactoringand variable matching.
second refactory is able to synthesize patches not only for program expressions but also for basic blocks by transplanting fragments of code from the correct solution.
symbolic execution based patch synthesis algorithm of semfix is orthogonal to our core contributions and can be potentially used to improve expression synthesis in refactory .
simfix mines repairs from similar code and past patches.
in principle it can be applied to correct student assignments when a history of previous corrections and a sufficient number of similar solutions are available.
in contrast our approach is designed to work when only a few correct solutions are available without relying on the history of previous corrections.
instead from a single correct solution we can generate several correct solutions one of which can match the control flow of the given buggy program followed by which we resort to basic block synthesis.
thus our approach authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1def swap l s t i j tmp l s t lst lst lst t m p a an incorrect program1def swap l s t i j tmp l s t lst lst lst t m p b a correct program fig.
function to swap two elements in list .
is more applicable in pedagogical scenarios e.g.
when a newly crafted assignment is given by an instructor.
our work on using a reference correct solution may appear superficially similar to the recent paper .
however employs simultaneous symbolic analysis of both buggy and correct programs to produce provably correct repairs.
similar to other recent works on repair in education we do not give formal guarantees about the repairs generated by our approach.
instead we use refactoring and synthesis toefficiently represent navigate the space of patches.
b. feedback generation automated program repair tools originally designed to work on large codebases targeting experienced developers have been used to provide feedback to students on introductory programming assignments with limited success .
hence new tools have been proposed in literature targeting the novice programmers and their mistakes specifically.
autograder proposes a program synthesis based approach which takes a reference solution and manually provided error model togenerate repairs on incorrect programs.
refazer attempts to learn simple syntactic program transformations from historical edit examples and applies ast rewrite rules on matching incorrect programs to automatically repair them.
clara and sarfgen are two recent approaches related to our work that generate complex patches on incorrect student programs automatically.
given an incorrect program attempt clara and sarfgen rely on finding a correct solution having the same looping and control flow structure respectively.
this assumption presents a serious challenge when there is lack of access to a diverse set of existing correct solutions for example when a newly crafted assignment is given by instructor.
to address this issue our approach attempts to refactor one or more correct solutions to generate new semantically equivalent correct solutions with different looping control flow struc tures.
in addition as noted in our experiments on running time clara suffers from a scalability problem due to the use of integer linear programming.
we are unable to compare our run time accuracy with sarfgen since their implementation has not been publicly released moreover sarfgen is targeted towards c while our tool works only for python programs.
consider the incorrect student attempt for swap function in fig.
6a.
here the student has made a mistake in swapping two elements of a list lst and lst through use of an intermediate tmp variable.
given the correct program shown in fig.
6b as input our refactory approach generates the minimal repair of modifying a single line 2from tmp lst totmp lst by replacing each line with holes and synthesizing expression candidates.
while clara generates a sub optimal solution at the block level by borrowing the two differing lines 3and4 from the correct program.
viii.
t hrea ts to v alidity our choice of refactoring rules are by no means exhaustive and primarily targets conditionals looping structures and their combinations which constitutes majority of the control flow mistakes made by students in introductory programmingclasses.
while we do report experimental results on additional assignments unseen during refactoring rule crafting in future we plan to rigorously test our tool on larger variety of programs collated from other publicly available datasets.
our implementation currently supports only structured programming control flow structures.
in future we plan to extendour approach to handle object oriented programming concepts.
additional complex features available in python such as list comprehensions or lambda functions are currently not handled since novice students rarely utilize advanced concepts.
correctness of repairs is verified against instructor provided test suite a manually designed incomplete specification.
finally we note that while our implementation is targeted towards python programs our approach based on refactoring and block repair is not restricted to python programs.
ix.
d iscussion the recent past has witnessed an explosion of works on automated feedback generation for introductory programming assignments through means of program repair .
at a general level most of the works search in the space of program edits to either generate feedback for students or to help automatically grade assignments.
due to a large variety of coding errors in programming assignments written by novice programmers the search space of edits between a given incorrect program and a correct program tends to be huge .
many past works have contributed immensely in the navigation of this search space of edits which may enable feedback generation for students.
in our work we have focused first on the search space representation thereby prompting our refactoring phase and then attempted to systematize the navigation of possible patches of a basic block by partitioningthe candidate patches using test equivalence analysis.
such a representation and navigation of the search space also allows us to work in various set ups including those where manycorrect solutions are not available.
our efforts are embodied in the form of refactory a customized python repair system.
we have employed the repair system extensively over a large data set of more than athousand programming assignments collected from hundreds of students enrolled in an introductory programming course.
in future work we plan to conduct detailed user studies where the feedback from our tool can be generated live during tutorial or recitation sessions so as to gauge the possible improvement in meeting learning outcomes.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.