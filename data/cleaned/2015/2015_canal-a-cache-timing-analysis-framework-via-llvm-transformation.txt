canal a cache timing analysis framework via llvm transformation chungha sung university of southern california los angeles ca usabrandon paulsen university of southern california los angeles ca usachao wang university of southern california los angeles ca usa abstract aunifiedmodelingframeworkfornon functionalpropertiesofa program is essential for research in software analysis and verification since it reduces burdens on individual researchers to implement new approaches and compare existing approaches.
we present canal aframeworkthatmodelsthe cachebehaviorsof aprogrambytransformingitsintermediaterepresentationinthe llvmcompiler.
canalinsertsauxiliaryvariablesandinstructions toallowstandardverificationtoolstohandleanewclassofcache related properties e.g.
for computing the worst case execution timeanddetectingside channelleaks.wedemonstratetheeffectivenessof canalusingthreeverificationtools klee smack and crab llvm.
we confirm the accuracy of our cache model by comparing with cpu cycle accurate simulation results of gem5.
ccs concepts software and its engineering software verification and validation securityandprivacy cryptanalysisandother attacks keywords cache executiontime sidechannel verification symbolicexecution abstract interpretation bounded model checking acm reference format chungha sung brandon paulsen and chao wang.
.
canal a cache timinganalysisframeworkviallvmtransformation.in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 4pages.
introduction analyzingthe cachebehaviorsofaprogramisimportant e.g.
for computing theworst case execution timeof areal time system and detectinginformationleaks throughsidechannels .
however existing verification tools are often designed only for checking functional properties e.g.
assertions or pre and postconditions.forexample noneoftheparticipantsofrecentsoftware verificationcompetitions canverify non functional properties suchasthoserelatedtotheexecutiontime.althoughspecialized toolshavebeendevelopedtohandlesuchnon functionalproperties theyarerarelyopen sourceoraswell maintainedasmainstream verificationtools.asaresult itisdifficultforindividualresearchers permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
!
figure the overall flow of canal.
to implement new approaches for verifying such properties or evaluate existing approaches.
wefillthegapbydevelopinga lightweight cachemodelingframework for standard verification tools by transforming the llvm intermediate representation ir of a program to add self modeling capabilities.
that is we insert auxiliary variables and llvm instructionsoverthesevariablestorecordandupdatecachestatistics relatedto load storeinstructionsduringtheprogramexecution.
by using the instrumented llvm bitcode as input standard functional verification tools will have the capability of verifying a new class of non functional properties.
our modeling framework named canal takes c c code as inputandemitsllvmbitcodeasoutput.thus itcanbeusedby anyllvm basedverificationtools.forexample symbolicexecution tools such as klee may take the program instrumented bycanalto detect side channel leaks bounded model checkers such as smack may take the program instrumented by canalto conduct must and may hit cache analyses and static analyzers based on numerical abstract interpretation such as crabllvm maytaketheprograminstrumentedby canaltoconductworst caseexecutiontime wcet analysis.
canalisavailable on github1.
in the remainder of this paper we shall explain how to combine canalwithklee smackandcrab llvmtoobtainthedesired results.wealsocompare canalwiththecpucycle accuratesimulationresultsofgem5 astandardmicro architecturalsimulator to demonstrate the accuracy of our cache model.
tool overview figure1shows the overall flow of canal which takes the c c code of a program and the cache configuration file of a target computer as input and returns the instrumented llvm bitcode as output.
after compiling the c c code into llvm bitcode it uses a sequence of optimization opt passes to insert before or after eachload storeinstruction somenewinstructionsthatmodelthe change of cache states due to these memory accesses.
the inserted instructions can be understood as invocations of two functions csim load addrinfo and csim store addrinfo which updates our model of the cache state whenever loadorstoreis executed addrinfo denotes information of the memory location.
1tool and benchmarks authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung brandon paulsen and chao wang inadditiontotheautomaticallyinsertedcallsto csim load and csim store the user of canalmay specify properties usingtheseauxiliaryvariables csim num hit csim num miss csim load ret and csim store ret .theyrepresenttheaccumulative numbers of hits and misses along a program path as well as the cache status hit or miss associated with each memory access.
by feeding the instrumented llvm bitcode to standard verification tools as input canalallows them to verify a new classofnon functionalproperties suchasassertionsoverauxiliary variables that model the cache behaviors of the program.
int main csim init cache char out aes encrypt hello world!
out csim print stat figure canal as standalone cache simulator.accuracy.
to demonstrate the accuracy of our cache model wecompareourresults with the cache statistics reported bygem5.
towardthis end note that canalmay be usedas a standalone cache simulator if we compile the llvmbitcode instrumentedby canaltoanexecutable andrunit withaconcreteinput itwillproducethecachestatisticsassociated withthatparticularexecution.figure 2showsthisusagecase where csim init cache and csim print stat areinsertedto theoriginalcprogramtoinitializethecachestatesanddisplaythe result respectively.thefunctionbodyof aes encrypt willbe instrumented by canalautomatically.
sincethecachestatisticsreportedbygem5includenotonlythe main function but also operating system code executed before andafter weneedtocreatetwoprogramversionsandthencomputetheirdifference.oneoftheprogramsconsistsofthe main function and instructions inserted at the beginning and end ofthe main function to flush the cache while the other program consists of only these cache flushing instructions with an empty main function body.
by running these two programs and computingthedifference wehaveobtainedtheexactnumbersofcache hits and misses reported by gem5.
table accuracy comparison canalversus gem5 gem5 canal name loc mem.access r.miss w.miss time s r.miss w.miss time s ary acc .
.
bub.sort .
.
ins.sort .
.
aes .
.
des .
.
table1shows the comparison of gem5 and canalfor five example programs including three sorting routines and two cryptographic routines.
the results are always identical.
the sortingroutines exhibit a diverse range of memory accessing behavior based on input data array of random integers .
the cryptographic routineshavesecurity criticalcomputationsthatareoftentarget ofside channelattacks theirinputsareanencryptedmessageof helloworld!
usingapredefinedencryptionkey.toensurethatwe trigger a rich set of cache behaviors during the experiments we configuredthecachetobe4 wayassociativitywithlrureplacementpolicy bytelinesize and1k bytecachesize.withalarger cachesize thesimulationspeedof canalwillnotchangemuch but there will be fewer cache conflicts.
application scenarios we now demonstrate how canalmay be used by klee smack and crab llvm using five example programs taken from the svcompbenchmark copysome sanfoundry andstandard from thearray programs section and gcdandsumfromthebit vectors section.
we use a way associative cache with lru and bytecache line while setting the cache size to kb kb and kb respectively.
we set the timeout to one hour for each program.
.
combined with symbolic execution tools symbolic execution is a technique for systematically exploring feasiblepathsof aprogramandgeneratingtheir testinputs.although it has been used primarily for checking functional properties with canal it can now be used to detect timing side channel leaks.
timing side channel leaks.
we say that a program p k with sensitive input khas timing side channel leaks if the execution time ofpdepends on the value of k. that is k1 k2 dom k p k1 nequal p k2 wherek1andk2are values in the domain of kand is the execution time.
even if the program executes the same number and type of instructions the execution time may still differ if there are different numbers of cache hits misses.
such side channel leaks may be detected by canal klee.
klee make symbolic input1 klee make symbolic input2 csim init cache prog input1 h1 csim num hit m1 csim num miss csim init cache prog input2 h2 csim num hit m2 csim num miss assert h1 h2 m1 m2 figure canal for timingsidechanneldetection.figure3shows an example where input1andinput2 aremarkedassymbolicvalues and used to run the program prog twice.
after each execution the numbers of hitsand misses are stored in h1 m1 h2 andm2 respectively.
finally the assertion checksif prog is leak free that is input1 input2 the condition h1 h2 m1 m2 always holds.
klee can be used to search for concrete values of input1andinput2that violate the assertion.
table2showstheresultsofrunningkleeontheseprograms.
in each case we manually modified the program to mark one or more parameters as the sensitive input.
columns show if a leak is detected together with the total number of tests generated and among them the number tests that manifest the leak.
columns show the time taken by klee for the different cache sizes.
table results of the side channel leak detection.
canal klee time s name loc detection result total tests leaky tests 1k b 6k b 2k b copysome no leak .
.
.
sanfoundry no leak .
.
.
standard leak .
.
.
gcd leak .
.
.
sum leak .
.
.
.
combined with software verification tools while symbolic execution is geared toward generating tests verification tools such as smack are geared toward generating proofs e.g.
proving that an assertion holds under all test inputs.
we show howsmackcanleverage canaltoprovecacherelatedproperties.
must hits and must misses.
one type of properties of interest is assertions over auxiliary variables such as csim load ret and csim store ret .
for example if a certain loadorstore instruction in the program always leads to a cache hit or miss regardless of the program path and test input in such a case we call it a must hit or a must miss.
canalinstrument the llvm bit code in such a way that calls to csim load and csim store setthevaluesofauxiliary variables csim load ret and csim store ret toreflect the cache status truemeans the memory access leads to a hit whereas falsemeans it leads to a miss.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
canal a cache timing analysis framework via llvm transformation ase september montpellier france figure4showsaprogramwherewecheckifreadof buffer is a must hit.
thus we save the value of csim load ret immediately after the read of buffer to the variable named hand add an assertion stating hshould always be true.
if smack can prove the assertion we know the read of buffer is a must hit.
alternatively wecanadd assert h false andusesmackto prove it is a must miss.
sinceprogramverificationisundecidedingeneral e.g.
equivalent to the turing halting problem smack may fail to prove either assertion in such a case the result remains inconclusive.
in thisparticularexample ho wever sma ckisabletofindaviolation ofthemust hitassertionandgenerateacounterexample.thecounterexample shows a scenario where buffer andbuffer resides in two different byte cache lines.
if cond buffer x else buffer y z buffer h csim load ret assert h true must hit ?
figure canalfor musthit analysis.table3shows the results ofapplying canal smack toassertionswemanuallyinserted to check if a load orstoreinstruction in the program is a must hit miss.
withloop unrolling boundof smack set to and the cachesizesetto1kb smacksuccessfullyverifiedallassertions.
however whenthecachesizewasincreasedto16kband32kb smack started to timeout on some programs.
this points out a scalability limitation of smack together with direction for future work improving the verification algorithms to make smack and similar tools more scalable for non functional properties.
table results of the must hit analysis.
canal smack time s name loc loop unroll bound property results 1k b 6k b 2k b copysome must miss verified .
to to sanfoundry must miss verified .
.
to standard must hit verified .
.
.
gcd must miss verified .
.
.
sum must miss verified .
.
.
.
combined with static analysis tools staticanalyzersbasedonnumericalabstractinterpretation such ascrab llvm cangenerateprograminvariants.theseinvariants computed for each program location are summaries over all paths andinputvalues.therefore theycanbeusedtoestimatetheworstcase execution time of a program.
more specifically by leveraging canal toolssuchascrab llvmcangenerateinvariantsinterms of auxiliary variables such as csim num load hit .
if cond buffer else buffer buffer n s h csim num store hit n s m csim num store miss n s n s h n s m crab assert n s h crab assert n s m crab assert n s figure canal for computing value ranges.figure5showsan if else statement controlled by the value of cond.
assume each cache line contains bytes the first integers of the ar ray fall into one cache line whereas the next integers starting with buffer fall intoanothercacheline.however during static analysis there is no way of knowing what the value of condis therefore one has to assume both branches may be taken.
when the then branch is taken buffer will be loaded to the cache which means the access to buffer is a cache hit.
however when the else branch is taken buffer will not be loaded to the cache which means the access to buffer is a cachemiss.byusingnumericalabstractinterpretation crab llvmcantakebothcasesintoconsiderationandcomputevalueranges ofn s n s handn s m. for this example in particular the value ranges would be for n s for n s h and for n s m. therefore crab llvmcanprovethesecondandthethirdassertions while reporting a potential violation of the first assertion.
inaddition aninterestingapplicationofthevaluerangescomputedbynumericalabstractinterpretationistocomputetheworstcase execution time wcet which depends on the maximum number of cache misses along all program paths.
table results of the numerical abstract interpretation.
canal crab llvm time s name loc s.hit s.miss l.hit l.miss 1k b 6k b 2k b copysome .
.
to sanfoundry .
.
.
standard .
.
.
gcd .
.
.
sum .
.
.
copysome unroll .
.
.
sanfoundry unroll .
.
.
standard unroll .
.
.
gcd unroll .
.
.
sum unroll .
.
.
table4shows the results of applying canal crab llvm on the exampleprograms.columns3 6reportthevaluerangesofthetotal numberstore hits s.hit store misses s.miss load hits l.hit and load misses l.miss .
since these programs have loops and crab llvmusesaggressiveover approximationtoforcetermination overloops mostoftheupperboundsbecome .luckily these arefixed boundloops andafterweautomaticallyunrolledthese loops crab llvm obtained more accurate value ranges.
cache modeling we now briefly explain how cache is modeled inside canal.i t isalightweight cachemodelinthatthemodelinginstructionsare carefully designed to reduce the overhead of the verification tools.
forexample pointersaredifficulttohandlebyverificationtools therefore we avoid using them in the instrumented code.
.
pre computing address to cache mapping inside llvm we first obtain the memory address of each program variable by analyzing the symbol table of the pre compiled code.
then for the target computer architecture we generate a memory layout.wetrytopre computethepossibleaddressvalueforeach load or store instruction in the program.
int var its cache set and tag are and respectively v a r csim store figure pre computed set and tag values.if the address is a fixed value we compute its set and tagfields in the cache and use these concrete val ues to simplify the instanti ation of csim load and csim store .
otherwise weresorttotheuseofif elsestatementstodynamicallycompute thesetandtagfields more difficult to handle by verification tools .
figure6showsasimplecasewheretheaddressof varisstatically known andthuswecanpre computeits set and tag .these concretevaluesareusedtoinstantiate csim store .although ccodeisusedinfigure thisisactuallyimplementedatthellvm bitcode level inside canal.
figure7showsamorecomplexcase wherethearrayisaccessed using a variable i and thus if else statements are used to compute thesetandtagofbuffer .althoughwecannotsimplifyasmuch as in figure we can still pre compute the value ranges of setand tagbased on the address of the array.
in particular we can assume the value range of setis and the tagis always .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france chungha sung brandon paulsen and chao wang .
simplifying updates of the cache statistics buffer if address of buffer i csim addr of cacheline01 csim store else if address of test i csim addr of cacheline02 csim store else csim store figure dynamically computed set and tag values.to simplify the storageand update of cache statisticsso verificationtools canhandlethemeasily we use a set of simple vari ables as opposed to an ar ray indexed by memory addresses.thiscandrastically reduce the complex ity of the cache modelinginstructions inside functions csim load and csim store .
function csim store set tag if set if csim cacheline00 taken csim cacheline00 tag tag cache hit csim num store hit csim store ret true else if ... cache hit ... else cache miss csim num store miss csim store ret false pick a new line based on the update policy ... else if set ... else if set ... ... figure code snippet of csim store.figure8shows the internals of csim store which updates the cache statistics based on the valuesofsetandtag.
instead of usingmonolithicarrayssuchas cacheline .tag weuse individual variables such as csim cacheline00 tag.
the number means the cache line isassociated with set0andway0 andtheauxiliary variable denotes the tag saved at the line.
when a cache miss occurs for example we update the value of cacheline00 tag aswellas the values of similar auxil iary variables and evicts a victim.
in this implementation lru policy is used to computethevictim butotherreplacementpoliciesmaybeincorporated into canaleasily.
implementations of csim store and csim load are specifictoeachindividualprogramunderverification andtherefore they are generated by canalautomatically.
related work canalis the first llvm based lightweight cache modeling frameworkdesignedspecificallyforsoftwareverificationtools.although thereareothercachesimulators andcpusimulatorssuch asgem5 theyarenot designedforthispurpose.inparticular they cannot be used in the same way as canalto afford existing verification tools the capability of verifying a new class of cache related non functional properties.
there are also tools designed specifically for wcet analysis based on cache analysis and for detecting cache timing side channels .
however the modeling part of these tools are tied up with the subsequent analysis part and therefore cannotbeusedbyotherverificationtools.furthermore theanalysispartof these tools is rarely open source and often not as well maintained asthemainstreamsoftwareverificationtools whichareupdated constantly to keep up with the competition .
although our main contribution in this work is the lightweight cachemodelingthatfacilitatesthesubsequentanalysisandverification there is still room for improvement in the analysis and verification algorithms.
since cache timing behaviors are non functionalproperties they often have significantly different characteristics from functional properties andthusmaybenefitfromspecialized algorithms to make verification more efficient and scalable.
our implementation of canalhas been tested on programs fromtwodomains real timesoftwareandembeddedsoftware.in both cases theprogram structure and language constructsare relatively simple.
to handle c c programs in other applicationdomains more sophisticated static analyses may be needed e.g.
to deal with pointer aliasing and complex loops during the precomputationofaddress to cachemappingandupdatesofthecachestatistics inordertokeeptheapplicationofourllvmbasedtransformation efficient.
we also plan to further refine our cache model e.g.
to handle multi threading as well as multi level cache.
conclusions wehavepresented canal aframeworkformodelingcachebehaviorsofaprogrambasedonllvmtransformations whichallows standard software verification tools to check cache timing properties.
we demonstrated the accuracy of our cache model in canal by comparing with the simulation results of gem5 as well as the effectivenessofcombining canalwiththreeexistingtools klee smack and crab llvm in verifying cache related properties.