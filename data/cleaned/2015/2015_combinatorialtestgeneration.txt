towards more efficient meta heuristic algorithms for combinatorial test generation jinkun lin state key laboratory of computer science institute of software chinese academy of sciences china jkunlin gmail.comshaowei cai state key laboratory of computer science institute of software chinese academy of sciences china caisw ios.ac.cnchuan luo microsoft research china chuan.luo microsoft.com qingwei lin microsoft research china qlin microsoft.comhongyu zhang the university of newcastle australia hongyu.zhang newcastle.edu.au abstract combinatorial interaction testing cit is a popular approach to detecting faults in highly configurable software systems.
the core task of cit is to generate a small test suite called a t way covering array ca where tis the covering strength.
many meta heuristic algorithms have been proposed to solve the constrained covering array generating ccag problem.
a major drawback of existing algorithms is that they usually need considerable time to obtain a good quality solution which hinders the wider applications of such algorithms.
we observe that the high time consumption of existing meta heuristic algorithms for ccag is mainly due to the procedure of score computation.
in this work we propose a much more efficient method for score computation.
the score computation method is applied to a state of the art algorithm tca showing significant improvements.
the new score computation method opens a way to utilize algorithmic ideas relying on scores which were not affordable previously.
we integrate a gradient descent search step to further improve the algorithm leading to a new algorithm called fastca .
experiments on a broad range of real world benchmarks and synthetic benchmarks show that fastca significantly outperforms state of the art algorithms for ccag algorithms in terms of both the size of obtained covering array and the run time.
ccs concepts computing methodologies heuristic function construction software and its engineering software testing and debugging search based software engineering .
corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
combinatorial interaction testing covering array generation local search acm reference format jinkun lin shaowei cai chuan luo qingwei lin and hongyu zhang.
.
towards more efficient meta heuristic algorithms for combinatorial test generation .
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
introduction with the increasing requirement on customizable software modern software systems usually have many configurable options.
these highly configurable systems allow users to control the behaviors of the softwares by setting the options to meet their demand.
besides the cost of development may be reduced significantly by reusing the systematic components among different variants.
these benefits are in the wake of challenges for the validation of highly configurable softwares as failures may be caused by some combinations of options .
testing highly configurable softwares is an intractable task mainly because the number of configurations grows exponentially with the number of options.
due to the combinatorial explosion the enumeration methods become futile and there is an urgent need to develop more effective and practical methods.
as a response to this significant requirement the combinatorial interaction testing cit approach has emerged as a popular paradigm for detecting option combination faults of configurable software system.
by using combinatorial optimization techniques to sample configurations from the configuration space cit can significantly reduce the number of required test cases.
cit has proved useful in many domains such as software product line graphical user interfaces concurrent programs among others.
particularly a recent research suggests that cit is more desirable when system faults are hard to detect .
the core task of cit is to generate a test suite as small as possible by which any t way combination of values of options is covered at least once.
such a test suite is called a t way covering array ca where tis the covering strength.
empirical studies suggest that most of the failures in highly configurable systems are caused by esec fse august tallinn estonia jinkun lin shaowei cai chuan luo qingwei lin and hongyu zhang the interaction of a limited number of toptions usually between two and six .
these failures can be revealed efficiently and effectively by a t way ca.
in most real world systems there are hard constraints on the permissible combinations of values of the options.
for the sake of the accuracy and the efficiency of the testing process these constraints must be taken into account when generating ca .
this gives rise to the constrained covering array generating ccag problem which aims at generating ca of minimum size while satisfying all constraints.
ccag is np hard and popular practical algorithms for solving ccag can be classified into three main groups constraintencoding algorithms greedy algorithms and meta heuristic algorithms .
while constraint encoding algorithms can effectively solve way ccag they typically fail to solve way ccag.
greedy algorithms focus on generating cas in a short time and the size of ca is not its major consideration.
meta heuristic algorithms can generate better solutions than other approaches but they usually need considerable time to obtain a good quality solution which hinders the wider applications of such algorithms.
this work is dedicated to more efficient meta heuristic algorithms for ccag which can provide good solutions within much shorter time compared to state of the art ccag algorithms.
metaheuristic algorithms for ccag are based on a methodology named local search.
we discover that the computation of the scores of candidate operations which are used to guide the search to select the operation to perform occupies a very high proportion of the time consumption of a local search algorithm for ccag.
according to our investigation on the tca algorithm this percentage is usually more than and can reach up to for some instances when solving way ccag.
the heavy score computation makes the algorithms slow and a more serious consequence is that some good algorithmic ideas cannot be used in meta heuristic algorithms for ccag due to the slow score computation.
thus to develop efficient local search solvers for ccag it is critical to develop an efficient method for score computation.
in this work we propose a method that is much faster than the previous methods for score computation.
the proposed method is based on an important observation that only two kinds of value combinations have influence on the scores and thus only these combinations need to be considered in calculating scores.
we apply our novel score computation method to a state of the art meta heuristic algorithm tca .
the experimental results on real world benchmarks show that the runtime to find cas of the same size is significant reduced by using our score computation method.
in addition with regard to the size of cas found within seconds the new algorithm tca improves tca on out of real world benchmarks and performs equally on the rest of the benchmarks.
the new score computation method opens a way to utilize algorithmic ideas relying on scores which were not affordable previously.
based on the new score computation method we develop a new algorithm named fastca .
it improves tca by introducing a gradient descent search step before the two mode search.
unlike the greedy mode of tca that only considers modifications related to one randomly chosen uncovered combination of values the gradient descent step considers all uncovered combinations and applies the best modification if it can reduce the number of uncoveredt way combinations.
we conduct experiments on a broad range of real world benchmarks and synthetic benchmarks to compare fastca with the state of the art algorithms for ccag.
experimental results show that fastca is faster and obtains better solutions than previous heuristics.
specifically with the time budget of seconds fastca finds cas of much smaller size than other algorithms on most instances and worse on none instance.
besides even the cutoff time for fastca is set to seconds it still finds better or equal cas than those found by other algorithms in seconds.
it means that fastca can generate ca smaller than stateof the art meta heuristic solvers using run time similar to greedy algorithms.
preliminaries a system under test sut is defined as a pair m p c where pis a set of options and ca set of constraints on the permissible combinations of values of the options in p. for each option pi p the set of feasible values is denoted as vi.
to define the ccag problem we need to introduce the notions of tuple andtest case .
definition .
.
given a sut m p c a tuple pi1 vi1 pi2 vi2 .
.
.
pit vit is a set of pairs which implies that option pij ptakes the value vij vij.
a tuple of size tis called a t tuple.
definition .
.
given a sut m p c a test case tcis a tuple that covers all options in p that is it is a complete assignment to p. the value of option pintcis denoted by tc .
for a sut m p c a tuple or test case is valid if and only if it satisfies all constraints in c. a tuple iscovered by a test case tc if and only if tc that is the options in take the same values as in tc.
definition .
.
given a sut m p c at way covering array ca m t is a set of valid test cases such that any valid t tuple is covered by at least one of the test case of ca where tis called the covering strength of ca.
the size of a ca is defined as the number of the test cases contained and it is denoted by .
definition .
.
given a sut m p c and covering strength t the ccag problem is to find a t way ca of minimal size.
.
preliminaries on local search for ccag as almost all meta heuristic algorithms for ccag are based on local search we also provide the basic concepts used in local search for solving ccag.
local search ccag algorithms work with partial covering arries which are defined as follows.
definition .
.
given a sut m p c at way partial covering array partial ca is a set of valid test cases.
a tuple is covered by a partial ca iff it is covered by at least one test case of and the cost of denoted as cost is defined as the number of valid t tuples not covered by .
typically a local search algorithm for ccag starts from an initial partial ca and tries to improve the solution by performing small modifications iteratively.
normally each step of the procedure is to change one option value of a test case which is formally defined as an operation.
towards more efficient meta heuristic algorithms for combinatorial test generation esec fse august tallinn estonia algorithm local search for ccag input sut m p c covering strength t output ca 1 initialization 2while the termination criterion is not met do ifcost 0then 4 5 partial ca of smaller size opset candidate operations forall op opset do calculate score op modify byop opset chosen according to socre op 10return definition .
.
given a partial ca an operation denoted as op tc pi vi modifies the value of one option piof a test case tc to bevi where tc is the test case to be modified pi pis the option and vi viis the new value for pi.
definition .
.
given a partial ca and an operation op the score of the operation is defined as score op cost cost where is the resulting partial ca after applying opto .
the framework of local search algorithms for ccag is presented in algorithm .
at the beginning a partial ca is generated as starting point for the search procedure line .
during each step of the search procedure line it first checks whether the cost of equals to zero.
if a ca is found the algorithm attempts to find ca of smaller size line .
otherwise it collects candidate operation and calculates score for each of them line .
after that one of the operation opchosen according to socre op is applied to .
.
benchmarks and experiment methodology in order to study the algorithms we carry out extensive experiments and report the results in tables.
in this subsection we introduce the benchmarks the experiment setup and reporting methodology for better understanding the experiment parts.
the experiments are conducted on a broad range of benchmarks including real world instances and synthetic instances.
these benchmarks have been widely used to evaluate the performance of ccag algorithms .
real world this benchmark contains six real world instances.
five of them are extracted from nontrivial real world systems including apache bugzilla gcc spin s and spinv.
these instances were introduced by cohen et al.
.
the other instance is tcas which was first introduced by kuhn and okun .
it is a traffic collision avoidance system from siemens suite.
ibm this benchmark contains real world instances generated by or for ibm customers .
these instances cover tar.gz broad range of application including banking systems telecommunications healthcare etc.
synthetic there are instances in this benchmark.
they were generated synthetically from the characteristics found in the five real world instances.
these instances were generated by garvin et al.
.
all experiments were conducted on a computing cluster consisting of computing nodes equipped with dual core .00ghz intel xeon e7 cpus mb l3 cache and gb ram running ubuntu version .
.
lts .
because meta heuristic algorithms are usually randomized for each algorithm we performed independent runs per instance with a cutoff time set to seconds .
all runs were conducted using runsolver version .
.
to measure cpu time and gnu parallel to manage processes.
for each algorithm on each instance we report the smallest size min and the averaged size avg found by the respective algorithm over runs.
in addition for each algorithm on each instance we report the running time time required for finding the optimized cas averaged over runs and all running times were measured in cpu seconds.
if an algorithm failed to find a ca during all runs we report size as .
for each instance the results in bold indicate the best performance in our comparisons.
also we use boldface to indicate the instances where our proposed algorithms are statistically outperform all its competitors w.r.t.
ca size according to wilcoxon rank sum test .
.
score computation in this section we first show that score computation is the most time consuming in meta heuristic algorithms and then propose a novel light weight method for score computation.
.
time consumption of previous score computation the state of the art performance for solving ccag is achieved by the meta heuristic algorithms such as the two mode heuristic algorithm tca and the simulated annealing based algorithm hhsa andcasa .
these algorithms are all based on the local search methodology and the search is guided with the scores of operations.
a commonly used method for computing scores of operations is as follows.
for an operation op tc p v asscore op measures the change on the number of uncovered valid t tuples a straightforward way to compute score op is to check each tuple involving p v .
if the checked tuple becomes covered from uncovered by the operation op it contributes to score op if becomes uncovered from covered it contributes to score op .
the above method for score computation is widely used in previous local search algorithms for ccag.
however this process is of high complexity and is very time consuming in practice.
a simple analysis shows that there are k t tuples to be checked for computing the score of only one operation.
for instance consider the real world instance apache with k 172options and suppose the required covering strength t then we need to check tuples for computing an operation s score.
what is worse in some modes of local search such as the greedy mode of tca the number esec fse august tallinn estonia jinkun lin shaowei cai chuan luo qingwei lin and hongyu zhang table the averaged time consumption in seconds of score computation on each benchmark running tca on each instance with time budget seconds.
t way real world ibm synthetic .
.
.
.
.
.
.
.
.
of candidate operations for which score computation is required is proportional to the size of ca.
to show that the above score computation is time consuming we carry out experiments to give empirical evidences about the time cost of score computation in tca a state of the art metaheuristic algorithm for solving ccag.
we run tca to solve ccag with covering strength between to on three benchmarks which will be introduced in section .
with time budget limited to seconds and one run for each instance.
the instances that can not be solved within the time budget appears in way ccag see table for reference are not considered in the statistics.
the statistics show that the time consumption of score computation occupies a major part of the time budget and increases with the covering strength.
in particular for the real world benchmark it cost .
.
and .
of the time budget respectively for and way covering strength.
therefore improving the efficiency of score computation is critical to the performance of local search algorithms for solving ccag.
.
a lightweight method for score computation in this subsection we propose a lightweight method for score computation.
before describing the method we first give a definition and a lemma.
definition .
.
given a t way partial ca a valid t tuple is covered if and only if there is exactly test cases in cover it.
a covered tuple is indeed an uncovered tuple.
an important fact is that only uncovered and covered tuples are related to the score of an operation.
this observation is formally described below.
lemma .
.
for an operation op tc p v only uncovered and 1covered t tuples may have impact to score op and any covered t tuple with 1has no impact to score op .
proof.
for a tuple pi1 vi1 pi2 vi2 .
.
.
pit vit there are three possibility to consider.
is uncovered tuple.
if and only if the following equation holds vij tc pij p v pij p will be covered by tcafter apply op contributing 1toscore op .
is1 covered tuple.
if it is not covered by tc then the coverage of it is unchanged after the applying op.
otherwise if p v andv v then applying opwill make uncovered contributing 1toscore op .
is covered tuple with .
suppose the tuple is covered by a set of test cases t and t .
iftc t obviously thetable the averaged number of uncovered tuples and 1covered tuples over the procedure of tca when solving 3way ccag in seconds.
instance prev checkuncovered covered num num apache .
.
.
.
bugzilla .
.
.
.
gcc .
.
.
.
spins .
.
.
.
spinv .
.
.
.
tcas .
.
.
total .
.
.
.
banking1 .
.
.
.
banking2 .
.
.
.
commprotocol .
.
.
.
concurrency .
.
healthcare1 .
.
.
.
healthcare2 .
.
.
.
healthcare3 .
.
.
.
healthcare4 .
.
.
.
insurance .
.
.
networkmgmt .
.
.
processorcomm1 .
.
.
.
processorcomm2 .
.
.
.
services .
.
.
.
storage1 .
.
.
storage2 .
.
.
.
storage3 .
.
.
.
storage4 .
.
.
.
storage5 .
.
.
.
systemmgmt .
.
.
telecom .
.
.
.
total .
.
.
.
operation ophas no influence on the coverage of iftc t then either remains covered or becomes covered tuple the proof is similar to .
since the tuple remains covered before and after the operation and thus has no impact to score op .
now we describe the lightweight method for score computation.
for an operation op tc p v its score is computed by the following procedure.
lightweight score computation operation op calculate make op which is the number of uncovered tuples that will become covered after applying op.
calculate break op which is the number of covered tuples that will become uncovered after applying op.
score op make op break op .
by this method the time complex of calculating score is reduced from o k t too c0 c1 where c0andc1is the set of uncovered and covered tuples respectively.
c0 and c1 are typically much smaller than k t .
we run tca on real world instances with time budget seconds to count the averaged number of uncovered and covered tuples in one procedure for score computation.
the results on way ccag are presented in table where prev check denotes the number of tuples need to be checked for computing an operation s score in the previous score computation method.
when compared to the number of tuples need to be checked in the previous score computation method i.e.
k t the numbers of uncovered and 1covered tuples are several orders smaller.
on average c0 k t .
towards more efficient meta heuristic algorithms for combinatorial test generation esec fse august tallinn estonia table tca vstca on the real world and ibm benchmarks instancetca tcatime rmin avg time min avg time apache .
.
.
.
.
bugzilla .
.
.
gcc .
.
.
.
.
spins .
.
.
spinv .
.
.
.
.
tcas .
.
.
banking1 .
.
.
banking2 .
.
.
commproto.
.
.
.
concurrency .
.
.
healthcare1 .
.
.
healthcare2 .
.
.
.
healthcare3 .
.
.
.
.
healthcare4 .
.
.
.
.
insurance .
.
.
networkmg.
.
.
.
proc.comm1 .
.
.
.
proc.comm2 .
.
.
.
.
services .
.
.
.
.
storage1 .
.
.
storage2 .
.
.
storage3 .
.
.
storage4 .
.
.
storage5 .
.
.
.
.
systemmg.
.
.
.
telecom .
.
.
avg time .
.
and c1 k t .
for the real world benchmark and these figures are .
and .
for the ibm benchmark.
.
application to existing algorithms the lightweight score computation method is a generic method that can be used in developing any local search algorithm for ccag that employs scores.
since it can accelerate the existing algorithms a natural question is whether this acceleration leads to performance improvement.
here we present the first research question.
rq1 can the lightweight score computation method improve existing meta heuristic algorithms for ccag?
as the state of the art for solving ccag is acquired by tca we apply the lightweight score computation method to re implement tca and the obtained solver is named tca .
we first measure the speedup of tca over tca by comparing the number of steps executed with the cutoff time of seconds for all instances figure .
on out of instances tca executes times more steps than tca with the same cutoff time.
dramatic speedups are observed on a considerable portion of instances for instances and for of them.
to study whether the acceleration leads to performance improvement we conduct experiments to compare the two solvers performance in terms of solution quality and run time on all benchmarks.
the experimental results on way ccag are presented in table and .
after using the score calculation method proposed tca outperforms the original tca on all instances.
on the metrics of the size of cas tca is better than tca on out of real world instances and out of synthetic instances while worse than tca on none instance.
for the instance where tca andtca findtable tca vstca on the synthetic benchmark instancetca tcatime rmin avg time min avg time syn 1 .
.
.
.
.
syn 2 .
.
.
.
.
syn 3 .
.
.
syn 4 .
.
.
syn 5 .
.
.
.
.
syn 6 .
.
.
syn 7 .
.
.
.
syn 8 .
.
.
.
.
syn 9 .
.
.
syn 10 .
.
.
syn 11 .
.
.
.
.
syn 12 .
.
.
.
.
syn 13 .
.
.
syn 14 .
.
.
syn 15 .
.
.
syn 16 .
.
.
syn 17 .
.
.
.
syn 18 .
.
.
.
.
syn 19 .
.
.
.
.
syn 20 .
.
.
.
.
syn 21 .
.
.
syn 22 .
.
.
syn 23 .
.
.
syn 24 .
.
.
.
.
syn 25 .
.
.
.
syn 26 .
.
.
.
.
syn 27 .
.
.
syn 28 .
.
.
.
.
syn 29 .
.
.
.
syn 30 .
.
.
.
.
avg time .
.
cas of the same size tca is always faster than tca.
to further show the efficiency of the score computation method we report the running time time r averaged over runs when tca find cas of the same size with tca on each instances.
as shown in the last column in table and table tca uses much less time to find cas found by tca in seconds.
for example on the apache instance the running time needed for tca is only .
seconds while tca needs .
seconds.
more significant improvements can be seen on the synthetic benchmarks.
it is also worthy to remark that since most meta heuristic algorithms for ccag use scores to guide the search our method for score computation is also useful to improve other algorithms.
the fastca algorithm thanks to the lightweight score computation method some algorithmic strategies that are not affordable previously now can be implemented with affordable time consumption.
in this section we further improve the tca algorithm by integrating a gradient descent mode which relies heavily on score computation leading to a new algorithm called fastca .
tca works between the random mode and greedy mode.
while the random mode is for better exploring the search space the greedy mode focuses on finding good operations to reduce uncovered tuples of the partial ca.
however tca searches for good operations w.r.t.
scores within a limited space.
it only considers operations involving one selected uncovered tuple.
therefore there is a considerable probability that the score of the chosen operation is negative esec fse august tallinn estonia jinkun lin shaowei cai chuan luo qingwei lin and hongyu zhang .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e .0e steps of tca in seconds steps of tca in seconds1x 10x 100x figure the number of steps of tca andtca for solving way ccag on real world and synthetic benchmarks.
indicating an increment on the number of uncovered tuples even when there are other operations of positive score.
the considerations above suggest that the exploitation corresponding to operations with positive scores of the search in tca should be enhanced.
according to research on local search whenever there is an operation leading to a better objective function it should be taken .
a reason that tca does not adopt such strategies might be that the original score computation in tca is quite time consuming making it not affordable to check many uncovered tuples.
thanks to the lightweight score computation method proposed in this work the dilemma no longer exists making it possible to integrate exploitation strategies to improve the algorithm.
this results in a new meta heuristic algorithm called fastca .
.
the description of fastca the pseudo code of the fastca algorithm is described in algorithm .
in the beginning fastca calls an initialization function to construct a ca which serves as a starting point for the search procedure line .
we use a well known greedy ccag solver acts in this procedure.
while the acts solver does not aim at cas of optimal size it can generate a ca of reasonable size quickly.
after the initialization fastca executes a loop of iterative modification steps until the termination criterion is met it is time budget usually .
whenever the algorithm successfully finds a ca of size nwhich covers all valid tuples it removes one test case from and goes on to search for a ca of size n line .
during the search process there are three important components in fastca including the gradient descent procedure the greedy mode searching and the random mode searching.
as the name indicates in the gradient descent search procedure fastca employs a gradient descent step according to the scores of operations.
it checks all uncovered valid t tuples to search for descent operations i.e.
with positive scores .
for each uncovered valid t tuples the algorithm calculates the score of each operation which can be performed subject to the tabu condition to cover thealgorithm the fastca algorithm input sut m p c covering strength t output ca 1 initialization 2 3while the termination criterion is not met do ifthere is no uncovered tuple then 5 remove one row from 7 gradient descent ifgradient descent is not successful then ifwith probability pthen random mode else greedy mode 13return tuple.
if there are any operation with positive score then the one with the greatest score is executed.
if there is no such operation fastca executes a two mode search process similar to tca.
with a probability p it works in the random mode otherwise with a probability p it works in the greedy mode.
unlike the gradient descent search procedure only one uncovered tuple is considered in this process.
one can refer to the description on tca in the related work section for details of the two mode search process.
.
gradient descent function the gradient descent function of fastca employs the tabu search heuristic .
before describing the details we give several definitions and notations below for better understanding the algorithm.
definition .
.
given a partial ca and a test case tcof an option pis a tabu option of tcif and only if tc has been changed during the last tsearch steps where tis the tabu tenure.
for simplification we say tc p is of tabu status.
definition .
.
given a partial ca and an uncovered tuple an operation op tc p v is feasible if and only if it meets all these criteria tc p is not of tabu status the resulting tcis valid and covers .
the set of feasible operations w.r.t.
an uncovered tuple is denoted by opset .
the pseudo code of the gradient descent search is described in algorithm .
different from the greedy mode of tca it checks all the uncovered valid t tuples under the current partial ca .
for each tuple the score of each feasible operation is calculated using the lightweight score computation method proposed in section .
each time a better score is found bestscore is updated accordingly and the responding operation is recorded line .
after all the scores related to uncovered valid tuples have been checked if bestscore the operation bestop of which the score isbestscore is applied to line .
otherwise the gradient descent process fails and stays unchanged.
towards more efficient meta heuristic algorithms for combinatorial test generation esec fse august tallinn estonia algorithm gradient descent input partial ca a set of uncovered valid t tuples s output partial ca 1bestscore 2forall sdo forall op opset do calculate score op ifscore op bestscore then bestscore score op bestop op 8ifbestscore 0then 9 execute bestop to 10return experiments in this section we conduct extensive experiments to evaluate the efficiency and effectiveness of fastca by comparing it with stateof the art algorithms for ccag.
since way ccag can be solved effectively by existing algorithms the experiments focus on way ccag.
in addition although way ca can reveal more failures of systems it remains very difficult for current solvers and few related work report results on it.
in our work we also investigate the performance of current state of the art algorithms for solving way ccag and compare that with the performance offastca .
.
research questions we present the research questions before describing the details of experiments.
rq2 how does fastca compare against current state ofthe art algorithms for way ccag?
the size of ca implies the number of test case needed to validate the correctness of a system.
therefore to find cas as small as possible is the primary goal of ccag.
in our experiments we set the time limit to seconds and compare fastca against its competitors.
rq3 can fastca outperform the current state of the art algorithms for way ccag with a smaller time budget?
meta heuristic algorithms can find smaller cas than greedy algorithms with more time consumption.
greedy algorithms can generate cas in a short time but the size of cas are usually larger.
fastca is proposed with expectation that it combines the advantage of greedy algorithms and meta heuristic algorithms.
thus we are interested in whether fastca is efficient enough to provide good solutions in short time.
in our experiments we limit the runtime of fastca to seconds and compare it against other solvers with runtime limited to seconds.
rq4 what is the performance of fastca and its competitors for way ccag?
it is well recognized that way ccag solving remains a challenge for existing ccag solvers due to the huge size of search space.
in order to demonstrate the generality and the superiorityoffastca we conduct experiments to compare fastca with its competitors for solving way ccag.
.
state of the art competitors in this subsection we compare fastca with state of the art ccag algorithms i.e.
tca hhsa casa and acts .
unlike the former three meta heuristic algorithms acts is a greedy algorithm.
it can construct cas in a short time while the size is generally larger than meta heuristic algorithms.
as it is used in the initialization of fastca we also included acts in the competition to evaluate the improvement of fastca s search procedure.
these solvers are all available online.
tca4is an efficient two mode meta heuristic algorithm.
it works between the greedy mode and the random mode.
as reported in the literature tca can generate cas of obviously smaller size than its competitors.
hhsa5is a hyper heuristic search algorithm.
it works in a simulated annealing framework using a reinforcement learning agent to dynamically choose different strategies without active supervision.
casa6is a simulated annealing algorithm which is improved from previous algorithms by using a reorganized search space based on the ccag problem structure.
acts7is an in parameter order algorithm which can handle constraints efficiently.
while the former three solvers are written in c acts is developed using java.
.
experimental setup the experimental setup used in this section is the same as the one described in section .
.
in the last row of the tables we report the number of instances where fastca finds better or equal sized ca than its competitors.
in addition in order to show the efficiency of fastca we also evaluate fastca with the cutoff time of seconds per run for solving way ccag on all testing benchmarks.
.
experimental results in this subsection we present the experimental results to answer each research question mentioned in section .
.
results on comparing fastca against its competitors for way ccag rq2 tables and show the results of fastca column fastca 1000s and its competitors for way ccag.
when the cutoff time is limited to seconds as can be seen from the tables fastca significantly outperforms other solvers on both the real world and synthetic benchmarks.
on the metrics of ca size fastca finds better solutions than the best competitor tca on out of instances and finds equal sizes on the remaining ones.
for the real world and ibm benchmarks we focus on the difficult instances which need more than seconds averaged runtime for all solvers excepting the greedy algorithm acts .
on these instances the size of cas found by fastca are usually much smaller than its competitors.
for example on the apache instance the averaged size found by fastca is134.
while the number for tca linux 64.tar.gz esec fse august tallinn estonia jinkun lin shaowei cai chuan luo qingwei lin and hongyu zhang table comparing fastca against state of the art competitors for way ccag on the real world and ibm benchmarks.
the running time is measured in cpu second.
the cutoff time is set to 100s for fastca and 1000s for the other solvers instancefastca 1000s fastca 100s tca 1000s acts 1000s hhsa 1000s casa 1000s min avg time min avg time min avg time min time min avg time min avg time apache .
.
.
.
.
.
.
.
.
bugzilla .
.
.
.
.
.
.
.
gcc .
.
.
.
.
.
.
.
spins .
.
.
.
.
.
.
.
spinv .
.
.
.
.
.
.
.
tcas .
.
.
.
.
.
.
banking1 .
.
.
.
.
.
.
banking2 .
.
.
.
.
.
.
commproto.
.
.
.
.
.
.
.
concurrency .
.
.
.
.
.
healthcare1 .
.
.
.
.
.
.
healthcare2 .
.
.
.
.
.
.
.
.
.
healthcare3 .
.
.
.
.
.
.
.
.
.
healthcare4 .
.
.
.
.
.
.
.
.
.
insurance .
.
.
.
.
.
networkmg.
.
.
.
.
.
.
.
proc.comm1 .
.
.
.
.
.
.
.
.
.
.
proc.comm2 .
.
.
.
.
.
.
.
.
.
services .
.
.
.
.
.
.
.
.
storage1 .
.
.
.
.
.
storage2 .
.
.
.
.
.
.
storage3 .
.
.
.
.
.
.
.
storage4 .
.
.
.
.
.
.
storage5 .
.
.
.
.
.
.
.
.
systemmg.
.
.
.
.
.
.
.
.
telecom .
.
.
.
.
.
.
better euqal of fastca is156.
for casa is247.
hhsa fails to solve apache within the time limit.
the gap between different solvers is even larger on the synthetic benchmark as can be seen from table .
since fastca uses the greedy algorithm acts as its initialization we study how much the search procedure can reduce the size of cas.
as shown in the tables fastca generates cas of significant smaller size than acts on almost all the instances.
besides for out of real world instances and out of synthetic instances it reduces the size of cas found by acts by more than test cases.
in particular on the services instance it reduces the size from to totally test cases.
these results indicate that fastca advances the state of the art for solving the way ccag problem.
results on comparing fastca with considerably less cutoff time against its competitors for way ccag rq3 the results are presented in tables and column fastca 100s .
fastca with the cutoff time of seconds still finds better or equal sizes of cas than all its competitors with the times longer cutoff time on all testing instances.
besides the gaps between fastca and its competitors observed in rq2 also appear here.
particularly on the gcc instance fastca finds cas of averaged size .6in75.
seconds while tca finds .6in802.79seconds and casa finds 140in943.47seconds.
overall the runtime for fastca is much shorter than other solvers for achieving solutions with better or equal size.
when it comes to the comparison between fastca andacts it is shown that seconds is sufficient to dramatically reduce the size of cas.
averagely more than test cases are reduced by the search procedure of fastca .
therefore if a test case takesmore than three seconds to run in the test process then fastca is preferred.
for the situation where ca is repeatedly used such as regression testing the advantage of fastca in practice is more obvious.
results on the performance of fastca and its competitors for way ccag rq4 table presents the results of way ccag solving on the real world and ibm benchmarks the results on the synthetic benchmarks are available online8.
since the hhsa algorithm available online cannot solve way ccag we do not report its result here.
it is shown that fastca outperforms other algorithms on all instances.
it can generate smaller cas in shorter time than its competitors.
for many instances such as spinv healthcare4 and storage4 the sizes of cas found by fastca is several hundreds or even thousands smaller than those found by other solvers indicating the superiority of fastca on way ccag.
discussion on the results of fastca for way ccag for comprehensive evaluation we summarize the empirical results for way ccag here.
on all instances fastca finds cas of smaller or equal size than its competitors.
in particular it finds better cas than tca on instances.
to achieve solution of equal size fastca is also faster than other solvers on nontrivial instances.
discussion on the effectiveness of the components underlying fastca in order to illustrate the contribution of gradient descent search to fastca we remove this component from fastca resulting in an alternative version named fastca .
experimental results on real world benchmarks for way ccag show that with the gradient descent search fastca generates smaller cas on towards more efficient meta heuristic algorithms for combinatorial test generation esec fse august tallinn estonia table comparing fastca against state of the art competitors for way ccag on the synthetic benchmarks.
the running time is measured in cpu second.
the cutoff time is set to 1000s for all solvers.
instancefastca 1000s fastca 100s tca 1000s acts 1000s hhsa 1000s casa 1000s min avg time min avg time min avg time min time min avg time min avg time syn 1 .
.
.
.
.
.
.
.
.
syn 2 .
.
.
.
.
.
.
syn 3 .
.
.
.
.
.
.
.
syn 4 .
.
.
.
.
.
.
.
syn 5 .
.
.
.
.
.
.
.
syn 6 .
.
.
.
.
.
syn 7 .
.
.
.
.
.
.
.
.
.
syn 8 .
.
.
.
.
.
.
.
.
syn 9 .
.
.
.
.
.
.
syn 10 .
.
.
.
.
.
.
.
syn 11 .
.
.
.
.
.
.
.
.
syn 12 .
.
.
.
.
.
.
.
syn 13 .
.
.
.
.
.
.
syn 14 .
.
.
.
.
.
syn 15 .
.
.
.
.
.
syn 16 .
.
.
.
.
.
syn 17 .
.
.
.
.
.
.
.
.
syn 18 .
.
.
.
.
.
.
syn 19 .
.
.
.
.
.
syn 20 .
.
.
.
.
.
.
.
.
syn 21 .
.
.
.
.
.
syn 22 .
.
.
.
.
.
syn 23 .
.
.
.
.
.
.
.
syn 24 .
.
.
.
.
.
.
.
.
syn 25 .
.
.
.
.
.
.
.
syn 26 .
.
.
.
.
.
.
.
.
syn 27 .
.
.
.
.
syn 28 .
.
.
.
.
.
.
syn 29 .
.
.
.
.
.
syn 30 .
.
.
.
.
.
.
.
.
better equal of fastca out of instances than fastca .
for the other instance fastca andfastca generate cas of the same size and most of them are solved within seconds.
we study the importance of the lightweight score computation by comparing fastca with its alternative fastcap implemented with the previous score computation method on real world instances of way ccag.
instances are easy for both algorithms they all find the same sized cas in seconds.
fastca finds better solutions than fastcap on the rest instances and takes less time to seconds less on of them.
indeed a premise of employing the gradient descent search to improve the algorithm is the lightweight score computation.
to give evidence on this we remove gradient descent search from fastcap leading to fastcap .
experiments on way ccag show that the gradient descent component only improve on instances while decrease the performance on instances on the metric of size of cas.
it makes fastcap worse than fastcap .
.
threats to validity it seems that the cutoff time setting is a threat to validity to our experimental results since seconds might not be enough to exploit the performance of hhsa andcasa .
however compared to the current best known solutions for most instances reported in literature we could found seconds even seconds are enough for fastca to achieve much better solutions.
in fact as reported in the papers of hhsa and casa although hhsaandcasa cost much more time even more than hours on some instances the solutions found are still much worse than fastca .
besides we run hhsa andcasa on real world benchmarks with the cutoff time of hours and fastca using the cutoff of only seconds still significantly outperforms such results.
since tca is the main competitor in our experiment we hence follow the experimental setup in tca paper and use seconds as the cutoff.
related work practical algorithms for solving ccag can be roughly categorized into three main groups constraint encoding algorithms greedy algorithms and meta heuristic algorithms.
constraint encoding algorithms focus on efficient methods to encode ccag into constrained optimization problem such as sat and maxsat problems .
while constraint encoding algorithms are effective for solving 2way ccag it required improvements to handle way ccag .
greedy algorithms can usually generate cas in a short time.
although the size of cas is not necessarily small greedy algorithms show its superior in some scenarios where highly optimized test suite is not the primary consideration.
one test at a time otat and in parameter order ipo are two main approaches of greedy algorithms.
the well known aetg algorithm is the first one using theotat strategy and since then a number variants were proposed to improve its performance .
the iop esec fse august tallinn estonia jinkun lin shaowei cai chuan luo qingwei lin and hongyu zhang table comparing fastca against state of the art competitors for way ccag on the real world and ibm benchmarks.
the running time is measured in cpu second.
the cutoff time is set to 1000s for all solvers.
instancefastca 1000s tca 1000s acts 1000s casa 1000s min avg time min avg time min time min avg time apache bugzilla .
.
.
.
.
.
.
gcc spins .
.
.
.
.
.
spinv .
.
.
.
.
tcas .
.
.
.
banking1 .
.
.
.
.
banking2 .
.
.
.
.
commprotocol .
.
.
.
.
concurrency .
.
.
.
healthcare1 .
.
.
.
.
healthcare2 .
.
.
.
.
.
.
healthcare3 .
.
.
.
.
.
.
healthcare4 .
.
.
.
.
.
insurance .
.
.
.
.
networkmgmt .
.
.
.
.
processorcomm1 .
.
.
.
.
.
processorcomm2 .
.
.
.
.
.
.
services .
.
.
.
.
.
.
storage1 .
.
.
.
storage2 .
.
.
.
.
storage3 .
.
.
.
storage4 .
.
.
.
.
.
storage5 .
.
.
.
.
systemmgmt .
.
.
telecom .
.
.
.
.
better equal of fastca strategy was first proposed by lei and tai to generate way cas and was later generalized to t way cas .
meta heuristic algorithms aim at reducing the size of cas with a price of more time consumption.
most state of the art solvers for ccag such as tca hhsa and casa can be categorized into this group.
the main procedure of these algorithms is searching for cas of iteratively smaller size.
there are many strategies have been proposed for improving the effectiveness of the search procedure including tabu search hyper heuristics simulated annealing and t set replacement .
these strategies are used to guide the search to more promising areas usually based on the scores of candidate operations.
the tca algorithm uses two mode heuristics in its searching procedure.
the greedy mode of tca devotes to decreasing the number of uncovered tuples while the random mode provides opportunities to escape from local optimal and better explore the search space.
in the random mode of tca it randomly deletes one test case from the current partial ca and generates a new one to cover the pre selected uncovered tuples.
when it is in the greedy mode tca takes one uncovered tuple randomly and choose the best operation to cover it based on the score calculated.
as revealed in this work the score computation costs a primary part of time budget and can be significantly reduced by our lightweight method.
search based software engineering is a research area that reformulates software engineering problems as optimization problems and then resorts to mete heuristics algorithms for solving.
there are many studies of practical problems such as test case generation program refactoring prioritization for regression testing and module clustering which all belong to thisarea of research.
in this sense our work also falls under the research area of search based software engineering.
conclusion the constrained covering array generating ccag problem is a challenging problem in combinatorial test generation.
a promising approach to this np hard problem is to find good solutions by metaheuristic algorithms.
a big issue in meta heuristic algorithms for ccag is the heavy time consumption of score computation which not only accounts for the low speed of the algorithms but also hinders the applications of many good algorithmic ideas relying on scores.
this paper addressed this issue by proposing a lightweight method for score computation.
we applied it to re implement a state of the art meta heuristic algorithm tca and finds significant speedup as well as performance improvements on real world and synthetic benchmarks.
additionally the lightweight score computation method opens a door to make more algorithm ideas affordable and thus more elaborate algorithms can be developed.
we took a step of this direction by integrating a gradient descent component totca with the lightweight score computation method leading to a new meta heuristic algorithm called fastca .
experiments on a broad range of real world and synthetic benchmarks show that fastca is faster and finds better solutions than existing algorithms which remains justified even when the cutoff time 100s for fastca is set to of that 1000s for the competitors.