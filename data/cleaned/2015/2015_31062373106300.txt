automatically diagnosing and repairing error handling bugs in c yuchi tian baishakhi ray university of virginia charlottesville va usa yuchi rayb virginia.edu abstract correct error handling is essential for building reliable and secure systems.
unfortunately low level languages like c often do not support any error handling primitives and leave it up to the developers to create their own mechanisms for error propagation and handling.
however in practice the developers often make mistakes while writing the repetitive and tedious error handling code and inadvertently introduce bugs.
such error handling bugs often have severe consequences undermining the security and reliability of the affected systems.
fixing these bugs is also tiring they are repetitive and cumbersome to implement.
therefore it is crucial to develop tool supports for automatically detecting and fixing error handling bugs.
to understand the nature of error handling bugs that occur in widely used c programs we conduct a comprehensive study of real world error handling bugs and their fixes.
leveraging the knowledge we then design implement and evaluate errdoc a tool that not only detects and characterizes different types of error handling bugs but also automatically fixes them.
our evaluation on five open source projects shows that errdoc can detect error handling bugs with to precision and around recall and categorize them with to precision and above recall.
thus errdoc improves precision up to percentage points and recall up to percentage points w.r.t.
the state of the art.
we also demonstrate that errdoc can fix the bugs with high accuracy.
ccs concepts software and its engineering software testing and debugging empirical software validation theory of computation program analysis keywords error handling bugs bug fix api errors bug detection acm reference format yuchi tian baishakhi ray.
.
automatically diagnosing and repairing error handling bugs in c. in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
introduction secure and reliable software must handle all possible failure conditions correctly.
modern programming languages therefore provide exception handling features so that software can behave gracefully even when lower level functions fail.
unfortunately low level languages like c do not have any native error handling primitives.
therefore in c the developers are forced to create their own error handling conventions often in ad hoc program specific manner.
such error handling code is usually repetitive and tedious to write correctly resulting in error handling bugs.
these bugs often lead to serious security and reliability flaws e.g.
cve cve cve cve and cve .
in fact improper error handling is one of the top causes of security vulnerabilities according to the open web application security project owasp .
common testing techniques usually fail to detect these bugs as most of the errors do not show up during regular executions.
moreover manually creating test cases to cover all possible error paths is not scalable for large real world programs.
due to severe implications of error handling bugs prior researchers have put significant effort in detecting them automatically.
however we still see a steady influx of error handling bugs several of which result in security vulnerabilities.
for example there are already two common vulnerability and exposure cve reports in cve cve about error handling bugs.
in order to understand the true nature of these bugs in practice we begin with a comprehensive study of real error handling bugs from 6large open source software.
we create a taxonomy of these bugs to understand their underlying causes.
our results indicate that error handling bugs usually occur due to four causes incorrect missing error checks incorrect missing error propagation incorrect missing error outputs and incorrect missing resource release.
while existing bug finding tools can partially detect some of these bugs a large proportion of them remains yet undetected.
leveraging the findings of our study we design and implement a tool errdoc that can detect and categorize all classes of error handling bugs.
using under constrained symbolic execution errdoc first explores all the error paths the paths along which a function can fail.
if a function fails the error needs to be handled properly along the error path.
to ensure that errdoc uses a combination of static analysis techniques and verify whether the error value returned from the failing function is checked propagated upstream or logged.
if none of these happen errdoc reports error handling bugs.
errdoc further ensures that a program can fail gracefully by releasing all the allocated resource.
if resources are not freed along an error path errdoc reports those cases as bugs.
we find that errdoc can detect error handling bugs with to precision esec fse september paderborn germany yuchi tian baishakhi ray and around recall.
to provide developers more information about the underlying causes of the bugs errdoc also categorizes these bugs with to precision and above recall.
in our case study we further notice that fixing error handling bugs is a repetitive and tenuous process.
most functions have their own error handling protocol.
to fix an error handling bug the developer not only has to fix the bug correctly but also follow the existing protocol to improve code readability and decrease maintenance overhead.
therefore the fixes to error handling bugs themselves often introduce new bugs.
in this paper we propose an algorithm to automatically generate patches for fixing different types of error handling bugs.
this algorithm modifies the abstract syntax tree ast of the buggy code to introduce the bug fixes.
one of the key characteristics of our patch generation algorithm is that the generated patches not only fix the corresponding error handling bugs but also blend into the existing error handling code seamlessly.
therefore such patches are more useful to the developers as demonstrated by the fact that several of our automatically generated patches are already accepted by openssl developers as bug fixes without any further modifications.
overall the bug fixing phase generates acceptable patches with to precision.
to this end we make the following contributions we conduct a comprehensive study to understand the characteristics of error handling bugs.
we present to the best of our knowledge the first classification of error handling bugs into four different categories incorrect missing error propagation incorrect missing error checks incorrect missing error outputs and incorrect missing resource release.
we design and implement errdoc a tool to automatically detect categorize and fix error handling bugs.
to our knowledge errdoc is the first tool that can automatically categorize and fix error handling bugs.
we present an extensive evaluation of errdoc on five large open source software including openssl gnutls wolfssl curl and httpd.
we find new bugs in openssl.
we are in the process of reporting them.
three of the patches generated by errdoc have already been accepted by the developers.
the rest of the paper is organized as follows.
section presents the comprehensive study on real world error handling bugs.
section introduces the tool errdoc followed by its implementation and evaluation in section and section respectively.
we discuss related work in section and conclude our work in section .
manual study to better understand what kind of error handling bugs occur in real c code and how developers fix them in practice we manually studied real world error handling bugs and their fix patches.
in this section we will discuss our study method and findings in detail.
study subject.
we collected version history from open source projects written in c. table summarizes the study subjects.
in total we have studied around 13m loc and 30k commits with a parallel development history of up to years.
study method.
for each studied project we begin with extracting all the changes committed within the studied time period.
a change typically contains a commit log and a patch see table along with other meta information.
from these changes we trytable study subjects studied total total eh project loc period commits bug fixes bugs openssl to gnutls to wolfssl to curl to httpd to linux to total to identify error handling bug fix related commits.
first from the commit messages we remove stopwords punctuations and other program identifier related information and stem the commit message using standard natural language processing nlp techniques.
we mark the corresponding commit to be bug fix related if the processed commit messages contain at least one of the following keywords bug fix check issue mistake incorrect fault defect and leak .
among the identified bug fix commits we further search for some combinations of error handling bug related keywords error path memory leak unchecked return error handl error check and check return .
for example we identify an openssl commit sha 0a618df with commit message fix a mem leak on an error path as a error handling bug fix commit.
to evaluate the precision of the above classification we randomly choose commits from each project that are marked as error handling bug fix.
we manually verify the commit messages and their corresponding patches.
out of commits are classified correctly thus giving a precision of .
.
only commits are misclassified.
in all these misclassified commits although the relevant keywords are present in their commit messages they were not related to error handling bugs.
for example commit message of one misclassified httpd change sha 068854a message apr have foo is checked via if not ifdef ... this fixes a compile error contains fix check and error keywords however it was referring to a compilation problem.
table studied error handling bugs patches projects ec ep rr eo others total openssl gnutls curl httpd wolfssl linux total .
.
.
.
.
characterization of the bugs fixes.
in our study we found total error handling bugs across all the projects see table .
among these bugs we randomly choose bugs and manually investigate them both commit messages and patches to understand the reason behind these errors.
based on this study we identify four different categories of error handling bugs incorrect missing error checks ec incorrect missing error propagation ep incorrect missing error outputs eo and incorrect missing resource release rr see table .
we use the code snippets in table to discuss each of the categories below.
.ec incorrect missing error checks when an api function say api test fails it usually indicates the failure to its caller by returning an appropriate error code.
thus after calling api test the caller should check its return value in case api testreturns an error code as per api test specification the caller should handle the failure properly.
however we find that developers often forget to check 753automatically diagnosing and repairing error handling bugs in c esec fse september paderborn germany table examples of error handling bugs of different types .
ec a missing error checks project openssl commit id b197257d71694fd52ab61d173f77c8a120d3eead file crypto ocsp ocsp ext.c author matt caswell matt openssl.org date log check for error return from asn1 object size os.
length asn1 object size len ... if os.length goto err ... ec b incorrect error checks project curl commit id 520833cbe1601feed1c6473bd28c4c894e7ee63e file lib ssluse.c author mike giancola mikegiancola gmail.com date log ossl recv ssl read returning is an error too nread ssize t ssl read ... if nread if nread int err ssl get error ... .
ep incorrect missing error propagation project openssl commit id e0670973d5c0b837eb5a9f1670e47107f466fbc7 file ssl ssl ciph.c author date log mem leak on error path and error propagation fix int ssl comp add compression method ... if id id sslerr ... return return .
eo incorrect missing error outputs project wolfssl commit id fa5dd0100146222a43d7562fdb2c600f481eaecf file wolfcrypt test test.c author david garske david wolfssl.com date log ... added error message for ecc test failures to show the curve size used ... ret ecc test curve size rng keysize ... if ret printf ecc test curve size d failed!
d keysize ret return ret .
rr incorrect missing resource release project openssl commit id 85d6b09ddaf32a67a351521f84651c3193286663 file crypto srp srp lib.c author matt caswell matt openssl.org date log fix mem leak on error path bignum srp calc u ... ... if cab openssl malloc longn null goto err ... err openssl free cab evp md ctx free ctxt return u the api return values.
table ec a shows such an example from openssl.
here the caller function calls api asn1 object size that returns on failure.
the caller function did not check whether the api returns an error code which causes an error handling bug.
developers fixed the bug in subsequent commit as shown in the example.
moreover developers sometimes check some return values but not the entire range of possible error codes that api test can return as shown in example ec b in table .
the api function ssl read can return as error code.
however the developer only checked for which causes the error handling bug.
developer fixed the bug in the commit shown in the example by adding the check for zero.
as per table .
of the studied bugs belong to this ec category.
fix the fixed patches usually include the missing check of the api return value using if statement or correcting the if condition to check all possible error codes.
in the corresponding error handling code i.e.the code within if block developers usually output an error message notifying users about the failing condition or propagate an error value upstream using an appropriate error return code.
.ep incorrect missing error propagation to handle an api failing condition correctly a caller may propagate the error code upstream using an appropriate return value to inform the rest of the system about the failure.
however we find that developers often forget to propagate the correct error code.
also due to complicated logic in the caller function the return value with correct error code may get overwritten with non failure values or the caller may return from another successful path by ignoring previous failing conditions.
for example see ep case in table .
the caller function ssl comp add compression method should return on error and on non error.
however the developer returned from an error path by mistake which was fixed in the subsequent patch.
table shows that only .
of the studied bugs belong to this category.
fix the fixed patches ensure to return the correct error values as per the callers error specifications.
.eo incorrect missing error outputs an api failure can be handled by logging outputting an appropriate error message so that the users become aware of the failure.
however in error handling code developers often forget to output an appropriate error message either no error message is logged or outputted or the error message is incorrect unclear or lacks details.
consider the eo example in table the wolfssl developer forgot to output an error message he later corrected it by showing the keysize and return value.
.
of the studied bugs belong to this category see table .
fix the fixes often include adding statements to output error messages or changing error messages with more specific details.
.rr incorrect missing resource release even if developers have logged or propagated error code correctly they often forget to release locally allocated resources e.g.
free memory in the error handling code causing rr bugs.
as shown in example rr in table developer allocated cab using openssl malloc but forgot to free that in the corresponding error handling code under errlabel.
the highest number of error handling bugs .
come from incorrect missing resource release category see table .
754esec fse september paderborn germany yuchi tian baishakhi ray fix to fix rr bugs the patches usually include adding the specific resource free function calls in the error handling code.
sometimes developers put all the free statements in one block and call them using goto statement from the error handling code to free all the resources together.
.other error handling bugs out of .
studied bugs arise due to some other issues in error handling code which may not be directly related to error handling bugs.
these include fixing double free mistakes refactoring or changing styles of error handling code and improving cleaning error handling code.
generic observation on bug fix patches.
although the error handling bug fix patches as discussed above under each category may seem to be quite straightforward to fix we notice that a real patch often shares similar characteristics of other error handling code in its immediate context.
for example if a caller function implements a common error handling code using errlabel see example rr in table a fix patch often calls goto err and implement the relevant error handling code within the common error handling block under label err.
even if semantically correct a fix patch does not get accepted by the project developers if the patch does not follow the protocol followed by other error handling code in the same local context.
threats to validity.
we investigate the error handling bugs in the studied projects for a given time period so our study may not cover all the error handling bugs and patches in these projects.
the collection of error handling bugs and patches is based on nlp techniques and keyword matching developers may not put the keywords that we look for in the commit messages.
also our manual categorization may be affected by inspectors biases.
approach here we introduce how errdoc errordoctor detects and diagnoses potential error handling bugs in c programs and also fixes them.
if a function call say f fails for some reason and returns an error to its caller say fcaller the caller must handle the error properly otherwise an error handling bug may occur.
if fcaller fails to do so an error handling bug may occur.
we begin with defining several key terms used in this work.
definition .
.
control flow graph cfg a cfg of a function in the program is a directed graph represented by a tuple n e .
n is the set of nodes where each node is labeled with a unique program statement.
the edges e n n represent possible flow of execution between the nodes in the cfg.
each cfg has a single begin n be in and end n end node.
all the nodes in the cfg are reachable from the n be innode and the n endnode is reachable from all nodes in the cfg.
definition .
.
path a path p is a sequence of nodes n0 n1 ....nj in a cfg such that there exists an edge between n kand n k i.e.
nk nk e for k ... j .
definition .
.
error path for a function pair fand its caller fcaller an error path path err fcaller f is a path that starts from nbe inoffcaller s cfg contains the function call to f follows a branch in f s cfg along which f s error conditions are satisfied and ends at n endoffcaller s cfg.
note that an error path spans over the cfgs of both fcaller and f. in figure callee evp digest returns error along path s2 s4 figure sample error path marked in red and error handling code marked in gray in the cfgs of fcaller andf.
here 0indicates failure while 1indicates success.
s5 the corresponding error path marked in red spans over the cfgs of both caller asn1 digest andevp digest l0 l1 s2 s4 s5 l3 l4 .
definition .
.
non error path for a function pair fand its caller fcaller a non error path path nerr fcaller f is a path that starts from n be inoffcaller s cfg contains the function call to f follows a branch in f s cfg along which f s error conditions are not satisfied and ends at n endoffcaller s cfg.
in the above example of figure path nerr fcaller f is marked as l0 l1 s2 s3 s5 l2 l4 .
definition .
.
error handling code for a function pair fand its caller fcaller error handling code is a sub graph in fcaller s cfg along the error path path err fcaller f that explicitly checks the error value returned by fand performs a special processing.
here fcan return error code by explicit return statement or changing the value of its function arguments if called by reference.
in figure gray nodes indicate error handling code.
.
overview an overview of errdoc s workflow for a target function fis shown in figure .
errdoc takes five inputs the signature of a fallible function f and their caller functions fcaller f s error specifications ferrspec global non error specification global nerrspec and a list of logging functions loggers .
a list of fallible functions that need to be tested and loggers are created manually ferrspec andglobal nerrspec are generated by either apex or entered manually and the caller functions are automatically detected by project specific call graph.
errdoc then works in three phases.
in phase i given each caller and callee pair errdoc detects all possible error paths step i a identifies error handling code along each error path step i b and looks for function pairs that often occur together along error paths step i c .
errdoc then detects and categorizes different types of error handling bugs in phase ii.
finally in phase iii errdoc leverages the knowledge from previous phases to fix the bugs.
the rest of the section discusses each of the phases in details.
listing serves as a motivating example to illustrate each step.
.
phase i. explore error paths this phase works in three steps identifying error paths detecting error handling code and function pairs along those paths.
step i a. identify error paths.
for a given function under test f its caller function fcaller and error specifications ferrspec as input errdoc symbolically executes fcaller and checks if fis 755automatically diagnosing and repairing error handling bugs in c esec fse september paderborn germany figure errdoc workflow called at each method call.
if found errdoc symbolically executes f and checks its return value fret at the call site along all the possible return paths.
if fret ferrspec is satisfiable then the corresponding path is marked as an error path otherwise it is marked as a nonerror path.
errdoc marks all the corresponding cfg nodes and edges along the error path.
this step is adapted from our previous tool .
step i b. identify error handling code eh along an error path.
along an error path path err fcaller f errdoc determines the corresponding error handling code in fcaller .
this is done at ast level i.e.errdoc identifies an ast subtree corresponding to the error handling code.
first errdoc identifies the ast sub tree of fcaller that constitutes the error path.
it then identifies the ast nodes related to fmethod call.
in particular errdoc matches the node type to be call expression and node value to bef.
let s call such node as fast.
next errdoc identifies the error handling code based on three heuristics.
along the error path if fasthas an immediate parent ifstatement and fastis inside the condition part of the if statement then errdoc considers the corresponding then orelse part whichever falls in the error path of the ast sub tree as potential error handling code.
for example if f then eh code see lines to in listing .
along the error path if the variable storing return value of fis inside the condition part of a fast s subsequent if statement then errdoc considers the corresponding then else part whichever falls in the error path of the ast sub tree as potential error handling code.
for example int b f if b then eh code see lines to in listing .
since error paths usually contain significantly fewer statements than non error paths errdoc considers the number of statements in the identified error handling code should be .
otherwise errdoc disregards the code block as error handling code.
step i c. identify function pairs fp along error paths.
certain resource related functions like malloc andfree orlock and unlock usually occur in pairs.
researchers identified such function pairs by mining source code .
however identifying such pairs from all the program paths may introduce noise.
here we focus on only the error paths.
our intuition is that if a resource is allocated in a function path that resource is in general deallocated before the function exits or returns for both error and non error paths.
since an error path is usually shorter than other program paths and contains less number of function calls our search space of identifying function pair will be significantly reduced.
in addition along a non buggy error path the path before function callfcorresponds to a regular path and can allocate a resource in contrast the path after fcontains error handling code see figure and usually deallocates the resource before it returns or exits.
thus fgives a natural separation between functions related to resource allocation and de allocation and thus facilitates pair wise analysis.
in this step errdoc collects the function call sequences along an error path that belong to fcaller cfg.
errdoc divides the call sequence into two sub sequences based on whether a function is called before or after f. for example the call sequence f1 f2 f2 f3ff4 f5 f3 is divided into before and after subsequences f1 f2 f2 f3 and f4 f5 f3 respectively.
next all the functions of the two subsequences are paired with each other.
however if the occurrences of a function and its pair vary in the two subsequences errdoc disregards them as function pairs are unlikely to have different frequencies in a program path.
thus all f2related pairs from the above example are disregarded as f2occurred twice in before subsequence.
also if a function e.g.
f3 occurs both before and after subsequences it is filtered out.
at the end of this step a potential set of function pairs are identified e.g.
f1 f4 and f1 f5 .
errdoc collects all the function pairs from all the error paths in a studied project and note their corresponding occurrence frequency.
errdoc then discards all the function pairs with frequency because these pairs are probably accidental.
next for any given function errdoc tries to find top n function pairs.
thus for a given right hand side function in the function pairs errdoc sorts its pairs based on their frequency in descending order and selects top n frequent function pairs.
the same process is repeated on the left hand side function element of the function pairs.
note that errdoc identifies function pairs with one to one oneto many many to one or even many to many mappings.
for example in openssl project both functions bio new andbio new file 756esec fse september paderborn germany yuchi tian baishakhi ray are paired with bio free .
similarly function crypto malloc is matched with both crypto free andcrypto clear free .
next errdoc checks how the two functions in a pair are related by analyzing data dependency between their arguments and return values along any related error path and represents the relation using function pair signature .
for example if for a function pair fp the first argument of the right function is data dependent on the return value of the left function the signature will be fplef t ret fpri ht arg1 .
if the paired functions are not data dependent they are eliminated from further considerations because they are unlikely to handle the same resources and thus are not related to our purpose.
.
phase ii.
detect categorize error handling bugs leveraging information gathered from previous steps this phase outputs buggy program location and corresponding bug category.
to detect ep and eo bugs errdoc extends our previous tool .
incorrect missing error propagation ep if along an error path path err fcaller f errdoc finds a return statement in fcaller errdoc checks the return value to ensure an error value is pushed upstream.
errdoc takes the global non error specification global nerrspec of the program under study as input.
while symbolically executing the error path errdoc checks whether the return value at fcaller can contain non error values according to global nerrspec i.e.constraints on return value satisfies globalnerrspec .
if it can contain only non error values then errdoc marks the corresponding return location as a source of ep bug.
if the return statement can contain both error or non error values errdoc marks the location as maybe ep bug while if it correctly contains only error values it is marked as not a bug.
in the case of a maybe bug errdoc further checks whether the return statement is part of an error handling code if true it marks a maybe bug to ep bug since error handling code should push an error value upstream.
for example in listing errdoc finds that at line the function is returning a success code according to error specification shown in line .
however it is along an error path of evp digest1 routine and also within the corresponding error handling code line to .
thus errdoc marks the return statement at line as potential source of ep bug and the corresponding error path as buggy.
incorrect missing error checks ec .
if for functions fand its caller fcaller an ep bug is diagnosed in the previous step and along the corresponding buggy error path in fcaller no error handling code for fis found errdoc reports it as a potential missing ec bug.
for example in listing corresponding to function call evp digest at line an error path in the buggy version is along the line5 .
however there was no error check in this path.
thus errdoc reports line as missing ec bug.
an error check can be incorrect.
if for functions fand its caller fcaller an ep bug is diagnosed in the previous step and also an error handling code is found along an error path but the buggy ep location reported in previous step is not part of the error handling code then the only reason behind the ep bug is an incorrect error check.
errdoc diagnoses such cases as incorrect ec.incorrect missing error outputs eo .
if along an error path path err fcaller f an exit statement is encountered errdoc makes sure the error situation is logged before exiting.
in this step program specific logging utilities are taken as input.
errdoc then checks whether a logging function is called before exiting.
errdoc also checks the constraints on the symbolic arguments of the exit function to ensure they can have error values .
for example in listing before exiting at line on openssl malloc failure nothing was logged in the buggy version.
errdoc diagnoses such case as eo bug.
listing motivating example adapted from openssl.
the comments and lines in red show the bugs and their categories the corresponding fixes are shown in green.
error spec returns on error on success int asn1 digest ... int i i2d data null unsigned char str openssl malloc i if str null eo bug exiting without logging asn1err ... err r malloc failure exit evp digest ... ec bug no error check if !evp digest ... openssl free str return if !
evp digest1 ... rr bug not freeing str openssl free str ep bug return success code on error path return return openssl free str return incorrect missing resource release rr .
given a list of function pairs fp and function pairs signatures as identified in section .
errdoc checks for potential violation of the pairs along an error path path err fcaller f .
in particular along the error path infcaller s cfg for every function call appears before f errdoc checks whether there is any corresponding paired function s from the fp list.
if found errdoc then looks for those paired functions along this error paths and checks the corresponding signatures along the error path in fcaller s cfg.
if none of the paired functions are found or none of the found paired functions satisfies any of the data dependency specified in the function pairs signatures errdoc reports a potential rr bug.
even if errdoc finds an rr bug it may happen the corresponding resource is freed later in a different function especially for resources that may exist beyond fcaller s scope.
for such resources errdoc simply reports warnings.
for example in listing corresponding to openssl malloc function at line there was no openssl free function along the 757automatically diagnosing and repairing error handling bugs in c esec fse september paderborn germany error path containing evp digest1 line .
errdoc reports this case as rr bug.
.
phase iii.
fix error handling bugs in this step errdoc automatically fixes four types of error handling bugs.
let s assume function fcaller did not handle errors returned by calling function f errdoc detected and reported that error.
to fix the bug errdoc takes three inputs the buggy program locations i.e.
source code line numbers the bug category and any error handling code that may pre exist in fcaller .
first errdoc traverses fcaller s ast abstract syntax tree and locates the ast nodes and its associated subtree that match the buggy program locations.
next depending on the bug category errdoc constructs an ast subtree to fix the bug as described below.
finally errdoc applies the fix to the original buggy ast by deleting and adding existing ast nodes and edges.
figure represents the fixing process.
red andgreen subtrees show deletion and addition operations respectively.
we observed in section a human written patch to fix error handling bug is often integrated with a pre existing error handling code block present in the buggy function body.
thus our main challenge is to produce a bug fix patch that blends well with its context to resemble a human written patch.
this is important as a patch that does not follow the developers coding practice may not get accepted .
errdoc looks for an existing error handling code that is already present in fcaller .
if multiple such error handling code is found errdoc chooses the one closest to the buggy location in terms of source code line number.
we measure the distance between the buggy program locations and an error handling code using three heuristics i if an error handling code block or the buggy locations span over multiple source code lines we choose the first line s as their respective starting points.
the distance between the two is then measured based on their starting points.
ii if multiple error handling code blocks exist in the context we choose the one having minimum distance w.r.t.
the bug location.
iii if the same target function f is called multiple times from the same caller fcaller and at least in one call site the error is handled correctly we follow its way to fix the bugs at other call sites within fcaller .
here even if other error handling code exist for different functions at nearer context we give priority to the same callee.
if an error handling code block is found following either ii or iii we call such pre existed block as contextual error handling code .
following this above generic strategy the rest of the section elaborates our big fixing process for each bug category.
incorrect missing error checks ec given an ec bug we know the function f s call site and the specific return value that is not checked correctly from ec bug detection step.
to fix the bug errdoc first adds the missing check i.e.if statement on the return value of fafter its call site as shown in a .
then if there is no contextual error handling code errdoc constructs an error handling code block that consists of logging function call and a return statement with global errvalue.
otherwise errdoc refers to the contextual error handling code.
for example if the contextual code jumps to an error label using a goto statement errdoc also follows the same.
for example in listing errdoc reports line as missing ec bug.
to fix the ec bug errdoc inserts an if statement at line on the return value of evp digest .
in addition errdoc leverages a ec b ep c eo d rr figure bug fixing examples the contextual error handling code line to and constructs the error handling code as shown in line to .
note that these two error handling code blocks follow the same patterns.
incorrect missing error propagation ep as discussed in the previous sections an ep bug returns an incorrect value from fcaller along an error path path err fcaller f .
to fix the bug errdoc considers following three scenarios outside f s error handling code.
if the buggy return statement returns a non error constant errdoc simply replaces it with an error specific constant value as per global err.
otherwise if it returns a variable say v errdoc constructs an assignment statement v global err.
errdoc then inserts the assignment statement at the beginning of f s error handling code.
inside f s error handling code with a contextual error handling block.
errdoc replaces the buggy return statement with the return statement contained in contextual error handling block.
inside f s error handling code without contextual error handling block.
errdoc updates the return value of the buggy return statement with global errvalue.
for example in listing errdoc marks the return statement at line as a potential source ep bug.
the buggy statement is within evp digest1 s error handling code line to .
to fix this ep bug errdoc replaces the buggy return statement with the return statement from contextual error handling block line to .
incorrect missing error outputs eo since eo bug does not call a logging function before exit along an error path to fix the bug errdoc inserts an extra logging function call statement before exit as shown in figure c .
for example in listing before exiting at line on openssl malloc failure nothing was logged in the buggy version.
errdoc diagnoses such case as eo bug and inserts an extra logging function call statement as per input logger utility functions as shown in line .
incorrect missing resource release rr since in an rr bug a resource is not released correctly along an error path i.e.
resource allocation function is called but not the corresponding release function errdoc first retrieves the function pair signature as identified in section .
and leveraging the signature constructs the 758esec fse september paderborn germany yuchi tian baishakhi ray corresponding paired function call statement.
then errdoc inserts the call statement before the return statement at the end of the error path.
for example in listing errdoc reports rr bug along the error path of evp digest1 see line since openssl free call was missing corresponding to openssl malloc function line .
based on the signature of these two pair functions errdoc constructs a corresponding function call openssl free str and inserts this function call statement before the return statement at line .
implementation errdoc is composed of three phases as shown in figure .
the first two phases include error path exploration phase i and bug detection phase ii .
they are implemented using clang static analysis framework adapted from previous tool epex and clang libtooling .
the last part includes ast based bug fixing phaseiii which is implemented using clang libtooling .
in total the implementation of errdoc includes almost seven thousand c loc and three hundred python loc.
in particular the implementation uses three clang analysis steps i.symbolic execution errdoc uses clang s static analysis framework to perform an under constrained symbolic execution for identifying error paths step i a and function pairs step i c and detecting and categorizing the bugs phase ii .
we implement three clang checkers for phase i and phase ii.
ii.
data dependency analysis clang s inbuild static analyzer does not support data dependency analysis.
hence inspired by zaks et al.
we leverage the symbols persistent representation of opaque values in clang analyzer to implement a checker that can support simple data dependency checking to identify the function pair signatures see section .
.
iii.ast analysis we leverage clang s ast analysis framework to identify error handling code step i b and related ec bug step ii a refining rr bug reports step ii d and fixing the buggy programs phase iii .
we use clang libtooling and clang libastmatchers for the ast analysis.
the overall running effort of errdoc is similar to a clang static checker.
given a list of inputs see section .
a python script is used to automate the whole process.
experimental results in this section we evaluate errdoc s ability of detecting categorizing and fixing error handling bugs.
in particular we investigate the following research questions rq1.
how accurately errdoc detects error handling bugs?
rq2.
how accurately errdoc categorizes error handling bugs?
rq3.
how accurately errdoc fixes error handling bugs?
study subject.
we select five projects openssl gnutls wolfssl curl and httpd for the evaluation.
these projects were also studied by epex.
we choose the same projects for comparison.
we also create three types of dataset i.manually injected bugs.
we randomly choose source files from each project and inject error handling bugs.
to insert ec bugs we remove existing error handling code that handles an api call.
we inject ep bugs by replacing a return error statement with a return non error statement.
eo bugs are injected by removing an existing logging function before exit function call along an error path.
finally to inject rr bug we remove a deallocation routinefrom an error handling code.
the corresponding original code are considered as correct code to evaluate bug fix performance.
we also choose instances of non buggy cases that are representative of correct error handling code as per our observation.
ii.real bugs from evolutionary data.
we further select real error handling bugs and patches from the error handling bug fix commits that we identified in the empirical study see section .
iii.new bugs in openssl.
errdoc also finds some new bugs.
we manually verify their correctness to evaluate the tool.
we are also in the process of reporting these bugs.
three of our patches are already integrated with openssl code.
study methodology.
we measure errdoc s capability to detect and categorize error handling bugs in terms of precision and recall.
for each bug type t suppose that e is the number of bugs detected by errdoc and a is the the number of true bugs in ground truth set.
then the precision and recall of errdoc in categorizing error handling bugs are a e e and a e a respectively.
we use similar measurement for bug detection and fixing.
.
study results rq1.
how accurately errdoc detects error handling bugs?
we evaluate errdoc in three settings as described in section .
we further compare errdoc s accuracy with state of the art error handling bug detection tool epex .
table summarizes the result.
table bug detection accuracy manually created dataset evolutionary dataset new bugs total total total bug non bug bug bug errdoc epex errdoc epex errdoc epex detected false positive false negative n a over precision .
.
.
.
.
.
recall .
.
.
.
n a n a in the manually curated dataset errdoc reports bugs out of that are false positives.
to verify errdoc should not incorrectly classify a non bug as bug we check errdoc s accuracy on correct error handling instances out of them errdoc mistakenly identifies as error handling bugs.
thus errdoc s overall precision and recall are and respectively.
in contrast on the same dataset we findepex detects error handling bugs with precision and recall.
in the evolutionary dataset errdoc detects error handling bugs with precision and recall while epex s precision and recall are and respectively.
finally we manually verify all the new bugs that both the tools have detected.
here errdoc s precision is while epex s precision is .
at any given point it is not possible for us to know how many new bugs we cannot find therefore we cannot detect recall in this case.
however errdoc can detect all the bugs that epex detects but bugs detected by errdoc cannot be found by epex .
thus we conclude that errdoc can successfully find error handling bugs with an overall improvement of to percentage points in precision and to percentage points in recall when compared with previous tool epex.
759automatically diagnosing and repairing error handling bugs in c esec fse september paderborn germany we notice that a major improvement on errdoc s accuracy over epex is due to the former s capability of detecting incorrect missing resource release rr bugs.
incorrect missing resource release bug detection primarily depends on the methodology to finding function pairs as discussed in section .
.
thus to get an estimate of rr bug detection capability we also measure errdoc s accuracy of detecting function pairs.
in particular we investigate rq1 a. how accurately errdoc detects function pairs?
for this experiment we create a ground truth set of real function pairs from openssl by carefully studying the functions specifications.
as discussed in section .
we perform the function pair analysis along error paths because error paths being shorter than non error paths will reduce the search space.
the target function f further provides an automatic divider between resource allocation and deallocation functions.
we also perform a data dependency analysis between the arguments and return values to the function pairs.
to check how effective these strategies are we compare errdoc s accuracy of detecting function pairs at different settings as shown in table .
in particular we compare the function pairs identified by errdoc against the ground truth set.
the errdoc s identified function pairs that are also in the ground truth are marked as true positives.
we further manually check the remaining function pairs detected by errdoc against openssl specification to decide if they are true or false positives.
to measure the false negatives we count how many function pairs in ground truth are not identified by errdoc.
table shows the result.
table accuracy of function pair detection at various settings top top top precision recall precision recall precision recall .error path f .
.
.
.
.
.
.all path f .
.
.
.
.
.
.error path not f .
.
.
.
.
.
.all path not f .
.
.
.
.
.
.error path f data dep .
.
.
.
.
.
.all path f data dep .
.
.
.
.
.
function pairs are computed along only error paths settings and all the paths settings .
in all the settings except and a target function say f is used as partitioning function.
also settings and consider data dependency analysis among the arguments of function pairs.
top top and top are top pairs selected for a given function.
the result shows that identifying function pairs using only error paths settings and as opposed to all the paths settings and gives better precision and recall in all the settings.
these results prove our intuition that only considering error paths reduce search space and thus introduce less noise in function pair analysis.
hence we see better accuracy.
in addition with a partitioning function say f we see better precision setting vs. and vs. .
for example comparing settings and we see fhelps in gaining precision by percentage point while recall remains almost the same.
these results indicate that fplays an important role in function pairing and also ordering the paired elements.
finally we compare the impact of data dependency analysis compare setting vs. vs. .
for instance setting vs. helps in percentage point gain in precision at top while the recall remains the same.
thus we conclude that setting i.e.error path f data dependency gives the highest accuracy in detecting function pairs.
note that the precision is highest at top setting while the recall is lower than top and as we disregard some valid pairs e.g.
openssl two to one or one to two function pairs .
since three to one or one to three function pairs are rare recalls at setting top and top are almost the same.
rq2.
how accurately errdoc categorizes error handling bugs?
table evaluation for bug categorization ec ep eo rr manually created datasetprecision .
.
recall .
.
evolutionary datasetprecision recall .
.
new bugs precision .
.
.
we evaluate errdoc s categorization accuracy for all the four bug types in three settings as shown in table .
overall errdoc categorizes the bugs with to precision and above recall.
we find that the false positives mainly fall into three categories.
if the caller does not follow the global error non error values errdoc may falsely detect them as ep ec or rr bugs.
secondly the false positive may occur due to the limitation of clang s static analyzer.
for example one correct code block is incorrectly detected as ep bug because the caller of this correct code block does not follow the global non error value.
false positives are also caused if errdoc misses to identify valid function pairs.
for example a correct code block is incorrectly detected as rr bug because errdoc misses alternative function pairs in case of one to multiple pair.
in categorizing eo bugs if a different logging function is used than expected false positives may occur.
some false negatives occur as there are some ec and rr bugs that cannot be detected by errdoc.
for undetected ec bug the caller of this ec bug does not follow the global non error value.
however this is not fundamental limitation of errdoc s algorithm for the rr bugs that errdoc fails to detect the function pairs do not have any data dependency e.g.
start andend .
rq3.
how accurately errdoc fixes error handling bugs?
we evaluate the correctness of our bug fix algorithms using both manual and evolutionary bug data.
for both the dataset we already know the corresponding fix patches.
thus to evaluate errdoc s performance we check whether errdoc s produced patches exactly match with the original fix if not we check whether they are semantically equivalent.
table summarizes the result across different projects.
in the manually created data patches generated by errdoc are exactly similar to the original correct code and patches generated by errdoc are semantically equivalent thus giving an overall precision of .
however there are patches that are not matched with the original correct code.
most of the mismatch arises because of the different logging messages between the patches generated by errdoc and the original code.
in the second part we apply errdoc to fix selected real bugs retrieved from evolutionary history.
as shown in table errdoc can fix real bugs in a similar way the developers have fixed them.
but for bugs our patches cannot be matched with the patches proposed by developers.
although all our produced bugs are correct i.e.fixing the bugs correctly a mismatch typically results from one 760esec fse september paderborn germany yuchi tian baishakhi ray table evaluation for bug fix manually injected bug real bug bug total exact semantic no total exact semantic no project type bugs match match match bugs match match match summaryec ep rr total of the three issues first developers sometimes use different logging messages.
secondly for some ep bugs developers return a specific meaningful error value instead of a global error returned by errdoc.
finally for some rr bugs developers put all the deallocation routine calls at the end of the caller function and insert goto statement to the error handling code so that all the resources can be deallocated together.
errdoc fails to produce such patch if no similar instances can be found in the context.
when comparing errdoc s produced patches with the patches by developers we find in some cases the closest error handling code identified by errdoc is a false positive instead of the real closest error handling code.
in these cases errdoc cannot fix ec bugs correctly even though the real closest error handling code can work.
threats to validity some inaccuracy in rr bug detection may arise due to the inaccuracies in function pair identification.
ec and ep bug detection may have false positives when a caller does not follow their global specifications.
further imprecise error specification and the limitation from symbolic execution may introduce inaccuracies in identifying error paths and function pairs.
also our way of identifying error handling code can affect the accuracy of ec bugs fix.
however our evaluation shows that these cases are rare.
we evaluate errdoc on only five projects.
thus our results may not generalize.
to minimize this threat we evaluate the results by creating different types of dataset across all the projects.
related work i automatically detecting error handling bugs.
researchers proposed several techniques to automatically detect some of these bugs.
lawall et al.
used program matching and transformation to detect ec bugs in openssl library .
gunawi and rubio gonzalez found both ec and ep bugs in file and storage system using static dataflow analysis .
jana et al.
used symbolic execution to detect error handling paths and then detected ec and ep bugs by checking whether appropriate error values are propagated upstream along the error paths.
errdoc extends jana et al.
s work.
saha et al.
proposed hector to detect rr bugs in error handling code.
they used an intra procedural live variable analysis to collect a set of exemplars of correct resource allocation and release.
then they compare each candidate fault with close exemplars to determine if some resources need to be released.
hector has a false positive rate.
in contrast errdoc does not need any manual exemplars and has a lower false positive than hector.
further there are tools to detect and analyze exception handling bugs in java .
since java exception handling mechanism differs significantly from c we cannot directly use these tools our study is complementary to them.
ii automated program repair.
automatic program repair is a well researched field and previous researchers proposed many generic techniques for general software bugs repair .
however they did not consider the unique characteristics of error handling bugs as discussed in section thus they cannot repair error handling bugs efficiently.
for example meng et al.
proposed program repair tools that learn the program patches from examples and applied the patches in a context aware fashion.
errdoc also uses the identified error handling code to fix ec bugs however users do not have to provide any explicit examples.
lawall et al.
can detect and fix ec bugs in openssl library.
since they made assumptions on the return error values their tool suffers from a high false positive rate around .
in contrast errdoc is designed to detect and fix different error handling bugs for general c programs with a high accuracy.
further the previous code repair tools mainly rely on test cases demonstrating buggy behaviors.
however it is often hard to write test cases showing erroneous behavior as error conditions rarely occur in a regular program execution.
also the generated patches produced by the previous tools even though functionally correct often do not blend in with the surrounding context.
errdoc addresses both of these issues for error handling bugs by leveraging heuristics specific to c error handling code.
iii specification mining.
there is a large volume of generic techniques to automatically detect bugs based on the specifications.
kang et al.
proposed apex that automatically inferred error specification of c apis and detected error handling bugs with .
precision overall.
engler et al.
and li et al.
used different static analysis techniques to extract rules from source code and then cross check for contradictions.
wu et al.
proposed rrfinder to automatically mine resource releasing specifications for java api libraries.
our work complements these generic techniques and particularly focuses on error handling behavior of c code.
conclusion error handling bugs are common and can have a significant effect on software security and reliability.
in this paper we first present a comprehensive study of real world error handling bugs and create a taxonomy of them.
next we design implement and evaluate errdoc that automatically detects diagnoses and fixes error handling bugs.
evaluating errdoc on five open source code bases reveals that errdoc can detect error handling bugs with high accuracy it outperforms the precision of existing tool epex up to percentage points and recall up to percentage points.
errdoc can further categorize and fix the bugs with high precision and recall.
not all the error handling bugs have same consequences.
in future we plan to examine the severity of these bugs and investigate heuristics to automatically rank these bugs based on their potential severity.
we will also extend this approach to analyze error and exception handling behavior for programs written in other programming languages and framework.