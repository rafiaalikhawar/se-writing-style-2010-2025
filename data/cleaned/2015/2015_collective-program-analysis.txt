collective program analysis ganesha upadhyaya dept.
of computer science iowa state university ames iowa usa ganeshau iastate.eduhridesh rajan dept.
of computer science iowa state university ames iowa usa hridesh iastate.edu abstract popularityofdata drivensoftwareengineeringhasledtoanincreasing demand on the infrastructures to support efficient execution of tasksthatrequiredeepersourcecodeanalysis.whiletaskoptimizationandparallelizationaretheadoptedsolutions otherresearch directions are less explored.
we present collective program analysis cpa atechniqueforscalinglargescalesourcecodeanalyses especiallythosethatmakeuseofcontrolanddataflowanalysis by leveraginganalysisspecificsimilarity.analysisspecificsimilarity is about whether two or more programs can be considered similar for a given analysis.
the key idea of collective program analysis is to cluster programs based on analysis specific similarity suchthat running the analysis on one candidate in each cluster is suf ficient to produce the result for others.
for determining analysis specific similarity and clustering analysis equivalent programs we useasparserepresentationandacanonicallabelingscheme.our evaluation shows that for a variety of source code analyses on a largedatasetofprograms substantialreductionintheanalysistime canbeachieved onaveragea69 reductionwhencomparedtoa baseline and on average a reduction when compared to a priortechnique.wealsofoundthatalargeamountofanalysis equivalent programs exists in large datasets.
ccs concepts software and its engineering formal software verification software maintenance tools keywords source code analysis clustering boa acm reference format ganesha upadhyaya and hridesh rajan.
.
collective program analysis.
inicse icse 40th internationalconference onsoftware engineering may june gothenburg sweden.
acm new york ny usa pages.
introduction data driven software engineering technique has gained popularity insolvingvarietyofsoftwareengineering se problems suchas permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
prediction bug fix suggestions programming patterndiscovery andspecificationinference .
the solutions to these se problems generally require expensive source code analyses such as data flow analysis.
parallelization andtaskoptimizationsarethetwowidelyadoptedtechniquesto scale source code analyses to large code bases .
we propose collective program analysis cpa a complementary technique that leverages analysis specific similarity to scale source code analysis to large code bases.
the key idea of cpais to cluster programsbasedonanalysisspecificsimilarity suchthatrunning theanalysisononecandidateineachclusterissufficienttoproduce theresultforothers.forinstance ifauserwantstorunananalysis to check for null dereference bugs in millions of programs cpa would run the analysis on only the unique programs and reuse the results on others.
thethreecoreconceptsin cpaaretheconceptof analysisspecificsimilarity thetechniqueofabstractlyrepresentingprograms torevealanalysisspecificsimilarity andthetechniqueofstoring andreusingtheanalysisresultsbetweensimilarprograms.analysis specific similarity or analysis equivalence is about whether two or more programs can be considered similar for a given analysis.programs can be considered similar if they execute the same set of instructions in the analysis.
for instance if an analysis is about counting the number of assert statements irrespective of how differentthetwoprogramsare iftheyhavethesamenumberofassert statements theycanbeconsideredsimilarforthepurposeofthe assert counting analysis.
codeclonesarethepopularwayofrepresentingsimilarcode .
syntactic clones represent code fragments that are look alike at token levelorast level semanticclonesrepresentcodefragments that have similar control and data flow functional clones represent codefragments that havesimilar input andoutput behaviors and behavioral clones are the code fragments that perform similar computation.
we did not use syntactic clones because the benefitswillbelimitedtocopy and pastecode.semanticclonescould not be used because of lack of guarantee that analysis output will be similar.
moreover semantically different code fragments mayproduce similar output for a given analysis and we would miss out on those.
for the same reason we also could not use the func tional andbehavioral clones.
for thesereasons we go beyondthe existing notion ofsimilarity and define analysis specific similarity.
we show that for analysis expressed in the lattice based data flow framework wecanusethetransferfunctionstoidentifyanalysis specific similarity.
programs may have statements that are irrelevant for the given analysis.
these are the statements that do not contributes to theanalysis output.
for identifying the analysis specific similarity itis necessary to remove the irrelevant statements and abstractly acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden ganesha upadhyaya and hridesh rajan 1public void writeobj string filename 2try filewriter file newfilewriter filename for .. file .write ... ... file .close catch ioexception e e.printstacktrace 1public static void main string args 2try ... outputstream out newfileoutputstream ... ... out.close catch exception e e.printstacktrace 1public void loadpropertyfile string file ... 2try try ... catch exception e bufferedinputstream bis newbuffered... ... bis.close catch exception ex throw new wrappedruntimeexception ex figure1 thethreemethodsextractedfromour sourceforge datasetthathavedifferentresourceusagepatterns howeverthere exists a similarity that all of them may lead to a resource leak.
represent the reduced program.
we use a sparse representation to remove the irrelevant statements without sacrificing the precision of the result .
comparing sparse representations to determine analysis equivalence becomes a graph isomorphism problem for data flowanalysisthathavesparsecontrolflowgraphs.weusea canonicallabelingschemetomakethiscomparisonefficient .
using the labeling scheme we can produce unique patterns to facilitatethe comparison.for reusingthe resultsbetween theanalysis equivalent programs we store the results in an efficient key value store based pattern database .
we evaluate our approach by measuring the reduction in the analysistimefor10sourcecodeanalysistasksthatinvolvedata flow analysis.
we use two large datasets of programs a dacapodataset containingdacapo9.12benchmarks and287thousandmethods asourceforge dataset containing open source sourceforge projects and .
million methods.
when compared to a baseline thatrunstheanalysisoneveryprograminthedataset cpareduces theanalysistimeby69 onaverageandwhencomparedtoanother technique that removes irrelevant program statements prior to running the analysis cpareduces the analysis time by on average.
wealso seea largeamount ofreuseopportunities inour datasets for almost all analyses.
motivating example consider a resource leak analysis that identifies possible resource leaksintheprogramsbytrackingtheresourcesthatareacquired and released throughout the program by performing a flow analysis .theanalysisreportsaproblemwhenanyacquiredresource isnotreleasedoneverypathintheprogram.1ifauserwantstorun thisanalysisonalargecodebasethatcontainsmillionsofmethods hewouldenduprunningtheanalysisoneverymethodinthecode base.
an optimization can be performed to skip analyzing methodsthatdonotcontainresourcerelatedstatements howeverthe methods that have resource related statements must be analyzed.
to illustrate consider the three methods writeobj main and loadpropertyfile extractedfromour sourceforge datasetshown in figure .
these three methods differ by syntax semantics functionality and behaviorally howeverfor the resource leak analysis 1thereexistsafinitenumbersystemresources suchasfiles streams sockets database connections anduserprogramsthatacquireaninstanceofaresourcemustrelease thatinstancebyexplicitlycallingthereleaseorclosemethod.failuretoreleasethe resource could lead to resource leak or unavailability.they all behave similar because all of them acquire a resource and release along one of the execution paths leading to a resource leak in eventof exception the resource is not released .although the three methods were similar for the resource leak analysis all of themwereanalyzedtoreportleak.ifthereexistedatechniquethat couldcapturethissimilarity itcouldperformtheanalysisonany one of these three methods and simply return truefor the other two methods indicating a resource leak.
when analyzing a small number of methods or a handful of projects there may not exist a lot of analysis specific similarity between the source code elements such as methods however in caseoflargecodebases alargeamountofanalysisequivalentmethods exists.
for instance the resource usage pattern leading to a leak shown in figure exists in methods in our sourceforge dataset.
this means that we only need to run the resource leak analysis on one method out of and reuse the result in this case whether a leak exists or not for the remaining methods.
thesourceforge datasetcontainsatotalof82 900methodsthat have resource related code out of methods in the dataset.
we were able to see unique patterns and the leak pattern discussedhereappearsinthetop3patterns.likewise whenanalyzing large code bases there exists a large amount of analysis equivalent codes and a large percentage of reuse opportunity to utilize for accelerating the overall analysis of large code bases.
3cpa collective program analysis figure provides a high level overview of collective program analysis cpa .givenasourcecodeanalysisthatneedstoberunona largedataset ofprograms we firstruna light weightpre analysis oneachprogramthatidentifiesandremovesirrelevantpartsoftheprogram andlabelstheremainingstatements theanalysisrelevant statements .
this labeled compact program is called a sparse representation.wethengenerateapatternforthesparserepresentation and check the pattern against a pattern database.
if the patternis not found the analysis is run on the sparse representation to producetheresult whereasifthepatternalreadyexists thenthe stored result is extracted and returned as the analysis output.
whileoursolutionlooksintuitive thereexistsseveralchallenges in realizing cpa.
for example how to generate a sparse representationgivenananalysisandaprogram howtogenerateapatternfor authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
collective program analysis icse may june gothenburg sweden figure an overview of collective program analysis cpa sparserepresentationsuchthatanalysisequivalentsparserepresentations can be identified and how to utilize the sparse representation to reuse the analysis results.
we will describe these challenges andoursolutionsindetail.but firstwedescribetheanalysismodel under assumption.
.
the analysis model a source code analysis can be performed either on the source code text or on the intermediate representations like abstract syntaxtrees asts control flow graphs cfgs etc.
a control and data flowanalysisisperformedonacfgandisoftenexpressedusing the lattice based data flow framework .
in this framework a data flowanalysisisdescribedbydefiningalattice whichdescribesthesetofvaluestobeassociatedwithprogramstatements andaset oftransferfunctionsthatdescribeshoweachprogramstatement transforms the input values to output values.2two sets of dataflow values are maintained at each node inandoutthat describes theinputandoutputvaluesateachnode.thedata flowanalysis solves a set of flow equations involving the two sets inandout and transfer functions.
based on the data flow values computed at the nodes assertions can be made about the program behavior.
for example the resource leak analysis described in the motivation sectionmaintainsasetofvariablesrepresentingtheresourcesas data flowvaluesandithasmainlythreekindsoftransferfunctions for handling resource acquire resource release and resource copy aliasing .3from hereon whenever we refer to analysis we mean the data flow analysis expressed in this framework.
definition3.
.
acontrolflowgraph ofaprogramisadirected graphcfg n e n0 ne with a set of nodes nrepresenting programstatementsandasetofedges erepresentingthecontrol 2amergeoperatorthatdescribeshowtwodata flowvaluescanbecombined apartial orderthatdescribestherelationbetweenvalues andtopandbottomvaluesarealso provided.
however for describing cpa transfer functions are sufficient.
3we ignore the method calls for simplifying the description however in our implementation the method calls are over approximated.flowbetweenstatements.
n0andnedenotetheentryandexitnodes of the cfg.
.
sparse representation given an analysis anda large set of programs we performa pre analysis on each program to produce a sparse representation.
a sparse representation is a reduced program that contains only the statements that are relevant for the analysis.
intuitively a program statementisrelevantforananalysis ifitcontributestotheanalysisoutput orgeneratessomeinformation .withrespecttotheanalysis model under consideration the relevancy is defined as follows definition .
.
a program statement is relevant for an analysis ifthereexistsanon identitytransferfunctionforthatstatementin the analysis.
that is if the analysis has defined a transfer function fk iforstatement i wherekrepresentsthetransferfunctionkind andfk nequal theniis relevant for the analysis.
in the data flow analysismodeltherealwaysexistsanidentitytransferfunction alongwiththeuserdefinedtransferfunctionstorepresentthose statement that have no effect on the analysis output.
definition3.
.
givenaprogram pwithasetofstatements s a sparse representation is a tuple p prime m wherep primecontains a subset of the statements s prime s such that i s prime iis a relevant statement.
m s fkis a map that provides the information about the kind of the transfer function that is applicable to each relevant statement iin sets prime.
ascpatakes data flow analysis and the control flow graphs cfgs ofprograms wehavetogeneratethesparserepresentations of cfgs.
for this purpose we utilize a prior work that proposes reducedcontrolflowgraphs rcfgs .inanutshell arcfgisa reducedcfgthatcontainsonlythosenodesforwhichthereexitsa non identity transfer function in the analysis.
rcfg is constructed using a pre analysis that takes an analysis specification and a cfg 4a cfg may contain multiple exit points however we connect them to a auxiliary exit node.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden ganesha upadhyaya and hridesh rajan asinput extractsalltheconditionsfortheanalysistransferfunctions andchecks the conditionsagainst thecfg nodes toidentify analysis relevant nodes.
we extended rcfg to also store the kind of the transfer function that are applicable to cfg nodes as special properties of nodes.
this information is required in a later stage of thecpato generate patterns for cfgs.
start c acquire end3 release figure sparse representation of writeobj method shown in figure .
to provide a concrete example of a sparse representation let us revisit the resource leak analysis described in our motivation and thewriteobj methodshowninfigure1.the resourceleak analysis contains threekinds of transfer functions acquire release andcopy.
using the transfer functions we can identify the relevant statements in the writeobj method.
the relevant statements for this method are at line and line because line creates a filewriter resourcevariableandithasanassociatedtransferfunction acquire andline7releasestheresourcebyinvoking close methodandithasanassociatetransferfunction release.allother statementsdonothaveanassociatedtransferfunctionandhence are considered irrelevantand removed except some specialnodes such as startandend.
rcfg also retains the branch nodes that haveatleastonesuccessorwitharelevantstatement.theresulting sparserepresentationisasshowninfigure3.thisgraphisarcfg ofthe writeobj method.itcontainstwonodes3and7thathave non identity transfer functions acquire andrelease respectively and a special branch node marked c. .
analysis equivalence given the sparse representations of programs our next problemis tofind similaritiesbetweenthem.
in caseof sparserepresentations of cfgs finding similarities is a graph isomorphism problem withrespecttocertainlabelingscheme.apriorworkgspan hasproposedusingadepth firstsearch dfs codeastheunique canonical label for graphs to find isomorphism.
we utilize the dfs code technique for obtaining the canonical form of the sparse representation.
given a graph directed or undirected with nodes and edges a dfscode isanedgesequenceconstructedbasedonalinearorder tby following rules assume e1 i1 j1 e2 i2 j2 where e1 e2are edges and i jare node ids ifi1 i2andj1 j2 e1 te2 ifi1 j1andj1 i2 e1 te2 and ife1 te2ande2 te3 e1 te3.
eachedgeinthedfscodeisrepresentedasa5 tuple i j li l i j lj wherei jare node ids li ljare node labels and l i j represents the edge label of an edge i j .
inthedfscodethatwegenerate weuseonly4 tupleandignore theedgelabel l i j becauseitisonlyrequiredformulti edgegraphs and cfgs are notmulti edge graphs.
for nodelabels we use the transferfunctionkinds.forinstance forthe resourceleak analysis weuse acquire releaseandcopyfornodelabels.notethat every nodeinthesparserepresentationofthecfghasanassociatednon identitytransferfunction.figure4showsthedfscodeconstructed for the sparse graph of writeobj method shown in figure .
as shown in the figure each edge is represented as a tuple.
for instance edgefromnode2tonode3isrepresentedas acquire release .byfollowingthethe torder weobtainedthedfscode shown in the figure.
figure dfs code for the sparse control flow graph of the writeobj method shown in figure .
anundirectedgraphcouldhaveseveraldfscodes basedonthe startingnode andtheminimumdfscodeprovidesthecanonical label suchthatiftwographs gandg primethathavethesameminimum dfs codes are isomorphic to each other .
theorem3.
isomorphicgraphsproduceeqaldfscode .
giventwographs gandg prime gisisomorphicto g primeiff theirminimum dfs codes are equal.
proof.the proof is based on .
theorem3.
acfghasauniqe minimaldfscode .
acfg always has a single dfs code that is minimum because there exists a single start node and the edges are directed.
proofsketch.
theproofisbycontradiction.considerthatacfg has two dfs codes c1andc2.
bothc1andc2must have the same first edge because there exists only one start node for a cfg.
fromthe destination node of the first edge c1andc2might have two authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
collective program analysis icse may june gothenburg sweden different edges.however thisis not possiblebecause thenext edgeis picked by following the linear order t which is deterministic and it always picks the same edge.
if this process of picking the next edge is continuedtoformtheedgesequencesin c1andc2 wecanseethat bothc1andc2must have the same edges in the same order in the sequences.
giventhatwehaveamechanismtoencodethesparsegraphsas dfscodes wedefineanalysisequivalenceofsparserepresentations of cfgs as graphs with same dfs code.
definition .
.
analysis equivalence two cfgs g1andg2 are equivalent for a given analysis or analysis equivalent if the dfs codes of the corresponding sparse graphs are same.
toprovideaconcreteexample considerthe resourceleak analysisandthethreemethods writeobj main and loadpropertyfile shown in figure .
although the cfgs of these three methods are different after removing all the irrelevant nodes the sparse graphs obtained are same as shown in figure .
for this sparse graph the dfscodeconstructedisshowninfigure4.asthesethreemethods havethesamedfscode theirsparserepresentationsareanalysis equivalent.
animportantpropertyoftheanalysisequivalentsparserepresentationsisthattheanalysisoutputforthesegraphsaresimilar.
whenwesaysimilar wemeanthattheanalysisexecutesexactly same set of instructions to compute results for nodes in the two sparse representations.
we formulate this property as a theorem and provide proof sketch.
theorem3.
analysiseqivalenceimpliesresultsimilarity .twoanalysisequivalentsparserepresentationsproducessimilar results.
proofsketch.
twoanalysisequivalentsparserepresentationswill havesamenumberofnodesandeachnodeisassociatedwiththesame kind of transfer function which means that the result produced at nodesaresimilar bytheapplicationofthetransferfunctions .the flow of results between the nodes in two sparse representations isalso similar because the edges between the nodes in the two sparserepresentations are also similar.
this means that if the two sparserepresentations starts off with an initial state often topelement of the data flow analysis they must produce similar results.
.
leveraging analysis specific similarity in the previous section we described a technique for identifyingthe analysis specific similarity between programs the final stepof cpais to cluster programs and reuse the analysis results.
we use a pattern database to store the dfs codes of the sparse representationsaskeysandanalysisresultsasvalues.asdescribed in our overview diagram shown in figure after producing thedfs codes for sparse representations our approach first checks whetheraresultisalreadypresentinthedatabase.wedefinethe presenceofthedfscodeasa hitandtheabsenceas miss.incase of a hit we simply return the stored result.
in case of a miss we runtheanalysisonthesparserepresentationstoproducetheresult and store the result along with the dfs code into the database for future use.
werequirethatanalysisresultsofsparserepresentationscannot contain any concrete program data for instance variable names.whiletheanalysiscancomputeanyconcreteresultforeachprogram statement the analysis resultsfor the sparserepresentation must be free from the concrete program data.
for example resource leak analysis collects and propagates the variable names of resource variables however at the end it produces a boolean assertion indicating whether a resource leak exists in the program?
.
thisisnotasevererestrictionfor cpatobeapplicable becausethe analysescanstillcomputeprogramspecificoutputs howeverthe final output has to be an assertion or any result that is free from program specific data.
evaluation themaingoalofourapproachistoacceleratelargescalesource codeanalysisthatinvolvescontrolanddata flowanalysis hence we mainly evaluate the performance.
however we also present ourcorrectnessevaluationalongwithsomeinterestingresultsof applying cpa.
below are the research questions answered in this section.
rq1.howmuchcanourapproach cpa speedupthesource codeanalysesthatinvolvesanalyzingthousandsandmillions of control flow graphs?
rq2.howmuchreuseopportunityexistswhenperforming collective program analysis?
rq3.what is the impact of the abstraction in the form of sparse representation on the correctness and precision of the analysis results?
.
performance .
.
methodology.
wecompareourapproachagainstabaseline that runs the analysis on all programs in the dataset without any optimization or reuse.
we also compare against a prior work that identifies and removes irrelevant statements prior toanalyzing programs.we measurethe analysistime forall threeapproaches cfg rcfg and cpa andcomputethepercentage reductionintheanalysistimeof cpaover cfg denotedasr and rcfg denoted as r respectively.
the analysis times were averaged over the last three runs when the variability across these measurementsisminimal under2 byfollowingthemethodology proposed by georges et al.
.
note that the cache or pattern database is cleared after every run to ensure same setting for each run.ourexperimentswererunonamachinewith24gbofmemory and cores running on linux .
.
.fc17 kernel.
.
.
analyses.
wehaveused10sourcecodeanalysestoevaluateourapproachaslistedintable1.weusedseveralcriteriato select the candidate analyses.
we have included analyses to obtain maximum coverage over the flow analysis properties such as analysis direction forward backward merge operation union intersection complexityoftheanalysis andcomplexityofthedatastructures used to store the analysis results at nodes.
the analyses are written using boa a domain specific language dsl for ultra large scale mining and we have used boa compiler and runtime for executing the analyses.
next we briefly describe each analysis used in our evaluation.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden ganesha upadhyaya and hridesh rajan table analyses used in our evaluation.
analysis description avail expression optimization opportunities dom control flow dominators escape escape analysis leak resource leaks live liveness of statements 6mayalias local alias relations null null check after dereference pointer points to relations safe unsafe synchronizations taint vulnerability detections avail.
available expression analysis tries to find optimizationopportunitiesinthesourcecode suchasvalueofabinopexpression computed once can be reused in the later program points ifthe variablesintheexpression arenotre defined.this isastandard compiler optimization drawn from the textbook.
we included this analysis to represent how an optimization problem can benefitfrom cpa.theanalysiswillreportifthereexistsoneormore optimization opportunities.
dom.
control flow dominators are useful in many analyses that requires control dependence for instance in computing the program dependence graph pdg however computing the dominatorsisexpensive henceweincludedthisinourlistofanalyses to demonstrate how our technique can accelerate computing dominators.thisisalsoaspecialkindofanalysis whereallnodesare relevant for the analysis and the sparse representation constitutes the whole cfg.
the analysis will report a map containing a list of dominators for each cfg node.
escape.
escape analysis computes whether the objects allocated inside methods stay within the method captured or escapes toanothermethods.thisinformationisusefultodecidewhetherto allocate memory for such objects in the stack instead of heap.
the analysisoutputs true ifthereexistsanycapturedobjects otherwise false.
leak.
this is aresource leakcheckerthatcaptures theresourceusageinprogramstoidentifypossibleleaks.theanalysis tracks all jdk resource related api usages in programs.
if any resource acquired is not released at the exit node it outputs that leak may exist.
live.
this analysis tracks the liveness of local variables usedintheprogram.thereexistsmanyclient applicationsofthis analysissuchasidentifyingandremovingthedeadcode registerallocation etc.thisanalysissimplyreportsallthevariabledefinition and use sites along with their control flow dependencies.
mayalias.
precisely computing the alias information is expensive and sometimes may not be possible.
in such situations computing the may alias information by following the direct assignmentscanbehandy.thismayaliasanalysiscomputesthealias information and reports the alias sets.
null.
this analysischecksifthere existsadereferencethat is post dominated by a null check.
such a pattern indicates thatthedereferencemaycausenullpointerexception becauseitcanbenull.theanalysisreportsifthereexistssuchproblemsinthe program.
pointer.
pointer or points to analysis implemented here is a flow sensitive and context insensitive points to analysis.
it computesthepoints tograph.apoints tographprovidestheinfor mationwhetherthevariablesintheprogrammaypointtothesame memorylocation.thisanalysisoutputsthepoints tographwith abstract variables and nodes meaning concrete variable names are mapped to symbols .
safe.
thesafesynchronizationcheckerlooksforthelock acquire releasepatternstoidentifybugs.acquiringlocksandnot releasing them may cause deadlock and starvation in the program.
theanalysistracksallthevariablesonwhichthelockisacquired and checks if the locks on these variables are released on every program path.
if not it reports that the problem exists.
taint.
taintanalysisdetectsandreportspossiblevulnerabilitiesbyperformingataintanalysis.theanalysisidentifiesthe variables that read data from external inputs like console tracks their dataflow and checks if the data from these variables are written to output.
.
.
datasets.
wehaveusedtwodatasetsforevaluating cpa.
the first dataset consists of all projects included in the dacapo benchmark a well established benchmark of java programs.
thisdatasetcontains45 054classesand286 888non emptymethods.thedacapodatasetispreparedusingthegithubprojectlinks of the dacapo projects.
the second dataset consists of open source sourceforge projects.
this dataset consists of classes and6 465non emptymethod.notethat theorderof methods in our datasets is random and it is determined by thedataset creators .
as such the order does not influence cpa while prior caching does.
.
.
results and analysis.
table2comparesourapproach cpa against the baseline cfg and theprior work rcfg .
the analysis timein caseof cfgisthe actualanalysistime whereas in caseof rcfg it includes the two overheads to identify and remove the irrelevant nodes and in case of cpa it includes several overheads to produce the sparse graph to generate pattern to check the patterndatabase andretrievetheresultincaseofhit andtopersist the results in case of miss .
the analysis times are reported inmilliseconds.
for some analysis the analysis times are low forinstance safe.
this is mainly because we have optimized all our analyses toskip through theirrelevant methods methodsthat do not contain the information the analysis is looking for .
finding and skipping through the irrelevant methods is done at a low cost.
table shows our results.
the two columns r and r shows the percentagereductionintheanalysistimeof cpaover cfgandrcfg respectively.onaverage cpawasabletoreducetheanalysistimeby over cfgand36 over rcfg averagedoverboth dacapoand sourceforge datasets which are individually and .
note that for dom the cfgandrcfgtimes are exactly same because for thisanalysisallnodesarerelevant hence rcfgissimply cfg.for leakanalysis on dacapodataset cpashows negative gain when comparedto rcfg.thishappensmainlybecauseofthelownumber of instances on which the analysis is run.
as shown in table under dacapo the leakanalysisisrunononly220uniquemethods authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
collective program analysis icse may june gothenburg sweden table reduction in the analysis time of cpa.
time in ms dacapo sourceforge analysis cfg rcfg cpa cpa ub cpa cr rr cfg rcfg cpa cpa ub rr avail dom escape leak live mayalias null pointer safe taint average figure5 benefitoftheupperboundachievedby cfg rcfg cpa.
higher bars are better.
and the cost of cpaoverheads may exceed the benefit hence we do not expect cpato improve the performance.
similar situation can be also be seen for safeanalysis.
cpausesanonlinestrategyofcachingtheanalysisresultsatthe sametimeasrunningtheanalysisonmillionsofprograms.
cpacan alsobeusedwithpriorcaching hencewecomputetheidealgain or an upper bound by re running the experiments on the same dataset after caching the results in the first run.
the analysis times are reported in table under cpa ubcolumn.
figure helps to understand how far cfg rcfg and cpaare from the ideal speedup cpa ub .asitcanbeseeninfigure5 formostanalysis cpaisthe closestto100 whencomparedtoothers cfgandrcfg except forleakandsafe.thereasonisasexplainedearlier thenumberof methodsonwhichtheanalysisisrunissmall hencetheoverheads ofcpaexceeds its benefits.
another interesting observation that canbemadeisthatexceptfor leakandsafe forallotheranalysis there exists substantial opportunities to improve the performance ofcpatogetitcloserto cpa ub.thiscanbeperformedbytraining cpaonsomerepresentativeprojects cachingtheresults andusing them on the test projects.
.
.
cross project.
we also performed a cross validation experiment whereweexcludedoneprojectatatimefromthe dacapo dataset that contains a total of projects ran the analysis cachedtheresults andmeasuredtheanalysistimefortheexcludedproject.
we repeated this experiment and aggregated the analysis times for all projects.
we reported the analysis times under cpa cr column in table .
as seen in the cpa crcolumn cpa cranalysis time lies between cpaandcpa ub.
for some analyses cpa cris abletonearlymeettheupper bound.forexample dom.for leak andtaint priorcachinghadlesseffectontheanalysistime mainly because the number of instances on which the analysis is run was small.
for other analyses a consistent speedup is seen over cpa.
thissuggeststhat cpawithsomepriorcachingcanimprovethe performance over the online strategy.
.
.
cpacomponents.
for every cfg of the method to be analyzed cpaproduces asparse representation ofthe cfg generates a pattern that represents the sparse graph and checks the pattern database for a result.
the overhead for this stage is represented as patternintable3.whenthereisamiss i.e.
theresultdoesnot exists for a pattern then cparuns the analysis to produce a result analysis stage andcachetheresult persist stage .whenthere is a hit i.e.
a result is found nothing else needs to be done.
it is interestingtoseehowtheoverall cpatimeisdistributedacrossthese components.thecomponentresultsareshownintable3 where pattern analysis and persistare the three components.
the absolutetimesareinmillisecondsandwealsoshowthecontributions of each of the three components towards cpatime numbers inside parentheses .
it can be seen that persist time is almost always negligible.
thepattern time which is the time to construct the sparse graph generate pattern and check the database sometimes exceeds the actual analysis time.
for example avail leak and safe.
this is mainly because in these analyses the amount of relevant nodes are very small.
thus the time for removing the irrelevant nodes to construct the sparse graph becomes substantial.
.
.
reuse opportunity.
table shows that our approach was abletosubstantiallyreducetheanalysistimeacross10analysesandtwodatasets.thereductionmainlystemsfromtheamountofreuseopportunitythatexistsinlargedatasetsofprograms.wemeasuredthetotalnumberofuniquegraphstocomputethereusepercentage.
the results are shown in table .
for all the analyses cpawas authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden ganesha upadhyaya and hridesh rajan table cpatime distribution across four components.
the absolute times are in milliseconds and the values inside are the contribution of the component towards cpatime.
dacapo sourceforge analysis cpa pattern analysis persist cpa pattern analysis persist avail dom escape leak live mayalias null pointer safe taint table amount of reuse opportunity available in various analysis.
dacapo sourceforge analysis totalunique reuse totalunique reuse avail dom286888 escape leak live286888 mayalias null pointer safe taint able to reuse the analysis results over of the time.
a very high percentage of reuse clearly suggests why our approach was able to achievesubstantialreductionintheanalysistime.further italso supports the fact that source code is repetitive.
table lists the transfer functions for all our analyses.
the namesofthesetransferfunctionsprovidesinformationaboutthe kindof statementsthatare relevantforthe analyses.forinstance def v transferfunctionappliestoallstatementsthathavevariable definitions.asweusetransferfunctionnamestolabelthenodes andproducethe pattern thesenamesare usedinthetoppatterns discussed next.
in case of taintanalysis we had a total of methods in thedacapodatasetthatwereanalyzed othermethodsdidn thad relevant code and they formed unique sparse graphs.
the analysisreportedpossibilityofvulnerabilitiesfor101sparsegraphs.
figure shows the top patterns along with their frequencies a b and c .
our analysis did not report any vulnerabilities for any methodsthathavethesparsegraphsshownin a b c becauseall these three sparse graphs only have either inputoroutputnodes.
for vulnerability to occur both must exists.
consider d which hasboth inputandoutputwasoneofthefrequentvulnerabilityfigure top patterns seen in case of taint analysis that de tects vulnerabilities patterninthe dacapodataset.wemanuallyverified20outof101 reported instances for the existence of possible vulnerabilities.
figure the most frequent lock unlock pattern and thecode example of the pattern.
incaseof safeanalysisthatchecksforthecorrectuseoflock unlockprimitivesusingjdkconcurrentlibraries wehad76instances reported correct and reported as having a problem.
out of the 50ofthemfollowedasinglepatternthatisshowninfigure7.
this is a correct usage pattern for lock unlock.
the one instance authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
collective program analysis icse may june gothenburg sweden table transfer functions to identify relevant nodes.
analysis relevant nodes avail def v binop v1 v2 dom all escapecopy v1 v2 load v1 v2.f store v1.f v2 gload v1 cl.f gstore cl.f v2 call v m v0 ... vk new v cl return v leak open v close v copy v1 v2 live def v use v mayalias def v1 c def v1 v2 null deref v copy v1 v2 nullcheck v pointercopy v1 v2 new v cl load v1 v2.f store v1.f v2 return v call v m v0 ... vk safe lock v unlock v taint input v output v copy v1 v2 thatwasreportedproblematicwasafalsepositiveanditrequires inter procedural analysis to eliminate it.
figure most frequent buggy resource leak pattern.
leakanalysis results were most surprising for us.
there existed usages of jdk resource related apis jdk has resource related apis and our analysis reported possible leaks.
outof these were definitely leaks and others were possible leaks and confirming them would require inter procedural analysis.
out ofthe336definiteleaks thetoppatternappearedin32methods.
figure shows this pattern.
.
correctness and precision in .3weprovidedaproofsketchastowhytheanalysisresults ofcpamust match with that of cfg.
to empirically evaluate the correctness of the results we conducted two experiments using all analysis and dacapodataset.
in the first experiment we comparedtheanalysisresultof cfgandcpaforeverymethodthatis analyzed.
table provides information about the results computed for each analysis.
we were able to match the two results perfectly.
asformostoftheanalysisintable6thecomputedresultsare justbooleanvalues wedouble checktheresultsbyprofilingthe transferfunctionsexecutedfor cfgandthesparsegraphof cpa and comparethesequenceoftransferfunctions.weskipthroughthe identitytransferfunctionsincaseof cfg asthe cfgmaycontain many irrelevant nodes.
as the order of nodes visited in both cfg andsparsegraphof cpaaresame wewereabletoseea100 match.table analysis results computed for various analysis.
analysis computed result availtrueorfalse domlist of dominators for each node escape points to escape graph with abstract variables leaktrueorfalse livedefinitions and uses of abstract variables mayalias alias sets of abstract variables nulltrueorfalse pointer points to graph with abstract variables safetrueorfalse tainttrueorfalse .
limitations in this work we have applied cpato accelerate analyses at methodlevel where results for each method is computed independently withoutusingtheresultsatthemethodcallsites.insteadofapplying theresultsofmethodsattheircallsiteswehaveadoptedanoverapproximationstrategy.assuch therearenotheoreticallimitations preventing the use of our technique in a compositional wholeprogramanalysissetting wheretheresultsofthecalledmethods canbeusedattheircallsites ifavailable.thisdesignchoicewas mainlyduetotheanalysisframeworkusedinourevaluation which does not support whole program analysis as of this writing.
anotherlimitationthatcurrentlyexistsin cpaisthatitcanonly storeabstractanalysisresults.forinstance booleanvaluetoindicate the existence of certain kinds of bug.
cpaalso allows using abstract variables and location names in the analysis as results.
for instance variable v0points to the first variable encountered while analyzingthemethodstatements.similarly thelocation loc0points to the first relevant statement that exists in the sparse representation of the method.
the abstract variables and location names helpedustomodelmanyimportantanalyses suchas live escape pointer etc.
in future we plan to support better output types.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden ganesha upadhyaya and hridesh rajan related works our work on cpais related to the prior work on both improving the efficiency of software analysis and finding software clones.
.
improving the efficiency of source code analysis there exists a trade off between improving the efficiency of the analysis and improving the accuracy of the analysis results.
removingtheunimportantpartsofthecodebeforeanalyzingithas been a popular choice .
for instance upadhyaya andrajan proposedrcfgareducedcontrolflowgraphthat contains only statements that are related to analysis.
our work on cpahas adopted the rcfg work to produce the sparse graph.
cpa uses rcfg as its sparse representation to cluster similar graphs and reuse the analysis results to further accelerate analyses.
as we have shown in our evaluation cpawas able to achieve on average a speedup over rcfg.
there also exists other sparse representations such as sparse evaluation graph seg that are more suitable for def use style data flow analysis.
there exists works that eliminates unnecessary computations in the traversal of the program statements to improve the efficiency of analysis .
thesetechniquesremovetheunne cessaryiterationsto improvethe efficiency whereas our work removes the unnecessary statements to produce sparse graphs and also reuses the results by clustering sparse graphs.
allenet al.
and smaragdakis et al.
have proposed a preanalysis stage prior to actual analysis to scale points to analysis to large code bases.
they perform static analysis and programcompaction to remove statements that do not contribute to thepoints to results.
their work is specialized for scaling points to analysis whereas cpais more general in that it can accelerate analysis that use data flow analysis and expressed using the lattice framework.
programslicingisafundamentaltechniquetoproduceacompilable and runnableprogram that contains statements ofinterest specified by a slicing criteria .
many slicing techniques have been proposed .
our pruning technique is similar to slicing in thatwealsoremovetheirrelevantstatements howeverourpruning techniqueisapre processingstepratherthanatransformationand it does not produce a compilable and runnable code like slicing.
slicing cannot be used for our purpose because the program statements of interest are not known.
even if the statements of interest are known slicing may includes statements affecting the values of variables at program points of interest that may not contribute to theanalysisoutput.ourtechniqueonlyincludesstatementsthat contributes to the analysis output.
reusing the analysisresults is another way to improve theefficiencyofprogramanalysis .kulkarni etal.
proposed a technique to accelerate program analysis in datalog.
the idea of their technique is to run an offline analysis on a corpus of training programstolearntheanalysisfactsandthenreusesthelearntfacts toacceleratetheanalysisofotherprogramsthatsharesomecode with the training corpus.
inter procedural analysis are often acceleratedbyreusingtheanalysisresultsintheformofpartial and complete procedure summaries where the analysis results of procedurescan bereusedat theircallsites.
ourtechnique doesnotrequire that programs share code it only requires that programs executed same set of analysis instructions to produce results.
.
finding software clones ourtechniqueisalsorelatedtocodeclones ascpaalsoclusters sparse representations of programs to reuse the analysis results.
thereexistsdifferenttypesofclones.syntacticclonesarelookalike code fragments semantic clones share common expressions and theyhavesimilarcontrolflows andfunctionalclonesaresimilar intermsoftheinputsandoutputs.therearealsootherapproachesthatgoesbeyondstructuralsimilarity likecodefingerprints behavioralclones andrun timebehavioralsimilarity .
we did not use syntactic clones token based or ast based because the benefits will be limited to copy and paste code.
semantic clones codefragmentswithsimilarcontrolanddataflow couldnot beused becauseoflackofguaranteethatanalysisoutputwillbe similar.moreover semanticallydifferentcodefragmentsmayproduce similar output for a given analysis and we would miss out on those.wecannotusefunctionalclones codefragmentswithsimilar input output because they may not produce similar analysis output.
we also could not use behavioral clones code fragments that perform similar computation captured using dynamic dependence graphs because they cannot guarantee similar analysis output.
an analysis may produce similar output for code fragments that arenotbehavioral clones.further inour setting whileanalyzing thousands of projects it is not feasible to instrument the code run them collecttraces andbuilddynamicdependencegraphstodetect behavioral clones.
conclusion and future work we proposed collective program analysis cpa a technique for acceleratinglargescalesourcecodeanalysisbyleveraginganalysis specific similarity.
the key idea of cpais clustering programs that aresimilarforthepurposeoftheanalysis suchthatitissufficientto runtheanalysisononeprogramfromeachclustertoproduceresult for others.
to find analysis specific similarity between programs a sparse representation and a canonical labeling scheme was used.
the technique is applied to source code analysis problems that requiresdata flowanalysis.whencomparedtothestate of the art where the analysis is directly performed on the cfgs cpawas able to reduce the analysis time by .
when compared to anoptimization technique that removes the irrelevant parts of theprogram before running the analysis cpawas able to reduce the analysistimeby36 .bothoftheseresultswereconsistentacross two datasets that contained several hundred thousand methods to over million methods.
the sparse representation used in the cpa was able to create a high percentage of reuse opportunity more than .
in future we plan to extend cpato whole program analysis and extend cpato support more output types.