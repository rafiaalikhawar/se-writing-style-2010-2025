general rights copyright and moral rights for the publications made accessible in the public portal are retained by the authors and or other copyright owners and it is a condition of accessing publications that users recogniz e and abide by the legal requirements associat ed with these rights.
users may download and print one copy of any publication from the public portal for the purpose of private study or researc h. you may not further distribute the material or use it for any profit making activity or commercial gai n you may freely distribute the url identifying the publication in the public portal if you believe that this document breaches copyright please contact us providing details and we will remove access to the wo rk immediately and investigate your claim.
if the document is published under a creative commons license this applies instead of the general right s. this coversheet template is made available by au library version .
december coversheet this is the accepted manuscript post print version of the article.
contentwise the accepted manuscript version is identical to the final published version but there may be differ ences in typography and layout .
how to cite this publication please cite the final published version anders m ller and martin toldam torp.
.
model based testing of breaking changes in node.js libraries.
in proceedings of the 27th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering esec fse .
association for computing machinery new york ny usa .
publication metadata title model based testing of breaking changes in node.js libraries author s anders m ller and martin toldam torp journal proceedings of the 27th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering esec fse document version accepted manuscript post print model based testing of breaking changes in node.js libraries anders m ller aarhus university denmark amoeller cs.au.dkmartin toldam torp aarhus university denmark torp cs.au.dk abstract semantic versioning is widely used by library developers to indicate whether updates contain changes that may break existing clients.
especially for dynamic languages like javascript using semantic versioning correctly is known to be difficult which often causes program failures and makes client developers reluctant to switch to new library versions.
the concept of type regression testing has recently been introduced as an automated mechanism to assist the javascript library developers.
that mechanism is effective for detecting breaking changes in widely used libraries but it suffers from scalability limitations that make it slow and also less useful for libraries that do not have many available clients.
this paper presents a model based variant of type regression testing.
instead of comparing api models of a library before and after an update it finds breaking changes by automatically generating tests from a reusable api model.
experiments show that this new approach significantly improves scalability it runs faster and it can find breaking changes in more libraries.
ccs concepts software and its engineering software maintenance tools software testing and debugging .
keywords semantic versioning javascript acm reference format anders m ller and martin toldam torp.
.
model based testing of breaking changes in node.js libraries.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
.
introduction an important challenge in software maintenance is how library developers can make updates without unintentionally breaking the existing clients of the libraries.
library developers commonly use the semantic versioning scheme to indicate if an update contains backward incompatible changes also called breaking changes.
with permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
versioning updates are marked as major when they are backward incompatible and minor or patch otherwise.
generally library developers should strive toward creating backward compatible updates since clients often apply such updates automatically and instant rollout of updates can be critical for security fixes.
a considerable weakness of semantic versioning is that library developers mostly rely on their own estimates when deciding which semantic versioning category an update belongs to.
previous work has shown that developers often incorrectly classify updates as minor or patch despite breaking changes .
this is especially problematic for dynamically typed languages like javascript where mismatches between the library and the client code are not detected until run time.
javascript application programmers use libraries extensively the npm1repository contains more than modules mostly libraries many of which have thousands of daily downloads and are frequently updated.
a few tools exist for helping developers detect breaking changes before an update is released to the clients.
examples include apidiff clirr and revapi for java the elm diff tool2for elm and noregrets and dont break3for javascript.
a common property of these tools is that they compute the changes to the types of the public api of the library for a given update and then identify the changes that may break clients.
although this approach can only detect type related breaking changes not semantic changes that affect the library functionality but preserve the types previous work has shown that it is strong enough to catch most breaking changes in practice .
the existing techniques noregrets anddont break for javascript require running the test suites of a library s clients to detect breaking changes when the library has been updated.
that approach has several disadvantages.
first installing the client test suites may consume a considerable amount of storage and running them often takes significant time although typically only a small part of those test suites is relevant for the library.
the dont break tool simply reports breaking changes whenever a client test fails with the updated version of the library.
in contrast noregrets uses a technique called type regression testing.
it performs a dynamic analysis of the client test executions to infer models of the library api before and after the library update which leads to more errors being detected and to more actionable error reports for the library developer.
however an important limitation of noregrets is that it can only use those clients whose dependencies include the current version of the library.
for example after a new major release of the library the clients cannot be used by noregrets until they have been updated to the new version.
we explain this august tallinn estonia anders m ller and martin toldam torp technical limitations of noregrets in more detail in section .
as a consequence we find that noregrets does not work well on libraries that only have few available clients.
in this paper we present a new technique for finding breaking changes in node.js library updates which does not suffer from these limitations of existing tools and yet finds more breaking changes.
the new technique is implemented in the tool noregrets .
it borrows the concept of dynamically computed api models introduced bynoregrets however noregrets does not need to re run all the client tests at every new release candidate of a library.
instead from a single execution of the client tests it computes an api model that can be used for checking multiple subsequent updates of the library.
it does so by using the model to guide a dynamic exploration of the library while checking that the types of the values that flow between the library and the clients are compatible with the model.
since noregrets only uses the client tests to generate the initial model it avoids running the irrelevant code of the client tests in the checking phase which makes it considerably faster than noregrets .
the models are typically not very large so they are also more easily stored than the whole set of clients.
additionally this new approach is less sensitive to the versioning constraints in the client dependencies which makes it useful even for libraries with relatively few clients.
in summary this work makes the following contributions we present a new model based approach to type regression testing designed to overcome the main practical limitations of thenoregrets technique.
we demonstrate by an experimental evaluation of our implementation noregrets that it is able to find more breaking changes than noregrets an order of magnitude faster and requiring less space and that the new approach works better for libraries where relatively few clients are available.
specifically applying noregrets to a total of minor or patch updates of 25node.js libraries with varying numbers of clients detects 84breaking changes where noregrets in comparison only finds .
the tool noregrets is available at .
motivating example to illustrate the practical limitations of the existing techniques for detecting breaking changes in javascript libraries consider the big integer library for arbitrary precision integer arithmetic.
example the patch update of big integer from version .
.
to version .
.
introduced a new representation of integers that are small enough to fit in a primitive number based on a new constructor named smallinteger .
the library internally uses a function parsevalue to create a representation of a big integer from some user supplied input for example a string representation of the integer in decimal form.
the update contains the following changes big integer .
.
2function parsevalue v ... return new biginteger ... .
.
7function parsevalue v if isprecise v return new smallinteger v ... return new biginteger ... the new smallinteger constructor is used instead of biginteger when the user supplied value is small enough lines .
the smallinteger constructor internally uses a primitive number to represent its value which makes it more efficient than the array of numbers used by biginteger .
to make the underlying representation transparent to the users the update also includes operations on smallinteger objects mirroring the existing functionality ofbiginteger .
all the operations performed on these types are overloaded for example it is possible to seamlessly multiply a smallinteger with a biginteger .
with this optimization the biginteger library became much faster at processing smaller integers with the release of version .
.
.
however the valueof method behaves differently.
on biginteger it returns a best effort conversion to a primitive number while on smallinteger it instead returns a reference to the smallinteger object itself.
because of this difference the update contains a breaking change that should not have been introduced in a patch update.
the severity of this breaking change is demonstrated by the fact that the big integer developers released a patch of this issue version .
.
even after version .
.
was released to also accommodate clients that automatically apply patch updates but not minor updates.
as mentioned in section the dont break tool works by running the test suites of clients of the library before and after the update.
one such client is the deposit iban5library which contains the following code 14const bigint require big integer 15export function isvalidiban iban ... const bban ... const checkdigitbigint bigint bban let checkdigitnumber string checkdigitbigint.mod bigint ... before the upgrade of big integer in line the modmethod returns a biginteger object whose valueof method is invoked implicitly at the operator.
after the upgrade modinstead returns a smallinteger object with the different valueof method which returns the smallinteger object instead of a primitive number.
this means that at the operator javascript implicitly now also invokes smallinteger stostring method which returns a string that in turn is coerced into a primitive number.
the test suite of depositiban does reach the isvalidiban function and the different behavior in line .
nevertheless all the tests still succeed with the broken version .
.
of big integer because the javascript runtime coerces the result of the modcall to the same primitive number as in version .
.
even though the behavior of valueof has changed.
as a consequence dont break misses the breaking change.
testing of breaking changes in node.js libraries esec fse august tallinn estonia in contrast the noregrets tool can detect this breaking change using deposit iban s test suite.
the api model produced by noregrets forbig integer version .
.
will state that valueof returns a number whereas the model of version .
.
will state that valueof returns anobject .
clearly these two types are not interchangeable so a breaking change is reported.
however noregrets still runs all of deposit iban s test suite which consists of separate tests where only some use big integer .
that test suite was naturally developed to test the logic of deposit iban rather than that of big integer so even for those tests that do use big integer most of the work is irrelevant from the perspective of determining whether the api of thebig integer library has changed.
with our new approach noregrets the test suites of the clients are still required to infer the initial api model of big integer .
however once this initial model has been constructed noregrets checks the types of the library s api by dynamically exploring it based on the information in the model.
specifically for the aforementioned breaking change all noregrets needs to do is to load thebig integer library call the modfunction with the right arguments call valueof on the result and assert that the type is compatible with the type in the model.
expressed as javascript code this corresponds to executing the following test 23const bigint require big integer 24assert typeof bigint .mod bigint .valueof number with this approach there is no need for storing the entire depositiban client and its test suite and similarly for all the other clients ofbig integer and the breaking change detection phase is much faster since the irrelevant work is avoided.
overview the purpose of noregrets is to help node.js library developers determine if a modification of a library results in breaking changes in the types of the library s api.
the intended usage is as follows.
first the library developer uses the model generation phase ofnoregrets that automatically fetches publicly available clients and their tests from github and then runs the tests and simultaneously records the interactions with the library to form a model of the library s api.
when the library developer is later ready to release an update noregrets is run in thetype regression testing phase6on the updated version of the library code and a set of non backward compatible differences in the api types is reported.
if the set is empty then the library developer can confidently mark the update as either minor or patch since the api types of the library probably did not change.
on the other hand a nonempty set indicates changes to the api.
if a manual inspection of the causes of the warnings produced by noregrets shows that the differences are unlikely to cause problems in practice then the developer can go ahead and release the new code as a minor or patch update.
if instead the warnings reveal more serious breaking changes then the developer can either release the changes as a major update and appropriately document the 6using the terminology introduced by mezzetti et al .
atype regression is a change in the type signatures of the library api that is incompatible with the mutual expectations of the client and the library developers.breaking changes or if the changes were unintended choose to fix the library code and rerun the checking phase of noregrets to check that the type regressions are gone and that no new type regressions were introduced in the process.
the checking phase is fast enough to be integrated into the library s integration test suite such that noregrets can be used continuously to check for type regressions during the development cycle.
because of the dynamic nature of javascript the api models produced by noregrets are of course not perfect so the tool should be used as a supplement not a substitute for the developer s understanding of the library code.
however as shown in previous work and in the experimental evaluation of noregrets section library developers often overlook breaking changes and noregrets can catch many of them.
example continuing example noregrets will first generate an api model for version .
.6ofbig integer by running the test suite of deposit iban while dynamically analyzing the interactions between the client and the library.
the main constituent of an api model is a map from dynamic access paths totypes which we define formally in section .
intuitively a dynamic access path or path for short refers to the value that appears as result of performing a sequence of operations for example a call from the client to a library function or a write within the library to an object originating from the client.
types include the ordinary javascript types such as string and number and also concrete primitive values.
for example the following paths expose the problem from example p1 require big integer a arg0 p2 require big integer b arg0 p3 require big integer b p4 require big integer a.modc arg0 p5 require big integer a.mod c.valueof d a model that includes these paths and many others is generated when using the client test code shown in lines .
for line when the client calls bigint the path p1refers to the value being read by the library function when accessing argument number in this case the string .
for the second call to bigint in line p2similarly refers to the string and p3 refers to the return value.
the path p4refers to the value read by the modlibrary function when it reads its argument number .
finally p5 refers to the value returned by the implicit call to valueof at the operator in line as the type number .
the labels a b and cuniquely identify the function calls involved specifically we see that p1 p4 andp5involve the same call to require big integer and p4and p5involve the same call to mod.
an api model additionally contains information about the order in which the paths have been observed and how values flow between paths which we describe in section .
such a model contains enough information to enable noregrets to automatically produce type regression tests like the one shown in lines .
for example when noregrets is run in the checking phase on version .
.7ofbig integer it simulates the individual actions of the path p5and observes that valueof returns an object instead of a number and therefore issues a type regression warning.
to reproduce the actions of p5 noregrets obtains arguments for the calls to modand the main function of big integer simply by inspecting the model at p1 p2 and p4.
this process of generating tests from the model is described in more detail in section .esec fse august tallinn estonia anders m ller and martin toldam torp phase i model generation we obtain realistic executions of the library of interest by leveraging the publicly available test suites of clients of the library.
running the test suites using program instrumentation with es6 proxies noregrets can monitor the flow of values between the clients and the library which makes it possible to build a model of the public api of the library.
although this phase of noregrets is conceptually very close to noregrets for completeness we briefly explain noregrets s notion of api models and we point out the important differences.
api models an api model is a triple .
we first explain which is map of the form path type that associates types with elements of a library api.
the set path consists of dynamic access paths each being a sequence of actions as described in the following grammar by pand respectively.
p require n p .n new argj n dynamic access paths can be thought of as