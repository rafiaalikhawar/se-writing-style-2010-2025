arxiv .03178v1 aug 2017more accuraterecommendationsformethod level changes georgdotzler mariuskamp patrickkreutzer michaelphilippse n programmingsystems group friedrich alexander university e rlangen n rnberg fau germany georg.dotzler marius.kamp patrick.kreutzer michael.
philippsen fau.de abstract during the life span of large software projects developers often apply the same code changes to different code locations in sli ght variations.
since the application of these changes to all lo cations is time consuming and error prone tools exist that learn c hange patterns from input examples search for possible pattern a pplications and generate corresponding recommendations.
in m any cases thegenerated recommendations aresyntacticallyor semanticallywrongduetocodemovements intheinputexamples.th us theyareoflowaccuracyanddeveloperscannotdirectlycopy them into their projectswithoutadjustments.
wepresent theaccuraterecommendationsystem ares that achieves ahigheraccuracythanothertoolsbecauseitsalgo rithms take care of code movements when creating patterns and recom mendations.
on average the recommendations by ares have an accuracyof96 withrespecttocodechangesthatdevelopers have manually performed in commits of source code archives.
at th e same time ares achieves precision and recall values that are on par withother tools.
ccs concepts informationsystems recommendersystems software and itsengineering softwaremaintenancetools keywords program transformation refactoring recommendationsys tem acmreference format georg dotzler marius kamp patrick kreutzer michael philippse n. .
more accurate recommendations for method level changes.
in proceedingsof201711thjointmeetingoftheeuropeansoftwareengi neeringconferenceandtheacmsigsoftsymposiumonthefoundationsofsoft wareengineering paderborn germany september4 esec fs e pages.
introduction developers often perform the error prone and repetitive ta sk of applyingthesame systematicedits tomanylocationsintheircode base.
thereasons for such systematic changes vary.
they inc lude bugfixes theadaptionofcallsitestonewapis etc.
andcon stitute themajorityof structuraleditsinsoftwareprojects .
permission to make digital or hard copies of all or part of thi s work for personal or classroomuseisgrantedwithoutfeeprovidedthatcopiesar enotmadeordistributed for profit or commercial advantage and that copies bear this n otice and the full citationonthefirstpage.copyrightsforcomponents of thiswork owned byothersthan the author s must be honored.
abstracting with credit is pe rmitted.
to copy otherwise orrepublish to post onserversorto redistributeto l ists requirespriorspecific permissionand orafee.
request permissionsfrompermissi ons acm.org.
esec fse september4 paderborn germany copyright held by the owner author s .
publication r ights licensed to associationfor computing machinery.
acm isbn978 ... .
usuallyperformsystematic edits manually beca use often the code is slightly different in each location with re spect to names contexts etc.
so that they cannot use a plain text ual search and replace.
refactoring wizards of ides also just offer a setofpredefinedtransformationsandthusonlyprovidehelp fora subsetofallsystematicchanges.furthermore theydonots upport code changes that lead to different semantics which is neces sary inmany situations e.g.
tofixerrors .
current research tools learn systematic edits from one or more manually provided training examples and build gener alized patterns from them.
then the tools search the code base f or locationstoapplythesepatternstoandpresentthecodeoft heapplied patterns as recommendations to developers.
since the tools construct the suggested code to a large extent purely synt actically thecodeis oftenwrong uses undefined variables cal lsnonexistingfunctions missesstatements etc.
.thus there commended codeis ofteninaccurate i.e.
it is not whatdevelopers wou ldhave written if they had done the systematic edits by hand.
althou gh such inaccurate recommendations are helpful as they identi fy locations for codechanges developers still need tomanually adjust them beforetheycan insert them into their projects.
fig.
illustrates this problem.
the two recommendation sys tems lase and ares learn a pattern from the code changes given in fig.
a b in a classic diffrepresentation .
both tools find the matching code location in fig.
c .
lase suggests th e code change in fig.
d .
ares produces the more accurate one in fig.
e that is closer to what a developer would have writ ten.
there are two reasons for the differences.
first since chang e b init foo.somemethod print foo if foo !
null foo.somemethod print foo a examplechange.init assert foo !
null foo.somemethod foo.print if foo !
null foo.somemethod foo.print b examplechange.
init assert foo !
null foo.somemethod foo.run c matchingcode location.
init assert foo !
null if foo !
null foo.somemethod foo.run d inaccurate recommendation by lase.init if foo !
null foo.somemethod foo.run e moreaccurate recommendation by ares.
figure1 examplefor coderecommendations.esec fse september4 paderborn germany geor gdotzler mariuskamp patrickkreutzer michael philippse n code changesinputorder determinationpattern creationgeneralized pattern searchfor applicationsrecommendation creationrecommendationscode base figure2 workflow of ares for one inputsetof codechanges.
explicitly removes the assertstatement it should not be part of therecommendation.however aslaseonlyappliesthecommo n subset of the code transformations that are present in the tr aining examples the assertremains untouched.
second lase leaves foo.run inplace.thisis wrongbecause fromadeveloper s point of view somemethod and the code in the following line are both movedintothenew if statement.however manyapproaches like lase either do not express code movements accurately or can not handle them due to the type of patterns and algorithms the y use .
since the latter only support delete insert andupdateoperationsonthecode theycanonlylearntoinsert print foo and orfoo.print butnot themoreaccuratecodemovement.
toavoidthesetwosourcesofinaccuracy thepatternrepres entationofarescanbothexpressvariationsintheinputcodecha nges andcodemovements.aresalsousesalgorithmsthatcangener ate moreaccuraterecommendations based onthesepatterns.
fig.
shows theworkflow of ares.the loopin theupper row derives and refines a generalized pattern that represents al l the codechangesinatrainingset.theloopstartswithtwocodec hanges from the input set and generates a pattern for them.
subseque nt iterationsrefinethispatternbyconsideringthenextexamp lessuccessively.
with a generalized pattern ares browses a given code baseforlocationswherethepatternisapplicable searchforapplications .
itthenapplies thetransformationencoded inthepattern to a copy of each found location recommendation creation and presents thetransformedcopyas recommendation totheuser .
sec.2explainsthepatterndesignandhowthishelpsincreat ing moreaccuraterecommendations.secs.
6describethepatt erncreation thesearchforlocationstoapplythem andthegenera tionof therecommendations.wethenquantitativelycomparearesw ith lase in sec.
and discuss relatedwork beforeweconclude.
pattern design ares uses a pattern representation that is close to source co de.
fig.3holdsanexamplepattern basedonourpreviousworkon this topic thatexpresses andgeneralizes codechangesa ppliedto acodebase.thesetofcodechangesistheinputofares.there are two plain java codeblocks in the pattern one original codeb lock thatrepresentstheinputexamplesbeforetheirtransforma tionand one modified code block that represents the examples after th eir transformation.
to express variations in the input example s the patterns usea set ofannotations addedas java comments.
theexamplepatternstartswiththe matchannotationthatsimply declares the beginning of the pattern.
the tags originaland modified allow an easy distinction between the two code parts of the patternfora human reader.
theoriginal partof the matchannotation also contains the letter k. thiskstands for an identifier thatoccursinthepatternbodyandmeansthattheidentifiern ameofkis not fixed and any variable name in a code location is an acceptable replacement for k. in contrast any location to which the pattern is applicable has to use the identifier name foo line .
the list of identifiers in the matchannotation is one mechanism of ares to express a generalization.
when ares creates a recommendationitreplaces kwiththeactualvariablenameatthe respectivecodelocation.this increases theaccuracyofth egeneratedrecommendations.
another generalization mechanism is the wildcard annotation.
it matches arbitrarycodeduringthe search for suitablecod elocations.therearetwodifferentversions.first wildcardsta ggedwith stmtaccept none or arbitrarystatements at the codelocation se e lines and .
this design provides a solution to the proble m of thedeleted assertintheintroductoryexample asitaccepts theassertif it is present and has no effect otherwise.
thus stmtwildcards handle variations in thetraining examples and in crease theaccuracyof thegenerated recommendations.
second wildcards tagged with expralways refer to the following statement.
they specify which part of it can contain an ar bitrary expression.
it is possible to have several such wildca rds referring to the same statement.
for example the expr wildcard in line specifies that at the first occurrence of verbosein line the search algorithm of ares can allow arbitrary expressions.
t his means that at a possible code location for the pattern the ca ll to initmayhavenoneoranarbitrarynumberofarguments.thishandlesvariations inthetraining examples onan even finer leve l. themodified part of the pattern does not contain wildcard but useannotations.
during the creation of a recommendation ares replacesthe useannotationwiththecodethatwasmatchedbythe corresponding wildcard.
a wildcard and ausecorrespond to each otheriftheyhavethesamename e.g.
a1 .asthenamecanappear anywhere in the modified part a pattern can express movement s match original k wildcard expr a1 verbose 3this.init verbose 4this.shutdown 5updatevalue 6k 7while k wildcard stmt a2 9k wildcard stmt a3 12foo.somemethod a original part.
match modified use a1 verbose this.init verbose updatevalue for k k k use a2 if foo !
null foo.somemethod choice case system.out.print foo case this.print foo this.shutdown b modified part.
figure3 generalizedpattern.more accurate recommendations for method level changes es ec fse september4 paderborn germany of arbitrary code.
this solves the accuracy problem of the mo ved printmethodsintheintroductoryexample.
themodified part of the pattern also contains a choiceannotation.
ares creates this annotation if some training example s add different code.astheaddedstatementshavenoconnectionto the original code ares and also other tools cannot decide whi ch statements lead to the most accurate recommendation.
ares i nstead lets the developer choose among the variants of the sam e recommendation.thus the choiceannotationallowsarestohandleadditionalvariationsinthetrainingexamplestoincre aseaccuracy.
theabovediscussiondemonstratesthatourpatterndesign c an increase theaccuracyof recommendations.howtogenerate s uch patterns from examples and how to use them to create accurate recommendation is covered in thenext sections.
input order determination whenconstructingthegeneralizedpattern aresconsiders theinput code changes one after the other in the loop that is shown i n the upper half of fig.
.
the order in which ares uses them influences thepattern.twochanges thatareverydifferent i.e .
that have a large edit distance probably lead to a generalized pa ttern thatmakesexcessiveuseofwildcardstohideawaythediffere nces.
the resulting pattern is over generalized and will match in many locations of the code base.
the smaller the edit distance bet ween two changes is the smaller are the differing code fragments t hat areshidesinwildcards.hence thekeyideaisthatinevery i terationoftheloop aresfirstidentifiesacodechangethatisasc lose tothecurrentworkinggeneralizedpatternaspossible.ini tially in the first iteration when there is no working generalized patt ern ares chooses the two code changes that are as close to all othe r changes intheinput setas possible.
todeterminetheeditdistance aresusesatreedifferencing algorithm that extractsthedifferences betweentwo abstracts yntax trees asts .ingeneral thisismoreprecisethanapproach esbased onstringsortokens.thus aresusesatreedifferencingalgo rithm to extract code differences throughout the whole process un less statedotherwise .treedifferencing algorithmsdifferwith respect totheirprecisionintrackingcodemovements.
atreediffere ncing algorithm that reliably detects code movements leads to an e dit distance that better captures the closeness of two input exa mples whichisimportantfortheinputorderdetermination.thus ares uses mtdiff the currently most precise tree differenci ng algorithm thatconsiders codemovements.
let us sketch this input ordering process bymeans ofan example.
assume that there are four codechanges c1..c4.
each of them consists of an o riginal method block oiand a modified method blockmi.toobtainthedistancebetweentwocodechanges ciand cj arescomputesthenumberofeditoperationsrequiredtotra nsformoiintoojplusthenumberofeditoperationstotransform mi intomj.table holds some fictitious edit distances for this example.
as initial pair ares selects the examples that represe nt the two columns with thelowest sum c2 andc3 inthe example .
the firstiterationthenconstructsaworking generalizedpattern .sec.
below describes this step in detail.
the next iteration of th e looptable editdistancesbetweencodechanges c1..c4.
c1c2c3c4 c1 c24 c35 c46 summationtext.
thencomputestheeditdistancesfromtheworkinggeneraliz edpattern to the remaining code changes c1 c4 and uses the change withthesmallest distancetoit forthenext iteration.
picking input examples in an order that yields fewer wildcar ds increases the accuracy of the recommendations as wildcards can hidecodetransformations.forexample itispossiblethat thecombinationoftheworkingpatternwithaninputexampleforces ares togeneralize theloopsinfig.
into anextra wildcard.ther esultingpatternwouldstillmatchrelevant codelocationsinthe search step butareswouldnolongertransformthe whileintoaforloop.
thus morewildcards leadtoless accuraterecommendations .
pattern creation the input of the pattern creation step are two code changes c1 andc2 withtheirrespectiveoriginalandmodifiedmethodbodies .
fig.4holdstherunningexampleforthissection fromwhich ares creates the pattern in fig.
.
as discussed in sec.
this pat tern solves theaccuracyproblems.
thepattern creation step adds wildcardannotations where the original method bodies o1 ando2 differ.
similarly it adds useannotations where m1 andm2 differ.
to do so ares uses the tree differencing algorithm mtdiff which takes one original and o ne modified ast as input and then matches nodes from the original ast with nodes of the modified ast.
two nodes are a possible match if they have the same type e.g.
if both are identifiers .
mtdiffusesheuristicsforthismatchingofnodes.basedonthe node matches mtdiff generates a small edit script i.e.
a list of edit operationsthattransform theoriginal astinto themodified ast.
it uses four different types of edit operations on the granula rity of ast nodes namely delete insert update andmove.
themove operationmoves acompletesubtreetoa new location.
any ast node that is part of such an edit operation identifies achangebetweenthemethodbodiesthatthe patterncreation handleswithannotations.italsokeepsalltheremainingcodeu nchanged inthepatterntoincrease theaccuracy.
belowweshowindetailhowaresusestheeditscripts d o1 o2 andd m1 m2 providedbymtdifftocreatethepattern.todeterminethecorrectnames inthe useannotations aresalsorequires d o1 m1 andd o2 m2 .asthisprocessisthemostcomplexpartof ares wepresent itin sixsteps.
.
change isolation when ares generates a pattern from the input examples it has to make sure that the edit scripts only cover the sections of t he code that contain the actual change.
surrounding code that h as nothing todowith thechange butstillis different in theinpu t examples should not be part of the pattern.
if there was no chang eesec fse september4 paderborn germany geor gdotzler mariuskamp patrickkreutzer michael philippse n 2d .
3this.init true 4this.shutdown 5updatevalue 6j 7while j 8string tmp quotedbl.varbar quotedbl.var 9this.init verbose tmp 10j 12assert foo !
null 14foo.somemethod a original method o1ofc1.
d .
this.init true updatevalue for j j j string tmp quotedbl.varbar quotedbl.var this.init verbose tmp if foo !
null foo.somemethod this.print foo this.shutdown b modified method m1ofc1.1try 2this.i 3this.init verbose 4this.shutdown 5updatevalue 6k 7while k 8updatevalue 9printvalue quotedbl.varfoo quotedbl.var 10k 14foo.somemethod catch exception e c original method o2ofc2.try this.i this.init verbose updatevalue for k k k updatevalue printvalue quotedbl.varfoo quotedbl.var if foo !
null foo.somemethod system.out.print foo this.shutdown catch exception e this.shutdown d modified method m2ofc2.
figure4 codechanges c1andc2.
isolation suchsurroundingcodewouldcauseanover gener alized patternand thusinaccuraterecommendations.infig.
4chan gec1 does not have a trystatement whereas c2does.
withouta preceding isolation of the main change mtdiff would create an insert operation for the trystatement that in turn results in a wildcard annotation.
this would lead to an over generalized pattern with a single wildcard.
to avoid this ares isolates the codepart s that actuallycontaintherelevantchange e.g.
thebodyofthe trynode.
aresimplementsthenecessary changeisolation intwophases.
the first phase identifies the lowest nodes in the asts that encapsulatethechanges thesecond phase applies several heu ristics if the first phase still leads to an over generalization.
in t he first phase ares works with the asts of the original method oiand thecorrespondingmodifiedmethod miofachange.theeditscript d oi mi helps to identify the lowest root nodes in the two asts that areaffected byalltheeditoperations.eachsuch change root has the maximal distance from the root node of its ast and stil l encapsulates all the differences between oandm.
in the example thechange rootof o1 m1isthecompletemethodblockfromline1 to20.thechange rootof o2 m2isthetrynode duetothechange in thecatch .
as the roots are of different types selecting these twonodeswouldstillleadtoanover generalization.
thisa ndsimilarinputexamples areaddressedbyphasetwo.inalleasier cases ares uses the change roots for isolation and pattern genera tion toexcludeallsurrounding code.
ifthefirstphasecannotpreventanover generalization th esecond phase applies the following three heuristics in the desc ribed order a search for similar statements i.e.
statements paired togetherbymtdiff inthechildrenofthechange rootof o1andthe childrenofthechange rootof o2.form1resp.m2 therehavetobe matchingnodesin d o1 m1 resp.d o2 m2 .
b reversetherolesof c1 andc2 and thentry a again.
c performs a and b again but thistimewiththegrandchildreninsteadofthechildren.if allthree heuristics fail thecurrent implementation of ares stops w ithout a generated patterntoreducetheexecutiontime.
on the example phase two identifies similar statements in th e block ofc1 and in the bodyof the trystatement.
these nodes isolate the actual change avoid over generalization in the re sultingpattern and thus reduce theirrelevant and inaccurate reco mmendations.
.
edit script adjustment whilechange isolation avoids over generalization edit script adjustmentfindsabalancebetweenover generalizationandover fittin g i.e.
the creation of patterns that only match in very speci fic situations e.g.
the training set .
to keep a balance ares use s a rule based system with over rules rule description on gi thub ntindividuallywithinthespacerestrictions ofthis paper.hence wecan only discuss the two main issues that influence the balance an d applytherelevant rules totherunning example.
the first issue is that in most cases the tree differencing is to o fine grained.itoftenidentifiesmanysmallchangesonthele velof expressions but only few changes on the level of statements especially if the training examples are quite similar.
the res ulting patternsthenhave wildcards andusesforfine grainedexpressions that often only fit the training examples.
the accuracy of the recommendations willbehigh buttherecallwillbelow.
toavoid this areslooksformatchingstatements thatvaryi n many of their sub expressions.
in those situations ares ad justs the mtdiff generated edit script to use a single edit operat ion that covers the whole statement instead of many edit operat ions for all the differing sub expressions .
for example rule see fig.
adjuststheeditscriptforadeclarationstatement.
itapplies toline2infig.
.althoughboththeleftandtherighthandsi deof the assignment differ in o1 ando2 mtdiff keeps the assignment as this keeps the size of the edit script d o1 o2 small.
to avoid over fitting aresadjuststheeditscriptandreplacesall deleteand insertoperations for both the left and the right hand side of the assignments lines in fig.
with one insertoperation for a full statement line in fig.
.
adding a deleteoperationfor the assignmentisunnecessaryasthiswouldonlyleadtoawildca rdat thesameposition.
since finding an optimal list of edit operations that include s code movements is np hard all move aware tree diffe rencing algorithms rely on heuristics and there are cases in w hichmore accurate recommendations for method level changes es ec fse september4 paderborn germany function r.sc u.sc l.sc e.sc48 editops mapping declmappings getdeclarationmappings mapping for do1 do2 declmappings do l o1 leftside d o1 lo2 leftside d o2 r o1 rightside d o1 ro2 rightside d o2 ifisdeleted l o1 editops isdeleted r o1 editops then ifisinserted l o2 editops isinserted r o2 editops then removeopsfort l o1 editops removeopsfort r o1 editops removeopsfort l o2 editops removeopsfort r o2 editops addinsertfornode d o2 editops figure5 editscript adjustmentrule .
the edit script is not optimal.
any non optimal list leads to unwanted wildcards and thus increases thegenerality unneces sarily.
this is the second balancing issue that the edit script adjus tment addresses.
forinstance rule 31examinesmovesacrossnestedcodeblo cks.
it applies to line in fig.
.
mtdiff determines that the numb er ofeditoperationsis minimized if thecodeofline9in o1is moved to line in o2.
as a consequence mtdiff generates a moveoperation.
due to this moveoperation ares would insert a wildcard inline .this is toogeneral.
instead theadjustmentstep r eplaces themovewith adeleteoperations for thecall in line of o1.
then it addsthe insertoperationfor verboseinline 3of o2.
rules 19handlemovementsofidenticalstatements.for example thereexisttwoidenticalstatementsin o2 lines5and8 for the call in line of o1.
although this is not a problem for the running example theadjustmentstephas totakecareofwrongpa irs oftwoidenticalstatementsinsidethetreedifferencingres ults.otherwise there are unnecessary movesin the list of edit operations which canlead toanover generalized pattern.
rules 46handlechangesthatarealreadycoveredbychan ges oftheparentstatement.theserulesapplytothelines8and9 ofo1 thatarereplacedbynewstatementsin o2.mtdiffgenerates delete andinsertoperationsforeachastnodeinbothlines.forexample mtdiff generates a deleteoperation for string tmp etc.
for the pattern creation onlytheinsertfortheinvocations of updatevalue andprintvalue ino2 are relevant.
thus the rules remove all edit operations onnodes thatare partof thestatements.
for the delete oftheassertinline12 aresalsoreplaces thedeletedexpressions witha single deleteofthecompletestatement.
.
matchinsertion thisstepinsertsthe matchannotationintothegeneralizedpattern seefig.
.themainpurposeofthisannotationistoprovid ealist of identifier names that differ between o1 ando2.using wildcards for them is too verbose and would unnecessarily enlarge the p atterns.instead aresusesthematchednodepairsfrom d o1 o2 to findidentifiersinthesamematchpairbutwithdifferentnames .for therunningexample thisisonlythepair j k oftheloopvariables.
by mentioning the names in the annotation ares can remove them from all updateoperations inboth d o1 o2 andd m1 m2 .
.
wildcard and useinsertion this step adds the wildcardanduseannotations to the pattern accordingtotheeditoperationsthatareleftaftertheprevio ussteps.aresreplaceseachstatementthatan insertaddsino2withawildcard.if the insertoperationadds anexpression aresaddsa wildcardannotationinfrontofthestatement.similarly foreach insert thataffectsexpressionsorstatementsin m2aresadds useannotations.foreach deleteoperationthatremovesanodefrom o1ares adds awildcardannotation at the correspondingspotin o2 determined with d o1 o2 and the heuristics .
in the same way ares replaces each deleteinm1 with auseannotation in m2.
asmove operations basically delete a node in o1 m1 and add it in o2 m2 aresadds wildcardsforthe deleteandinsertoperationexpressed by themove.
note that at this point there are no longer update operations as the edit script adjustment either removed the m or replacedthemwith insertoperations.aresalsomemorizeswhich annotation belongs to which edit operation in order to facil itate thefollowingnameassignment step.
sinceintheexamplethe insertofverboseisleftind o1 o2 ares adds awildcard annotation before the statement and tags it with expr.additionally itspecifieswhichexpressioncorrespondst othe wildcard verbose .
as it is possible that an expression occurs severaltimesonthesamestatement thewildcardinline3ofthe final pattern in fig.
a also specifies the number of the occurren ce fortheexample .
fig.
b shows thecorresponding use.
another operation is the insertof the assignment in line of c2.
ares replaces this assignment with a wildcard annotation in o2.
as it is a replacement for a complete statement the tag stmt is added to the wildcard.
similarly ares replaces the assig nment inm2 with auseannotation.
for the inserted statements in lines and ares also inserts wildcardanduseannotations.
after the insertionoftheannotationsinline9 aresimmediatelycom bines bothadjacent annotations into a single one.
aresproceeds with theremaining edit operationsin this fas hionand finallycreates theresult infig.
.
.
wildcard name assignment this step assigns the names that link the wildcard annotations in theoriginalparttothe useannotations inthemodifiedpart.since these names can occur in different spots on both sides of a pattern they encode code movement.
hence they are crucial for the accuracyof therecommendations.
to identify the correct wildcard usepairs this step examines thestatementsthatwerereplacedbywildcards memorizedb ythe previousstep .intherunningexample awildcardreplaced updatevalueinline8of o2.thenaresuses d o2 m2 tofindanodein m2 thatismatchedtothemoved updatevalue fromo2.intheexample thematchednodeis thecall of updatevalue inm2.asupdatevalue inm2was alsoreplaced bya use ares links the wildcardanduse of the call together and gives them the same name a2in the example .similarly ares assigns theothernames tocreate fi g. .
the previous steps may create a patternthat starts with a stmt wildcard.
however when searching for applications it is un clear which sequence of statements this wildcard should match.
th erefore ares enforces that patterns begin with a specific state ment instead of a wildcard.
in the running example ares removes t he wildcard that replaced the assignment in line of o2.
if there is a corresponding usewiththesamenameandthis useisalsothefirst statement in the pattern ares also removes it.
the same appl iesesec fse september4 paderborn germany geor gdotzler mariuskamp patrickkreutzer michael philippse n tostmtwildcards attheend ofthepatternasthey matchthecomplete remaining function and thus the recommendation would be unnecessarily large.
the evaluation shows that this has no n egative impact on precision and recall compared to other recomm endationsystems.if theassigned useofaremoved wildcardisnotat the top or bottom of the pattern ares keeps the useannotation and only removes the assigned name.
this is necessary since t he corresponding wildcardis no longer present.
.
choice insertion the final step handles differences between the modified parts o f the code changes that do not correspond to code in the origina l parts.toincreasetheaccuracyoftherecommendationsitis necessarytohandlethosedifferencesexplicitly.aftertheprevi oussteps the differences are visible as they correspond to useannotations without assigned names.
this step replaces each such usewith a choiceannotationbecausetheinputexamples provideinsufficient information to determine the right recommendation based on a purelysyntactical approach.
intherunningexample the usethatreplacedthe assertandprint callhasnoassignednameandisthuschangedintoa choiceannotation.
based on c1 andc2 it is impossible to determine which print invocation should be part of the recommendation.
hence are s generates several recommendations one for each variant.
i t is up to the developer to decide which of the recommendations is th e most appropriate.
similar to the name assignment process a res onlyhastoexaminethestatementthatwasreplacedbythe useannotationtoidentify thecodeforthe caseannotations infig.
b .
search forapplications thissectionexplainshowaresfindscodelocationswhereagi ven pattern is applicable.
for a high accuracy it is important t hat the algorithm identifies the correct matches between the ast nod es in the pattern including wildcards and ast nodes at the cod e location.tomakethealgorithmasfastaspossible thissec tionno longer relies on a tree structure but uses a serialized list o f ast nodes.
however this is no limitationto the movement suppor tas therecommendationcreation sec.
handles them.
as exampleweusethepatterninfig.3and browsethecodein fig.
a .aresfirstsearchesforsuitablestartingpointsi nthecode and then executes the ast node matching from there in parall el.
suchastartingpointisanastnodethathasthesametypeasth e first ast node in the original part of the pattern and that is no t partofanannotation.thefirstnodeinfig.
3is themethodcal lin line .
suitable starting points in fig.
a are the calls in lines and .
ares uses each of these calls as a startnode when executingthealgorithmgiveninfig.
.theotherinputargu ments aretheastofthemethodthatcontains startnode andtheastof theoriginal partofthepattern.
in lines and of fig.
ares generates a list of ast nodes forthecodelocation startingat startnode andalistofastnodes for the pattern starting from the first code node in the body o f thematchannotation .
with the loop in lines the algorithm compares both lists of ast nodes to determine whether they ar e identical withrespecttothewildcards inwhichcasethe pattern is applicabletothecodelocationthat startsat startnode .1foo foo library.getobject 2this.init getverbose 3this.shutdown 4updatevalue 5c 6while c 7system.out.println c 8c 10foo.somemethod 11return foo a matchingcodelocation.foo foo library.getobject this.init getverbose updatevalue for c c c system.out.println c if foo !
null foo.somemethod this.shutdown return foo b recommendation.
figure6 recommendationcreation.
intherunning example bothlistsstartwitha callnode.asthe node of the pattern is not a wildcard w line is nulland the algorithm uses ismatchto compare n clof the code location with npofthepattern.thefunction ismatchreturnstrueifthetypesof these ast nodes are identical e.g.
if both are callnodes .
there areonlytwoexceptions.ifbothastnodesareidentifiers ismatch is true if n pis in the list of identifiers of the matchannotation or if the identifier names are equal.
the second exception conce rns boolean constants as they make a large difference in the patte rn due to their limited value range.
in this case ismatchis only true if both are identical.
ares does not compare the values of oth er constants.thisincreasesthegeneralizationofapatterna ndmakes itapplicabletomorecodelocationsbecausedifferentliter alsdonot prevent a patternfrombeing applicable.
ifthecomparisonwith ismatchissuccessful thealgorithmadds thepair n cl np tothesetofmatchednodes matches .therecommendationalgorithmlaterusesthissettoreplacetheident ifiersin thepattern e.g.
k withidentifiersofthecodelocation e.g.
c and function s.sc e.sc a.sc r.sc c.sc h.sc startnode methodbody originalpatternpart nl cl getnodes methodbody startnode nl p getpatternnodes originalpatternpart pos cl posp resets matches visited whileposcl nlcl posp nlp do n cl getnode nl cl poscl np getnode nl p posp w null ifiswildcard n p then w np else ifhasassociatedwildcard n p then w getassociatedwildcard n p ifw nullthen ifismatch n cl np originalpatternpart then matches ncl np pos cl poscl posp posp continue else ifw nelementvisitedthen addlast resets pos cl posp matches visited visited visited w ifallowednode w n cl then matches ncl w ifallowedreset w n cl then addlast resets pos cl posp matches visited pos cl poscl continue ifresets thenreturn null pos cl posp matches visited removelast resets ifposp nlp then returnmatches else returnnull figure7 algorithm tosearch for suitablecodelocations.more accurate recommendations for method level changes es ec fse september4 paderborn germany also toreplace constants in thepattern e.g.
withcons tants in thecodelocation e.g.
.ifthecomparisonwith ismatchisunsuccessful thealgorithmlooksforanothervalidpositiontob acktrack lines .if thereisavalid position aresresets thev ariables tothesaved values and continues from thelast validpositio n. backtracking is necessary due to the use of wildcards.
the pa ttern design see sec.
allows a wildcard to replace none or m ore statements expressions.
this leadstoseveral validend po intsofa wildcard match and creates the reset nodes.
in the example t he nodeverboseis associated with a wildcard.
thus getassociatedwildcard identifies the wildcard in line of the pattern.
as this is thefirstappearanceof this wildcard thealgorithmcreates avalid reset position in line .
this reset position covers the cas e that the wildcard is empty and does not match any code at this location.
the reset point starts at the position after verbose posp and thus continues withoutamatch.
inourexample inithasanargumentandthusthewildcardhasa nodetomatch.thefunction allowednode checkswhetherthewildcard canreplacen cl.areplacement ispossibleif n cliswithinthe scopeofthewildcard.forthewildcardinline2 thescopeco nsists of the arguments of init.
here this is the case and the algorithm adds the appropriate match line .
if n clis also the last node of one argument of init the node is also a valid end point of the wildcard and the algorithm adds a new reset point that starts at the end of the argument lines .
then the search contin ues at the next node in the list of the codelocation lines .
the algorithmhandlestheotherwildcards lines8 inasimi larfashion.
the difference is only that this time allowednode accepts all nodes from the current code block and allowedreset accepts only completestatements.
aftertheloopterminates thealgorithmcheckswhetherthe process reached the end of the template and thus whether the code locationmatches all nodes of the template.
in this case thes earch is successful and returns theset ofmatched nodes lines .
recommendation creation thegeneralideaofthecreationstepistousemtdifftocreat ethe list of edit operations that change the originalpart of the pattern intothemodifiedpart seefig.
andtoapplytheseeditoperations toacopyofthecodelocation identifiedinthepreviousstep .note thataresdoesnotusethe modifiedpartofthepatternasthebase for the recommendation.
using the list of edit operations in stead hastheadvantagethatarescanpreservepartsofthecopiedc ode e.g.
theidentifier candthenumber seefig.
a .thisincreases theaccuracyof therecommendation.
to be able to apply the list of edit operations the copied cod e has to look like the originalpart of the pattern.
for that purpose ares removes all ast nodes from the copy that were matched withawildcardduringthesearch.thenaresinsertsthewild card annotationsintothecopy.afterthesechanges thecopyloo kslike theoriginalpartofthepatterninfig.
a exceptforthepreserved codeparts.thisallowsarestoapplytheeditoperationstoc reate themodifiedpartofthepattern withrespecttothepreservedcode parts .thenaresreplacesthe useannotationswiththecodethat is paired with the corresponding wildcard i.e.
the wildca rd with thesame name.finally aresworksonthe choiceannotations.forasingle choice ares could create one copy of the recommendation per case.
if therearemore choices thenconceptuallythereisthepotentialfor exponential growth.
hence ares limits the number of copies .
if thereareatmost maxcasestatementsinall choices 2intheexample arescreates max copiesof thecurrent recommendation code.the n thcopycontainsthecodeinthe n thcaseannotationof eachchoice.if achoiceannotationhasfewer than ncases weomit this choice completely.
this implies that the last copy does not contain any code from choiceannotations.
after this step ares presentsthe max 1copiesasvariantsofonerecommendationto thedeveloper.
evaluation wefirstevaluatetheaccuracyofaresandcompareitwiththat of lase before we show that the improved accuracy does not gravely impact precision recall or execution times.
for a ll measurements we use a workstation with gb of ram and a .
ghz intel xeon cpu openjdk and ubuntu .
.
we also discussthecurrent limitations ofares inthis section.
.
accuracy ourbenchmarkscompriseseveralreal worldsourcecodearc hives thatvarywithrespecttothenumberandsizeofthesetsoftra ining examples similar code changes .
we always check how close t he recommended code changes get to changes that can actually be foundin thecommits.
eclipse two input code changes.
in this part we use groups of similar code changes bugzilla ids f rom theeclipse jdt project and groups from the eclipse swt project .
meng et al.
used the same manually collected groups for their evaluation of lase.
all these code changes a re present in commitsof therespectiverepositories.
table2 lists the bugzillaids of thechanges mis the sizeof the group of similar code changes that exist in the repositories for a bug.inmostcases mis equaltotheevaluationprovidedbymeng etal.theonlyexceptionsaretherowswithids20and21forwh ich weidentified a different number of changes intherepository.
for the next two segments of table lase two input code changes ares two input code changes we use the same two changesofagroupforthecreationofthepatterns.wecarefu llyselectedthetwochanges toreproducethesameprecisionandre call values thatmeng etal.
listintheir evaluation.
for each of the bug fixes the columns list the number of codelocationsforwhichlaseandarescreatearecommendati on.
the columns marked with checkshow how many of the mmanually identified locations the tools find.
for each of them column at andacgive the accuracy i.e.
the closeness of the recommendation to the code that the original developers of the change wr ote.
thus a perfect accuracy means that the recommendation has t he same statements moved code and identifiers that are present in the repository.
for developers this is important because a h igher accuracy means less work to actuallyapply a recommendation to a project.
to measure the accuracy we compute the levenshtei n distance ld between the method body of the recommenda tionandthemethodbodyofthechangedcodefromthereposito ry.esec fse september4 paderborn germany geor gdotzler mariuskamp patrickkreutzer michael philippse n table comparison withlase on23 codechangesfrom eclipse jdtand eclipseswt.
lase twoinputcode changes ares twoinputcode changes ares all code changes idbugzillaidm checkat ac p r checkat ac p r checkat ac p r avg.
m availablelocations generated recommendations checkcorrectrecommendations at tokenaccuracy at characteraccuracy p precision r recall weusetwovariants.
thefirstuses asttokens t thesecond actualcharacters c .a high tokenaccuracy atshows thattherecommendationis accuratewith respecttothesyntax e.g.
us es the samenumberof ifstatements .weuse at ldt max rt mt where rt is the number of tokens in the recommendation and mt isthenumberoftokensinthemethodbodyfromtherepository.as comments are not part of any token they are ignored f or thismeasurement.wealsodefine ac ldc max rc mc where rc is the number of characters in the recommendation and mc isthenumberofcharactersinthemethodbodyfromthe repository.thisincludesbothcommentsandwhitespace.ea chcell intheaccuracycolumnscontains themeanofthecorrectlyid entified recommendations check .
across all groups of codechanges ares can producemore accurate recommendations compared to lase and even achieves a perfect accuracy for of the groups.
for these gro ups the recommendations are identical to the changes that were a ctually performed by a human developer.
a closer inspection of t he recommendations by lase shows that lase ignores code transformations that occur only in one of the input examples which reducesat.
for some cases the ares accuracy column contains twovalues.inthesecases thepatterncontainsachoiceann otation andaresgeneratesseveralrecommendationvariants.
atandac give the minimal and the maximal accuracy values for the corr esponding groups.
in of the cases ids even the m inimalvaluesfor atofaresoutperformlase.often for11groups aresachievesperfectaccuracyvalues in ac.hence ares recommends exactly the code a developer has written includ ing comments codingstyle and whitespace.
eclipse all code changes.
in some cases e.g.
patterns for critical bugs a high recall is more important than a high pre cision and accuracy .
for these cases ares supports more tha n two input changes.
each additional change in the training se t can increase the number of wildcards and hence the recall.
howev er each additionalwildcardcanalsodecreaseprecisionandac curacy.toexaminetheeffectsofadditionalinputchangesweaddedat hird set of evaluation results in table ares all code changes .
for theseresults aresusesallinputchangestocreateapatter n.thus we maximize the recall and minimize precision and accuracy f or each of thegroups.
forthisset theaccuracyofaresisstillat94 inthemi nimalchoicecase onaverage.
in mostcases theaccuracyofa res inthisconfigurationisalsohigherthantheaccuracyoflase with only two input changes.
this means that even with the most gen eral pattern for a group and thus the pattern with the least ac curacy ares still achieves higher accuracy values than lase.
also aresstillhas aperfectaccuracyfor8 groups.
junit allcodechanges.
theaboveanalysisshowsthatares achievesahigheraccuracyforthe23groupsofcodechangesf rom eclipse.
a threat to the validity of these results is that it i s possible to optimize a system for such a small dataset.
to examin e whetheraresalsohashigheraccuracyvaluesforalargerdat aset we use groups of code changes from junit taken from theresults of c3 .c3is a toolthat identifies groups of similar codechanges incoderepositorieswiththehelpofclusterin galgorithms.
the groups by c3are suitable inputs for ares and lase.
this time we use all input examples not only two to train are s and lase.
whereas it is again possible to measure the accuracy as the manual code changes are in the repository there cannot be nu mbersfor precisionand recallas mis unknown forthis dataset.
table shows the accuracy results for junit.
for sets of i nputchanges bothlase and ares producerecommendations and generate a recommendation for the input changes.
we exclude d inputchangesforwhichoneofthetoolsproducesanerrorord oes not recommend a change.
similar to the evaluation above are s reaches a high accuracy of to .
again for most groups the accuracy of ares is higher than that achieved by lase.
thi s is alsotruefor theminimal accuracyvalues.more accurate recommendations for method level changes es ec fse september4 paderborn germany .
precision recall and time measurements precision recall.
letusnowcomparetheprecision p check and recallr check m values.thehigher theprecisionand recall thebetter isthetool.overall theprecisionofaresissimilartothat oflase.
for of the groups of code changes the precision of ares is identicaltoorhigherthanthatoflase.theaveragerecallo fares isstillatahighlevel butbelowthatoflase .how ever christakis and bird found in their studythat therecall is less importanttodeveloperscomparedtoahighprecision.hence with respect to precision and recall there are almost no costs f or the improved accuracyofares.
a closer look reveals that ares is more precise than lase for three change groups ids becauseof two reasons.
first arescanhandlevariationsintheinputchanges withappropr iate wildcards.
instead lase uses the maximum common embedded subtree extraction algorithm to identify the common ast that all training examples share and which is moregeneral in some cas es.
second ares keeps common code even if it is unrelated to the changes whereas lase identifies code that has no dependenci es tothecodechange and excludes itfrom thepattern.
while it can be beneficial to keep some unrelated code in the pattern keeping too much of it causes a loss of precision id or recall.
there is room for more research concerning this is sue.
in contrast to lase ares is also currently limited to themet hod body and does not include the method signature in the pattern s. this lack of a signature in thepatternlowers theprecision i n two cases ids .
thegroups20and23areoutliersastheprecisionofbothares andlaseisconsiderablylowercomparedtotheothergroups.
the reason is that the input examples for both groups only add the same statements and otherwise have very little code in commo n. this leads toshortand very general patterns.
time measurements.
here we compare the times that ares and lase take to create the patterns and to use them when they browsetheprojectsforpossiblepatternapplications ecl ipseswt java files 000lines of code eclipse jdt java files 000loc .
fig.
shows the measurements.
each code change row in table corresponds to one measurement point .
the lines in the boxes are the medians of the time measurement s. theboxesoftheplotdefinethe25 and75 quartiles thewhis kers show theminimum and maximum.
arescreatespatternsfasterthanlase patterncreation infig.
because the changedistiller tree differencing algorit hm that lase uses has a higher runtime than mtdiff .
however the search for pattern applications in ares pattern use in fig.
is slowerbecausethepatternsofaresarecurrentlylimitedto method bodies and do not contain method signatures.
lase can use the method signature to filter out methods and thus has to inspect table accuracyon junit.
lase ares min max groups of code changes shared recommendations shared recommendations at mean shared recommendations at median shared recommendations ac mean shared recommendations ac median 80ares pattern uselase pattern useares pattern creationlase pattern creation execution time sec.
figure8 timeperchangegroupfortwoinputcodechanges quartiles whiskers minimum maximum .
fewer method bodies.
still even for such large repositorie s ares completesthesearchforonepatternwithinaminuteinmostc ases.
.
limitations and threats to validity themajor limitation of ares is thecurrent restriction tome thod bodies.duetothis restrictionwealsohadtoexcludethegro upof code changes with bugzilla id that meng et al.
use i n their evaluationof lase.
this was necessary as thecodechan ges inthisgrouponlyhaveacommonsignaturebutnocommonstate ments.
whereasboththesearchandrecommendationcreationofares already support larger changes extending the pattern crea tion to work with full classes would need annotations that for exam ple define when methods or fields can be reordered.
the pattern cre ation would also require new rules and transformations for w ildcards outsideofcodeblocks.
anotherlimitationisthatares likelase canonlysearchf or onepatternatatime.similartotheirapplicationincodecl onedetectiontools suffixtrees mayacceleratethesearchfor several patternsin parallel.
thethreattovalidityoftheevaluationistheimplementati onof lasethatwebuiltfromapubliclyavailableversion .weh adto applyseveralbugfixestobeabletoreplicatetheevaluation results of meng et al.
.
despite our efforts there are still some s mall differencesleft.wealsochangedtheimplementationtobypa ssthe ui to enable script based performance measurements.
we arg ue thatifwehaveintroducednewerrorstheyareprobablysmall since weobtained mostoftheoriginal results.
related work the book recommendation systems in software engineering and the study by gasparic and janes provide an overview o f therelatedwork.wediscuss theworks closesttoares.
example basedrecommendation.
lase isclosesttoares.
the main differences are that lase does not handle moved code partsaccuratelyand thus theaccuracyof therecommendatio ns is lower.
rase relies on lase to create a generalized patte rn from examples.
with this pattern it refactors the code witho ut altering its semantics to replace all changed locations with a single unifying code fragment.
thus it has the same low accurac y as lase and also only supportsrefactorings.
in contrast to a res sydit generates an edit script from just one example whi ch limits its generalization ability.
developers also must fin d patternesec fse september4 paderborn germany geor gdotzler mariuskamp patrickkreutzer michael philippse n applicationsmanuallywithsyditwhereasaresfindsthemaut omatically.critics addressesthereviewprocess.thed eveloper provides a generalization of a single codechange as input.
c ritics thenfindsmatchingspotsinthecodewhereasimilarchangema y have been forgotten or where an inconsistent modification ma y haveoccurred.forcritics itisthetaskofthedeveloperto provide the generalization and to take care of the design of the patte rn to increase theaccuracy.arescreates thepatternautomatica lly.
refazer is another toolthatlearns codetransformatio ns from examples.
it uses a domain specific language dsl to rep resent code change patterns.
in contrast to ares the algori thms thatgeneratethispatterndonotsupportcodemovementsand thus if a code pattern relies on movements it cannot be as accurate as ares.
currently a direct comparisonis not possibleas refa zer onlysupportsc and python whereas aresuses java.
santosetal.
comparethreedifferent ways structural astbased information retrieval to search for additional cod e change locationsbasedonuptotwoexamples.ifasearchfindssuchal ocation theirsystemappliesasetofcodechanges.ifthisissu ccessful their system recommends the code change.
their ast based ap proach uses the longest common subsequence lcs and thu s is less precise then ares in regard to moved code.
also this ap proach is time consuming as it requires the execution of the l cs on many different asts.
ares is faster as its backtracking alg orithm can abort the search for possible pattern application s earlier.
their information retrieval approach relies on the si milarity of code parts e.g.
variable names and is less precise then ares that includes the code structure in the pattern.
their struc tural approach searches for methods with similar signatures pac kages etc.
the authors argue that this is useful in combination wit h the ast based and information retrieval approaches.
it is poss ible to includetheir structuralapproach inarestoincrease preci sion.
tate et al.
use a proof checker to learn transformation s from examples.
they can only find provably semantic preserv ing transformations.
padioleau et al.
introduce semantic patches to manuall y generalize patches obtained from standard diff tools.ander sen et al.
extend this idea and introduce a tool that creates g eneralized semantic patches from hand picked diffs.
ares is more accurate as it supports code movements whereas diffs are limi ted toinsertanddeleteoperations.
code completion.
cookbook uses generalizations from examples to suggest code completions while the developer is typing.
in contrast to ares it is a line based approach and does no t support code movements and thus has a lower accuracy if code movements are necessary.
mapo and precise search f or similar api usages in code repositories.
mapo recommends fr equently used call sequences.
precise extracts api calls inc luding theirargumentvaluesandcorrespondingdeclarationsfrom repositories extracts groups with similar arguments using a k n earest neighbor algorithm and generates api usage recommendatio ns includingpossibleparameters.bruchetal.
alsouseak nearest neighbor algorithm and find code fragments that are similar t o code that is currently being developed.
bajracharya et al.
use structural semantic indexing for this purpose.
all focus on code completionsandthussmallcodingsuggestions.
incontrast aresstrivestosuggestlargertransformationsincludingchang esofcompletemethods.
specialized recommendation.
in addition to example based approaches there are also tools for specific tasks.
cfix uses predefinedpatternstoautomaticallyfixconcurrencybugs.w eimer etal.
andautofix e generatebugfixesautomatical ly but arelimitedtotestablefixesandspecifications.robbesandl anza learn code transformations by examining edit operations in the ide.theirtoolcannotautomaticallyfindlocations.strate go xt anddms offerdslstospecifyasttransformations.mannie sing etal.
focusonlooptransformations.otherworkssolel ylocate patternsinsourcecode e.g.
thedependencyquerylanguag e or the program query language .
in contrast to ares deve lopersmustspecifypatternsmanually.theyalsodonotgetre commendations.
miller et al.
let developers select multip le code fragmentsandthentheyapplyachangetoalloftheminthesam e fashion.
in contrast to ares this is limited to identical cha nges and developers havetofind thecodelocationsthemselves.
th ung et al.
introduce a recommendation system that supports developers in backporting linux drivers.
their framework is s pecifically tailored to the backporting and is not intended for ge neral codechange recommendations.
conclusion wepresentedthenovelaccuraterecommendationsystem are s that specializes on code movements to increase the accuracy of coderecommendations.
a higher accuracy means that ares gen erates coderecommendations that better reflect what a devel oper would have written.
ares achieves the higher accuracy resul ts with a pattern design that expresses code movements more accurately compared to the state of the art.
similar to othe r tools aresgeneratesthesepatternsfromsourcecodetrainingexa mples.
thegeneratedpatternsofarescontainonlyplainjavacodew ith a set ofannotations and therefore are not a black boxfordeve lopers.thus developers canread and manuallyadaptthepatter ns.
we also presented in detail how ares generates generalizes and applies these patterns.
with these techniques ares achi eves anaveragerecommendationaccuracyof96 inourevaluation and outperformslase.
precision and recall are onpar.
the execu tion timeisabithigher butstillbelowtwominutesforlargerea l world sourcecodearchives.
forreproducibilityandtokindlefurtherresearch weopen source ares therulesfortheeditscriptadjustment alltheevalu ationinputsandresults includingthehuman readablepatternsge nerated byares