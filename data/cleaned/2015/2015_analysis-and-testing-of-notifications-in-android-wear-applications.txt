analysis and testing of notifications in android wear applications hailong zhang and atanas rountev ohio state university columbus oh usa email zhanhail rountev cse.ohio state.edu abstract android wear a w is google s platform for developing applications for wearable devices.
our goal is to make a first step toward a foundation for analysis and testing of a w apps.
we focus on a core feature of such apps notifications issued by a handheld device e.g.
a smartphone and displayed on a wearable device e.g.
a smartwatch .
we first define a formal semantics of a w notifications in order to capture the core features and behavior of the notification mechanism.
next we describe a constraint based static analysis to build a model of this run time behavior .
we then use this model to develop a novel testing tool for a w apps.
the tool contains a testing framework together with components to support a w specific coverage criteria and to automate the generation of gui events on the wearable.
these contributions advance the state of the art in the increasingly important area of software for wearable devices.
i. i ntroduction wearable devices.
electronic wearable devices are designed to be worn on the body in order to enable mobility and handsfree eyes free activities.
while smartwatches and fitness wristbands are currently the most widely used such devices other device categories are also expected to become increasingly popular including head mounted displays smart jewelry body cameras and smart garments.
traditional mobile devices require direct manipulation resulting in high cognitive and perceptual load that causes distractions for the user.
wearable devices are supposed to reduce this load and to allow interactions that are embedded context aware personalized adaptive and anticipatory.
the long term trend is toward devices rich with environmental and physiological sensors e.g.
gps accelerometer heart rate with a wide range of uses in healthcare fitness entertainment manufacturing construction field work etc.
wearable devices are expected to become one of the fastest growing markets in computing.
a recent industry report forecasts that over million smart wearable devices will be shipped in and .
million units will be android based .
software applications written for wearable devices present a variety of interesting challenges for software engineering researchers for example security privacy power consumption uis optimized for device limitations and software evolution due to a rapidly evolving marketplace.
in this context it will be essential to develop a body of work on static and dynamic analyses for program understanding testing debugging optimization and evolution.
android wear .
android wear aw is google s software platform for developing apps for wearable devices .
ata high level there are two categories of aw apps.
first a wearable device may work in conjunction with a companion handheld device which is typically a smartphone or a tablet.
the software on the wearable and the software on the handheld interact through platform apis.
a second scenario is when a stand alone wearable device contains software running independently.
stand alone apps are not well supported by aw .x but are expected to become more popular because of better support in aw .
released officially in february .
for the rest of this paper we consider aw apps in which software runs both on a wearable and a companion handheld.
our work focuses on a core feature of aw apps notifications that are issued by the handheld and displayed on the wearable.
the building and issuing of notifications is the first topic that is introduced by google s aw developer guide .
when a notification is displayed users can perform an action that returns the flow of control back to the handheld.
our contributions.
to the best of our knowledge this key aspect of aw app behavior has not been studied in prior work.
given the increasing importance of wearable devices it is highly desirable to establish foundations for analysis and testing of wearable apps.
the contributions of our work can be summarized as follows.
first we define a formal semantics of a w notifications .
using abstracted syntax and operational semantics we capture the core behavior of the notification mechanisms.
second we describe a static analysis to build a static model of this run time behavior.
the analysis is based on static abstractions of relevant run time entities together with a constraint based representation of the important relationships between these entities.
third we use the model to develop a novel testing tool for aw apps.
the tool contains a testing framework to define and execute tests across the two devices a component to measure run time coverage for awspecific coverage criteria and a component to automate the generation of gui events on the wearable.
finally we present experimental results and case studies to evaluate the proposed techniques.
we plan to release publicly our implementation and experimental subjects in the near future.
ii.
b ackground and example our focus are android wear applications which are defined for and run on a handheld device e.g.
a smartphone but use a wearable device e.g.
a smartwatch to display notification to the user and to receive user feedback.
in essence the wearable device becomes an extension of the gui for the handheld ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1class mynotificationmanager void create builder builder new builder intent mainintent new intent mainactivity.
class pendingintent mainpi pendingintent.getactivity mainintent wearableextender extender new wearableextender if ... notification chatpage new builder .build extender.addpage chatpage intent replyintent new intent remotemessagingreceiver.
class pendingintent replypi pendingintent.getbroadcast replyintent action replyaction new action.builder replypi .build extender.addaction replyaction intent readintent new intent markreadreceiver.
class pendingintent readpi pendingintent.getbroadcast readintent action readaction new action.builder readpi .build extender.addaction readaction builder.setcontentintent mainpi .extend extender notificationmanager.notify builder.build fig.
.
simplified code from qksms .
g29 g3 g86 g90 g76 g83 g72 g3 g87 g82 g3 g79 g72 g73 g87 g29 g3 g70 g79 g76 g70 g78 g29 g3 g86 g90 g76 g83 g72 g3 g87 g82 g3 g85 g76 g74 g75 g87 fig.
.
screens on a smartwatch.
device.
in practice this means that there is one application apk running on the handheld and api calls are issued in this apk to trigger certain behaviors on the wearable.
in an exploratory study of google play apps we considered the top apps in each app category and identified apps that contain wearable specific code.
of those had this structure.
two other alternatives are also possible.
first there could be an apk running on the handheld and another apk running on the wearable with inter device communication provided by relevant apis.
second there could be a standalone apk on the wearable without the need to a companion handheld.
while both of these scenarios are interesting for future work they are not considered here.
a notification is displayed as a sequence of screens on the wearables.
swiping left and right allows the user to navigate between screens.
there are two categories of screens.
a page displays the content of a notification including title text and icon.
it is a passive entity the user observes the information but does not interact with it.
an action is a screen containing a title and an action button the user can click the button to execute some desirable functionality by triggering code that executes on the handheld device.
a. sample android wear app figure presents a simplified version of code from the qksms open source android wear app.
non essential details have been removed or simplified for clarity.
this messaging app interacts with a smartwatch to issue notifications.
the call tonotify at line results in several screens being displayed on the smartwatch as illustrated in figure .
the main page is displayed first.
the title of this page is test account the message sender identifier and the page text aloha is the content of the message.
if the user swipes to the left another nested page is displayed with the chat history for this message sender.
another swipe from right to left shows the reply action.
through additional swiping the user can access three more actions.
the last one block app is a default aw action that blocks further notification from this app.
a notification has at least one page the main page as well as the block app action.
there can be additional pagesfollowing the main page.
these pages are followed by a sequence of actions.
when an action s button is touched by the user the aw framework executes code on the handheld.
for example for the open on phone action a screen will be opened on the handheld to display the list of conversations.
the executed code is in class mainactivity and is triggered using the intent object at line in figure .
b. main concepts and apis the key concepts for the notification mechanism are a notification builder object is used as a factory for notification objects a wearable extender is a helper object which when applied to a notification builder causes the creation of wearable specific notifications several actions can be included in a notification to allow the user of the wearable device to respond an intent inside an action determines which handheld app component is invoked in response nested pages can also be included in the extender builder notification.
lines and in figure create notification builder objects.
these are instances of class notificationcompat .builder shortened to builder in the example.
line creates a wearable extender.
the builders and the extender are ultimately used to create a notification object call to build at line and to display it on the wearable call to notify at line .
in general notifications can be displayed both on handheld devices and on wearable devices.
wearable specific notifications are created using wearable extender objects.
an extender adds more features to a builder.
for example the call to extend at line adds the actions and nested pages of extender intobuilder .
earlier api calls populate the extender with these actions lines and calls to addaction and nested pages line call to addpage .
an action object describes a screen to be displayed on the wearable device.
the screen contains a title e.g.
mark as read and has an underlying intent .
when the user swipes to this screen and touches the icon the intent is used to trigger an app component on the handheld device.
for the running example an action object for reply is created at line using a helper action builder object.
this action is associated with an intent to execute remotemessagingreceiver line authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
an app component that operates on the handheld device.
this component is an example of a broadcast receiver a standard android component type that operates in the background and responds to requests sent through intents.
another intent created at line is used to trigger a broadcast receiver markreadreceiver on the handheld in response to the action created at line .
both actions are added to the extender and then copied to the builder via extend and then to the notification created at line via build .
an instance of class intent contains an abstract description of an operation to be performed.
this is the general android mechanism for triggering app components.
for example if one activity another standard component type in android in a handheld device app wants to trigger another activity in the same app it typically invokes startactivity and provides as parameter an intent that describes the target activity.
similarly a call to sendbroadcast triggers a broadcast receiver based on a given intent.
because of the widespread use of this mechanism prior work e.g.
has considered the semantics of intents and their static modeling.
for an intent to be used as part of the notification mechanism analyzed in our work which works across two devices rather than inside a single device it has to be wrapped by a helper pendingintent object.
for security reasons the intent should almost always be explicit .
lines and show the creation of these helper objects.
the pending intent is given to the android notification manager as part of the action object and when the action is actually performed i.e.
the action icon is touched by the user the pending intent is used to access the underlying regular intent.
at that time the conceptual equivalent of a call such as startactivity orsendbroadcast occurs using that intent object.
the call to setcontentintent at line is used to add a default open on phone action to the builder.
the action is implicitly created as part of this api call.
in this example the target of this action is mainactivity via the intent created at line .
this activity is executed on the handheld in order to display the list of conversations.
line creates a notification object and line uses addpage to add it to the extender and thus to the notification being created by build at line .
note that both line and line invoke build on a notification builder and produce a notification instance.
in this case one of the notifications line corresponds to the main notification page and the other one line to a nested page for the chat history.
the next section formalizes the key abstractions for aw notifications and defines their run time effects.
this formalization serves as the foundation for the proposed static analysis.
iii.
f ormal semantics of aw n otifica tions the formal definition of the run time semantics of notifications in aw apps is based on semantic definitions for plain java loosely based on and plain android derived from our prior work as well as a formalization newly developed by us specifically for aw applications.a.
plain java and plain android plain java.
our discussion focuses on the semantics of individual statements inside method bodies.
the modeling of the type system and the behavior due to calls and returns is well understood e.g.
and is elided for simplicity.
a java program contains a set of java classes.
each class defines a set of fields f field and a set of methods and constructors.
a method body contains declarations of local variables x var and a control flow graph in which nodes are statements.
the syntax of these statements is defined by s x newc x y x y.f x.f y generalizations to include method calls and other java features are well known and are not discussed.
the corresponding semantics is based on a set obj of heap objects a map store that defines how local variables refer to these objects and a map heap to represent the values of object fields.
o obj heap objects store var obj variable values h heap obj field obj field values the semantic effects on the store and the heap are angbracketleftx newc h angbracketright angbracketleft h angbracketright angbracketleftx y h angbracketright angbracketleft h angbracketright angbracketleftx y.f h angbracketright angbracketleft h angbracketright angbracketleftx.f y h angbracketright angbracketleft h angbracketright the rules show the updated store heap a indicates that map ais updated by re mapping btoc.f o rx newc o obj denotes a new heap object of class c we assume that the initialization of o s fields is represented by separate statements of the form x.f y. plain android.
our prior work on analysis of android guis defined the gui related semantics of several important android features e.g.
activities menus dialogs widgets layout definitions event listeners etc.
.
these definitions are not directly related to the problem considered in this paper but the aw semantics described below can be considered as an extension of these existing definitions.
b. notifications in android wear anotification is a message displayed outside an application s normal gui.
for the aw applications we consider an application running on a handheld device uses notifications to display information on a companion wearable device.
instances of the relevant aw classes and the sets of all such instances will be denoted as follows no notif obj notifications nb notifbuilder obj notification builders we wearextender obj wearable extenders ac action obj actions in intent obj intents pi pendingintent obj pending intents after a notification is created in the handheld device app it can trigger a new screen on the wearable device.
this is done through a call to notify as illustrated by line authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in figure .
for the purposes of control flow and data flow analysis notify causes the execution of event processing logic on the wearable device which then triggers eventhandling code back in the handheld device in a component such as an activity or a broadcast receiver.
analysis of inter component control flow and data flow in android apps is of fundamental importance and has been the target of many existing analyses e.g.
.
for aw apps notify is a control flow exit point which has to be matched with a subsequent re entry point in the handheld app code.
in essence the notification mechanism provides a new path for inter component control data flow but this time involving two devices.
our static analysis is the first approach to model this kind of inter component interactions.
the matching of control flow exit points and re entry points is part of the analysis output.
this information can potentially be used by other static analyses and their clients e.g.
testing debugging security analysis and profiling .
c. builders extenders and notifications several categories of api calls are related to builders extenders and notifications created from them.
the subset of api calls relevant for our purposes is captured by the following definitions for the abstract syntax of statements s s x addaction y z x setaction y z x extend y z x build y notify x adding actions.
abstract operation addaction represents an api call that adds an action to a wearable extender and thus to wearable specific notifications created with the help of this extender.
parameter yrefers to the extender while zrefers to the action being added.
the return value of addaction is a reference to the updated extender i.e.
xandyare aliases .
to express the semantics we generalize the heap with an artificial field weactions for extenders we wearextender heap ... wearextender weactions action the field stores the sequence of actions that have been added to the extender.
the semantic effects are angbracketleftx addaction y z h angbracketright angbracketleft h angbracketright where denotes concatenation.
operation addaction can also be applied to a notification builder.
the modeling is similar using an artificial field nbactions for builder objects.
default action.
a notification builder can have a default wearable specific action open on phone as illustrated in the running example.
if setcontentintent is called on a builder line in figure this implicitly creates such a default action and associates it with the builder.
we model these effects using an abstract operation x setaction y z whereyrefers to a builder and zrefers to the action.
a field default stores this association heap ... notifbuilder default action the semantics of setaction is to map h y default to z and to copy the value of ytox.extending a builder .
abstract operation x extend y z takes as input a notification builder referenced by yand a wearable extender referenced by z. the return value is a reference to the same builder object.
when extend is executed a snapshot of the current state of the extender is stored inside the builder.
in our definitions this can be modeled by copying the action list of the extender to the builder.
thus we introduce a field weactions in the builder and set h y weactions to have the value of h z weactions .
building notifications.
an operation x build y uses the state of the builder referenced by yto create and initialize a notification object no notif .
local variable xis assigned a reference to no.
a key property of the object state is the list of actions which requires the following heap extension heap ... notif actions action given nb y the actions for the new notification are defined as follows.
if weactions innb is not empty the new notification s actions field is set to be h nb weactions h nb default .
however if weactions is empty actions is set toh nb nbactions h nb default .
this behavior corresponds to two scenarios.
first if nb was extended by an extender with a non empty action list these actions are the ones shown on the wearable followed by nb s default action .
it is also possible for an extender to provide no actions but rather to set other options e.g.
the display style.
in this case the wearable displays the actions added directly to the builder.
in addition a pre defined block app action is added at the end of the action list to allow blocking of further notifications.
figure illustrates the resulting sequence of actions.
d. actions and intents to model api calls related to intents pending intents and actions we define the following abstract syntax s x buildpending y x buildaction y operation buildpending abstracts api calls that build a pending intent wrapped around a regular intent referenced by y as illustrated at lines and in figure .
the pending intent can be used when a new action object is created in the second production yrefers to this pending intent.
operation buildaction represents two cases a construction call in anew action expression and the use of an action builder as illustrated at lines and in figure .
similarly to how notification builders create notifications action builders can create actions.
for simplicity we elide the relevant details but our implementation handles both cases.
regardless of how an action object is created part of its internal state is a pending intent.
we need heap generalizations heap ... pendingintent intent intent action pending pendingintent the semantics of buildpending andbuildaction is as expected and is not shown in detail.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
e. nested pages each notification object displays a main notification page.
sometimes additional information is displayed on nested pages accessible when the user swipes to the left.
such pages can be added by creating additional notification objects and attaching them to the main notification object.
notification chatpage in figure is an example of a nested page.
the abstract syntax is s x addpage y z where yrefers to a wearable extender and zrefers to the nested notification object.
the sequence of pages added to an extender can be represented by a field pages heap ... wearextender pages notif h y pages is updated by appending z in addition yis copied into x. we also need to generalize builders and notifications with similar fields pages .
the semantics of extend andbuild includes the copying of the value of pages to a builder or a notification respectively.
two additional aspects of the semantics should be noted.
first suppose that a notification no contains a nested page no prime.
even though no primemay have its own actions they do not affect the actions for no.
in other words h no actions is independent of h no pages .
second when no is actually displayed on the wearable device repeated swiping to the left will first show the sequence of its nested pages and then the sequence of its actions.
this behavior is illustrated by figure .
iv .
s t a tic analysis this section describes a static analysis that models the propagation of notification related objects and determines important relationships between them.
a similar referencepropagation problem for plain java can be solved using a constraint graph .
a graph node corresponds to a variable x var a field f field or an allocation newc.
edges encode constraints on values.
for example assignment x y is represented by an edge y x showing that the set of values foryis a subset of the set of values for x. forward reachability from newcdetermines which variables and fields refer to the cinstances.
such an analysis is classified as a flow insensitive context insensitive field based reference analysis .
our analysis for aw apps generalizes this approach.
v arious precision extensions can be defined e.g.
and can be combined with our aw specific analysis.
the conceptual input to the analysis is a program representation based on the abstracted semantics presented earlier.
figure shows this representation for the running example.
the analysis implementation works on the three address jimple representation from the soot analysis framework and conceptually maps call statements to these abstract operations.
a. constraint graph operation nodes.
in addition to the standard constraint graph nodes listed above we use a set op of operation nodes.
the abstract operations defined in the previous section are represented by such nodes.
for x op y the corresponding nodenhas an incoming edge from the node for variable y 1builder a new builder 2intent b new intent mainactivity.
class 3pendingintent c buildpending b 4wearableextender d new wearableextender 5builder e new builder 6notification f e.build 7addpage d f 8intent g new intent remotemessagingreceiver.
class 9pendingintent h buildpending g 10action i buildaction h 11addaction d i 12intent j new intent markreadreceiver.
class 13pendingintent k buildpending j 14action l buildaction k 15addaction d l 16action m buildaction c 17builder n setaction a m 18extend n d 19notification o build a 20notify o fig.
.
abstracted program representation.
builder1 a setaction17 build19b buildpending3 intent2 c buildaction16 wearableextender4 d addpage7 addaction11 addaction15 extend18builder5 e build6 fintent8 g buildpending9 h buildaction10 iintent12 j buildpending13 k buildaction14 lm n o notify20 fig.
.
constraint graph for the running example.
and an outgoing edge to the node for x. if the operation has two parameters there is a second incoming edge.
figure shows the constraint graph for the running example.
numeric suffixes correspond to line numbers in figure .
object creation.
node sets nb we in bn bp and ba represent objects created by program statements.
let nb be the set of allocation nodes corresponding to new expressions for notification builders e.g.
nodes builder2 andbuilder5 in figure .
similarly let we be the set of nodes for wearable extender new expressions and inbe the similar set for intents.
in addition to new expressions operation nodes may create new objects.
a notification is created with x build y .
each such operation corresponds to a constraint graph node n bn op.
in the example bn build6 build19 .
similarly x buildpending y creates a pending intent and is represented by a node n bp op.
finally action objects can be created either with new expressions or with build calls on action builders.
both cases are abstracted with x buildaction y for which we have a node n ba op.
in the example ba contains three buildaction nodes.
b. constraint based analysis we define the analysis in terms of several relations.
these relations are described in declarative fashion using inference rules.
later we describe how the relations are computed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the flow of object