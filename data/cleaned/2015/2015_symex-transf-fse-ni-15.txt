targeted program transformations for symbolic execution cristian cadar imperial college london c.cadar imperial.ac.uk abstract semantics preserving program transformations such as refactorings and optimisations can have a signi cant impact on the e ectiveness of symbolic execution testing and analysis.
furthermore semantics preserving transformations that increase the performance of native execution can in fact decrease the scalability of symbolic execution.
similarly semantics altering transformations such as type changes and object size modi cations can often lead to substantial improvements in the testing e ectiveness achieved by symbolic execution in the original program.
as a result we argue that one should treat program transformations as rst class ingredients of scalable symbolic execution alongside widely accepted aspects such as search heuristics and constraint solving optimisations.
first we propose to understand the impact of existing program transformations on symbolic execution to increase scalability and improve experimental design and reproducibility.
second we argue for the design of testability transformations speci cally targeted toward more scalable symbolic execution.
categories and subject descriptors d. .
symbolic execution keywords testability transformations dynamic symbolic execution .
background dynamic symbolic execution dse has gained tremendous popularity in the last decade becoming part of the standard toolbox of techniques in many computer science elds including software engineering programming languages software testing veri cation security and computer systems.
the technique has enabled a wide range of applications including automatic detection of bugs and security vulnerabilities recovery of corrupt documents patch generation and automatic debugging among many others.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy copyright is held by the owner author.
publication rights licensed to acm.
acm ... .
a high level dse is a program analysis technique that allows the automatic exploration of paths in a program.
it works by executing the program on a symbolic input which is initially unconstrained.
as the program runs any operations that depend on the symbolic input add constraints on the input.
for example if the program input is represented by variable x than the statement y x would add the constraint that y x .
most importantly whenever a branch that depends directly or indirectly on the symbolic input is reached the technique rst checks if both sides of the branch are feasible and if so it forks execution and follows each side separately adding the constraint that the branch condition is true on the then side and false on the else side.
for example given the symbolic input x the symbolic execution of the branch if x would result in two paths being explored one on which x and one on which x6 .
there are two main challenges in dse path explosion and constraint solving.
in all but the smallest programs the number of paths is extremely large being typically at least exponential in the number of static branches in the code.
in the presence of loops path explosion gets even worse as a loop with niterations having inside a branch that depends on the symbolic input can spawn up to 2npaths.
existing research has proposed a range of solutions such as search heuristics redundant path elimination function summaries and path merging.
while these solutions have made the approach practical for several types of applications path explosion still represents an important challenge in dse.
the second main challenge is related to constraint solving.
the problem is compounded by two factors rst dse can generate large expensive constraints and second dse issues a constraint solving query at every single branch that depends on a symbolic value to determine the feasibility of each side of the branch.
despite signi cant progress in constraint solving technology during the recent years constraint solving continues to be one of the main bottlenecks of dse and it is absolutely essential for the success of dse to devise e ective techniques that target the kind of constraints generated during symbolic execution.
.
targeted program transformations for symbolic execution we believe that the scalability of dynamic symbolic execution can be improved via targeted program transformations referred in literature as testability transformations .
the rst insight is that semantically equivalent programs can di er substantially with respect to the e ectiveness ofintgetvalue intk f return k k k g precond k intfoo unsigned k f if get value k 100000jj getvalue k return else return g a intvalues f0 ... g precond k intfoo unsigned k f if values 100000jj values return else return g b figure the c code in a is transformed into the code in b using a precomputed lookup table.
dse to explore the program state space.
these di erences can be signi cant as we are going to show below simple semantics preserving transformations can lead to orders of magnitude di erence in performance.
the second insight is that semantics altering transformations can also substantially improve the performance of symbolic execution and the quality of testing of the original program.
.
semantics preserving transformations one might be initially surprised to nd out that the scalability of symbolic execution testing can vary dramatically across semantically equivalent programs.
furthermore it can be even more unexpected that transformations that increase the performance of native execution can in fact decrease the scalability of symbolic execution.
however this is exactly what often happens in practice requiring us to rethink the type of transformations that should be applied in a dse context and to consider the opportunity of designing transformations that are targeted toward more scalable symbolic execution.
program transformations can have an impact on both constraint solving and path exploration.
below we give a couple of examples in each category.
transformations a ecting constraint solving.
to illustrate the potential impact of program transformations on constraint solving consider the function foo in figure 1a which we assume is called with an argument between inclusive and exclusive .
in turn foo calls get value twice.
if foo is called many di erent times then precomputing the result of get value can lead to signi cant performance gains.
assume the developer handoptimised the function into the code of figure 1b.
while this speeds up native execution the performance of dse drops signi cantly.
for example running fooa single time with the symbolic executor klee1by treating its integer argument as symbolic takes 2seconds2for the code in figure 1a and 50seconds for the code in figure 1b which represents a 250times slowdown!
the reason is that without the optimisation the constraint solver has to deal with satis ability queries of the form k k k while with the optimisation it has to deal with queries of the form 1klee is a state of the art dynamic symbolic execution engine based on the llvm compiler infrastructure.
it is available as open source at 2on an intel r core tm duo cpu e8400 at .00ghz with 8gb ram using klee based on llvm .
.
values values values the latter creating a much larger formula in the solver.
in our experience dse often struggles with large tables of constants and one way to deal with this problem would be to reverse such precomputed lookup table optimisations.
in other words a dse friendly testability transformation for code fragments involving large constant tables would be to replace them with mathematical formulas.
for example a simple polynomial interpolation method might often be successful.
as a second example consider common optimisations performed by modern compilers such as constant folding dead store elimination inline expansion loop ssion loopinvariant code motion loop unrolling and test reordering.
while many compiler optimisations do help symbolic execution and our tool klee implements various compilerstyle optimisations in order to improve performance surprisingly some compiler optimisations that signi cantly improve native program performance can in fact signi cantly hurt the symbolic execution of a program .
for example the code in figure 2a is optimised via strength reduction into the code in figure 2b.
the strength reduction optimisation aims to replace expensive operations such as multiplication with less expensive ones such as addition.
in this example the multiplication of the loop index is replaced with addition by using the auxiliary variable k. while this optimisation does result in faster native code the performance of dse degrades signi cantly.
treating variable cas the symbolic input the code in figure 2a takes 2seconds to run with klee while the code in figure 2b takes 20minutes which represents a times slowdown!
the reason is that the latter constructs very large chains of addition operations which are much more expensive for the underlying constraint solver than multiplications by a constant.
therefore a dsefriendly testability transformation would be the reverse of strength reduction called induction variable substitution and typically applied in order to parallelise loops.
transformations a ecting path exploration.
program transformations could also have a signi cant e ect on path exploration.
as a rst example consider the code in figure which involves a switch statement and which has a division by zero bug for x6 and y .
aswitch statement is a higher level programming language construct and most dse tools would rst transform it into lower level constructs or allow an external compiler to do so .
the way in which theswitch statement is transformed has a signi cant in u intfoo intc f inty i for i i i f y c i if y printf yes n else printf no n g g a intfoo intc f inty i intk for i i i f y k k k c if y printf yes n else printf no n g g b figure the c code in a is transformed via strength reduction into the code in b .
conversely the code in b is transformed via induction variable substitution into the code in a .
ence on the path exploration and the ability to nd the bug.
for instance if the transformation employs a binary search algorithm on the switch expression range klee con gured to use breadth rst search bfs takes .
seconds to hit the division by zero bug.
by contrast if the transformation creates a linear chain of ifstatements then klee does not nd the bug within a time limit of one hour.
while this result is unsurprising if we think about the structure of the resulting controlow graph it shows that program transformations can have an important impact on path exploration in dse and symbolic execution tools could use them to their advantage.
for example if a broad exploration of the search space is desired then one should use bfs and transform switch statements using binary search.
as a second simple example consider the code in figure which counts the number of positive numbers in an array of ten elements and reports success if all of them are positive.
compiling this program with llvm using optimisation ag o0results in paths explored by klee taking a total of seconds.
however compiling this program with llvm using optimisation ag o2results in only two paths being explored in .
seconds.
the reason is that the o2optimisations transform the branch inside the loop into a select operation count select a count count which klee sends directly to the constraint solver without having to fork.
in essence the optimisation has merged the paths inside the loop!
transformations involving switch and select statements are not the only examples other program transformations such as those splitting or merging loops are likely to have a similar e ect on path exploration and should be treated as another mechanism to improve program exploration similarly to how search heuristics are designed.
as a nal example applicable to both constraint solving and path exploration consider running dse with the same settings e.g.
search heuristics on di erent versions of the same program the original source code the code compiled to an intermediate language the x86 binary the source code raised from the binary etc.
while all these programs are semantically equivalent the performance of dse can vary signi cantly thinking about these versions in terms of semantics preserving program transformations might provide a better understanding of the tradeo s involved in operating at di erent levels of abstraction.intexpensive intx f intbits i for i i i if x i bits return bits g intfoo intx inty f switch x f case return expensive y case return expensive y case return expensive y case return expensive y default return x y g g figure example showing the impact of switch transformations on dse.
.
semantics altering transformations as argued in prior work program transformations that do not preserve the semantics of the program can nevertheless improve the testing of the original program.
in the context of symbolic execution this can be an e ective mechanism for improving its scalability.
one example are transformations whose main goal is to reduce the scope of the analysis to a subset of the allowable program behaviours.
as a rst example consider a program that uses oating point numbers.
most dse engines cannot handle symbolic oating point computations mainly due to the poor scalability of oating point constraint solvers .
a possible testability transformation would be to replace all oating point variables with integers or rational numbers allowing dse to make progress while exploring a limited subset of behaviours.
of course testing a subset of program behaviours is better than not being able to test a program at all and in practice it may often be enough to discover important errors or cover interesting parts of the code.
note also that such a transformation would not strictly explore a subset of possible behaviours due to di erences in the arithmetic over ow behaviour between oating point numbers and integers rationals some infeasible executions might beintfoo inta f intcount i for i i i if a count if count printf success n return count g figure example showing the impact of compiler optimisations of path exploration.
introduced.
but this might be easily tolerable in practice especially since dse has the ability to generate concrete test inputs which for example could be rerun to con rm any reported bugs.
as a second example one could automatically shrink large bu ers that pose scalability challenges in dse or assign concrete values to parts of a symbolic input.
such testability transformations are often performed manually by dse testers but could be easily automated.
.
envisaged impact targeted program transformations can have a signi cant impact on symbolic execution.
first they can lead to increased scalability while the examples in this paper are toy programs they illustrate well the way in which testability transformations could help address the two main challenges of dse namely speed up constraint solving and improve path exploration.
second they can improve experimental design and reproducibility of results as program transformations are often implicitly performed by the compiler or the analysis framework.
this potential confounding factor is almost always overlooked during experimental design rendering comparisons across projects di cult to assess.
for example starting with the same source code and using the same algorithmic settings a tool running on top of cil3 such as exe and one running on top of llvm4 such as klee can perform very di erently simply because cil and llvm apply di erent transformations to the original program code.
even more the same tool with the same settings but using two di erent versions of the underlying compiler say klee on top of llvm .
and klee on top of llvm .
can result in widely di erent behaviour simply because the different compiler versions perform a slightly di erent set of optimisations!
.
related work this paper is inspired by the author s experience with the signi cant variations in klee s performance when changing llvm versions or refactoring the code under analysis this has also been reported by other klee users.
recent work by wagner et al.
and dong et al.
more rigorously showed that compiler optimisations can in uence dse performance.
particular wagner et al.
argued for and designed a series of compiler optimisations focusing on improving path exploration in dse.
in this paper we provide additional evidence of the e ect of semantics preserving trasformations including compiler optimisations on both path exploration and constraint solving and go beyond semantics preserving optimisations to also look at semantics altering ones.
the idea of using program transformations to improve testability was rst introduced by harman et al.
in the context of search based software testing.
for example in evolutionary testing boolean ags involved in branch predicates induce two plateaux on the search space making evolutionary testing no better than random testing an e ective solution to this problem is to perform a program transformation that replaces the ag variable with the expression that was used to compute it.
.
conclusion this paper argues for treating program transformations as rst class ingredients of symbolic execution alongside widely accepted aspects such as constraint solving and search heuristics.
program transformations occur in many di erent forms e.g.
refactorings manual optimisations translation into intermediate languages and compiler optimisations and can have a signi cant impact on the performance of dse.
understanding existing optimisations can allow developers to disable the ones that hurt scalability and enable the ones that increase it as well as to improve experimental design and reproducibility.
furthermore we believe that the design of dse friendly testability transformations can have the potential of becoming an important ingredient of scalable symbolic execution testing and analysis.