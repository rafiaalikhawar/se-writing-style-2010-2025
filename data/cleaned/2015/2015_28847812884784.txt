double take fast and precise error detection via evidence based dynamic analysis t ongping liu dept.
of computer science university of t exas at san antonio san antonio tx t ongping.liu utsa.educharlie curtsinger dept.
of computer science grinnell college 8th ave. grinnell ia curtsinger grinnell.eduemery d. berger college of information and computer sciences university of massachusetts amherst amherst ma emery cs.umass.edu abstract programs written in unsafe languages like c and c often suffer from errors like buffer overflows dangling pointers and memoryleaks.
dynamic analysis tools like v algrind can detect these errors but their overhead primarily due to the cost of instrumenting every memory read and write makes them too heavyweight foruse in deployed applications and makes testing with them painfullyslow.
the result is that much deployed software remains susceptible to these bugs which are notoriously difficult to track down.
this paper presents evidence based dynamic analysis an approach that enables these analyses while imposing minimal overhead under making it practical for the first time to performthese analyses in deployed settings.
the key insight of evidencebased dynamic analysis is that for a class of errors it is possible to ensure that evidence that they happened at some point in the pastremains for later detection.
evidence based dynamic analysis al lows execution to proceed at nearly full speed until the end of an epoch e.g.
a heavyweight system call .
it then examines program state to check for evidence that an error occurred at some time dur ing that epoch.
if so it rolls back execution and re executes thecode with instrumentation activated to pinpoint the error.
we present d ouble take a prototype evidence based dynamic analysis framework.
d ouble take is practical and easy to deploy requiring neither custom hardware compiler nor operatingsystem support.
we demonstrate d ouble take s generality and efficiency by building dynamic analyses that find buffer overflows memory use after free errors and memory leaks.
our evaluation shows that d ouble take is efficient imposing under overhead on average making it the fastest such system to date.
it isalso precise d ouble take pinpoints the location of these errors to the exact line and memory addresses where they occur providing valuable debugging information to programmers.
this work was initiated and partially conducted while liu and curtsinger were phd students at the university of massachusetts amherst.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than theauthor s must be honored.
abstracting with credit is permitted.
to copy otherwise orrepublish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
icse may austin tx usa copyright held by the owner author s .
publication rights licensed to acm.isbn .
.
.
.
and subject descriptors d. .
testing and debugging debugging aids monitors tracing d. .
soft ware program v erification reliability keywords dynamic analysis software quality testing debugging leakdetection buffer overflow detection use after free detection .
introduction dynamic analysis tools are widely used to find bugs in applications.
they are popular among programmers because of their precision for many analyses they report no false positives and can pinpoint the exact location of errors down to the individualline of code.
perhaps the most prominent and widely used dynamicanalysis tool for c c binaries is v algrind .
v algrind s mostpopular use case via its default tool memcheck can find a wide range of memory errors including buffer overflows use after free errors and memory leaks.
unfortunately these dynamic analysis tools often impose significant performance overhead that precludes their use outside of testing scenarios.
an extreme example is the widely used tool v algrind.
across the spec cpu2006 benchmark suite v algrind de grades performance by almost on average geometric mean its overhead ranges from .
and .
making it often too slow to use even for testing see table .
while faster dynamic analysis frameworks exist for finding particular errors leveraging compiler support to reduce overhead they sacrifice precision while continuing to impose substantial over head that would impede their use in deployed settings.
the current state of the art google s addresssanitizer detects buffer overflows and use after free errors but slows applications by around .addresssanitizer also identifies memory leaks but only at the endof program execution which is not necessarily useful for servers orother long lived applications.
because of their overhead this class of dynamic analysis tools can generally only be used during testing.
however they are lim ited by definition to the executions that are tested prior to deploy ment.
even exhaustive testing regimes will inevitably fail to uncover these errors which are notoriously difficult to debug.
this paper presents an approach called evidence based dynamic analysis that is based on the following key insight it is often possible to discover evidence that an error occurred or plant markers that ensure that such evidence exists.
by combining evidence placement with checkpointing and infrequent checking we can run app2016 ieee acm 38th ieee international conference on software engineering plications at nearly full speed in the common case no errors .
if we find an error we can use the checkpoint to roll back and reexecute the program with instrumentation activated to pinpoint the exact cause of the error.
certain errors including the ones we describe here naturally exhibit a monotonicity property when an error occurs evidence that it happened tends to remain or even grow so that it can be discovered at a later point during execution.
when this evidence is not naturally occurring or not naturally monotonic it can be forced toexhibit this property by planting what we call tripwires to ensure later detection.
a canonical example of such a tripwire is a random canary value placed in unallocated space between heap objects .
a corrupted canary is incontrovertible evidence that a buffer overflow occurred at some time in the past.
this paper presents a prototype evidence based dynamic analysis framework called d ouble take that locates such errors with extremely low overhead and no false positives.
d ouble take checkpoints program state and performs most of its error analysesonly at epoch boundaries what we call irrevocable system calls orwhen segfaults occur these occur relatively infrequently amortizing d ouble take s overhead.
if d ouble take finds evidence of an error at an epoch boundary or after a segmentation violation it re executes the application from the most recent checkpoint.
during re execution d ouble take enables instrumentation to let it precisely locate the source of the error.
for example for buffer overflows d ouble take sets hardware watchpoints on the tripwire memory locations that werefound to be corrupted.
during re execution d ouble take pinpoints exactly the point where the buffer overflow occurred.
we have implemented d ouble take as a drop in library that can be linked directly with the application without the need tomodify code or even recompile the program.
d ouble take works without the need for custom hardware compiler or os support.
using d ouble take as a framework we have built three different analyses that attack three of the most salient problems forunsafe code a buffer overflow detector as described above ause after free detector and a memory leak detector.
these anal yses can all run concurrently.
by virtue of being evidence based they have a zero false positive rate precisely pinpoint the error location and operate with extremely low overhead for example with d ouble take buffer overflow analysis alone operates with virtually no overhead.
when all three of these analyses are enabled double take s average overhead is under .
for all of the analyses we have implemented d ouble take is the fastest detector of these errors to date providing compellingevidence for the promise of evidence based dynamic analyses.
itsoverhead is already low enough to dramatically speed testing and often low enough to enable the use of these formerly prohibitive analyses in deployed settings.
this work thus promises to signifi cantly extend the reach of dynamic analyses.
contributions the contributions of this paper are the following .
it introduces evidence based dynamic analysis a new analysis technique that combines checkpointing with evidence gathering and instrumented replay to enable precise error detection with extremely low overhead.
.
it presents d ouble take a prototype framework that implements evidence based dynamic analyses for c c pro grams each of the analyses we have built using d ouble take detecting buffer overflows use after frees and memory leaks are the fastest reported to date.
figure overview of d ouble take in action execution is divided into epochs at the boundary of irrevocable system calls.each epoch begins by taking a snapshot of program state.
exe cution runs at nearly full speed during epochs.
evidence based analysis takes place once an epoch ends replaying execution from the previous snapshot until it pinpoints the exact locationwhere the error is introduced.
relatively long epochs amortizethe cost of snapshots and analysis keeping overhead low.
outline this paper first provides an overview of the basic operation of double take in section .
section details the dynamic analyses we have built using d ouble take .
section describes key implementation details.
section evaluates d ouble take s effectiveness performance and memory overhead and compares theseto the state of the art.
section describes how users can add new analyses to d ouble take and discusses limitations of evidencebased analysis and the detectors implemented to date.
section describes key related work and section concludes.
.
overview double take is an efficient dynamic analysis framework for a class of errors that exhibit or can be forced to exhibit a monotonicityproperty evidence of the error is persistent and can be gathered after the fact.
with d ouble take program execution is divided into epochs during which execution proceeds at full speed fig ure .
at the beginning of an epoch d ouble take checkpoints program state.
epochs end only when the application issues an irrevocable system call e.g.
a socket read most system calls are not irrevocable see section .
for full details .
once an epoch ends double take checks the program state for evidence of memory errors.
because epochs are relatively long lived the cost of check pointing and error analysis is amortized over program execution.if d ouble take finds an error it re executes code executed from the previous epoch with additional instrumentation to pinpoint theexact cause of the error.
to demonstrate d ouble take s effectiveness we have implemented detection tools for three of the most important classes oferrors in c and c code heap buffer overflows use after free er rors and memory leaks section describes these in detail .
all detection tools share the following core infrastructure that d ouble take provides.
.
efficient recording at the beginning of every epoch d ouble take saves a snapshot of program registers and all writable memory.
an epoch ends when the program attempts to issue an irrevocable system call butmost system calls do not end the current epoch.
d ouble take also records a small amount of system state at the beginning of each epoch e.g.
file offsets which lets it unroll the effect of sys912tem calls that modify this state when re execution is required.
during execution d ouble take manages various types of system calls in an effort to reduce the number of epochs which section .
discusses.
in practice d ouble take limits the number of epoch boundaries amortizing the cost of program state checks.
thekind of checks employed depend on the particular dynamic analy sis being performed section describes the details of the analyses we have built on top of d ouble take .
.
lightweight replay when program state checks indicate that an error occurred during the current epoch d ouble take replays execution from the last checkpoint to pinpoint the error s root cause.
d ouble take ensures that all program visible state including system call results and memory allocations and deallocations is identical to the original run.
during replay d ouble take returns cached return values for most system calls with special handling for some cases.
section describes in detail how d ouble take records and reexecutes system calls.
.
deterministic memory management and tripwire support to be able to find the exact location of errors d ouble take requires that the replayed sequence of memory addresses gener ated by the underlying heap allocator be identical to the recorded sequence.
that is the allocator must be deterministic given the same sequence of malloc andfree requests it must provide the same addresses for allocated objects.
d ouble take relies on this determinism to be able to place instrumentation at the locations of compromised tripwires.
unfortunately current system supplied memory allocators are non deterministic they are not guaranteed to provide the samesequence of object addresses.
these allocators grow the heap ondemand by invoking mmap or a similar call on other operating systems to obtain memory from the system.
however becauseof address space layout randomization now implemented on allmodern operating systems to increase security mmap almost always returns different addresses when invoked.
this effect meansthat heap addresses in a replayed execution would likely differ from the original.
d ouble take therefore replaces the default heap allocator with a custom deterministic heap built with the h eap layers framework .
in addition to providing repeatable sequences of ad dresses d ouble take s heap provides a number of other useful features that improve d ouble take s efficiency and simplify building analyses using it efficiency via large chunk allocation.
the d ouble take heap obtains memory from the operating system in large chunks and satisfies all memory allocations from them reducing thenumber of system calls that d ouble take must track and thus lowering its overhead.
simplified tripwire installation.
double take s heap also makes the process of implanting tripwires easier.
for exam ple detection tools can easily interpose on heap operations toalter memory allocation requests or defer the reuse of freedmemory and can mark the status of each object in metadata e.g.
via a dedicated object header that the heap provides for this purpose .
efficient tripwire checking.
finally d ouble take s heap makes tripwire checking far more efficient.
it maintains a shadow bitmap to identify the locations and status of heap figure heap organization used to provide evidence of buffer overflow errors.
object headers and unrequested space withinallocated objects are filled with canaries a corrupted canary indicates an overflow occurred.
canaries which allows it to use vectorized bit operations toperform efficient checking at the end of each epoch.
section .
presents full details of d ouble take s heap implementation.
.
pinpointing error locations during replay d ouble take lets detection tools set hardware watchpoints during re execution to pinpoint error locations i.e.
on an overwritten canary .
modern architectures make availablea small number of watchpoints four on x86 .
each watchpoint can be configured to pause program execution when a specific byteor word of memory is accessed.
while watchpoints are primarilyused by debuggers d ouble take uses them to speed error location during re execution.
double take s watchpoints are particularly useful in combination with heap canaries.
for example during re execution d ouble take s buffer overflow and use after free detectors place a watchpoint at the location of the overwritten canary to trap the instruction s responsible for the error.
.
analyses to demonstrate d ouble take s generality and efficiency we implement a range of error detection tools as evidence based dynamic analyses.
in particular we implement the following threedetection tools with d ouble take heap buffer overflow detection .
when an application writes outside the bounds of an allocated object use after free detection .
when an application writes to freed memory i.e.
through a dangling pointer and memory leak detection .
when a heap object becomes inaccessible but has not been explicitly freed.
for each of these tools we describe the evidence that d ouble take observes or places to detect these errors and how reexecution and error isolation proceeds once an error is detected.note that because these analyses are orthogonal they can all beused simultaneously.
.
heap buffer overflow detection heap buffer overflows occur when programs write outside the bounds of an allocated object.
d ouble take reports an error when it discovers that a canary value has been overwritten.
when it findsan overwritten canary the detector places watchpoints during reexecution to identify the instruction responsible for the overflow.
evidence based error detection figure presents an overview of the approach used to locate buffer overflows.
our buffer overflow detector places canaries between figure evidence based detection of dangling pointer useafter free errors.
freed objects are deferred in a quarantinein fifo order and filled with canaries.
a corrupted canaryindicates that a write was performed after an object was freed.
heap objects so that an overflow from one object into an adjacent one can be detected.
in addition the overflow detector fills any remaining empty space inside allocated objects with canaries d ouble take s allocator rounds all object size requests up to the nearest power of two.
thisapproach lets d ouble take identify small overflows that would otherwise be missed because they did not actually go beyond theobject s allocated space these overflows are typically missed by existing tools.
at memory deallocation time calls to free ordelete d ouble take checks for buffer overflows in objects whose requested size is less than a power of two.
it defers the checking of power of two sized objects to the end of the current epoch.
at the end of each epoch d ouble take checks whether any canaries have been overwritten including those for exact powerof two requests .
if it finds any overwritten canaries it has incon trovertible evidence that a buffer overflow has occurred.
d ouble take then triggers a re execution to locate the exact point in the program when the overflow happened.
re execution and error isolation double take installs a watchpoint at the address of the corrupted canary before re execution.
when the program is re executed anyinstruction that writes to this address will trigger the watchpoint.the operating system will deliver a sigtrap signal to d ouble take before the instruction is executed.
by handling this signal double take reports the complete call stack of the trapped instruction by invoking the backtrace function.
.
use after free detection use after free or dangling pointer overflow errors occur when an application continues to access memory through pointers thathave been passed to free ordelete.
writes to freed memory can overwrite the contents of other live objects leading to unexpectedprogram behavior.
like the buffer overflow detector our use afterfree detector uses canaries to detect writes to freed memory.
when a use after free error is detected d ouble take reports the allocation and deallocation sites of the object and all instruction s thatwrote to the object after it was freed.
evidence based error detection figure illustrates how we detect use after free errors using d ouble take .
our use after free detector delays the re allocation of freed memory.
we adopt the approach used by addresssanitizerof maintaining a fifo quarantine list .
in our implementation objects are released from the quarantine list when the total size ofquarantined objects exceeds megabytes or when there are morethan quarantined objects.
note that all thresholds used by the detector are easily configurable.
the detector overwrites the first bytes of all objects in the quarantine list which have all been freed by the program with canary values.
this threshold strikes a compromise between error detection and efficiency.
we have found empirically that filling largerobjects with canaries i.e.
going beyond bytes to the full sizeof allocated objects introduces substantial overhead during normal execution but is unlikely to catch any additional errors.
this is be cause large objects often consist of a header followed by a buffer.
a prematurely reused object is likely to have its prologue scrambled by a constructor while the remainder of the object the buffercontents may remain unmodified for a long time.
before an object can be returned to the program heap d ouble take verifies that no canaries have been overwritten.
it also checks all canaries in the entire heap at epoch boundaries.
in either case ifa canary has been overwritten the detector knows that a use after free error has occurred.
it then immediately triggers re executionto identify the cause of this error.
re execution and error isolation during re execution the use after free detector interposes on malloc andfree calls to find the allocation and deallocation sites of the overwritten object.
the detector records a call stack for both sitesusing the backtrace function.
the detector also installs a watchpoint at the address of the overwritten canary.
as with buffer overflow detection any writes to the watched address will generate a sigtrap signal.
when this signal is triggered the detector reports information about the object s allocation and deallocation sites aswell as call stack and line number information for the instructions responsible for the use after free error.
.
memory leak detection heap memory is leaked when it becomes inaccessible without being freed.
memory leaks can significantly degrade program performance due to an increased memory footprint.
our leak detector identifies possible unreachable allocated objects at the end of each epoch.
allocation sites can help users fix memory leaks butcollecting this information for allmalloc calls in normal execution would unnecessarily slow down the program for the common case no memory leaks .
instead d ouble take only records the allocation sites of leaked memory during re execution and adds no overhead for normal execution.
evidence based error detection unlike the previously described detectors memory leak detectiondoes not need tripwires.
instead the evidence of a memory leak is latent in the heap organization itself.
our detector finds memory leaks using the same marking approach as conservative garbage collection .
the marking phase performs a breadth first scan of reachable memory using a workqueue.
initially all values in registers globals and the stack that look like pointers are added to the work queue.
any eight byte aligned value that falls within the range of allocated heap memoryis treated as a pointer.
at each step in the scan the detector takes the first item off the work queue.
using the heap metadata located before each object the detector finds the bounds of each object.
each object has aheader containing a marked bit and an allocated bit.
if the marked bit is set this object has already been visited.
the detector thenremoves this object and moves on to the next item in the queue.
if the object is allocated but not yet marked the detector marks it as reachable by setting the marked bit and adds all pointer values within the object s bounds to the work queue.
once the work queueis empty d ouble take ends its scan.
914double take then traverses the entire heap to find any leaked objects these are allocated but unmarked unreachable .
if it finds memory leaks re execution begins.
note that using this approach our detector can also find potential dangling pointers that is reach able freed objects .
this option is disabled by default because un like other applications potential dangling pointer detection couldproduce false positives.
re execution and error isolation during re execution the leak detector checks the results of eachmalloc call.
when the allocation of a leaked object is found the detector records the call stack using the backtrace function.
at the end of the epoch re execution the detector reports the last callstack for each leaked object since the last site is responsible for thememory leak.
.
implementation details double take is implemented as a library for linux applications.
it can be linked directly or at runtime using the ld preload mechanism.
d ouble take is thus convenient to use there is no need to change or recompile applications to use a specialized hard ware platform run inside a virtual machine or modify the os.
at startup d ouble take begins the first epoch.
this epoch continues until the program issues an irrevocable system call see section .
for details .
before an irrevocable system call d ouble take checks program state for evidence of errors.
the details are presented in section .
if no errors are found d ouble take ends the current epoch issues the irrevocable system call and begins a new epoch.
ifit finds evidence of an error d ouble take enters re execution mode.
d ouble take will then re execute with instrumentation activated and report the lines of code responsible for the error s .
the remainder of this section describes the implementation of double take s core functionality.
.
startup and shutdown at program startup d ouble take performs initialization and starts the first epoch.
d ouble take needs to get in early to interpose on system calls and install its own heap implementation.
it accomplishes this by marking its own initialization function with the constructor attribute.
since d ouble take must wrap library functions that eventually invoke with system calls as described insection .
it collects the addresses of all intercepted functionsduring this initialization phase.
d ouble take acquires memory from the os to hold its heap collects the names and ranges of allglobals by analyzing proc self maps installs signal handler for segmentation violations and prepares the data structure for record ing and handling system calls.
d ouble take must postpone the checkpointing of program state and thus the beginning of the first epoch until just before execu tion enters the application enters its main function.
this delay is necessary to let key low level startup tasks complete.
for exam ple c performs its initialization for the standard stream after the execution of constructor functions including in this case d ouble take itself .
because d ouble take relies on streams to report any errors it detects by definition it cannot start the first epoch before that point.
to make this all possible we interpose on the libc start main function and pass a custom main function implemented by d ouble take that performs a snapshot just before entering the application s real main routine.
double take treats program termination as the end of the final epoch.
as with any other epoch if it finds evidence of program er rors d ouble take re executes the program to pinpoint the exactcategory functions repeatable getpid sleep pause recordable mmap gettimeofday time clone open revocable write read deferrable close munmap irrevocable fork exec exit lseek pipe flock socket related system calls table system calls handled by d ouble take .
all unlisted system calls are conservatively treated as irrevocable and end the current epoch.
section .
describes how d ouble take handles calls in each category.
causes of errors.
this logic is embedded in a finalizer marked with the deconstructor attribute that d ouble take installs.
.
epoch start at the beginning of each epoch d ouble take takes a snapshot of program state.
d ouble take saves all writable memory stack heap and globals from the main program and any linked libraries and saves the register state of each thread with the getcontext function.
to reduce the cost of snapshots d ouble take does not checkpoint any read only memory.
to identify all writable mapped memory d ouble take processes the proc self map file which on linux identifies every mapped memory region andits attributes other operating systems implement similar function ality .
d ouble take also records the file positions of all open files which lets programs issue read andwrite system calls without ending the current epoch.
d ouble take uses the combination of saved memory state file positions and registers to rollback exe cution if it finds evidence of an error.
.
normal execution once a snapshot has been written d ouble take lets the program execute normally but interposes on heap allocations deallo cations and system calls in order to set tripwires and support re execution.
system calls double take ends each epoch when the program attempts to issue an irrevocable system call.
however most system calls cansafely be re executed or undone to enable re execution.
d ouble take divides system calls into five categories shown in table .
system calls could be intercepted using ptrace but this would add unacceptable overhead during normal execution.
in stead d ouble take interposes on all library functions that may issue system calls except those in the first category repeatable system calls do not modify system state and return the same result during normal execution and re execution.no special handling is required for these calls.
recordable system calls may return different results if they are re executed.
d ouble take records the result of these system calls during normal execution and returns the savedresult during re execution.
some recordable system calls such as mmap change the state of underlying os.
revocable system calls modify system state but d ouble take can save the original state beforehand and restore it prior to re execution.
most file i o operations fall into this 915category.
for example although write modifies file contents d ouble take can write the same content during reexecution.
the write function also changes the current file position but the file position can be restored to the saved one using lseek prior to re execution.
at the beginning of each epoch d ouble take saves all file descriptors of opened files in a hash table.
maintaining thishash table helps to identify whether a read andwrite call is operating on sockets or not because socket communications must be treated as irrevocable system calls.
in addition d ouble take must save stream contents returned by fread in order to support re execution.
deferrable system calls will irrevocably change program state but can safely be delayed until the end of the current epoch.
d ouble take delays all calls to munmap andclose and executes these system calls before starting a new epochwhen there is no need to re execute the program.
irrevocable system calls change internally visible program state and cannot be rolled back and re executed.
d ouble take ends the current epoch before these system calls.
double take reduces the number of irrevocable system calls by observing their arguments in some cases they are not neces sarily irrevocable.
for example when fcntl invoked with f get d ouble take treats it as a repeatable system call since it is simply a read of file system state.
however it treats this call as irrevocable if invoked with f set since the call then actually updates the file system.
similarly lseek is repeatable when called with theseek cur flag with offset which simply returns the current position in the file.
however lseek is irrevocable when given the arguments seek set orseek end which change the current offset of a file.
memory management as described in section .
d ouble take intercepts memory allocations and deallocations to implant tripwires identify heap corruption and facilitate re execution.
d ouble take replaces the default heap with a fixed size bibop style allocator with per thread subheaps and power of two size classes.
we built this heap usingthe h eap layers framework .
double take implants tripwires differently for different analyses.
to detect heap based buffer overflows d ouble take places canaries along with each heap object.
in order to find use after free errors d ouble take postpones the reuse of freed objects by putting them into a quarantine list and filling them with canaries.
for memory leak detection there is no need to implant tripwires because the evidence of a leak can be found without them.
to identify heap corruption d ouble take maintains a bitmap that records the locations of all heap canaries.
the bitmap recordsevery word of heap memory that contains a canary which will be checked at the end of each epoch.
if any of these words are modified d ouble take notifies the detection tool.
to speed re execution d ouble take uses its heap allocator to satisfy memory requests from the application and corresponding libraries and maintains a separate heap for internal use only.
for example the memory that d ouble take uses to record system calls results is allocated from its internal heap and there is no need toreplay these allocations during re execution.
any additional mem ory allocations during the replay phase are also satisfied from its internal heap.
.
epoch end each epoch ends when the program issues an irrevocable system call.
at the end of each epoch d ouble take checks program state for errors.
these analysis specific error checks are described in section .
the scanning process is extremely efficient check ing 512mb of program state for all of these analyses takes just milliseconds.
it also has minimal impact on latency because it is piggybacked on relatively expensive system calls.
if an error is found during the scan d ouble take rolls back execution to the immediately preceding epoch and switches to re execution mode.
if no error is found d ouble take issues any deferred system calls clears the logs for all recorded system calls and begins the next epoch.
.
rollback if an error is found d ouble take rolls back program state before re executing the epoch.
this rollback must be handled with care.
if the rollback is caused by a segmentation fault d ouble take must return from the signal handler before switching to the saved program state.
d ouble take changes the saved context to return to a custom rollback function exits the signal handler andthen initiates rollback outside the signal handler.
during rollback the saved state of all writable memory is copied back which alsorecovers the status of its heap.
restoring the saved stack can over write live values on the current program stack so d ouble take must switch to a temporary stack during the rollback phase.
d ouble take also recovers the file positions of opened files so that all read write calls can be issued normally during re execution.
double take then sets hardware watchpoints on all corrupted addresses in order to report the root causes of buffer overflows or dangling pointers.
since debug registers are not directly accessible in user mode d ouble take utilizes the perf event open call to load watched addresses into the debug registers.
d ouble take also sets a sigtrap handler for watchpoints so that it will get notified when these addresses are overwritten e.g.
during buffer overflows or uses of freed objects .
once all watchpoints have been placed d ouble take uses the setcontext call to restore register state and begin the re execution.
.
re execution during re execution d ouble take repeats all memory operations allocations deallocations and accesses while tracking precise information related to memory errors handles system callsdepending on their type and handles signals triggered by watch points.
memory operation tracking during replay d ouble take enables tracking of precise information in the memory allocator allallocations and deallocations record their calling context so thesecan be reported later if needed.
note that recording call sites during ordinary execution would be prohibitively expensive imposing overhead.
d ouble take only imposes this overhead during re execution once d ouble take has detected a memory error.
replaying system calls double take replays the saved results of recordable system calls from the log collected during normal execution while avoiding invoking actual system calls that is their execution is simulated.
all deferred system calls are convertedto no ops while the program is re executing.
d ouble take issues other types of system calls normally.
trapping on watchpoints finally d ouble take handles traps caused by accesses to watchpoints.
inside the trap handler d ouble take first determines which watchpoint caused the current trap if there are multiple watchpoints.
it also filters out any ac cesses from d ouble take itself.
d ouble take prints the call916site stack of the instruction responsible for a buffer overflow or use after free errors and their memory allocation or deallocation sites.
for memory leaks d ouble take reports the allocation callsite of the leaked object.
.
ev aluation we evaluate d ouble take to demonstrate its efficiency in terms of execution time memory overhead and effectiveness at detectingerrors.
all experiments are performed on a quiescent intel core dual processor system with 16gb of ram running on linux3.
.
generic with glibc .
.
each processor is a core bit intel xeon operating at .33ghz with a 4mb shared l2cache and a 32kb per core l1 cache.
all programs are built as 64bit executables using llvm .
with the clang front end and o2 optimizations.
all evaluations on spec cpu2006 are exercised with the ref reference input set.
.
runtime overhead we evaluate d ouble take s execution time and memory overhead across all of the c and c spec cpu2006 benchmarks 19in total.
we compare d ouble take with the previous state ofthe art tool google s addresssanitizer .
as mentioned earlier addresssanitizer can detect buffer overflows and use after free errors but it only detects memory leaks at the end of execution.
bycontrast d ouble take detects all of these errors at the end of every epoch.
in our evaluation d ouble take discovered several memory leaks which trigger rollback and error identification.
to isolatenormal execution overhead we disable d ouble take s rollback in our evaluation.
that is our runs with d ouble take incur all of the overhead of ordinary tracking including implanting of tripwires and examining state but do not measure the time to rollback and locate errors in general this cost is low and in any event doesnot affect bug free execution which is the common case.
for eachbenchmark we report the average runtime of three runs.
figure presents execution time overhead results for d ouble take and addresssanitizer.
on average d ouble take imposes only overhead with all three error detectors enabled.
when use after free detection dp is disabled d ouble take exhibits no observable overhead.
addresssanitizer has an average runtime overhead over recall that addresssanitizer only performs leak detection at the end of program execution while d ouble take performs it every epoch.
for out of benchmarks d ouble take outperforms addresssanitizer.
for benchmarks d ouble take s runtime overhead with all detectors enabled is under .
unsurprisingly both double take and addresssanitizer substantially outperform v algrind on all benchmarks.
four of the benchmarks have higher than average overhead for double take and addresssanitizer .perlbench .gcc .h264ref and .xalancbmk .
both d ouble take and addresssanitizer substantially increase these applications memoryfootprints see table .
we attribute their increased execution time to this increased memory footprint and its corresponding increased cache and tlb pressure.
d ouble take s use after free detection adds roughly runtime overhead but only gcc andh264ref run with more than overhead.
as described in section .
all freed objects are filled with canaries up to bytes .
d ouble take spends a substantial amount of time filling freed memory with canaries for applications with a large number of malloc andfree calls.
thus d ouble take runs much slower for the application gcc when the detection of use after free errors is enabled.
h264ref adds significantoverhead on d ouble take because of its large number of epochs.
table presents detailed benchmark characteristics.
the processes column shows the number of different process invocations by calling fork .
the number of epochs is significantly lower than the number of actual system calls demonstrating d ouble take s effectiveness at reducing epochs via its lightweight system call han dling.
the benchmarks with the highest overhead share the follow ing characteristics they consist of a substantial number of epochs e.g.
perlbench andh264ref or are unusually malloc intensive e.g.
gcc omnetpp and xalancbmk .
runtime overhead summary for nearly all of the benchmarks we examine d ouble take substantially outperforms the state of the art.
for most benchmarks d ouble take s runtime overhead is under .
.
memory overhead we measure program memory usage by recording the peak physical memory usage.
virtual memory consumption is generally not relevant for bit platforms.
d ouble take s pre allocated heap and internal heap consume 8gb of virtual memory space.
we compute peak physical memory usage by periodically collectingprocess level information on linux this is available in the pseudofile proc self smaps and summing the proportional set sizes of memory segments.
figure presents memory overhead for d ouble take and addresssanitizer table has full details .
on average both acrossthe benchmark suite and when broken down by footprint large 100mb and small 100mb d ouble take imposes considerably lower memory overhead than addresssanitizer.
d ouble take imposes lower memory overhead than addresssanitizer on all but three benchmarks perlbench h264 and namd.
we drill down to explore the application and analysis characteristics that contribute to d ouble take s memory overhead number of epochs much of d ouble take s memory overhead comes from the snapshot of writable memory taken atthe beginning of each epoch.
however the first snapshot isoften small because the heap is almost empty before the main routine.
for example the benchmarks bzip2 mcf sjeng milc and lbm run in a single epoch and accordingly exhibit very low memory overhead.
system call logs system call logs introduce additional memory overhead that depends on the number of recorded systemcalls.
analysis specific overhead other sources of memory overhead are analysis specific.
buffer overflow detection addscanaries between heap objects which can increase memoryusage for programs with many small allocations.
for thisanalysis d ouble take also maintains a bit map that marks the placement of canaries for each eight bytes word of theheap d ouble take adds a bit to mark whether this word has the canaries or not.
finally use after free detection addsconstant size memory overhead by delaying memory reuse.
note that any similar dynamic analyses must impose similar overheads.
memory overhead summary on average d ouble take imposes lower memory overhead than addresssanitizer.
for largefootprint applications it increases memory consumption for appli cations by on average.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
figure runtime overhead of d ouble take of buffer overflow detection ml memory leak detection dp dangling pointers detection and addresssanitizer normalized to each benchmark s original execution time.
with all detections enabled double take only introduces performance overhead on average.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
figure memory overhead of d ouble take and addresssanitizer.
.
effectiveness we evaluate the effectiveness of d ouble take on a range of applications including synthetic test cases standard benchmarks and real world applications.
synthetic test cases and benchmarks we first evaluate d ouble take on synthetic test cases test cases from the nist sama te reference dataset project.
this corpus includes caseswith buffer overflows and cases without overflows .
we alsoevaluate d ouble take on c c benchmarks from the spec cpu2006 benchmark suite.
for heap overflows d ouble take detects all known overflows in one synthetic test case and test cases of sama te suite.for the cases without overflows in sama te suite d ouble take has no false positives.
for the spec cpu2006 benchmarks double take did not find any heap buffer overflows and useafter frees which is the same result found with addresssanitizer.however d ouble take detected a significant number of memory leaks in perlbench andgcc of spec cpu2006 which we verified using v algrind s memcheck tool.
real applications we also ran d ouble take with a variety of applications with known or implanted errors see table .
to ver ify the effectiveness of d ouble take s buffer overflow detection we collected applications from evaluations of prior tools bugzilla and bugbench including bc gcc .
.
gzip libhx polymorph and vim .
.
in every case d ouble take detected all known or converted errors.
converted errors are existing global or array overflows that double take currently cannnot detect we converted these to heap overflows to verify its effectiveness.
d ouble take also identified !
!
!
!
!
!
!
!
!
figure an example report by d ouble take for buffer overflow identification.
memory leaks in gcc .
.
andvim .
which we confirmed with v algrind.
to evaluate the detection of use after free errors we manually injected errors on real applications such as vim .
lsandwc.d ouble take identified all of these memory errors.
note that the errors observed in these applications are triggered only by specific inputs.
in the common case these applications per form as expected.
this is exactly the case for which d ouble take is ideal since its low overhead is designed to make it feasible to use it in deployed settings.
detailed reporting double take reports precise information aimed at helping programmers identify the exact causes of different memory errors as shown in figure .
for buffer overflows d ouble take reports the call sites and line numbers of the overflow and the original memory allocation.
for memory leaks d ouble take reports the last call site of its memory allocation.
for useafter frees error d ouble take reports both allocation and deallocation call sites and the instruction s that wrote to the object after it was freed.
note that d ouble take can identify more errors than address918memory usage mb benchmark original address d ouble sanitizer t ake large footprint 100mb .perlbench .bzip2 .gcc .mcf .sjeng .omnetpp .astar .xalancbmk .milc .dealii .soplex .lbm geometric mean small footprint 100mb .gobmk .hmmer .libquantum .h264ref .namd .povray .sphinx3 103geometric mean overall geometric mean table addresssanitizer and d ouble take memory usage in megabytes.
the top section lists memory overhead for largefootprint applications over mb while the bottom section presents overhead for small footprint applications.
d ouble take s memory overhead is generally less than addresssanitizer s. sanitizer.
d ouble take can track up to four buffer overflows or use after free errors during the same epoch because its isolation is based on the use of hardware debugging registers.
addresssanitizer always stops at the detection of the first such error.
effectiveness summary across the applications we examine double take detects all known or injected errors with no false positives.
d ouble take is as effective at finding errors as addresssanitizer but with much lower performance and memory overhead.
it also provides more detailed reports for these errors.
.
discussion this section discusses how users of d ouble take can extend it to find other errors and describes limitations of evidence baseddynamic analyses in general and of the error detectors implementedto date.
application description loc error type bc basic calculator 12k known overflow gzip compress or expand files 5k converted overflow libhx common library 7k known overflow polymorph filename converter .4k converted overflow vim .
text editor 282k known overflow gcc .
gnu compiler collection 5784k unknown leaks vim .
text editor 282k unknown leak ls directory listing .5k implanted uaf wc word count .6k implanted uaf vim .
text editor 332k implanted uaf table error detection d ouble take detects both known injected and non injected and previously unknown errors onthe above applications any reported errors are real as d ouble take has a zero false positive rate .benchmark processes epochs syscalls mallocs .perlbench .bzip2 .gcc .mcf .gobmk .hmmer .sjeng .libquantum .h264ref .omnetpp .astar .xalancbmk .milc .namd .dealii .soplex .povray table benchmark characteristics.
.
extending double take the d ouble take framework can be extended to discover other program errors that exhibit the required monotonicity property evi dence of an error persists or can be made to persist after its occurrence.
this paper presents its use to detect heap buffer overflows use after free errors and memory leaks other potential use casesinclude invalid frees double frees and null dereferences.
to extend d ouble take to detect new errors users must implement at most three functions an optional tripwire installation function to force errors to leave evidence for later detection whenrequired a detection function that identifies when an error has occurred and a precise instrumentation function that can pinpoint the cause of an error during re execution.
.
limitations while d ouble take can effectively identify a range of important errors there are errors that remain out of its scope.
by its na ture evidence based dynamic analyses cannot detect errors if thereis no evidence that they occurred or it is not practical to force evi dence of their existence.
for example d ouble take cannot detect problems caused exclusively by memory reads which leaveno evidence that an error occurred.
evidence based analysis alsodepends on errors being generally monotonic once an error hasoccurred its evidence needs to persist until the end of the epochin order to ensure detection.
in addition d ouble take currently operates exclusively over the heap and cannot detect errors withinglobal variables or on the stack it is also currently limited to single threaded applications.
the analyses we have built using d ouble take heap buffer overflows use after free errors and memory leaks have no falsepositives but they can have false negatives.
if an overflow touchesmemory only in adjacent objects and skips over canaries d ouble take s end of epoch scan will not reveal any evidence of the overflow.
while extremely unlikely a buffer overflow or dangling pointer write that writes the exact same data as our random canary value will also escape detection.
both the buffer overflow anduse after free detectors can detect errors only on writes.
to reduceoverhead the use after free detector only places canaries in the first bytes of freed objects.
if a write to freed memory goes beyond this threshold the current detector will not find it.
the memory leak detector will not produce false positives but can yield false negatives.
the leak detector may miss leaks when adata value accidentally aliases the pointers of a leaked heap object though in practice this is unlikely especially on bit architec919valgrind execution time overhead benchmark overhead benchmark overhead .perlbench .
.sjeng .
.bzip2 .
.omnetpp .
.gcc .
.astar .
.mcf .
.milc .
.gobmk .
.namd .
.hmmer .
.dealii .
table valgrind s execution time overhead across the spec benchmark suite.
valgrind imposes on average overhead geometric mean making it prohibitively high for use in deployment and quite expensive even for testing purposes.
tures.
if a leaked object was not allocated in the current epoch double take s re execution will not be able to find the object s allocation site a limitation shared by addresssanitizer .
in practice d ouble take s epochs are long enough to collect allocation site information for all leaks detected during our evaluation.
.
related work dynamic instrumentation dynamic instrumentation based error detection tools include v algrind s memcheck tool dr. memory purify intel inspector and sun discover .these tools use dynamic instrumentation engines such as pin v al grind and dynamirio and can detect memory leaks use after free errors uninitialized reads and buffer overflows.
like d ouble take these tools are easy to use because they do not require recompilation unlike d ouble take they impose considerable overhead programs run with v algrind take longer than usual see table and dr. memory introduces runtime overhead.
d ouble take issignificantly faster than prior dynamic instrumentation tools under performance overhead .
several dynamic analysis tools leverage static analysis to reduce the amount and thus the overhead of instrumentation .
addresssanitizer represents the previous state of the art.
it relies on a compiler e.g.
llvm to instrument and opti mize away memory accesses.
during execution addresssanitizerbehaves much like d ouble take it intercepts heap allocations and deallocations to place canaries and delay the reuse of freedheap objects and reports errors such as buffer overflows or use after frees.
addresssanitizer s instrumentation lets it detect out of bound reads and overflows on stack or global variables which d ouble take does not.
however addresssanitizer cannot find errors in code that was not compiled with addresssanitizer en abled which includes most libraries d ouble take detects heap object overflows dangling pointer writes and leaks in the wholeprogram libraries included without recompilation.
addresssanitizer checks for leaked objects only during shutdown whereas d ouble take detects leaks during execution enabling leak detection in long running applications.
d ouble take introduces significantly lower overhead than addresssanitizer even though d ouble take s analysis covers library code.
checking only for illegal writes addresssanitizer incurs approximately overhead versus overhead with d ouble take .
interposition double take uses library interposition exclusively during normal execution.
more expensive instrumentation is only introduced after an error has been detected.
boundschecker interposes on windows heap library calls to detect memory leaks use after free errors and buffer overflows .
many prior ap proaches use a mix of library interposition and virtual memorytechniques to detect memory errors though their overhead is much higher than d ouble take s.record and replay several replay based approaches target software debugging and or fault tolerance .
flashback supports replay debugging by employing a shadow process to checkpoint the state of an application and recording the results of system calls to facilitate the replay.
triage uses replay to automatethe failure diagnosis process for crashing bugs .
both flash back and triage need custom kernel support.
aftersight is the related work that is closest in spirit to d ouble take .
it separates analysis from normal execution by logging inputs to a virtual machine and exporting them to a separatevirtual machine for detailed slow analysis that can run offline orconcurrently with application execution.
aftersight monitors applications running in a virtual machine which adds some amount of workload dependent overhead.
vm based recording alone adds ad ditional runtime overhead an average of on the spec cpu2006benchmarks.
aftersight s dynamic analyses are offloaded to unusedprocessors which may not be available in some deployments.
unlike aftersight d ouble take does not require the use of a virtual machine does not rely on additional processors for dynamic analyses and incurs lower average overhead.
speck is another replay based system focused on security checking including taint analysis and virus scanning .
security checksgenerally require applications to halt immediately upon detectingan error functionality that d ouble take by design does not provide.
other systems have focused on reducing the performanceoverhead of recording .
.
conclusion this paper introduces evidence based dynamic analysis a new lightweight dynamic analysis technique.
evidence based dynamicanalysis works for errors that naturally leave evidence of their oc currence or can be forced to do so.
these errors include key problems for c and c programs buffer overflows dangling pointer errors and memory leaks.
evidence based dynamic analysis is fastbecause it lets the application run at full speed until an error isdetected execution is then rolled back and replayed with instru mentation at the point where the evidence was found pinpointing the error.
we present d ouble take an evidence based dynamic analysis framework and implement these analyses using it.
the resulting analyses are the fastest to date imposing on average un der overhead.
these results demonstrate the effectiveness and efficiency of this approach which promises to speed testing and dramatically increase the reach of dynamic analysis by extendingit to deployed settings.
d ouble take is available for download at .
.