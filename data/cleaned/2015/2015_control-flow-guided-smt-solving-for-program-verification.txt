control flow guided smt solving for program verification jianhui chen school of software tsinghua university key laboratory for information system security moe beijing national research center for information science and technology beijing china chenjian16 mails.tsinghua.edu.cnfei he school of software tsinghua university key laboratory for information system security moe beijing national research center for information science and technology beijing china hefei tsinghua.edu.cn abstract satisfiability modulotheories smt solvers havebeen widely applied as the reasoning engine for diverse software analysis and verification technologies.
the efficiency of the smt solver has significanteffectsontheperformanceofthesetechnologies.however the current smt solvers are designed for the general purpose of constraint solving.
many useful knowledge of programs cannot be utilizedduringthesmtsolving.asaresult thesmtsolvermay spendalotofefforttoexploreredundantsearchspace.inthispaper we propose a novel approach for utilizing control flow knowledge in smt solving.with this technique the searchspace can be considerablyreducedandtheefficiencyofsmtsolvingisobservably improved.
we conducted extensive experiments on credible benchmarks the results show orders of magnitude improvements of our approach.
ccs concepts theory of computation logic and verification software and its engineering formal software verification keywords program verification satisfiability modulo theory control flow graph acm reference format jianhui chen and fei he.
.
control flow guided smt solving for program verification.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.
thisworkwaspartiallyfundedbythensfofchinaundergrantno.61672310and grant no.
the national science and technology major project under grant no.
2016zx01038101.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction satisfiability modulo theories smt are applied in diverse softwareengineeringtechnologies suchassoftwareverification static program analysis symbolic execution test case generation andsoon.apowerfulsmtsolverisacrucialfactor to improve the efficiency of these technologies.
however the smt solvers are designed for the general purpose of constraint solving .
domain specific knowledge cannot be efficiently utilized innowadayssmtsolvers.ontheotherhand domainknowledge may be quite useful for pruning the search space and thus improving the efficiency of smt solvers.
control flowgraph cfg isagraphrepresentationofprograms.
itissimplebutinformative.manydomainknowledgeaboutprograms is implied in this representation.
for example let be a programexecution if passesabasicblock itpassesallstatements in this block reversely if it does not pass a block all statements in that blockare notexecuted by .this isstraightforward fromthe cfg.however aftertheprogramisencodedintothesmtformula thesmt solverisunaware ofthisknowledge.moreover consider anif statement anexecutioncanneverpassbothofitsbranches.
again the smt solver is unaware of this.
as a result the smt solver may spend a lot of effort to explore redundant space which could have been pruned if the control flow knowledge is known.
onemayconsidertospecifythecontrol flowknowledgeassmt constraints.however specifyingtheseknowledgemayintroduce additional variables and thus increases the problem complexity.
we have a simpler and smarter solution.
the basic idea is to use a decisionordertoguidethesmtsolving.thedecisionorderdecides at each search step which variable should be taken for assignment.
it determines the search direction in the smt solving.
we propose toinferadecisionorderfromthecontrol flowgraphoftheprogram and then use this order to guide the search process of smt solving.
we propose two heuristics for arranging the decision order.
firstly werecognizetheimportanceofbranchingconditionsthat dominate the control flows of the program and assign the correspondingvariableshigherprioritiesinthedecisionorder.secondly we follow the domination relation of the control flow graph to arrangethe orderof branchingvariables.in thisway wepropose alightweighttechniquetoutilizecontrol flowknowledge insmt solving.
it can take full advantage of the built in features of the smt solver.
moreover we propose an enhanced cnf conversion procedure.
aftertheprogramisencodedintothesmtformula the iteterms keep the control flow information of the original program.
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianhui chen and fei he conventional approach breaks the nested structures of iteterms andthuslosethecontrol flowinformation.weproposeanew ite rewritingalgorithm withwhichthenestedstructureof itetermsis kept in some form of cnf formulas.
with our enhanced approach thegeneratedcnfcontainsfewerclausesandfewervariables.the efficiency is thus improved.
to the best of our knowledge this is the first attempt at improving smt solving by using domain knowledge of programs.
there are some works on domain knowledge guided sat solving .
in the structure information of transition systems is utilized to guide the sat solvers.
in the variable dependencyinformationofthemodelisutilizedtoguidethesat solvers.
the paper considers the iterative sat solving for boundedmodelchecking.theinformationfromthepreviousunsatisfiabilitycoreisutilizedtorefinethedecisionorderingforthe current sat instance.
all these techniques are designed for sat solvers andthedomainknowledgecomesfromthemodelchecking.
in this paper we consider smt solving for program verification.
the domain knowledge is different and the application target is also different.
werealizedaprototypeofourapproachontopofcbmcandz3.
we conducted extensive experiments on credible benchmarks.
all benchmarks are obtained from sv comp .
up to smt instancesaregenerated.experimentalresultsshowthatthecontrolflow knowledge can significantly improve the efficiency of smt solving.
the average speedup is .
times for all instances and .
times for satisfiable instances.
in summary our main contributions include weproposeanovelapproachforutilizingcontrolflowknowledge in smt solving.
this approach is lightweight and can take full advantage of the built in features of smt solvers.
weproposeanenhancedcnfconversionprocedure with which the control flowinformation can be keptin the cnf formulas.
weimplementourapproachonthetopofcbmcandz3 and conductextensive experimentsto evaluateits effectiveness andefficiency.resultsshowpromisingperformanceofour approach.
therestofthispaperisorganizedasfollows.section 2introduces somebackgroundknowledge.section 3usesasimpleexampleto motivate our approach.
section 4presents our control flow guided smtsolvingapproach.experimentsarereportedinsection r elated works are discussed in section .
finally section 7concludes this paper.
preliminaries .
notations in first order logic fol a termcan be a variable a constant or an ary function applied to nterms.
an atomis latticetop o ran ary predicate applied to nterms.
aliteralis an atom or its negation.
a fol formula is built from literals using the boolean connectives andquantifiers.aninterpretation ormodel mconsistsofanonemptysetofobjectscalledthedomainof m writtendom m amap from each variable and each constant respectively to an object and an interpretation for each function symbol and each predicate symbol respectively.
given a formula w es a y m satisfies written m i f is true in the model m. a first order theory tis defined by a signature and a set of axioms where the signature defines a set of constant function and predicatesymbolsallowedin t andtheaxiomsdefinetheintended meanings.
a t model is a model that satisfies all axioms of t.a formula ist satisfiable if there exists a t modelmsuch that m .
a formula ist valid ifm ffor allt modelsm.
.
control flow graph acontrol flow graph cfg is a graphical representation of computation and control flow in the program.
let a basic block be a straight linesequenceofinstructionswithoutanyjumpsorjump targets.especially jumptargetsstartablockandjumpsendablock.
a control flow graph cfg is a directed graph where nodes are basic blocks and edges represent jumps in the control flow.
two speciallydesignatedblocks entryandexit maybeusedinacfg to represent the entry and exit points of the program.
letcbe the condition of a branch statement.
the cis called a branching condition.
and two branches of the branch statement is calledcbranchand cbranch respectively.givenabasicblock its block condition is a predicate such that the block is executable iff the block condition is satisfiable.
.
program verification recentadvancesinmodelchecking staticanalysis abstract interpretation predicate abstraction etc promoted programverificationtoapracticaltechniqueforcorrectnessassurance ofprograms.loopsarethemainhurdleforprogramverification.
there are mainly two approaches for handling loops in a program loop invariant and loop unwinding .
the former approach usesaloopinvariant whichholdsatthebeginningofeachiteration oftheloop torepresentthebehaviorsoftheloop.however itrelies on the user to provide the loop invariant.
automatic generation ofloopinvariantshavebeenextensivelystudied buttheexisting techniques are still not practical enough .
the more popular approach for handling loops is by unwinding.
with this technique each loop is unwound to a predefined depth.
as a result the loops are replaced by nested if statements.
this technique is good at bug finding.
other techniques like k induction enhances this approach by enabling the correctness proving of programs.
many of state of the art program verification techniques are basedonthesatisfiabilitymodulotheories smt solvers .these solvers are used as the reasoning engine.
in this paper we assume all programs have been processed by the loop invariant or loopunwinding technique and are thus free of loops.
the loop freeprograms are converted to their static single assignment ssa forms .withthessaform thecorrectnessofaprogramcan easily be encoded as a set of smt formulas .
these formulas are called the verification condition of the program with respect to the property.
the validity of the verification condition implies the correctness of the program.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
control flow guided smt solving for program verification ase september montpellier france smt formula sat solver unsat sat theory solver b is unsat let m be a satisfying model add a t conflict clause to m is t sat m is t unsat b is sat figure dpll t .
satisfiability modulo theories satisfiabilitymodulotheories smt extendssatwiththeabilityto reasonwithfirst ordertheories.weassumealltheoriesdiscussed in this paper are decidable and for each theory t there is a tsolver that can check the t satisfiability of conjunctions of literals int.
in practice theories are not isolated.
for example software verification needs theories of uninterpreted function arithmetic array bitvectors andsoon.nelson oppenproposedacombination method to deal with fol formulas in multiple theories.
dpll t extends dpll algorithm to incorporate reasoning abouttheories.itusesansatsolvertocopewiththebooleanstructure and theory solvers for deciding satisfiability in background theories.
the basic idea of dpll t is illustrated in fig.
.
given ansmtformula eachofitsatomsisfirstreplacedwithafresh boolean variable called the boolean abstraction.
denote the resulting formulaas b .
theboolean abstraction gives usa lazyway to solve the smt formulas.
dpll t uses an sat solver to findassignments for b and then uses a theory solver to check the t satisfiability of the found assignments.
the boolean abstraction isanover approximationoftheoriginalformulawithrespecttoits satisfiability.if b isunsatisfiable thensois butthereverse may not hold.
thehigh levelview ofapracticaldpll t algorithm isshown inalg.
.atthislevel thealgorithmisthesameasthatofaconflictdrivenclauselearning basedsatsolver .thedifferencesliein the implementations of propagate and check resolve conflict anddecide .
the method propagate and check repeatedly applies unit propagation and theory propagation to force values toas many as possible literals.
it also checks the t consistency of the current model.
the method returns if it encounters a con flict or t inconsistency and otherwise.
in case of conflict or t inconsistency themethod resolve conflict isinvokedtolearn conflictclausesandaddthemtotheclausedatabase.themethod decide decides the next unassigned boolean variable and guess its value.
if there is no unassigned variable the current model is complete and is thus a satisfying model.
many heuristics are developed for selecting the next unassigned variableanddecidingitsvalue.acommonlyusedbranchingheuristic is the vsids branching heuristic which is employed as the defaultheuristicinmanywell knownsolvers .dpll t is essentially a depth first search algorithm.
we may guide the searchingprocessofdpll t byenforcingavariableorderinthe decide method.algorithm dpll t input an smt formula output sat or unsat whiletruedo while!propagate and check do ifdecision level 0then return unsat elseresolve conflict if!decide then return sat motivations in this section we use a simple example to motivate our approach.
weshowthatsomeimportantcontrol flowknowledgeisneglected by the smt solver and utilizing this knowledge can make great gains.
considerasimpleprogramshownintheleftoffig.
.itsmain partisatwo tiernestedif statements.control flowgraphofthis program is shown in fig.
where ellipse nodes represent entry and exit and rectangle nodes represent blocks.
we ignore the detailed forms of the branching conditions in the program and simplyrepresentthemas c0andc1 respectively.thepropertyisto verify that x yholds at the end of this program.
verification condition.
the original program is firstly converted intothesinglestaticassignment ssa form whereforeachassignmentstatement a new variable is introduced for the right hand side variable.
after this conversion there is at most one assignment for each variable.
the ssa form of the program example is shown in the right of fig.
.
note that ite bool is a ternary function thatreturnsitssecondorthirdargumentdependingonifitsfirst argument is true or not.
also note thatthe nested structure of the originalif statementiskeptintheformulaasanested itestructure.
the verification condition vc i s vc definesenc cor whereencis the encoding of the program and corthe correctness condition.
for the motivating example we have enc x4 ite c0 ite c1 y4 ite c0 ite c1 and cor x4 nequaly4 theprogramis correctwithrespecttothepropertyifandonlyif vcisunsatisfiable.
conjunctivenormalform.
werelyonansmtsolvertocheckthe satisfiabilityof vc.theformulaneedbeconvertedto conjunctive normal form cnf .
a conjunctive normal form is a conjunction of clauses and each clause is a disjunction of literals.
for ease ofunderstanding we usually write a clause as a logical entailment sinceitcanbeconvertedtoaclausedirectly i.e.
a1 ak b can be convertedto a1 ak b wherea1 ... akandb are literals.
in the remainder of the paper we also write a cnf as a set of clauses and a clause as a set of literals.
mostsmtsolversadoptthetseitin stransformationmethod to perform the cnf conversion which adds a new variable for eachsubformulaoftheoriginalformula.considerthemotivating authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianhui chen and fei he if c0 x y else if c1 x y else x y assert x y if c0 x1 y1 else if c1 x2 y2 else x3 y3 x4 ite c0 x1 ite c1 x2 x3 y4 ite c0 y1 ite c1 y2 y3 assert x4 y4 ssa program figure example example thecnfof enc written cnf enc istheconjunctionof the following clauses c0 x4 c0 x4 tx c1 tx c1 tx 3c0 y4 c0 y4 ty c1 ty c1 ty notethattheauxiliaryvariables txandtyareintroducedfortheinneritefunctionof vcx4andvcy4 respectively.moreover cnf vc cnf enc cnf cor wherecnf cor x4 nequaly4.
thetseitin smethodguaranteesthattheconvertedformulais equi satisfiabletotheoriginalformula.inotherwords theverification condition vcis satisfiable iff cnf vc is satisfiable.
dpll t .
dpll t isthestandardtechniqueunderlyingmodern smt solvers.
it starts by replacing each atom of the formula with a fresh boolean variable called boolean abstraction.
in the following we usevlto represent the boolean variable for the atom l. the boolean abstraction of cnf enc written b cnf enc i s vc0 vx4 vc0 vx4 tx vc1 vtx vc1 vtx 3vc0 vy4 vc0 vy4 ty vc1 vty vc1 vty moreover b cnf vc b cnf enc b cnf cor where b cnf cor vx4 y4.
.
control flow knowledge is neglected the first knowledge is about the execution of statements in the sameblock.consideringthebooleanformula allvariablesare independenteachother.thevariables vx4 1andvy4 1canbeassigned with different values by dpll t .
however if we look at the original program in fig.
clearly the statements x and y areinthesamebasicblock.foranyexecution eitherthese twostatementsarebothexecuted orneither.correspondingtothe boolean formula the boolean variables vx4 1andvy4 1must be assigned with the same boolean value.
similarly the boolean variables vx4 2andvy4 the boolean variables vx4 3andvy4 must be assigned with the same boolean values too.
this is an importantknowledgeaboutthecontrolflowoftheprogram which is however neglected by the smt solver.x y if c0 x y if c1 x y true false true false assert x y figure control flow graph of the example thesecondknowledgeisabouttheexecutionofmultipleblocks.
the example program has three blocks at line and with conditions of c0 c0 c1 and c0 c1 respectively.
apparently their conditions are mutually exclusive hence only one of these blocks can be executedin one program execution.
this important knowledge is also neglected by the smt solver.
for example assumethe c0istrue onlystatements x y and assert x y areexecuted theprogram scorrectnessisrelevanttothesethree statements only.
for the boolean formula the first two clauses encodethe c0branch andthelastsixclausesencodethe c0branch.
weexpectthelastsixclausesneednotbeconsideredindpll t assoonas vc0isassigned true.theactualsituationisthatthethird and fourth clauses can be dropped from dpll t since they are satisfied whereasthelastfourclausescannot.thesmtsolverstill makes some efforts to consider different assignments of boolean variables in these clauses i.e.
to explore the corresponding blocks in the subsequent search process.
.
applying control flow knowledge makes great gains consideringabasicblockwith nstatements let betheformula that encodes this block and b the boolean abstraction of there are at least nboolean variables in b .
dpll t treats all these variables as independent individuals and needs explore their 2nassignments.incontrast withthecontrol flowknowledgeabout the execution of statements in the same block only assignments of thesenvariables both trueor bothfalse need be explored.
moreover considering a program with mmutually exclusive blocks.
without the control flow knowledge the smt solver needs to explore all combinations of these mblocks.
the search space in this case is the cartesian product of these mblocks.
in contrast withthecontrol flowknowledgeabouttheexecutionofmultiple blocks eachtime we explore oneblock only.
thesearch space is the addition of these mblocks.
the search space is thus greatly reduced.
control flow guided smt solving to utilize the control flow knowledge one may consider adding constraints to the original formula.
however specifying these constraints may introduce additional variables and thus increases the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
control flow guided smt solving for program verification ase september montpellier france verifier solver smt formula order a satisfied model unsat figure overview of our approach problem complexity.
we have a simpler and smarter solution.
the basicideaistoinferavariableorderfromthecontrol flowofthe program and then use this order to guide the search process of dpll t moreclearly byenforcingthisorderin decide ofalg.
.
our approach can take full advantage of the built in features of dpll t .itprovidesalightweighttechniqueforutilizingcontrolflow information.
fig.
4shows an overview of our approach.
at the verifier side except the smt formula that encodes the verification problem a decision order on the variables is also generated section4.
.
this order records the control flow information of the program.
an smt solving involves two steps cnf conversion and dpll t .
we propose techniques to enhance both steps a technique for guiding the dpll t with an order section .
and an enhanced cnf conversion technique section .
.
.
decision order let beaformula b thebooleanabstractionof andvtheset of boolean variables in b .
we distinguish the boolean variables for branching conditions and call them branching variables.
let vb vbe the set of branching variables in b .
we intend to defineapartialorder precedesorcurlyoverv.wecallthisorderthe decisionorder.
letv1 v2be two variables in v i fv1 precedesorcurlyv2 w es a yv1isprior tov2 in precedesorcurly.
inthecfgofaprogram anode d1issaidto dominate another noded2 ifeverypathfrom entrytod2mustgothrough d1.consideringthecfginfig.
thec0nodedominatesallnodesinthe graph except of entryand itself the c1node dominates two of its successor nodes.
remarkthatthebranchingconditionsdominatethecontrolflow of the program.
we have the following heuristic.
heuristic .
branching variables are prior toall other variables inv i.e.
v1 vb v2 v vb.v1 precedesorcurlyv2.
recalltheproblemdiscussedinsection .
thestatements x and y are in the same block while the boolean variables vx4 andvy4 1canbeassignedtodifferentvalues.withheuristic this isnotgoingtohappen.if vc0 true bybooleanpropagation on thefirsttwoclausesoftheformula both vx4 1andvy4 1are forced to be true i fvc0 false the first two clauses are trivially satisfied and the boolean variables vx4 1andvy4 1need not be considered in the subsequent process of dpll t .
to further define the order among branching variables we have the following heuristic heuristic .
given two branching variables v1 v2 vb v1is prior tov2 i fv1dominates v2.
the underlying principle of heuristic 2is straightforward.
consideringthecfginfig.
ifc0istrue thewhole falsebranchof c0 c0 c1 true false true false figure branching graph nomatter c1holdingornot canbeexcludedfromtheconsideration.
in contrast deciding a value of c1cannot drop any branch of c0.
this paper consider loop free programs only.
thus there can neverbetwonodes d1andd2inthecfg suchthatboth d1 precedesorcurlyd2 andd2 precedesorcurlyd1.inotherwords theinducedorderbyheuristic 2isa partial order.
.
.
inferring the order.
the control flow graph has all the information that we need.
inferring the decision order from the cfg of a given program is quite easy.
given a cfg we construct a so called branching graph by eliminatingallstatementsinformationbutkeepingthebranchingconditions in the graph.
let dbe a node except of entryandexit ofthecfg weuse label d todenotethestatementslabeledon d parent d theparentnodesof d andchild d thechildnodesof d. if the last statement of label d is a branch statement we delete all information in label d but keep the branching condition.
if the last statement in label d is not a branch statement indicating that dhasonlyonechildnode weconnectallitsparentnodestothis single child node and then delete d. the resulting branching graph is a directed graph where nodes are branching conditions and edges are control flows.
all control flows are kept in the branching graph.
the branching graph of the motivatingexampleisshowninfig.
.comparingthebranching graph infig.
tothecfg infig.
fournodesaredeleted the labels of two nodes are changed.
note that the boolean values associated with edges are all kept.
apparently the branching graph induce a partial order that agreeswithheuristic .weusethisgraphtoguidethesearchof dpll t .
.
.
storing the order.
wedesignamechanismtoimplicitlystore the branching graph.
the edges of the graph are recorded in the identifiers of variables which won t affect the semantics of the formula.asaresult whenansmtsolverisinvoked theonlyinputisthesmtformulafile insmt lib v. .0format .noadditionalfile need be provided.
all condition variables are indexed by the order of their appearances inthe program.
let vbe acondition variable.
theidentifier ofvis a series of numbers separated by with the first number being the index of v and others being indexes of v s parents in the branching graph.
for example the condition variable vc0 s identifier is indicating that c0is indexed by and has no parent the condition variable vc1 s identifier is 1 0 indicating that c1is indexed by and its single parent is indexed by i.e.
c0 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianhui chen and fei he algorithm decide input the current node curin the branching graph output an unassigned variable vand a boolean value value ifcur exitthen v value decide nonbranching variables whilevar cur is an assigned variable do lettbe the assigned value to cur cur next cur t v value var cur rand return v value when an smt solver is invoked it first parses the smt formula and restore the branching graph from the variables identifiers.
then it uses this branching graph to guide its dpll t procedure.
.
control flow guided dpll t toguidethesmtsolving weenforceadecisionorderinthe decide operator of dpll t .
ourimplementationof decide isshowninalg.
.assumethere isabranchinggraph and curisitscurrentnodethatrepresentsthe lastassignedbranchingvariable.let dbeanode and taboolean value we provide two methods for manipulating the branching graph var d returns the branching variable that drepresents and next d t returns the next node following the t edge ofd.i fcur is the exitnode indicating that all of the branching variables have beenassigned to avalue the algorithmrelies on themethod decide nonbranching variables toselectthenextvariableanddecideitsvalue whichimplementsthedefaultbranchingheuristics inconventional smtsolver .otherwise ifthevariable that currepresents has been assigned a value the algorithm follows its valueand move tothe nextnode.
this movingprocess repeats untilwegetanunassignedbranchingvariable.thenwereturnthis variable and a randomly decided value.
moreover the resolve conflict methodinalg.
1needsbeslightly modified.
in case of backtracking if the target variable is a branchingvariable weneedtocorrespondinglymodify curtothenode that represents the backtracked variable and flip its assigned value.
.
enhanced cnf conversion recalltheproblemabouttheexecutionofmutuallyexclusiveblocks seesection .
.afterthecnfconversion theconditionsofblocks are divided into parts.
even two blocks are mutually exclusive the smt solver cannot drop the opposite one.
to solve this problem we need to enhance the cnf conversion procedure.forthemotivatingexample the cnf enc isexpected to be the conjunction of the following clauses c0 x4 c0 c1 x4 c0 c1 x4 3c0 y4 c0 c1 y4 c0 c1 y4 comparedto whichisobtainedby theconventionalapproach the block conditions are specified in as the premises of clauses.
asaresult iftheconditionpredicateofoneblockis true bymutual exclusionofblockconditions theclausescorrespondingtoother blocks are trivially satisfied.
in the above cnf formula thealgorithm rewrite ite input a smt formula output a rewritten formula withoutitefunctions letitesbe the set of ite terms in for each ite itesdo let l rbe three real parameters of ite replaceitein with rewrite ite l rewrite ite r return first twoclauses represent the c0branch andthe last fourclauses represent the c0branch.
assume vc0istrue thus vc0 c1and vc0 c1arefalse thelastfourclausesarehencetriviallysatisfied.
the atoms in these four clauses for instance x4 y4 and so on need not be considered againin dpll t .
in this way we avoid dpll t to explore the c0branch.
the key to getting the above cnf is the iterewriting procedure which rewrites iteterms into those with only boolean connectives.
remark thatall branching conditions ofthe verification condition formula are stored in the iteterms.
the conventional rewriting algorithmbreaksthenestedstructuresof iteterms andthussplitsthe block conditions into parts.
we want a new iterewriting algorithm that keeps the block condition as a whole.
our new iterewriting algorithm is shown in alg.
.
the algorithm finds all iteterms in .
eachiteterm is a ternary function with three parameters.
we store these three parameters in land r respectively.
the semantics of the itefunction is that if is true it returns l and otherwise returns r which is equivalent to l r .
note that landrmay also contain iteterms.
thealgorithmneedbeappliedto landrrecursively.finally contains noiteterm.
ouralgorithm cancollaborate with thetseitin s algorithm directly sincethe rewritten iteformulas are already in the form of a conjunction of clauses section .
comparing our iterewriting algorithm to the conventional one the conventional rewritingalgorithms introducean auxiliaryvariable for each ite term.
the most benefit of the conventional approachisthatallgeneratedclausescontainsonlytwoliteralsfor generating binaryclauses asmore aspossible.binaryclauses are good for boolean propagations.
however the main problem here is not boolean propagation but the theory propagation.
with ourcnfformula therearesomeresultsthatcanbeforcedbyapply ingbooleanpropagationonly.ho wever with theircnfformula in many cases must the theory solver be involved can we deduce the sameresult.moreover withourenhancedapproach thenumber ofclausesisfewer.besides ouralgorithmneedsnottointroduce auxiliary variables for each iteterm.
the total number of variables is also reduced.
implementation and experimental evaluation in this section we discuss the implementation and evaluation of our control flow guided smt solving tactic.
during the evaluation we mainly consider the following research questions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
control flow guided smt solving for program verification ase september montpellier france 100control flow guided s baseline s figure smt solving time on all benchmarks.
rq1.how can we evaluate the performance of our tactic credibly?
rq2.how does the performance vary between our tactic and the original method on credible benchmarks?
rq3.does ourtactic affect the performanceof the smt solver in a way as we expected?
.
implementation we implement our control flow guided smt solving tactic presented in section in cbmc and z3 .
cbmc is a well knownboundedmodelcheckingtoolforc c programsand z3 is an efficient smt solver.
both cbmc and z3 are open source projects.
in our implementation cbmc is responsible for generating smt formulae that encode the verification conditions of the programs.ourdecisionorderinferringalgorithmisimplemented in cbmc since the control flow information can be directly obtainedaftercbmcparsestheprograms.ourcontrolflow guided dpll t algorithmandtheenhancedcnfconversionalgorithm areimplemented inz3.the smtfilestransferred betweencbmc and z3 are in the smt lib v. .
format.
.
experiment setup allexperimentsareconducted onthereachsafetybenchmarksin sv comp .
this benchmark set contains up to c programs.
alltheseprogramshavealreadybeenpreprocessedforverification.
weusecbmctogeneratesmtformulasfromthebenchmark programs.let kbetheunrollboundofcbmc.withdifferentvalues ofk cbmcgeneratesdifferentsmtformulas.weaskthecbmc to generate as many as possible smt formulas within minutes.
if theunrollboundreaches2000 thegenerationprocessalsostops.
consider a falsified program let k be the minimal value of ksuch thatacounterexamplecanberevealedfromtheprogram.then for allgeneratedsmtformulasforthisprogram theyareunsatisfiable fork k and satisfiable for k k .
in order to balance the numberofsatisfiableandunsatisfiableinstances wedropsomesmt instanceswitharathersmall k.finally excludingtheexceptional cases timeout internal error etc there are totally programs with which cbmc successfully generates smt instances.
all of110100 100control flow guided s baseline s figure smt solving time on satisfiable benchmarks.
901accumulated times s accumulated solved benchmarks baseline control flow guided figure8 accumulatedsmtsolvingtimeonallbenchmarks.
these smt files are plain text files in smt lib v. .
format.
the largest smt files occupy hundreds of mb.
wecomparetheperformanceofourcontrolflow guidedsmt solving tactic to that of the default heuristic in z3.
the original z3 with the default heuristic is considered as the baseline.
the plus of z3 and our tactic is called z3 .
timeout for each instance is set to minutes.
notethat some preamble tactics for example the simplifying tactic thevariable eliminating tactic etc arerealized inz3 withwhichsomeofthesesmtinstancescanbeimmediatelysolved withoutcallingthedpll t procedure.therearealsosomeinstancesthataretoohardtobesolvedbyeitherz3 orthebaseline in the time limit.
we drop the above two kinds of exceptional benchmarks.finally wegot948smtinstances where314instances are satisfiable and ones are unsatisfiable.
we believe these benchmarksaresufficienttoevaluatetheperformanceofourtactic credibly.
.
experimental results figure6showthesmtsolvingtimeofthebaselineandourcontrol flow guided tactic on all benchmarks.
the figure demonstratesthat our tactic is superior to the baseline on the majority of the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianhui chen and fei he 301accumulated times s accumulated solved benchmarks baseline control flow guided figure accumulated smt solving time on satisfiable benchmarks.
benchmarks.
especially our tactic can speed up the smt solver by orders of magnitude on about a quarter of the benchmarks and there are a very little of benchmarks on which our tactic is notablyinferiortothebaseline.theaccumulatedsmtsolvingtime forsolvedbenchmarksisshowninfigure .ingeneral ourtactic uses only .
percents of time of the baseline to resolve the same number of the benchmarks.
wealsopresentthesmtsolvingtimeofthesatisfiablebenchmarks in figure .
on satisfiable benchmarks our tactic is superior to the baseline for most of the benchmarks.
there are only a handful of benchmarks that cost our tactic more time.
besides nearlyhalf of the benchmarks are sped up by orders of magnitude.
theaccumulated smt solving time for all satisfiable benchmarks is shown in figure .
our tactic costs only .
percents of time of the baseline to resolve the same benchmark group.
theaccumulatedsmtsolvingtimeforsolvedunsatisfiablebenchmarks is shown in figure .
the curves for both the baseline and our tactic are substantially identical.
our tactic saved about .
percents of the smt solving time for this group of benchmarks.
summary of the experimental results for smt solving time is presented in table .
thecpu time is the total running time of each tool on the whole benchmark set.
our tactic costs half the cputime tofinishallthebenchmarksandonlyspendsaquarter ofcputime tofinishthesatisfiablebenchmarkscomparedtothe baseline.the scoretime istheaccumulatedtimeforsolvingacertain quantityofbenchmarks wherethequantityisequaltothemaximal numberofbenchmarkthatthebaselinecansolve.allofthe score timesare indicated by the straight dash line in the curve diagrams like figure .
the ratio of the score time of the baseline and our tactic indicates the speed up times of our tactic for solving thesame group of benchmarks.
to summarize our tactic speeds upthe solver by .
times for all benchmarks and .
times for satisfiablebenchmarks.also thenumberoftimeoutcaseswithour tactic is much fewer than that with the baseline.
in conclusion our controlflow guidedsmtsolvingtacticcansignificantlyimprove the performance of the smt solver.
601accumulated times s accumulated solved benchmarks baseline control flow guided figure accumulated smt solving time on unsatisfiable benchmarks.
table summary of experimental result subcpu time s score time s timeout z3 z3 lift z3 z3 lift z3 z3 sat .
.
unsat .
.
all .
.
.
result analysis the experimental results illustrate remarkable improvements of our tactic over the baseline.
also note that the improvement of our tactic on unsatisfiable benchmarks is not as significant as that on satisfiable benchmarks.
in other words the utility of our tactic is limited for the unsatisfiable instances.
recall that dpll t is basically an exhaustive search procedure.
for an unsatisfiable formula no matterour tacticorthe baselinetheyhave toexplore thewholesearchspacetoproveitsunsatisfiability.theefficiency of the control flow guided approach is thus greatly limited.
in fact the unsatisfiable cases are hard to be optimized for most of the existing heuristic methods.
furthermore during the dpll t search procedure the algorithmstopsaslongasasatisfiablevariableassignmentsisfound.if the current variable assignments conflict a conflict clause is learnedandthesearchprocedurebacktracks.toacertainextent the number of conflict clauses indicates the try times in the search procedure of dpll t .
figure 11shows the number of conflict clauseslearnedduringthedpll t .aswecansee onthemajority of the benchmarks the number of the conflict clauses learned with our tactic is fewer than that with the baseline especially for thesatisfiablebenchmarks.theseresultsindicatethatourtacticcan guide dpll t to find a satisfiable solution with fewer try times in the search procedure.
.
threats to validity themain internalthreatstothevalidityofourapproacharethat whether the performance improvements are mainly due to our controlflow guidedtactic andthatwhethertheimplementation authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
control flow guided smt solving for program verification ase september montpellier france 1000000control flow guided baselinesat unsat figure conflict clauses learned during dpll t .
of our tactic is credible.
firstly we only implemented two algorithms in z3 i.e.
the branching heuristic and the enhanced cnfconversion algorithm.
they are simple and barely coupled with other modules.
meanwhile we have implemented our algorithm as clearly as we can.
secondly the adding of the control flow infor mation won t affect the performance of the original solver since weimplicitlyrecordthedecisionorderinthesmtfilebynaming the smt variables in a special fashion which doesn t have any effect on the semantics of the smt formula.
last but not the least we conduct experiments on a large number of benchmarks from sv comp .
the experimentalresults show theremarkableperformanceofourtechnique.additionally theanalysisofthenumberofconflictclausesfurtherdemonstratesthatourtacticdoesaccelerate the search procedure which conforms to our expectations.
we are thus confident in the effectiveness of our tactic.
anotherthreattothevalidityofourapproachisthatwhether our approach can be generalized to other solvers other than z3.
actually our tactic is based on the dpll t framework it has nothingtodowiththespecificfeaturesofthez3solveritself.thus ourtacticcanbeimplementedinany dpll t basedsmtsolver for program analysis.
onemorethreatisthatwhetherourapproachcanbegeneralized to other program analysis techniques except bmc.
the answeris also yes.
actually we use cbmc in our experiments only to generatesmtinstances andnothingmore.ourtacticcanbeeasily applied to other program analysis techniques only if they are smt based i.e.
they encode the verification conditions as the smt formulas and then rely on an smt solver to solve these formulas.
related work thereisalargebodyofworkonimprovingtheperformanceofthe dpll basedconstraintsolvers likesatandsmtsolvers.below we compare our approach with the most closely related works.
sinceourapproachisbasedonthebranchingheuristic alsonamed thedecision ordering of the dpll backtrack search procedure we discuss this aspect first.
.
branching heuristics oneofthemostfamousbranchingheuristicsisvsids .it increases the ranking values of each literal in a newly inferred conflict clause and also decays these values periodically.
the ordering is based on these ranking values.
there are also other branching heuristics utilize the information from the backtrack search procedure likemomheuristic jeroslow wangheuristics literal count heuristics etc.
however all of these branching heuristicsaredesignedforthegeneralsatisfiabilityproblems which can only utilize the information from the dpll procedure and almostdonotcareaboutthedomain specificknowledgefromoriginalproblemsmodeledbythesatisfiabilityproblems.oursemanticbranchingheuristiciscombinedwithoneofthemostefficient heuristics vsids based butfocusonthesatisfiabilityproblemsde rivedfromtheprogramanalysisproblem.withthedomain specific knowledge of program analysis our heuristic can lead to more efficient constraint solving.
thereisalsosomeworkonrefiningthedecisionorderingbythe domain specific knowledge of circuits or models.
the most closely relatedworkis whereyinetal.refinethedecisionordering forthesatisfiabilityproblemfromtransitionsystembygivingthe higher priority to the transition variables over other variables.
besides all of the transition variables are ordered by the transition relations in the models.
as we discussed in section the program is more complex than the general transition systems.
furthermore thisheuristiccanhardlyworksincealloftheprogramvariablesare transition variables and the dpll decision procedure is performed on the predicates over the program variables instead of on the program variables directly.
moreover there are some other related workrefiningthedecisionorderingbytheknowledgeofthetransitionsystems.in wangetal.identifytheimportantvariablesin theunsat core form the previous unsatisfiable bmc instances and giveprioritytotheseimportantvariablesindecisionorderingon thecurrentinstance.shtrichmanandofer suggestsastaticpredeterminingorderfollowingaforwardorbackwardbreadth first searchonthevariabledependencygraphofthetransitionsystem.
in guptaetal.exploreimplicationslearnedfromthecircuit structurerepresentedbybddstohelpthesatsolving.sincethere is less structure information in a cnf formula ostrowski et al.
suggests recovering and exploiting structural knowledge by a set of equations form initial sat instance to eliminate clausesand variables.
all of the work are based on the domain specific knowledge of circuits or models instead of the programs.
.
utilizing control flow information our tactic is based on utilizing the control flow information of the program.
we also compare our approach with the related work on utilizingthecontrol flowinformationforprogramanalysis.in leinoetal.splitthemonolithicvcofaprogramanalysisprocedure intotheconjunctionofseveralsmallervcsaccordingtothecontrolflowinformation.thepartitionresultsinseveralsmallersmtquery whichcouldbesolvedmoreefficientlythantheoriginalone.cimatti et al.
partitions the abstraction problem into the combination of several smaller abstraction problems by exploiting the structure of the program.
these approaches improve the performance by the heuristicofpartitionthemonolithicproblemintoseveralsmaller authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianhui chen and fei he problems utilizing the control flow information.
our tactic also utilizedthisheuristicsincegivingprioritytotheconditionvariable issimilartosplittingthewholeprogramintoseveralprogrampaths and then solving the path formula one by one.
symbolicexecutiongeneratesaverificationconditionforeach path of the program.
for different paths of the control flow of the program it generates different smt formulas.
in this respect one may saythat thesymbolic executionalso utilizesthe controlflow informationofprograms.ho wever symb olicexecutionutilizesthis informationatthelevelofvcgeneration whileoursdoesatthe level of the smt solver.
with our approach only one smt formula thatencodesverificationconditionsofallpathsoftheprogramis generated.ourtacticcanusethemanybuilt infeaturesofthesmt solver including the conflict clause learning value propagation andsoon.asaresult theintermediateresultsamongverifyingthe many paths of the program can be easily and automatically shared.
belt et al.
and feist et al.
proposed to utilize the controlflowinformationandthedomain specificknowledgeofsymbolic executiontoreducethetimesofthesmtquery respectively.for the same reason these work are also different from ours.
.
theory aware approach the optimization of our tactic is based on pruning the conflict assignmentsearly.someoftherelatedworkbasedonthetheoryaware approach also optimize the constraint solving procedure in this way.
the theory aware approaches discover the constraintsfrom the underlying theory by a lightweight method and utilize theseconstraintstohelptoprunetheconflictassignmentsindpll procedure.
berzish et al.
proposed a theory aware branching heuristic which prioritizes simpler branches over more complexones in string solvers.
they also proposed a theory aware case split to circumvent mutually exclusive assignments by the struc ture of string theory literals.
goldwasser et al.
p r o p o s e da theory aware branching heuristic for linear reals arithmetic based onageometricanalysisoverthelinearconstraints.theheuristic suggests the values which is consistent with the current partialassignment for the unassigned predicates of linear constraints.
bruttomesso et al.
utilize the structural information like equalitiesand arithmeticfunctionsto helpto reasonata higherlevelof abstraction within the theory of bit vectors.
all of these theoryawareapproachesfocusonthespecifictheory suchasstringtheory linear reals arithmetic theory and bit vector theory.
however our tactic is a high level approach based on refining branching heuristic of dpll procedure which is independent of theories.
in kuehlmannetal.usecircuitspecificknowledgetoguidethesearchofsatsolvingandhelpthesolverreasoningonspecificlogic.this work is only suitable for circuit problems.
besides the dpll based solver theotherconstraintsolvercanalsoutilize thetheory aware approachtoimprovetheperformancesignificantly.forexample hooimeijer et al.
proposed a lazy backtracking search algorithmforsolvingtheregularexpressionconstraintsefficientlyby afollowgraph andaconstraint pathmapgeneratedfromtheconstraint system.
this work is specifically for solving the regular expression constraints.
conclusion and future work in this paper we present control flow guided smt solving tacticutilizing the control flow information of the programs to refinethe dpll t search procedure in smt solvers.
in our tactic the search space is reconstructed continuously and dynamically by the control flow information and thus a large number of redundant searchpathscanbepruned.weimplementourtacticinthemodern smtsolverz3 andcompareourtacticwiththedefaultheuristic in z3.
the experiments on sv comp benchmarks have shown thatourcontrolflow guidedsmtsolvingtacticcansignificantly speed up the smt solving.
especially our tactic achieves orders of magnitude improvements on satisfiable benchmarks.
inalgorithm afteradecisionvariableisselected itsvalueis randomlydetermined.therealsoexistsomestrategiesfordeciding a variable s value in the existing sat smt solvers.
again these strategies are not domain specific.
we are planning to study to use the program information to guide the smt solver for determining the variables values.