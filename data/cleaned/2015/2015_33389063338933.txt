nodest feedback driven static analysis of node.js applications benjamin barslev nielsen oracle labs australia aarhus university denmark barslev cs.au.dkbehnaz hassanshahi oracle labs australia behnaz.hassanshahi oracle.comfran ois gauthier oracle labs australia francois.gauthier oracle.com abstract node.js provides the ability to write javascript programs for the server side and has become a popular language for developing web applications.
node.js allows direct access to the underlying filesystem operating system resources and databases but does not provide any security mechanism such as sandboxing of untrusted code and injection vulnerabilities are now commonly reported in node.js modules.
existing static dataflow analysis techniques do not scale to node.js applications to find injection vulnerabilities because small node.js web applications typically depend on many third party modules.
we present a new feedback driven static analysis that scales well to detect injection vulnerabilities in node.js applications.
the key idea behind our new technique is that not all third party modules need to be analyzed to detect an injection vulnerability.
results of running our analysis nodest on realworld node.js applications show that the technique scales to large applications and finds previously known as well as new vulnerabilities.
in particular nodest finds true positive taint flows in a set of our benchmarks whereas a state of the art static analysis reports only.
moreover our analysis scales to express the most popular node.js web framework and reports non trivial injection vulnerabilities.
ccs concepts software and its engineering automated static analysis .
keywords program analysis static analysis taint analysis security analysis node.js javascript acm reference format benjamin barslev nielsen behnaz hassanshahi and fran ois gauthier.
.
nodest feedback driven static analysis of node.js applications.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
introduction node.js is a platform to run javascript on the server side.
node.js applications consist of modules and are managed by the npm package manager.
in contrast to client side javascript applications that run in browsers node.js allows direct access to filesystem operating system resources and databases but does not provide any security mechanism such as sandboxing of untrusted code.
to detect injection vulnerabilities tracking user controlled inputs is needed.
this type of analysis is known as taint analysis which is a popular analysis to detect flows of data from untrusted sources to security sensitive sinks.
due to the dynamic nature of javascript existing dataflow analyses for statically typed languages such as java are not suitable in practice.
for example it is possible to construct an over approximate callgraph in a pre analysis step to refine and scale a more precise and expensive analysis for java .
however constructing callgraphs for javascript programs requires handling dynamic dispatches which requires type inference which itself requires a precise callgraph.
abstract interpretation techniques that are designed to more closely model the program semantics compared to previous dataflow techniques have shown to be more precise and suitable for analyzing dynamic languages such as javascript .
a taint analysis can be specified as a client analysis in an abstract interpretation framework to detect vulnerable dataflows.
abstract interpretation is a static analysis technique that computes a sound overapproximation of all possible program behaviors .
statically computing all possible behaviors of a program using concrete language semantics is known to be undecidable.
therefore abstract interpretation frameworks overapproximate concrete values and operations with abstract values and operations.
existing state of the art static analysis techniques for javascript are conducted as a whole program analysis precisely analyzing all reachable code from the main entry point of the program .
these analysis techniques often fail to scale because of the highly dynamic nature of the javascript language.
this problem is exacerbated in node.js applications because they often consist of many npm modules.
for instance many of the web based node.js applications are built upon libraries such as express which relies on many other npm modules making a single dependency transitively depend on about 30modules with an estimated lines of javascript code.
the standard whole program analysis techniques often get stuck in a hard to analyze npm module in the early stages of the analysis and are not able to produce any useful results.
in abstract interpretation fine tuning analysis precision and scalability manually is infeasible.
the key idea in this paper is to automatically determine which modules in a node.js application esec fse august tallinn estonia benjamin barslev nielsen behnaz hassanshahi and fran ois gauthier can be approximated1with a wide abstraction to improve scalability while preserving precision.
by precisely analyzing a set of modules while approximating the rest our analysis is able to scale to node.js applications and detect injection vulnerabilities.
our analysis tool nodest performs feedback driven static analysis that is carried out through several iterations.
it uses tajs an abstract interpretation framework for javascript as the underlying analysis in each iteration.
at the start of the process the set of modules that need to be analyzed precisely includes all modules in the node.js application and excludes all third party modules.
during each iteration it applies heuristics to determine any new modules that need to be added to this set or existing modules that need to be deleted from the set and uses this information as feedback to the next iteration.
third party modules that are not in this set are not analyzed i.e.
they are approximated and their side effects are ignored.
we evaluated the effectiveness of our technique using benchmarks in and additional real world node.js applications.
we also compared our technique with the whole program analysis in tajs to understand if nodest helps scaling the analysis to find injection vulnerabilities in real world applications that were not analyzable before.
our results show that nodest scales to those applications and finds not only the previously known vulnerabilities but also previously unknown zero day vulnerabilities.
moreover it achieves high precision and reports few false positives.
in summary this paper makes the following contributions we present a feedback driven static analysis that scales to real world node.js applications section .
we extend our feedback driven analysis with a static taint analysis which enables us to find non trivial injection vulnerabilities in node.js applications section .
we evaluate our feedback driven static taint analysis on real world node.js applications and report injection vulnerabilities that would otherwise be missed by a whole program taint analysis.
moreover we report new vulnerabilities that are not reported by existing dynamic analyses section .
motivating example to better understand the challenges explained in section consider the code snippet in listing .
this example shows a simplified node.js application based on express that is vulnerable to a nosql injection attack.
nosql is a common term for nonrelational databases in which queries and data are represented in javascript object notation json format.
the purpose of the code is to provide information of a patient by specifying the phone number of the patient.
in this example the attacker can craft a json object instead of a phone number and send it as input through an http request such that the query at line satisfies all patients instead of only a patient with a specific phone number.
the attacker can thereby access the records of all patients.
the application starts by importing built in and third party modules between lines and .
lines and instantiate the express framework a web framework that provides http utility methods and middleware to build node.js web applications.
1throughout the paper approximating a module refers to approximating the return value of require m which imports a module named m without analyzing m .1var http require http 2var yaml require js yaml 3var mongo require mongodb 4var express require express 5var app express ... 7app.get patients function req res ... q mobile req.query.val ... mongo.collection.find q function e r ... listing excerpt of ankimedrec a vulnerable node.js application that whole program analysis fails to analyze.
when an http request req comes in it is passed to the application from express at line .
http requests can be controlled by the attacker hence reqis a taint source2.
the query.val property of reqis used at line through q to query the mongodb nosql database3using the mongodb database driver which is imported at line .
this application is vulnerable because an attacker controllable tainted value is directly passed to mongo.collection.find as an argument allowing an attacker to access sensitive data of patients with no restrictions.
to analyze this program and find the vulnerable taint flow a whole program abstract interpretation such as tajs can be used analyzing all the imported modules precisely based on the designed abstract domain and abstract operations until it reaches a fixpoint.
tajs times out while analyzing js yaml at line .
note however that it is not necessary to analyze this module precisely to find the nosql injection at line .
on the other hand if express at line is not analyzed precisely the analysis will not be able to reason about the taint flow from an incoming http request to the sink hence failing to find the nosql injection vulnerability.
in section we revisit this example and show how our feedback driven analysis is able to scale and find the taint flow by approximating modules such as js yaml while precisely analyzing modules such as express .
background static analysis in tajs our work is based on tajs an abstract interpretation framework for javascript.
we extend several components of the original wholeprogram analysis in tajs to adapt it to our proposed feedbackdriven approach.
the analysis in tajs is based on the monotone framework and uses a fixpoint solver that depends on a worklist algorithm.
the program being analyzed is represented as a control flow graph.
the abstract domain used by the analysis simulates the ecmascript specification and in high level provides a callgraph and an abstract state for each context and flow graph node.
fig.
shows the simplified definitions of the abstract domain in tajs that are useful for understanding the new extensions proposed by our approach.
analysislattice maps node and context pairs to abstract states and the fixpoint solver needs to reach a fixpoint in this lattice.
an abstract state maps object addresses to abstract 2the taint source location is the allocation site for a reqobject in the http module.
3to simplify the example we have not included the database driver setup steps.
456nodest feedback driven static analysis of node.js applications esec fse august tallinn estonia p property names l object addresses n nodes c contexts analysislattice n c state state l obj obj p value value undef null bool num string p l figure parts of the basic abstract domain in tajs.
objects that are maps from property names to abstract values.
abstract values are modeled by the lattice value .
the details of each kind of value is discussed in detail in .
tajs performs static analysis using the worklist algorithm in algorithm .
the worklist algorithm iterates over node and context pairs until a fixed abstract state is found for each node and context pair.
the analysis starts by adding the initial node and context to the worklist.
an element is removed from the worklist and analyzed until there are no more elements left.
after analyzing the element the current state propagates to its successors.
if the state at the successor changes by this propagation propagate n c is true we add the successor to the worklist.
algorithm worklist algorithm in tajs add the initial node and context n c to the worklist while worklist not empty do remove node and context n c from worklist analyze n c forall successors n ofndo ifpropagate n c then add n c to worklist end if end for end while modelling the module loader in tajs .
the original module loader in tajs mimics the require mechanism in node.js .
given a module name and the location from which require is called it finds the first matching file following a precedence order specified by the require mechanism and runs the abstract interpretation analysis in tajs to analyze it precisely.
feedback driven analysis in a standard whole program analysis such as tajs the whole program is analyzed with the same level of precision across all modules.
however the analysis can be tuned for certain modules that are more critical.
to automatically determine which modules can be approximated with a wide abstraction to improve scalability while preserving precision we define mspas a set of modules that are analyzed precisely and msbas a blacklist of modules that are not allowed to be added to msp e.g.
modules that are hardto analyze which can be known a priori or during the feedbackdriven analysis .
both mspandmsbcan initially be specified by the user and they should be disjoint sets.
by default mspandmsb are empty sets.
if mspcontains all modules used by the application the feedback driven analysis will be equivalent to running the normal whole program static analysis and if mspis empty we do not analyze any third party modules.
determining the right msp andmsbsets manually can be difficult.
therefore we design a feedback driven analysis to automatically update these sets.
algorithm feedback driven analysis inputs mspandmsb results nu ll while haschan ed msp do results extendedtajs msp msp msb processanalysisresults results msp msb end while report results .taintflows algorithm shows the main feedback loop of our analysis.
this algorithm takes mspandmsbas inputs and reports taint flows.
the loop continues until mspreaches a fixpoint.
at each iteration we run an extended version of the standard analysis in tajs4.
we extend the module loader to load only modules that belong to msp.
at the end of each iteration we process the analysis results by running the algorithm shown in fig.
for each third party module in the application dependency tree including transitive dependencies .
this algorithm performs heuristics to update msp andmsbsets at the end of each iteration.
if these sets are modified we run the extendedtajs analysis again using the updated msp.
fig.
is described in detail in section .
.
.
extending the static analysis in tajs in this section we describe our extensions to the abstract domain in tajs how the module loader is modified to approximate modules that are not in msp and changes to the underlying analysis in tajs to handle values that originate from approximated modules.
abstract domain extension .
fig.
shows the extensions added to the abstract domain in tajs.
we extend abstract values and abstract objects with a taggingwrapper set.taggingwrapper consists of tagging which provides additional information about the origin of an abstract value.
tagging can have three values module m specifies that the abstract value originates from module m sideeffect m specifies that module mmight have caused sideeffects on the abstract value which have been unsoundly ignored because we ignore side effects for approximated modules and imprecisewrite m specifies that an abstract value v is written in an imprecise dynamic property write i.e.
o vwhere pis approximated due to not analyzing m. joining and propagating taggingwrappers .taggingwrappers are joined by set union and all built in models are updated to propagate taggingwrappers .
4feedback driven analysis is applicable for other abstract interpretation frameworks such as safe .
5note that the extendedtajs analysis does not reuse analysis results from the previous iterations.
457esec fse august tallinn estonia benjamin barslev nielsen behnaz hassanshahi and fran ois gauthier m module name sl source code location b true false value value p taggingwrapper obj obj p taggingwrapper taggingwrapper tagging b b tagging module m sideeffect m imprecisewrite m taint sl figure extensions to the abstract domain in tajs.
highlighted parts are taint extensions introduced in section .
updated module loader .
before loading a third party module m line in listing the updated module loader checks if mis inmsp.
ifmis in msp it is analyzed otherwise it is approximated with the tagging module m .
note that node.js built in modules are always analyzed.
1var m require m 2var obj 3m.f function g obj.a g 6obj.a rest of application listing approximating callbacks.
calls to approximated functions .
to understand how the analysis handles the values passed to the modules that are not analyzed consider the code snippet in listing .
in this example because m is not in msp it is not analyzed i.e.
the value of the variable mis approximated.
if we do not analyze the call to the callback function passed as argument to m.fat line we get a definite type error6 at line because obj.a isundefined and the dataflow to the rest of the application will be missed.
therefore the analysis analyzes the call to the callback function with an approximated argument g labeled with the same tag used for m.f which is the same tag used for m7.
next the approximated value is written to obj.a at line and the type of obj.a at line is resolved to a value of any type including function.
as a result the analysis is able to continue analyzing the rest of the application.
next we show how the feedback driven analysis uses the new extension to the abstract domain to identify the modules that should be analyzed i.e.
included in msp.
6all abstracted executions end in a typeerror .
7module m m m msb m msp timesout m msp msp m msb msb m getimprecision m msp msp m hassideeffect m causetypeerror m isintaintflow m no yes no yes yesno yes no yes figure flowchart for post processing analysis results.
rectangular boxes indicate modifications to msbormsp while the other boxes indicate predicates used by our heuristics.
post processing terminates for an input module m when there is no transition to follow.
.
post processing analysis results at the end of each iteration in algorithm we post process the analysis results to determine whether the module sets mspand msbshould be modified as depicted in fig.
.
recall that this is done for each third party module in the application dependency tree including transitive dependencies .
given a module m if it is inmsb we end the post processing step for this module because modules are never removed from msb.
ifmis not in msb but in msp we check if mhas been too expensive to analyze.
the predicate timesout m is satisfied when mhas taken a large fraction of the analysis time.
in this case mis moved from msptomsb.
ifmis neither in msbnor in msp we apply heuristics to determine whether mshould be added to msp.
the first heuristic is a precision heuristic which checks if not analyzing a module results in a large precision loss.
in this heuristic the function getimprecision m returns the number of source locations in which theimprecisewrite m tag see fig.
is read.
if this number exceeds the preconfigured threshold mis added to msp.
otherwise we apply our side effect heuristic.
the predicate hassideeffect m causetypeerror m checks whether a sideeffect m tag ends up in a 458nodest feedback driven static analysis of node.js applications esec fse august tallinn estonia definite type error.
if that is the case we add mtomsp.
the last predicate isintaintflow m is related to the taint analysis which is used as a client analysis in this paper and is explained in section .
to better understand the side effect heuristic consider the codesnippet in listing which uses the setprototypeof module to set the properties of the router object to the proto object.
the program imports the module setprototypeof defines a function and writes it to the proto variable from lines to and adds a property to proto at line .
from lines to the function router is defined and the function setprototypeof is called with router and proto passed as arguments.
this function call adds proto to the router object s prototype chain which makes the properties of proto accessible through the router function object.
in this example the router.handle function called at line is the function proto.handle defined at line .
if the analysis fails to resolve router.handle correctly it stops due to a definite type error at line .
now we explain how our feedback driven approach handles this example.
initially the setprototypeof module is not included in msp.
because setprototypeof is approximated the analysis does not analyze it at line .
instead it adds a side effect tag8 to the router and proto objects.
the router function is returned at line and because we do not overapproximate side effects of setprototypeof when the router function is called the analysis cannot resolve router.handle and the side effect tag ends up in a definite type error.
therefore setprototypeof is added to mspto be analyzed in the next iteration.
1var setprototypeof require setprototypeof 2var proto module.exports function function router req res next router.handle req res next setprototypeof router proto return router 9proto.handle function handle req res next ... listing side effect heuristic example.
termination of feedback driven analysis .
our feedback driven analysis in algorithm is guaranteed to reach a fixpoint.
each iteration is guaranteed to terminate because the underlying analysis extendedtajs is guaranteed to terminate and processanalysisresults runs in linear time with respect to the modules used by the application.
there is an upper bound for the number of iterations in the feedback loop in algorithm and because each iteration terminates the entire algorithm is guaranteed to terminate.
note that mspis modified in each iteration but a module is added to mspat most once during the entire feedback driven analysis when a module is moved from msptomsb it remains in msbuntil the end of the analysis.
assuming that the number of third party modules used by an application is n at most nmodules can be added tomsp resulting in at most niterations.
in iterations where no modules are added to msp and msphas not reached a fixpoint a module is moved to msb.
note that at most nmodules can be 8sideeffect setprototypeof added to msb resulting in at most nextra iterations.
therefore our feedback driven analysis is guaranteed to terminate after at most 2niterations.
algorithm optimized worklist algorithm in tajs input add the initial node and context n c to the worklist wlphase ordinary postponedworklist visitationcounter while worklist not empty do remove node and context n c from worklist ifwlphase max cov then ifvisitationcounter.get n c then add n c to postponedworklist continue end if visitationcounter.count n c end if analyze n c forall successors n ofndo ifpropagate n c then add n c to worklist end if end for ifworklist empty and wlphase max cov then worklist postponedworklist empty postponedworklist wlphase ordinary else if wlphase ordinary and switchphase then visitationcounter.reset wlphase max cov end if end while .
optimized worklist algorithm to scale the static analysis to node.js applications and increase code coverage in addition to the feedback driven analysis discussed in this section we design an optimized worklist algorithm that aims to increase the coverage of worklist items before the analysis times out.
this is done by introducing a new phase in the worklist algorithm as shown in algorithm .
in this new phase if a n c pair is visited more than times it is postponed to be processed in the ordinary worklist phase.
when the worklist is empty the ordinary worklist phase continues with the postponed worklist items.
the highlighted parts of algorithm show the new extensions to the standard worklist algorithm in algorithm .
the algorithm is performed in two phases ordinary and max cov .
the current phase is stored in wlphase which is initially set to ordinary line .
postponedworklist line is a list containing worklist items that have been postponed during the max cov phase.
visitationcounter line is a map from n c to an integer number describing how many times n c is visited in the current max cov phase.
during themax cov phase lines to make sure that a n c pair is not analyzed more than times.
lines to switch between the 459esec fse august tallinn estonia benjamin barslev nielsen behnaz hassanshahi and fran ois gauthier ordinary and max cov phases lines to switch from max cov toordinary when the worklist is empty and postponedworklist is assigned to the ordinary worklist to be processed later in the ordinary phase lines to switch from ordinary tomax cov based on the analysis execution time making sure that multiple phases of max cov are performed before the analysis times out.
static taint analysis in this section we explain how our feedback driven analysis can be extended to perform static taint analysis as a client analysis.
.
incorporating taint analysis to support taint analysis we make slight modifications to the abstract domain section .
and add one more heuristic to the postprocessing algorithm in our feedback driven analysis.
abstract domain extensions .
the highlighted parts of fig.
show the modifications needed to support static taint analysis.
taggingwrapper is extended with two boolean flags the first one indicates whether the value is tainted or not and the second one indicates whether the value is a sink.
to understand why we need these additional flags consider the code var x require m .f eval where mis neither a taint source nor sink.
the value returned from require m .f eval might be a taint sink because eval is a sink.
however the tag present in the return value would still bemodule m .
therefore by adding these flags we can precisely distinguish which abstract values originating from mmight be taint sources or sinks.
we also added the tagging type taint sl specifying that the value is tainted by a taint source located at the source location sl.
post processing extension .
to make sure we do not miss any taint flows because of not analyzing a module in the feedback driven approach we use the last heuristic taint heuristic in the postprocessing step as shown in fig.
.
the taint heuristic adds a module mtomspwhen isintaintflow m predicate holds.
intuitively we add mtomspif it is either the source or the sink in a taint flow.
therefore the predicate holds in two cases mis the sink a tainted value flows to a sink with the tag module m or mis the source a tainted value with the tag module m flows to a sink and the sink is not approximated due to not analyzing a different module.
.
taint analysis configuration we perform a syntactic analysis that identifies sources and sinks in the application and third party modules using method signatures.
the source and sink definitions are provided as configurations by the user.
for instance if eval is marked as a sink the syntactic analysis looks for occurrences of eval in the source code files.
it analyzes all files that are reachable through require function calls where the argument is a constant string.
if the syntactic analysis does not find any taint sources or sinks in a module mor its dependencies loading module mwill yield an approximated value tagged with module m false false which indicates that the approximated value is neither a taint source nor a sink.
.
revisiting the motivating example in this section we show how our feedback driven analysis extended with taint analysis finds the taint flow in listing .
in this example our syntactic analysis marks the http request object allocated through the express module as source and mongodb as sink.
initially mspis empty so third party modules added between lines to are approximated and msbcontains mongodb .
in the first iteration of the analysis express is not analyzed therefore appat line is approximated.
because tainted data enters the application from the express module it is labeled with a taint tag.
at line app.get req and resare all approximated and labeled with the same tag as app9.
the reqobject flows to the variable q ultimately reaching mongo.collection.find .
this flow indicates that a tainted value has reached a sink.
because of the taint heuristic discussed earlier in this section express the approximated module from which the taint tag is originated is added to msp.
in the next iteration of the analysis mspcontains express .
to simplify this example we skip the iterations where the analysis adjusts the mspandmsbsets to analyze the express module.
in the last iteration mspcontains the necessary modules to precisely identify that reqis an http request object so req.query.val is tainted.
asreq.query.val flows to mongo.collection.find a taint flow is reported from an incoming http request to a nosql sink.
evaluation we implemented our feedback driven static taint analysis of node.js applications in a tool called nodest .
to evaluate our technique we used a windows machine with an intel core i5 cpu .
ghz and a jvm with 10gb memory.
we use the benchmarks from which are the existing program analysis frameworks for node.js that detect injection vulnerabilities.
we also analyze two more express based applications mongo express and ankimedrec which have not been analyzed by previous works.
we have responsibly disclosed all the new vulnerabilities found by nodest to the developers.
the benchmarks from have small test drivers for npm modules applications that exercise injection vulnerabilities.
we use the test drivers for some of these benchmarks in our evaluation.
for applications that depend on networking libraries such as the http module we do not need the test drivers because our analysis overapproximates all the incoming requests.
our evaluation answers the following three research questions rq1 can static taint analysis detect taint flows in simple node.js modules with high precision?
rq2 isnodest able to improve the scalability of a whole program static taint analysis without missing any known taint flows?
rq3 how important is the optimized worklist algorithm for scaling static analysis of node.js applications?
.
rq1 precision we will answer the first research question by comparing our static analysis with prior dynamic analysis works that detect taint flows.
the static analysis in this experiment is the whole program analysis in tajs extended with taint support.
we use the benchmarks module express true false 460nodest feedback driven static analysis of node.js applications esec fse august tallinn estonia table results for whole program analysis of module benchmarks.
analysis timeout is five minutes.
module no fn no fp reached fixpoint os uptime chook growl reporter growl os env fish mlog node os utils gm mongo parse mongoosify x x printer kerb request mixin pro pidusage modulify x x system locale mol proto x x libnotify pomelo monitor systeminformation node wos git2json office converter mongoosemask cocos utils from that are modules not applications for this experiment as well as the benchmarks used in .
all the benchmarks from contain at least one known vulnerability.
we exclude the modules in which exploiting the vulnerability requires interaction with the filesystem.
the benchmarks contain both vulnerable and benign npms.
the latter are used to test precision.
table shows that nodest finds the vulnerabilities in out of modules and does not reach a fixpoint in the remaining .
the analysis does not report false positives in any of the benchmarks.
these results indicate that static analysis is suitable for detecting taint flows for node.js modules because the analysis reaches a fixpoint for almost all of these benchmarks and has high precision.
.
rq2 scalability and accuracy to answer the second research question we use those benchmarks from that are applications most of which depend on the express framework.
we also test against mongoosify and modulify which are two of the three modules that could not be analyzed by the whole program analysis in table .
we do not include the third module because it has no dependencies.
furthermore we evaluate our technique on one application from nodegoat v1.
and two new applications ankimedrec and mongo express .
all of these applications are based on express and use a mongodb database .for the express based applications we have added a couple of source code transformations to remove unsupported es6 features .
alternatively we could have used an existing source code transformation tool such as babel to analyze such features.
we chose not to invest time setting up babel since very few locations required transformations.
using babel instead should not affect the analysis results.
moreover we have annotated a couple of functions in express to enable additional parameter sensitivity .
note that the underlying abstract interpretation analysis could be improved to avoid such transformations however the goal of this evaluation is to test the effectiveness of our feedback driven analysis.
therefore we use the underlying analysis as it is.
feedback driven analysis setup .
the feedback driven analysis presented in section relies on the following configurations msp is initially empty except for mongoosify and modulify for which mspis defined as mongoosify and modulify respectively because they require test drivers to exercise the injection vulnerabilities.
msbis initialized with the following database modules whose apis are used as taint sinks mongodb monk and sqlite3 .
after the analysis runs for more than seconds the timesout m predicate in fig.
is triggered if a file in mspends more than of the analysis time.
for the precision predicate in fig.
getimprecision m we use .10we use 2in algorithm and switchphase triggers three times after and seconds.
note that these parameters have been chosen by one or two trial and errors and they are not tuned to our benchmarks.
we do not expect slight perturbations of these parameters to affect the analysis results significantly.
feedback driven analysis results .
table shows the results of running nodest with a minute timeout for each analysis iteration.
note that the analysis might terminate before reaching the timeout if any of the post processing heuristics are satisfied.
identifying module sets is the time spent to identify the module sets and analysis time is the execution time for the last iteration in which analysis is performed on the final version of module sets module sets do not change in this iteration .
installed modules is the number of third party modules that are installed11during the installation of the application.
msp is the size of mspafter reaching a fixpoint.
eval exec and nosql indicate the number of true positive and false positive taint flows found for eval require child process .exec and nosql sinks provided by the database modules respectively.
we manually investigated the reported flows to determine whether they are true positives.
however the true positive taint flows might not be exploitable due to non trivial sanitization.
nodest is able to find taint flows in benchmarks.
we can also see that nodest does not report any false positives for these benchmarks.
even though the analysis does not reach a fixpoint in the final iteration in applications it is still able to report true positive taint flows.
as shown in this table identifying module sets formodulify takes no time.
the reason is that the taint flow in this application involves only its main module which is included in mspinitially and the rest of the modules that are not analyzed are 10we have observed that lower thresholds can trigger at local precision losses as compared to the precision loss spread throughout the application .
11we use npm ls prod to count the number of unique modules.
461esec fse august tallinn estonia benjamin barslev nielsen behnaz hassanshahi and fran ois gauthier table results for feedback driven analysis of node.js modules applications.
applicationidentifying module sets hh mm ss analysis time mm ss installed modules msp eval tp fpexec tp fpnosql tp fp nodegoat times out keepass dmenu ankimedrec times out mongui times out codem transcode times out mock2easy times out mongoosify modulify mongo edit times out mongo express times out mqtt growl total not affecting the taint flow.
therefore the modules in mspdo not need to change.
comparing the number of installed modules with the size of mspafter reaching a fixpoint we see that our feedbackdriven analysis skips analyzing many modules which makes our analysis more scalable.
as an example by installing mongui modules are installed which are too many for a static analysis tool such as tajs to scale.
nodest is able to identify modules msp out of these modules that are sufficient to detect the taint flows.
furthermore there is no direct correlation between the time spent to identify module sets and the size of mspafter reaching a fixpoint.
the reason is that the duration of each iteration might vary a lot across different benchmarks.
feedback driven vs whole program analysis .
next we compare nodest with the whole program analysis in tajs on the same benchmarks to determine if the feedback driven analysis improves the scalability without missing taint flows.
results for the whole program analysis can be seen in table .
the timeout in this experiment is minutes.
this table shows that the whole program analysis only reaches a fixpoint in one application note that nodest reaches a fixpoint in .
we also observe that the whole program analysis only finds taint flows in applications whereas nodest finds taint flows in applications.
all the applications except for mqtt growl in which the whole program analysis finds taint flows has at most installed modules indicating that scalability of the whole program analysis is correlated with the size of the application.
the whole program analysis finds a strict subset of the taint flows found by nodest which indicates that the feedback driven analysis does not introduce any false negatives even though it skips the analysis of some modules.
therefore we conclude that our feedback driven analysis is able to improve the scalability of the underlying static taint analysis without missing any known taint flows.
xss injection vulnerabilities .
because some of our benchmarks are express based web applications where reflected xss12is common we also conducted experiments to see if nodest is able to 12in a reflected xss attacker controllable input that comes through an http request is sent back to the client side through an http response.table results for whole program analysis.
applicationanalysis time mm ss eval tp fpexec tp fpnosql tp fp nodegoat times out keepass dmenu times out ankimedrec times out mongui out of memory codem transcode times out mock2easy times out mongoosify times out modulify times out mongo edit times out mongo express times out mqtt growl total detect xss injection vulnerabilities.
the taint source for xss vulnerabilities is http request object and sinks are http response functions.
in an express application sources are created in the framework and sinks are often used both in the framework and application.
therefore express applications are likely to have common taint flows.
to distinguish such results manual investigation is required.
below we summarize our findings for this category of vulnerabilities.
nodest reports xss taint flows in six applications which are all introduced by express .
in these taint flows the attacker controllable input enters the application through req.query.url and is sent back to the client side through res.end if the request is invalid.
however the tainted value is sanitized so it might not be exploitable.
we also found other unique true positive xss taint flows in four applications.
except for one application the rest of the taint flows are not sanitized.
nodest reported false positive taint flows infeasible dataflow for only one application.
the average time for inspecting and classifying the analysis results for xss vulnerabilities was around to minutes.
new taint flow reports .nodest is able to find new taint flows that are not reported by existing tools.
it reports multiple eval 462nodest feedback driven static analysis of node.js applications esec fse august tallinn estonia table taint flows found using feedback driven fd and whole program wp analysis without optimized worklist.
eval exec nosql application fd wp fd wp fd wp nodegoat keepass dmenu ankimedrec mongui codem transcode mock2easy mongoosify modulify mongo edit mongo express mqtt growl total vulnerabilities in mongui which are not exercised and reported by existing dynamic analysis tools .
in general it is known that static analysis can achieve better coverage compared to dynamic analysis because the latter requires specific inputs at runtime that exercise these taint flows to be able to report them.
furthermore all the nosql and xss taint reports except for nodegoat13are new and have not been reported before.
apart from affogato nodest is the only tool that detects nosql and xss taint flows.
.
rq3 optimized worklist algorithm to answer the third question we performed the experiments in rq2 without using the extended worklist algorithm see section .
.
table shows the reported taint flows for the feedback driven analysis fd and the whole program analysis wp in both of which the optimized worklist algorithm is disabled.
note that the optimized worklist algorithm makes no difference in reaching a fixpoint in our benchmarks.
as shown in table without using the optimized worklist the feedback driven analysis reports taint flows sum of fd columns while the whole program analysis reports flows sum of wp columns .
on the other hand using the optimized worklist helps the feedback driven analysis to report taint flows see table while the whole program analysis reports flows in total see table .
therefore we conclude that the optimized worklist algorithm improves the scalability of static taint analysis of node.js applications by increasing coverage and reporting more true positive taint flows.
case studies in this section we describe two case studies to show how our feedback driven analysis is able to find non trivial taint flows in complex node.js applications.
in the first case study both the source and sink are in third party modules i.e.
in the code not analyzed in the first iteration of the feedback driven analysis section .
.
the second case study shows an example of a complicated taint flow which depends on multiple requests and a specific timing between 13the deliberately vulnerable application from owasp .these requests which motivates the use of static instead of dynamic analysis section .
.
1var mqtt require mqtt growl require growl require underscore 4growl .throttle growl 5mqtt.f function message growl message underscore.js .throttle function func return function func.apply this arguments listing simplified version of mqtt growl.
.
mqtt growl listing shows a simplified version of mqtt growl which has a remote code execution vulnerability attacker controllable input reaches an exec sink .
this code snippet is simply importing three third party modules from lines to mqtt growl and underscore and the rest of the code does not have any sources or sinks hence does not seem to be vulnerable in the first look.
however by combining these three modules it enables an exploitable taint flow starting from a source in mqtt passing through underscore and finally reaching a sink in growl .
our feedback driven analysis goes through four iterations to identify all the modules that need to be analyzed and detect the vulnerable taint flow.
initially all the three third party modules from lines to are approximated not analyzed .
note that even though mqtt and hence mqtt.f from line to is approximated the callback function passed as argument is called by the analysis and analyzed with approximated argument message .
therefore line is reachable in all the iterations.
the first iteration adds underscore tomsp the set of modules that need to be analyzed because it has caused growl message at line to be approximated while this function call is potentially part of a taint flow see the taint heuristic in section .
the second iteration adds the growl module to msp because by analyzing underscore the analysis reaches line where func is approximated due to not analyzing growl and arguments is tainted.
in the third iteration the call to func at line is resolved to the growl function object and analyzed.
now the tainted value passed to growl is approximated because of not analyzing mqtt which includes the taint source message .
the tainted value flows to an exec sink and therefore mqtt is identified to be potentially part of a taint flow and added to msp.
finally in the fourth iteration the analysis reports a taint flow from a source in mqtt to the exec function in growl .
.
codem transcode codem transcode is a video transcoder which receives requests through a simple http api.
the application has a xss vulnerability which depends on multiple requests and a specific timing 463esec fse august tallinn estonia benjamin barslev nielsen behnaz hassanshahi and fran ois gauthier between these requests.
static analysis is suitable for finding this vulnerability because it overapproximates all possible orderings of incoming requests.
nodest is the first tool that reports this vulnerability.
the application has a route for posting jobs post jobs and a route for getting all the jobs that are registered but not completed get jobs .
1var slots post jobs 3postnewjob function request response var postdata request.on data function d postdata d request.on end function processpostedjob postdata 8processpostedjob function postdata var job job.create json.parse postdata slots.push job ... get jobs getjobs function request response var content jobs slots response.end json.stringify content utf8 listing simplified version of codem transcode .
a very simplified version of the implementation is shown in listing .
lines to define the function that is called upon receiving a post request to jobs route.
this function registers event listeners on the request object.
it uses the data event to collect the data.
once all data is received i.e.
the endevent is triggered it calls processpostedjob postdata to create a new job jobobject forpostdata .
note that postdata is tainted because the attacker can control it through http requests.
the code not shown in processpostedjob actually processes the job asynchronously and upon finishing the job removes it from the slots array.
each jobobject that is processed but not finished yet can be retrieved by a get request to the jobs route which is handled through the function defined from line to .
as it can be seen this function reflects back the tainted data to the client side making the application vulnerable to an xss attack.
this example shows the advantage of using static analysis over dynamic analysis as the latter requires a test driver to trigger this behavior while our analysis is able to find this taint flow by overapproximating the incoming requests and their orders.
related work static analysis for javascript has a rich history and different static analysis frameworks have been developed over the years.
because of its highly dynamic nature however the javascript language is very difficult to analyze both precisely andefficiently.
in this work we presented an approach to scale static analysis for javascript and enable precise taint analysis of node.js applications.
static analysis of javascript .
in order to be practical most if not all static analysis frameworks for javascript allow for precision and scalability trade offs through context field heap and loop sensitivity tuning .
when sensitivity tuning reaches its limit however auxiliary strategies have to be used to achieve acceptable precision and scalability.
for example the work by madsen et al.
specifically addresses the issue of computing points to analysis for javascript applications that depend on complex frameworks and libraries.
to avoid the need for manually written stubs their approach performs a use analysis that automatically infers points to specifications.
the work in addresses the challenge of scaling points to analysis for javascript through correlation tracking a lightweight pre analysis that identifies field reads and writes that must refer to the same property.
using correlation information the subsequent points to analysis avoids introducing spurious points to edges which leads to a sparser points to graph.
in a constant quest to overcome the scalability challenges of javascript analysis others have developed hybrid analyses where the core static analysis uses dynamic information to restrict its search space often at the cost of soundness.
wei and ryder coined the term blended analysis to designate static analyses that use some dynamic analysis results as part of their computation.
the work in uses dynamic analysis to resolve calls to eval and to build a call graph that is then used by a static taint analysis .
similarly tripp et al.
use concrete location referrer url domelement values to perform partial evaluation that enables more precise string and taint analyses.
while the aforementioned works all focused on javascript code embedded in web pages the work in specifically targets javascript web applications and proposes the use of execution environment snapshots as a lighter alternative to dynamic trace collection to inform the subsequent static analysis.
on the other hand andreasen et al.
used blended analysis to pinpoint root causes of imprecision and the work in proposes to use dynamic information after the static analysis to help pinpoint and fix root causes of imprecision and to specialize the analysis to the code of interest.
compared to these works while our approach is not sound its unsoundness is more principled than relying on concrete executions hence gaining better coverage.
taint analysis for javascript .
previous work on static taint analysis for javascript relied either on points to analysis or on information flow tracking .
to the best of our knowledge this is the first paper on abstract interpretation based taint analysis for javascript.
other work has also explored dynamic taint analysis approaches to circumvent the precision and scalability challenges of static analysis at the cost of completeness.
conclusion we have presented a feedback driven static analysis that improves the scalability of an existing state of the art whole program static analysis for node.js applications.
by automatically identifying the third party modules of an application that need to be analyzed we detect taint flows in critical modules.
we evaluated our tool nodest on existing benchmarks and additional real world node.js applications.
the results show that our feedback driven static analysis scales well and is able to find previously known and new zero day injection vulnerabilities with high precision.
nodest can statically analyze real world applications that no other static analysis tool has been able to analyze before.
in particular it is able to analyze the express framework and report non trivial taint flows.
464nodest feedback driven static analysis of node.js applications esec fse august tallinn estonia