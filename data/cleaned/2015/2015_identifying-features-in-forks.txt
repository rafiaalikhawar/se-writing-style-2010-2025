acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. zhou et al.
the goal of our work is to identify and label cohesive code changes features among changes in forks to provide a compact overviewoffeaturesandtheirimplementations.thisisastepto establish an overview of development activities in various forks of a project.
in contrast to github s network view we deemphasize commits which frequently have unreliable descriptions and frequently are unreliable indicators of cohesive functionality asit is common that commits tangle code of multiple features and even morecommon thata single featureis scatteredacross multiple commits .
instead we cluster changed code based on relationships and dependencies within those code fragmentsandlabeleachfeaturewith representativekeywords extracted from commitmessages code and comments.technically we take inspirationfromclusterchanges tountanglecodechanges during code review based on a graph of code dependencies andrepurpose the idea for our problem furthermore we incorporatecommunity detection techniques to refine an initial clusteringand information retrievaltechniques for derivingconcise labels see fig.
1b .
weimplementedouranalysisintheinfoxtool1thatproduces web pages describing the features in individual forks and across multipleforksofac c projectasillustratedinfig.
.inamixedmethodsevaluation wedemonstrate thatinfoxiseffectiveat identifying features among changes in open source projects with a median accuracy of percent that infox s technical innovations improve clustering accuracy over an existing state of the art technique designed to cluster individual commits and that the produced overview provides useful insights for contributors and maintainers of projects with many forks.
to summarize we contribute a infox an approach and corresponding tool which automatically identifies and summarizes featuresinforksofaproject usingsourcecodeanalysis community detection andinformation retrievaltechniques and b evidence thatinfoximprovesaccuracyoverexistingtechniquesandprovides meaningful insights to maintainers of forks.
while infox currently aims at supporting exploration and navigation by summarizing features it lays a foundation for future interactivetoolsupportthatcanrefineandpersistfeatures e.g.
for a product line platform and support developers in merging selective changes across forks e.g.
generating pull requests .
monitoring forks in practice github smainfacilitytonavigateforksisthenetworkview whichvisualizesthehistoryofcommitsovertimeacrossallbranches and forks of a project.
this cross fork visualization provides transparencytodeveloperswhowanttotrackongoingchangesbyothers wanttoknowwhoisactiveandwhattheyaretryingtodowiththe code .
for example one of the developers we have interviewed said i check the more updated forks.
i think this view is helpful because i am not gonna look at all forks.
is a lot probably this projecthasthousands thatwillberidiculous.iwillneverdothat .
1infox is short for identifying features in f orks.
source code is publicly available at a lightweight web service is available at forks insight.com.althoughthenetworkviewisagoodstartingpointtounderstand how the project evolves it is tedious and time consuming to use if aprojecthasmanyforks.inordertoseeolderhistory usersclick and drag within the graph and if users want to see the commit information they hover the mouse over each commit dot and read the commit message.
also they have to scroll back a lot to find theforkpointandthengototheendagainforseeingwhatchanged sincethenintheparentandinthefork .ifdeveloperswantto investigatethecodechangesofcertainforks theyhavetomanually openand checkeachfork.
asonedeveloper stated idon t lookat the graphs on github... it is very hard to find the data you haveto scroll for minutes to find stuff .
the view does not even loadwhenthereareover1000forks nomattertheyareactiveor inactive.
subsequently itisdifficultfordeveloperstomaintainanoverview of forks which can lead to several additional problems redundant development unaware of activities in other forks developers may reimplement functionality already developed elsewhere.
st nciulescu et al.
report that in an open source project 14percentofallpullrequestswererejectedbecauseofconcurrent development .
redundant development further leads to merge conflicts which would demotivate or prevent developers from continuously contributing to the repository and significantly increases the maintenance effort for maintainers .adeveloperweinterviewedforthispaperdescribedthe problemasfollows ithinktherearealotofpeoplewhohavedone work twice and coded in completely different coding style .
lost contributions developers may explore interesting ideas fix bugs oraddusefulfeaturesinforks butunlesstheycontribute thosechangesbacktotheoriginalproject thosecontributionsare easily lost to the larger community.
even though contemporary social codingplatformslistallknownforks seefig.
project maintainers are unlikely to identify interesting contributions among the thousands of forks many open source projects attract.
furthermore even when a feature of interest is identified in a fork because of independent development in each fork it can be difficult to port features from one fork to another .
a frequentlymentionedcomplaintisthatforksrarelychangethe readme file to describe what the fork changes.
suboptimalforkingpoint withoutanoverviewofforksandtheir different contributions developers might not fork from the code basethatisclosesttotheirintendedgoals.dubinskyetal.report that in industrial fork based development projects developers often struggle to identify which of multiple existing forks to select as a starting point .
there are many different reasons to fork a project adding a feature fixingabug preparingapullrequest continuinganabandoned project customizing or configuring the project to create a variant or making a private copy .
in fact many forks of a project tend to be inactive.
for example one of the subject systemsinourstudy smoothieware has623forksintotal ofwhich89forks performed unique non merged code changes of which were active within the last months.
to an observer the function of a fork and its activity level is difficult to identify somebody looking forinterestingactivities e.g.
forksdevelopingfeatures fixingbugsorexperimentingwithcode willoftenhastonavigateallforks.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
identifying features in forks icse may june gothenburg sweden githubhas notaddressed theincreasingissue withnavigating manyforksdespitemanyfeaturerequests .externaldevelopers haveexploredonlyverybasicimprovements mostnotablyaweb browserextensionthatshowsthemoststarredfork forthecommon usecaseofidentifyinganactiveforktoanabandonedproject .in our user study we learned there are mainly two ways practitioner currently use to find interesting forks developers either look at forks they know about and go through the fork s commits and commitmessages e.g.
idocompareonebranchtoanother or usegoogleandgithubtosearchforparticularkeywords.searching is mentioned by several participants as the preferred choice e.g.
i usually will use google but set to only look inside github .
inthiswork wesuggestamoresystematicapproachtocreatean overview of forks that identifies the changes in each forks clusters them into features and provides concise descriptions through a set of characteristic keywords.
infox infoxidentifiesandlabelsfeatureswithinalargerchangeofafork.
it takes the diff between the latest commit of the upstream source snapshot and the latest commit of the fork target snapshot from github whichreturnsthenon mergedchangesfromfork.2then it proceeds in three steps as shown in fig.
identifyadependencygraphamongalladdedorchangedlines ofcode byparsingand analyzingthe codeformultiple kindsof dependencies sec.
.
.
clusterthelinesofthechangebasedonthedependencygraph using a community detection technique mapping each line of codetoafeature suchthatlineswithmanyconnectionsinthe dependency graph are mapped to the same feature sec.
.
.
labeleachclusterbyextractingrepresentativekeywordswith an information retrieval technique sec.
.
.
the first step is inspired by clusterchanges an approach to untanglecodeincommitsforcodereview .clusterchanges clusters changed code fragments based on a dependency graph of linesofcode.weadoptthisideaforadifferentpurpose identifyingandnamingfeaturesinmultipleforksratherthanuntangling changesinasinglecommit andweextendtheapproachwithaddi tionalkindsofdependencyedges additionalstepsintheclustering process and labeling of clusters as we will explain.
.
generating a dependency graph we generate a dependency graph for all lines of code of the target snapshotbyparsingthetargetsnapshotandanalyzingtheresultingabstractsyntaxtree.weaddedgesbetweenlinesforseveralkindsofrelationshipsofcodefragmentswithinthoselinesthatmayindicate that the two fragments are that are more likely to be related.
we collectthefollowingkindsofdependencies whichwealsoillustrate on a simple excerpt of an email system in fig.
definition usage edges we add edges between the definition and use of functions and variables in the program and the definition anduseofstructsorclassesandtheirmembers.weconjecture that def use relationships between two code fragments often 2whiledevelopedforchangesinasinglefork ourapproachcanbetechnicallyused toclusterthechangesbetweenanytwocodesnapshots includingtwocommitsina single repository or two copies of code maintained without a version control system.
!
!
figure generating and clustering dependency graphs to identify features and labeling features.
pointtotwocodefragmentsthatfulfillajointpurposeandare thus more likely to be part of the same cohesive change in a larger change.
control flow edges we generate a control flow graph for the sourcecodeandaddedgesbetweentwolinesifthereisacontrol dependency relation between the statements of each line.
in line with emerson s cohesion metrics we think that the flow of control information contributes to the cohesion of code changes.
adjacency and hierarchy edges we add edges between consecutive lines and lines that represent hierarchical structures in thesourcecode struct classmemberspointtotheouterstruct definition .adjacencyedgesandhierarchyedgesrepresentthe structure of the source code and indicate that code fragmentsthat are located close to each other are more likely to belongto the same cohesive fragment than code fragments scattered across different places.
the result is a labeled weighted undirected graph in which nodes represent lines of code and edges represent the identified dependencies listed above.
we assign a low weight of for adjacency edges andaweightof5forallotheredges.intuitively semanticde pendenciesintheprogramshouldbestrongerindicatorsoffeatures than structural relations.
we use an undirected dependency graph asourexperimentsshowednobenefitinmaintainingdirectionality.
usingadiffcommandbetweenthesourceandthetargetsnapshot we identify and mark all nodes that have been added or changed in the target snapshot highlighted in fig.
.
comparedtoclusterchanges weaddedgesbetweennodes with hierarchical and control flow relations and add weights.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. zhou et al.
edgesandwithandwithoutsplittingandjoining.
regarding rq2 we observe that splitting joining steps improves accuracy by stat.sign.
p .
.removinganykindofedgesfromthe clustering approach significantly affects accuracy as well p .
all kinds of edges are important for the clustering quality but the definition usage edges are the most influential ones.
.
human subject study rq3 rq4 toevaluatetheusabilityofinfox wecontactedopen sourcedeveloperswhomaintainforkstovalidateidentifiedfeaturesandexplore whether the generated summaries provide meaningful insights.
studydesign.
weinviteddevelopersofactiveforks seeselection below foraremoteinterview.weconductedeachinterviewina semi structured fashion divided into four phases opening and introduction we started each interview by briefly explainingourresearchtopicandthegeneralpurposeofour study.
we asked whether the participants would share their screen with us and whether they consent to screen and audio recording.
validating clustering result rq3 in order to help participants remember what the code changes are and also help us to gain domain knowledge for a better conversation we first asked participantstobrieflydescribetheprojectandcodechanges.subsequently we sent them the clustering result of infox for their own fork as a folder of html files as illustrated in fig.
.
within those results participants could split and join clusters interactively.
we started with an initial clustering result withoutanysplitting andexplainedhowtoreadand navigate the results.
inasubsequentdiscussion wepursuedtwoquestions whether thekeywordsarerepresentativeoftheirfeatureimplementation and whether the clustering of the source code is meaningful to them.
most of the participants were communicative and rightafterspendingsometimelearninghowtointeractwith infox theystartedtonavigateamongcodechanges explaining themeaning ofthecode andwhetherclustersmade senseor not.inlinewithmethodsforthink aloudprotocols weencouraged participants that were interacting with infox without sayinganything for along time to speakout loud asking probingquestions suchas couldyoutelluswhatareyoulooking at?
or would you explain what this code cluster means?
exploring the project overview rq4 before exploring infox s summaryofotherforks wetransitionedthediscussionwith the question do you check what other forks are in this project?
and followed up with questions on how and for what purpose they do this.
afterward we sent them the project overview cf.
fig.
1b and encouraged them to look through the list of forks.
by clicking on the name of a fork theycouldalsoexplorethatfork scodewithinfox sresults just as they previously did for their own fork.
participants were usually actively exploring other forks at this point without our prompting and shared discoveries with us.
when participants explored the code of a fork we asked whether the keyword summary provided them a reasonable approximation of what they found in the implementation.
in addition weopportunistically asked questions about the relevance ofkeywords and the accuracy of clustering results in other forks based on their understanding similar to questions about their own fork previously when it fit the flow of the exploration.
opendiscussionandclosing weconcludedeachsessionwith general and open ended questions about further use cases and suggestions for improvement.
we compensated each participants with a amazon gift card.
the interviews lasted between and minutes.
participant selection.
we searched for projects with active forks using two strategies.
first we used the github search to findprojects written in c c selecting projects with more than 30forks.
second we queried ghtorrent for the c c projects with the most first level forks.
amongtheseprojects weselectedforksthat a hadatleastone commitwithinthelastyear increasingthechancethatintervieweescanremembertheirchanges b haveaddedatleast10linesofcode smaller changes are less likely to be a feature implementation c have a large portion of commits submitted by the fork owner excluding forks that aggregate changes of others and d have a public email address or website of the fork owner.
to enable questionsabouttheoverviewpage weexcludedprojectsforwhich we could not find at least three forks that fit these criteria.
in the end we analyzed projects on github and found projects fit our filtering criteria.
we identified fork owners.
we sent out an email to candidate developers briefly describing our study.weinterviewed11developersfrom7differentprojects responserate13.
.wequicklyreachedsaturationinthatadditionalinterviewsprovidedonlymarginaladditionalinsights.intable2we listthecharacteristicsoftheprojectsfromwhichweinterviewed developers.alldevelopersareexperiencedopen sourcedevelopers.
analysis.
we analyzed the interviews primarily qualitatively analyzing what participants learned and how they interacted with the tool.
two of the authors transcribed and coded the interviews following standard methods of qualitative empirical research .
threatstovalidity.
regardingexternalvalidity ourstudymay sufferfromaselectionbias ascommonforthesekindsofstudies.
many of our participants work on 3d printers which may have differentcharacteristics.however overallwereacheddevelopers from several different domains and did not observe any systematic differences.
finally we focus on open source whereas results may differ in industrial settings in which forks are centrally managed.
regarding internal validity communication issues may have affected some answers we mitigated this threat by refining our interviewguidewhenquestionsraisedconfusionandinvolvedtwo researchersineachinterview.despiteopen endedquestionsand carefuldesign seeabove wecannotentirelyexcludeconfirmation bias inwhichparticipantsmightavoidraisingcriticalpoints we mitigate this by focusing on insights gained not just claims.
results.regarding rq3 clustering quality participants mostly confirmed that the clustering results were appropriate but often fine tunedthemwithfurthersplittingandjoining.thisfurthersup ports the need for interactive tools.
overall participants supported ourdecisiontoclusterchangesinafork.forexample participant p4 said it is necessary to split code changes into pieces even though they cannot be executed in isolation.
of the participants said authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
identifying features in forks icse may june gothenburg sweden table participants of our user study and their projects project forks active forks loc change size loc domain participant marlinfirmware marlin 3d printer p1 p3 smoothieware smoothieware 3d printer p5 p6 p7 grpc grpc general purpose rpc framework p2 timscaffidi ofxvideorecorder multi threaded video recording extension p4 arduino arduino electronic prototyping platform p4 bitcoin bitcoin experimental digital currency p8 p9 p10 ariya phantomjs scriptable headless webkit p11 that infox correctly identified the clusters most of the time althoughtherearesmallclusters containingoneortwolines should havebeenmergedintobiggerclusters.theremainingparticipant pointed out a cluster containing unrelated code that was automatically generated by libraries and should be removed.
aswediscussedearlier infoxprovidesflexibilitytodevelopers by allowing them to split or join clusters interactively.
during the interviews participants compared thesplitting and joining results carefully and after several steps they usually identified clusters that they agreed with.
for example a typical interaction flowed as follows herefromparticipantp5 ithinkthisblueandyellowcluster should belong together.. ..oh so your software correctlyidentifiesallofthisbeingonethingnottwodifferentthings.
theparticipantsidentifiedsomecasesinwhichtheclustering resultcouldbeimproved usuallycausedbytechnicallimitations of the dependency analysis in our prototype see section .
for example when p4 found a line cluster that should belong toanother bigger cluster the participant said i know it is related accelerationandvolumetric arerelated butlookingatjustthesyntaxitisnot itisnotusingthesamewords.addingcheck boxtomanually merge selected clusters could solve this problem .
in summary participants generally agreed that infox could identify correct clusters at certain splitting or joiningsteps rq3 .participantssuggestedthatinfoxcouldprovidemore flexibility for manually refining the clustering result.
even though limited to few participants our interviews corroborate the highaccuracy results from our quantitative study in a realistic setting.
with regard to rq4 overview we looked particularly for signs that developers learned new insights while exploring the overview.
of the participants we showed participants p2 p11 theoverview of forks in their project and gained different kinds of new information from the overview page finding redundant development.
two participants found other forks that are working on the same feature implementation as theydidbefore.whentheyfoundtheseinstancesofredundant development they explored the fork s source code.
for example p3 said it does look like somebody did a very simple one function system.ithinktheyshoulduseourcode thereisgreatreasontouseit.
afterskimmingtheoverviewpage p4said icansee multiple forksare workingon the similarproblem.
thisone looks like it is adding that i already added.
find interesting and potentially reusable feature.
when skimming alltheforks 6participantsidentifiedspecificfeaturesofinterest for example p5 expressed this is all laser stuff this is useful.
whenparticipantsmentionedsomethingisinteresting weasked themwhy.theanswersallidentifyfeaturesthatareimportant totheprojectorthattheycouldreuseintheirownforks suchas p5 s statement if it is only exists in this fork then i want to somehow get this fork into my fork.
beyond these specific actionable insights many participants more generally indicated that this overview would be useful by lookingattheoverviewpage ourparticipantsfoundmanyforks thattheydidnotknowbefore andbyreadingthesummarytableof eachfork theyusuallygottheideaofwhathashappenedineach fork.
for example participant p3 said it is going to make it a lot easiertofindthethingsyouarelookingforasaprogrammer.
andp6 explained i see all the differences for all the forks.
basically it is the samethingiam in the same place i don t have to jump and open tabs to do it.
participantp7expressedinteresttousethetoolforanotherproject he maintained for which he always wanted to know what is going on in forks but was limited by current tools.
regardinglabelsforcodetheydidnotknow wecouldobserve that they clearly gave some initial idea to participants and could typicallydescribewhattheywouldexpectfromtheimplementation.forexample participantp5described the givemesome clues of temperature i know which part of smoothie is modified.
overall allparticipantsthoughttheinterpretationofkeywordsis similar to their understanding of the source code.
in summary even though we interviewed only a small number of participants we found frequent and concrete evidence of new insights gained from the overview page including re dundant development and reusable contributions rq4 .this is encouraging for the usefulness of the approach and its capability to provide actionable insights.
related work transparency in social coding.
transparency in modern social codingplatformshasbeenshowntobeessentialfordecisionmaking infastpacedanddistributedsoftwaredevelopment .visible clues suchasdeveloperactivitiesorprojectpopularity influence decisionmakingandreputationinanecosystem.withthiswork wemakeoften lostcontributionsinforksandbranchestransparent to developers with the aim of reducing inefficiencies in the development process.
forking practices.
before the rise of social coding forking traditionally referred to splitting off a new independent development branch to compete with or supersede the original project.
theright for such hard forks codified in open source licenses was seen as essential for guaranteeing freedom and useful for fosteringdisruptive innovations but hard forks themselves were oftenseenasantisocialandasrisktoprojects .inthe context of modern forking alower bar of forking may encourage developers to maintain multiple variants of a product in parallel authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden s. zhou et al.
often not intended ashard forks.
gousios et al.
exploredgithub s pull request model in which forking is an essential component.
their work confirms that forking provides increased opportunities for community engagement but also highlights that only few contributions are integrated and pull requests arefrequently rejected due to redundant development and missing coordination .
understanding branches and forks.
conceptually closest to our workisbirdandzimmerman sanalysisofbranchesatmicrosoft revealingthattoomanybranchescanbeanissueand what ifanalysistoexplorethecostsofmergingcansupportdecisionmaking .
in addition several studies have studied forking practicesin open source and industrial product line development .
those studies have revealed the discussed problems but did not provide any solutions.
untanglingcodechanges.
technically ourworkrelatestowork onuntanglingcodechanges.originally untanglingcodechanges was driven by biases in mining repositories and predicting defects .barnettetal .
proposedclusterchangestodecompose tangled code changes in order to identify independent parts of changes especially large commits to facilitate understanding during the code reviewing process.
a key assumption is that commits are not always cohesive and reliable.
these approachesoften analyze dependencies within a change and our implemen tation was inspired by and improves upon clusterchanges as discussed and evaluated.
otherstrategieshavebeenexploredtountanglechanges includingsemantichistoryslicing thatcomparestestexecutions andepiceauntangler andthresher which interact with developerswhencommittingachange toencouragemorecohesive commits.
all these approaches are less applicable in our setting as they would require test cases for all added functionality or upfront clean commits by all developers.
in fact herzig and zeller arguethattangledchangesarenaturalandshouldnotbeforbidden we support this view and build tooling that extracts features after the fact but at much larger granularity of differences in forks.
concern location.
concern location or concept or feature location is the challenge of identifying the parts of the sourcecode that correspond to a specific functionality typically formaintenance tasks .
based on a keyword or entry point developers or tools attempt to identify all code relevant for that feature.
concern location typically uses either a static a dynamic or an information retrieval strategy static analyses examine structural information such as control or data flow dependencies whereasdynamic analyses examinethe system s execution .incontrast information retrieval basedanalyses perform some sort of search based on keywords withmoreorlesssophisticatednaturallanguageprocessing .
combinations of these strategies are common .
our analysis has similarities with static concern location approaches but the setting is different instead of identifying code related to a specific givencodefragmentinasinglecodebase weaimatdividingthe difference between two snapshots into cohesive code fragments without starting points.
whereas location usually identifies one concern at a time we identify multiple features in a fork.
at the same time if execution traces or external keywords were available thosecouldlikelybeintegratedintoaclusteringprocesslikeinfox.code summarization.
finally there are many approaches to summarize source code using information retrieval to derive topics from the vocabulary usage at the source code level.
so far we use only a standard lightweight information retrieval technique to identify keywords for clusters but combinations with more advanced summarization strategies might improve results significantly.
discussion and conclusion evidencefrombothacademiaandindustryshowsthatcurrentfork baseddevelopmentispopularbuthasmanypracticalproblemsthat can be traced to a lack of transparency.
because developers do not have an overview of forks of a project problems like redundant development lostcontributionsandsuboptimalforkingpointarise.
to improve the transparency we designed an approach to identify featuresfromforksandgenerateanoverviewoftheprojectinorder to inform developers of what has happened in each active fork.
infoxisafirststepinmakingtransparentwhathappensinforks ofaproject anditcanbeabuildingblockinalargerendeavorto supportfork baseddevelopment suchthatitkeepsitsmainbenefits such as ease of use and distributed and independent development while addressing many of its shortcomings through tool support.
thisnewtransparency mightaddressproblemsincludinglost contributionsand redundantdevelopment.allparticipants inour human subject study had immediate ideas of who might benefitfrom such a tool including the person who maintains the main branch and itissuperusefulforeverybody especiallyformajor main smoothieware developers .
in addition our evaluation has shown that clustering results are accurate on average and labels are meaningful summaries.
atthesametime infoxisjustaninitialprototypewithtechnical limitations and many opportunities for extensions theinitialclusteringstrategyaswellasthecommunity detection algorithm are designed to divide a change into disjoint clusters.
boundaries between features are not always easy to define andfeaturesmayoverlapormaybesplitintosubfeatures.explor ingothernetworkanalysistechniquestoidentifyoverlappedfea turesorsub featuresisaninterestingavenueforfurtherresearch.
although our clustering approach achieved high accuracy results it would be worth to explore additional information that might provide insights about relationships of code fragments even if unreliable generally such as data flow dependencies syntacticorstructuralsimilaritybetweencodefragments code fragments that have been changed together in the same commit or by the same author.
to identify which of these provide useful insights and which just create more noise.