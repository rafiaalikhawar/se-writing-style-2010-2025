reducing combinatorics in gui testing of android applications nariman mirzaei joshua garcia hamid bagheri alireza sadeghi sam malek department of computer science george mason university nmirzaei gmu.edu department of informatics university of california irvine joshug4 hamidb alirezs1 malek uci.edu abstract the rising popularity of android and the gui driven nature of its apps have motivated the need for applicable automated gui testing techniques.
although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing it is often infeasible due to the combinatorial explosion of test cases.
this paper presents trimdroid a framework for gui testing of android apps that uses a novel strategy to generate tests in a combinatorial yet scalable fashion.
it is backed with automated program analysis and formally rigorous test generation engines.
trimdroid relies on program analysis to extract formal specifications.
these specifications express the app s behavior i.e.
control flow between the various app screens as well as the gui elements and their dependencies.
the dependencies among the gui elements comprising the app are used to reduce the number of combinations with the help of a solver.
our experiments have corroborated trimdroid s ability to achieve a comparable coverage as that possible under exhaustive gui testing using significantly fewer test cases.
keywords android software testing input generation .
introduction with well over a million apps android has become one of the dominant mobile platforms .
android app markets such as google play have created a fundamental shift in the way software is delivered to consumers with thousands of apps added and updated on a daily basis.
the majority of these apps are developed at a nominal cost by entrepreneurs that do not have the resources for properly testing their software.
hence there is an increasing demand for applicable automated testing techniques.
one key obstacle towards achieving test automation for gui driven android apps is the lack of effective techniques for test input generation.
a recent study of existing tools by choudhary et al.
claims android monkey a random testing program for android to be the winner among the existing test input generation tools.
android monkey provides a random mechanism that often achieves shallow code coverage.
several recent research efforts including our own have aimed to improve android testing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin texas usa c acm.
isbn .
.
.
.
however to the best of our knowledge no prior research has explored a fully automated combinatorial gui testing approach in the context of android.
this is mainly because exhaustive combinatorial gui testing is often viewed to be impractical due to the explosion of possible combinations for even the smallest applications .
a more practical alternative is t way combinatorial testing where all combinations for only a subset of gui widgets i.e.
t are considered .
but even under t way testing the number of generated test cases could grow rapidly.
moreover without a systematic approach to determine the interactions arbitrary selection of twidgets to be combinatorily tested is bound to be less effective than an exhaustive approach in terms of both code coverage and fault detection.
an opportunity to automate the testing activities in android is presented by the fact that apps are developed on top of an application development framework adf .
the android adf ensures apps developed by a variety of suppliers can interoperate and coexist together in a single system a phone as long as they conform to the rules and constraints imposed by the framework.
the android adf constrains the life cycle of components comprising an app the styles of communication among its software components and the ways in which gui widgets e.g.
buttons check boxes and other commonly needed functionalities e.g.
gps coordinates camera can be accessed.
an underlying insight in our research is that the knowledge of these constraints along with the metadata associated with each app can be used to automate many software testing activities specifically combinatorial testing of apps.
in this paper we present trimdroid testing reduced gui combinations for anddroid a fully automated combinatorial testing approach for android apps.
given an android apk file trimdroid employs static analysis techniques that are informed by the rules and constraints imposed by the android adf to identify gui widgets that interact with one another.1thus the set of interacting widgets become candidates for t way combinatorial testing.
by avoiding the generation of tests for widgets that do not interact trimdroid is able to significantly reduce the number of tests.
for identifying the interactions trimdroid statically analyzes the control and data flow dependencies among the widgets and actions available on an app.
finally trimdroid uses an efficient constraint solver to enumerate the test cases covering all possible combinations of gui widgets and actions.
our evaluation of trimdroid shows that it achieves the same coverage as exhaustive combinatorial testing but reduces the number of test cases by .
on average and by as much as .
.
this reduction is important as it not only reduces the time it takes to execute the test cases but also significantly decreases the effort required to inspect the test results.
1an apk file is a java bytecode package used to install android apps.
ieee acm 38th ieee international conference on software engineering the paper is organized as follows.
section presents an illustrative app to motivate and describe the research.
section provides an overview of trimdroid.
sections and describe the extraction of required models and dependencies from apps.
sections and describe enumeration of execution scenarios and generation of test cases respectively.
section presents our experimental evaluation of trimdroid.
the paper concludes with an overview of the related research and a discussion of our future work.
.
illustrative example we use a simple android app called expense reporting system ers to illustrate our research.
this app allows a user to maintain a log of meal expenses incurred during a trip.
figure depicts two of ers s activities newreportactivity anditemizedreportactivity.
newreportactivity is the main activity i.e.
it is the first screen presented to the user when an app is invoked.
from newreportactivity the user can select the destination enter an allowable expense amount the currency and initiate the creation of two types of reports itemized report andquick report.
itemizedreportactivity allows the user to enter an itemized list of meal expenses including the total days of the trip and the number of meals purchased on the trip s first and last day.
when total days is i.e.
the first and last days are the same the check boxes corresponding to the last day meals are disabled see figure 1a .
on the other hand quickreportactivity not shown in figure for brevity allows the user to provide an aggregate number for the meal expenses incurred on a trip.
regardless of the approach used for entering the expenses the user is led to a confirmation page where she can submit the expenses and is presented with a summary report that she can save.
an overview of the relationships among the activities comprising the ers are depicted in figure .
testing of gui driven apps such as ers requires utilizing a large number of event sequences.
these sequences are often generated by gui interactions involving radio boxes check boxes dropdown lists etc.
exhaustive combinatorial testing i.e.
a bruteforce approach that tries all possible gui combinations is often computationally prohibitive.
an alternative approach to exhaustive testing is t way combinatorial testing .
consider a gui screen under test that has a total ofnwidgets.
t way combinatorial testing requires that all possible t way combinations of widget values are selected where t n. the most common type of t way testing is pairwise testing where t .
although t way testing produces a smaller number of tests it is less effective than exhaustive testing in terms of both code coverage and fault detection.
for instance when pairwise testing is used code that depends on the interaction of three or more gui widgets may remain uncovered.
to illustrate the challenges of combinatorial testing consider a situation in which the user clicks on the itemizedreport button of newreportactivity and subsequently on the next button of itemizedreportactivity see figure .
newreportactivity contains thedestination drop down list with choices and the currency check box with exclusive choices.
let us also assume two values of and have been identified as proper input classes for the amount field.
this would result in a total of unique combinations for newreportactivity.
similarly itemizedreportactivity contains the total days drop down list with choices the first day meals andlast day meals each of which has inclusive choices resulting in a total of unique combinations.
2anactivity is a type of android component that represents a gui screen.
figure screenshots for a part of ers app a when total days is the check boxes for last day meals are disabled and b when the total days is greater than the check boxes for last day meals are enabled.
since the widget values selected on one activity could impact the behavior that is manifested in subsequent activities for gui system testing we also need to consider the interaction of widgets across activities.
thus the number of all unique tests for the above use case is .
the number of tests would continue to grow if we consider the other activities comprising this app.
this approach is infeasible in practice in terms of both the effort required to execute the tests and the effort required in assessing the results.
trimdroid drastically reduces the number of tests for achieving a comparable coverage as exhaustive gui testing.
the insight guiding our research is that not all gui widgets and actions interact with one another.
to that end trimdroid statically extracts the control and dataflow dependencies among the gui widgets event handlers and activities of an app and it does so without access to source code rather from the app s apk file.
an example of gui widget interaction can be gleaned from figure 1a.
here we can see that when total days obtains a value of last day meals check boxes are disabled thus indicating a dependency between these two widgets implying that their combinations should be tested.
on the other hand if our analysis indicates that total days andfirst day meals are indeed independent of one another we can safely conclude that their combinations do not need to be tested.
trimdroid detects such dependencies which provide the basis for combinatorial generation of tests.
to appreciate the significant reductions possible this way consider the use case of ers described earlier.
trimdroid generates only maxf 23g tests for itemizedreportactivity when the next button is clicked.
that represents a reduction of combinations compared to the exhaustive approach.
trimdroid realizes that the possible combinations for total days andlast day meals are independent of the possible combinations for first day meals.
since we can use combinations of independent widgets in the same test the dependent widgets with the biggest number of unique combinations determine the number of generated tests.
here the combinations for total days andlast day meals are merged with the combinations forfirst day meals to produce widget combinations for itemizedreportactivity.
for testing both activities together trimdroid produces tests representing a reduction of tests compared to the exhaustive approach.
assuming an accurate extraction of dependencies through static analysis the reduced set of tests generated using trimdroid would 560be as effective as exhaustively generated tests in terms of their coverage and fault detection power.
.
approach overview figure depicts a high level overview of trimdroid which is comprised of four major components model extraction dependency extraction sequence generation and test case generation.
together these components produce a significantly smaller number of test cases than an exhaustive combinatorial technique yet achieve a comparable coverage.
similar to our previous work model extraction produces two types of models by statically analyzing an android app interface model im provides a representation of all the gui inputs of an app including the input widgets and events actions for each activity.
trimdroid uses the im to determine how a gui screen can be exercised in order to generate the tests for it.
activity transition model atm is a finite state machine representing the event driven behavior of an android app including the relationships among its activities and their event handlers transitions .
since our research targets gui testing we only extract information that is related to activities not other android components e.g.
services .
figure depicts theatm for the entire ers app.
these models are represented in alloy a formal specification language based on first order relational logic.
alloy specifications can be analyzed using alloy analyzer thereby allowing us to systematically explore the combinatorial space with the help of a constraint solver.
in a step parallel to model extraction dependency extraction identifies gui induced dependencies among app elements using a combination of control and data flow analysis techniques.
dependency extraction identifies three types of dependencies when one gui widget depends on the value of another widget e.g.
a drop down menu is disabled because a check box is not selected when a gui event handler depends on a widget value e.g.
a button handler method uses the selected value of a check box and when an activity depends on the widget values from a preceding activity e.g.
the widget values from a preceding activity are included in the payload of an intent starting a new activity.3these dependencies are also represented in the form of alloy specifications and used by test case generation in a later step for pruning the combinatorial space of tests.
sequence generation uses the alloy analyzer to synthesize sequences of events that cover the paths in the atm.
each path in the atm represents a sequence of events in a possible use case.
a good coverage of the atm is essential for achieving high code coverage.
trimdroid covers the paths using the prime path coverage criterion known to subsume most other graph coverage criteria .
finally test case generation constructs system tests by performing three key steps.
first it traverses the sequences of events representing the paths produced by sequence generation.
second for each step in a given sequence it uses alloy analyzer to generate value combinations for different gui widgets.
to that end testcase generation utilizes the sets of dependent widgets generated by dependency extraction and the specification of each widget in the im.
lastly test case generation merges the value combinations to create tests that cover the entire sequence of events in each path of the atm.
the generated tests can then be executed using robotium an android test automation framework.
3all android components are activated via intent messages.
an intent message is an event for an action to be performed along with the data that supports that action.
figure a high level overview of trimdroid the next four sections describe the four components of trimdroid in more detail.
.
model extraction trimdroid extracts two types of alloy models for each app interface model im andactivity transition model atm .
we define each model and describe the extraction process for each in the remainder of this section.
.
interface model theimprovides information about all of the gui inputs of an app such as the widgets and input fields belonging to an activity.
more formally the im is defined as follows definition .
theimof an app is a tuple ha e w ii where ais a finite non empty set of activities of the app.
eis a finite set of event handlers of the app e.g.
onclick is the handler for a button click .
each activity a2ahas a set of event handlers ehandlers a e. wis a finite set of gui widgets of the app e.g.
a checkbox radio button .
each activity ahas a set of widgets widgets a w. iis a finite set of input classes for widgets of the app.
each widget whas a set of input classes ic w i. each input class is a partition of the input domain of each widget.
for instance input classes of a check box are checked and unchecked while input classes of a drop down menu are its choices.
model extraction obtains the imby analyzing the information contained in the meta data included in an android apk file namely its xml based manifest andlayout files.
more specifically model extraction determines all the activities within an app from its manifest file.
subsequently for each activity model extraction parses the corresponding layout file to obtain all information for each widget such as its name id input type etc.
our current implementation extracts the input classes for widgets that provide users with a list of options such as check boxes and drop down menus directly from the layout files.
we use the same layout files to divide the domain space of text boxes into different classes based on the limits imposed on the text box values e.g.
max length .
for unbounded text boxes and other unbounded widgets we use a configurable set of input classes that can be defined by the user.
.
activity transition model anatm represents the high level behavior of an app s gui in terms of its activities and the transitions resulting from invocations of its event handlers.
more formally the atm is defined as follows definition .
the atm of an app is a finite state machine represented as a tupleha a0 e fi where ais a finite non empty set of activities.
a0is the starting activity i.e.
main activity defined in an app s manifest file.
eis a finite set of directed transitions from the starting activity to final activities labeled by event handler names.
each transition represents an event handler and denoted as aiek !aj where ai aj2aandekis an event handler.
fis a finite non empty set of final activities in the atm.
figure shows the atm for the ers app.
to obtain an atm such as this model extraction first determines the activitiesa fa0 a1 a2 a3 a4gcomprising the app from its manifest file.
to determine the transitions between the activities model extraction performs a depth first traversal of main activity s call graph starting from its oncreate method which we know from android s adf specification to be the starting point of all apps.
in the context of ers this corresponds to newreportactivity s oncreate method.
for each encountered node in the call graph model extraction checks whether it would result in an activity transition and if so adds it to set e. a call may result in a transition in two ways .inter component transition these are implicit calls that result in the transfer of control from one activity to another activity.
for instance in the example of ers in figure when the itemized report button is clicked the corresponding handler calls android s startactivity method which sends an intent message resulting in the transfer of control to itemizedreportactivity s oncreate method.
in this case we extract the destination from the intent and add the following transition e e fa 0onclick itemizedreport !
a2g.
.intra component transition these are implicit calls to gui event handlers in an activity that result in a transition back to the same activity.
for instance the itemizedreportactivity has a click event associated with its reset button.
this event is handled by the activity s onclick method that is registered with that button.
in this case we add the following transition to the model e e fa 2onclick reset !
a2g.
upon traversing the call graph of a0 the above process repeats for all of the activities remaining in a. finally we populate the set fwith the activities that do not have any outgoing inter component transitions and if they do it is only to nodes that precede them.
we implemented the model extraction component on top of soot a static analysis framework for java .
to analyze an android app trimdroid utilizes the dexpler transformer to translate android s dalvik bytecode to jimple soot s intermediate representation.
by leveraging soot and dexpler trimdroid works with an app s source code as well as its apk file.
.
dependency extraction trimdroid uses the dependencies among the app elements to determine the combinations that should be tested and those that can be safely pruned.
to that end dependency extraction determines three types of dependencies as described further below.
figure activity transition model for the ers appalgorithm wdep input a2a output wd p widgets a 1wd 2deppairs 3foreach meth2a methods do foreach wused in a conditional statement stmt 1ofmeth do ifisawidget w then foreach w1aused along either branch of stmt 1do ifisawidget w1a then deppairs deppairs ffw 1a wgg foreach rvdefined along either branch of stmt 1do foreach w22widgetswhosevalueaffects rv do deppairs deppairs ffw wgg foreach conditional statement stmt 2that uses rvdo foreach w1bused along either branch of stmt 2do ifisawidget w1b then deppairs deppairs ffw 1b wgg 16wd merge deppairs 17wd wd isolateremainingwidgets wd widgets a .
widget dependency two widgets w1 and w2 are dependent if combinations of their values affect an app s control or data flow.
widget combinations that affect the control flow impact the code coverage of generated tests widget combinations that affect the data flow determine the state of the system under test.
here are two possible dependencies between w1 and w2 that our approach detects case w2 s use depends on the value of w1.
this can occur in two situations.
first a widget w1 is used in a conditional statement and widget w2 is used along either branch of that statement.
an example of the first case is shown below where lastbreakfast is dependent on totaldays if string.valueof totaldays.
getselecteditem .equals lastbreakfast .setenabled false the second situation occurs when the value of widget w1 affects a reference r and w2 s use depends on the value of r. an example of this case is shown below where the use of totaldays is indirectly dependent on firstbreakfast based on the variable mealscount if firstbreakfast .ischecked mealscount if mealscount totalmeals totaldays.getvalue mealscount case in a conditional statement widget w1 is used and reference ris defined in its block and ris later used in the block of another conditional statement where w2 is used.
an example of this case is shown below where the value combinations of firstbreakfast andfirstlunch impact the value of mealscount if firstbreakfast .ischecked mealscount if firstlunch.ischecked mealscount algorithm defines wdep which partitions widgets a based on the two cases above.
the algorithm takes an activity aas input and produces wd a partition for widgets a where wd p widgets a .
for each method wdep iterates over each reference wthat is used in a conditional statement and determines if wrefers to a widget lines of algorithm .
to make that determination isawidget w traverses the definition use chain of wto determine 562algorithm hdep input a2a e2ehandlers a output hd p widgets a 1hd 2foreach ris used in edo ifisawidget r then foreach wd2wdep a do ifr2wdthen hd hd fwdg break if any of its definitions refers to a widget.
at this point wdep distinguishes the two cases that result in widget dependencies.
to determine the first situation of case wdep checks if any other variable w1ais used and