feedback based debugging yun lin1 jun sun2 yinxing xue3 yang liu3 and jinsong dong1 1school of computing national university of singapore singapore 2singapore university of technology and design singapore 3school of computer engineering nanyang technological university singapore abstract software debugging has long been regarded as a time and effort consuming task.
in the process of debugging developers usually need to manually inspect many program steps to see whether they deviate from their intended behaviors.
given that intended behaviors usually exist nowhere but in human mind the automation of debugging turns out to be extremely hard if not impossible.
in this work we propose a feedback based debugging approach which builds on light weight human feedbacks on a buggy program and regards the feedbacks as partial program specification to infer suspicious steps of the buggy execution.
given a buggy program we record its execution trace and allow developers to provide light weight feedback on trace steps.
based on the feedbacks we recommend suspicious steps on the trace.
moreover our approach can further learn and approximate bugfree paths which helps reduce required feedbacks to expedite the debugging process.
we conduct an experiment to evaluate our approach with simulated feedbacks on mutated bugs across open source projects.
the results show that our feedbackbased approach can detect .
of the bugs and of the detected bugs require less than feedbacks.
in addition we implement our proof of concept tool microbat and conduct a user study involving participants on debugging tasks.
the results show that compared to the participants using the baseline tool whyline the ones using microbat can spend on average .
less time to locate the bugs.
i. i ntroduction software debugging is often regarded as one of the most time consuming tasks in software development and maintenance .
given an observable fault developers usually need to start with the fault revealing code speculate where the bugs are and inspect the code line by line or sometimes step by step with the intended code specification in mind .
when the code gets complicated such a manual process of debugging inevitably demands huge amount of time and mental efforts.
researchers have proposed a lot of techniques for automation of software debugging such as spectrum based fault localization delta debugging and dynamic trace recording .
spectrum based fault localization regards test cases as executable requirement.
given a set of test cases it quantifies the suspiciousness of source code lines by comparing the code coverage of passed or failed test cases.
delta debugging analyzes differences between passed and failed test cases such as test inputs and running program states so as to simplify the test inputs and isolate root cause variable of bug .
however in the process of development developers usually lack sufficient passed test cases to apply or take full advantage of these techniques.
some dynamic trace recording techniques such as omniscientdebugging can record the execution trace for a single run and allow developers to trace back and analyze the faults.
nevertheless when the trace length gets long especially caused by loops the effort for stepwise checking becomes overwhelming.
in this paper we propose a tool supported and feedbackbased debugging approach which requires only one failed test case and aims to reveal the root cause step in the execution.
our rationale lies in the observation that the specification of detailed code usually exists nowhere but in human mind.
therefore we leverage light weight user feedback as partial specification to feed the debugger so that it can recommend suspicious steps.
given a buggy program we first build a trace model which records the execution trace and captures causality relations i.e.
data control dominance relation among the steps.
on each trace step we allow the developers to provide four types of feedback i.e.
correct wrong variable value wrong path and unclear .
our approach then takes the feedback and recommends suspicious steps based on causality relation among trace steps.
after collecting a number of feedbacks our approach begins to learn and approximate bug free paths on trace which helps reduce the number of feedbacks to expedite the debugging process.
this iterative process starts with a user feedback on a fault revealing trace step and finishes when the root cause step is recommended.
we implement our approach as an eclipse plugin microbat a demo video of microbat is available at .
we first conduct a simulation experiment by using microbat to find mutated bugs with simulated feedbacks on three open source projects.
the results show that microbat is able to detect .
of the mutated bugs and of detected bugs require less than feedbacks.
in addition we conduct a user study involving participants on real world bugs.
the result shows that compared to the participants using the baseline tool whyline the ones using microbat can spend on average .
less time to locate the bugs.
this paper makes the following contributions we propose a feedback based debugging approach which incorporates four types of feedback to recommend suspicious steps.
we develop microbat tool for the practical use of our feedback debugging approach we conduct both simulation experiment and user study to evaluate our approach and tool.
the results show that microbat is both effective and practical.
the rest of the paper is structured as follows.
section ii presents a motivating example.
section iii describes our approach.
section iv presents our tool microbat .
section v evaluates our approach with a simulation experiment.
section vi shows our user study on real world bugs.
section vii reviews ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i debugging code example public int calculate string expr int brktstartidx while containsbracket expr char l i s t expr .
tochararray for int i i list .
length i if ch brktstartidx i else if ch string simpleexpr expr.
substring b rktstartidx i int value evaluatesimpleexpr expr string beforeexpr expr.
substring brktstartidx string afterexpr i expr.
length ?
expr.
substring i expr.
length expr beforeexpr value afterexpr break int result ev aluatesimpleexpr expr return result related work.
section viii concludes the paper.
ii.
m otiv a ting example table i shows our motivating example which is adopted from a code training website .
given a valid algorithmic expression consisting of integers brackets or plus minus signs e.g.
this program should compute its correct value.
overall the program parses the expression by iteratively replacing the expression inside the most inner pair of brackets with its value line .
for example the expression will be iteratively reduced into expressions and .
finally it will be evaluated to a number returned as the result line .
in our example however given the complicated expression of it returns a wrong value of instead of the correct value of .
with a traditional debugger developers usually need to set a number of breakpoints for tracking down the bug.
however they will have to answer some following questions.
where to set breakpoints?
in our example given that theresult variable in line is wrong every statement possibly influencing it is suspicious which makes almost every line in table i as a potential breakpoint.
how many breakpoints are appropriate?
too many breakpoints may suspend the debugging execution when unnecessary.
however any miss of a breakpoint may cause the execution suspended after the bug has already occurred which requires the developer to re run the program from the very beginning.
how to avoid over inspection effort caused by loop?
when the breakpoints are set inside a nested loop developers have to manually inspect variable values each time a breakpoint is reached e.g.
a breakpoint set on line in table i. with the number of iterations increases the effort of inspecting variable values soars dramatically.
in this work we propose microbat to address the above issues.
for the case in table i microbat first generates the execution trace by a single run and records all the read or written variables and their values in each trace step.
given the visualized trace see section iv developers are able to startdebugging in a backward way.
specifically developers can start from the very end of the trace where the fault is observed and provide his feedback on this step such as which variable in this step is with wrong value or whether this step should be executed then microbat is able to recommend certain step responsible for its cause.
in our example the developer can first observe the program state in the step running into line in table i where the result variable has the wrong value of instead of the expected .
thus he can select this variable on this step indicating its wrong value as feedback and ask microbat to recommend a suspicious step for further inspection.
using the feedback microbat recommends a step by simple causality analysis bug free path inference and clarity guidance.
simple causality analysis.
simple causality analysis aims to parse the dynamic data control dominance relation between steps to alleviate the burden of setting breakpoints.
in above case microbat first recommends the most recent step writing theresult variable data dominance i.e.
the step running into line .
on this step it reads a variable expr of value and writes the variable result of value .
given that equals and the value of the written variable result has been indicated as wrong the read expr variable must be wrong.
thus the developer can further select theexpr variable to indicate its wrong value as feedback.
with simple causality analysis microbat then recommends a step running into line which writes the expr variable.
bug free path inference.
bug free path inference aims to reduce the inspection effort.
with only above causality analysis the developer will repeatedly inspect the steps running into line and line in every iteration.
in the worst case he would need to go through all the iterations if the bug happens at the very beginning of the execution.
final result fig.
.
execution of example program figure shows the iterations along with their execution order when parsing the expression .
since the developer inspects the variables in a backward way he will first give wrong variable value feedback on the 9th and 8th iteration sequentially.
microbat then approximates some possible bug free paths along the loop trace.
in this case microbat can skip the 6th and 7th iteration and recommend a step in the 5th iteration.
the rationale is as follows.
based on developer s feedback the bug does not occur in the 8th or 9th iteration.
in addition microbat finds that the cases in 6th 9th iteration are similar in that they all parse the addition of two positive integers for example in 9th iteration in the 8th iteration.
therefore microbat approximates that the bug may not happen in the 6th or 7th authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iteration either.
hence microbat stops in the 5th iteration as the case of a positive integer minus a negative integer has never been encountered.
the developer now inspects a step running into line in table i in which the read expr is while the written value of value variable is .
then the developer can select the returned variable from evaluatesimpleexpr method so that microbat can further conduct simple causality analysis inside the method invocation.
clarity guidance.
in some cases developers could get lost when inspecting the correctness of program state.
microbat enables the developers to provide an unclear feedback then microbat will try to suggest its context step such as method invocation or loop head i.e.
the step starting a loop iteration .
suppose the developer cannot make sure the correctness of a step srunning into line he can provide the unclear feedback so that microbat will recommend its loop head step running into line by one unclear feedback or line by two unclear feedbacks .
by this means he can be aware of the context information such as which iteration of figure isslocated in and what is the reduced expression at the beginning of this iteration.
with feedbacks provided on context steps microbat manages to present bigger picture and gradually guides the developer back to understand the step he gets lost at the first place.
iii.
a pproach given a trace of steps our approach aims to find the rootcause step which deviates from developer s expectation and eventually causes the observable fault after program execution.
a. trace model given a run of the buggy program we can obtain a trace consisting of a number of step s. each step corresponds to an executed source code line which can define i.e.
write oruse i.e.
read some variable s. given a variable var i f var is defined by step s1while used by step s2 then we say that step s1data dominate ss2onvar.
in addition the variable var is called as the attributed variable of the data dominance relation.
on the other hand given a conditional statement con stat i fcon stat is executed in step s1while the evaluation value of con stat i.e.
true or false decides the execution of step s2 then we say that step s1control dominate ss2.
given two steps s1ands2 i fs1control or data dominates s2 then we say that s1is control or data dominator ofs2 and s2is the control or data daminatee ofs1.
in addition we say that s1is the contextual parent of s2if either of following conditions happens s1starts a loop iteration l and s2is executed in lbut not in any nested loop iteration or method invocation in l. s1starts a method invocation mands2is executed in m but not in any nested method invocation or loop iteration inm.
the contextual parent child relation can organize our trace into astep tree in which the root is the entry method and the leaves are the steps invoking no method and starting no loop iteration.
given a step we define its layer on step tree as its abstract level .
by default the abstract level of the entry method is .b.
recommendation mechanism we support four types of feedback as follows correct step the step is executed in correct control flow and all the values of visible variables in this step are correct.
wrong variable value at least one variable in this step is of wrong value.
once a developer provides such feedback he should further select the specific variables of wrong value.
wrong path the step should not be executed.
unclear the developer is not confident to make any of the above feedback on this step.
we consider correct step wrong variable value and wrongpath feedback as clear feedback.
we recommend a suspicious step if the developer provides a clear feedback and recommend a step to help understand the code if he provide an unclear feedback.
for clarity we start illustrating our approach when developers only provide clear feedback then we proceed to the case when they provide unclear feedback.
overall mechanism with clear feedbacks when a developer specifies an incorrect step by providing wrongvariable value or wrong path feedback we move forward on trace to a suspicious previous step by data or control dominance relation.
the developer can iteratively provide feedbacks and move forward to locate the root cause step.
however moving forward only by dominance relation can be either too slow so that it requires a great amount of feedbacks or too fast so that we skip the root cause step by a single dominance relation.
figure uses a state machine to present our overall recommending mechanism with only clear feedbacks.
the states consists of simple casuality analysis we simply recommend steps based on dominance relation.
bug free path inference we skip some inferred and approximated bug free paths to move faster .
inspect details when we find moving and recommending steps by dominance relation is too fast we go through steps in between a dominance relation.
inspect detailssimple causality analysis bug free path inferencecorrect step !pattern matched wrong value wrong path pattern matched incorrect approximationcorrect step correct approximation fig.
.
overall recommending mechanism with clear feedback in figure we assume the developer starts debugging from a fault revealing step therefore he starts in simple causality analysis state.
the developer stays in this state until we find recommending steps by dominance relation is either too slow or too fast.
we detect the case of being too slow by inferring bug free paths and summarizing bug free path patterns to approximate authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
potential bug free paths.
once we find some path matches bugfree path patterns i.e.
bug free prone in simple causality analysis state we transfer to bug free path inference state where we expedite the moving by skipping steps.
in bug free path inference state we also reply on user feedback to confirm our approximation of bug free paths.
when our approximation is confirmed we stay in this state.
otherwise we transfer back tosimple causality analysis state.
we detect the case of being too fast as follows.
given a path of dominance relation if the developer provides a wrongvariable value or wrong path feedback at the end step and a correct feedback at the start step the root cause step must lie in between them.
in such case we enter inspect detail state.
in this state if the developer provides correct feedback we sequentially explore and recommend the steps between the start and end step.
otherwise we transfer back to simple causality analysis state.
since simple causality analysis and inspect detail state are straight forward we focus our illustration on bug free path inference state.
bug free path inference bug free path inference aims to infer bug free paths by user feedback and approximate potential bug free paths.
during debugging we discriminate the steps on more bug free paths and recommend those on more bug prone paths to expedite the debugging process.
in our approach we first infer and record the bug free path based on user feedbacks.
we extract path pattern for each bugfree path.
we approximate the paths conforming to the pattern of a bug free path to be bug free.
during simple causality analysis if a path of dominance relation is approximated to be bug free we will skip this path and recommend a further forward step.
moreover when we detect that we have overapproximated some bug free paths we adopt a binary search based mechanism for complement.
next we explain the details of pattern extraction section iii b2a step skipping section iii b2b and binary search section iii b2c .
a pattern extraction pattern extraction aims to identify bug free paths and extract their pattern keys.
bug free path given a step step on trace if one of its read variables is marked as being of wrong value then we call this step as an attributed step .
an attributed step means that its incorrectness is spread from some step executed before.
given a path of a data dominance relation on the trace if it satisfies that both its start step and end step are attributed steps we consider it as a bug free path1.
expr variable value variablepath path w w w ... iter iter iter iter fig.
.
path example figure shows a part of trace of the buggy program in 1it is possible that there are over two bugs in the trace thus a bug may exist in our defined bug free path .
in such case our approach focuses on locating the first bug appearing in the trace.table i. each rectangle represents a trace step the upper number indicates the corresponding line number in table i and the lower number in brackets indicates its order.
the dots between the 17th step and 28th step indicate that the steps inside method invocation in line in table i are omitted.
in addition the curve lines indicate data dominance relations and their attributed variables.
suppose the developer provided his wrong variable value sequentially on value variable on the 31th step line and expr variable on the 17th step line then we have a bug free path s t e p s t e p .
pattern key extraction for a path we abstract it into a more compact form i.e.
pattern key so that the paths conforming to the pattern key is considered as similar.
table ii path abstraction example private int evaluatesimpleexpr string simpleexpr string operators parseoperators simpleexpr string numberstrings simpleexpr .
split string numstring1 retrievenum numberstrings integer num1 int eger .
valueof numstring1 for int i i operators .
length i string operator operators string numstring2 retrievenum numberstrings i if operator .
equals num1 num1 in teger .
valueof numstring2 else if operator .
equals num1 num1 integer .
valueof numstring2 return num1 table ii shows the details of the method invoked in line and in table i. the execution of the loop line causes the iterations going through either path a b or c in which the elements represent line number.
in this example each iteration path i.e.
a b orc represents the case when evaluating the addition of two numbers subtraction of two numbers or simply one number.
given a path pcontaining a number of iterations we approximate its semantic similarity with other paths by whether they contain similar iterations and whether the iterations are executed in similar order.
thus we regard p as a string of iterations e.g.
p a a b b b a or a b a b .
then we summarize pinto a regular expression by abstracting its consecutive repetitive substrings e.g.
a b aor ab .
such regular expression is the pattern key ofp.
note that if pcontains nested loop iterations e.g a a a b b b a a b b we first reduce pinto p primeby generating pattern keys for iterations in the most inner loop e.g.
p prime a b a b .
thus the nested hierarchies inp primeis one level flatter.
then we apply the same procedure onp primeto further flatten the nested hierarchies e.g.
a b .
such a procedure is applied until all the nested hierarchies in pis flattened into one patten key.
for the example in table ii based on the user feedbacks if a path a b b afor addition and bfor subtraction can be implied to be bug free thus its pattern key is ab .
then we will consider another path a b as more likely authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm recommendation with step skipping input a wrong variable value step step input a wrong read variable of step var input existing bug free paths bug free paths output recommended step step rec 1step d dom step var 2path s step d step 3ifpath s.conformt o bug free paths then isskip true while isskip do isskip false for each read variable read var onstep ddo step new d dom step d read var path s t e p new d step d ifpath.conformt o bug free paths then step d dom step new d read var isskip true break end end end 17end 18return step d to be bug free as it conforms to the pattern key ab o f the former path.
the interpretation is as follows.
if adding numbers once then subtracting numbers twice is bug free then we approximate that adding numbers once then subtracting numbers once is more likely to be bugfree comparing to other cases such as subtracting numbers twice .
b step skipping when the developer provides feedbacks and gets recommended steps with simple casuality analysis he is also marking the bug freeness of the paths of dominance relation.
for the example of figure if the developer provides a wrong variable value feedback on value variable on the 31th step then provides a wrong variable value onexpr variable on the recommended data dominator i.e.
the 17th step.
apart from recommending the 1st step as the data dominator we can also mark the path starting with the 17th step and ending with the 31th step as bug free .
with the increase of feedbacks we can have more bug free paths for us to conduct step skipping.
algorithm shows how we skip steps with regard to recorded bug free paths.
given a step step where the developer provides a wrong variable value feedback on its read variable var we first find the data dominator step dofstep byvar line .
instead of directly returning step d we check whether the path path sof s t e p d step conforms to one of the bug free paths bug free paths line .
if not we return step d otherwise we consider path sprone to bug free and try to skip step das follows.
we go through all the read variables onstep dand check whether there exists a path path starting bystep d s dominator step new dand ending by step d is also bug free prone line .
if yes we can further skip step new d and check its even forward dominators which is assigned to step d on trace line .
otherwise we stop skipping and return the most forward dominator step d. c binary search as mentioned before our skipping strategy may over approximate bug free paths which makes us over skip some steps.
we can detect such case when thealgorithm recommendation with binary search input a list of skipped dominators list output recommended step step rec 1start end list.length current start 2while start end do feedback user provide feedback on list iffeedback is correct then current current end start current else if feedback is wrong variable value then path list list var attr findattr path list ifvar attr negationslash feedback.var then current current start end current else return simca list feedback end else return simca list feedback end 17end 18return list developer provides a correct step feedback immediately after we recommend a step by step skipping.
given a previous step marked as correct and a later step marked as wrong variablevalue the root cause step should lie in between.
therefore we adopt a binary search based strategy as algorithm .
step skipping will result in a sequential list of skipped dominators list in execution order.
algorithm applies binary search on list.
during the binary search if the developer provides a correct feedback we search backward on trace in a binary way line .
on the contrary if the developer provides a wrong variable value feedback we search forward on trace in a binary way line .
moreover we leverage developer s feedback on dominators inlist to confirm our approximation during step skipping.
when the developer provides a wrong variable value feedback on certain dominator list inlist we can check whether the wrong variable chosen in this feedback is the same to attributed variable of the skipped path of dominance relation list list line .
if yes we can confirm that we make correct approximation when skipping list list and continue the binary search procedure line .
otherwise we regard the developer is no longer debugging on the track of our approximation during step skipping.
therefore we stop the binary search and adopt simple causality analysis on list instead line .
with the same reason we stop the binary search in the same way when the developer provides a wrong path feedback line .
clarity guidance once the developer cannot decide the correctness of a step he can provide an unclear feedback.
we aim to guide the developer better understand the unclear step so that he can resume where he gets lost.
algorithm shows how clarity guidance works.
given an unclear step step we first back up the debugging context of step such as the details of step skipping or binary search in addition we maintain a stack stack and push step into it line .
then we retrieve the context step step con ofstep bygetcontext method line .
the getcontext method authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm recommendation with unclear feedback input an unclear step step output recommended step step rec 1back up context of step stack stack.push step 2step con getcontext step and recommend step con 3while true do feedback user provide feedback on step con iffeedback is unclear then step con getcontext step con stack.push step con recommend step con else if feedback is correct then step con stack.pop ifstack then resume context of step con return step con else recommend step con end else return simca step con feedback end 20end returns the step executed before step if its abstract level of step is and returns the contextual parent i.e.
loop head or method invocation step of step otherwise see definition in section iii a .
the context aims to provide a big picture so that the developer can better understand the unclear step.
then the developer needs to provide feedback on step con.
if the developer provides an unclear feedback on step con we further retrieve and recommend its context step and push it into stack line .
if the developer provides a correct feedback on step con we pop stack to get the most recent unclear step and assign it to step con line .
in this case ifstack is empty it means that step conis the very first step he gets unclear therefore we resume its backed up context and recommend step con line .
otherwise we consider that the developer is partially clear as he can now tell the correctness of the context of some unclear step.
thus we recommend step con for his further feedback line .
in addition if the developer provides a wrong variable value or wrong path feedback we consider that the developer has gotten new debugging clue.
hence we stop the procedure and conduct simple causality analysis for step con line .
iv .
t ool support we implemented our approach as an eclipse plugin.
a screenshot can be checked at microbat github website .
microbat consists of three views i.e.
trace view feedback view and reason view.
the recorded trace will be presented intrace view.
in trace view the steps are organized in a tree structure conforming to the contextual parent child relation and each step is labeled with its execution order class file name and line number.
once the developer clicks a step on trace view the corresponding line of code will be highlighted in java editor and its detailed information will be showed onfeedback view.
at the top of feedback view shows the four types of feedback.
given a selected step feedback view lists its read and written variables as well as a snapshot of program states.
once a feedback is provided the developer canclick the find bug button to make microbat to recommend a step.
after a step is recommended reason view shows its recommendation explanation in natural language.
in addition the developer can click undo button to get back to the state before the recommendation for the current step.
v. s imulation experiment we conduct a simulation experiment to answer the following research questions rq1 how effectively and efficiently can microbat facilitate the debugging process?
rq2 what is the contribution of bug free path inference to the debugging process?
rq3 what is the impact of unclear feedback?
in the simulation experiment we generate mutants which can kill a given test case as buggy code and apply microbat with simulated feedbacks on the trace of mutants to see whether microbat can recommend a step running into where the mutation happens.
we first collect test cases from three apache open source projects see table iii .
for each passed test case we mutate its tested code with a standard mutator.
the mutator replaces algorithmic operators logical operators and number constants e.g.
replacing with .
in each mutation only one source code line is modified.
if a mutation kills the test case we generate the correct trace before mutation trace c and the buggy trace after mutation trace m. then we can reference trace cto check the correctness of the steps in trace m. we customize a dynamic programming algorithm to match the steps between the two traces.
if a step in trace m cannot be matched to a step in trace c we simulate a wrongpath feedback.
otherwise we difference the read and written variables between two matched steps to check whether the variable values on the step of mutated trace are correct.
if not we simulate a wrong variable value feedback otherwise we simulate a correct step feedback.
as for the unclear feedback we design the simulation as follows.
if the step is the first fault revealing step at the end of the trace the simulated developer will not provide a unclear feedback.
otherwise given a step swhich has an abstract level see definition in section iii a l and it is the kth times checked by our simulated developer then the probability to simulate an unclear feedback is p l k el k. intuitively this is designed such that the lower level sis or the less times sis checked the more likely an unclear feedback is simulated on s. we call each simulated debugging process on a mutated trace as a trial .
in a trial t we consider the mutated line of source code line mas the root cause of the bug.
let the trace length be lt i f microbat can recommend a suspicious step which runs into line mwithin ltfeedbacks we consider the trial as effective.
in addition we limit the generated trace length for each trial to steps to avoid infinite loop bugs introduced by mutation.
for each mutation we generate multiple trials by enabling the feature of bug free path inference and controlling the amount of provided unclear feedbacks to observe their difference.
we control the amount of simulated unclear feedbacks authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to be .
and of the trace length.
we choose the trials with inference feature enabled and provided unclear feedbacks as representative trial s. a. rq1 effectiveness and efficiency table iii shows the experiment results on representative trials including the number of test cases tc number of mutation mu average trace length atl average clear unclear feedback number acf auf median clear unclear feedback number mcf muf and the effective ratio er .
table iii experiment result project tc mu atl acf auf mcf auf er apache math2.
.
.
.
.
.
apache lang3.
.
.
.
.
.
apache cli1.
.
.
.
.
.
total .
.
.
.
table iii shows that microbat can find .
of the mutated bugs with our recommendation paradigm.
we investigated the failed trials and found that microbat could miss some data dominance relation due to third party library calls.
our implementation does not analyze the third party library thus some missing the data dominance relation results in microbat failing to recommend data dominator step in such cases.
table iii also shows that compared to the average trace length of .
steps microbat generally requires the developer to provide on average .
clear feedbacks with on average .
unclear feedbacks and a median of feedbacks.
figure shows the distribution of required feedback number versus the trace length.
in general our statistic shows that of the representative trials require less than clear feedbacks to locate the bug the details can be checked at .
12000feedback number trace length fig.
.
feedback number versus trace length we investigated the trials with a large number of feedbacks we found that these cases happen when the bug lies in between a dominance relation where dominator is correct and the dominatee is incorrect.
in such case microbat will transfer to inspect detail state to sequentially inspect the steps.
when the path of the dominance relation is long it causes a great number of correct feedbacks.
an extreme case happens in one trial of the test case testunstablederivative inmath project.
the simulated developer provided a wrong variable value feedbackon the 5611st step and a correct feedback on the 495th step where the variable is defined.
however the mutated bug happens at the 4536th step.
after providing a correct step feedback at 495th step microbat transits the debugging state to inspect detail state.
the simulated developer then sequentially provided correct feedbacks until he finally found the mutated bug.
we call such case as long dominance effect .
we will discuss more about it in section v d. b. rq2 contribution of bug free path inference we regard the inference feature takes positive effect if it can save feedbacks and negative effect otherwise.
overall the feature takes positive effect on i.e.
.
trials and negative effect on i.e.
.
trials.
among these trials the feature saves an average of .
i.e.
.
feedbacks per trial and a maximum of feedbacks in one trial.
more comprehensive details can be checked at .
c. rq3 impact of unclear feedback a impact on feedback number and effective ratio table iv shows that when the unclear feedback ratio increases the clear feedback number both on average and median increases while the effective ratio almost keeps intact.
table iv impact on er acf and mcf unclear ratio .
feedback numberacf .
.
.
.
.
mcf .
.
.
.
.
er .
.
.
.
.
b impact on inference feature table iv shows that on those inference effective trials the positive effect decreases and negative effect increases with the increase of unclear feedback ratio.
our investigation finds that the reason lies in the randomness of simulated unclear feedbacks.
first randomly provided unclear feedback sometimes makes microbat hard to stably summarize bug free path pattern.
meanwhile if the random unclear feedback leads microbat toinspect detail state when long dominance effect happens a large number of correct feedbacks makes the case turn negative.
nevertheless the majority of trials out of still take positive effect under unclear feedbacks.
table v impact on inference feature unclear ratio .
inference featurepositive negative d. discussion in this work our collected feedbacks are partial specification.
the gap between the partial information collected through feedbacks and the real specification causes microbat sometimes require a large number of feedbacks when the long dominance effect happens.
obviously there is a trade off between the effort for developers to provide feedback and the accuracy of step recommendation.
in this work we favour the developers effort over recommendation authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
accuracy.
our future work will explore more alternatives of such trade off.
in summary we conclude that microbat can detect the majority of our mutated bugs with an acceptable number of feedbacks the bug free path inference makes considerable contribution to reduce the feedbacks and the increase of unclear feedback number impacts little on trial effective rate but sometimes offsets the effect of bug free path inference and requires more feedbacks to find the bug.
e. threat to v alidity the main threat in our simulation experiment lies in that the mutated bugs are still different from the real world bugs in practice.
nevertheless andrew et al.
empirically assess the effect of mutation and their result shows that the use of mutation operator yields trustworthy results and seeded faults are harder to detect.
vi.
u ser study we conducted a user study to investigate whether our technique can help developers debug in practice.
we design the study to answer the following research questions rq1 whether can microbat help developer debug the program more efficiently in practice?
rq2 how does developers use microbat in practice?
a. study design in this study we asked the participants to finish three debugging tasks.
we chose whyline as the baseline tool to compare with microbat a demo of whyline can be checked at .
whyline can record the execution trace allow developers to ask why or why not questions on trace steps e.g.
why does the variable equal ?
orwhy is this statement executed?
and answer the questions by showing a relevant source code line.
the user study for whyline showed that novice programmers with whyline were twice as fast as expert programmers without it .
the main difference between microbat and whyline lies in that microbat allows richer types of feedback such as correct and unclear and supports more sophisticated inference for suspicious steps such as bugfree path inference and clarity guidance.
we recruited graduate students or research staffs as participants in this study from two universities in singapore.
we surveyed all the participants and divided them into two equivalent groups based on their programming experience.
participants were matched in pairs by their capability and each pair was randomly allocated to the experimental or control group.
the experimental group used microbat and the control group used whyline to accomplish the same tasks in the study.
we gave tutorials of both tools three hours before the study and asked the participants to familiarize themselves with an exercise using their respective tool.
we chose three bugs as debugging tasks which were once used as the debugging problems in the final exam of software testing course in nanjing university ranking top in china table vi task description task name loc general description bug reason simple calculator145 given a valid algorithmic expression parse it into correct value.some negative signs are parsed to minus sign.
longest consecutive sequence70 given an integer array find the size of its largest subset which consists of consecutive elements.duplicated elements in the set are not considered.
search in rotated sorted array85 given a sorted array is rotated at some unknown pivot find an element in o lg n time.some boundary checking is wrong.
in may .
the source code of debugging tasks can be checked at .
table vi shows brief description of the tasks.
despite these programs consist of only lines of code we regard them as non trial because the code involves complicated logic the statistic of the final exam in nanjing university shows that .
of the students failed to locate the bugs the participants had to spend some effort to understand the code details as they were unfamiliar with the code in advance.
before the study we explained the general idea of how each buggy program works to reduce their effort for program comprehension.
in the study the participants were given a failed test case and required to find the bug with respective debugger.
since bug fixing is out of the capability of both tools we did not require them to fix the bug.
instead they should write down the detailed reason why the buggy programs fail with the given test case.
in order to conduct post mortem analysis on participants behaviors on microbat we instrumented the tool to record the usage frequency of each feature.
in addition we required the participants in both groups to run a full screen recorder throughout the experiment session.
b. results debugging efficiency rq1 in this study all the participants in both groups successfully figured out why the bugs happen.
therefore we evaluated the task completion time as their performance.
table vii performance of both group min par task task task task p1 p9 .
.
.
.
.
.
p2 p10 .
.
.
.
.
.
p3 p11 .
.
.
.
.
.
p4 p12 .
.
.
.
.
.
p5 p13 .
.
.
.
.
.
p6 p14 .
.
.
.
.
.
p7 p15 .
.
.
.
.
.
p8 p16 .
.
.
.
.
.
avg .
.
.
.
.
.
p value .
.
.
table vii shows the time used by the participants in both groups to accomplish three debugging tasks.
in table vii p1 p8 are the participants in microbat group and p9 p18 are the ones in whyline group.
overall microbat group accomplished the tasks in shorter time compared with whyline group.
we introduced the following null and alternative hypotheses to evaluate how different the performance of both groups is.
h0 the primary null hypothesis is that there is no significant performance difference between the two groups.
h1 an alternative hypothesis to h0 is that there is significant performance difference between the two groups.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we used wilcoxon s matched pairs signed ranked tests to evaluate the null hypothesis h0 in terms of the completion time on each task at a .
level of significance.
table vii shows that all the p values are less than .
thus we reject the null hypothesis for the completion time of all the three tasks and conclude that there is a significant performance difference between the two groups.
in addition table vii shows that microbat group completed those tasks in shorter average time.
hence we conclude that microbat group accomplished all the three debugging tasks in significant shorter time.
c. results user behavior rq2 table viii shows the frequency of each feature of microbat is used in each debugging task.
the features include four types of feedback provided by the participants frequency of bug free path inference taking effect noted by inference participants manual clicks on the trace steps noted by exploration on trace and un certain feedback on a trace step noted by undo .
table viii user beha vior of microbat group task par p1 p2 p3 p4 p5 p6 p7 p8 avg wrong variablevalue feedback .
.
.
wrong path feedback .
.
.
correct feedback .
.
.
unclear feedback .
.
.
inference .
.
.
exploration on trace .
.
.
undo .
.
.
overall we have the following observations.
first wrongvariable value feedback is the most frequent among all four types of feedback.
second the amount of unclear feedback is fairly low only p2 and p6 provided one such feedback .
third the bug free path inference took effect for many participants in task task but not in task .
fourth the participants also actively explored additional steps other than those recommended ones average .
times for task and task and .
times for task .
last but not least some participants would make wrong feedbacks so that they need to apply undo to correct their previous mistakes.
d. analysis on study results we analyzed the recorded videos and interviewed some participants to uncover the reason of the results showed in table vii and table viii.
why microbat group debug faster?
we found that the reason lies in the bug free path inference and the more explicit context information provided in microbat .first the bug free path inference reduced the number of inspected steps.
for example the trace in task consists of steps.
it involves loop iterations each of which further involves an average of nested loop iterations.
with the inference feature microbat can skip a large number of less suspicious iterations and recommend a more relevant one.
in contrast the generated questions in whyline are only relevant to data and control dominance relations.
when the iteration number increases the participants in whyline group usually need to manually go through a large number of iterations which takes considerable time and effort.
second the more explicit context information provided by microbat speeds up the debugging process.
most participants started debugging in a backward manner.
after a step or a source code line is recommend by microbat orwhyline they usually need to grasp the context of the recommended step.
otherwise they would easily get lost in the trace and fail to provide a clear feedback for microbat or select a correct question for whyline .microbat organizes the trace steps in a visualized hierarchical way so that participants can explore the tree structure to keep track of which iteration or which method invocation a step belongs to.
for example the buggy program in task adopts a greedy strategy to search the size of the largest consecutive subset see specification at .
in each iteration of search the participants should be aware of how many consecutive subsets had been formed.
the participants inmicrobat group can retrieve such contextual information by simply exploring the parent or children of a step and checking relevant variables in program state.
in contrast the participants in whyline group had to retrieve such information by iteratively checking the predecessors and successors of the recommended step in a stepwise manner which would usually break their mental flow and affect the debugging efficiency.
why few unclear feedback were provided?
our interview with some participants in microbat shows that they often cannot make a decisive wrong variable value wrong path or correct feedback.
however they did not prefer to provide the unclear feedback in microbat either.
we found the reason as follows.
despite participants would get unclear about certain step during debugging they usually knew how to explore the trace to make it clear.
since the participants were the first time to use microbat they had not built much confidence in the tool.
in addition they needed to keep their debugging mental flow when inspecting the trace.
hence when they had a clue to understand a step their choice is conservative i.e.
manually exploring the trace rather than relying on the tool s recommendation.
it also explains why the frequency of exploration on trace in table viii is high average .
for task task and .
for task .
why bug free path inference took effect differently on tasks?
the recorded video shows that some participants inmicrobat group adopt different strategies when accomplishing task task and task .
when accomplishing task task they located the bug in a backward manner as we expected.
therefore the wrong variable value feedback was provided more frequently average .
.
in task task and the bug free path inference can take effect average .
.
in task task .
however some authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
participants located the bug in task in a forward manner rather than backward manner.
the reason is as follows.
the buggy program in task adopts a binary search strategy to find an element in a rotated sorted array see specification at .
after providing several feedbacks at the end of trace some participants got no clue of the correct search range on an intermediate step even after checking its contextual steps.
therefore they decided to start from the very beginning step and explored the trace in a top down manner i.e.
going through the trace from high level steps to low level steps and finally locate the bug.
it also explains why the frequency of exploration on trace increases average .
times in task .
in contrast other participants took some time to summarize the loop invariants based on which they provided correct feedbacks on intermediate steps so that they can debug in a backward manner as in task task .
in summary the user study shows that microbat outperforms the state of the art tool in debugging efficiency.
nevertheless it also reveals possible useful improvement of our tool such as supporting loop invariant summarization and wrong user feedback detection.
we will pursue these improvements in our future work.
e. threats to v alidity there are mainly three threats in our user study.
first our recruited participants were not very familiar with the buggy programs which may potentially incur their spending lots of effort on understanding the code.
in order to mitigate this threat we describe the general idea of how each program works with one given test case.
second we assume that the experimental group is equivalent with the control group in their capability and experience which may be threatened by the actual differences between the two groups.
to mitigate this threat we allocated participants with comparable capability and experience into different groups based on our pre study survey.
third we used three debugging tasks in this study which may not be representative for all the cases.
further studies are required to generalize our findings in large scale industrial systems.
vii.
r elated work spectrum based fault localization techniques are widely used to locate bugs in terms of lines of source code.
these techniques compare the code coverage of passed and failed test cases to provide the most suspiciousness code to developers.
reps et al.
first proposed the idea of spectrum based fault localization and the researchers keep improving technique over the years.
renieris et al.
proposed a simple spectrum based technique and implemented a tool called whither.
wang et al.
improved the effect of fault localization by addressing the coincident correctness problem.
abreu et al.
further proposed an approach to detecting multiple faults by combining spectra and modelbased diagnosis.
an overview of spectrum based techniques can be checked in .
similar to spectrum based techniques delta debugging also requires a set of passedand failed test cases.
however these techniques compare the difference of test cases in more aspects than code coverage such as test input program states path constraints etc.
zeller et al.
first proposed the idea of delta debugging and used it in regression testing.
then they exploited the technique to simplify test case isolate bug causing variable and etc.
followed by their work misherghi et al.
proposed an improvement to refine the result of delta debugging.
with similar ideology qi et al.
and yi et al.
referenced the delta in versions of regression testing to facilitate fault localization.
different from these techniques our approach assumes no comparison with a passed test case.
in addition our approach locates the bug in finer grain in terms of buggy step instead of line of source code.
similar to our approach a lot of techniques leverage program execution trace for the fault localization.
ressia et al.
proposed an object centric debugging approach which facilitates tracking a specific object instance during the execution.
yuan et al.
proposed a tool called sherlog which infers the reason of program failure by combining recorded program log and source code.
pohier et al.
proposed omniscient debugger which records the whole execution trace of a debugged program and enables user to explore it.
ko et al.
built a tool called whyline which provides an interface to allow user to select some questions on program output and the tool can find possible explanation by dynamic slicing on the recorded program trace.
our approach is different from these works in that we allow richer types of feedbacks and support more sophisticated inference for suspicious steps.
additionally lo et al.
proposed a feedback based approach to improve spectrum based fault localization approach with user feedback on recommended suspicious program statements.
in contrast our approach allows developers to provide feedback on execution steps to localize the fault.
viii.
c onclusion and future work in this paper we propose a feedback based debugging approach which incorporates developers feedback on recorded program execution steps.
by inferring and approximating the bug free paths our approach aims to iteratively guide them to localize the root cause step.
our simulation experiment shows that our approach can effectively and efficiently locate the buggy step and our case study indicates that our tool microbat is practical to facilitate the debugging tasks.
in our future work we would pursuit new features such as solving longdominance effect summarizing loop invariant on trace steps and detecting mistaken feedback on microbat .
ix.
a cknowledgement we thank the anonymous reviewers for their valuable comments and suggestions.
this research has been partially supported by the national research foundation singapore no.
nrf2015ncr ncr003 and the national science foundation of china no.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.