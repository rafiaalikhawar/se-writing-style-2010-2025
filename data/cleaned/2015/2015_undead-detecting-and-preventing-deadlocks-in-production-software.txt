undead detecting and preventing deadlocks in production software jinpeng zhou sam silvestro hongyu liu yan cai and tongping liu department of computer science university of texas at san antonio usa state key laboratory of computer science institute of software chinese academy of sciences beijing china jinpeng.zhou utsa.edu sam.silvestro utsa.edu liuhyscc gmail.com ycai.mail gmail.com tongping.liu utsa.edu abstract deadlocks are critical problems afflicting parallel applications causing software to hang with no further progress.
existing detection tools suffer not only from significant recording performance overhead but also from excessive memory and or storage overhead.
in addition they may generate numerous false alarms.
subsequently after problems have been reported tremendous manual effort is required to confirm and fix these deadlocks.
this paper designs a novel system u ndead that helps defeat deadlocks in production software.
different from existing detection tools u ndead imposes negligible runtime performance overhead less than on average and small memory overhead around without any storage consumption.
after detection undead automatically strengthens erroneous programs to prevent future occurrences of both existing and potential deadlocks which is similar to the existing work dimmunix.
however undead exceeds dimmunix with several orders of magnitude lower performance overhead while eliminating numerous false positives.
extremely low runtime and memory overhead convenience and automatic prevention make u ndead an always on detection tool and a band aid prevention system for production software.
i. i ntroduction the lock is possibly the most widely used synchronization primitive in multithreaded programs.
it ensures that at any time at most one thread is allowed to execute inside a critical section.
common programming practice utilizes different locks to protect different shared data in order to avoid unnecessary conflicts which may easily cause a notorious concurrency problem deadlock.
generally deadlocks can be divided into two types resource deadlocks and communication deadlocks .
this paper only deals with resource deadlocks that are caused by locks without involving signals or other communication mechanisms e.g.
shared buffer .
deadlock occurs when a set of competing threads are simultaneously waiting for a lock held by their competitors as shown in figure .
in this example thread t1 has acquired lock l1and waits for lock l2.
however thread t2has acquired lock l2and waits for lock l1.
this situation prevents the program from making any further progress .
since deadlocks as well as other concurrency bugs only occur under specific inputs and with a precise timing requirement e.g.
two threads should acquire their first locks simultaneously they cannot be completely expunged during development phases due to incomplete tests.
they may be unavoidably leaked into deployed software which may result l t t l fig.
.
a simple deadlock example.
in unpredictable losses as programs must be restarted when deadlocks occur.
deadlocks continue to be a serious concern accounting for more than of reported concurrency bugs .
a significant amount of work focuses on detecting deadlocks using static and dynamic approaches.
static detection tools such as may report numerous false positives and are difficult to scale to large programs .
dynamic techniques primarily focus on detecting potential cycles within the execution trace .
existing dynamic approaches have the following problems.
first existing systems record the full execution context including call stacks and the order of all lock acquisitions and releases which imposes significant overhead in the recording phase.
for instance the performance overhead of deadlockfuzzer is between and12 .
second the execution trace can be extremely large for longrunning applications e.g.
server applications thus leading to unaffordable memory and or storage overhead.
third detecting potential cycles within a large execution trace may require a considerable amount of time as long as two days .
together these shortcomings prevent existing detection techniques from gaining widespread adoption within deployed systems.
some approaches aim to fix known deadlocks by relying on the precise information of deadlocks that is difficult or impossible to obtain currently due to the problems discussed above and they may require additional manual effort e.g.
recompilation before users can actually prevent problems.
also many existing techniques may additionally generate new deadlocks through the introduction of gate locks as discovered by dfixer authors .
dimmunix pioneers the combination of detection and prevention in a single system without involving additional manual effort .
for detection dimmunix employs a monitor thread to periodically check 100ms by default whether recent locks generate a cycle of lock acquisitions.
if so dimmunix stops a susceptible program immediately and outputs the signature of locks into a persistent file used to guide its prevention during future executions.
to prevent deadlocks dimmunix obtains the .
c ieeease urbana champaign il usa technical research729 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
call stacks by invoking the very slow backtrace api upon every lock acquisition and confirms whether this acquisition matches one of the known deadlock patterns.
if so the current thread will be forced to wait.
for every lock release dimmunix checks whether a potential deadlock has been broken.
if so it may wake other threads waiting for the release event of this lock.
dimmunix allows a deadlock prone system to function correctly while developers are fixing these discovered bugs which is a very interesting and helpful idea that could be potentially suitable for the deployment environment.
however dimmunix suffers from a large number of false positives a fact that is self acknowledged incurs large runtime overhead as high as slower based on our evaluation and could possibly miss some deadlocks as it only checks recent locks.
these serious limitations prevent dimmunix from actually being deployed in production software.
this paper presents a novel system undead to defeat deadlocks in production software.
it shares the same target as dimmunix it can detect deadlocks and protect a program immediately and automatically whenever potential or actual deadlocks are found during prior executions.
undead makes several key design choices to reduce overhead and improve accuracy of detection and also proposes a novel lock variablebased approach to prevent deadlocks automatically.
all of these details are further described in section ii.
a. contributions overall u ndead makes the following contributions undead provides an efficient and effective detection tool undead s detection tool imposes only negligible performance overhead less than on average and avoids the significant number of false positives.
it only adds memory overhead in total.
undead proposes a novel lock variable based approach to prevent deadlocks this novel approach supports deadlock prevention based on an incomplete execution trace any call stacks related to these lock variables even non exercised call stacks will be unable to cause the deadlock.
undead s prevention can also be seamlessly integrated with its detection without any manual intervention.
we performed substantial evaluation on existing benchmarks and real applications and compared it with existing work evaluation results confirm the efficiency and effectiveness of u ndead.
b. outline the remainder of this paper is organized as follows.
section ii first describes the background of deadlocks as well as the basic idea of undead.
section iii and section iv describe the implementation of undead s detection and prevention mechanisms respectively.
then section v presents experimental results.
in the end we discuss the related work in section vi and conclude in section vii.ii.
o verview a. background of deadlocks as described in section i deadlocks occur when the relationship between threads and locks generates a cycle.
deadlocks may be easily diagnosed by experts when they actually occur.
experts could attach a debugger to the hanging process check the call stacks of lock acquisitions made by each thread then possibly infer the exact causes of the deadlock.
however this discovery process requires expert knowledge and is not suitable for normal users in the production environment.
more importantly this discovery can only uncover actual deadlocks while leaving behind potential deadlocks that may incur unpredictable losses in a deployed environment.
based on our observation deadlocks have the following key properties .
only nested locks are capable of producing deadlocks since a single level lock will not be involved in a holdand wait situation and thus will not generate a circle as shown in figure .
in reality the majority of lock acquisitions are not nested without lock dependencies but rather single level locks.
this fact is further confirmed by the statistics listed in table i. deadlocks are very sensitive to timing and only occur when all participating threads can successfully acquire their first locks prior to any thread subsequently requesting an additional lock.
as illustrated in figure if one thread can first acquire both locks l1andl2successfully which may cause the competing thread to fail to acquire its first lock the deadlock will not occur.
b. deadlock detection undead s detection aims to detect deadlocks for use by its prevention system as well as for normal users while keeping low performance and memory storage overhead.
undead makes several design choices to achieve this target.
we make the first key observation a program typically only has a bounded number of unique lock dependencies although a program may execute for a long time .
this key observation is further confirmed via extensive experiments where the results are shown as table i. the lock dependency is first introduced by prior work deadlockfuzzer as discussed in more detail in section iii c .
when a program has ndistinct locks the maximum number of unique lock dependencies consisting of two locks will be equal to the permutation p n .
in reality the actual number is even lower than this maximum number.
although the bounded property may not hold if a program dynamically creates and destroys locks we did not find such cases in our experiments.
firstly based on this key observation undead only records unique lock dependencies under nested locks for every thread during the execution instead of recording the entire history of lock acquisitions and releases.
it will skip all duplicated lock dependencies.
note that this will not compromise detection effectiveness as all distinct lock dependencies with their unique call stacks are still recorded completely which can achieve authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the same guarantee as existing work.
this method prevents an ever increasing trace log for long running applications instead the size of the execution trace becomes stable after seconds or minutes of execution.
a small execution trace greatly reduces not only the memory storage requirement but also the amount of time required for the detection.
secondly undead also avoids unnecessary information during the recording phase.
single level locks are never recorded because they will never cause potential deadlocks as property discussed in section ii a.undead also discards lock acquisition events when only a single thread exists since deadlocks typically involve more than one thread.
thirdly undead minimizes the overhead of collecting call stacks.
undead utilizes the following two methods to reduce the overhead.
undead does not fetch the call stacks of first level locks.
this method reduces a large number ofbacktrace invocations but creates some inconvenience.
although undead reports the address of locks involved in deadlocks as well as where threads are hanging it cannot report statements where the first level locks were acquired.
users are required to manually identify the information of first level locks for the purpose of detection.
however this problem will not affect undead s prevention.
undead further avoids invocations of backtrace when both stack offset and lock address of a lock acquisition are the same as existing ones.
stack offset is utilized here since different threads may possess the same stack offset for the same call stack.
it is possible although unlikely that two different call stacks will have the same stack offset where users may have to identify correct call stacks manually.
again this shortcoming only affects the reporting functionality and will not reduce the effectiveness of u ndead s detection and prevention.
c. deadlock prevention undead starts from a novel observation concerning the prevention of deadlocks replacing multiple locks within the same deadlock set with the same lock eliminates the possibility of deadlock shown in figure .
replacing multiple locks in the same deadlock set mimics the effect of using a coarse grained lock rather than using multiple fine grained locks.
this method eliminates the timing property of deadlocks.
in the example shown in figure when two locks l1andl2 are actually using the same lock l12 the deadlock will never occur.
if one thread acquires lock l12successfully it will prevent another thread from acquiring the same lock due to the exclusivity property of mutex locks.
this method is significantly different from signature based approaches .
for signature based approaches they require call stacks of all lock acquisitions that are involved in a deadlock so that they can explicitly locate and fix buggy acquisitions to avoid possible deadlocks.
they cannot prevent deadlocks if a single statement is neglected to be changed.
compared with these approaches undead supports prevention based on an incomplete execution trace as long as some call stacks of suspect lock variables are detected to have potential deadlocks any call stacks consisting of these variables even call stacks not encountered in previous detection will be unable to cause the deadlock.
undead replaces all of these locks with the same physical lock during the initialization phase and prevents any possible deadlock afterwards.
also undead requires no change to the program and no re compilation while the prevention can be enabled automatically during future executions.
undead also has one advantage when compared to dimmunix a signature based approach requiring no additional manual effort.
undead significantly reduces the prevention overhead since there is no need to check the signature on every lock acquisition and release.
performance concern this naturally raises a concern with respect to the performance impact that is whether merging multiple locks into the same lock will significantly increase lock contention.
in practice lock contention may not be substantially increased due to the following two reasons.
first deployed software has been extensively tested and typically will not contain a large number of deadlocks inside.
this fact will limit the number of distinct locks that should be merged.
second all locks belonging to the same deadlock set are less likely to be acquired frequently since deadlocks caused by frequently acquired locks are most likely to have been eliminated during development phases.
evaluation results in section v confirm that undead only introduces around performance overhead which is comparable to the state of theart dfixer .
thread thread lock l1 lock l3 i n t e r m e d i a t e l o c k lock l2 lock l3 lock l2 fig.
.
a potential new deadlock due to the lock merge.
thread thread lock l1 lock l1 lock l2 unlock l1 cond wait cond l2 lock l2 unlock l2 c o n d s i g n a l cond unlock l1 unlock l2 fig.
.
atomicity violation due to the lock merge.
correctness concern we have identified two possible correctness issues related to lock merging shown as figure and figure .
figure shows an example of a potential new deadlock.
in this example the acquisition of lock l3is located between l1andl2in thread and thread will acquire l3 before acquiring l2.
when l1andl2are merged into a new lockl12 it may create a potential deadlock caused by the lock set offl12 l3g.
figure shows another example in which the merging of l1andl2may cause an atomicity violation.
thread should release the merged lock l12at the invocation point ofcondwait line of thread and can possibly violate the original atomicity semantics since other threads may be able to acquire the lock l1in the middle.
however invoking a conditional wait while holding two locks is actually a wellknown deadlock pattern reported by existing work .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
original programlock object 10x60000 00lock object 20x60000 ...0x60000 50with prevention0x60000 000x60000 ...0x60000 50shared lock 10x12340c0000 ...0x12340c0000000x12340c0000000x60000 080x60000 30redirectionfig.
.
the idea of deadlock prevention.
in figure thread may never acquire l1successfully and would subsequently be unable to wake up thread .
undead provides the following guarantees for these two correctness concerns all locks e.g.
l3of figure occurring in the middle of a known deadlock set e.g.
l1 l2 and which may potentially cause deadlocks will be merged into the same deadlock set.
thus the situation listed as figure will never create new deadlocks if such a lock acquisition e.g.
l3 has been observed during previous executions.
for cases such as figure undead only reports the deadlocks to users but never performs automatic prevention.
thus it does not introduce potential atomicity violations.
all conditional waits inside nested locks are recorded to avoid this problem.
iii.
d eadlock detection for deadlock detection undead first records necessary lock related events during executions section iii a .
then it can detect actual deadlocks periodically section iii b or detect actual and potential deadlocks on program exit or upon receiving instruction from users section iii c .
a. logging phase undead logs only necessary lock related information.
it prunes all unnecessary information during the logging phase including single level locks unnecessary lock acquisitions during the single threaded period and duplicated lock dependencies.
undead intercepts mutex lock operations including locks unlocks and try locks .
for try locks undead only records successful acquisitions.
undead also records the conditional waits inside nested locks in order to avoid the problems listed in figure .
additionally undead obtains call stacks of mutex initializations as this information will be employed by its prevention system to accomplish deadlock prevention section iv .
undead collects the call stacks of lock acquisitions using backtrace but handles it differently from all existing work.
undead maintains the number of locks held by each thread separately.
it does not obtain the call stacks of first level locks but rather simply records the addresses of these locks.
when a thread is acquiring more than one lock undead first confirms whether the corresponding lock dependency already exists.
if the lock dependency exists undead further determines whether it is necessary to obtain the call stack for the purpose of reporting.
currently undead confirms whether both stack offset and lock address inside the lock dependency of a lock acquisition are the same as existing ones since acquiring the call stack using backtrace can be veryexpensive.
if both of these values and the lock dependency are the same undead does not obtain the call stack for this lock acquisition.
the combination of the stack offset and the lock address is generally an adequate indicator of the call stack as the chance of sharing the same stack offset and lock address but with a different call stack is extremely low.
the only situation with confusion is when there are multiple acquisitions of the same lock within the same function.
for this case users may be required to check all lock acquisitions inside the same function manually if they would like to identify which acquisition is involved in the deadlock.
note that undead s prevention mechanism does not rely on the call stacks of acquisitions and requires no manual effort.
the reason why undead uses the stack offset is that multiple threads inside a multithreaded program have the same offset but different absolute addresses.
if the call stack is new undead additionally records it.
the call stacks of lock acquisitions could be utilized by existing prevention tools or used to facilitate manual fixes.
in the implementation all lock dependencies associated with each thread are stored in a per thread hash table for performance reasons.
this method may introduce slightly more memory overhead used to hold unique lock dependencies but avoids concurrent accesses from multiple threads.
also it eliminates the necessity of using locks to protect the actions of searching and adding new lock dependencies.
to save lock dependencies undead utilizes the combination of two locks as the key for the hash table.
for instance if lock l1is dependent on locks fl2 l3g undead utilizes the xor value of the addresses of the two most internal locks e.g.
l1andl2here as the search key.
this method substantially reduces conflicts on hash keys and thus considerably reduces the number of comparisons required to check the duplicates of a lock dependency.
undead also improves the performance of obtaining perthread data.
during development we discovered significant performance overhead associated with retrieving per thread data upon every intercepted function invocation if we simply utilized the thread local storage area declared using the keyword thread .
when using thread local storage the system assigns a unique global id to each thread local variable and maintains a thread local storage tls lookup table for all threads.
searching the thread local area involves at least the cost of an external library call as well as a lookup in the indexed table.
thus undead proposes a novel method to circumvent the cost of using tls variables .
because every thread will be allotted its own stack the address of a stack variable can be utilized to identify a particular thread.
thus undead initially allocates a global map which will be used to create the stack areas for every thread.
upon creation of each thread undead assigns a specific stack area to the thread based on its internal thread index such as 8mb per thread by default.
during execution undead is able to compute the thread index by dividing the offset between the address of a stack variable and the starting address of the global stack map with the stack size.
with the computed thread index undead authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
can efficiently obtain the per thread data from a shared global array.
b. periodic detection undead creates a monitor thread to perform detection periodically during normal executions which is similar to existing work .
this option allows undead to timely detect deadlocks in long running applications.
every thread maintains its own current locking set.
the monitor thread is awakened periodically.
upon waking up the monitor thread takes a snapshot of the current locking set for each thread and utilizes the simple loop detection as shown in figure to check whether there is a cycle inside.
if a cycle is found the monitor thread will confirm again whether the current lock holding status of related threads has been changed.
the same status indicates that the program is actually in deadlock status and cannot proceed.
otherwise it is a potential deadlock that may not actually occur.
undead allows a program with a potential deadlock to proceed as normal.
note that undead does not change the original lock logic for periodic detection which simplifies implementation and possibly benefits performance.
instead undead utilizes another confirmation to avoid any possible false positives caused by using the snapshots.
if a deadlock is actually detected undead further performs comprehensive detection to identify any other potential deadlocks as discussed in section iii c. c. comprehensive detection undead performs comprehensive detection when the program is about to exit or when it receives special instructions from users.
as discussed above undead only keeps unique lock dependencies and prunes all unnecessary information.
this reduces undead s detection time due to handling many fewer items.
intercepting exits and user instructions a program may terminate in various ways.
aside from exiting normally a program may exit by explicitly calling abort or due to failed assertions or other program errors such as segmentation faults.
undead handles these different exit patterns.
to intercept normal exits undead places the detection procedure within a function marked with the destructor attribute.
furthermore undead also registers a signal handler for signals such as sighup sigquit sigint and sigsegv from which it invokes exit such that the default exit handler will then be invoked.
additionally users may send a special signal using the sigusr2 signal number to invoke the detection procedure on demand.
detection algorithm undead utilizes the known deadlock detection method igoodlock which was proposed by deadlockfuzzer and extended by magicfuzzer .
however the idea of pruning unnecessary information is novel to this paper which is the key reason that undead keeps a low performance and memory storage overhead and is different from these existing works .
igoodlock defines the following basic concepts lock dependency a triple d ft l lgindicates that a thread tis waiting for lock lwhile holding all locks in setl.
lock dependency chain a sequence of lock dependencies c hd1 d ki describes a relationship among the lock dependencies of multiple threads each lock dependency inside cis from a distinct thread.
8i6 j l itlj ?
which means no locks are held in common by any distinct pair of threads.
8i2 li2li which indicates the i th thread has already acquired the lock li which the ith thread is trying to acquire.
cyclic lock dependency chain a cyclic chain is a special type of lock dependency chain where lk2l1in order to form a circle.
as described above each thread records its own lock dependencies within its own per thread hash table which eliminates the necessity of including the thread information from the lock dependency.
for detection undead searches for lock dependency chains by checking all possible permutations of lock dependencies among two threads then three threads and so on.
undead utilizes a depth first algorithm to iteratively explore dependency chains.
if there exist lock dependency chains undead further checks for cycles within these dependency chains.
a cyclic dependency chain indicates a potential deadlock problem which undead will report in the end.
reporting deadlocks undead generates two different reports one for normal users or signature based prevention systems the other for its prevention system.
for the first report undead reports all information necessary to assist deadlock fixes such as the call stack with source code line information of initialization and acquisitions of each involved lock not including first level locks and the address of all involved locks.
programmers can proceed to fix these discovered deadlocks based on u ndead s report.
for its prevention system the report currently takes the format of a text file in which every deadlock set is separated by a special symbol.
when multiple deadlock sets exist undead further confirms whether or not they share any common locks.
if true undead merges various lock sets containing the common lock into the same deadlock set which will utilize the same physical lock in prevention.
for the example of figure l3will be merged into the same deadlock set offl1 l2g.
inside the same deadlock set each entry on a separate line will represent a different lock the format for which appears as such lock address initialization call stack .
if a lock is a global variable that is initialized via the pthread mutex initializer macro its initialization call stack will be empty.
thus undead s prevention system can handle them accordingly.
depending on the preferences of the user undead may skip a deadlock set that contains a conditional wait while holding multiple locks.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d. limitations undead may experience false negatives.
like other dynamic tools undead cannot detect deadlocks if the corresponding code is not exercised.
currently undead cannot detect resource deadlocks caused by conditional variables.
similar to existing work undead does not recognize other types of locks such as spin locks or read write locks which will be a focus of our future work.
in theory undead can produce false positives as well.
when two lock sets have a strong happens before relationship which prevents their concurrent appearance such as those ordered by conditional waits or barriers undead may incorrectly generate false alarms.
however experimental results in section v d confirm that undead is very effective at capturing potential deadlocks in reality without any false alarms.
iv.
d eadlock prevention this section describes how undead s prevention system works automatically based on its detection results.
undead s detection system reports potential deadlocks where different lock sets are separated using a special symbol in the deadlock history file.
as discussed in section ii c all locks within the same deadlock set are redirected into the same physical lock as shown in figure which eliminates the deadlock problem.
for the example shown in figure if lock l1and lock l2 are replaced with a new lock l12 then t1 s acquisition of l1 now l12 will prevent t2 s acquisition of l2 due to their uses of the same lock l12.
therefore it is impossible to generate a circle preventing the deadlock caused by lock l1and lock l2.
as shown in figure the new shared lock l12will be allocated from an easily identifiable memory mapped region such as a continuous region starting from 0x12340 c000000 .
undead will store the address of l12into the first word of both l1andl2.
originally this word includes two fields lock the lock state and count the number of recursive locks which should not fall into the special range discussed above.
thus when the first word of a lock falls within the special range it is a pointer to a shared lock.
undead then forces the lock acquisition onto the shared lock.
this redirection mechanism is adapted from our existing work syncperf .
the detailed implementation is discussed as follows.
a. implementation initialization one type of lock variables are initialized via the pthread mutex initializer macro while another type are initialized by explicitly invoking a mutex initialization procedure.
locks of the first type have no call stacks inside the deadlock history file and these locks can only be global variables.
therefore they will be redirected before entering the application s main routine.
undead sets its initialization function with the constructor attribute in order to perform this initialization before entering into the main routine.
for the other type of locks undead intercepts the initializations of all locks and confirms the call stack of theseinitialization invocations.
when an initialization has the same call stack as those listed in the deadlock history file undead redirects it appropriately as shown in figure .
redirection during prevention undead intercepts every lock acquisition and release as well as conditional waits.
it checks whether the lock s first word falls within the special range.
if so undead redirects the operation to the shared lock.
otherwise it simply performs the operation on the original pthread mutex t object.
at every lock acquisition and release the overhead imposed by undead is limited to a fetching operation and a checking operation which is significantly lower than that of dimmunix.
handling recursive and irregular locks undead also handles recursive and irregular locks carefully.
if a lock has been successfully acquired by the current thread another invocation on the same lock will fail.
therefore a simple and naive solution is to change the shared lock to be a recursive one by setting the pthread mutex recursive attribute.
however this simple solution cannot handle a program with an irregular lock pattern as shown in figure .
there is no problem for this example initially without the redirection mechanism since releasing an already released lock such asl2in figure will be silently turned into a no operation.
however if a recursive lock is utilized to replace these two locks such as l1andl2in the example the code after line of figure will not be protected by any lock which violates the original semantics of the program.
lock l1 lock l2 unlock l2 unlock l2 i r r e g u l a r l o c k p a t t e r n unlock l1 fig.
.
irregular lock pattern.
undead handles this problem by tracking the locking count of every specific lock with its original address in the deadlock sets.
for every shared lock each thread maintains a per thread lock count and an array of lock counts that track the status of all original lock variables inside the same deadlock set.
the actual shared lock will only be acquired at the first acquisition while subsequent acquisitions only increment the lock count of its corresponding original lock variable.
this also helps report some potential problems of original lock uses.
if an original lock variable is acquired multiple times which indicates a double lock problem in the original program undead can report this problem.
during a release undead first confirms whether the local lock count is larger than .
if true it decrements the local and per thread lock counts at the same time and only invokes the actual release operation when the per thread lock count is .
otherwise it simply omits this operation and returns .
this method matches the original semantics.
b. limitations undead s prevention is only enabled when evidence of potential deadlocks is detected with a cyclic lock dependency authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
chain.
note that undead s prevention does not require a deadlock to occur.
performance concern undead s prevention can increase the lock contention rate thus affecting the performance of applications by merging multiple locks into a single lock.
however it only requires simple engineering effort to track the contention rate of merged locks and disable them if the rate is higher than a specified percentage.
the other candidate is to request confirmation from users undead s prevention may skip a deadlock set based on the input of users.
correctness concern undead provides the guarantees as discussed in section ii c. in extremely rare situations undead may add potential new deadlocks or violate atomicity when the critical information is not observed during prior executions.
however the deadlock and atomicity violation may not actually occur during executions since they are both sensitive to timing.
also upon the end of an execution undead will adjust its deadlock sets based on new evidence and further prevent the potential problems in future executions.
v. e valuation a. experimental setup we performed experiments on a core quiescent machine with two sockets installed with intel r xeon r cpu e5 processors.
this machine has 256gb of main memory and 256kb l1 2mb l2 and 20mb l3 cache.
the experiments were performed on the unchanged ubuntu .
installed with linux .
.
kernel.
we used gcc .
.
with o2 and g flags to compile all applications.
b. performance overhead for the performance overhead we compared undead with the only available work with similar functionality dimmunix .
the source code of dimmunix was downloaded from google code .
because dimmunix halts a program immediately after detecting potential deadlocks inside it often cannot complete applications normally due to many false positives.
for performance comparison we allowed dimmunix to run until program completion by disabling the halting mechanism.
we evaluated multithreaded applications in total.
among these applications ten of them are from the parsec suite while others are real applications including mysql .
.
memcached .
.
apache httpd .
.
sqlite .
.
aget pfscan and pbzip2 .
parsec applications were exercised using native inputs with threads .mysql was tested using thesysbench application with threads and maximum requests.
memcached was tested using the python memcached script but changed to loop times in order to obtain sufficient runtime.
sqlite was tested using a program called threadtest3.c and the total amount of iterations is shown in the figure.
apache was tested by sending 000requests via ab and the requests per second is shown in the figure.
for aget we collected the execution time of downloading 600mb of data .
.
.
.
.
.
.
.
.
.
.
.
normalized performancedimmunixundead logundeadfig.
.
normalized runtime overhead of dimmunix and undead.
undead lists the overhead with both detection and prevention which is comparable to dimmunix s overhead.
undead log shows the runtime overhead of undead s logging mechanism only.
from another quiescent server located on the local network.
forpfscan we performed a keyword search within 800mb of data.
for pbzip2 we performed compression on a file containing 150mb of data.
the average results of ten executions of these applications are shown in figure where all values of undead and dimmunix are normalized to that of the default pthreads library.
a taller bar indicates a larger overhead.
undead has two sets of performance data in figure undead log is a special build with logging only where both detection and prevention mechanisms are disabled in order to confirm the efficiency of undead s logging strategy undead represents the full version with all functionalities enabled logging detection and prevention .
because dimmunix combines logging with its detection and prevention we only show one set of data.
dimmunix should be compared to undead in figure with the same functionality.
as shown in figure undead s logging only introduces around performance overhead on average.
overall undead introduces around .
overhead on average with all mechanisms enabled.
for all applications except fluidanimate undead s performance overhead is less than .
in contrast dimmunix imposes more than performance overhead on average.
without fluidanimate dimmunix s average overhead is still more than .
we further collected the lock characteristics of these applications which helps explain the performance problems of both undead and dimmunix.
the data is shown as table i. the time column shows the total execution time of each application.
the locks column shows the number of distinct lock objects and the lock acqs column shows the number of lock acquisitions.
total and unique indicate the amounts of all and unique lock dependencies respectively.
undead imposes around performance overhead for thefluidanimate application which is still orders of magnitude lower than dimmunix s overhead .
the data shows that this application issues approximately .
billion lock acquisitions within seconds execution and contains authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i c haracteristics of evaluated applications applicationstime locks lock acqs dependencies s total unique blackscholes .
bodytrack .
canneal .
dedup .
facesim .
ferret .
fluidanimate streamcluster .
swaptions .
x264 .
aget .
apache .
memcached .
mysql .
.
.
pbzip2 .
pfscan .
sqlite .
different lock objects.
undead should collect the call stacks for each distinct lock initialization and also record the address of every lock acquisition.
this explains the significant performance overhead for this application.
however we expect that normal applications should not have such extensive lock acquisitions such as mysql andmemcached here.
thus undead s performance overhead should be totally acceptable.
table i also helps explain the performance overhead of dimmunix as well.
to our understanding dimmunix imposes high overhead because it must obtain call stacks of all lock acquisitions.
for applications with a significant number of lock acquisitions such as fluidanimate mysql facesim andsqlite dimmunix imposes significant performance overhead.
table i also confirms several design choices employed by undead.
the number of single level lock acquisitions is much larger than the number of nested locks.
for instance fluidanimate has more than .
billion lock acquisitions but with zero nested locks.
similarly mysql s quantity of single level lock acquisitions is times more than the number of nested locks.
thus avoiding the overhead of obtaining call stacks for first level locks can greatly reduce logging overhead.
the total number of lock dependencies is much larger than the number of unique dependencies.
facesim has around lock dependencies but with only that are unique.
thus recording only the unique lock dependencies can largely reduce the detection time and memory disk consumption.
the mechanism of recording all lock acquisitions employed by existing work is not suitable for long running applications as the ever expanding trace will consume too much memory disk capacity and significantly increases the detection time.
c. memory overhead the physical memory overhead from using pthreads dimmunix and undead is shown in table ii.
for smallfootprint applications such as aget andswaptions undead may add a high percentage of startup memory overhead introduced by its recording mechanism due to utilizing sometable ii m emory consumption mb applications default dimmunix undead blackscholes bodytrack canneal dedup facesim ferret fluidanimate streamcluster swaptions x264 aget apache memcached mysql .
.
pbzip2 pfscan sqlite total pre allocated mechanisms inside.
however if we sum the memory usage across all applications undead imposes only memory overhead when compared to the default pthreads library which is similar to dimmunix s memory overhead.
we further performed another experiment to verify whether the memory overhead introduced by undead is stable across different sizes of input.
we verified the memory consumption ofmysql .
.
server and showed the results in figure .
the memory consumption of undead remains almost the same across varying numbers of requests where the number of unique lock dependencies has a similar trend as well.
d. detection effectiveness this section confirms the detection effectiveness of both undead and dimmunix false negatives and false positives.
we evaluated all applications in section v b as well as real world deadlock problems frequently utilized by previous work .
the bug in mysql .
.
is a synthetic bug used in existing work .
effectiveness results are shown in table iii.
those applications without false positives and false 104k 105k 125k 305k 2m 20m memory consumption mb of requests per thread of lock acquisitions fig.
.
memory consumption of undead when sysbench utilizes different numbers of requests and different numbers of lock acquisitions to exercise the mysql .
.
server.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii c omparison of detection effectiveness applications of cycles real deadlocks dimmunix undead bodytrack dedup facesim ferret fluidanimate streamcluster hawknl .6b3 mysql .
.
mysql .
.
pbzip2 sqlite .
.
negatives for both undead and dimmunix are not shown in this table.
in these experiments undead reports no false positives and identifies all known deadlocks.
thus undead is very effective at detecting deadlocks although it cannot completely avoid false positives and false negatives in theory as discussed in section iii d. in contrast dimmunix reports false alarms on evaluated applications and misses an actual deadlock in mysql .
.
.
when an application has more than one deadlock dimmunix may only detect one deadlock and then kill the program inducing false negatives.
dimmunix may report different results on different executions as its monitor thread may check deadlocks at random points.
false positives of dimmunix are due to its implementation fault based on our understanding of their source code.
dimmunix accidentally has two different states for the same lock in its resource allocation graph which mimics the effect of two continuous lock acquisitions of the same lock from the same thread.
dimmunix treats this behavior as an irregular lock pattern that can cause a program to hang so it reports this to users.
this explains why dimmunix has many false positives even when a program e.g.
fluidanimate only contains single level locks.
e. prevention effectiveness we evaluated the effectiveness of undead s prevention system for applications containing known deadlocks by comparing with dimmunix and the state of the art dfixer .
for all of these buggy applications including hawknl .6b3 sqlite .
.
and mysql .
.
these three prevention systems can successfully prevent those deadlocks.
as shown in table iv the merged locks column lists the number of locks that are actually merged by undead.
real indicates the number of real locks contained in the deadlock set while the add column lists the number of locks that should be additionally merged in order to avoid new deadlocks.
the conflict acqs column lists the number of lock conflicts during the execution with pthreads orig and undead using buggy inputs.
undead adds one additional lock into the deadlock set for hawknl .6b3 andmysql .
.
to avoid the problem as shown in figure .
f .
prevention performance figure shows that undead s prevention mechanism imposes little overhead for programs without deadlocks sinceundead s overhead with prevention is similar to the one undead log without prevention.
the performance results with deadlocks are shown in table iv.
when unnecessary invocations of sleep inside these programs were removed these executions finished very quickly.
for example hawknl andsqlite only execute for less than .
seconds which makes the performance comparison meaninglessly.
however both undead and dfixer perform better than dimmunix but worse than the original executions marked as orig .
undead may introduce some startup overhead undead should read the bug report file redirect locks and check whether a lock operation should be performed on a shared lock.
the number of lock conflicts can be slightly increased with the prevention system of u ndead.
we further confirmed the prevention overhead on normal executions which is more important than small inputs.
we utilized sysbench to exercise both mysql .
.
and mysql .
.
with threads and maximum requests.
as shown in table v both undead and dfixer significantly outperform dimmunix.
the overhead of both undead and dfixer is less than while dimmunix runs up to slower.
for mysql .
.
dimmunix encounters many false positives caused by the levels of call stacks and its performance deteriorates significantly undead achieves similar prevention performance as dfixer despite its additional workload such as call stacks fetching and lock redirection.
the comparison between dfixer and undead is further discussed in section vi.
vi.
r elated work a. detection and prediction there are two types of dynamic tools used for detecting deadlocks.
one type is very efficient comparable toundead but which cannot report potential deadlocks.
for instance pulse periodically checks whether the system has been blocked by checking whether the resource graph contains a possible cycle.
the other type of detection tools focus on detecting potential deadlocks that do not occur in the execution.
many works aim to predict cycles however these works typically incur significant performance overhead as high as multiple orders of magnitude .
for example sherlock introduces more than overhead compared to that of deadlockfuzzer while deadlockfuzzer itself operates with up to overhead.
wolf reduces its recording overhead over deadlockfuzzer by about .
in contrast undead exhibits much lower recording overhead than these tools a result of its careful design.
also undead imposes low memory overhead by pruning all unnecessary information during execution.
there exist works that also attempt to utilize scheduling to trigger deadlock occurrences .
they typically utilize dynamic analysis to identify potential deadlocks at first then direct a scheduler to reproduce these potential deadlocks with high probability.
however these approaches reduce convenience by adding an additional authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv c haracteristics of undead s prevention applications bug idtime s merged locks conflict acqs orig undead dimmunix dfixer real add orig undead hawknl .6b3 n a .
.
.
.
sqlite .
.
.
.
.
.
mysql .
.
.
.
.
.
table v n ormalized performance and lock conflicts under normal inputs applications bug idnormalized slowdown normalized conflicts undead dimmunix dfixer orig undead mysql .
.
.
.
mysql .
.
.
.
confirmation stage.
armus detects barrier deadlocks on a set of synchronization models .
stepdad helps reproduce the deadlocks inside database problems .
the lock confirmation can serve as a great supplement to undead though with a different focus.
contege and omen generate concurrent test cases toward triggering deadlocks and other concurrency bugs.
they could possibly integrate with undead s detection to find additional deadlock problems.
b. prevention fixing and recovery some previous work prevents deadlock occurrences by patching programs relying on precise signatures of deadlocks that are difficult or impossible to obtain due to the lack of efficient detection tools.
gadara synthesizes the discrete control theory at source code level to avoid deadlocks by inserting some gate locks during compilation then dynamically chooses to enforce them at runtime.
however as observed by dfixer gadara can also introduce potential deadlocks and it reports a maximum of performance overhead.
lock capabilities can statically verify a deadlock problem then may be used to prevent deadlock occurrences .
various other works also take similar approaches such as afix cfix axis grail and which can introduce potential deadlocks as well.
sammati proposes an online prevention system that is not based on detection results .
it can checkpoint the state of the program upon lock acquisitions and monitor the possible cycles during execution.
if a deadlock is found the program is rolled back to a previous checkpoint where the program is re executed to avoid the susceptible schedule .
however sammati may impose more than performance overhead for some applications.
similar to dimmunix redact utilizes a supervisor controller to prevent deadlocks in database applications.
differently it uses static analysis to find hold and wait cycles in transactions and feeds the analysis results to the controller.
afterwards it utilizes a similar mechanism as that of dimmunix to prevent the deadlocks.
it delays a transaction if it is involved in a hold and wait cycle.
dfixer is the previous state of the art in the deadlock prevention.
it proposes a lock pre acquisition idea that enables one thread involved in a deadlock to acquire all locks in the same deadlock set at one time.
this eliminates the hold andwait condition necessary for a deadlock to occur which issimilar to undead s idea.
dfixer also proposes context aware conditionals to avoid the introduce of new communication deadlocks which may avoid problems as shown in figure .
dfixer has the following significant differences from undead dfixer requires an additional recompilation which cannot work on legacy applications without the source code available.
in contrast undead directly works on commercial off theshelf cots binaries without recompilations.
dfixer requires precise inputs on deadlocks where it may not avoid deadlocks caused by non instrumented statements.
undead proposes a variable based mechanism that can prevent all deadlocks related to known lock variables preventing deadlocks based on incomplete trace.
dfixer may require the special handling for complexed situations such as multiple deadlocks caused by the same set of locks or irregular lock patterns.
on the contrary undead s mechanisms can handle complex situations easily but with possible performance compromise.
vii.
c onclusion this paper introduces undead a novel system that can efficiently detect and prevent deadlocks in production software.
as a detection tool undead only imposes runtime overhead and memory overhead.
evaluation results show that undead detects all known deadlocks while reporting no false positives.
undead also proposes a novel idea of merging locks to prevent deadlock problems temporarily providing a band aid for production software.
undead s prevention system can automatically read detection results and strengthen buggy programs by preventing potential deadlocks in future executions.
undead is available at com utsasrg undead.