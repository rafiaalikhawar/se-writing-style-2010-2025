loop path reduction by state pruning jianxiong gao electrical and computer engineering university of illinois at urbana champaign champaign illinois usa gao2 illinois.edusteven s. lumetta electrical and computer engineering university of illinois at urbana champaign champaign illinois usa lumetta illinois.edu abstract pathexplosionhasbeenaproblemforsymbolicexecutionforalong time.thekeytoavoidpathexplosionistolimitthenumberofpaths generated within loops while maintaining high code coverage.
full symbolic execution creates paths for every possible execution path.
frequently paths within loops do not contribute to code coverage.
branches within loops may generate new states at every iteration.
the path explosion problem created by loops often stops symbolic execution to reach deeper parts of the code.
inthispaper weproposeanewpathexplorationmethodthat reduces the number of states needed to achieve high coverage.our algorithm limits the number of new states created by first prioritizingstates andthenpruningthestatesthatdonotcontribute to code coverage.
our algorithm does not require loop invariantinference loop summarization nor does it bound the number ofiterations of loop exploration.
the proposed algorithm can thushandle a broader set of loops than previous approaches.
in fact our algorithm is orthogonal to loop summarization techniques and search guide heuristics so it complements the current methods.
we have implemented our algorithm using klee and tested with student generated versions of a classroom assignment.
our results show that our algorithm helps to achieve the samecoverage with speedup of .
for out of the programs while adding max observed and average overhead over the of programs not benefiting from the technique.
the maximum speedup for a single program is .
.
ccs concepts software and its engineering software testing and debugging keywords symbolic execution loop analysis acm reference format jianxionggaoandstevens.lumetta.
.looppathreductionbystate pruning.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 6pages.
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
i j a b symbolic strings.
while i a .
s i z e j b.size if a b i j else i i j j a substring matching program if j i condition c do something b condition requires specific paths figure example program introduction symbolic execution has been proven to be practical at identifyingprogramdefects.insymbolicexecution asetofinputsisfirst marked as symbolic.
starting from an initial state an interpreter executes instructions symbolically.
the state is updated by the effect of each instruction.
when the execution reaches a branch instruction the conditions cand care evaluated by an smt solver.
whenbothconditionsaresatisfiable thecurrentstateforksinto twostates withcondition cand caddedtooneofthetwonew states as a constraint.
each execution state generated corresponds toadifferentexecutionpath andisexecutedindependently.the execution continues until all of the states execution paths have terminated or halts early due to either a time or a memory limit.
thoughpowerful thetimeandmemoryresourcesrequiredby symbolic execution are linear in the number of possible execution statesinthetestedprogram.unfortunately whenloopsarepresent thenumberofexecutionstatescanbeexponentialtothenumber of loop iterations executed.
the simple loop example shown in figure1a taken from illustrates this problem loop explosion.
to enhance symbolic execution we must find a way to reduce the time and memory cost of loop execution.
the motivation of our algorithm comes from our application of symbolicexecutiononstudent submittedprograms.weusesymbolic execution to determine the correctness of student submitted programs andtoprovidecounter exampleswhenpossible.students can submit theirprograms for testing at anytime and feedback is generated within minutes of submission.
weobservethatthesymbolicexecutiontimeneededtogenerate feedback depends heavily on the type of the assignment.
for assignments that require students to write loops we have to limit the size of the domain for symbolic variables in order to bound the loop exploration.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianxiong gao and steven s. lumetta s0 s0 s0 s0s01s00 s00s000s1 s1 s11s1s10 s10s101 normal state postponed state ghost state figure execution path tree the challenge is we need to symbolically explore the loops in programs to an extent such that most bugs are exposed while minimizing the time required to finish symbolic execution.
ouralgorithm only explore loops when necessary to improve code coverage.
by reducing the number of states explored wespeedup symbolic execution while maintaining the same code coverage and defect detection capabilities.
the key contribution of this paper is that even with loops that generate large numbers of possible paths which are difficult to summarize we can simply avoid execution of most paths and still achieve high code coverage.
we emphasize that executing all possiblepaths througha loopis notthe purposeof symbolicexecution.
rather thepurposeistoachievehighcodecoverageandtogenerate test cases that expose program defects.
we use figure 1to show that it is not necessary to cover all possible paths to achieve high coverage.
for the example in figure 1a weonlyneedtwoexecutionstates withoneofthestatesexecuting throughthe ifbranch andtheotherstateexecutingthroughthe elsebranch to cover the whole loop.
after both branches are explored in later iterations when the execution reaches the branch statement again we can continue theexecutionononeofthestates whilekeepingtheotherstates postponed.
we explore the postponed states only when necessary.
by stopping the exploration of the p ostponed states wecanspeed up the symbolic execution by orders of magnitude.
in the example execution of iterations shown in figure instead of exploring 8states weonlyneedtoanalyze2states.thestates s00 s01 s10ands11shown in figure 2are postponed states because the pathstheycoverhavealreadybeencoveredbystates s0ors1.from the example we can see that the number of postponed states islinear with the number of explored states.
herein only n postponed states are created but not explored .
weneedtoexplorethepostponedstatesonlywhenlaterparts of the program cannot be all covered by the explored states.
in figure1b thebranchcanonlybecoveredbyspecificvaluesofiand j which depend on the execution result of the loop for a specificstate.
with the two states explored initially in figure s0and s1 the code in figure 1bcannot be covered.
in other words the condition cin figure 1bcannot be satisfied given the explored states.ouralgorithmthenpicksonestatefromthepostponedstatesto explore.
we pick the state by first checking the constraints ofthe picked state csand the target condition c. a state is picked only when there exists a solution that satisfies both constraints cs andc.
the picked state is then changed from postponed to normal.
we iteratively repeat the process until the branch is either covered or proven uncoverable by exhaustively checking all the postponed states.
byusingpostponedstates wecanachievethesamecodecoveragewhileexploringmuchfewerstates.becausethepostponed states get explored only when needed their children states ghost states in figure may not get generated at all.
therestofthispaperisasfollows sectioniibrieflysummarizes currentloopanalysisalgorithms.sectioniiidescribesouralgorithm in detail.
section iv describes our experiments and analyzes the results.
we conclude in section v. background .
symbolic execution symbolicexecutionstartsexecutingatargetprogramfromaninitial executionstate.aninterpreterexecutesinstructionsbyupdating theexecution state.at branchinstructions theconditionsto both branches are evaluated by an smt solver.
when both condition constraints are satisfiable the execution state forks into two states withtheconstraintaddedtoeachstate.anexecutionstateterminates at any terminal instruction halt or abort for example.
all executionstatesareexecutedindependently.theprocedureends whenthereareno moreexecutionstatestoexecute.foreachexecutionstate asetofinputsthatsatisfiestheconstraintsofthestate is generated as a test case.
.
loop in this paper we define loop as a single strongly connected subgraphofaprogram scontrolflowgraph cfg suchthatthesubgraphhasasingleentrypointandcontainsnopropersubgraphs that are strongly connected but not loops.
with the assumption of thereisno otostatements wedefinecyclesasstrongly connected componentsinthecfg.aloopisaspecialkindofcyclethathas only one entry node.
the entry node of a loop is a node that dominatesallothernodesinsidetheloop.nodeadominatesnodebif and only if node a belongs to every execution path from the start node to node b. loopscanbenested inwhichcasewerefertotheinnerloopasa sub loop.
loops cannot contain cycles that are not loops.
non loop cycles are excluded because the numbers of paths generated by such cfg elements cannot be bounded.
fortunately few programs contain such elements.
we define the set of exit nodes of a loop l as cfg nodes outside of l that have at least one parent node within l. .
loop analysis there are three main types of techniques discussed in previous workaboutloopanalysis loopsummarization search guidingheuristics and loopunwinding .loopunwindingisthemostintuitivemethod in which each loop is unrolled for a bounded number of iterations.
loop unwinding ignores any program behavior that occurs only for iterations beyond the chosen unrolling bound.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
loop path reduction by state pruning ase september montpellier france 1map loop vector looppath lps genloopinfo lps 3statepruningsearcher searcher searcher statepruningsearcher initialstate 5while !searcher.done state searcher.pickstate 7executeinstruction state endfigure symbolic execution workflow genloopinfo map loop vector looppath lps 2foreach loop l in program p if l is not in lps 4genlooppaths l end 6end genlooppaths loop l 8foreach innerloop il in l genlooppaths il 10end vector basicblock exitnodes getexitnodes l 12lps .pushback getpath l exitnodes endfigure looppaths initialization .
.
loop summarization.
loop summarization uses a few states toeffectivelyrepresentafamilyofexecutionstates.eachexecution path through the loop is summarized as a set of equations.
the exit states of the loop are calculated with the set of equations the executionstateattheentranceoftheloop theexecutionorderof each path and the number of iterations to be executed.
to calculate the number of iterations to be executed a strong loop invariant is needed.
for the purpose of loop summarization a loopinvariantis strongenoughwhenthe numberofiterationsto beexecutedcanbeinferred orcalculatedinductivelygivenonly the symbolic execution state at the entrance of the loop.
tosummarizealoopwithasetofequations allpathsthrough the loop are first summarized.
if there is only a single path or periodically interleaved multi paths through the loop an exact equation is produced .
otherwise the equation is approximate.
howeverloopsummarizationcannotbeappliedgenerallytoall loops.theloopinvariantoffigure 1a forexample isquitedifficult or impossible to find because the result of the loop depends ontheorderofexecution whichinturndependsontheinputarray.
there is simply no pattern on how future execution state would be basedoncurrentexecutionstate.thusinordertocoverallpossible execution states new execution states still have to be generated and explored.
.
.
search guiding heuristics.
search guidingheuristicsareused to generate constraints that can cover specific chunks of code.
jan andtrt k computedanontrivialquantifier freenecessary condition on input values.
their technique is based on loop summariesofpathsthroughtheloop butaddressesonlysequentialandperiodicloops.xieetal.
developedatechniquethatusesa fitness function to measure how close a target node is to a current path.
ouralgorithmisorthogonaltosearch guidingheuristics.infact search guiding heuristics can be used to prune the states when possible.becausesearch guidingheuristicsarenotthefocusofthis paper we used only basic heuritstics for pruning.
with integration of more advanced search guiding heuristics the performance of our implementation can be further improved.1executeinstruction state instruction ins state.pc 3basicblock bb ins.parent if ins bb.head 5processbasicblock bb end 7updatestate ins state returnfigure execute instruction processbasicblock basicblock bb 2if unvisted bb markvisited bb 4end loop sl getcurrentloop state 6if sl vector ba sicblock exitnodes 8exitnodes getexitnodes sl if bb in exitnodes 10looppath lp state.sf.loop paths.top looppath.pushback bb 12if lps .find looppath lps .remove looppath 14end state.sf.looppaths.pop 16sl getcurrentloop state end 18if sl state.sf.looppaths.top.pushback bb 20end end 22if loopheadnode bb loop l get loop bb 24if l sl looppath lp state.sf.loop paths.top 26if lps .find looppath lps .remove looppath 28end lp.clear 30else looppath lp new looppath 32state.sf.looppaths.push lp end 34endfigure process basic block algorithm description to give an overview of our implementation our algorithm is different from the current symbolic execution designs in two aspects.
first we define two types of execution states normal states and postponedstates.normalstatesareexecutedaswithpriority while postponedstates are executedonly ifthey might enablecoverage ofcodethatisotherwiseuncoverable.westartbysettingtheinitial state as a normal state.
when new states are forked our algorithm determines what type of states the forked states are.
we explain the details on type of states in section .
.
.
the second difference is that we stop the symbolic execution process when two conditions are met all normal states have terminated and all coverable code has been covered.
a pieceof code is coverableiftheconstraintsofanypostponedstatescomplywith the constraints necessary to cover the code.
figure3shows the workflow of our algorithm.
we start by statically analyzing the program to gather information about loops and all possible paths through each loop.
the pseudo code for staticanalysis is shown in figure 4and explained in section .
.
.w e then initialize the stateprunin searcher with the initial state.
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianxiong gao and steven s. lumetta searcher determines when to finish execution by the donefunction.
when there is still code to be covered the searcher picks a state toexplorebythe pickstate function.whenexecutinganinstruction the node and loop path coverage information is updated if the instruction is the first instruction of its node.
the pseudo code for updating coverage information is shown in figure 5and6 and explained insection .
.
newstates are createdat branch instructionsandaddedtothesearcherbycallingthe addstate functionof the searcher.the pseudocode for the stateprunin searcher class is shown in figure 7and explained in section .
.
.
loop path beforewesymbolicallyexecuteaprogram weinitializetheloop coverageinformationbysettingallpathsthroughallloopsasunvisited.therearetwodifferentpathsinaloop headtohead h2h paths orheadtoexit h2e paths.allpathsstartfromtheentry node head.
anh2h pathis asimplecycle thatstarts andends at theentrynode witheachnodeanancestorofthenextnode.an h2e path starts at the entry node and ends at one of the exit nodes for the loop without passing through the entry node again.
.
data structures used to determine the type of a state and when to stop symbolic execution someadditionalinformationisstoredinexecutionstates.
.
.
list of loops loop paths.
beforesymbolicexecution we findallloopswithinaprogramthroughstaticanalysis figure .
we then identify all paths through each loop for a single iteration starting with innermost loops and working outward line of figure4 .thegetpathfunction line13 abstractsanyinnerloop as a switch instruction the exit nodes of the inner loop are the branches of the switch instruction.
the result is stored in a hash table with the loop as the key and all possible paths of the loop as value.
.
.
loop path vector stack.
thecurrentpathvectorstoresthe nodes executed from the entry node to the current execution state.
to support nested loops we use a stack the state .sf .looppaths variable in figure to contain information about the current path.
wheneveraloopisexecuted theinformationispushedontothe path vector stack figure 6line .
the loop info is popped off the stack when the current state exits a loop figure 6line .
to support function calls the path vector stack is placed on the stackframe state .sfvariable in figure for each state.
when functions are called a new stackframe with an empty loop info stack is created.
.
update coverage information when the first instruction of a node is symbolically executed lines 6offigure wecheckifweneedtoupdatethecoveragestatistics.
therearetwocoveragestatistics nodecoverageandpathcoverage.
ouralgorithmstopsexploringnewstateswhenallcoverablenodes andpathsarecovered.westartbycheckingifthenodehasbeen visitedbefore.ifnotyet wethenmarkitasbeenvisited line2 offigure .forexecutionofloops wecategorizethecurrentnode into three types entry node exit node or internal node.
although anexitnodeeofalooplisnotpartofl thelooppathcoverage statisticshavetobeupdatedwheneisreached.anodecanhave multipletypes.forexampleanentrynodeofainnerloopcanbeclass statepruningsearcher 2private vector state normalstates 4vector state postponedstates state candidatestate public 8statepruningsearcher state s normalstates.pushback s 10candidatestate null return bool done 14if normalstates.size candidatestate normalstates.
pick 16return true end 18candidatestate null foreach b asicblock bb in uncoveredfrontier 20constraint c getconstraint bb foreach state s in postponedstates 22constraint sc s.constraint if smtsolver.solve sc c 24candidatestate s postponedstates.remove s 26normalstates.pushback s return true 28end end 30setuncoverable bb end 32return false state pickstate 34return c andidatestate 36addstate state s loop sl getcurrentloop state if sl 40looppath currentlp state.sf.loop paths.top foreach lo oppath lp in lps 42if currentlp lp normalstates.pushback s 44return end 46end postponedstates.pushback s 48end normalstates.pushback s 50return figure statesearcher aninternalnodeoftheouterloop anexitnodeofinnerloopcan be either an internal node or the entry node of the outterloop.
.
.
entry node.
when we encounter an entry node there are two possibilities this is the first time we encounter the loop or wehaveexecutedah2hpaththroughtheloop.wedifferentiate the two by checking the top of the path vector stack.
if the path vector belongs to the loop of the entry node a h2h path has been executed.inthiscase wemarktheh2hpathascovered line26 of figure .
otherwise the execution has entered a new loop so we push an empty path vector on to the path vector stack.
.
.
exit node.
when an exit node is visited we need to check if thecurrenth2epathhas beenvisitedornot.ifnot theh2epath is marked as visited by removing it from lps and then popped off the path vector stack.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
loop path reduction by state pruning ase september montpellier france .
statepruningsearcher thestateprunin searcher decides when to stop symbolic execution and which state to explore.
the searcher determines if a node is coverable or not.
the symbolic execution stops when there is no more coverable loop path or node for the current states.
when the searcher decides a node might be covered by a state the state is explored further.
.
.
type of state.
at branch conditions if the constraints for both branches are satisfiable the current execution state continues executionononebranch andanewexecutionstateiscreatedto cover the other branch.
when an execution state forks into two statesinsidealoop thetypeofthenewstateisdeterminedusing loopcoverageinformation.thenewstateispostponedifthecurrent pathisnotaprefixofanyuncoveredpath line41 46offigure .a stateispostponedonlyatthetimeofcreation.normalstatesnever change into postponed states.
.
.
coverable node.
thedonefunctionofthestatepruningsearcher class determineswhen tostop symbolic execution.the donefunctionfirstchecksiftherearestillnormalstatesthathavenotfinished execution line of figure .
if so one of the normal states ispickedbyadefaultsearchalgorithm bfs dfs interleaveetc.
.
when there are no more normal states to explore the searcher checks for uncovered nodes.
insteadoflookingforastatethatcoverstheuncoverednode we eliminatethestatesthatarenotabletodoso.the uncoveredfrontier at line of figure 7represents uncovered nodes with one of its ancestors covered.
for each frontier node the constraints to cover the node is obtained and checked against every postponed state line of figure .
when the constraints to cover the frontier nodecontradictswithallthepostponedstates thenodeissetasuncoverable and removed from the uncoveredfrontier .
a postponed state is promoted to a normal state if its constraints do not contradict those of the frontier node lines of figure .
once a state is promoted back to normal state it is executed normally until the state halts.
by changing the type of state we reduce the number of times to check constraints with the smt solver.
.
discussion the goal of our algorithm is to minimize the execution time while maintaining the same code coverage.
the normal states are the states that are more likely to cover new nodes than the postponed states andthusaregivenpriorityinexecution.postponedstates arelesslikelytocontributetocodecoverage.thedecisionabout whether a state should be postponed is made at the time of state creation.
ouralgorithmisalsoorthogonaltocurrentsearch guidingheuristics techniques.
our implementation only checks if the constraints of the target node contradict with the constraints of the postponed state line of figure .
search guiding heuristics can be integrated here to help in picking the right postponed state.
experiments we implemented our design as a modification to klee version .
comparedwithunmodifiedkleeversion1.3on235programs.theprogramswerewrittenbystudentsinanintroductoryprogrammingclassasanassignment.theprogramtookagameboardasanarray of integers.
the assignment asked students to count the number of figure execution time statepruning vs klee times the number appeared in the neighboring cells with a given location on the game board.
we have removed duplicate programs andprogramsthatdonotcontainanyloop.theprogramsexamined contain different numbers of loops from to .
students were encouraged but not required to write nested loops.
thenormalexecutionuseddefaultkleesettings.thetimelimit was set to seconds for both configurations.
for each configuration wesymbolicallyexecutedthetargetprogramthreetimes.the data of the fastest execution was used.
.
experiment results .
.
validity.
the number of branches covered for all different configurationswasthesame.tovalidateourresult thetestcases generated were used to re execute the program.
for all different configurations the decision was the same either all tests passed or bugdetected.foralltheprogramswetested allbugsdiscovered were the same.
.
.
runtime statepruning vs klee.
wefirst comparetheexecutiontimeofourimplementation denotedstatepruning withthe unmodified klee denoted klee .
the result is shown in figure .
from the figure we can see that for a large cluster of programsnear the y axis statepruning finishes execution in less than 25seconds while klee takes from to seconds.
for a secondcluster of programs along the y xaxis statepruning does not improve performance.
a couple of points lay near the y border implied by the time limit not includingklee termination time .
for three such programs statepruning finishes within seconds while klee times out.
the cluster near the y axis contains different programs.
the maximumspeedupis52.
.kleerequiredatotalof8275.2seconds tofinishwhilestatepruningrequired699.8seconds speedingup total execution time for the batch by .
.
the execution time for all programs is .
seconds and .8secondswith statepruning.theminimumspeedup a slowdown for any program was .
.
.
.
number of states explored statepruning vs klee.
we also compared the number of states created by statepruning and klee.
theresultisshowninfigure .thesizeofthepointsrepresentsthe numberofprogramsatthepoint.from thefigurewecanseethat authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jianxiong gao and steven s. lumetta figure number of states explored statepruning vs klee table number of loops for programs with states in klee and fewer than statepruning states o fl oo p s of programs a number of klee executions saturate at and states.
the two programs to the right of the y xline at and both time out for both configurations.
there are programs with klee execution states and less than statepruningexecution states.
the number of loops contained in these programs is provided in table .
most programs havetwoloops withthecodestructuresimilartotheoneprovided in figure .
along the line y x there is a cluster of programs at the point .thedetaileddistributionofloopsislistedintable .the code structure is similar to the one provided in figure but with a difference in the ordering of conditions.
the result is that one of thepaththroughthe loopisuncoverable causingthestatepruning execution to exhaust every possible state ending up with the same number of states as the unmodified klee execution.
1foreach row around cell ifrow within bound 3foreach col around cell ifcol within bound 5ifnot self cell ifvalue count figure common structure1foreach row around cell foreach col around cell 3ifnot self cell ifrow within bound 5ifcol within bound ifvalue count figure alternative structure conclusion loop analysis for symbolic execution has been discussed in numer ouspapersinthecontextofloopsummarization.ourcontributionistotackletheproblemfromanotherangle.insteadoftryingtocover all the possible execution states we try to only cover states that contributetotheverificationoftheprogram.wehaveimplementedouralgorithmandtestedouralgorithmover235realprograms.our experiment shows that we can achieve .
speedup over half of the tested programs while maintaining max observed and table number of loops for programs with states in klee and statepruning states o fl oo p s of programs average overhead over the of programs not benefiting from the technique.
the reduced execution time helps us to verify more programs withinalimitedtime.hereatouruniversitywehaveasystemto check student submissions and provide feedback to them.
students can submit their programs any time and expect to get feedback within minutes.
many of the assignments use arrays as input data pictures maps game boards etc.
the reduction on loop execution time is vital for our system to better support the students.
wealsobelievethatourcurrentimplementationhasnotachieved thefullpotentialofstatepruning.thereareseveralfurtherpotential improvementsthatcanbedone.onedirectionforfutureworkis to extend our work on state pruning methods.
another important topicistodetectuncoverablepathsthroughloopmoreefficiently to provide support for a larger family of programs.