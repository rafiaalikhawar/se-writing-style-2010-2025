detecting event anomalies in event based systems gholamreza safi arman shahbazian william g.j.
halfond nenad medvidovic computer science department university of southern california los angeles ca usa gsafi armansha halfond neno usc.edu abstract event based interaction is an attractive paradigm because its use can lead to highly flexible and adaptable systems.
one problem in this paradigm is that events are sent received and processed nondeterministically due to the systems reliance on implicit invocation and implicit concurrency.
this nondeterminism can lead to event anomalies which occur when an event based system receives multiple events that lead to the write of a shared field or memory location.
event anomalies can lead to unreliable errorprone and hard to debug behavior in an event based system.
to detect these anomalies this paper presents a new static analysis technique deva for automatically detecting eventanomalies.
deva has been evaluated on a set of open source event based systems against a state of the art technique for detecting data races in multithreaded systems and a recent technique for solving a similar problem with event processing in android applications.
deva exhibited high precision with respect to manually constructed ground truths and was able to locate event anomalies that had not been detected by the existing solutions.
categories and subject descriptors d. .
distribution maintenance and enhancement d. .
diagnostics general terms design experimentation keywords event based system android application event anomaly race detection .
introduction the event based paradigm allows developers to design and build systems that are highly flexible and can be easily adapted .
these advantages have made event based systems ebss popular in a range of domains .
however the event based paradigm can also introduce complications due to the nature of the underlying event processing.
events can be delayed damaged orlost because of environment problems such as network errors or hardware deficiencies.
more generally events can be consumed nondeterministically independent of their order of occurrence .
while directly enabling ebs flexibility this nondeterminism can also lead to unpredictable system behavior.
in this paper we address one specific type of problem related to event handling event anomaly ea .
an ebs has an ea when the processing of two or more events results in accesses to the same memory location e.g.
a variable containing state or data and at least one of those is a write access.
the impact of an ea can vary based on the role the affected variable plays in the ebs but could include undesirable behaviors ranging from inconsistent state to data corruption.
detecting eas is hard for several reasons nondeterminism when a tester suspects that an ebs contains an ea nondeterminism can make it difficult to execute or reproduce the ea.
this reduces the efficiency and effectiveness of standard test based detection techniques and popular spectrumbased fault localization techniques.
implicit invocation ebss rely on callbacks which are methods registered with an event notification facility and called when the notifier receives an appropriate event.
the resulting implicit invocation makes it difficult to identify the control flow of the code when an event is received and processed.
ambiguous interfaces event callback methods often accept a generic event type.
they must examine the event s attributes to determine its actual type and to dispatch the event appropriately .
ambiguous interfaces make it difficult to determine the event type that is responsible for an ea.
implicit concurrency different types of received events may result in different method invocations in an ebs thereby introducing different execution paths.
each of these paths is independent of the others and may be executed in any order depending on when the events are consumed .
the resulting implicit concurrency makes it difficult to identify when a variable may be accessed by two different execution paths.
implicit invocation implicit concurrency and ambiguous interfaces are useful mechanisms for ebss.
together they allow ebss to be loosely coupled and to scale easily.
at the same time these very mechanisms make it harder to determine execution order and memory access patterns in an ebs whose interplay results in eas.
as a consequence it can be very challenging for developers to detect eas in ebss.
researchers have recognized the need for automatically discovering eas.
for instance cafa identifies use after free uf a common type of ea in android applications while w ebracer and e vent racer focus on detecting certain types of eas in client side web applications.
however these techniques are based on dynamic analysis therefore they offer no guarantees this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... 25of completeness and can only identify eas that have been exposed during an execution.
other approaches try to address the problem of eas by introducing new programming language constructs .
however these approaches are not applicable to existing systems that are written in general purpose languages such as java.
furthermore they tend to consider callback handlers with explicitly typed events as the potential source of anomalies when for many ebss the cause of eas is the processing of generically typed events inside the handlers followed by dispatching to different component methods.
to address these limitations of existing techniques we have developed a new static analysis technique that specifically targets ebss and can handle the semantics of implicit invocation ambiguous interfaces and implicit concurrency.
our approach called deva fordetecting eventanomalies builds on our recent work on static analysis to identify ambiguous interfaces in ebss and adds further analyses to identify variables that may be modified as a result of receiving an event a potential ea.
we evaluated deva on open source event based applications and libraries from different domains.
we compared deva s performance to two stateof the art techniques one targeting traditional data races in multithreaded systems and the other targeting ufanomalies in android.
our evaluation results show that deva has high precision and was able to find eas that the other techniques were unable to detect.
deva was also fast averaging one minute per application analysis which is significantly faster than the previously proposed techniques.
the remainder of the paper is organized as follows.
section discusses a motivating example.
section defines fundamental concepts underlying ebss and provides a formal definition of eas.
sections and detail deva and its evaluation.
section summarizes the related work.
section concludes the paper.
finally section includes information about deva s implementation and the replication package we have made available.
.
motiv ating example as a simple example consider mytracks an android application developed by google.
mytracks records the location path distance and elevation of a google maps user.
figure shows a portion of this application specifically the handlers for two events onlocationchangedasync line processes locationchangedasync events and ondestroy line processes destroy events.
destroy is a common event used for memory management that when it occurs frees the memory assigned to an activity or service of a given android application.
in the case of mytracks the ea occurs when both destroy and locationchangedasync events occur but destroy is processed first.
the ondestroy handler will free memory by setting the private class variable providerutils to null.
at some point shortly thereafter onlocationchangedasync will attempt to access providerutils thus generating a null pointer exception.
the cause of this exception is an ea since each of the two events results in an access to the same memory location and one of them is a write access.
the example in figure is an instance of an ea known as useafter free uf .
our approach deva was able to detect this ea but existing techniques such as cafa were unable to do so see section .
these types of eas also occur in other real world systems such as firefox for android .
1note that invoking ondestroy is not equivalent to performing garbage collection in android.
ondestroy only provides an opportunity to clean things up before an activity or service is destroyed it can change the memory locations referenced by the activity or service instance or free them by setting them to null but it does not release the instance.1public class trackrecordingservice extends service implements locationlistener ... private void onlocationchangedasync location location ... location lastrecordedlocation providerutils.getlastlocation ... public void ondestroy log.d tag trackrecordingservice.ondestroy ... providerutils null ... ... figure excerpt from the mytracks android application .
foundations in this section we define the underlying concepts and terminology that we will use to describe deva in section .
we describe how events are defined in an ebs and how we employ our recent static analysis technique to automatically identify different event types in systems with ambiguous interfaces.
finally we provide a formal definition of event based anomalies.
to illustrate our definitions we will use the implementation of a loadbalancer component shown in figure .
loadbalancer monitors the state of a server.
whenever the load on the server rises above a specified limit it will stop responding to new requests.
a new request comes to loadbalancer through a newrequest event.
at lines and of figure loadbalancer consumes this event and decides whether to process it on the server or send a notification event to inform other parts of the system that the server is overloaded.
the limit for the load on the server is set whenever loadbalancer receives a setlimit event.
at lines loadbalancer consumes this event sets the limit and checks if the new limit is less than the previous one.
if so it informs other parts of the system about the limit reduction.
.
terminology our approach relies on control flow information in the form of a control flow graph cfg .
a cfg is a directed graph in which each node represents a basic block of code and each edge represents the relationship between two blocks that at runtime may be executed after one another.
we also use the inter procedural control flow graph icfg which is a directed graph that contains the cfgs of a component s different methods.
if one method calls another then there is an edge in the icfg between the method invocation point and the entry node of the target method s cfg.
the icfg of loadbalancer is shown in figure .
the nodes in the icfg correspond to the statements in figure .
we use this graph to illustrate two more concepts.
first a cfg node xiscontrol dependent on node yif execution of ydetermines whether x will be executed.
consider the cfg of the handle method in the loadbalancer component which is shown in figure starting at node entry in the top middle of the graph.
nodes and are control dependent on being true but node is not since will execute for either condition of node .
second a node xisdata dependent on node yif there is a path in the cfg from ytox xuses the value of a variable that has been defined at y and no other node on that path redefines that variable .
in the loadbalancer ex261public class loadbalancer extends component long curload long lmt long prelmt public void handle event e if e.getname .equals newrequest managecurrentload e.getrequest if e.getname .equals setlimit prelmt lmt lmt long.parselong e.getattr limit if lmt prelmt send new event limitreduced public void managecurrentload request r if curload lmt curload curload start processing new request else send new event loadtoohigh figure event based load balancing component ample node is data dependent on node since at line in figure the ifstatement uses the lmtvariable and lmtis defined at node .
to show all control and data dependency relationships between different nodes of an icfg we can use the program dependence graph pdg .
in a pdg the nodes represent basic blocks in the program and edges represent control or data dependencies between the nodes.
figure shows the pdg for the example from figure .
.
consumed events event based systems ebss also referred to as message based systems are widely used in a range of application domains from user interface software to distributed systems.
in an ebs the process of a component receiving an event and accessing the information defined in the event s attributes is called event consumption .
at lines of figure the event setlimit is consumed since loadbalancer receives the event and processes the event s contents by checking its name and limit attributes.
an ebs component s entry point for event consumption is called a sink or alternatively an event handler .
in figure the handle method defined at line is a sink.
we say that loadbalancer has an ambiguous interface since it receives all events via the same sink.
identifying the types of events consumed by an ebs in the presence of ambiguous interfaces is challenging because all events handled by a system arrive as a single generic event type.
the actual type of each event is determined at runtime by checking the attributes contained within the event.
our recent work resulted in a static analysis technique called eos that analyzes the implementation of an ebs to infer the set of event types it can consume at runtime.
eos leverages consumed event revealing cer statements to infer information about the consumed event types cets of a component.
a cer statement is a method call that retrieves information stored in an event without modifying the event s attributes.
a cet is defined by a set of attributes and their values which can be inferred from cer statements.
methods called by a cer statement are of the following forms .getattr a represents methods retrieving the value of the attribute named aof an event.
as an example consider getattr in figure at line .
entry 8t 9f exitf10 12t thandle event e entry 22t f 1413fmanagecurrentload request r .
call .
call .
return .
return exitfigure icfg of loadbalancer .retrievespecificeventinfo represents methods whose names indicate the information the methods directly obtain about an event this is in contrast to getattr a which relies on parameterato specify the information of interest.
for example in figure at line e getname is used to retrieve the name parameter of event e while at line e getrequest is used to retrieve the request parameter contained in e. .hasattribute a represents methods that check whether an event has a specific attribute with the name a.
.m e indicates methods that accept an event eas an argument.
the explicitly declared type of the argument required by the programming language reveals information about the type of the event e which may have been cast elsewhere in the system before m was invoked.
eos identifies cer statements in a component and aggregates their information along the paths in the cfgs of the component s methods.
the type information revealed by the cer statements along each path is used to define a cet of the component.
we refer to the set of all event types that are consumed in a component as its cet set.
eos also returns all of the nodes in the icfg that contain a cer statement that contributed to the definition of each cet.
to illustrate consider the loadbalancer component from figure .
its cet set consists of two event types.
the first event type has two attributes one with the name name whose value is newrequest and one with the name request .
the second event type also has two attributes name with the value setlimit and limit .
.
definition of event anomalies an event consumption may cause an access to the state of a component which is represented by the component s fields as well as any shared non local variables.
for example in the loadbalancer component variables curload lmtandprelmt are its fields.
an access to a field is either a read i.e.
use or a write i.e.
definition .
when the consumption of two different cets causes accesses to the same field with at least one access being a write a problem 27entry t10 11t entry 22tthandle event e managecurrentload request r 20t f1314 t7.call .call .return .returntprelmt lmt exitexitfigure pdg of loadbalancer may occur the consumption order of the two events may be dependent on the system s environment and therefore the system s behavior may be nondeterministic.
we refer to this potential problem as an event anomaly ea .
the goal of our technique deva is to identify and report such anomalies to developers.
letcomponents be the set of all components in a system.
for a given c2components we define fcas the set of all of c s fields.
furthermore cerextract e is eos s function that extracts all cer statements for an event e. there exists an ea in component cover the field f2fcdue to event types e1 e22cet ciff the following conditions hold .e16 e2 .9fx1 xpg nodes icfg j1 i p xi 1is control or data dependent on x i x12cerextract e1 .9fy1 yqg nodes icfg j1 j q yj 1is control or data dependent on y j y12cerextract e2 .xpis a use or definition of f .yqis a definition of f the intuition behind this definition is that we can say an access to a field has been caused by an event consumption whenever the occurrence of consumption determines that the access must happen control dependency or the consumption affects the value that is stored in that field data dependency .
the above definition has three principal parts i the cet set of a component condition ii the control or data dependency paths from cets to fields that imply causality conditions and and iii determining those paths that access the same field with at least one write access conditions and .
these three elements form the foundation of our approach for extracting event anomalies described next.
.
approach the goal of deva is to identify eas in ebss.
to this end we have developed an automated static analysis technique that examines the implementation of a system and identifies points in the code where eas may occur.
our approach identifies all possible eas regardless of their impact on the ebs.
determining the impact of an ea is challenging in part because it can vary significantly.
for example prior work has found that some races are harmless and that removing them by introducing additional checksin the code can compromise the performance of the system .
on the other hand eas can lead to significant reliability problems and could impact system scalability .
the determination of the category into which an ea falls is generally a task for a system s engineers who must evaluate the ea s impact on the ebs s functional and non functional requirements.
the main inputs to our analysis are the implementation of an ebs and a description of the framework used for processing events in the system.
the description must specify the list of all methods used as event sinks in the case of an ebs with ambiguous interfaces or callback methods that serve as event sinks in the case of frameworks such as android that rely on explicit event interfaces the base class used to implement events in the system and the set of methods used as consumed event revealing cer statements.
all of the information in the description can be derived from the api specification of the underlying event based framework and only needs to be identified once per framework.
deva s analysis can be divided into three distinct phases.
in the first phase extraction the analysis identifies all of the consumed event types cets and fields accessed by each component of the system.
the second phase causation performs a path based analysis to determine if there is a connection between the cets and accessed fields.
finally the third phase joining identifies cets that will lead to an access of the same field that is a possible ea.
the cets and fields identified in the last phase are returned to the developer for more investigation.
in the remainder of this section we discuss each of the three phases in more detail.
.
extraction during this phase deva identifies two types of information about the ebs that will be used in the later phases to identify anomalies.
the first is the set of locations within each component where the component s fields are accessed either by a use or definition.
the second is the set of cets accessed by each of the components.
deva identifies a component s field accesses via a static intraprocedural analysis of the component s implementation.
formally we define a field access as a tuple hf niin which f2fcis a field of component c recall that fcis the set of all fields of component c andn2nmis a node in a method m s control flow graph nmrepresents the set of all nodes in method m s cfg that represents the location in the code where the field is used or defined.
deva generates two different sets fuse mthat contains field uses and fdefm that contains field definitions.
fdefm fhf nijf2fc n2nm ndefines fg fuse m fhf nijf2fc n2nm n uses fg to compute these sets deva first builds the cfg of each component method.
it then traverses the cfg and checks each node to determine if it accesses a field.
to analyze a field we performed alias analysis that first used class hierarchy analysis cha to identify potential targets of a field access and then used points to analysis based on spark to refine the results.
to illustrate this step consider the loadbalancer component shown in figure and its icfg shown in figure .
the fdef and fuse sets are shown in table .
in the handle method since there is a definition of field prelmt at node of the icfg corresponding to line in loadbalancer s implementation and a definition of field lmtat node tupleshprelmt 10iandhlmt 11iare added tofdefhandle .
also since there are two uses of field lmtat nodes and and a use of field prelmt at node tupleshprelmt 12i hlmt 10iandhlmt 12iare added to fuse handle .
our recently developed technique eos is able to identify cets in ebss that use ambiguous interfaces.
running eos on the 28table loadbalancer component information methods fdef fuse handlefhprelmt 10i hlmt 11igfhprelmt 12i hlmt 12i hlmt 10ig managecurrentload fhcurload 18igfhcurload 17i hcurload 18i hlmt 17ig loadbalancer component would identify the two event types discussed in section .
the first event with the attributes name and request that are accessed using cer statements at lines and of figure and the second event with the attributes name and limit that are retrieved using the cer statements at lines and .
in addition to the cet set we extended eos to also output the code locations at which different attributes of each cet are retrieved rather than just the name and value of each attribute.
we thus extract those locations and record them along with the name of corresponding event in the cet set.
therefore the cet set for loadbalancer will befh newrequest 7i h setlimit 11ig.
algorithm callback sink extraction input components interfaces cet ands sink setsfor each component output updated cet ands sink setsfor each component 1foreach i2interfaces do foreach c2components do ifc implements i then add c i to implementedinterf if9f2fcsuch that f and i have the same type t then add c t i to candidates 7foreach c i 2implementedinterf do if9f2fcof type t fand9 tf t i 2candidates then foreach m2methods ido add m name m entry node to cet c add m to s c if9n2methods c n is called by a thread defined inside m then add n name n entry node to cet c add n to s c eos targets ebss with ambiguous interfaces and is not able to identify callback methods which serve as sinks for explicitly typed events in frameworks such as android.
example callback sinks in android are onlocationchangedasync andondestroy from figure .
standard callbacks such as ondestroy can be easily identified in the code.
however custom application specific event sinks such as onlocationchangedasync must also be identified.
algorithm identifies two common patterns of custom event sinks and uses these to identify sinks and cets for android applications.
the first pattern comprises an interface i a component c1that implements interface i and a component c2that defines a field variable f1with the same type as interface i in turn c1should define a field variable f2with the same type as c2.
two components have the same type when they are either instances of the same class or one extends or implements the other.
in this situation whenever component c1is instantiated it will provide its this reference via f2 to component c2 and c2will save the reference in f1.
by this c2will be able to call methods that are declared in interface i on component c1.
the second pattern comprises a definition of a thread inside a callback method and a call to another method inside that thread to perform the required operation asynchronously.
algorithm finds the first pattern by first searching for all components cthat implement a given interface i lines and stores thehc iituples in the implementedinterf set.
after that algo rithm checks if a given component chas a field variable of the same type tas the interface i lines and stores the hc t iituple in the candidates set.
finally algorithm searches through implementedinterf to check for all components cthat implement an interface iand have a field variable of type tf such that tf s class in turn has a field variable of type i lines .
in other words algorithm checks for tuples of the form htf t iiin the candidates set.
if such a tuple is found then the methods in interface iwill be added to c s sinks and the cet set lines .
algorithm finds the second pattern by identifying methods called asynchronously inside a thread and adding them to the s i.e.
sink and cet sets of component c lines .
onlocationchangedasync from the mytracks application of figure is an example of an asynchronous callback in android.
algorithm over approximates callback sinks to detect all possible user defined callback methods and to avoid false negatives.
this over approximation may cause some false positives in the manner discussed in section .
.
.
causation the second phase of deva s analysis identifies whether field accesses are dependent on the consumption of specific event types.
to this end deva analyzes each field access location to determine if it is control or data dependent on cer statements that are used to define a cet.
the intuition is that if such dependencies exist then the field access occurs at least in part due to the consumption of an event type and may be part of an ea.
intuitively one can think of this phase as analyzing the program dependence graph pdg of a component.
for each field access deva performs a backwards traversal of the edges in the pdg.
if a cer statement is encountered during this traversal then deva identifies the corresponding cet and the originating field as being connected.
the phase outputs these connected cets and fields.
for larger systems generating and traversing a pdg is not scalable.
case in point to naively analyze the subject systems used in our evaluation see section it would be necessary to generate pdgs for over methods on average.
this could consume hours for a typical application.
to address this issue deva only generates pdgs for a component s sink methods and then uses the call graph cg of the system to identify methods that are reachable from each sink.
a field s definition or use in method mthat is reachable from sink smay be caused by an event s consumption if the invocation in sthat initiates the call to mis control or data dependent on that consumption.
we now detail the algorithms that implement this approach.
the algorithm for this phase is shown as algorithm .
the inputs to this algorithm are the component cto be analyzed the cets of the component cet c the call graph of the component cgc and the fuse andfdef sets for each method in c. note that cet c fuse and fdef are the outputs of the first phase discussed in section .
.
the outputs of the algorithm are two sets consumedtodef andconsumedtouse which contain tuples representing the fields and cets that are linked by a dependency relationship.
each tuple is of the formhf n eiwhere fis the field nis the location of the field s access in the code and eis the cet.
the set consumedtodef contains tuples where nrepresents a definition of f while in consumedtouse n represents a use of f. algorithm first accesses a set scthat contains all sink methods inc. this set is defined using method signatures for applications with ambiguous interfaces but is augmented with the results of algorithm for android applications.
then the algorithm iterates over each method minc lines .
if mis a sink or it can be reached from a sink in the call graph line then deva analyzes 29algorithm causation input c2components cg c cet c 8m2methods c fdefm fuse m output consumedtodefc consumedtouse c 1letsc set of all c s event sinks 2foreach m2methods cdo if m2sc or 9s2scso that m is reachable from s in cg c then consumedtodefc fieldaccessbacktoconsumption c m fdefm cet c consumedtouse c fieldaccessbacktoconsumption c m fuse m cet c algorithm fieldaccessbacktoconsumption input c2components m2methods c fieldaccesses cet c output consumedtoaccess c 1letnm set of all nodes in m s cfg 2letcernodes e m where e2cet candm2methods c fnjn2nm n2cerextract e g 3letsc set of all of c s event sinks 4letsm sc set of sinks that can reach mincg c 5letstom s m set of nodes in the cfg of s2scthat can reach m through direct or indirect calls 6foreach f n 2fieldaccesses do foreach e2cet cdo ifm2scthen if9l2cernodes e m such that n is directly or transitively control or data dependent on l then add f n e to consumedtoaccess c else foreach t2smdo foreach k2stom t m do if9l2cernodes e t so that k is directly or transitively control or data dependent on l then add f k e to consumedtoaccess c 16return consumedtoaccess c the field accesses in mby calling fieldaccessbacktoconsumption lines and .
the function fieldaccessbacktoconsumption is shown in algorithm .
at a high level fieldaccessbacktoconsumption iterates over each field access in m line and each event incet c line to determine if a dependency relationship exists between them.
within this iteration there are two cases to consider.
the first case at line is when mis a sink.
in this case deva simply checks the pdg of mto see if the field access is dependent on any cer node for the current cet line .
if so the tuple representing the field location and event type is added to the output set line .
the second case at line is for any non sink method.
deva begins by iterating over the set of all sink methods smthat can reach m line .
within each t2sm deva also iterates over each node kthat is in tand can reach m line .
we compute this reachability relationship by determining if kcan reach an invocation in t s cfg that in turn reaches mvia the call graph.
this relationship is encapsulated in the function stom line .
if kis dependent on a cer node then this relationship is added to the output set lines and .
the intuition here is that the field accesshf nican be reached via a statement kthat is itself dependent on a cer node.
let us now consider an example for each of the two cases.
to illustrate the first case consider the handle method of the loadbalancer component from figure .
since handle is a sink fieldaccessbacktoconsumption will use the pdg shown in figure to extract those members of fdefhandle listed in table that arecontrol or data dependent on a node that contains a cer statement.
considerhlmt 11iin the pdg .
node is connected to node which contains a node with a cer statement for the setlimit event sohlmt setlimit iwill be added to the return set.
next hprelmt 10iis also dependent on node so hprelmt setlimit iwill be added to the return set.
to illustrate the second case consider the method managecurrentload .
based on the icfg in figure only node in the sink handle can reach managecurrentload .stom handle managecurre ntload thus returns a singleton containing node .
based on the pdg ofhandle figure node is control dependent on node which contains a cer statement of the newrequest event.
therefore any definition or use inside the managecurrentload method is dependent on this event.
since fdefmanagecurrentload contains hcurload 18i our algorithm will add hcurload newrequest i to the return set for definition accesses of managecurrentload .
after algorithm completes its analysis of the loadbalancer component from figure its output would be consumedtodefloadbalancer f hlmt setlimit i hcurload newrequest i hprelmt setlimit ig consumedtouse loadbalancer f hcurload newrequest i hcurload newrequest i hlmt newrequest i hlmt setlimit i hlmt setlimit i hprelmt setlimit ig .
joining deva s third phase analyzes the dependencies between cets and fields to determine which ones may lead to an ea.
the intuition is that if one cet field dependency writes to a field and another one either writes to or reads from that field then this is an ea.
the algorithm for this phase is shown in algorithm .
the inputs to the algorithm are consumedtodefcandconsumedtouse c which were generated in the second phase and whose values for loadbalancer are shown at the end of section .
.
the goal of the first step lines of the algorithm is to remove uses that may result in false positives.
this step is analogous to identifying reaching definitions a definition of a given field freaches a node nin a cfg if there is a path in the cfg from the node at which fis defined to nwithout any other definition of fon that path.
if there is a definition of a field that dominates a use of the same field then that use cannot be involved in an ea condition with any other definition of the field.
domination occurs when all paths from the entry node of a cfg to the location of field f s use include the node that defines f. in that case f s use is removed from the consumedtouse set at line of algorithm .
to illustrate this first step consider the definition of lmtat line of figure .
this definition dominates the use of lmtat line .
therefore the use of lmtat line will be removed from consumedtouse loadbalancer after which we will have consumedtouse loadbalancer f hcurload newrequest i hcurload newrequest i hlmt newrequest i hlmt setlimit i hprelmt setlimit ig the second step of the algorithm lines iterates over each cet field dependency where the field access is a definition and checks whether there are any definitions or uses of the same field that can be triggered by the consumption of different cets.
essentially this performs a join over two inputs when the field in each tuple is the same.
if such cet field dependencies exist then an ea is detected and a tuple containing the affected field and the two 30algorithm joining input c2components consumedtodefc consumedtouse c icfg output eventanomalies c 1foreachhf n ei2consumedtodefcdo foreachhf2 n2 e2i2consumedtouse c f f2 e e2do iff s definition at node n kills all other definitions that reach node n 2then removehf2 n2 e2if rom consumedtouse c 5foreachhf n ei2consumedtodefcdo foreachhf3 n3 e3i2consumedtodefc f f3 e6 e3do addhf e e3ito eventanomalies c foreachhf4 n4 e4i2consumedtouse c f f4 e6 e4do addhf e e4ito eventanomalies c event types is added to the output set.
to illustrate the joining algorithm consider the consumedtode f loadbalancer set reported at the end of section .
and consumedtouse loadbalancer after line of algorithm reported earlier in this section.
there is one cet field dependency that defines lmt.
this definition happens at line and is caused by the setlimit event.
there is also one cet field dependency that uses lmt.
this use happens at line and is caused by the newrequest event.
these paths access the same field with one of them being a write access and are dependent on different event types introducing an ea.
the output of algorithm for loadbalancer is therefore fhlmt setlimit newrequest ig.
.
ev aluation we have empirically evaluated deva to measure its accuracy in extracting eas to compare it with a state of the art race detection technique for multi threaded systems to compare its performance with a recently published race detection technique for android applications and to examine its execution time.
.
subject systems and implementation table contains information about the subject systems we have used in our evaluation of them are applications and the remaining two are widely used android libraries e.g.
these libraries are used in several of the android applications from table .
all subjects are implemented in java but are from different application domains app type of different sizes sloc and use different underlying mechanisms for consuming events event mechanism .
in selecting these subjects we first located a corpus of suitable systems that make use of events in their implementations.
two phd students examined a number of open source applications and identified likely candidates by looking for possible instances of eas.
each system for which our preliminary examination indicated a potential presence of eas was then carefully analyzed by the two students with the help of the eclipse ide to obtain the ground truth.
the generation of the ground truths took slightly more than person hours per system on average.
as discussed in section even seemingly harmless races may actually harm a system in subtle ways hence our ground truths contained all possible races regardless of their impact on the ebss.
a notable outlier among our subject systems is project.net which is significantly larger than the other systems.
it partly uses eventbased interactions on its server side but mostly relies on web based interactions.
we only provided project.net s event based portion totaling around ksloc as an input to deva .
however to pinpoint this portion we had to analyze the entire system.
deva is implemented in java and scala and it uses the soot program analysis library to generate call graphs control flow graphs and program dependency graphs.
to analyze ebss that rely on am table systems used in the evaluation app name app type sloc event mechanism planner ai planner 6k c2.fw java events klax arcade game 5k c2.fw java events dradel software ide 11k c2.fw ers crisis response 7k prism mw troops simulator 9k c2.fw stoxx stock ticker 6k rebeca jmschat chat system 12k activemq java events project.net project mgmt 247k spring todowidget todo list recorder 2k android events fbreader book feed reader 34k android events mytracks location tracker 13k android events zxing barcode scanner 16k android events firefox browser app 58k android events connectbot shh client 23k android events vlc media player 101k android events browser android browser app 22k android events camera android camera app 13k android events music android audio player 8k android events android.support.v4 support library 7k android events android.support.v7 support library 11k android events biguous interfaces in our case this includes all non android applications from table we used an extension of eos for generating the required inputs for deva as described in section .
.
we ran deva on a quad core intel i7 .80ghz system with 8gbs of memory running windows professional.
.
accuracy of ea detection to assess deva s accuracy in detecting eas we applied it on the subject systems and compared its results to the ground truths.
if an anomaly reported by deva was not in the ground truth we counted it as a false positive conversely an anomaly in the ground truth that was not reported by deva was counted as a false negative.
our results are summarized in table .
for all but three of the systems deva was able to find each anomaly identified in the ground truth.
the three exceptions were klax for which deva yielded false negatives todowidget with false negatives and mytracks with false negative.
deva did not report any results that we had not found and confirmed as eas in our ground truths i.e.
it had no false positives.
table results of applying deva on the subject systems system anomalies time s planner klax dradel ers troops stoxx jmschat project.net todowidget fbreader mytracks zxing firefox connectbot vlc browser camera music android.support.v7 android.support.v4 in the cases of klax todowidget and mytracks the false negatives occurred because these systems rely on non standard mechanisms to access component state and communicate state changes.
for example mytracks dispatches an event by directly accessing the event s what attribute while klax passes the entire current state of the game from one component to another via a single event with a single very complex parameter.
deva could be relatively 31easily modified to cover each of these exceptional cases.
however we have chosen not to do so for our evaluation because it will always be possible to use other unforeseen non standard hacks when generating and processing events so that deva or a similar technique would not catch them without accounting for additional special cases.
deva relies on ebs engineers to exercise relatively minimal discipline when developing their systems.
deva reported several hundred eas across the subject systems.
as discussed above deva was able to identify a great majority of the anomalies present in our ground truths and it did not yield any false positives each reported anomaly did in fact reflect implicitly concurrent accesses to a component field with at least one access being a write.
an ea may have one of three possible outcomes .it is clearly a bug.
an example is the ufanomaly in the mytracks android application from figure .
.it is clearly an undesirable nondeterministic behavior.
an example involves the gameover event in klax which can be preempted by the gamepaused event resulting in an additional life for the player.
.it is potentially an undesirable nondeterministic behavior.
an example is a stoxx event that changes a threshold on a stock s price while another event requests a computation using the threshold and the stock s change history.
while not all of the eas reported by deva will have the same effect they all have the potential to cause undesired behavior in a system and should be carefully examined by the engineers .
.
comparison to multi threaded analysis in a multi threaded environment a data race occurs when two or more threads access the same memory location without proper synchronization.
because this is similar to our problem we investigated whether standard data race detection techniques could be applied to find eas.
to determine whether this is the case we studied the literature on race detection and selected chord as a state of the art static analysis technique to apply on our subject systems.
chord was chosen because it is the only technique of its kind that has a reliable actively maintained implementation.
the purpose of this study was to establish the extent of overlap between the outputs produced by chord anddeva .
the numbers of data races found by chord are shown in table .
since chord starts its analysis from a main method and project.net has no such method chord was unable to analyze project.net .
furthermore we were unable to apply chord on android applications because chord is not designed to consider the methods used in android as event entry points.
despite this the comparative analysis was revealing.
we found that the result sets produced by chord anddeva do not overlap none of the eas reported by deva were among the data races reported by chord or vice versa.
deva was unable to detect any of the data races in the subject systems for the simple reason that it does not target traditional data races.
similarly chord does not consider the conditions that result in eas.
this suggests that deva and a static race detection technique such as chord are complementary and can be used effectively alongside each other.
a deeper analysis sheds further light on why the two techniques yield such different results.
eas are caused by implicit concurrency.
they are independent of the number of threads in a system and may occur even in single threaded ebss.
on the other hand data races only happen in the presence of at least two threads.
eas detected by deva are potentially more dangerous in that it is harder to track accesses to shared data when those accesses are impactedtable results of applying chord on the subject systems system data races planner klax dradel ers troops stoxx jmschat by a number of factors and actors in a distributed system the local state of the component processing an event the network event routers and dispatchers and all the other distributed components in the ebs along with their respective states.
.
comparison to existing android analysis we also evaluated deva against cafa a recent dynamic analysis technique for detecting use after free uf eas in android applications.
in order to compare our approach with cafa we configured deva to report only ufanomalies among the eas it detects.
we then applied deva on the same versions of applications used in cafa s evaluation .
table shows the relevant results.
note that the cafa results did not include the two android support libraries shown in table so for this reason they are omitted from table .
table results of ufanalysis by cafa anddeva note that cafa is unable to identify the other eas shown in table cafa deva j cafa deva app name all all jharmful harmful todowidget j fbreader j mytracks j zxing j firefox j connectbot j vlc j browser j camera j music j thecafa all anddeva all columns include all ufanomalies reported by the two techniques.
as discussed by the authors of cafa certain ufanomalies will not actually result in null pointer exceptions because of checks placed in the code .
using the classification established for evaluating cafa the cafa harmful anddeva harmful columns in table show the respective numbers of discovered ufanomalies that result in actual runtime exceptions.
for all but two of the applications deva was able to identify more harmful ufanomalies than cafa .
for two of the ten applications camera andtodowidget cafa performed better.
in the case of camera cafa reported a single harmful ufanomaly that deva could not detect.
after inspecting the source code of this application we were not able to locate cafa s reported anomaly.
it is possible that the anomaly occurred because of problems in the libraries that camera uses as cafa did not analyze libraries separately from the application while deva did not analyze these particular libraries.
deva also had seven false negatives in the case of todowidget .
the reason was already discussed above todowidgetrelies on non standard mechanisms to access component state.
with regards to false positives the performance of deva was also stronger.
cafa reported non harmful ufeas in six out of ten android applications.
as discussed in these are false positives they are not actual eas.
as configured for this comparative evaluation deva reported non harmful uf anomalies in five of the ten applications.
however these false positives were actually 32eas just not ufanomalies while they will not produce runtime null pointer exceptions they do result in nondeterministic application behavior and it is therefore still important for the developers to be aware of them.
in summary out of the combined harmful uf anomalies that were discovered by cafa anddeva in the analyzed android applications cafa was able to discover while deva was able to discover .
in addition to the comparison study described above deva was able to uncover a number of eas in the two android libraries we analyzed recall table .
some of those were in fact harmful uf anomalies.
for example deva reported a harmful anomaly in the android.support.v4 library.
this is a known bug but to the best of our knowledge deva is the first to identify the bug s root cause.
this bug happens in the android.support.v4.app.dialogfragment class due to the interaction between events activitycreated processed by the method onactivitycreated and destroyview processed by ondestroyview over the field variable mdialog .
because the order of the two events is nondeterministic onactivitycreated is able to access mdialog after ondestroyview sets it to null.
overall the results of this study were very positive.
when we configured deva to identify only ufanomalies deva was able to uncover more such anomalies than a leading technique in eight of the ten applications.
the number of false positives yielded by deva was lower and while these were not necessarily ufanomalies they were actual eas.
finally deva was able to find the root cause of a previously unsolved bug in a widely used android library.
.
execution time given our objective of constructing an efficient technique we designed deva to generate and use only the subset of system information that is required for event anomaly analysis.
thus for example deva generates pdgs for component sink methods only and considers only those cets that are consumed at a given sink recall section .
table shows the execution time required by deva to analyze each subject system.
these measurements include the time used by soot to generate call graphs cfgs and pdgs the soot analysis averaged around sper system.
the analysis by deva ranged between sand s with an average of s. this execution time is reasonable especially when we take into account that analyzing each system manually took over hours.
as a further comparison cafa s execution time for the ten android applications shown in table varied between minutes and hours deva s maximum execution time for the same applications was seconds.
.
limitations and threats to validity we have identified three limitations in our evaluation.
the first limitation is the largely manual construction of the ground truth aided only by the code search and visualization features of eclipse.
human error in this process could affect the reported results.
we tried to mitigate this issue by carefully validating the ground truth through inspection as reflected in the very long time required to construct it.
this is further mitigated by the comparison to cafa which indicates that with the exception of the single application that relies on a non standard event processing mechanism deva did not miss any harmful ufeas.
the second limitation is that in analyzing ebss with ambiguous interfaces eos occasionally yields a small number of false positives in reporting event types .
in turn this may affect deva s results.
note that eos s inaccuracy did not have any impact on the android systems we analyzed since deva s algorithm rather than eos was used there.
the third limitation is that deva assumes that callback methods are definedin the source code of an android application to handle events that can occur nondeterministically.
if this is not the case deva will report false positives.
beyond the three limitations that are specific to deva there are at least two additional limitations that impact the accuracy of static analysis techniques in general aliasing and detecting feasible paths.
aliasing can take the form of data aliasing in the case of