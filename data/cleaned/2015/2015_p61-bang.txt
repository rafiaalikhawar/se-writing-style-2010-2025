automatically computing path complexity of programs lucas bang abdulbaki aydin and tevfik bultan department of computer science university of california santa barbara ca usa bang baki bultan cs.ucsb.edu abstract recent automated software testing techniques concentrate on achieving path coverage.
we present a complexity measure that provides an upper bound for the number of paths in a program and hence can be used for assessing the difculty of achieving path coverage for a given method.
we de ne the path complexity of a program as a function that takes a depth bound as input and returns the number of paths in the control ow graph that are within that bound.
we show how to automatically compute the path complexity function in closed form and the asymptotic path complexity which identi es the dominant term in the path complexity function.
our results demonstrate that path complexity can be computed e ciently and it is a better complexity measure for path coverage compared to cyclomatic complexity and npath complexity.
categories and subject descriptors d2.
complexity measures general terms algorithms measurement.
keywords path complexity path coverage automated testing.
this material is based on research sponsored by nsf under grant ccf and by darpa under agreement number fa8750 .
the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright notation thereon.
the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the o cial policies or endorsements either expressed or implied of darpa or the u.s. government.
part of this research was conducted while tev k bultan was visiting ko c university in istanbul turkey supported by a research fellowship from t ub itak under the b ideb program.
.
introduction automated testing i.e.
automated generation of test cases has become a very active area of research.
part of the surge in research activity in this area stems from the fact that in the last two decades automated veri cation research has mainly focused on bug nding techniques which resulted in merging of automated veri cation and automated testing research areas.
exhaustive exploration techniques such as model checking static analysis techniques such as extended static checking and symbolic reasoning techniques such as symbolic execution combined with advanced decision procedures have been e ectively adopted to automated testing .
this blurring of the lines between automated veri cation and testing resulted in new techniques that focus on path coverage rather than more traditional testing criteria such asstatement coverage branch coverage and mc dc coverage.
path coverage demands that all paths in the program are explored during testing.
this is not always possible since some program paths may not be feasible.
moreover in the presence of loops and unbounded recursion the number of program paths may not be bounded.
so rather than targeting full path coverage many modern automated software testing techniques try to cover paths up to a certain execution depth where the execution depth can be increased iteratively with iterative deepening .
in this paper we show how to compute the path complexity of a program which provides an upper bound for the number of execution paths in a program with respect to the execution depth.
as such path complexity can be used to assess the di culty of achieving path coverage with respect to increasing depth.
path complexity focuses only on the control ow structure and cannot determine the di culty of nding input values that can exercise a certain branch condition.
however due to this abstraction path complexity can be computed e ciently as we demonstrate in this paper.
path complexity of a program with an acyclic control ow graph i.e.
no loops or recursion is simply the number of paths in that control ow graph.
in the presence of cyclic control ow graphs path complexity of a program is a function that takes a single number nas input which corresponds to the execution depth and evaluation of the path complexity function gives the number of paths of the program within that depth.
in this paper we show how to compute the path complexity function using graph theoretic techniques.
note that path complexity function could be a complicated function with many terms and constants.
we also de ne and show how to compute the asymptotic path permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
61complexity which corresponds to the most signi cant term in the path complexity function.
using asymptotic path complexity we can classify programs as programs with constant polynomial or exponential path complexity and identify the degree of the polynomial for programs with polynomial path complexity and the base of the exponent for programs with exponential path complexity.
based on the techniques we present in this paper we implemented a tool for computing path complexity and asymptotic path complexity of java methods.
we rst extract the control ow graph of each method from the java bytecode and then compute the path complexity and the asymptotic path complexity on the control ow graph.
our current implementation is intra procedural where method calls are represented as single edges in the control ow graph and during path complexity analysis the execution paths in the callee method s body are not investigated.
our approach can be extended to inter procedural path complexity analysis by combining control ow graphs of individual methods with a procedure call graph.
however such an extension would generate an over approximation since it would also count spurious paths where call and return sites do not match.
a context sensitive extension to path complexity analysis that matches calls and returns would result in a more precise inter procedural analysis and would be a valuable extension to the techniques we present in this paper.
related work.
there have been earlier e orts in assessing the di culty of testing a program by analyzing the the control ow graph cfg of the program.
for example cyclomatic complexitydetermines the number of linearly independent paths in a given program by analyzing the cfg of the given program .
one testing strategy called basis point testing is to exercise all such paths during testing.
the upper bound for number of test cases required for basis point testing is given by the cyclomatic complexity.
moreover it can be shown that cyclomatic complexity also provides an upper bound for the minimum number of test cases required for branch coverage and statement coverage.
however cyclomatic complexity does not consider the paths that are subsumed by the other paths i.e.
if all the nodes in a path is subsumed by the other paths it is not considered .
another complexity metric called npath complexity determines the number of paths in a program which may be subsumed by each other by restricting each loop execution to one or zero executions .
npath complexity can increase exponentially with the length of the program and can result in very large numbers.
neither cyclomatic nor npath complexity are adequate measures for assessing difculty of path coverage of a program since cyclomatic complexity does not consider paths that are subsumed by other paths and the npath complexity does not consider multiple executions of loops.
in this paper we are focusing on use of complexity metrics for assessing the di culty of testing a program.
there has been research on use of complexity metrics for assessing other properties of programs such as maintenance costs and number of errors .
we have not investigated use of path complexity for such purposes but believe that these are interesting future research directions.
there has been recent work on automated worst case complexity analysis .
the main idea is to rstinstrument the loops in a program with auxiliary counters that keep track of how many times a loop is executed.
then using invariant generation techniques one infers invariants that relate the values of these counters to the inputs of the program.
in e ect these discovered invariants provide the complexity bound for the program since they demonstrate how many times loops of a program are executed for a given input value.
note that this is signi cantly di erent than the path complexity we investigate in this paper.
in worst case complexity analysis the goal is to discover a relationship between the input size and the length of execution paths whereas in path complexity analysis the goal is to discover a relationship between the execution depth and the number of execution paths.
moreover the path complexity analysis we present in this paper is a purely structural analysis which ignores branch conditions whereas the worst case complexity analysis discussed in requires sophisticated constraint analysis for invariant generation.
success of this approach depends on the quality of the invariant generation which is a di cult problem.
for example the abstract interpretation based approach described in is semi automated and requires user guidance during invariant discovery process.
in contrast the path complexity analysis we present in this paper is fully automated and it is scalable.
the techniques we present in this paper for computing path complexity of a program are based on algebraic graph theory and analytic combinatorics techniques for counting the number of paths in graphs .
in particular we use the transfer matrix method based on generating functions .
recently generating functions have also been used in model counting constraint solvers for determining the number of solutions to a given string constraint .
there has been some earlier work on path complexity of programs .
however the path complexity concept discussed in this earlier work de nes the path complexity as a relation between the input size and the number of execution paths rather than a relation between the execution depth and the number of execution paths as we de ne in this paper.
furthermore this earlier work does not present an automated way of computing the path complexity.
the remainder of the paper is organized as follows.
in section we brie y discuss and contrast cyclomatic npath path and asymptotic path complexity.
in section we present the techniques for automatically computing path complexity.
in section we compare cyclomatic npath and asymptotic path complexity on several cfg patterns.
we discuss our implementation and experiments in section and provide our conclusions in section .
.
overview in this section we use three example methods shown in figure from java sdk to explain the following concepts and their di erences cyclomatic complexity introduced in npath complexity introduced in and the path complexity and asymptotic path complexity introduced in this paper.
in order to present all these concepts in a uniform manner we use the control ow graph cfg representation i.e.
given a program we rst extract a cfg from the program and then we compute these complexity measures on the cfg.
a cfg consists of a set of nodes that correspond to basic blocks of the program.
nodes of 62private static void rangecheck int length int fromindex int toindex if fromindex toindex throw new illegalargumentexception fromindex fromindex toindex toindex if fromindex throw new arrayindexoutofboundsexception fromindex if toindex length throw new arrayindexoutofboundsexception toindex a java.util.arrays.rangecheck public matcher reset first last oldlast for int i i groups.length i groups for int i i locals.length i locals lastappendposition from to gettextlength return this b java.util.regex.matcher.reset private static int binarysearch0 long a int fromindex int toindex long key int low fromindex int high toindex while low high int mid low high long midval a if midval key low mid else if midval key high mid else return mid key found return low key not found.
c java.util.arrays.binarysearch0 figure three example methods from java sdk.
the cfg are connected with edges that correspond to control ow of the program i.e.
if there is an edge from node to node then in some program execution basic block that corresponds to node can be executed immediately after the basic block that corresponds to node .
we assume that each cfg has a unique entry node denoting the program point where the execution starts and a single exit node denoting the program point where the execution terminates it is easy to convert cfgs that have multiple termination points to this form by adding an extra node .
figures a b and c show the cfgs for the methods shown in figures a b and c respectively.
cyclomatic complexity.
given a cfg cyclomatic complexity computes the maximum number of linearly independent paths in the cfg from the entry node to the exit node .
a set of paths through a program are linearly independent if and only if each path in the set contains at least one edge that is not included in any other path in the set.for example the method shown in figure a with the cfg shown in figure a has at most linearly independent paths hs ti hs ti hs ti hs tiwhere we identify each path by the sequence of nodes visited during the execution of the path and we use sto denote the entry point where the execution starts and tto denote the exit point where the execution terminates.
since the maximum number of linearly independent paths for the method shown in figure a is the cyclomatic complexity of this method is .
on the other hand the method shown in figure b with the cfg shown in figure b has at most linearly independent paths hs ti hs ti hs ti hence its cyclomatic complexity is .
note that we can replace the last path in the set above with the pathhs tiand the resulting set of three paths will still be linearly independent.
however we cannot have both hs tiand hs tiin the set of linearly independent paths since these two paths are not linearly independent.
finally the method shown in figure c with cfg shown in figure c has at most linearly independent paths hs ti hs ti hs ti and hs ti.
we can nd other sets of linearly independent paths for this method but the cardinality of the set of linearly independent paths can never be more than .
for this cfg after linearly independent paths any other path we add will not include any new nodes and therefore will not be linearly independent.
cyclomatic complexity can be computed easily from a cfg by rst counting the number of edges e the number of nodes n and the number of connected components p in the cfg.
then the cyclomatic complexity is given by the expression e n 2p.
for example for the cfg shown in figure a we have e n p and the cyclomatic complexity is .
on the other hand for the cfg shown in figure b we have e n p and the cyclomatic complexity is and for the cfg shown in figure c we have e n p and the cyclomatic complexity is .
cyclomatic complexity can be used for estimating the cost of testing since it provides an upper bound for the minimum number of test cases required for branch coverage.
hence as the cyclomatic complexity of a program increases the cost of achieving branch coverage for that program is likely to increase.
however cyclomatic complexity is not very useful for assessing di culty of achieving path coverage.
for example the methods shown in figure b and c contain loops hence achieving path coverage during testing for these methods will be di cult.
however cyclomatic complexity of the method shown in figure b is lower than the cyclomatic complexity of the method shown in figure a and the cyclomatic complexity of the method shown in figure a is same as the cyclomatic complexity of the method shown in figure b .
hence if we are targeting path coverage cyclomatic complexity is not a useful measure.
even without a coverage criteria in mind if we accept the fact that testing programs with loops is harder than testing programs without loops cyclomatic complexity is not a useful metric for determining di culty of testing since it does not distinguish between the back and forward edges in cfgs 63start exit2 a cfg for java.util.arrays.rangecheck start exit2 b cfg for java.util.regex.matcher.reset start exit2 c cfg for java.util.arrays.binarysearch0 figure control flow graphs cfgs for the the three methods in figure .
and therefore it is ambivalent to existence of loops in the cfg.
another reason for the inadequacy of cyclomatic complexity as a metric for di culty of achieving path coverage is the fact that cyclomatic complexity grows at most linearly with the number of edges in the cfg.
however the number of paths in a cfg can grow exponentially even without loops.
for example consider the cfg of a program that consists ofkif then else statements executed back to back.
the cyclomatic complexity of such a cfg structure would grow linearly with respect to k whereas the number of paths in the cfg would grow exponentially i.e.
would be proportional to 2k.
npath complexity.
npath complexity overcomes this short coming of cyclomatic complexity by counting all acyclic paths in the cfg without requiring them to be linearly independent .
for example the npath complexity of the method shown in figure a with the cfg shown in figure a is which simply is the number of paths in the cfg.
since npath complexity focuses on counting the number of paths in the cfg it is more suitable for assessing the di culty of achieving path coverage than cyclomatic complexity.
however for cfgs with loops npath complexity also makes a simplifying assumption which makes it unsuitable for assessing the di culty of achieving path coverage.
in the presence of loops npath complexity only counts the paths that execute the loop body once or zero times.
for example there are two loops in the method shown in figure b with the cfg shown in figure b .
npath complexity counts the path that executes each loop zero times hs ti it counts the two paths that execute one loop one times and the other loop zero times hs ti hs ti and itcounts the path that executes each loop one time hs ti resulting in paths.
so the npath complexity of the method shown in figure c is .
the method shown in figure c with the cfg shown in figure c has a single loop that contains conditional statements in the loop body unlike the loops in the cfg shown in figure b which do not contain conditional statements in the loop body .
for the cfg shown in figure c the npath complexity takes into account the path that executes the loop body zero times hs ti the path that executes the loop body once and takes the rst thenbranch hs ti the loop that executes the loop body once and takes the rst else branch and the second then branch hs ti and the loop that executes the loop body once and takes the both elsebranches hs ti .
so the npath complexity of the method shown in figure c is also .
npath complexity was originally de ned through operations that are applied directly to structured programming code .
however we observe that npath complexity can be restated in terms of the cfg in the following way npath is the number of paths in the cfg that use any edge at most once.
thus for any node u the number of paths fromuto the exit node is given by the recursive de nition npath u g x euv2gnpath v g euv whereeuvis an edge from utovandg euvis the graph obtained by deleting euvfromg.
thus we can compute npath start g using dynamic programming techniques and applying the initial condition npath exit .
since npath complexity only considers execution of each loop body once or zero times it is not able to distinguish 64table results of di erent complexity measures.
methodcyclomatic complexitynpath complexitypath complexityasymptotic complexity java.util.arrays.rangecheck figure a java.util.regex.matcher.reset figure b n2 n n2 java.util.arrays.binarysearch0 figure c 17n 1n 84n 17n between loops that create a large number of paths from the loops that do not create a large number of paths.
moreover since npath complexity produces a single constant number it is not possible the distinguish cfgs that have a constant number of paths from the ones that have an unbounded number of paths i.e.
the ones with loops .
for example the npath complexities of the methods in figure a b and c are all the same although two of them contain loops and one of them does not contain a loop.
path complexity.
path complexity is equal to the npath complexity for the programs that do not contain loops or recursion i.e.
for the programs with a constant number of paths path complexity just returns the number of paths.
however for the programs with loops or recursion path complexity is not a constant number but a symbolic expression on a single variablenwhich denotes the execution depth.
the expression computed by the path complexity is an upper bound for the number of paths in the program up to the depth n. i.e.
substituting a constant value for nin the function returned by the path complexity and then evaluating the function results in a constant number that corresponds to an upper bound for the number of paths in the program within that execution depth.
for example for the method shown in figure a the path complexity is .
since this method does not contain any loops its path complexity is equal to its npath complexity.
however for the method shown in figure b the path complexity is n2 n .
here we observe that the number of paths in this method increases polynomially with respect to the depth of execution.
on the other hand for the method shown in figure c the path complexity is 17n 1n 84n .
i.e.
for this method the number of paths increases exponentially with respect to the depth of execution.
asymptotic path complexity.
the path complexity expressions could easily get extremely complicated.
in order to produce a more readable and understandable complexity measure we also de ne the asymptotic path complexity which simply extracts the dominant term from the path complexity expression.
so the asymptotic path complexity of the method shown in figure a is denoting that its number of paths are constant the asymptotic path complexity of the method shown in figure b is n2 denoting a quadratic growth in the number of paths with increasing execution depth and the asymptotic path complexity of the method shown in figure c is 17n denoting an exponential growth in the number of paths with increasing execution depth.
the summary of di erent complexity measures for themethods shown in figure is shown in table .
we claim that path complexity and asymptotic path complexity reect the cost of achieving path coverage in testing better than cyclomatic complexity and npath complexity.
.
computing path complexity in order to compute the path complexity of a method within a program we rst extract its control ow graph cfg .
a cfg gis a tuplehn e s tiwherenis the set of nodes denoting basic blocks of the program e n nis the set of edges denoting the control ow among basic blocks s2nis a unique node denoting the basic block where the execution starts and t2nis a unique node denoting the basic block where the execution terminates programs with multiple termination points can be represented with cfgs in this format by creating an extra termination node .
below we assume that sis always the node labeled with the smallest number i.e.
and tis always the node labeled with the highest number.
once we have determined the control ow graph we make use of techniques from algebraic graph theory and analytic combinatorics to count the number of execution paths .
given a cfg g using standard graph theory notation a path is a sequence of edges in g e1 e2 e n and the length of a path l is the number of edges in the path.
given a bound n on the execution depth we produce a closed form solution function path n that computes the number of paths withl n. frompath n the asymptotic behavior can be determined and used to categorize the path complexity of the method from which the cfg was derived.
in order to aid the reader we demonstrate the technique on a small example.
consider the cfg shown in figure .
de necount n to be the number of paths of exactly length nandpath n to be the number of paths with length less than or equal to n. that is path n pn i 1count i .
for our small example graph one can verify that count n is if n 3k for some non negative integer kand otherwise there is one path of length one path of length and so on.
the values of count n andpath n are listed in the table shown in figure for values of nup to .
we de ne the path count sequence of a graph g to be an in nite sequence a0 a1 a i where each ai path i .
in our running example the path count sequence is f0 g. further investigation would indicate that path n bn 3cwherebxcis the integer oor function.
asymptotically speaking we can see that the number of paths grows linearly approximately asn with the depth boundn.
we will demonstrate how such asymptotic analysis can be automated using the theory of integer sequence generating functions.
start exit 4ncount n path n ......... figure an example cfg and corresponding path counts.
generating function for an integer sequence for an integer sequencefaigthat represents the bounded path counts of a cfg we can encode values of path i as the coe cients of a polynomial an ordinary generating function gf .
the ordinary generating function of the sequence a0 a1 ai is the in nite polynomial g z x i 0aizi althoughg z is an in nite polynomial it can be interpreted as the taylor series of a nite rational expression .
i.e.
we can also write g z p z q z wherep z andq z are nite degree polynomials.
if g z is given as such a nite rational expression each aican be computed from the taylor series expansion of g z ai g i i!
whereg i z is theithderivative of g z .
we write g z for theithtaylor series coe cient of g z .
this is what makes a generating function useful it is a compact nite representation of an in nite series.
returning to our running example we can write the generating function for path n both as a rational function and as an in nite taylor series polynomial.
the reader can verify the following equivalence by computing the coe cients via equation g z z2 z z3 z4 z2 z3 z4 2z5 2z6 2z7 3z8 given the generating function for our cfg written as a nite rational expression we can take the nthtaylor series coe cient to determine the number of paths with length bounded by n. for example to compute the number of paths with a length bound of we can compute path g z .
in fact we can use the generating function to derive a closed form function of nthat computes the desired coe cient.
in the following describe how to determine the generating function as a nite rational expression for a cfg extract a closed form function for counting paths and howto perform asymptotic analysis of that function.
generating function for a cfg given a cgf gand length n we can compute the generating function g z such that thenthtaylor series coe cient of g z is equal to path n .
from a cfg g we construct the adjacency matrix also called the transfer matrix t wheretijis if there is an edge from vitovjand otherwise.
in addition tjnj jnj wherejnjis the number of nodes in g. then the generating function for path n is g z jnj 1det i zt jnj det i zt where m i j denotes the matrix obtained by removing theithrow andjthcolumn from m iis the identity matrix and det m is the matrix determinant.
the transition matrix t and the terms i zt and i zt n for our running example are t i zt z0 z0 z z z0 z3 i zt z0 z0 z z0 z0 and applying equation by taking the appropriate determinants results in the generating function g z z2 z z3 z4 this is precisely the same gf that counts paths in our example cfg given in equation .
a closed form solution from a rational generating function g z p z q z we can derive a closed form function for path n that is a sum of products of simple polynomial and exponential terms.
given a generating function the form ofpath n is determined by the roots of the denominator q z .
supposeq z is a polynomial of degree d. by the fundamental theorem of algebra q z has exactly droots over the complex numbers accounting for multiplicity.
ignoring multiplicity suppose there are ddistinct roots.
let ribe theithdistinct root of q z andmibe the multiplicity ofri.
thenpath n is given by path n dx i 1mi 1x j 0ci jnj ri n whereciare coe cients that are determined by the rst d terms of the taylor series expansion of g z .
sincepath n g z for alln we can de ne a system of dequations and dunknowns.
this system can be solved for the coe cients ci jvia elementary linear algebra.
in our example q z z z3 z4and has four roots.
the root is repeated and so there are three distinct roots r1 r2 with multiplicity m1 m2 r3 ip 2with multiplicity m3 andr4 ip 2with multiplicity m4 .
in this particular case it turns out that1 r3 r3and1 r4 r4 whereris the complex conjugate ofr.
so our desired function becomes path n c1 c1 1n c2 ip n c3 ip n the rst four terms of the taylor series expansion of g z area0 a1 anda2 a3 .
by evaluating path n at n we can solve for the coe cients ci jto nd that c1 c1 c2 ip c3 ip .
thus we have path n 3n ip ip n ip ip n while it appears that this function may take on fractional and complex values for every value of n any imaginary terms conveniently cancel out and fractions combine to result in integers.
in fact one may verify that the resulting functionpath n is equivalent to bn 3c.
furthermore althoughpath n has a seemingly complicated form it can be derived automatically from the transfer matrix method and the resulting generating function.
upper bounds in order to perform asymptotic analysis of path n we rst bound the complex terms.
because the complex roots of q z always appear in conjugate pairs we can bound and combine them in pairs.
for any complex numberw wn wnis a real number.
furthermore 2jwjn wn wn 2jwjn wherejwjdenotes the complex norm of w. thus we can replace each exponentiated complex root in path n with its norm in order to get a sound upper bound.
we denote the upper bound on path n byupper n .
in our example jr3j jr4j .
performing the substitution and simplifying we get path n 3n ip ip n upper n notice that this is the same result given in our initial informal analysis of the example cfg without the oor function.
we plot the exact solution given in equation and the upper bound given in equation together in figure .
asymptotic analysis we extract the asymptotic complexity from the upper bound on path n using standard asymptotic analysis where f n g n if and only if lim n!1f n g n .
the asymptotic path complexity of our running example can be described by upper n n .
execution path length bound npath complexity exact bound figure comparison of exact solution and upper bound.
we have been able to determine that the path complexity of our example cfg grows linearly with the execution depth.
this same method outlined here works on more complex cfgs as well allowing one to determine if the path complexity of a program is asymptotic to a constant n n2 n3 and so on or bnfor some exponential base b. numeric approximation in some instances it is necessary to perform numeric approximation for the roots of q z .
this is due to the fact that there is no explicit formula for solving polynomials with degree larger than .
by the abel ru ni theorem a general solution does not exist for exactly expressing roots in terms of the elementary algebraic operations of addition subtraction multiplication division exponentiation taking roots and so on.
note that this does not mean that all polynomials of degree or larger cannot be solved exactly but that there is no all purpose method for producing exact solutions.
on the other hand the roots of any polynomial can be approximated to within any desired nite precision using standard numeric root nding techniques .
thus when the degree of q z is greater than we numerically approximate each root riby ri .
in our experiments is such that we maintain at least digits of precision.
algorithm overview now that we have described the mathematical theory behind path complexity we give a high level description of the path complexity analysis in algorithm .
algorithm computing path complexity of cfg g determine adjacency matrix tof the cfg g. compute generating function via eq.
as follows g z p z q z n 1det i zt n det i zt compute roots of q z to determine path n via eq.
.
solve for each ci jinpath n using the rstjnjtaylor series coe cients of g z via eq.
which gives path n .
determine upper bound on path n by replacing each complex root wwithjwjand simplifying.
determine asymptotic behavior of upper bound on path n .
67table complexity measure comparison.
pattern control flow graphcyclomatic complexitynpath complexityasymptotic path complexity kif else in sequence k k k 2k2k kif else nested 1k k k k k k kloop in sequence k k k 2k nk kloop nested k k k k bn .
comparison with other complexity measures in table we give the cyclomatic npath and asymptotic path complexity expressions for four common programming patterns.
given an integer constant k we examine the following a sequence of kconditional statements fully nested conditional statements to a depth of k a sequence ofkloops and fully nested loops to a depth of k. for these four patterns cyclomatic complexity gives identical results and it simply grows linearly with the number of conditional or loop structures.
consequently cyclomatic complexity alone cannot distinguish the di erences in these four patterns and is not a good measure of assessing the difculty of achieving path coverage in testing these programs.
npath complexity does a slightly better job but still only reports a constant number that depends directly on the size of the graph not on the execution depth bound.
npath complexity cannot distinguish between kconditional statements in sequence and klooping statements in sequence both of which yield a constant value of 2kfor a givenk.
likewise npath cannot distinguish between k nested conditional statements and knested looping statements both of which yield a constant value of k for a givenk.
because npath complexity counts paths in which edges cannot be crossed more than once it does not account for all possible combinations of loop repetitions and therefore is also not a good measure of assessing di culty of achieving path coverage.
among the three metrics asymptotic path complexity is the most useful in distinguishing between the complexity of the four programming patterns.
it produces four di erent types of results.
for kconditional statements executed in sequence it tells us that there are a constant number of possible executions and that the constant number is exponential in the number of conditions.
for nested conditions it tells us that the number of paths is constant and that the number of paths is linear in the number of conditions.
for kloops in sequence asymptotic path complexity tells us that as the execution depth bound nincreases the number of paths grows polynomially as nk .
finally for knested loop structures we nd that as the depth bound nincreases the number of possible executions grows exponentially as bn wherebis a constant number that depends on k. .
implementation experiments in order to evaluate the path complexity algorithm we performed an experimental comparison with the two complexity measurement method described in section cyclomatic complexity and npath complexity.
we implemented algorithm in a tool called path complexity analyzer pac .pac automatically computes the path complexity and asymptotic path complexity of java methods.
pac accepts a java class le or a jar of class les as input and reports path complexity and asymptotic path complexity for all methods of input java class es .
pac has two main steps controlow graph cfg extraction path complexity calculation.
pac is available for download see the appendix for details.
we used the asm1java bytecode manipulation library to generate cfgs using an intra procedural analysis for each method.
pac rst computes the basic blocks of a method.
a basic block is a sequence of code statements where there is only one entry point and one exit point.
in other words none of the instructions are the target of a jump instruction except for the rst and none of the instructions are a jump halt instruction except for the last.
pac constructs cfgs using basic blocks which results in compact cfgs.
we implemented algorithm based on the techniques described in section using mathematica2.
implementing the algorithm in the mathematica language allowed us to leverage the built in routines for symbolic manipulation of matrices polynomials and complex expressions as well as numeric root nding methods.
we also implemented the computation of cyclomatic complexity and a version of npath complexity based on the cfg as described in section .
to do a comparative evaluation we experimented with the java sdk java benchmark and the apache commons3libraries apache benchmark .
we extracted cfgs from the java benchmark and cfgs from the apache benchmark.
we ran all the experiments on an intel i5 machine with .5ghz x processors and gb of memory running ubuntu .
.
68table comparison of asymptotic complexity classi cation with cyclomatic and npath complexity values.
path comp.
classi cationsasym.
comp.
methodscyclomatic complexity methodsnpath complexity methods c .
.
.
.
.
.
.
.
n .
.
.
.
.
.
.
.
n2 .
.
.
.
.
.
.
.
n3 .
.
.
.
.
.
.
.
ne e .
.
.
.
.
.
.
.
bn b .
.
.
.
.
.
.
.
bn b .
.
.
.
.
.
.
.
bn b .
.
.
.
.
.
.
.
bn b .
.
.
.
.
.
.
.
experimental results.
we ran pac for the java sdk and the apache commons libraries.
the total execution time for the java benchmark is hours minutes seconds with an average of .
seconds per class le.
the total execution time for the apache benchmark is minutes and seconds with an average of .
seconds per class le.
we compared pac s asymptotic path complexity with cyclomatic complexity and npath complexity.
we de ned four complexity classes constant with value c constant with a value that is greater than c polynomial nk withk and exponential bn with n .
figure shows the percentage of number of methods for each complexity class based on the pac analysis results.
the java and apache benchmarks have similar distributions.
more than half of the methods have only execution path for both benchmarks.
i.e.
there are no jump instructions in those methods except for the method exit.
for the java benchmark of the methods have a constant complexity value greater than one and of them have polynomial or exponential complexity.
similarly of the apache benchmark methods have constant complexity greater than one and of them have polynomial or exponential complexity.
we will omit the discussion of the methods that have a single execution path as all complexity measurements report the constant value .
for the rest of the discussion we further de ne ne grained complexity classes based on the degrees of the polynomials and bases of the exponentials rst column in table and give the number of methods at each ne grained class that are classi ed by pac second column .
java sdk c c 1nkbn60.
.
.
.
apache c c 1nkbn60.
.
.
.
figure distribution of the methods to four asymptotic complexity classes single path c constant number of paths greater than one c polynomial nk k and exponential bn n .table shows the distributions of the cyclomatic and npath complexity results over the ne grained complexity classes.
we de ned bins for the values of cyclomatic and npath complexity as shown in the table header.
the rst row represents the methods that have nitely many execution paths cfg contains only forward edges .
for this case reporting the actual number of execution paths is more meaningful for path coverage rather than simply reporting that it is a constant number.
for this reason pac also reports the actual number of execution paths in this complexity class.
pac and npath complexity give the same result and cyclomatic complexity gives the same or a smaller number.
npath complexity percentages for the bins are larger than cyclomatic complexity percentages for the same bins.
this is due to the fact that there can be exponential growth in the number of execution paths with the increase of forward edges in a cfg whereas cyclomatic complexity only grows linearly with the number of forwardedges.
npath complexity is able to catch such exponential cases as shown in the rst row of table .
by looking at only that row we can say that cyclomatic complexity is not a good metric for assessing the di culty of achieving path coverage.
the percentages of the corresponding bins in the c row and n row are close to each other both in cyclomatic and npath complexity.
hence we can say that neither cyclomatic complexity nor npath complexity is able to differentiate between the methods with a constant number of execution paths and the methods with unbounded number of execution paths.
as the degree of the polynomial increases the percentages in the bin decreases.
similarly as the base of the exponential increases the percentages in the bin decreases.
this is because of the fact that as the complexity grows we would expect more edges in the cfg.
cyclomatic complexity always grows linearly with the number of edges and npath complexity grows linearly or exponentially with the number of edges.
we can see that the npath complexity shows a stronger increase in the percentages of higher range bins as the degree of polynomials increases compared to the increase in the base of the exponentials.
this is due to that fact that npath complexity grows exponentially when the complexity is polynomial and linearly when the complexity is exponential.
hence npath complexity is not a good measure for assessing the di culty of achieving path coverage.
one other important point is that cyclomatic complexity and npath complexity only give a constant number as a measurement of program complexity.
the number itself does not give su cient information on di culty of path coverage.
there is always an overlap between di erent com69plexity classes in terms of number of methods in the same range.
for example cyclomatic complexity reports values in the bin for di erent complexity classes and npath reports values in the bin for di erent complexity classes.
as a concrete example pac reports n3 for the method com.sun.org.apache.xerces.internal.impl.xs.xml schemavalidator valuestorecache.initvaluestoresfor and 3n for the method sun.java2d.loops.graphicsprimitive.satisfies the corresponding cyclomatic complexity and npath complexity reported for both methods are which does not carry enough information on actual di culty of achieving path coverage for these methods.
we conducted the same comparison for all values of cyclomatic and npath complexity in c n n2 bn b and bn b complexity classes.
figure shows the frequencies of npath complexity and cyclomatic complexity up to complexity measures of in order to visualize the distribution.
frequencies in figure 6a and figure 6c for npath complexity follows similar trends for the complexity classes c and n .
we can see a similar trend between any two frequency graphs of npath complexity.
the frequencies of cyclomatic complexity values are also following the same trend as shown in figures 6b 6d 6f 6h 6j.
figure validates that cyclomatic complexity and npath complexity are not successful in di erentiating between methods in di erent complexity classes and hence they are not good for assessing the di culty of achieving path coverage.
overall our experimental results validate that path complexity is a better measure for assessing di culty of achieving path coverage compared to to cyclomatic complexity and npath complexity.
our results also show that path complexity can be computed e ciently.
.
conclusions we present path complexity and asymptotic path complexity measures that provide an upper bound for the number of execution paths in a program.
in order to compute the path complexity we rst extract the control ow graph and then use graph theoretic techniques to generate a path complexity function that gives an upper bound for the number of execution paths within a given execution depth.
our path complexity analyzer can be used for assessing the difculty of achieving path coverage with respect to increasing execution depth in the context of automated testing.
our experiments on popular java libraries demonstrate the effectiveness and e ciency of the proposed approach.
in the future we plan to extend our path complexity analyzer with a context sensitive inter procedural analysis.
npath complexity methods 1000c a cyclomatic complexity methods 1000c b npath complexity methods n c cyclomatic complexity methods n d npath complexity methods n2 e cyclomatic complexity methods n2 f npath complexity methods bn b g cyclomatic complexity methods bn b h npath complexity methods bn b i cyclomatic complexity methods bn b j figure distribution of npath and cyclomatic complexity values for the methods in di erent asymptotic complexity classes.
.
replication package the source code for pac as well as a web interface are available from the university of california santa barbra veri cation lab ucsb vlab website .
source code and data.
our tool pac and experimental results have been successfully evaluated by the replication packages evaluation committee and found to meet expectations.
the replication package for pac can be downloaded as a compressed archive.
detailed instructions and scripts are provided for running our tools.
please note that our path complexity routines require a current installation of mathematica .
the package consists of ve major components.
.cfg extractor.
this is an intra procedural control ow graph extraction tool based on the asm java bytecode manipulation library.
our command linebased application takes a directory of java class les or a single java class le as input.
it then computes an intra procedural control ow graph for every method.
the output is a directory of cfgs exported to graphviz dotformat.
.complexity analyzer.
cyclomatic npath and path complexities are computed with a set of mathematica routines.
a command line based script is provided that takes a directory of control ow graphs or a single control ow graph as input.
the input cfg s must be in graphviz dot format.
each cfg is imported into a mathematica session and analyzed.
the results are output into a user de ned le of comma separated values see the following description of experimental data.
.java libraries.
the java sdk and apache commons libraries are provided as benchmark sets.
the cfg extractor described above can be run on these libraries in order to generate the control ow graphs as input to the complexity analyzer.
.control flow graphs.
all of the control ow graphs generated from the java libraries are provided.
.experimental data.
all experimental results for java sdk and apache libraries as summarized in section are also included.
the results include the cyclomatic complexity npath complexity path complexity asymptotic complexity and complexity class constant polynomial or exponential for every method in the benchmark libraries.
web interface.
a web interface for pac is also available from the ucsb veri cation lab web page.
the user may upload a java class le multiple class les a folder of class les or a .jar le.
for every method in the submitted les a table is produced that describes the method s cyclomatic complexity npath complexity path complexity asymptotic path complexity and complexity class.
the complexity class is reported as either constant polynomial or exponential.
.