multise multi path symbolic execution using value summaries koushik sen george necula liang gong philip wontae choi electrical engineering and computer sciences university of california at berkeley technical report no.
ucb eecs october 2014multise multi path symbolic execution using value summaries koushik sen george necula liang gong wontae choi eecs department university of california berkeley ksen necula gongliang13 wtchoi cs.berkeley.edu abstract dynamic symbolic execution dse has been proposed recently to effectively generate test inputs for real world programs.
unfortunately dynamic symbolic execution techniques do not scale well for large realistic programs because often the number of feasible execution paths of a program increases exponentially with the increase in the length of an execution path.
in this paper we propose m ulti se a new technique for merging states incrementally during symbolic execution without using auxiliary variables .
the key idea of m ulti se is based on an alternative representation of the state where we map each variable including the program counter to a set of guarded symbolic expressions called a value summary .m ulti se has several advantages over conventional dse and state merging techniques value summaries enable sharing of symbolic expressions and path constraints along multiple paths value summaries avoid redundant execution m ulti se does not introduce auxiliary symbolic values which enables it to make progress even when merging values not supported by the constraint solver such as floating point or function values.
we have implemented m ulti se for javascript programs in a publicly available open source tool.
our evaluation of m ulti se on several programs shows that m ulti se can run significantly faster than traditional symbolic execution.
.
introduction symbolic execution is a technique for automatically generating a symbolic model from a program.
it has been used succesfully as a key component in a variety of applications including generating high coverage tests for c c c java php javascript x86binaries .
symbolic execution has also been used in program verification tools such as jstar and key .
the key idea behind symbolic execution was introduced almost years ago .
in this paper we consider the dynamic variant of symbolic execution dse in which a program is executed using symbolic values in place of concrete values for inputs.
during the execution the state of variables is represented using symbolic expressions over the symbolic input values.
for each explored execution path of the program symbolic execution generates a path constraint formula over the symbolic input values.
a satisfying assignment to the path constraint denotes a concrete test input to the program on which the program executes along the corresponding path.
symbolic execution attempts to explore all feasible execution paths of a program systematically using a search strategy.
when symbolic execution is used for test input generation a constraint solver is used to extract a satisfying assignment for each path constraint.
when it is used for path based program verifi cation the path constraint and the desired postcondition are passed to a theorem prover in the form of a path verification condition.
symbolic execution techniques do not scale for large realistic programs because often the number of feasible execution paths of a program increases exponentially with the length of an execution path.
to mitigate this path explosion problem a number of techniques have been proposed to merge states obtained from multiple paths converging at a join point.
for example if a variable xis assigned some values v1andv2along the two branches of an if then else statement then after the conditional statement the states from the two paths are merged into a single state by introducing an auxiliary symbolic value for the value ofx say x0.
in the merged states the variable xis mapped to x0 and a symbolic constraint x0 v1 x0 v2 is added to the path constraint stating that x0can either be v1orv2.
the advantage of merging paths at join points is that the number of paths that are explicitly explored remains polynomial in the length of an execution.
however this form of state merging can lead to difficulties if the resulting formulas are outside the scope of the theories supported by the constraint solver which may happen for example ifv1orv2in the above example are floating point values function values or objects.
at the same time this representation of the merged state prevents a common optimization in symbolic execution which is to perform operations concretely if the operands are concrete.
this would be the case in our example if v1andv2are constants in the merged state the operations would have to be performed on the newly introduced auxiliary variable x0 which means that they would have to be performed symbolically.
in this paper we propose m ulti se a new technique for merging states incrementally during symbolic execution without using auxiliary variables .
the key idea of m ulti se is based on an alternative representation of the state where we map each variable including the program counter to a set of guarded symbolic expressions called a value summary .m ulti se improves upon conventional dse while avoiding some of the drawbacks of conventional state merging based on auxiliary variables as follows .
compared to conventional dse the value summary representation of m ulti se is a powerful way of sharing symbolic expressions and path constraints along multiple paths.
as an improvement over state merging sharing using value summaries works even for paths that do not all end at the same join points as long as some variables have the same values on those paths.
also in multi se the sharing is achieved without having to explicitly identify join points and without having to traverse the entire state when merging.
instead the sharing is achieved incrementally at each statement in the program.
we show in this paper that the sharing factor i.e.
the ratio of the number of paths to the number of distinct symbolic expressions in value summaries for each variable ranges from to in our experiments.
var x readinput var z readinput var r readinput x x if x if z r .
if r z r halt .
var x readinput .
var z readinput .
var r readinput .
x x .
if x .
if z .
r .
.
if r .
z r halt .
if r .
z r halt halt .
if r .
z r halt halt .
var x readinput .
var z readinput .
var r readinput .
x x .
if x .
if z .
r .
.
if r .
z r halt figure .
a a simple program to illustrate multise b conventional symbolic execution tree c multise execution dag.
.
compared to conventional dse multise can avoid re dundant work e.g.
for statements that follow a join point andwhich operate on variables that have the same values on thejoining paths.
this follows naturally from the value summaryrepresentation of the state that shares the parts of the state thatare the same among different paths.
we show in this paper thatmultise executes between .
to times faster than con ventional dse.
this is due to multise performing between2 to times fewer operations and correspondingly spendingbetween .
to times less time in smt solver invocations.
.
compared to conventional state merging multise does notuse auxiliary variables.
this has several important advantages.first symbolic execution can proceed even when joining valuesthat are not supported by the constraint solver e.g.
dependingon the solver floating point values objects or function values.existing symbolic execution techniques deal with such situa tions by discarding one of the paths and continuing the exe cution with a concrete value while multise can often carryout the symbolic execution for all paths while staying withinthe scope of the constraint solver.
second if the values beingmerged are function values and the merged value is invoked the multise value summary representation encodes naturallythe various possible functions that may be invoked.
in contrast in conventional state merging if the value being invoked is rep resented as an auxiliary variable an smt solver must be usedto figure out what function should be invoked to proceed withthe symbolic evaluation.
these kinds of operations are quitecommon in dynamically typed programming languages suchas javascript python and ruby.
we show in section .
thatabout half of our benchmarks would require auxiliary variablesof type other than integer or string if executed with conven tional state merging sometimes in the thousands for up to of the joins multise avoids all these problematic auxiliaryvariables.
.
value summary based symbolic execution can be formulatedin a way that generalizes both conventional dse and state merging algorithms for symbolic execution.
we show in thispaper that both these variants can be obtained from multiseby varying the choice of when and to what extent value sum maries are compacted based on sharing of symbolic values.
wealso show that we can vary the way multise chooses whichstate to explore next and depending on this choice we canget different search strategies in symbolic execution such asbreadth first or depth first.
this flexibility of multise makesit a general framework for describing various heuristics used insymbolic execution and state merging.we have implemented multise for javascript programs ina publicly available open source tool branchsymfront .
we usebinary decision diagrams bdds to concisely represent andto efficiently manipulate path constraints and guards of value sum maries.
our evaluation of multise on several programs showsthat multise can run significantly faster than traditional symbolicexecution.
.
overviewwe introduce the concepts of conventional symbolic execution andits state representation informally and then we describe the mainelements of the multise symbolic execution.
we will use theprogram in figure a as a running example which is written ina javascript like language.
a statement of the formvar v e declares and initializes a variablevwith the value of the expressione.
the execution of the statementvar x readinput receivesan integer input from the environment and assigns it to the variablex.
.
conventional dynamic symbolic executiondynamic symbolic execution dse executes a program usingsymbolic expressions for the program variables and memory loca tions.
these expressions are in terms of fresh symbolic values thatare introduced upon execution ofreadinputexpressions.
dse ex ecutes one path at a time and it maintains the current symbolic statethat includes the program counter a mapping of program variablesto symbolic expressions and a symbolic path constraint which isa quantifier free propositional formula over symbolic expressions.for example after executing statements from our examplethe symbolic execution state is as follows path pcxzr1 5true52x0z0r0wherex0 z0 andr0are the symbolic values introduced for theresult of thereadinputexpressions in lines respectively.each row in these tables corresponds to the symbolic executionstate of a path.1informally for any concrete input values concretevalues for the symbolic values that satisfy the path constraint theconcrete execution on those input values will follow the path givenin the table.
also if we evaluate the symbolic expressions on thesame input values for the symbolic variables we obtain the value ofthe variable in the concrete execution at the end of the path.
in ourexample so far for any set of input values the program will followthe path and if the input value forx0is then the value ofxat line will be .upon encountering a branch and if both sides of the branch arefeasible dse replaces the current symbolic state with two copiesof the state with updated values ofpcand of the path constraints.one of these copies is placed in a backtracking set and the otherbecomes the new current state.
continuing our example we can1thepathcomponent of the state is shown here for clarity but is notexplicitly maintained during symbolic execution.
13represent the state after executing the conditional in line in a consolidated manner as follows path pc x z r 2x0 2x0z0r0 2x0 2x0z0r0 in general the path constraints are conjunctions of symbolic boolean expressions corresponding to the branches taken to follow the path specified in the first column.
at every step dse will pick one state from the consolidated state and will update the values of variables and the value of the program counter according to the statement at the program counter for that state.
in the case of a conditional statement a copy of the state with updated pcand path constraint is added to the consolidated state.
we can consider that dse is exploring the execution tree figure b and depending on the strategy dse uses to pick the state to advance next we can have different exploration orders in symbolic execution such as depth first breadth first or best first.
eventually dse will finish exploring all states and will terminate with the consolidated state shown below with each of the five states corresponding to one of the five feasible paths shown in figure b .
path pc x z r 2x0 r0 2x0r0 1r0 2x0 r0 2x0z0 r0 2x0 z06 r0 2x0r0 1r0 2x0 z06 r0 2x0z0 r0 2x0 z0 2x00.
.
we make several observations about this state.
first the path constraints for any two paths in a consolidated state are disjoint.
second dse will evaluate eagerly expressions containing concrete values.
in our example when the conditional if r ... is executed in the path that includes line the boolean condition is evaluated concretely for the value .3forr.
the condition for the then branch is .
which evaluates to true and is thus not shown above in the path constraint for the path .
third symbolic execution aggressively rules out unfeasible paths by checking the satisfiability of the path constraint for the two branches of a conditional using an smt solver.
for the same conditional as before the path constraint for the else includes the conjunct .
1that evaluates to false and makes the path constraint unsatisfiable.
.
m ultise value summary state representation the m ulti se representation of the symbolic execution state is based on the key observation that by considering a consolidated view of the execution state including the current state and also the states saved for backtracking we expose a significant opportunity for sharing of path constraints and symbolic expressions.
consider the final consolidated state of dse as shown above.
we can obtain a more compact representation if we represent it by variables i.e.
by columns.
for each variable and for each distinct symbolic expression of the variable we construct the disjunction of the corresponding path constraints.
for example for pcthe only symbolic expression is 10with the disjunction of path constraints 1 2 3 4 5which is equivalent to true.
consequently we represent the consolidated value of pcas the pair true .w e call such a pair a guarded symbolic expression .
for variables that take different symbolic expressions on different paths we represent their value as a set of pairs with one pair for every distinct symbolic expression.
we call such a set of guarded symbolic expressions avalue summary .
the m ulti se state is a mapping that maps each variable to a value summary.
the path constraints of different guarded expressions for a given variable are disjoint and their disjunction is true.
the m ulti se representation of the final state for our example program is pc7!
true x7!
true 2x0 z7!
1 r0 2 z0 .
r7!
r0 .
final state am ulti se final state describes compactly the final values of all variables in all feasible concrete executions as follows.
given any assignment of integer input values to the symbolic values corresponding to the program inputs exactly one of the path constraints will hold for each variable.
the corresponding symbolic expression evaluated at the given program inputs gives the value of the variable at the end of the execution of the program on the given program inputs.
there are several advantages to the m ulti se value summary representation.
the obvious one is its more compact form.
as we will show in our experiments there is a significant amount of sharing for the symbolic expressions of variables among the many execution paths.
the less obvious but more important advantage is that this representation achieves a natural form of state merging which in turn can reduce dramatically the number of statements that must be executed symbolically as we discuss in the next section and we show experimentally in section .
.
m ultise symbolic execution with value summaries to illustrate the operation of m ulti se consider the state when the symbolic execution has explored all three paths up to the conditional in line .
for a conventional dse the state would be path pc x z r 2x0 2x0z0r0 2x0 z06 2x0z0r0 2x0 z0 2x0z01.
this state representation with three separate rows corresponds to the three separate instances of execution paths ending in the statement at line shown in dse execution tree from figure b .
the corresponding m ulti se value summary representation of the state is pc7!
true x7!
true 2x0 z7!
true z0 r7!
r0 .
intermediate state where x0 z0 .
note that the guard for the value r0of the variable r can be written either as 2x0 100 2x0 z06 or the logically equivalent .
this value summary represents a merge of the three separate conventional dse states corresponding to three separate executions paths.
this allows m ulti se to evaluate the conditional in line twice i.e.
once for each value of rin the value summary instead of three times for conventional dse as shown in the m ulti se execution dag directed acyclic graph shown in figure c .
multi se symbolic execution in this state first considers the value summary for the program counter.
it picks one of the values in this case guarded by the path constraint true and executes the statement if r ... .
this requires the computation of the value of the expression r .
the symbolic execution of the expression r goes over each guarded expression in the value summary for variable r applies the operation on the expression part of each guarded expression and computes the value summary r0 true .
note that we add the conjunct true to each guard to account 13for the current path constraint for the program counter.
note that the second guarded expression for r contains the symbolic expression true which is obtained from .
.m ulti se eagerly simplifies the parts of symbolic expressions that do not depend on symbolic values.
essentially we want to compute the value of the binary expressionr only for the paths matching the path constraint from the value summary of pc.
next m ulti se processes the actual conditional statement.
we compute the condition for the computed value of r to be true as a disjunction over the guarded expressions in the value summary forr .
we must also add a conjunction for the current path constraint true .
we will denote this condition as true r0 true therefore after the execution of the conditional statement at line in the new state pcmaps to the value summary where 6is logically equivalent to r0 the condition for the computed value of r to be false .
the value summary representing compactly both the then and the else branches can be written as pc7!
x7!
true 2x0 z7!
true z0 r7!
r0 .
intermediate state note that this value summary represents five paths two of which end at line after taking the else branch at line and the remaining three paths end at line .
6denotes the combined path constraint of the two paths ending at line and 6denotes the combined path constraint of the three paths ending at line .
every time a new guarded symbolic expression is added to the value summary for pc m ulti se invokes a quick bdd satisfiability check followed by an smt solver satisfiability check for the path constraint.
this is important in order to avoid exploring unfeasible paths.
for the value summaries of other variables only a bdd satisfiability check is used to reduce the overall cost of smt solving which is a significant fraction of the overall cost.
one of the most interesting aspects of m ulti se is that it performs incremental state merging at every assignment statement to obtain a new consolidated representation of states using value summaries.
to illustrate this aspect we continue with the above multi se state.
say that for the program counter m ulti se picks the guarded value and executes line next with the path constraint .
first we symbolically evaluate the right hand side of the assignment r and we obtain the guarded value r0 .
since line is guarded by the path constraint symbolic execution of the assignment z r should only update the value ofzfor those paths for which 6istrue.
the value of zmust remain unchanged in the symbolic state for the other paths.
this is achieved by computing the new value of zusing a guarded valuesummary union where we preserve the previous value of zwith the additional guard the negation of the current path constraint to which we add the value summary for the right hand side with the additional guard .
by applying a conjunction of 6to the guards of the current value summary stored in z we keep unchanged the portion of the value summary for the other two paths whose combined path constraint is .
the resulting value summary for zis z0 r0 .
which is logically equivalent with the value summary we have used in final state for the final value of z. finally the value summary stored in pcis also updated to which simplifies to true .
therefore after the execution of the statement z r at line the state becomes the same as the final state .
.
advantages of m ultise we highlight the key advantages of m ulti se over existing techniques for symbolic execution.
first the m ulti se state representation using guarded symbolic expressions is a powerful way of sharing symbolic expressions and path constraints among many different paths.
we show in section that the sharing factor i.e.
the ratio of the number of paths to the number of distinct symbolic expressions in value summaries ranges from to in our experiments.
some amount of sharing is also accomplished by previous techniques for symbolic execution using state merging but in multi se there is sharing for all states not just those at controlflow join points as shown for example in the intermediate state .
multi se proposes a novel technique for incrementally updatingthe consolidated symbolic execution state.
we have seen an example of this incremental update in the previous section when we showed the state update for the assignment on line .
the righthand side of the assignment is computed only for the paths matching the current path constraint by conjoining the guards of the used variables with the current path constraint.
the new value summary for the variable includes this computed value summary for the right hand side along with the old value summary conjoined with the negation of the current path constraint to model the preservation of the value of the variable on paths not matching the path constraint.
thus the m ulti se state is at all times consolidated over all the paths being explored.
this incremental state update is in contrast with how state merging is conventionally implemented.
at join points state merging needs to iterate over the part of the symbolic state that has been modified by the paths converging at the join point and merge that part of the state.
identifying the join points keeping track of the modified part of the state and merging the modified state could pose various implementation challenges which are not present in multi se.
furthermore because in m ulti se sharing is automatic for all paths at all times it takes effect even for programs where the join points are not known statically such as programs with exceptions or computed control flow or for binary programs with unstructured control flow where the join points are non trivial to compute.
in fact in section we present the m ulti se algorithm for an assembly like language with computed jumps which shows that multi se can be used effectively for very low level languages.
in contrast state merging techniques need explicit knowledge of the join points to trigger the merging operation that achieves sharing.
second multi se avoids redundant computation.
this feature is directly due to maintaining the value summaries in a consolidated form at all times.
at each step m ulti se picks one of the guarded expressions in the program counter value summary and executes that statement.
for example in conventional dse the same statement z r at line will get executed three times along three paths reaching the statement as shown in figure b .
m ulti se executed the statement only once as shown in figure c because the new state representation intermediate state merges the three paths.
in contrast to state merging techniques which need to identify statically the join points in m ulti se we can achieve sharing and thus effectively merging even in a language with computed jumps.
we show in section that m ulti se executes between .
to times faster than conventional dse.
this is due to dse per4 13forming between to times more operations and also spending between .
to times more time in smt solver invocations.
third m ulti se achieves sharing without introducing auxiliary symbolic values during state merging at join points.
this has three advantages .
execution can proceed even if certain theories are not supported by the constraint solver.
.
execution can carry out most operations concretely.
.
there is no need for expensive constraint solver calls where conventional state merging introduces auxiliary symbolic values for functions and subsequently functions denoted by those auxiliary symbolic values are called.
to illustrate these advantages we first need to take a look at how existing symbolic execution techniques for merging state work.
existing techniques introduce auxiliary symbolic values to represent the value of a variable computed along two or more paths merging at a point.
for example consider the intermediate dse state of the example program at line where three paths merge.
path pc x z r 2x0 2x0z0r0 2x0 z06 2x0z0r0 2x0 z0 2x0z01.
here the symbolic expression for the variable ralong the three paths are not all the same.
conventional dse stores only one symbolic expression for each variable.
therefore conventional state merging would introduce an auxiliary variable r1to denote the value of the variable r and would add to the path constraint the relationship between r1and the different symbolic expressions for ralong the merged paths as follows path pc x z r .
.
.
2x0 r1 r0 2x0 z06 r1 r0 2x0 z0 r1 .
2x0z0r1 the problem with this approach is that the new path constraint containing the auxiliary variable has a predicate r1 .
.
however if the constraint solver does not support floating point constraints then symbolic execution cannot merge the paths to generate a path constraint that is beyond the scope of the constraint solver.
in m ulti se we never introduce auxiliary symbolic values.
therefore path constraints in m ulti se are always formulas over the input symbolic values which we restrict to integer and string types.
concrete values of data types that are not supported by the constraint solver remains in the state as concrete values guarded by symbolic predicates.
this also implies m ulti se can perform more operations concretely than existing techniques as demonstrated below for functions as values.
the fact that m ulti se does not introduce auxiliary symbolic values while merging paths also helps m ulti se to efficiently handle function values which are often first class objects in dynamic languages such as javascript python and ruby.
we illustrate this using the following program var x readinput var f r if x f f u n c t i o nf r e t u r n1 else f f u n c t i o nf r e t u r n r f 2the same problems arise if we write the path constraint using ite if thenelse r1 ite 2x0 r0 ite z06 r0 .
.in this program xgets an input from the environment.
depending on whether x fis assigned the function f1orf2.
then the function stored in fis called and the value returned by the call is stored in r. consider a conventional dse state with two paths both of which end at line path pc x f r x0 x0f1 x0 x0f2 if we merge the two paths using existing path merging techniques then the state becomes path pc x f r .
.
.
x0 f0 f1 x0 f0 f2 x0f00 merging introduces an auxiliary variable f0and the path constraint now refers to the function objects f1andf2.
if we treat f1andf2as symbolic