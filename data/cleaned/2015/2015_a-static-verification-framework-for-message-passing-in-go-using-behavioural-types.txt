a static verification framework for message passing in go using behavioural types julien lange university of kent j.s.lange kent.ac.uknicholasng imperialcollege london nickng imperial.ac.ukbernardo toninho imperial college london b.toninho imperial.ac.uknobukoyoshida imperialcollege london n.yoshida imperial.ac.uk abstract the go programming language has been heavily adopted in industryasalanguagethatefficientlycombinessystemsprogramming withconcurrency.go sconcurrencyprimitives inspiredbyprocess calculisuchasccsandcsp featurechannel basedcommunication and lightweight threads providing a distinct means of structuring concurrentsoftware.despiteitspopularity thegoprogramming ecosystemofferslittletonosupportforguaranteeingthecorrectness of message passing concurrent programs.
thisworkproposesapracticalverificationframeworkformessage passing concurrency in go by developing a robust static analysisthatinfersanabstractmodelofaprogram scommunication behaviour in the form of a behavioural type a powerful process calculitypingdiscipline.wemakeuseofouranalysistodeploya model and termination checking based verification of the inferred behavioural type that is suitable for a range of safety and liveness propertiesofgoprograms providingseveralimprovementsover existingapproaches.weevaluateourframeworkanditsimplementationon publicly available real world go code.
ccsconcepts theoryofcomputation verificationbymodelchecking typetheory processcalculi softwareanditsengineering model checking automated static analysis softwareverification concurrent programming languages acm reference format julienlange nicholasng bernardotoninho andnobukoyoshida.
.a staticverificationframeworkformessagepassingingousingbehavioural types.in icse icse 40thinternationalconferenceonsoftwareengineering may27 june3 gothenburg sweden.
acm newyork ny usa pages.
introduction modern programming languages have evolved with the ever increasing need for highly available interactive software services providing programmers with frameworks that facilitate the developmentof suchintricatecommunicating systems.amongstthese languages the go programming language created at google in 2007targetsthe development of concurrent software systems by integrating channel based concurrency and lightweight threads as icse may june gothenburg sweden copyright held by the owner author s .
acm isbn .
languagesforconcurrencytheoryknownas processcalculi .go enablesprogrammerstowritestatically typedconcurrentsoftware andhasbeenusedsuccessfullyinarangeofindustrialsettingssuch as uber and dropbox s infrastructure the docker software container platform the kubernetes cluster manager amongothers .
however beyonditssimplestatictypesystem goprovidesfairly fewassurancesonthecorrectnessofconcurrentcode.atcompile time goonlyenforcesthatmessagesexchangedviacommunication channels adhere to thedeclared channel payload types providing nowayofdetectingcommonconcurrencyerrorssuchasdeadlocks orundeliveredmessages.atruntime gooffersonlyatoyglobal deadlockdetector.thisisinsharpcontrastwiththerichbodyof workonprocesscalculi basedverification whereaplethoraoftypebased and logic based techniques enable reasoning about safety andliveness properties of interactive systems.
given the foundations of go s message passing concurrency in process calculi our work aims to bridge the divide between thefoundationsandprogrammingpracticesbyapplyingmodern process calculi based verification techniques to real world go concurrent programming.
concretely we propose a static verification framework for concurrency and message passing communication usingconcurrentbehaviouraltypes whichhavebeendeveloped extensively in concurrency theory since the early 90s.
to achieve this we crucially address the substantial conceptual gap that exists between a formal mathematical language a process calculus and a general purpose programming language withconcurrencyfeatures.ourapproachanalysesgeneralgosource code and distills from programs behavioural types that serve as a faithful modelof its message passing concurrent behaviour.
our behavioural types consist of a simplified form of concurrent processes which are reminiscent of concurrent communicating systems ccs or communicating sequential processes csp which inspired the design of the go language .
given such a formallygroundedmodel wemaythenapplyarangeofprocesscalculi oriented verification techniques to go.
specifically we convert gosourcecodeintoastaticsingleassignment ssa formwhich provides a fine grained view of the concurrency primitives used in programs in a quasi functional form enabling our behavioural typeinference.wethenemploymodelcheckingandterminationchecking techniques to automatically verify safety and liveness properties such as deadlock freedom and communication safety.
asignificantadvantageofourapproachoverpreviousworks is thatour inferenceprocedure covers amuch largerpart of the go language allowing for the automatic extraction of an accuratemodelofaprogram sconcurrency relatedfeatures resultingin amore preciseanalysiswithreduced numbersoffalse alarmsand .
ui oufsobujpobm pogfsfodf po 4pguxbsf ohjoff sjoh this work is licensed under a creative commons attribution international .
license.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden julienlange nicholasng bernardo toninho and nobuko yoshida funcprod ch chan int fori i i ch i send i to ch 5close ch no further values accepted at ch funccons ch1 ch2 chan int for select casex ch1 print x either input from ch1 casex ch2 print x or input from ch2 funcmain 16ch1 ch2 make chan int make chan int goprod ch1 goprod ch2 19cons ch1 ch1 figure partially deadlocked producer consumer in go.
undetectederrors.ourintegrationwithageneralpurposemodel checker also enables us to modularly verify arbitrary safety and livenessproperties overthemoresingle mindednatureofpreviously proposedtechniques aswell astake advantageof advances in model checking to provide better performance scaling.
concurrentprogrammingingo.
weprovideanoverviewof the goprogramming language withan emphasis onthe challenges ofconcurrentprogrammingandhowourverificationframework can check for common concurrency errors in programs.
go is a language with message passing concurrency features and lightweight threads known as goroutines .
the key feature of go s concurrency primitives is the predominance of channelbasedcommunication over shared memory based communication amongst threads.
in go a channel consists of a typed buffer that canbeusedbyanarbitrarynumberofthreadsforreadandwrite operations.channelsare synchronous bydefault i.e.blockingon readsandwrites butcanbemadeasynchronousbyspecifyinga buffersizeduringchannelcreation.asynchronouschannelsprovide non blocking sends whilethe bufferis not full.
we introduce thego programming language with the program infigure1whichimplementsaproducer consumerconcurrentpatternwithtwoproducersandoneconsumerthread communicating over a pair of synchronous channels.
the producer code lines is written as a function that takes as a parameter a channel chthat cancarrypayloadsoftype int.aproducermerelysendsaninteger value over the given communication channel ch writtench i in go where iis the value to be sent a predetermined number of times encodedasa forloop andthen closesthechannel signalling thatno further values are to be sent.
the consumer code lines is specified as a function taking twochannels ch1andch2 oneperproducer .the consfunction consists of a common go idiom known as a for select loop a potentially infinite loop the parameterless foron line containing a selective communication construct line .
the behaviour of selectis such that the consumer waits for an input on either ch1 orch2 inputs in go are written ch .
whenever communication is available the appropriate caseis selected.
the consumer printsgo source codeinference go ssabehavioural types model checker mcrl2 termination checker kittel figure the godel checker workflow.
the received integer from either producer.
despite the channels being closed by the producers the consumer s inputs still succeed.
finally theprogramentrypoint maininlines15 setsupthe producersandconsumerbycreatingthetwosynchronouschannels ch1andch2 line16 spawningtwoproducersinparallel achieved by the goprefix to the function calls which creates a goroutine that runs in parallel with the main program executing the prod function and then runningthe consfunction.
common concurrency errors in go.
we describe common errors in channel based go programming as well as limitations of go s built in runtime detector channel safety errors once a channel is closed receive actions always succeed receiving messages in flight or a default value for the payload type but all send and close actions performed on the channel raise a runtime error.
hence channels should be closed at mostonceand no message should be sent on closed channels.global deadlocks the goruntimecontains a globaldeadlock detector that signalsa runtime errorwhen allgoroutines in aprogramarestuck i.e.deadlocked .howeveritisoftenthecasethat when certain libraries are imported such as the commonly used netlibrary for networking the global deadlock detector is silently disabled i.e.
all global deadlocks are just ignored.
partial deadlocks it is often the case that a program s communicationcannotprogressdespite someofitsgoroutinesnotbeing stuck.
this is known as a partialdeadlock or as a failure of liveness.
for instance the consfunction above is being executed with thewrongchannels ch1twice instead of ch1andch2 due to a programmererror.runningtheprogramresultsinasystemthat is notlive since the second producer is not interacting with the consumer the outputs are never matched with their respective inputs.
since only a subset of the goroutines are stuck these errors cannotbe detected by the go runtime.
astaticverificationframeworkforgo.
thispaperproposes astaticanalysistoolchaindubbedgodelchecker whichcan automatically detect safety and liveness errors in real world go programs.theworkflowispresentedinfigure2 consistingofthree layers given a go program we first perform behavioural type inference detailed in that extracts a behavioural type model for the program .
in this stage we use the ssa static single assignment package from the go project and apply a control flow analysis to obtain behavioural types.
we then apply a model checkingtool mcrl2 totheextractedbehaviouraltypes .
thisenablesustochecktypeswithafinitestate space i.e.
finite control fortheabsenceofglobaldeadlocks aswellasseveralgo specific safety properties including channel safety .
finally to pinpointpotentiallyproblematicloopsandaccuratelydetectpartial authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a static verification framework for message passing in go using behavioural types icse may june gothenburg sweden deadlocks weaugmentourapproachwithaterminationanalysis for loops in the original go source code using a term rewriting based tool kittel .
we show benchmarks for publicly available go programs and compare with existing tools .
behavioural types for go this section introduces behavioural types for concurrent go whichareinferedasanabstractmodelofgo see andtheir relationshipwithgoprograms followingourpreviousworkin .
behaviouraltypesareatypingdisciplineinwhichtypesexpress thepossibleactionsofaprograminafine grainedway .when applied to communication and concurrency behavioural types act as an abstract specification of all communication actions that may be performed in a program.
moreover behavioural types are an executable specification.
they have a natural operational meaning and evolve throughout program execution.
the syntax of types is given below it extends the types defined in with general sequencing.
the types abstract away data elements singling out the concurrency specific features such as spawning of threads i.e.
goroutines creation of communication channels send and receive actions and selective communication.
colonequalu u t colonequal ti yi ti i iins t s colonequal t t s t s binampersand i ti i i t s newna t closeu t t angbracketleft u angbracketright a n k a communication is specified with the prefix where can beu denotingasendonchannel u u denotingthedualreceiveactionon channeluand denotingasilentinternalstep uiseitheraconstant channeloravariable .
t smodelsthesequentialcompositionof tands.
the construct closeusignals that channel uis to be closed.werepresentconditionalbranchingwiththe t sconstruct denotinga non deterministic internalchoicebetween tands.thus our type level analogue of conditional branching does not depend ondatabutrathersimulatestheabilitytotakeeitherbranchofa conditionalthrougha non deterministic step.
we model go s selective communication with binampersand i ti i i. the construct waits for the availability of one of the icommunication actions.whensomeaction jbecomesavailable itisexecutedand thecommunicationevolvestobehaviour tj discardingtheother options .whenmorethanonecommunicationactionisavailable one is chosen non deterministically.
since actions are always available to fire we can use a action in a select construct to model timeouts or default behaviours when no other actions are available.
the parallel composition construct t sdenotes the parallelexecutionof tands theconstruct 0denotesnobehaviour.
channelsingoaresynchronousbuffersbydefault butmayalso becreatedwith a bound achievingasynchronous communication.
send actions are non blocking until the number of messages in the buffer reaches the bound and dually receive actions on empty buffersareblockinguntilamessageisavailable.
newna tdenotes the creation of a channel a with a bound n which can be used locally in t. if the bound nis set to then ais a synchronous channel.
we often write newa tfor new0a tand assume that the scope of aextends as far to the right as possible.
construct t angbracketleft u angbracketrightdenotes a function call with parameter u.w e oftenidentifyalist uwithitsunderlyingsetandwrite x uifxisaelementof u.weusethefollowingtwo runtimeconstructstodefine the semantics of types in a n krepresents a communication channel at a wherenis the maximum capacity of the queue and k is the current number of messages in it and a represents a closed channela.
the type of a program sometimes written ti yi ti i iins is a set of potentially mutually recursive definitions tiwith a distinguishedprogram entrypoint s.recursivedefinitionscanbe parameterisedbycommunicationchannelsandrepresentthe goroutinesthatare executedinthe program.foreachtype definition ti yi tiwe assume that the free names of tiare included in yi.
example .
type for consumer producer and their properties .
the behavioural type for the program of figure is given below.
braceleftbig prod ch ch prod angbracketleftch angbracketright closech cons ch1 ch2 binampersand ch1 cons angbracketleftch1 ch2 angbracketright ch2 cons angbracketleftch1 ch2 angbracketright main newch1 ch2 prod angbracketleftch1 angbracketright prod angbracketleftch2 angbracketright cons angbracketleftch1 ch1 angbracketright bracerightbig inmain angbracketleft angbracketright definition prod ch specifiesthetypeforthe producer function while cons ch1 ch2 stands for the type of the consumer function andmain angbracketleft angbracketrightis the type of the program entry point i.e.
the main function .noticehowtheimperativecontrolstructuresaretransformed into recursive definitions and the data elements are erased.
for instance the type prodspecifies the behaviour of performing aninternalchoice denotedbythe construct betweensending onchand recursing or closing the channel chandterminating.
given that behavioural types act as a form of executable specifications itisnaturaltoconsiderpropertiesof typesintermsoftheir executions as well as their relationship with program properties.
.
behaviouralproperties of types the property of global deadlock freedom gdf entails that if a communication action is available to fire the type can alwaysmake progress meaning that a type as a whole is never globally stuck.
for instance the type mainin example .
satisfies gdf since the communication actions in subcomponents prod angbracketleftch1 angbracketright andcons angbracketleftch1 ch1 angbracketrightcanalwaysmakeprogress despitethefactthat actionsin prod angbracketleftch2 angbracketrightare always stuck.
thepropertyof liveness alsoknownas partial deadlock freedom isstrictlystrongerthangdf giventhateverylivetypeisalso gdf.
it states that allcommunications that can become enabled in a type can always eventually fire.
for instance replacing the call to cons angbracketleftch1 ch1 angbracketrightwith cons angbracketleftch1 ch2 angbracketrightmakes the type main angbracketleft angbracketright in example .
satisfy liveness.
we note that in the presence of internalchoice i.e.conditionalbranching livenessrequiresthat communicationactionsin bothbranchesmust eventually succeed but when facing external choice i.e.
the selectconstruct only branches that can be selected are required to eventually succeed.
for instance the following single producer variant of main angbracketleft angbracketrightalso satisfieslivenesseventhoughthe ch2branchintheselectconstruct can never be taken newch1 ch2 prod angbracketleftch1 angbracketright cons angbracketleftch1 ch2 angbracketright .
in we formally define the above properties as well as other properties that are verified in our work in the modal calculus.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden julienlange nicholasng bernardo toninho and nobuko yoshida 1funcmain 2ch make chan int create channel gosendfn ch run as goroutine 4x recvval ch ordinary func call fori i x i print i 8close ch close channel ch funcsendfn c chan int 11c send on channel c funcrecvval c chan int int return c receive from channel c listing1 a simple concurrent program in go.
.
relationshipbetween types and programs inouranalysis aconditionalisabstractedasanon deterministic choice between the two alternative behaviours present in the then andelsebranches.thiscoarseabstractionintroducesasubtleinteractionbetweennon terminatingprogrambehaviourand datadependent communication wrt.
liveness we note that this issuedoesnotaffectgdforchannelsafety .forinstance consider the following go program 1funcsend n int cchan int ifn conditional send if n is even c n send to channel c 5send n c 7funcrecv c chan int for infinite loop x c receive from channel c funcmain 13c make chan int gosend c gorecv c thetypeforthefunction send lines1 is send c c send angbracketleftc angbracketright send angbracketleftc angbracketright.similarly thetypefor recv line9 is recv c c recv angbracketleftc angbracketright.
the type for the program above is deemed live since the then branchoftheconditionalin sendcanalwayseventuallybereached throughrecursion ensuringthattheinputsin recvarematched.
however in the program the thenbranch of the conditional can never be reached and so the inputs in recvcannot succeed.
thisexampleissymptomaticofamismatchbetweentypeand program liveness in the presence of infiniteexecutions that flow throughaconditional.notethatitisnotthecasethatthesimple existence of non termination makes the liveness analysis unsound .
for instance for the example in type liveness implies programliveness despitethepresenceofnon termination since there is no communication contingent on a data dependent test.
in we address this issue by deploying a lightweight termination analysis of iterative behaviour in our framework.packagemain t0 makechan int gosendfn t0 t1 recvval t0 jump30 t5 phi i t t t ift6goto1else23 t2 print t5 t t jump31 t4 close t0 return2for.loopfor.donefuncmain entry returnsend c return0funcsendfn c entry return t0 c return t00funcrecvval c entry return block of instructionsn function boundary package boundary figure ssa ir built from listing .
behavioural type inference we detail one of the main contributions of our work the development and formalisation of a procedure that infers whenever possible behavioural types from go source code.
the inference consistsoftwokeysteps theconversionofgosourcecodeto astaticsingleassignment ssa intermediaterepresentation ir using the ssapackage from the go standard library and the extraction of the communication structure as behavioural types from ssa blocks.
.
from go source code to ssa ir thessapackage representssourcecodeinssaformandprovides a high level api for manipulating go source code programatically.
go programs are organised as packages which consist of package variables and functions also definable within bodies of functions .
each function is transformed into a list of blocksof ssa instructions withone block marked as the function entry point .
figure gives a graphical view of the ssa representation of the programinlisting1.eachofthethreegofunctions main sendfn andrecvval becomes a set of blocks graphically a dotted box represents the scope of the function .
the last instruction of a blockisalwaysacontrolflowinstruction if jump orreturn connectingtheblocktoitssuccessors ifany .thesuccessorrelation isshowninthegraphvia edgesconnectingblockswithinafunction.
there are also entryandreturnarrows for function entry and exit respectively implicit from the ssa ir.
table summarises the instructionsof interest to our inference.
communicationinstructions.
go s channel based communicationconstructsareactualprimitivelanguageconstructs.thus the keyoperationssuchaschannelcreation make chant cf.line2 from listing sending and receiving values over channels ch value and chrespectively lines and spawning of goroutines gosendfn inline3 andclosingchannels i.e.
close authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a static verification framework for message passing in go using behavioural types icse may june gothenburg sweden table key ssa instructions used by our type inference.
makechants create channel of type tand sizes localchant declare channel of type t ch v sendvto channel ch ch receive from channel ch select b non deterministicselect close ch close channel ch jump1 enter block ift0goto1else2ift0then enterblock 1else block return exit function f call function f gof spawnfas goroutine t t storet1intoaddress t0 phi i inedges selectviif predecessor block is blki operation line8 areall explicitinthessair.asaresult identifying the channel operations that match with the corresponding behavioural types is straightforward.
select instructions.
non deterministic selective communication select also appears explicitly in the ssa representation but requires a more intricate representation.
we illustrate the structureof the ssa representation of the select block from listing in figure4.listing2showsasimplefunction myselect c whichconsists of a select construct featuring three cases the first is guarded byareceiveactiononchannel c thesecondisguardedbyatimeout and the last is the default case executed if none of the other cases are ready to be executed .
the ssa ir of myselect c consists of6blocks.block 0istheentrypointofthefunction containing thessainstructionforselect.notethattheinstruction select nonblocking contains only two cases.
the defaultcaseisidentifiedbythekeyword nonblocking ifaselect does not specify a default case its ssa representation becomes select blocking .
we note that timeouts are implemented in go as channels e.g.
t0 that receive a message afterapredeterminedtime.thismessageisplacedintothechannel by theruntime andnot by auser level send.the statement t2 extract t1 determines the index of the case which will be executed and stores it in t2.
block0ends with an if then else construct which is the first of an if then else chain identifying whichcaseoftheselectistobeexecuteddependingonthevalueof t2.blocks2and4representthebodiesofthefirsttwocases respectively.block 5containsthebodyofthedefaultcase thedefaultcase is always the last block of the chain if a select statement does not specifyadefaultcase thenthisblockcontainsa panic instruction whichcannotbeexecutedinnormalcircumstances.finally block 1represents the code that follows the select statement.
phiinstructions.
another key ssa instruction is phi blki vi i inedgeswhichisusedtoselectbetweentwoormorevariables when merging the control flow into one ssa block.
an example of such an instruction is given in block 3of figure where the instruction is used to select the value of variable t5 the index of theforloop dependingonwhetherthepredecessorofblock 3is block0orblock1.theformercorrespondstotheinitialisationstep1funcmyselect c chan int select casemsg c print received msg case time.after time.second print timeout ready in 1s default print default always ready listing a select statement in go.
t0 time.after time.
duration t1 select nonblocking t2 extract t1 case index t t ift3goto2else30 t t ift4goto4else53 receive ... jump12 timeout ... jump14 default ... jump15 cont.
... return1funcmyselect c returnentry figure simplified ssa ir built from listing .
of the loop in which case the index is the latter corresponds to an execution of the body of the loop.
conventions.
given an ssa statement s e.g.
t0 make chan int theleft hand side lhs isthepartofthestatement on the left of the symbol the variablet0 .
the key features of the ssa representation are that within the scope of a function all the lhs of the statements in the blocks of that function are pairwise distinct.
also the static typing information is available foreachstatement.inaddition variablesdeclaredatthepackage level are initialised in a special init function.
variables that are accessed by anonymous functions appear in the header of the ssa representation of that function as free variables.
.
extractingtype definition bodies instep we soundlyapproximate wheneverpossible thecommunicationbehaviourofgoprogramswiththetypelanguage.first foreachssablock nineachfunction fun x wegenerateatype signature of the form fun n y t v where yisasubsequenceof xwhereeach yin yisachannelparameter tis a list of channelvariables that appear in the lhs of the statementsinthepredecessorsofblock nanddonotappear in the lhs in block n visalistof globalchannel variables declaredoutsideoffunction fun e.g.
package level variables .
we store all signatures in an environment and write fun n for the signature of block nin function fun.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may27 june gothenburg sweden julienlange nicholasng bernardo toninho and nobuko yoshida function genfunction fun n k switchs statement at line kdo caset makechantsdo genfunction fun n k newst caset local chantdo genfunction fun n k caset vor tort tdo genfunction fun n k mkprefix s caseclose t do genfunction fun n k close t casereturndo return casejumpido return mkjump fun i caseif gotoielsejdo return mkjump fun i mkjump fun j caseselectb do c mkjump fun n foriin do i mkprefix i prime i mkjump fun n i ifb nonblocking then d mkjump fun n j return binampersand i prime i c i ... j d c else return binampersand i prime i c i ... j casef x ort f x do iftis a channel then abort elsegenfunction fun n k mkcall f x casegof x do prime genfunction fun n k return mkcall f x prime case t t ort0 t1 do ift1is a channel then genfunction fun n k elsegenfunction fun n k casephi i inedgesdo if i inedges viis a channel then abort elsegenfunction fun n k otherwise do genfunction fun n k algorithm1 pseudo code of genfunction .
.
core procedure genfunction .we present the core algorithm the genfunction procedure whichgeneratesatypeabstraction from an ssa block.
the procedure takes five parameters fun the name of the function being considered n the identifier of theblock k thelinenumberwithinblock n thetypewehave constructed thus far and a context which maps each channel variablenameto its representative .
thecontext iscrucialinourdevelopmentasgoallowschannels to be aliased i.e.
several variables may contain a reference to thesamechannel andchannelvariablestobeoverwritten e.g.
a channelvariablemayrefertodifferentchannelsatdifferentpointof theexecutionofaprogram ormaybedeclaredandonlyinitialised at a later point.
we keep track of aliased channels by assigning a unique representative to each newly created channel.
we write forthecontext wherethemappingfrom tisupdated tot prime.
we assume that isundefined ift dom and t nequal in order to disallowchannel overwriting.algorithmfor genfunction .ouralgorithmreliesonauxiliary partial functions for thetranslationsfrom statements to types mkprefix s send receive actions and select guards mkjump fun j jumpstatements mkcall fun x functioncalls eachfunctionusescontext togeneratecommunicationactions and type definition calls respectively.
algorithm gives the implementation of genfunction which iterates over the lines of block nin function funand makes a case analysis depending on the structure of the statement sfound at linek.theprocedurereturnsabehaviouraltypeor abortswhenever an invocation to auxiliary functions is undefined or when the algorithm reaches an abort statement since in these cases we cannot guarantee a sound approximation of program behaviour.
in particular the algorithm aborts if a channel variable is overwritten a new channel is assigned to it .
channel creation declaration.
ifsis a channel creationstatement variable tbecomes the representative name for this channel and we update the environment with .
the ssa representation guarantees that tis unique in function fun.
we create the corresponding new channel type construct and recursively call genfunction over the next line.
if sis a channel declaration statement weupdatetheenvironmentwith .notethat tcan only be used after it is initialised.
send receive.
ifsis a send or receive statement we translate it to a type construct with a call to mkprefix s defined below mkprefix s uifs t vand t u uifs t t t and t u ifs tandtis atimeoutchannel timeoutchannelsarededicatedchannelscreatedatcompiletime to encode timeouts they are never added in the context .
closeismappedtoitsrespectivetypeprimitive viacontextlookup.
return.wereturnthetypebuiltsofarappendedwiththetermination construct.
jump.we translate a jump statement into a type function call through the auxiliary function defined below which uses the globally availablesignature environment .
mkjump fun j fun j angbracketleft y t v angbracketrightif fun j fun j y t v and t t t nequal otherwise mkjump fun j models a jump to another block within the same enclosingfunctionhencethereisnoneedtorenametheparameters northe global variablesfromthefunctionsignature sincethey arefixedwithinthescopeofthefunction .instead theinternally declared variables are replaced by their representatives using .
the function mkjump fun j is undefined if any of the targuments maps to an uninitialised channel in order to guarantee that thesecannotbeoverwritteninthedefinitionof fun.the yand v arguments are assumed to be initialised by the parent function.
conditional constructsarealsotranslatedstraightforwardlyusing and type definition call.
select.ifsis aselectconstructthen sis followed by a chain of blocks linked by if then else statements which encode the branching structure of the select as explained in .
.
the jump to the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a static verification framework for message passing in go using behavioural types icse may june gothenburg sweden function genbody fun n fun n y t v fun n x y t v returngenfunction fun n function genequations return fun n genbody fun n fun n dom inmain angbracketleft angbracketright algorithm2 pseudo code of the overall algorithm.
continuationoftheselectstatementisstoredin c whiletheguard andbodyofeachcaseisstoredinto iand prime i respectively.ifthe selectstatementcontains adefaultcase b nonblocking we additionallytranslatethelastblockofthechainintoatypefunction call.
the guard and body of each case is then appended with the type function call corresponding to the continuation and all the componentsare packaged into an external choice construct.function calls.
ifsis a function call we create a corresponding type definition call using the auxiliary function mkcall fun x whichdefined as follows mkcall fun x fun angbracketleft x v angbracketrightif fun fun y v and x x x nequal otherwise notethattheargumentsarereplacedbytheirrepresentativesaccording to and the function is undefined if any of them refers to an uninitialised channel.
goroutines.
ifsspawns a new goroutine we proceed similarly to the function call case but place the call in parallel with its continuation whichiscomputedthroughacallto genfunction starting withan empty behavioural type denoted by .
aliasing.
ifsstores achannelvariable into another we update the context with which is undefined if t0 nequal .
phi.ifsisaphistatement weproceedonlyifitdoesnotoverwrite channels we discuss how to lift this restriction in .
we skip all other statements as they do not pertain to communicationor concurrency.
.
.
top level procedure genequations .finally wegenerate the body of type definitions using the genfunction procedure and thus obtain a set of recursive equations as required.
algorithm gives the overall generation process.
we iterate over each type signature and therefore each ssa block to generate a type im plementationstartingwithacontext whichisinitialisedtothe identityfunctionforeachoftheparameters.thealgorithmreturns a set of possibly mutually recursive type definitions whose entry point is the program entry point e.g.
main angbracketleft angbracketright.
example .
.
consider the go program from listing and its ssa representation in figure .
the set of type definitions infered from this example is given below.
main newt0 sendfn angbracketleftt0 angbracketright recvval angbracketleftt0 angbracketright main angbracketleftt0 angbracketright main t0 main angbracketleftt0 angbracketright main t0 closet0 main t0 main angbracketleftt0 angbracketright main angbracketleftt0 angbracketright sendfn c c recvval c c 0note that the spawning of the goroutine sendfn ch becomes a parallelcompositionof the main thread with sendfn angbracketleftt0 angbracketright.
example .
.
consider the go program from listing and its ssa representation in figure .
its inferred type definitions are given below.
myselect c binampersand braceleftbig c myselect angbracketleftc angbracketright myselect angbracketleftc angbracketright myselect angbracketleftc angbracketright myselect angbracketleftc angbracketright myselect angbracketleftc angbracketright myselect angbracketleftc angbracketright bracerightbig myselect i c fori myselect c myselect angbracketleftc angbracketright myselect angbracketleftc angbracketright the type s entry point is myselect c andmyselect t0 is unused.
note how each branch of the select consists of the sequential compositionofaguard atypefunctioncallcorrespondingtothe body of the branch and a call to the continuation myselect angbracketleftt0 angbracketright.
model checking behavioural types we present our model checking based analysis of the finite control fragmentofbehaviouraltypes.weproceedinthreesteps we generate a finite labelled transition system lts for the types fromasetofoperationalsemanticsrules wedefinepropertiesof thestatesoftheltsintermsoftheimmediateactionsbehavioural types can take and we give safety and liveness properties expressed in the modal calculus .
the notionof finitecontrol hasseveral definitionsin theliterature butisgenerallyunderstoodtorefertohaving finitely manyreachablestates possiblyup tosomeequivalencerelation .
here we adopt the definition of finite control used by the mcrl2 toolchain typescannotfeatureparallelcompositionorchannel creation operators under recursion which is a sufficient condition to guarantee a finite state space.
for instance types of the form t x t angbracketleft x angbracketright tort x newa t angbracketlefta angbracketrightarenotfinite control as the formergeneratesinfinitelymanyinstancesoftype t x whilethe latter generatesinfinitely manychannels.
semantics of types.
before proceeding to step i.e.
the generationofalabelledtransitionsystem lts frombehavioural types we introduce the semantics of types.
the semantics follows standard definitions from ccs and csp accounting for the constructs that are specific to the go programming language.
the labels ranged over by and have the form colonequala a a cloa cloa a a a and theirmeaning is given in table .
we assume types are in normal form with all channel creations at the outermost top level.
in a finite control setting we can always soundly rewrite types to satisfy this normal form using the equivalences defined in figure .
thus a program s type is always of the form ti yi ti i iin newn0a0 ... newnkak t0 angbracketleft angbracketright wheretheseveral ticontainnochannelcreations.wealsomake use of the following transition which initialises all the channels accordingly and write afor theset of all initialised channels ti yi ti i iin newn0a0 ... newnkak t0 angbracketleft angbracketright ti yi ti i iin t0 angbracketleft angbracketright a0 n0 ... ak nk authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden julienlange nicholasng bernardo toninho and nobuko yoshida a ta ta ta t t t closea tcloa t a n kcloa a a a a i t1 t2 ti j tj j tjj i binampersand i ti i i j tj t t prime t s t prime st t prime t s t prime s0 s s a a a t t primes s prime a a t s a t prime s prime t t primet t prime prime t prime t prime primet a x t primet x t t angbracketleft a angbracketright t prime tcloa t primescloa s prime t s t prime s primek n a n k a a n k 1k a n ka a n k figure semantics of types.
t tt s s tt t prime s t t prime s t tt t prime t t prime newna newmb t newmb newna t newna newna a newna a n k t newna s newna t s a nelementfn t figure structural congruence for types.
we give the semantic rules for behavioural types in figure adapted from wheret t primedenotes that treduces to t prime by producing according to the rules in figure .
in the first line therulesrespectivelymodelsend receiveandsilentactions.
inthesecondline therulesrespectivelymodelcloseactions the closure of channel aand a closed buffer sending default values.
in the third line the rules respectively model a silent transition representing an internalchoice and an externalchoice.
the fourth line gives the standard rules for parallel and general sequencing.
the rule in the fifth line models the synchronisation between a type or buffer firing a send like action i.e.
a send action a closed buffer oranon emptyasynchronousbuffer andareceiveactionor a non full buffer.
the sixth line gives standard rules to deal with equivalenceandunfoldingofdefinitioncalls.intheseventhline the rules respectively model the synchronisation of a type and a buffer atoeffectivelyclose a andtheactionofadding resp.removing an elementin resp.from abuffer where nisthecapacityofthequeue andkis the number of messages currently stored in the queue.
we have omitted symmetric rules for parallel and synchronisations.
in step given a finite control type in normal form we construct afinitelabelled transition system which represents allpossible executions of t0 angbracketleft angbracketright i.e.
the entry point type under all the name restrictions.theltsof t0 angbracketleft angbracketrightisatuple t s t0 angbracketleft angbracketright a suchthat sis a set of states implicitly labelled by behavioural type terms we often identify labels and states t0 angbracketleft angbracketright sis the initial state table predicate labels a a send receive on channel a a synchronisationover a silent action cloa cloarequest to close a closinga a channelais closed a a push pop on buffer a o waiting to synchronise over the actions in o a t aclosea t cloa a t aa a i ... n i oi binampersand i t i ... n o1...on t o t t prime ot at prime aort prime a t t prime at a x ot x t t angbracketleft a angbracketright o t a i a t binampersand i si i i at aort a i a t binampersand i si i i a k n a n k ak a n k a t at prime a t t prime at a i a t binampersand i si i i a t o t t prime ot oa nelementfn o newna t ot ot t prime t o figure barb predicates for types.
a a a a is the set of labels and s a sis the transition relation t t primewhere the label can be either a silent move i.e.
or a synchronisation over a channel e.g.
a. propertiesofbehaviouraltypestates.
instep wedefine predicates over the state labels of the lts defined above.
thisallows us to analyse what actions a given state or type can fireimmediately.
concretely we define a family of predicates of the formt oort owhichholdsif tisreadytofireaction oorone of the actions in o witho oi a a a cloa a a a .
table explains the meaning of each label and figure gives the defining rules of the predicates t oandt o. essentially t oiftis immediatelyreadytofireaction o witho nequal andt oiftcontains anexternalchoicewhichdoesnotfeatureabranchguardedby i.e.
nelement o .
we have e.g.
t o for anyoand binampersand t1 a t2 o for any o which is an important subtlety for defining accurate safety and liveness properties.
liveness and safety properties.
in step we encode liveness and channel properties including those discussed in .
in the calculus extended with the atomic propositions on state labels defined in step .
a calculusformula isinterpretedonapointedlts i.e.
an lts with a starting state t we write t t iftsatisfies in the ltst.
namely formula latticetopholds for every t while never holds .theconstruct isamodaloperatorthatissatisfiedif for each derivative t primeoft i.e.t primeisreachablefrom tbyperforming action the formula holds int prime.
the dual modality is angbracketleft angbracketright which holds if there is an derivative t primeoftsuch that holds int prime.
construct x. resp.
x. is the standard greatest resp.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a static verification framework for message passing in go using behavioural types icse may june gothenburg sweden def x. x def y. angbracketlefta angbracketrighty tdef angbracketlefta angbracketright latticetop cdef y. y def logicalandtext.
a a a a angbracketlefta angbracketright latticetop ladef logicalandtext.
a a a a angbracketleft a angbracketright latticetop lbdef logicalandtext.
a p a a angbracketleft a a a angbracketright latticetop sdef logicalandtext.
a a a a cloa edef logicalandtext.
a a a angbracketleft a angbracketright latticetop figure calculusformulae.
smallest fixpointoperator binding xin .theatomicproposition o resp.
o holdsiff t o resp.t o .givenasetofactions a a we write for logicalandtext.
a and angbracketlefta angbracketright for logicalortext.
a angbracketleft angbracketright .
we now describe several properties which can be verified using the model checker mcrl2 .
below we refer to the formulae giveninfigure8.givena calculusformula formula holds if holds for all reachable states while formula holds if holdsinsomereachablestate.formula t holdsif no terminal stateis reachable in t i.e.
the behavioural types only exhibit infiniteexecutions duallyformula choldsifthereare no cycles int this property is useful as it implies that liveness of types correspondswithlivenessofprograms cf.
.
.formula parenleftbig parenrightbig modelsthe global deadlock freedom propertydiscussedin .
i.e.
the formula holds if for each state tintiftis ready to executeasendorreceiveaction then thasasuccessor.formula parenleftbig la lb parenrightbig models the livenessproperty cf.
.
.
it holds if for all state tint i i ftis ready to send receive on a there is alwayseventuallyasynchronisationon a cf.
la and ii ifthasa selectconstruct whichdoesnotcontaina branch thereisalways eventually a synchronisation over one of the channels guarding the construct cf.
lb .
formula s models the channel safety property i.e.
no send nor close action is executed on a channel that is already closed.
formula e models eventual reception whichguarantees that when a channel is not empty the head of its buffercan eventually be consumed.
implementation wepresentthe godelchecker toolchainoffigure2whichconsists of two core components an inference tool and a type verifier.
inference tool.
the type inference tool implements the core algorithmsdescribedin withadditionaladjustmentstosupport analysisof real world go programs which we discuss below.uninitialised channels uninitialised channels or nil channels can be used in go but they always block on communication.
to modelthisbehaviour weprefixanycommunicationonanuninitialised channel with a newa construct with afresh .
composite data structures our tool supports channels that are storedin structsbyflattening suchconstructsintoseveralchannels.
we only support structures that store finitely many channels e.g.
arrays or linked list of channels are not supported .uniform representation of functions auniformrepresentation ofcallableobjectsisusedasanabstractionwhenobtainingthetype signature of an ssa block.
this allows us to support return values and closures by uniformly converting return values and closure bindingas additional function parameters.
channels in phi instructions we support ssa instructions to merge control flow phi when they refer to channels by adding a parameter to the type definition of its enclosing block and modifying functioncalls accordingly.
type verifier.
the type verifier transforms the inferred behaviouraltypesintoanltsandpropertiesinto calculusformulae followingthemethodologyin 4forthe mcrl2modelchecker and also into input for the kittelterminationanalyser.
model checking once a behavioural type has been inferred from go source code we translate it straightforwardly to the mcrl2 language .beforegeneratingthe calculusformulaedescribed in we analyse the model so to build the smallest formulae possible.finally werunthe mcrl2modelcheckerforeachformula and return the result to the user.
termination checking to address the mismatch between types and programs detailed in .
we deploy a termination analysis of loops usingthe kittelterminationanalyser .thetooltargets cprogramsandisbasedonintegertermrewriting.thechoiceof this particular analyser amounts to the syntax of go being close to c its usability and performance.
theanalysistakesadvantageoftheinferenceprocedureof to collect the locations and parameters of loops in a given program whicharethencheckedfortermination.ouranalysischecks that the loop parameters are enough to make each loop eventually terminate regardless of the non loop code within the loop itself.
this enables us to pinpoint program locations where liveness of types may not entail the analogue property in the program if the termination analysis identifies the program as terminating the liveness properties on types and programs coincide .
the analysis generates all loops in the original go program as a setofcfunctions ignoringallothergostatements.eachcfunction and thus each loop is then individually checked fortermination.
sinceloopscanbenested ouranalysistakesthisintoaccountby replicatingthenestinginthegeneratedcfunctions.forinstance for the followingcode snippet 1funcf nint fori i n i forj j j ... ourtoolgeneratesasinglecfunction fcontainingthetwoloops.
staticallyunknown valuesin loopparameters e.g.
theparameter n offunction fabove aregeneratedasparametersoftherespectivec functions.thisforcestheterminationcheckertoverifytermination for allpossible values of the unknown parameter.
such values can appearduetousagesoffunctionarguments valuescontainedin dynamic data structures or communicated data.
our analysis relies on the following loops in go programs generatetypeswithconditionalbranchingcombinedwithrecursion most programs use traditional imperative control flow features such as for loops for range loops i.e.
loops over a fixed finite data structure andfor selectloops i.e.aninfiniteloopwitha select authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june3 gothenburg sweden julienlange nicholasng bernardo toninho and nobuko yoshida table go programs verified by our framework and comparison with existing static deadlock detection tools.
godel checker dingo hunter gopherlyzer goinfer gong programs loc states l s einfer live live cs term live timedf timelive cs time 1mismatch check check .
.
.
check .
.
check616.
2fixed check check check check .
.
.
check check .
check .
check check .
3fanin check check check check .
.
.
check check .
check .
check check .
4sieve n a n an a n a check check .
5philo check check .
.
.
check .
.
check .
6dinephil3 check check check check .
.
.
checkn a n a check check .
min 7starvephil3 check check .
.
.
checkn a n a check3.
min 8sel check check .
.
.
check .
.
check .
9selfixed check check check check .
.
.
check check .
check .
check check .
10jobsched check check check check .
.
.
checkn a check .
check check .
11forselect check check check check .
.
.
check check .8n a check check .
12cond recur check check check check .
.
.
check check .4n a check check .
13concsys check check .
.
.
checkn a .
check521.
14alt bit check check check check .
.
.
checkn a n a check check .
15prod cons check check check .
.
.
check .
.
check .
16nonlive check check check check .
.
.
timeout .6n a check613.
17double close check check check3.
.
.
check squaremultiply .
squaremultiply .
check .
18stuckmsg check check check .
.
.
checkn a n a check check .
19dinephil5 1m check check check check .
.
sec .
sec checkn a n a timeout hrs 20prod3 cons3 check check check check .
.
sec .
sec checkn a n a timeout hrs 21async prod cons check check check check .
.
sec .
sec checkn a n a timeout hrs 22astranet 18k1160 check check check check .
.
sec .
sec checkn a n a n a column cs channel safe term termination check df deadlock free timeout termination check timeout likely does not terminate squaremultiply false alarm undetected liveness error.
thatcanbreaktheloop the consumer functionoffigure1 instead of recursion we assume that loop indices are not modified in loop bodies and that no goto likeconstructsare used in a loop.
since the analysis only takes into account loop parameters a loopthatindefinitelyblocks e.g.duetocommunication maybe identified as terminating.
however if our analysis identifies the inferredtypesaslive andtheterminationcheckvalidatestheprogram both termination and program liveness are guaranteed.
evaluation table lists several benchmarks of our tool against other static deadlock detection tools for go a detailed comparison of these tools is given in .
the benchmarks were run with go1.
.
on an core intel i7 machine with 16gb ram on a bit linux.
the model checker we used was mcrl2 v201707.
.
the results for godel checker are shown in columns .
column4showsthenumberofstatesintheinputltsasameasurementoftherelativecomplexityofeachprogram proportionaltothe number of concurrency related operations rather than the number of lines of code .
columns shows the core formulae of figure in i.e.
no global deadlock liveness l channel safety s and eventual reception e .
a checkmark means thatthe considered tool reports that the property holds.
for example in the case of godelchecker a checkmarkundercolumn meansthattheformula parenleftbig parenrightbigevaluates to true.
in the case of goinfer gong a checkmark undercolumn livemeansthatthetoolreportstheprogramtobe live as defined in .
a mark indicates that the considered tool reports that the property in question does not hold.
columns list the running time of godelchecker where column lists the inferencetime columns10and11arethemodelcheckingtimes forliveness andbothlivenessandchannelsafety respectively.the totalruntimecanbeobtainedbyaddingcolumn9tocolumn10or .unlessotherwisestated alltimesareinmilliseconds.column12 term shows the result of the termination check which proves theterminationofloopsinthegivenprogram ortimesoutafter 15s.
a program that times out is conservatively assumed not to terminate.
columns pertain to the dingo hunter tool from .
the time includes both communicating finite state machine extraction and their analysis but does not include building the global graphand only checks for liveness.
columns pertain to the gopherlyzer tool which only checks for global deadlockfreedom mostprogramshadtobemanuallyadjustedinordertobeacceptedbythistool see 7fortheseverepracticallimitationsof thetool .columns17 19refertothe goinfer gong toolfrom .
thetimesincludebothtypeinferenceandanalysisstages which only accounts for liveness and channel safety checks.
most pro gramsintable3aretakeneitherfromotherpapersonthestatic verificationofgoprograms orfrompubliclyavailable source code.
programs and are benchmarks introduced by this work.
programs that are unsupported by a tool are marked withn a. table includes all the benchmarks from previous works exceptfor3non finitecontrolexamplesfrom whichourtool cannotanalyse i.e.
like sieve andhtcatfrom whichismanually transformed to be supported by dingo hunter .
programs1 7aretypicalconcurrentprogramsfromtheliterature.
the sieveprogram is not finite control it spawns an infinite numberofthreads thusitcanonlybeanalysedby goinfer gong .
program is a three dining philosophers program where the first forkcanbereleased whileprogram7isthetraditionaldeadlockingversion program19isasprogram6butwith5philosophers .
dingo hunter does not support programs and due to dynamicallyspawnedgoroutines while gopherlyzer doesnotsupportthemduetoanestedselectstatement.
goinfer gong analyses themcorrectly but is much slower than godelchecker .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a static verification framework for message passing in go using behavioural types icse may june gothenburg sweden programs consist of idiomatic go patterns which are all handled correctly and quickly by our tool.
program is a publicly available program which is not live.
program is an implementationofthealternatingbitprotocol.program15istheproducerconsumerexamplefrom whichisnotlive.alltoolswereableto verifythissimpleprogram.program16demonstratesthemismatch between type and program liveness where the type is live but due to an erroneous loop the program does not terminate and causes a partial deadlock.the termination check identifiesthis as possibly non terminating while goinfer gong incorrectly identifies it as live.program17closesachanneltwicewhichflagsaviolationof channelsafetyin godelchecker andgoinfer gong .interestingly dingo hunter detects a deadlock a false alarm due to its representation of channel closure as a message exchange but not due to thedoubleclose.
gopherlyzer alsodetectsadeadlockincorrectly due to the samereason.
program is a program that violatesthe eventual reception property bysendingan asynchronousmessage thatis never received none of the earlier tools can detect this.
programs demonstrate the scalability of our approach.
program22isaconcurrentdatastreammultiplexer forhandling multipleindependentdatastreamsinasingletcpconnection.it consists of 16k lines of code of which only a small portion relate to concurrency which is the case with common concurrent go applications .
the program is not natively finite control since it spawnsrequesthandlersasgoroutinesinaloop.notingthatrequest handlers do not interact with each other we modified the program to handle requests sequentially and enable our analysis.
we note that while the execution time for small programs is slightly higher than the other tools but still under seconds godel checker is amore general toolsince it canverify arbitrary propertiesexpressibleinthe calculusandourpreciseinference allows us to reduce both the false alarms and crucially undetected liveness errors .
the verification times also suffer from the initialisation of mcrl2 the tool uses binaries .
in small programs the running times are generally dominated by this fact which is the reason why the times are quite similar.
this is amortised in programswithlargestatespaces cf.secondpartoftable3 wherethe efficiency of mcrl2produces gains of several orders of magnitude overgopherlyzer andgoinfer gong whileperformingmoredetailed analyses.
we note that a significant portion of the inference time is due to the translation into ssa by the ssapackage.
limitations.
asexplainedin ourinferencedoesnotsupport channelvariableoverwriting i.e.
weonlysupport immutable channel variables.
in addition it does not support channels in dynamic datastructures suchasarrays slices variablesizedarrays and dictionaries or recursively defined data structures e.g.
linked lists .however ourtoolensuresthatsuchdatastructuresdonot containchannelsandcanbesafelyignored signallinganerrorotherwise.
we also require channel buffer sizes to be statically known.
while the inference is agnostic to the finite control limitation of themodelcheckingtool ifatypeisinferredsuccessfully itmust be finite control in order for our type verifier to produce an output.
we note that these limitations are also present in the other tools mentioned in this section goinfer gong supports infinite state systemsby performing a bounded verification .
related work and conclusion applyingprogramanalysestoreal worldsoftware.
theerrorprone nature of concurrent software has led to a plethora of works on automated verification of concurrency via program analysis.
however these works mostly target lock based concurrency such as those based on java pathfinder or abstract interpretation and so are of a fundamentally different nature than ourwork targetting message based concurrency in go.
verification of go programs.
despite the young age of go it has received some attention from the research community.
the workof istothebestofourknowledgethefirsttotacklestatic verification of go programs.
their work uses multiparty session types andtheirconnectiontocommunicatingautomata tocheckforlivenessingobyextractingcommunicatingfinitestate machinesfromsourcecode.however theirworkcannotsupport dynamic spawning of goroutines requiring all goroutines to be executing before any communication takes place nor asynchrony.
this severely limitsthe applicability of their work.their analysis alsodoesnotcovermanyfeaturesofgowhichresultsincrashesin theanalysis such as phiinstructionsand uninitialised channels.
using a form of regular expressions with a fork construct the workof capturesthreadspawningin synchronous goprograms.
theiranalysisisextremelylimited itdoesnotsupportasynchrony closingchannelsnorselectivecommunicationwithnon trivialcase bodies.moreover theirworkusesthe gurutooltomanuallyobtain aliasinginformationinordertoidentifychannels andassumesthat allfunctionscanbeinlined.asaresult theirtoolfailstoanalyse programs that cannot be trivially inlined e.g.
programs with aliasedchannelorrepeatedusagesofthesamefunction ruling outmost usefulprograms.
ourpreviouswork infersbehaviouraltypesfromgocode whicharechecked forliveness andsafety properties using a techniqueakintoboundedsymbolicexecution.the goinfer gong tool explicitlyexecutesthetypeltswhichhasscalabilityissueswith large state spaces see and is specialised for liveness and channelsafety whereasourtoolcancheckforamuchwiderrangeof propertiesofinterest ingeneralwecanverifyanypropertythat can be represented as a calculus formula .
the type inference of whichwasnotformaliseduntilthiswork didnothavefull support for closures nor general sequencing needed to accurately represent most imperative programming patterns.behaviouraltypes.
there is a vast body of work on behavioural typesforconcurrency see forgeneralsurveys .themain contrast between our work and most of those in is that we usebehaviouraltypes asa componentin alarger analysisthat can automatically check for a range of safety and liveness properties instead of focusing solely on forms of deadlock freedom.
the work proposes a framework combining a behavioural type analysis with model checking.
their work uses the calculus as a source language and extracts ccs like behavioural types based on whichcanthenbecheckedforpropertieswrittenasanltl formula.themainlimitationoftheirworkistherequirementof explicittypeannotationsinprocesses.moreover itisnotclearhow to represent our notions of global and partial deadlock freedom as well as channel safety as a general ltl formula.
ltl formulas can use always and eventually modalities to describe reachable authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may27 june gothenburg sweden julienlange nicholasng bernardo toninho and nobuko yoshida states but cannotmentionspecific communicationactions which requires non obvious encodings.
note that most previous works aredevelopedinthecontextofprocesscalculiandarenot applicableto a general purpose language.
concludingremarks.
we have presented a static verification frameworkforchannel basedconcurrencyingowhichwehaveimplementedinthe godel checker tool.asshownin ourinference procedure allows us to accurately cover a broader classof go programs without the need for annotations or significant user input.
by integrating our approach with a general purpose modelchecker weareabletomodularlyverifyarbitrarysafetyandlivenessproperties.comparedtootherexistingtools ourapproach providessignificantlybetterperformanceforlargerprograms verifyingmorepropertiesandwithbetteroutcomesintermsofboth false alarms and crucially undetected liveness errors.
given the general nature of our inference procedure our framework is not necessarily limited to mcrl2 nor model checking techniques in general.
for future work we plan to use other process calculi verification techniques such as as well as other model checkersforconcurrencysuchas .also thegeneralideaforour inference canin principlebe applied toother concurrency centric languagesthatrelyonsomeformofssa likeintermediaterepresentation.
we plan to apply our techniques to the erlang language via thecoreerlang intermediaterepresentation.wealsoplantoaddresstheopencl2.0heterogeneousprogrammingframework which provides pipeobjects akin to go channels that are used for inter kernelcommunicationsand are prone to deadlocks.