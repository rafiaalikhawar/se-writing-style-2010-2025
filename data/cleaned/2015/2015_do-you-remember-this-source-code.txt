do you remember this source code?
jacob kr ger harz university of applied sciences otto von guericke university wernigerode magdeburg germany jkrueger ovgu.dejens wiemann otto von guericke university magdeburg germanywolfram fenske otto von guericke university magdeburg germany wfenske ovgu.de gunter saake otto von guericke university magdeburg germany saake ovgu.dethomas leich harz university of applied sciences metop gmbh wernigerode magdeburg germany tleich hs harz.de abstract beingfamiliarwiththesourcecodeofaprogramcomprisesknowledge about its purpose structure and details.
consequently familiarity is an important factor in many contexts of software development especially for maintenance and program comprehension.
as a result familiarity is considered to some extent in many different approaches for example to model costs or to identify experts.
still all approaches we are aware of require a manual assessment of familiarityandempiricalanalysesof forgetting insoftwaredevelopment are missing.
in this paper we address this issue with an empiricalstudythatweconductedwith60open sourcedevelopers.
we usedasurveyto receiveinformationon thedevelopers familiarityandanalyzetheresponsesbasedondataweextractfromtheir usedversioncontrolsystems.theresultsshowthatforgettingisan importantfactorwhenconsideringfamiliarityandprogramcomprehension of developers.
we find that a forgetting curve is partly applicableforsoftwaredevelopment investigatethreefactors the number of edits ratio of owned code and tracking behavior that can impact familiarity with code and derive a general memory strength for our participants.
our findings can be used to scope approachesthathavetoconsiderfamiliarityandtheyprovideinsights into forgetting in the context of software development.
ccs concepts generalandreference empiricalstudies softwareand its engineering maintaining software risk management applied computing psychology keywords familiarity forgetting empiricalstudy maintenance programcomprehension expert identification knowledge management permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
reference format jacob kr ger jens wiemann wolfram fenske gunter saake and thomas leich.
.
do you remember this source code?.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm newyork ny usa 12pages.
.
.
introduction developers familiarity or expertise with a project s context comprising programs and colleagues is an essential factor for many aspects of software engineering such as team and task performance knowledge sharing and tool acceptance .
considering the software itself familiarity influences how fast and reliable developers can comprehend enhance and maintain a program for instance to locate and fixbugs or for reengineering .
consequently software familiarity comprising the knowledge on a programs source code design and usage facilitates maintenance tasks .
especially asmaintainingsoftwareisthemaincostdriverinsoftwaredevelopment comprehending and familiarizing with a program is essential .
for this reason familiarity is considered asanimportantfactorinmanycostestimationapproaches and identifying experts for a piece of code receives much attention .
whileteamfamiliarityhasbeeninvestigatedextensively lessresearchfocusesonanalyzingsoftwarefamiliarity.the mainissueinthiscontextaredevelopersforgettingdetailsabout theirsourcecode complicatingsoftwaredevelopmentandmaintenance .
toaddress this issue approaches on program comprehension aim to support developers in regaining their familiarity.
several approaches such as clean code guidelines o r suitable identifier names have been analyzed and proposedtoimprovethecomprehensionofsourcecode .however atthis pointfamiliarity mustalreadybe regained .assessing howfamiliaradeveloperstilliswiththesourcecodeisessential forexample toassigntasks toidentifyexperts or consequently to reduce and estimate costs.
inthispaper weproposetoadoptforgettingcurves fromthepsychologicaldomainforsoftwareengineering.forthis purpose weutilizetheforgettingcurveproposedbyebbinghaus and test its applicability for software engineering.
thus the main focus of our work is an empirical study that we conducted acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden j. kr ger et al.
with open source developers from github projects.
they participated in an online survey in which they for example approximatedtheirownfamiliaritywithaspecificfile.basedontheir responses and data from their commits we investigate three factors namely the number of repeated edits ratio of own code and tracking behavior that may affect their familiarity derive an average memory strength and test the aforementioned forgetting curve.ourfindingshelptounderstandhowdevelopersforgetdetailsabouttheirsourcecodeandhowtoestimatetheirremaining familiarity.theresultscansupportmanyapproachesinsoftware engineering forexample toallocatedeveloperstotaskstheyare most efficient on to identifyexperts and to search for knowledge gaps in a project.
moreover reliable familiarity estimations can improvetheaccuracyofcostmodels.indetail wecontributethe following in this paper wereportanempiricalstudythatweconductedasanonline survey.
based on responses with open source developers we investigate the importance of repetition ratio of own code andcodetrackingontheirfamiliarity.theresultsindi cate moderate to strong correlations for the first two factors.
surprisingly we find no correlation between familiarity and tracking for our participants.
weidentifyanaveragememorystrengthforourparticipantsasacrucialfactortoapproximateforgetting.whilethisvalue needs to be refined in the future it provides hints at how fastdevelopersmayforgettheircodeandonthereliability ofself assessments.
also researchersand practitionerscanuse this value as baseline for further research.
we test if ebbinghaus forgetting curve is applicable in software engineering.
for this purpose we analyze whichof the investigated factors distort the standard course ofthe curve.
the results show that different factors need tobe considered before the forgetting curve can be fully applied.nonetheless ifthesefactorsarenoteffective thecurve actually fits well to the responses of our participants.
overall weaimatanalyzingtheeffectsofforgettingtoderiveapproaches to automatically measure or improve software familiarity in future research.
background in this section we introduce background information on familiarityandforgetting curves.
both concepts are essential for the understanding of this paper.
.
familiarity familiarity comprises knowledge persons gain on different aspectsof their daily work and about their team members.
over time they becomefamiliarwiththeirdomainandeachother improvinginteractions implementing a knowledge base and supporting the identificationofexpertise .thus studiesshowpositiveeffects of familiarity on for example team performance in flight simulations problem solving and several other tasks .
insoftwaredevelopment thisfamiliarityfocusesonaspecific program and the developing team.
while it is an important factor wearenotawareofdetailedanalysesandmeasurementsofa developer sfamiliaritywithaprogram.forexample boehmetal .
figure forgetting curves of ebbinghaus for memory strengths s of and .
introduceascaletomeasureunfamiliarityforcostestimations with the cocomo ii model and its extensions .
the proposed scale ranges from to representing completely familiar andcompletely unfamiliar respectively.
still the actual value must be judged by a user.
in the context of this work we are focusing on a developer s familiaritywithaprogram.this softwarefamiliarity istheresult of studying and working with a program leading to knowledge aboutthepurpose usage andstructure forexampleofafile.we are aware that several terms exist that are closely related used synonymously andsometimesmaybeinterpretedinthesameway for instance comprehension knowledge learning expertise or experience.
however we rely on the term familiarity in this paper as it subsumes such meanings.
.
forgetting familiarityisnoconsistentstate itcanbegainedbutalsofadesover time.
the main reason for becoming unfamiliar with a program is that weforgetdetails about it.
consequently over time developers becomelessfamiliarwiththeircodeandneedmoreefforttoregain the necessary familiarity to work on it.
this forgetting process basicallyrepresentstheoppositeand thus isstronglyconnected to learning .
in psychology different forgetting models and curves exist .
we rely on the forgetting curve described by ebbinghaus .
while it is rather old studies show that it can be replicated and performs similar to other curves .
in the contextofthiswork theremainingmemorycalculatedwiththis curve represents the developers familiarity.
ebbinghaus describesanexponentialnatureofforgetting as we display in equation .
r e t s authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
do you remember this source code?
icse may june gothenburg sweden here rrepresentstheresultingmemoryretentionrate.therelative memory strength of the considered subject is defined by sandt isthetime indays betweenstudyinganartifactandtestingthe subject s memory.
to exemplify this function we display curves forthreedifferentmemorystrengthsinfigure1.aswecansee a highermemorystrengthresultsinaslowerretentionrate meaning that the familiarity remains for a longer time.
for example with a memory strength of s solid red line in figure after the firstdayonly37 ofthefamiliarityremains.incontrast amemory strengthof s dottedblacklineinfigure1 indicatesthatthe same value is reached only after three days.
this memory strength is individualfor eachperson anddepends onseveral factors such as learning effects and the considered artifact.
problem statement inseveralscientificandindustrialdomainsitisessentialtoconsider the familiarity of software developers with the code they work on.therearemultiplefactorsthatinfluencehowfastdevelopers forget and thus loose familiarity with a program.
consider the followingexamplewithtwodevelopers aandb atfirst developer a implements a file and at the point of creation is most likely completelyfamiliarwithit.however whenhestopsworkingonthe file for some time his familiarity decreases potentially resembling a forgetting curve by ebbinghaus as we depict in figure .
additionally developer b changes the file for example to add new functionsorremovebugs.here twootherfactorsbesidesforgetting apply developer b has to understand the existing code at least far enough to change it and thus gains familiarity.
he could even gain100 familiarityifhewouldinvestigateeverydetailofthefile.
in contrast the familiarity of developer a is negatively affectedbecause he also has to analyze the new implementation at somepoint.
any further change results in the same effects and in one developer loosing familiarity while the other may gain it.
this example raises several questions regarding the impact of code changes on a developer s familiarity for example is a forgetting curve appropriate for software developers?
how fast do software developers actually forget their source code?
do repeated commits improvethememorystrength?
howdochangesofotherdevelopersim pactfamiliarity?
howmanychangesofothersdodevelopersanalyze?
whichothertasks suchas reviewingortesting affectfamiliarity?
in this work we focus on a subset of these questions.
namely we investigatetheapplicabilityofebbinghaus forgettingcurve on software developers their average memory strength and if repetitions the ratio of own code or observing others changes on ownfilesaffectfamiliarity.despiteourfocusonthesefactors all stated questions are important future work.
the resulting findings can be used to derive approaches for measuring familiarity and to improve our understating of software engineering activities.
tothisend wederivethefollowingthreescenariosthataffect familiarity based on our example sc1forget over time developers lose knowledge and become less familiarwithsourcecodetheyworkedon.thus theycannot recall all details anymore and need time to regain familiarity.
sc2gain developerswhoeditsourcecode forinstance byadding modifying or removing lines aim to understand already existing code in addition to their newly written code.
thus theygainorregainfamiliarity duetoanalyzingexistingsourcecode either someone else s or their own.
sc3unaware ifanotherdevelopereditssourcecode theoriginal author is unlikely to review the modifications until it is necessary.forthisreason thefamiliarityofadeveloperdecreases withanyeditanotheroneapplies duetohisunawarenessof the modification.
in the remaining paper we refer to these scenarios to describe which aspects of familiarity we address with our analysis.
survey design to address the aforementioned questions we conducted an online survey.inthissection wedescribeour researchquestions survey setup and subjects.
.
research questions the goal of our survey is to provide insights into software familiarity and especially on factors that preserve it.
thus we aim to answer the following research questions rq1do the factors repetition ratio of own code or change tracking affect a developer s familiarity?
there are many factors that can affect a developer s familiarity of which we investigate three firstly we hypothesize that repeatedly working on the same code refreshes famil iarity sc and improves capabilities to remember details due to learning effects sc .
based on the results of glenberg weexpectamonotonicallyrisingdependency.secondly developers should also be more familiar with a file if they wrote a larger ratio of it sc .
finally we analyze whether our participants track changes sc of other developers on their files and if this affects their familiarity.
answering this researchquestionwillcontributeempiricalfindingsregarding the influence of these factors on software familiarity.
rq2what is the average memory strength of a developerregarding the source code?
as we described in section the memory strength is necessarytoestimatehowfastforgettingproceeds sc .thus our results help to approximate how long developers remembercode supportingcorrespondingestimations.weremark that this factor is heavily impacted by individuals characteristicsandcanalso betrained.consequently therecanbe considerable outliers for a specific developer.
rq3is ebinghaus forgetting curve applicable for softwaredevelopers?in theend weaim toassess theapplicability ofebbinghaus forgettingcurveinsoftwaredevelopment.forthispurpose we compare the self evaluations of our participants withcomputedvalues.the outcomehelpstodesignfurther research forexample toautomaticallymeasurefamiliarity or improve approaches that are based on it.
overall answering these questions helps research and industry aliketoanalyze understand andimprovesoftwaredevelopment.
ourfindingssupportmanyresearchareas suchas costestimation knowledge management teaching programming expert identification and reengineering.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden j. kr ger et al.
.
survey setup for the general setup of our study we decided to perform an onlinesurvey.asanintroducingpartofthesurveyweprovidedthe followingshortintroductionoffamiliaritytoavoidconfusionon this term softwarefamiliarity generallyknownasaresultofstudyor experience.iffamiliar youknow thepurposeofafile itsusage across the project and its structure or programming patterns.
weaskedtoinsertthegithubusernameormailaddresstoprevent multiple responses from the same developer and to track their commits.furthermore alldevelopershadtospecifyonefileoftheir project they had been working with.
here we especially asked them not to check this file before participating.
we used several questions of which the following are of interest for this work.
howwelldoyouknowthecontentofthefile?
forthisquestion thedevelopershavetoassesshowfamiliartheyarewiththe file they specified before.
here they can rate their familiarity on a likertscalefrom1 i.e.
barelythepurpose to9 i.e.
purpose usage and structure which represents percentages.
we do not allow a rating of as the developer of a file should have at least some knowledgeaboutit.furthermore weassumethatparticipantsdo not knowall details e.g.
eachline of thecode evenif theydeveloped it and thus we do not allow a .
we use the answers for all our research questions as they provide the basis for our analysis.
afterhowmanydaysdoyouonlyrememberthestructure and purpose of a file but have forgotten the details?
in this case theparticipantshavetoestimateafterhowmanydaysthey wouldstillhavearemainingfamiliarityof5 i.e.
itspurposeand usage .
while this is a challenging estimation we use the answers to validate our calculations for the second research question.
howwelldoyoutrackchangesotherdevelopersmakeon yourfiles?
thisquestionaddressesourfirstresearchquestion.we canextractvaluesforrepetitionsbasedoncommitsandtheratioofowncodebasedonafile shistory.incontrast wehavetopersonally ask our participants whether they track changes that others do on theirfiles.tothisend weusealikertscalerangingfrom0 i.e.
no tracking at all to i.e.
analyzing each change .
how many lines of code does the file contain?
weaskthis questiontovalidatewhethertheparticipantsrememberthecorrect fileorarejusttoounfamiliarwithit.here weexcluderesponses with a high error rate as we describe in the next section.
when was the last date you edited the file?
again we use this question to validate the participants responses.
a high deviation from the real date of the last edit may indicate missing motivation or a wrong file being remembered.
thus we also exclude such responses from our analysis.
.
subjects as we aimed to use data from version control systems to answer our research questions we considered the ten github projects we display in table .
we varied our selection to consider different developmentapproachesandtoincreasetheresponserate wherefore we included projects with different attributes firstly we searched for actively developed and popular projects from which we invited all developers that edited a file in .
secondly we varied thetable projects considered for the survey.
project languagedevelopers inv.
resp.
incl.
aframe javascript 4angular.js javascript 7astropy python 7ember.js javascript 3featureide java 4ipython python 3odoo python 10react javascript 4serverless javascript 11sympy python overall inv invited resp.
responded incl.
included programminglanguageandteamsizetoconsiderdifferentdevelopment styles.
finally we considered some scientificprojects for example astropy as research shows that response rates for these are higher .
each active developer received a mail containing a link to our survey.
to consider the quality of responses we define the following exclusion criteria participant did not edit the selected file as we do not ask the participants to specify a file they committed to but withwhichtheyworked 4ofthempickedonetheydidnot committo.aswecannotextractanyinformationfromthe commits we remove these responses.
last edit was more than a year ago we especially ask the participants to specify a file they worked on in .
still of them picked one that they edited only before.
we exclude these responses.
high deviation we also exclude responses where answers to the last two questions deviate by more than considering the lower bound for lines of code from the real value.
in cases this appears for the date of the last edit measured in days and in other cases for the lines of code.
as we show in table the delta between responded and included we exclude responses often due to multiple criteria.
still responses remain valid and provide the basis for our analysis.
results inthissection wedescribeforeachresearchquestiontheresults ofoursurveyanddiscussthecorrespondingimplications.wedisplay an overview of our data in table .1here we show all values grouped by the subjective familiarity sf that each participant estimated.furthermore weshowthenumberofcommitsthatwere done bythe participant c aswell as thenumber ofparticipants p thatrespondedwiththiscombinationoffamiliarityandcommits.weremark thatthecommitsactuallyrefertodistinctdays onwhichtheparticipantsubmittedatleastonecommit.otherwise we would for example consider multiple small commits of one developer more important than a larger one by another.
this way weaimtoneglectthiseffect.inaddition thenumberofparticipants 1all responses anonymous authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
do you remember this source code?
icse may june gothenburg sweden table subjective file familiarity sf assessment compared to the number of commits c and time since the last commit d .thenumberofparticipants p isexplicitanddescribeshowoftenthecorrespondingcombinationofsfand cappears.
sf1 c112 p481 d206.
.
.
sf c13 p12 d10 figure familiarity of all responses related to the time since the last commit and the number of commits circle sizes represent c .
the solid blue line displays average val ues.
the dashed red line displays the average for responses with a single commit.
isexplicit notrepresentedbythenumberofcolumns andwehave between and participants for each familiarity level.
finally we provide an overview on the average days since the last commit d based on the date on which the survey has been answered.
first we consider figure to describe the necessity for our researchquestions.here wedisplayallresponsesbyrelatingthe days since the last commit to the subjective familiarity.
each circle representsoneparticipantandthecircles sizestheabsolutenumber ofcommits.inaddition thesolidbluelineillustratestheaverage valueforallparticipants whilethedashedredlineillustratesthe average for those that committed only once.
ifweassumethatalldevelopershavethesamememorystrength and that no other factors influence how well they can remember code the average in figure should resemble the forgetting curve of ebbinghaus .
at the beginning this seems to be the case asmost participants state a high familiarity if their last commit is not farinthepast.however aroundthevalueof100dayssincethelast commit theaveragefamiliarityrises.weseeinfigure2thatthe responses with high familiarity at this point skew the curve.
overall theaveragedoesnotfollowtheforgettingcurve.also considering the peak at around days this implies two pos sibilities firstly the forgetting curve is unsuitable for software developers.secondly thereareotherfactorsbesidesthetimethat influence familiarity.
as the responses with a single commit the dashed red line in figure fit the forgetting curve better we favor thesecondoption whichmeansthatadaptationstothecurveare necessary.thismatchesourfirstandthirdresearchquestion which we investigate in the following.
.
factors impact on familiarity regarding ourfirst researchquestion we aimto identifyif thereare correlations between the subjective familiarity and the three factors repetition ratio of own code and tracking.
we support our investigationsofeachfactorwithtworankcorrelationmeasures spearman s rho rs and kendall s tau .
both areusedtoassesmonotonicdependenciesbetweentwovariables withoutassumingnormaldistribution.theresultsrangefrom to1 meaningnegativeandpositivecorrelation respectively.we apply for each measure a corresponding significance test with a confidenceintervalof0.
usingalgorithmas89 forspearman s rho and a tau test for kendall s tau as implemented in the statistical programming language r .
before investigating the mentioned factors we have to test whetherthesizeofafilecorrelatestofamiliarity.thisshouldnot bethecase aswe inaccordancewithebbinghaus forgetting curve consider each file as a single artifact and the remaining familiarity in percentages.
the statistics show no significant correlation p .
.
for completeness we still compute the effect sizes which are very weak for both measures rs .
and .
.
thus all results confirm our assumption that the file size does not correlatewiththestatedfamiliarity.wesummarizethesignificance tests and correlation measures for all factors including file size at the end of this section in table .
.
.
repetition.
asfirstfactorthatmayinfluencethedeviation betweenthetheoreticalforgettingcurvebyebbinghaus and the empirical average we consider repetition.
research shows that repetition can significantly improve memory and learning .
in figure we see that the increase around days since the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden j. kr ger et al.
figure3 familiarityrelatedtothenumberofcommits.the blue line displays average values.
the circle sizes representthe number of participants with this combination.
lastcommitmatcheswithahighernumberoftotalcommits.furthermore weseethatmostresponseswithmultiplecommitsare above a familiarity of .
responses with fewer mostly singular commits are mainly below this threshold.
we can further support this observation by displaying the average only for those responses with a single commit as the dashedred line in figure .
in this case the average actually resembles theforgettingcurveofebbinghaus .thisisreasonableasthe curvedoesnotconsiderrepetitionsand thus maybeappropriate for single commits.
infigure3 weshowthefamiliaritysolelyrelatedtothenumber of commits.
here the circles sizes illustrate the number of participantsstatingthis combination.again theblue linerepresents average values.
we see that all responses below a familiarity of5 have or less commits.
on average the results show a rising familiarity as the number of commits increases.
discussion.
all results indicate that repetition affects familiarity.
the average deviates from the forgetting curve at points at which responses with multiple commits appear.
this is due to these responsesbeingmostlylocatedinthetophalfofthefamiliarityscale where they should not be according to the forgetting curve.
in figure3 thiseffectisemphasizedevenmore asonlyresponseswith less than commits in total are below this threshold.
to test this weassumethenullhypothesisthatcommitsandfamiliarityarenot correlated.
however our statistics reveal a highly significant correlation between the two p .
.
the rank correlation measures imply a moderate to strong positive effect rs .
and .
.
wethereforerejectthenullhypothesisinfavorofassumingthat the number of commits positively affects familiarity.
figure familiarity related to the ratio of own code.
the blue line displays average values.
the circle sizes representthe number of participants with this combination.
based on the results we conclude the number of edits is moderately to strongly positively correlated with familiarity in software development.
.
.
ratio of own code.
another factor that may impact a developer sfamiliarityistheratioofcodetheyimplementthemselves.
tocomputethisratio weextractthefile sversionforthedaywe received the survey.
then we account each line the participants editedlast using git blame tothemandrelatethesumtothefile size.wedisplaythecorrespondingresultsinfigure4.again the blue line represents the average and the circle sizes the number of participants with this combination.
the average behaves comparable to the one we find for repetitions cf.
figure .
however the line is on a lower familiarity level in this case.
discussion.
the results imply a correlation between the ratio of owncodeandfamiliarity.still astheaveragetrendisnotasstrong as in figure and more deviation occurs we assume a weaker correlation.
this seems reasonable as the developer has implemented thecodebutcanonlyregainfamiliaritybasedonrepetitions.for oursignificancetests weassumeasnullhypothesisthattheratioof code a developer implemented is not correlated to their familiarity.
theoutcomeindicatesahighlysignificantcorrelation p .
wherefore wereject thenull hypothesisin favorof assumingthat both parameters are related.
as rank correlations we compute rs .
and .
and thus a positive moderate correlation.
based on the results we conclude theratioofcodeimplementedbydevelopersthemselvesis moderately positively correlated with their familiarity.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
do you remember this source code?
icse may june gothenburg sweden figure familiarity related to the tracking behavior.
the blue line displays average values.
the circle sizes representthe number of participants with this combination.
.
.
tracking.
we asked our participants to which extent they track changes others apply to their code.
this factor could alsoimpact their familiarity because tracking may indicate that they analyze the changes and are therefore more familiar with the code.
we display the results in figure .
actually it surprises us that many of our participants state a value of above .
this indicatesthat they are aware of the code others implement and change in theirfiles.still participantswithhightrackingvaluesarealmost equally distributed above and below a familiarity of .
discussion.
despitehighvaluesintheresponses wefindnohint ofacorrelationbetweentrackingandfamiliarityinfigure5.dueto the deviation of responses we assume no correlation between the two considered parameters.
we use this as our null hypothesis and findnosignificantcorrelation p .
.also therankcorrelation measures of rs .
and .
indicate almost no dependency.
thus for our participants we find no correlation between tracking changes and familiarity.
this result poses some questions.
possible explanations may be thatdevelopersindeedtrackchangesbutdonotinvestigatethem.
maybe ourparticipantsalsointerpretedtheterm trackingdifferently.
for example some may have seen it as actually analyzing code butothersasjustreadingnotifications.iftheyactuallyreviewcode wewouldexpectacorrelationtothefamiliarity astheseactiv itiesarealsoaformofrepetition.however thisdoesnotseemtobe thecase.furtherqualitativeanalysesarenecessarytoinvestigate this discrepancy.
based on the results we conclude the tracking behavior of own files does not affect familiarity.table spearman s rho rs kendall s tau and the corresponding significance sig.
values for each factor.
factor rs sig.
sig.
file size .
.
.
.
repetition .
.
.
.
own code .
.
.
.
tracking .
.
.
.
.
.
summary.
overall we find that repetitions are positively correlatedwithfamiliarity.thisisnotsurprising aslearningand memorizing are improved with re petitions.
interestingly the numberofcommitsseemstopartlyoutweightimeasanindicatorfor thesubjectivefamiliarity.fortheratioofcodeimplementedbya developer we alsofind a positive but weakercorrelation.
it seems clear that the code developers implement themselves is more familiar to them.
still they also become unfamiliar with this code reducing their familiarity if they do not repeatedly investigate it.
considering the tracking of changes we find no correlation.
regarding our first research question we conclude repetitionaswellastheratioofowncodearesignificantly positively correlated with familiarity.
thus they must be considered in a suitable forgetting curve.
.
memory strength regarding our second research question we want to identify an averagememorystrengthforourparticipants.forthispurpose wecomputethememorystrengthofeachparticipantfirstbytransposing equation into equation .
s t ln r recall that trepresents the days since the last commit and ris the stated familiarity.
consequently sindicates how fast our participants memory fades each day.
we compute three different distributions firstly the memory strengthbasedonthesubjectivefamiliarityofallparticipants.this value includes repetition and thus is biased considering the actual forgetting rate.
however we can again verify our previous findings if repetition is significant the median and distribution of the memory strength should be higher than for the other two cases.
secondly wecomputethememorystrengthbasedonthesubjectivefamiliarityofparticipantsthatcommittedonlyonce.finally we compute the memory strength based on the responses to the questionafterhowmuchtimehalfofafileisforgotten.here the retention rate ris .
meaning that half the familiarity is lost and the time is the participant s response.
as this question is challengingtoanswer weassumethatthesecondvalueshouldrepresent the best approximation for our participants memory strength.
results.we display the computed distributions for each case as violin plots in figure .
note that we use the median insteadof the mean for our calculations in the next section as we have large outliers.
these outliers are only partly visualized to avoid an unreadable scaling.
we also display the number of responses in each distribution below the corresponding violin plot.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden j. kr ger et al.
!
figure computed memory strengths based on the familiarity of all participants overall left of only those with one commit e center and based on the approximation question r .
right .
as we expect the memory strength based on the familiarity of all participants is the highest with a median of .
in addition the deviation in the results is the largest.
for the participants with only a single commit e and the approximation question the mediansare65and43 respectively.bothhaveconsiderablysmallerdeviations than the first sample.
while the sample with only single commits has the smallest deviation it also contains only out of responses.
regarding the approximation question we remarkthatourparticipantsstatethattheyforgethalfoftheirfilesafter30 days in the median and days on average.
to compute the corresponding familiarity we again use the median.
discussion.
for our goal of deriving a general memory strength we discard the overall sample as it includes repetition.
however the higher deviation and median substantiate our previous findings.
due to repetition the computed memory strength increases indicating the same effects we find in section .
.
interpretingtheremainingtwosamplesisquitedifficult.inthe sample e we compute the values based on the remaining familiarityandonly forparticipantsthatcommittedonceto afile.
due to the smaller sample size less deviation appears.
the median value of indicates that after this number of days developers rememberonly36.
oftheoriginalfile.afterapproximately45 days half of the knowledge is lost.
themedian of43forthe approximationsample r .
could represent a more complete view on the participants familiarity asweincludealloftheminthisdistribution.however insteadof assessingonlytheirsubjectivefamiliarity eachparticipantalsohas to estimate a time factor.
thus these results seem less reliable.
this analysis has to be repeated and validated in further studies.
still we argue that can be considered as a good approximationof the general memory strength for our participants.
it is based on less subjective assessments includes only the appropriate subjects and is affected by less deviation.
in addition this memory strength does closely correspond to the stated days on average after which half of a file is forgotten .
regarding our second research question we conclude thecomputedmemorystrengthssubstantiatethepreviousre sultsonrepetition.amedianvalueof65seemstobeanappropriate approximation of our participants memory strength.
.
the forgetting curve finally weconsiderebbinghaus forgettingcurvetoanswer our thirdresearchquestion.
asstated before if thereare noother factors than time the results we show in figure should resemble the forgetting curve.
if we only consider responses with a single commit dashedredline ourresultsandthecurvebecomemore similar.still ourpreviousresultsshowthattherearefactorsthat influence familiarity in software engineering.
infigure7 wedisplaythefamiliaritiescomputedwithequation1 basedonthepreviouslyderivedmemorystrengths compared to the subjective assessment of our participants.
ideally one of thecurveswouldresembleequalvaluesforbothfamiliarities.we illustrate this with the black diagonal.
as we see none of the functionsresemblesthislinecompletely.thisisnotsurprising asthe forgetting curve does not consider any other factor than time.
for instance wefindthatahighnumberofcommitsindicatesahigh familiarityand forthisreason allfunctionsdropatacertainpoint.
still asweexplainedbefore ebbinghaus curvedoesroughly resembletheblacklineifweconsiderthememorystrengthof65 andonlysinglecommits.thisisindicatedbytheorangelineand trianglesbeingclosetotheidealuntilafamiliarityof6.however as we determined this memory strength based on the illustrated values this match is not surprising.
discussion.
the results of our study indicate that the forgetting curveofebbinghaus isapplicableinsoftwareengineeringif no other factors than time affect familiarity.
in our study most deviationoccursduetorepetition.consequently thecurvecould be used if developers would not modify their code again.
still this is usually not the case and adapted approaches for software developmentseemnecessary.thesecanbaseonouranalysisand potentially integrate our findings into an existing forgetting curve for example by ebbinghaus .
the results we show in figure also substantiate that the responses of the approximation question seem less reliable.
estimating two subjective values may have negatively influenced the selfassessmentofourparticipants.however wecannotfinallyconclude which of the curves represents reality best as we rely on subjective self assessments.
thus further empirical studies are needed tovalidateandconsolidatethememorystrength potentiallywith different measurements.
regarding our third research question we conclude theforgettingcurveofebbinghaus isonlyapplicablefor software developers if no other factors mainly repetitions occur.
thus an adaptation seems necessary.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
do you remember this source code?
icse may june gothenburg sweden figure7 comparisonofsubjectiveandcomputedfamiliarities with different memory strengths.
threats to validity we are aware of several threats to validity which we discuss based on common classifications .
most threats result from combining two research areas psychology and computer science.
construct validity.
the terms we used may result in misunderstandings and our questions may have been misinterpreted.
especially this could be a problem regarding that native and nonnative english speakers participated.
we mitigate this threat byusingcontrolquestions asexplainedinsection4 andexcludingresponses that indicate misunderstandings e.g.
proposing a file the participant did not commit to .
internal validity.
asweaimtomeasurethefamiliarityofdeveloperswiththesourcecode wefindseveralthreatstotheinternal validity due to potentially unknown or not yet considered parameters.
in the following we exemplify some aspects that can affect learning and forgetting but are excluded from our study theeffectof reviewing andtestingbutnotcommittingsource code is not considered but also results in repetitions.
different development approaches may influence how developersremembersourcecodeorwhetherweconsiderthem correctly during our analysis.
the degree of reuseof source code may further support developers memory due to multiple occurrences.
considering implemented features development time and importance ofsourcecodecouldindicatewhetherdevelopers can remember such factors more easily.
someprogramming languages may be harder or easier to remember than others.
despitesuchfactors weintentionallyusedasimplisticapproach basedonaprominentforgettingcurvetogaininsightintoforgettingin software engineering.
while all the aforementioned factors can have an impact further investigations are necessary to analyze these and currently we would have to rely on many assumptions.
also we argue that considering forgetting unknown code and repetition are valid and important factors to this end.
anotherthreattotheinternalvalidityistheusedforgettingcurve of ebbinghaus .
other curves may be better suited to represent forgetting in software engineering and may consider additional parameters.
however the curve we use is established and in a recent study murre and dros replicate and validateits suitability in anexperiment.astheyalsoshowthatotherforgettingcurvesdo notheavilydiffer wearguethatthisisnotthreateningourstudy.
furthermore averell and heathcote also show that the exponential nature of the forgetting curve fits best to their participants results.
we remark that both studies origin from the psychological domain and thus may not be completely transferable.
external validity.
background factors such as age gender education or the motivation of open source developers andourrespondentsinparticular mayinfluencememory performance.
however medical and psychological studies suggest thatmemoryperformanceisstableuntilmiddleage andgender mainly affects episodic memory which is unimportant to our study.
we assume that the educational level and motivation are relativelyhomogeneousinoursample.still aswecannotcontrol these factors they remain a threat to validity.
an additional concern is the subjective nature of familiarity.
each developer learns understands and forgets at adifferent rate with different factors influencing familiarity.
still as we rely on an acceptedmodelforforgetting wearguethatbyusingmediansof the participants results we obtain valid insights into forgetting in software development.
conclusion validity and reliability.
potentially the main threattoourworkareseveralofourquestionsrequiringsubjective self assessment.
this could bias our conclusions in several ways but as we measure and compute subjective factors we have to rely on these assessments until we know more about such factors.
inaddition we have a comparatively small number of participants which may lead to statistical errors.
we mitigate these threats with our control questions excluding implausible responses andby carefully deriving conclusions not only from statistical tests which we only use to support our arguments.
considering the appliedtests weespeciallyusedspearman srhoandkendall stau as they do not require normal distributions or linear correlations.
despite the discussed threats we argue that any researcher can repeatourstudyontheirown.dependingonthesubjects questions andparameters differentresultsmayoccur .however thisistruefor mostempiricalstudiesandisnotathreattoourstudy.nonetheless we strongly encourage the research community to replicate and extend our approach and study as we also aim to do.
for this purpose weprovideaccesstoananonymousversionofourresults as we described in section .
related work thereexistseveralrelatedworksthatinvestigate forgetting indifferentdomains.othercomplementaryworksinclude empiricalstudies andexpert identification.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden j. kr ger et al.
forgetting.
nembhard and osothsilp report a comparative studyonforgettingmodelsinthecontextofproductionmanagement.theyidentifyseveralstrengthsandweaknessesofthemodels consideringdifferenttasks.whilethisworkhasadifferentscope than ours utilizing the applied method can help to adapt an approach for software development.
also the problem of correctly approximating forgetting and familiarity can be seen as few years later jaber and sikstrom criticize the aforementioned work.
they contradict theresults for one modelthat performs poorly in thepreviousstudy.similarly jaberandbonney comparethree learning and forgetting models on a mathematical level.
in psychology the form of forgetting curves is often debated and averell and heathcote address this issue with an experiment.
to this end they measure different variables over days to observe forgetting.
the results indicate that exponential forgetting curves suchastheonebyebbinghaus arethebestfitfortheir participants.theiranalysismayprovidefurtherdetailsforrefining our study and to derive an approach for software engineering.
empirical studies.
in an empirical study with java developers fritzetal .
investigatetheidentificationofknowledge in software development.
the participants are asked questions for files theyworked regularly orrecently on.
both metricsare helpful to identify the experts of a program element and several aspects that can improve the model are investigated.
our study is complementarytothisoneaswearenotinterestedonidentifyingexisting knowledge but its fading over time.
we also show a significant correlationbetweenregularlyworkingonafile i.e.
repetition and familiarity which supports the assumptions of fritz et al.
.
kang andhahn investigate learningand forgettingin software development.
their findings suggest that learning effects appearforallkindoftechnologywhileonlymethodologicalknowledgeexhibitsforgetting.however theyperformtheiranalysison artificial project data rather than with participants and focus on generalcategoriesofknowledge.ourworkdiffersasweexamine familiarityonthecodelevelandconductourstudywithdevelopers.
latoza and myers investigate questions that programmers face while developing software.
for this purpose they gather more than300questionsandcategorizethem.theresultsindicatethat developers often ask rather specific questions about a scenario such as the impact of a potential bug.
most of these questions areconnectedtothesourcecodeandillustratetheimportanceof being familiar with it.
thus their work can be used as basis for extendingourstudybydefiningmoredetailedquestions potentially to approximate familiarity for validation purposes.
koenemann and robertson report an empirical study in whichtheyinvestigatehowprofessionaldevelopersanalyzesource code.theirfindingsshowthatprogrammersonlyfocusonthose parts of a software that are relevant to them.
combining these results with ours could imply some further factors that we have to consider when approximating familiarity.
expertise identification.
mockusandherbsleb propose theexpertise browser a tool to identify experienced developers and experts.
to this end they rely on change management andquantify the changes implemented by a developer as experience.
we are not aware of theirapproach considering that even experts forget and become unfamiliar.
thus our analysis confirms their assumptions and complements their approach.
this also applies tootherexpertiseidentificationapproachesandtools whichfocuson communities as well as source code .
oftheseapproaches theoneproposedbyfritzetal .
maybe the oneclosest toour study.the authorsderive amodel toidentify experts from previous empirical studies.
here they consider developers authorshipandinteractionswithapieceofcodetorepresent their familiarity which are additional factors that we have to con sider.however whilethisapproachisbased onrepetition weare notawareofanyconsiderationofforgetting.thus ourapproach may improve their model by also including this factor.
anviketal .
describeanapproachtoassignbugreportsbased onthepreviouslyperformedbugfixesofadeveloper usingmachine learning.
they use this knowledge to identify the most suitable experttoresolvethenewproblem.ourinsightscomplementthis analysis as we investigate at which point an expert may have lost too much knowledge.
conclusions in this paper we investigated forgetting in the context of software engineering.
for this purpose we conducted an empirical study with60developers.wereliedonasimplebutvalidforgettingcurve toanalyzetheirfamiliaritywithafile.withourstudy weidentifyto whichextenttheoriginalcurverepresentsthesubjectiveassessment of developers.
furthermore we investigate the importance of three factors on familiarity and derive a representative memory strength for our participants.
to conclude our findings we find the forgetting curve of ebbinghaus is appropriate in software development if only time has to be considered.
repetitionsmoderatelytostronglycorrelatetofamiliarity and can be even more important than the elapsed time.
the ratio of code a developer implemented is moderately correlated to familiarity.
we need to better understand how developers track their code as we find no correlation to familiarity.
avalueof65forthememorystrengthseemstobeanappropriate value regarding our participants.
we remark that there are several threats to our work and only further studiesand research can validatethe results.
nonetheless we do provide important insights into familiarity in the context of software development.
in future work we will measure familiarity in more detail to investigateforgetting.currently weaimtocomparesubjectiveand measurablefamiliarity.integratinganautomatedapproachbased on our results and related works is interesting.
also additional artifacts of a project and other factors such as learning need to be integrated.
tothis end additionalstudies areessential tovalidate the results and identify further factors that influence familiarity.
we see the need for interview studies and action research to derive qualitative insights into forgetting of developers.
with large scale experiments thesefindingscanbevalidatedandevaluatedinmore detailthanwe coulddofornow.furthermore differentforgetting curves and their adaptations should be compared and evaluated regarding their applicability for software developers.