top down model driven engineering of web services from extended openapi models david sferruzza ls2n umr cnrs nantes france david.sferruzza ls2n.fr abstract web services engineering is a crucial subject because web services areoftenbuilttobeusedbyotherprograms thustheyshouldhave a good documentation targeting developers.
furthermore when buildingadigitalproduct engineersneedtobuildseveralprograms that interact with a central instance of web services.
openapi a popular industry standard makes possible to document web services in order to quickly make a prototype of the product.
it allows a top down process where developers iterate to build an openapi modelthatdescribesthewebservicestheywant andthenimplement both the web services and the programs that will consumethem.
however when such rapid prototyping developers tendtoeitherskipthisdesignphaseandimplementwebservices rightaway orstopupdatingtheopenapimodelwhentheproduct is released in both cases they cannot take advantage of having an openapimodelalignedwiththeimplementation.weshowhow openapi can be extended to add implementation details insidemodels.
these extensions link services to assemblies of components that describe computations.
hence a top down development processthatkeepsmodelandimplementationaligned.moreover this makes possible for developers to benefit from more support features while keeping the same flexibility.
ccs concepts softwareanditsengineering model drivensoftwareengineering domain specific languages software prototyping keywords web services model driven engineering documentation code generation openapi .
acm reference format davidsferruzza.
.top downmodel drivenengineeringofwebservices from extended openapi models.
in proceedings of the 33rd acm ieeeinternationalconferenceonautomatedsoftwareengineering ase september montpellier france.
acm new york ny usa 4pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction context.webservicesarekeyelementsofmanydigitalproducts.
indeed these products often require to be available on several platforms web android ios ... thus can benefit from separating concerns web services centralizing data and business logic have differentlifecyclesthantheseveraluserinterfacesthatrelyonthem.
this architecture is quite common for example after several years ofcoachingstartupsatstartuppalace1 itappearsthatalotofthem are using it or should be.
one of the difficulties of this approach istodesignandmaintainaconsistentinterfacebetweentheweb servicesandtheotherprograms whicharesometimesdevelopedby other teams or even unrelated people.
fortunately many tools and languages exist to help designing writing and maintaining such interfaces.
openapi is one of them it defines a specification to describe the http apis of web services in a language agnostic way.
it is quite famous in the industry and has a rich ecosystem of tools2.
motivation.
building or fast prototyping digital products can be achievedusingatop downapproach.first theydesignanopenapi model and make sure it is suitable as an interface between thedifferent actors.
then they can rely on this model to implementthem independantly using programming languages.
some tools likeswagger code generator provide support to developers in this process they generate code based on the openapi model targeting one of the numerous supported languages and frameworks.
however because openapi is language agnostic the generated codedoesnotcontainimplementationdetails developersstillhave to complete it in a way that respects the contract defined by theopenapi model so that they obtain a working implementation.
focusingonwebservices thismeansthat apartfromthisone timegeneration theopenapimodelandtheactualimplementationwill need to be maintained in a separate manner which in many cases results inthe implementation beingmaintained andthe openapi modelbeingoutdated.thisbecomesmoreproblematicwhenthe digitalproductevolvesalot i.e.itisamvp3 becausedevelopers cannot benefit again from the code generation step when another top down cycle as it would override precedently customized code.
contributions.
toovercomethisissueandgiveevenmoresupport to developers we extend the openapi .
specification to make possible to add some implementation details in models and md 3minimum viable product a finished but lightweight product made to test market hypotheses.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france david sferruzza provide a tool to generate working web services from extended models.
implementation details added to openapi models consist of assemblies of components that represent computation units.
these components can be defined in two ways i by a contract and animplementationinaprogramminglanguage or ii intermof alreadydefinedcomponents.everyserviceislinkedtoacomponent whose purpose is to generate an http response.
ourtool swsg providessupporttoautomatizesthetopdown development process.
it can read these extended models checkseveral propertiestoensuretheir consistency andgenerate code of working web services.
on top of solving the alignment problem this gives even more support to developers.
the article is structured as follows.
section describes the componentsystemandhowitisintegratedinopenapi3.
.
section3 introducesswsgandshowshowitchecksmodelsandgenerates code.section4 presents relatedwork.
finally section5 concludes the article with some lessons and future work.
extending openapi the openapi specification defines a standard to express interfaces tohttpapisinalanguage agnosticway.itaimsatallowing both humans and computers to discover and understand the capabilities of the service without access to source code documentation or through network traffic inspection .
as in model driven engineering mde the point of having such meta models is to have tools that can rely on them in order to safely manipulate models and offer support to developers.
indeed the growing ecosystem of openapi contains numerous tools that can be used in a top down process which often means that an openapi is given as input to a tool that will refine it and produce another artifact.
for exemple bothswaggereditor andswaggerui provideaninteractivegraphicaluserinterfacefromamodel and dredd generates functional tests from a model.
by design openapi does not contain implementation details thatdescribehowthewebservicesaretobeimplemented.asstated in the introduction this can lead to a misalignment between the openapimodelanditsimplementation.toovercomethislimitation whilekeepingthebenefitsofusingopenapimodelsinatop down process weextendopenapitoaddanewlayerofinformationthat describes the implementation of the web services at a high level ofabstraction.thislayerconsistsofcomponentsdefinitionsand instanciationssuchasthoseweintroducedinapreviouswork .
section .
describes this new layer and section .
shows how it is integrated in openapi .
.
.
the component system componentsareunitsofprocessesandcomputationsthatoccurin sidewebservicesandwhosepurposeistoproducehttpresponses.
their execution happens in an isolated context that can contain variables.
they can mutate this context by adding and removing variables or return an http response.
components can be of two kinds either atomic or composite.atomic components are defined by a name and four sets of variables parameters preconditions additionsandremovals.parameters are variables whose values must be provided when instanciatingthecomponent itallowstodesigngenericcomponentsthatare easiertoreuse.theotherthreesetsofvariablesformthecontractof the component they define what variables it needs to access from thecontext preconditions whatvariablesitwilladdtothecontext additions and what variables it will remove removals .
the point ofthiscontractistosupportalightweightkindofstaticverification we call structural consistency.
atomic components must go along with an implementation in a programming language which makes them very flexible.
composite componentsare defined bya name aset of parameters and a list of instances of components.
parameters work in the samewayasforatomiccomponents.instancesofcomponentsreferenceacomponentbyitsnameandprovidebindingsandaliases that arespecifictotheinstance.bindingsassociateaparameterofthe component to a value and aliases allow to rename a variable from thecomponent scontractinalocalway.compositecomponents do not need to be implemented using a programming language becausetheyaredefinedintermofothercomponents.indeed their behaviorconsistsofexecutingtheirsubcomponentssequentially eachgettingthecontextoutputbytheprevious.however thissequential execution is interrupted if any of the components outputs an http response instead of a new context.
thiscomponentsystemwasvoluntarilydesignedtobesimple and offer a good trade off between expressiveness and ease of support.thatiswhy forexample sequentialexecutionistheonlyway to combine components.
.
extensions to openapi .
to make it possible to use this component system and describe implementationsofwebservicesfrominsideanopenapimodel theopenapi3.0specificationmustbeextended.twokindsofinformations must be added definitions of components and for each service aninstanceofcomponent.hopefully openapiprovides anextensionmechanismthatpreservestoolscompatibility most of the schemas of the specification can be enhanced with more attributes if their names start with x .
the full specification of our extensions is available in .
thelisting shows an extract of the petstoreexample an official example of openapi .
model that has been enhanced with our extensions.
the components object contains two new properties x swsg cc andx swsg ac .
the first is a set of composite component definition here we define a component called findpet in terms of two other components named getpetbyid andrenderpet .thesecondisasetofatomiccomponentdefinition that contains the definitions of getpetbyid andrenderpet .
the listing shows how the findpet component is instanciated from a service in the x swsg ci attribute.
generating web services to use our extensions to openapi .
we propose the following top down development process developerswriteastandardopenapimodelthatfitstheir needs authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
top down mde of web services from extended openapi models ase september montpellier france components schemas pet allof ref components schemas newpet required i d properties id type integer format int64 newpet required name properties name type string tag type string x swsg cc name findpet components component getpetbyid component renderpet x swsg ac name renderpet pre name pet type entity pet name getpetbyid pre name id type string add name pet type entity pet listing components definition paths pets id get parameters name id in path description id of pet to fetch required true schema type integer format int64 responses description pet response content application json schema ref components schemas pet x swsg ci component findpet listing service definition they use our extensions to design components and associate them to every web services they write an implementation for each atomic component they run swsg to check the model and generate code.
thestep ismadepossiblebyourextensionsandprovideatransitional step between the modelling and the implementation intherefinementprocess.itsimplifiestheimplementation by reducing it to several small functions instead of a whole program.
the step makes useof our tool swsg thatfollows the process shown in figure .
we present this tool in the followingsections section .
focuses on the model consistency verification andsection .
on the code generation.
openapi modelmodel parsingsyntax ok?failure starttransforming to swsg model consistent?consistency checkinggenerationac implementations web servicestransformation ok?
stopfailure failure yesyes yesno nono1 figure process of swsg .
consistency verification thethirdstepoftheprocessofswsg figure1 isastaticverification of the structural consistency of the model.
it consists of a setofformalrulesthatcheckthesemanticsofmodelstodetermine whether it allows for a safe code generation.
this set of rules is derivedfromtheonewepresentedin .itspurposeistohelp developers to spot inconsistencies in models as earlier as possible.
for example the model presented in listings and2is inconsistent swsg indicates a preconditionerror .
details of the error tell us that the getpetbyid component is not given a variable of typestringcalledid as it requires.
indeed the service definition shows that the idvariable comes from a service parameter that has theintegertype.
this kind of mistakes is quite common in softwaredevelopment buthavingtherighttoolscanmitigateits consequences.here swsgdetectedtheproblembeforeweeven run the code in production so we just lost a small amount of time wecouldhavelostalotmoretimeifthiscodehadbeendeployed just for a typo .
when this error is fixed in the model swsg can proceed to the code generation step.
.
code generation the process depicted by figure 1is generic it does not rely on a specific language or technology.
yet the language and technologies used to implement atomic components must be identical orcompatiblewiththoseofthecodegenerationtarget.becausewe experimentin startuppalace scontext thecurrentimplementation ofswsgtargetsthephpprogramminglanguage4withthelaravel web framework5 which is a common tool stack.
the generation in itself is done with a model to text transformation that uses a template engine called twirl6.
apart from some static classes and from the implementations of atomic components that are not altered swsg generated two kinds of source files implementations of composite components and a route file.
the listing shows the code generated for the findpet component defined in listing .
wetooktheapproachofgeneratingcodethatshouldneverbe manuallyedited.thegeneratedcodedoesnotoverrideanyexisting authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france david sferruzza ?php this is a generated file do not edit namespace app components useapp swsg component app swsg ctx app swsg params class findpet implements component public static function execute params params ctx ctx ctx0 app components getpetbyid execute new app swsg params ctx arrowhookleft if ctx0instanceof illuminate http response return ctx0 if ctx0instanceof swsg ctx ctx0 ctx0 ctx1 app components renderpet execute new app swsg params ctx0 arrowhookleft if ctx1instanceof illuminate http response return ctx1 if ctx1instanceof swsg ctx ctx1 ctx1 return ctx1 listing generated code for the findpetcomponent files in a laravel s architecture and can be easily hooked to an existing web application through configuration.
incaseofevolutionoftheneeds whichislikelywhenworkingwith mvps developershave togo through thetop down development processagain butcanreusemostoftheexistingitems partsofthe extended openapi model implementation of atomic components .
thisapproachpreservesalignmentbetweenthemodelandtheweb services and fosters reuse of components.
related work the use of mde for development and automatic generation of web servicesorwebapplicationsisnotanewtopic .indeed this work is built on top of the approach of swsg and reifier .
throughswsg ourprocesssharesthemeta modellingapproach with tools such as m3d introduced in and extended in that alsofocusonbuildingwebservicesusingmde.oneofthemain differencesbetween swsgand m3disthat swsgwas developed with a focus on design time support.
even if swsg is definitely relatedtoexistingstandardssuchasbpel orwsdl ourapproach differsonseveralaspects.first wewantto avoidtheshortcomings described in that is wsdl models contain toomuch technical detailsandaredifficulttounderstandforhumans.indeedourmetamodel is simpler and less expressive than wsdl or bpel.
second this allows swsg to provide more support to users the balance between flexibility and support is discussed in .
one of the tools featured in the openapi ecosystem is swagger codegenerator .itaimsatgeneratingclientlibrairies server stubsordocumentationsfromanopenapimodel.itsupportsmany languages and frameworks but only helps developers to write new services by generated boilerplate code.
this automatizes a tedious task howeve r they still need to add a lot of code on top of it.
moreover when services evolve developer need to manually propagate evolutions into the codebase because swagger code generator isn t abletomergethemautomatically.ourapproachsolvesthisissue becauseitgivesflexibilitytodevelopersbeforethecodegeneration step makinguselesseditinggeneratedcode.thisensuresalignment between the openapi model and the web services.
conclusion we extended openapi .
with a component system to describe implementationsofwebservicesfromahigh level.thisestablishesanintermediaryartifactthatfitswellinthetop downdevelopment process between the abstract openapi model and the concrete implementationofwebservices.thisallowstogenerateanimplemen tationofthewebservicesthatdoesnotneedmanualmodifications.
as a consequence alignment between the openapi model and the implementation is guaranteed.
moreover this paves the way for enhanced support features for example verification or interactive visualization.
we also presented swsg a tool that can check structural consistency of extended openapi models and generate code of the web services.
this approach was tested on several case studies7 but needs moretestingonbiggerprojects.anotherperspectiveistogeneralize swsg to support more languages and technologies.
this would probably lead to the formalization of interfaces to make it possible toplugexternalcodegenerators.also itwouldbeinterestingto allow swsg to check the compliance between implementations of atomic components and their contract.
in a similar manner calling external tools could be a solution to keep swsg generic.