a large scale empirical study of compiler errors in continuous integration chen zhang school of computer science fudan university chinabihuan chen school of computer science fudan university chinalinlin chen school of computer science fudan university china xin peng school of computer science fudan university chinawenyun zhao school of computer science fudan university china abstract continuous integration ci is a widely used software development practice to reduce risks.
ci builds often break and a large amount of efforts are put into troubleshooting broken builds.
despite that compiler errors have been recognized as one of the most frequent types of build failures little is known about the common types fix efforts and fix patterns of compiler errors that occur in ci builds of open source projects.
to fill such a gap we present a large scale empirical study on ci builds from open source java projects hosted on github.
using the build data we measured the frequency of broken builds caused by compiler errors investigated the ten most common compiler error types and reported their fix time.
we manually analyzed broken builds to summarize fix patterns of the ten most common compiler error types.
our findings help to characterize and understand compiler errors during ci and provide practical implications to developers tool builders and researchers.
ccs concepts software and its engineering compilers .
keywords continuous integration build failures compiler errors acm reference format chen zhang bihuan chen linlin chen xin peng and wenyun zhao.
.
a large scale empirical study of compiler errors in continuous integration.
inproceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
also with the shanghai key laboratory of data science fudan university china and the shanghai institute of intelligent electronics systems china.
bihuan chen is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
introduction continuous integration ci is a software engineering practice of merging all the developers working copies to a shared branch frequently .
the concept of ci was proposed in .
then it was adopted as one of the practices by microsoft and extreme programming .
gradually ci gained wide acceptance due to its automated build process including compilation static analysis and testing.
ci can help developers detect and fix integration errors as early as possible and reduce risks in software development .
with the widespread use and continued growth of ci empirical studies have been recently conducted to explore the usage cost benefits barriers and needs when developers use ci .
they investigate the overall relationships between ci and software development but are not designed to look into the details of ci builds.
specifically ci builds often break i.e.
fail and a large amount of efforts are put into troubleshooting broken builds .
therefore studies have been conducted to analyze the type and frequency of build failures in industrial and open source projects .
they find that test failures violations in static analysis and compiler errors are generally the most frequent types of ci build failures.
to have a deep understanding of one specific ci build failure type in open source projects labuschagne et al.
focused on test failures and zampetti et al.
targeted violations in static analysis.
however little is known about the common types fix efforts and fix patterns of compiler errors during ci in open source projects.
such knowledge about compiler errors in ci is important for ci tools developers and compilers.
to the best of our knowledge the only study on compiler errors is from google .
however it targets industrial projects but not open source projects and it does not systematically analyze the fix patterns of compiler errors.
to fill the gap in characterizing and understanding compiler errors during ci in open source projects we conducted a large scale empirical study on ci builds from open source java projects hosted on github and using travis ci .
by analyzing the data we answered four research questions in this paper.
rq1 frequency analysis.
how often do ci builds fail because of compiler errors?
sec.
rq2 distribution analysis.
what are the common types of compiler errors that cause ci build failures?
sec.
rq3 fix effort analysis.
how long does it take to fix ci build failures caused by compiler errors?
sec.
176esec fse august tallinn estonia chen zhang bihuan chen linlin chen xin peng and wenyun zhao before installinstallbefore scriptscriptafter successafter failureafter scriptlifecycle of build tools e.g.
maven and gradle figure the lifecycle of travis ci rq4 fix pattern analysis.
how are ci build failures caused by compiler errors fixed?
sec.
our answers to the above four research questions can be summarized as the following findings.
of broken builds were a result of compiler errors affecting of projects.
the ten most common compiler error types accounted for .
of compiler errors.
the median fix time of the ten most common error types ranged from minutes to minutes.
simple fix patterns did exist for most of the common error types and ides provided limited supports to automatically fix them.
our findings shed light on the potential areas where developers tool builders and researchers from the compiler and ci community can provide the most benefit.
in summary this work makes the following contributions.
we conducted a large scale empirical study to understand the common types fix efforts and fix patterns of compiler errors occurring during ci builds of open source projects.
we provided practical implications of our findings to three audiences developers tool builders and researchers.
we released a large scale dataset of broken ci builds to foster potential applications of this dataset.
continuous integration travis ci.
an abundance of ci tools are available from self hosted to hosted systems .
for example jenkins is a self hosted system i.e.
developers need to set up the ci service locally and jenkins only store data on recent builds.
travis ci is a hosted system which is integrated with github.
the entire build history of a project is available via the travis ci api.
according to the analysis of opensource projects from github of projects use ci and .
of them use travis ci as their ci service .
to cover the majority of projects and have access to their entire build history we focus our attention in this study on the projects that use travis ci as their ci service.
triggering events.
travis ci builds can be triggered by several events.
push andpull request are the typical ones.
when a commit is pushed to a repository on github or a pull request is opened on github travis ci triggers a build.
besides travis ci supports two other events apiandcron .apimeans that developers can trigger a build by sending a post request directly to the travis ci api.
cron means that builds are triggered at regular intervals e.g.
every week independently of whether any commits were pushed to the repository.
build lifecycle.
as shown in fig.
the default lifecycle of travis ci consists of multiple phases among which install andscript are the most important ones.
the install phase installs any dependencies required for building a project.
the script phase runs the build script e.g.
running testing or static analysis tools .
since travis ci relies on automated build tools such as maven and gradle the lifecyle of a ci build interacts with the lifecylce of a maven or gradle build as shown by the dotted arrows in fig.
.
hereafter a build refers to a ci build but not a maven or gradle build if not explained.maven and gradle are designed to separate the compilation of production code and test code.
by default for the projects using maven both production and test code are compiled in the install phase and thus compiler errors are reported in the install phase.
differently for the projects using gradle the production code is compiled in the installphase and the test code is compiled in the script phase and thus compiler errors in the production code and test code are respectively reported in the install andscript phase.
jobs and states.
in travis ci a build is a group of jobs and a job is an automated build process that clones a repository into a virtual environment and carries out a series of phases such as compiling code running static analysis and executing tests.
for example a build has three jobs each of which runs the build with a different jdk version.
hereafter for the ease of presentation a build refers to a ci build job.
based on the result of a build travis ci assigns different states to a build.
a build is marked as passed if the build ran successfully errored if errors occurred in the before install install orbefore script phase and failed if errors occurred in the script phase.
a build failure occurs if a build is errored or failed and the build is called a broken build.
a build might have other states e.g.
canceled andstarted .
empirical study methodology in this section we first introduce the design of our empirical study and then present our data collection process.
.
study design our goal is to characterize and understand the common types fix efforts and fix patterns of compiler errors that break ci builds of opensource projects.
to this end we proposed the four research questions as introduced in sec.
.
thefrequency analysis in rq1 analyzes the overall frequency of broken builds caused by compiler errors and the distribution analysis in rq2 reports the overall distribution of compiler error types that break builds.
our findings from rq1 can characterize the significance of compiler errors in broken builds and motivate the importance of our study.
our findings from rq2 can identify the most common types of compiler errors where developers researchers and tool builders from the compiler and ci community should concern.
further rq1 and rq2 investigate the frequency and distribution across three important aspects of open source projects project properties development mechanisms and ci mechanisms.
for the three aspects several factors are respectively included number of projects builds and stars branches and code types and build states and triggering events.
our findings can hint the circumstances where compiler errors are more likely to break builds and how compiler error types distribute differently and suggest how to improve the development discipline and ci usage to avoid compiler errors during ci builds.
thefix effort analysis in rq3 measures the time spent by developers fixing each type of compiler errors.
our findings from rq3 can prioritize the types of compiler errors that may reduce developers productivity and where automated debugging or fixing tools may provide the most benefit.
the fix pattern analysis in rq4 analyzes a total of broken builds to summarize fix patterns of ten common types.
our findings from rq4 can assess the feasibility of automatic fixing or fix recommendation of compiler errors and provide hints for developers to troubleshoot compiler errors during ci.
177a large scale empirical study of compiler errors in continuous integration esec fse august tallinn estonia ratio of broken builds caused by compiler errors 0100200300400500600700number of projects a projects ratio of broken builds caused by compiler errors 010020030040050060070080090010001100median of stars median of builds stars builds b builds and stars .
.
master others branch0246810121416ratio of broken builds caused by compiler errors c branches errored failed passed state0123456789ratio of broken builds caused by compiler errors production test8.
.
.
.
.
.
d code types and build states maven errored failed passed state0123456789ratio of broken builds caused by compiler errors production test .
.
.
.
.
.
e code types and build states gradle .
.
.
.
push pull request api cron triggering event02468101214ratio of broken builds caused by compiler errors f triggering events figure frequency of compiler errors across projects builds stars branches code types build states and triggering events .
data preparation since we focus on compiler errors occurring during ci builds of opensource projects we first used the github api to crawl the list of opensource java projects that were not forked as of april .
we focused on java because it is widely used and thus our findings can be beneficial to wide audiences.
this resulted in a set of projects.
to ensure the quality of selected projects we removed the projects that had less than stars which resulted in projects.
of these projects we selected the projects that used travis ci and had more than builds in order to provide sufficient build data which restricted our selection to projects.
to obtain well formatted build logs for the ease of our analysis we only kept the projects that used maven or gradle.
finally we had a set of projects.
we crawled the entire build history of the project.
the data of a build consists of two files a logfile with the logging information generated during the whole build process which includes the information about compiler errors and a jsonfile with various fields e.g.
state to report the statistics of a build.
to this end we crawled the data through a restful web api provided by travis ci.
totally we crawled a dataset of builds for projects which had a total size of .
tb.
then we determined whether a build was broken or successful by checking whether the state field in its jsonfile was errored orfailed orpassed .
finally we obtained broken builds and successful builds which accounted for .
of all builds.
the other .
had uncommon states e.g.
canceled andstarted and were not considered due to their incomplete builds.
frequency analysis rq1 to analyze the frequency of compiler errors we obtained the broken builds that were caused by compiler errors.
to this end we applied akeyword search over logfiles of broken builds by checking whether thelogfile contains compilation error for maven projects or compilation failed for gradle projects.
the two keywords are the default messages to indicate compiler errors in maven and gradle.
.
overall frequency of the broken builds we had broken builds that were caused by compiler errors.
they accounted for of broken builds which was above the as reported by vassallo et al.
using open source java projects but below the as reported by miller et al.
using industrial build failures .
the differences might owe to the different scale of the studies.
further we analyzed the number of projects that had at least one broken build that was caused by compiler errors.
as a result projects were affected by compiler errors.
in that sense compiler errors are a nonnegligible failure types of broken builds and affect most of the opensource java projects which motivates the study in this paper.
.
frequency across project properties we analyzed the ratio of broken builds caused by compiler errors for each project.
as projects with only few broken build would introduce noise we removed the projects that had less than broken builds.
the result is reported in fig.
2a where the y axis denotes the number of projects whose ratio is in a range e.g.
represents the range .
of the projects projects did not have any broken build caused by compiler errors projects had less than of broken builds caused by compiler errors and projects had more than of broken builds caused by compiler errors.
surprisingly at least of the broken builds in projects were caused by compiler errors.
we investigated these 178esec fse august tallinn estonia chen zhang bihuan chen linlin chen xin peng and wenyun zhao projects and found that they mostly do not have any tests or use any static analysis tools and hence broken builds are mostly caused by compiler errors.
for the projects with no compiler errors we found that some developers configure travis ci incorrectly making most builds break before the compilation and they simply ignore the failures and do not fix the configuration.
hence ci training and automated ci configuration tools are needed to ease the configuration and widen the practical adoption of ci in open source projects.
in addition we analyzed project s number of builds and stars to investigate whether they correlate to the ratio of broken builds caused by compiler errors.
the result is reported in fig.
2b where the y axis denotes the median number of builds and stars of the projects whose ratio is in a range.
the projects whose ratio was between and had a larger median number of builds and stars and than the projects whose ratio was and and than the projects whose ratio was between and .
and .
thus popular and frequently built projects have a relatively low ratio of broken builds caused by compiler errors and the differences are statistically significant p .8937e and .0905e in one way anova test .
it implies that frequent builds can facilitate fast integration.
however too frequent builds may incur high time overhead.
thus build prediction techniques are needed to suggest developers when to build.
.
frequency across branches we investigated the ratio of broken builds caused by compiler errors across different branches to test the hypothesis that master branches are less likely to contain compiler errors than non master branches.
we distinguished the master branch from others and extracted this branch data from the branch field of the jsonfiles of broken builds.
the result is shown in fig.
2c where the y axis denotes the ratio and the number of broken builds caused by compiler errors is shown in each bar which is the same in fig.
2d 2e and 2f .
we failed to get the branch data from the jsonfiles of broken builds because of tag builds or missed build data and of them were caused by compiler errors.
of the and broken builds from the master and other branches .
and .
were caused by compiler errors.
this indicates that broken builds on master branches are less likely to have compiler errors than those on other branches.
this difference is statistically significant p .3955e in wilcoxon signed rank test .
it is potentially because developers are often more careful when changing code on master branches so as to make master branches stable otherwise many developers will be affected.
hence a strengthened discipline is need for committing to non master branches e.g.
pre compilation before committing.
.
frequency across code types and build states as compiler errors in production and test code are reported in different phases of ci depending on whether maven or gradle is used see details in sec.
the build state of the resulting broken builds can be different.
hence we analyzed the ratio of broken builds caused by compiler errors with respect to code types and build states together.
we determined whether a broken build was caused by compiler errors in the production or test code by two ways checking whether compiler errors occur in the default task of compiling production or test code as maven and gradle separate their compilation in two tasks or checking whether the file with compiler errors locates in the default folderof production or test code as maven and gradle have separate folders for them.
further we extracted the state data from the state field in the jsonfiles.
here we also analyzed the successful builds as we found some of them also had compiler errors.
the results for projects using maven and gradle are shown in fig.
2d and 2e respectively.
we failed to decide whether compiler errors happened in the production or test code for broken builds as some projects changed the default compilation tasks or source code structures.
and broken builds were respectively marked as errored andfailed and builds were marked as passed .
first production code was more likely to contain compiler errors than test code and the difference is statistically significant p .3093e in wilcoxon signed rank test .
the potential reasons are that production code is usually more complex and frequently changed than test code and projects can have a small number of tests or even no test.
second for maven projects not all compiler errors occurred in errored builds and for gradle projects not all compiler errors in production resp.
test code occurred in errored resp.
failed builds.
this indicates that travis ci provides the flexibility for developers to compile production code in the later script phase.
however this flexibility is at the cost of a longer build time affecting the efficiency of software development.
in detail we analyzed the average build time of errored andfailed builds that were caused by compiler errors and errored builds took seconds while failed builds took seconds.
this difference is statistically significant p .
in one way anova test .
therefore developers should be aware of this tradeoff when changing compilation configurations.
third surprisingly of successful builds also had compiler errors.
to find root causes two of the authors separately analyzed cases by investigating commits logs and configuration files to summarize root causes.
then they discussed root causes and investigated inconsistent cases together to reach consensus.
these cases were randomly selected from cases achieving a confidence level of and a margin of error of .
finally we identified three root causes i compiler errors occur after the script phase and they will not affect the build result ii travis ci can be configured to allow some compiler errors to happen without affecting the build result and iii travis ci provides a retry mechanism to rebuild when a previous build fails and thus previously occurred compiler errors would disappear in retried builds .
thus automated compiler error localization techniques are needed to locate such easily missed but still risky compiler errors.
.
frequency across triggering events we investigated the ratio of broken builds caused by compiler errors across four kinds of events to trigger a build see details in sec.
.
we extracted this event data from the event type field in the jsonfiles of broken builds.
the result is presented in fig.
2f.
it turned out that broken builds had a value of nullfor this event data due to missed build data and one of them was caused by compiler errors.
of the and broken builds respectively triggered by push pull request apiandcron .
.
.
and .
were caused by compiler errors.
this shows that while being the most common way to trigger builds pull requests are more likely to make compiler errors than pushes.
the difference is statistically significant p .9891e in wilcoxon signed rank test .
as pull 179a large scale empirical study of compiler errors in continuous integration esec fse august tallinn estonia .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ratio of compiler errors type.doesnt.take.paramscant.implementwrong.number.type.argslocal.var.accessed.from.icls.needs.finalhas.been.deprecatedreport.accessstatic.imp.only.classes.and.interfacesnot.stmtref.ambiguousdiamond.not.supportedcant.apply.symbolsduplicate.classdoes.not.override.abstractincompatible.typeillegal.startcant.apply.symbolmethod.does.not.override.superclassexpecteddoesnt.existcant.resolve figure overall distribution of compiler error types requests are developed on an isolated branch from the master branch developers may be less aware of code changes on the master branch.
besides it is also possible to file a pull request for a feature that is incomplete such that other developers can provide suggestions inside of the pull request.
on the other hand as developers may do not use ides or be unaware of code changes from other developers or different java versions are used in local and ci compilation environments compiler errors appear in pushes.
therefore proactive alerting techniques are needed to inform developers about potential compiler errors just before pushes or pull requests.
compiler errors caused of broken builds affecting of projects.
of projects had more than of broken builds caused by compiler errors.
production code and pull requests were more likely to contain compiler errors than pushes and test code.
broken builds on master branches were less likely to be caused by compiler errors than those on other branches.
travis ci s flexibility to compile code in later phases was at a price of a longer build time.
even successful builds could contain compiler errors.
distribution analysis rq2 to identify the common types of compiler errors and their distribution we analyzed the compiler error messages reported in the logfiles of broken builds caused by compiler errors.
the list of compiler error types with the formatted error messages are available from the compiler properties file used by javac .
thus we analyzed the compiler properties file for java and made a union of their error types and obtained error types.
then for each of the error types we wrote regular expressions based on the formatted error message and used them to match the error messages in the logfiles.
finally we counted the number of matched compiler errors for each error type and computed the distribution of error types.
.
overall distribution we matched error types with compiler errors but did not find any error for types.
we believe this is attributed to the extensive usage of ides during software development as many error types can be easily captured by ides and are fixed before building.
fig.
lists the most common error types.
they covered .
of compiler errors.
the most common error type was cant.resolve that accounted for .
of compiler errors.
this error occurs when a compiler cannot recognize a symbol in code.
doesnt.exist covered .
of compiler errors.
this error occurs when the compiler cannot find the imported package in the classpath.
expected appeared in .
of compiler errors.
such an error occurs when the compiler expects a token that is not found.
the three most common error types covered .
of compiler errors while the ten most common ones covered .
.
thus developer researchers and tool builders should focus on these most common error types to provide the most benefit.
hereafter we will focus our discussion on the ten most common error types.
comparison to google s study .
the most two common error types in ours are the same in theirs i.e.
they respectively rank 1st and 3rd as reported by seo et al.
and an error type strict ranks 2nd which corresponds to a google specific dependency check .
such dependency related error types are common regardless of the different development practices in google and open source community.
besides some common error types in ours are less common in theirs e.g.
expected andmethod.does.not.override.superclass rank 3rd and 4th in ours but rank 9th and 8th as reported by seo et al.
or even not in their most common error types e.g.
duplicate.class .
we believe this attributes to different datasets produced via different development practices.
our dataset is produced from ci while google s dataset is produced from a monolithic software repository and a centralized build system where code review is conducted before committing and products are built from head.
thus syntax errors e.g.
expected and class access rule violation errors e.g.
method.does.not.override.superclass andduplicate.class are less likely introduced by google s developers.
further some common error types in theirs are missing in our most common error types e.g.
unchecked andrawtypes rank 7th and 13th as reported by seo et al.
but rank 39th and 30th in ours .
as unchecked and rawtypes are warnings only projects in our study were configured to treat them as errors and the other projects just filtered them out but we believe the command line flags to javac in the centralized build system in were consistent across the dataset.
these differences motivate the necessity of this study.
.
distributions across code types and triggering events we further analyzed whether the distribution of compiler error types differs with respect to projects branches code types build states and triggering events.
we found that the distribution had no statistically significant difference for projects whose ratio of broken builds caused by compiler errors was below and above see sec.
.
and for different build states and branches.
hence we omitted their results and investigated the ten most common compiler error types for different code types and triggering events.
fig.
4a and 4b report the results for production code and test code.
the first major difference was that does.not.override.abstract and 180esec fse august tallinn estonia chen zhang bihuan chen linlin chen xin peng and wenyun zhao .
.
.
.
.
.
.
.
.
.
ratio of compiler errors cant.apply.symbolsdiamond.not.supportedincompatible.typescant.apply.symbolillegal.startdoes.not.override.abstractmethod.does.not.override.superclassexpecteddoesnt.existcant.resolve a production code .
.
.
.
.
.
.
.
.
.
ratio of compiler errors method.does.not.override.superclasshas.been.deprecatedillegal.startduplicate.classcant.apply.symbolsincompatible.typesexpectedcant.apply.symboldoesnt.existcant.resolve b test code .
.
.
.
.
.
.
.
.
.
ratio of compiler errors diamond.not.supportedcant.apply.symbolsincompatible.typesillegal.startdoes.not.override.abstractcant.apply.symbolmethod.does.not.override.superclassexpecteddoesnt.existcant.resolve c pushes .
.
.
.
.
.
.
.
.
.
ratio of compiler errors ref.ambiguousdoes.not.override.abstractincompatible.typesillegal.startcant.apply.symbolduplicate.classmethod.does.not.override.superclassexpecteddoesnt.existcant.resolve d pull requests figure distribution of compiler error types across code types and triggering events passedbrokenbrokenpassedpassedbrokenbrokenbrokenfix timefix timesuccessful compilation figure examples of computing fix time method.does.not.override.superclass were more commonly seen in production code than in test code.
this difference is statistically significant p .0709e and .4066e in wilcoxon signed rank test .
these two error types are related to inheritance andimplements .
generally production code has more complicated inheritance andimplements relationships than test code which might cause the difference.
the second difference was that cant.apply.symbol occurred more frequently in test code than in production code.
this error occurs when a method is called with an incorrect argument list.
this difference is statistically significant p .1176e in wilcoxon signed rank test .
this can be attributed to that test code may not be timely maintained when production code changes.
hence automated co evolution techniques are needed to either suggest or automate the co evolution of production code and test code.
fig.
4c and 4d present the results for pushes and pull requests.
one main difference was that doesnt.exist was less commonly seen in pull requests than in pushes.
this difference is statistically significant p .6670e in wilcoxon signed rank test .
as pull requests are filed with the expectation to be successfully merged developers are less likely to import a non existent package.
besides pushes have a high chance to add new features that often introduce new classes.
cant.resolve doesnt.exist and expected were the most common compiler error types.
the ten most common compiler error types accounted for .
of compiler errors.
fix effort analysis rq3 to measure the fix effort of each compiler error type we analyzed the elapsed time during which a broken build caused by compiler errors was fixed to be either passed orfailed with its compilation being successful i.e.
the previous compiler errors had been fixed but the build still broke e.g.
due to test failures as shown in fig.
.
the build can break for several times before compiler errors are fixed.
therefore we identified the sequences of broken builds that had one type of compiler errors and were succeeded by a successful build or a failed build with a successful compilation.
since the sequences of travis ci builds are not linear but a directed graph we followed expected doesnt.exist cant.resolve incompatible.types illegal.start cant.apply.symbols cant.apply.symbol duplicate.class method.does.not.override.superclass does.not.override.abstract 0200400600fix time minutes figure fix time of common compiler error types the method proposed by beller et al.
to extract the sequences.
following google s study we excluded broken builds that had multiple types of compiler errors because it is difficult to discriminate the fix time for each error type.
in total we found sequences.
then we computed the fix time as the time interval between the finishing time of the first broken build in the sequence i.e.
indicating the discovery of a compiler error and the creation time of the succeeded build in the sequence.
as suggested in google s study we excluded the sequences in which the fix time was greater than hours to avoid compounding the fix time with developers schedule as well as to have fair comparisons with google.
finally we computed the fix time for sequences covering error types.
fig.
presents the fix time of the ten most common compiler error types in fig.
.
a box plot is shown for each error type and the line within the box denotes the median value of fix time.
the error types in fig.
were ordered in increasing median fix time and the number of identified sequences that contained the error type was reported in the parentheses after each error type name in the x axis.
overall the median fix time of the error types ranged from minutes to minutes.
some error types like does.not.override.abstract andmethod.does.not.override.superclass took twice more fix time than others such as expected doesnt.exist andcant.resolve .
this difference is statistically significant p .1464e in one way anova test .
this is reasonable because both does.not.override.abstract and method.does.not.override.superclass usually require developers to think about the implementation of new methods while expected involves token level syntax changes and doesnt.exist andcant.resolve are mostly related to dependency or type mismatch issues.
besides the median number of build attempts until the compiler errors were fixed was and .
of the compiler errors were fixed by at least builds.
this indicates that compiler errors are not trivial to fix.
comparison to google s study .
the median fix time of the common compiler error types in our study was much longer than in 181a large scale empirical study of compiler errors in continuous integration esec fse august tallinn estonia google s study less than minutes .
this large difference can be attributed to that google s dataset is gleaned from iterative development and google s monolithic repository asks developers to quickly respond to errors to avoid affecting a wide range of developers.
the median fix time of the ten most common compiler error types ranged from minutes to minutes.
fix pattern analysis rq4 to analyze the fix patterns of compiler errors we focused on the ten most common error types.
for each error type we first randomly selected five broken builds that contained the error type and two of the authors separately looked into the broken builds with the code commit or pull request to investigate how they were fixed.
then they discussed their discovered fix patterns to reach a consensus.
multiple rounds of selection investigation and discussion were conducted until no new fix pattern could be discovered for two consecutive rounds.
finally we analyzed a total of broken builds.
table lists the derived fix patterns for each error type where the first column shows the error type with the number of analyzed broken builds in the parentheses the second column describes the error the third column shows the fix pattern with the number of fixed broken builds in the parentheses and the last column reports the number of errors falsely reported or having imprecise error message.
cant.resolve .we analyzed broken builds to have stable fix patterns for cant.resolve .
the most common fix is to correct mistypes e.g.
change package class method or variable name.
the error is usually due to misspelling incomplete refactoring or code change usage of snapshot libraries and different java versions in build environments.
another common fix is to remove all the relevant code about the symbol not found which is often caused by incomplete refactoring or code change.
an interesting pattern is to add a class meaning that developers seem to use a class that does not exist.
a close look at the commit messages shows that developers often miss some code files in commits.
adding an import statement or a dependency library is also quite common.
less common patterns include adding a variable declaration updating the dependency library version moving a class from a package to another or casting the object type.
doesnt.exist .from broken builds we summarized four patterns to fix doesnt.exist .
in particular adding a dependency library is the most common pattern which resolves errors caused by a missed dependency declaration in automated building tools.
changing an imported package fixed eight broken builds.
these errors are often due to misspelling incomplete code change or usage of snapshot libraries.
similar to the case in cant.resolve developers may miss to commit a whole package.
thus a corresponding fix pattern is to add the package and the classes in it.
the last pattern is to remove the package import statement.
it is interesting that in one of the broken builds a cant.resolve error was falsely reported as a doesnt.exist error due to static method invocation where the compiler falsely considered a class as a package since it is possible that a class is used through its fully qualified name without an import statement.
expected .we investigated broken builds of expected .
as this error type is generally related to syntax violations many fixes are hard to summarize e.g.
changing a token from to add or remove .
therefore we grouped them together as a pattern to change add or remove a token.
besides a common pattern is to remove illegal tokens which occurred times.
most of the illegal tokens were resulted from merge conflicts which developers did not resolve.
the other two patterns are to change misspelled keywords and move code e.g.
moving a method declaration out of a method declaration .
surprisingly .
broken builds had imprecise error messages that failed to locate the position of an error.
method.does.not.override.superclass .via analyzing broken builds we summarized seven fix patterns.
most commonly it is fixed by removing the override annotation and method in the subclass which is usually caused by the removed method in its superclass i.e.
incomplete code changes .
another common fix is to change the method signature in the subclass to match the already changed method in its superclass.
adding the superclass fixed two broken builds where the cant.resolve error was reported together.
updating dependency library version fixed two broken builds.
the libraries were developed by developers in the same team but violated the original design.
thus the libraries were updated to follow the original design.
other patterns are to remove the override annotation or add the missed superclass or dependency library.
cant.apply.symbol s .for the broken builds the common fix patterns are all about changing arguments in a method call i.e.
add an argument remove an argument change the type of an argument and change the order of two arguments.
these errors are caused by incomplete refactoring or code changes or method misuses due to carelessness or unfamiliarity.
another common fix is to add missed method declaration which is usually caused by new features.
a common pattern is to change the method name which means that developers called the wrong method.
a less common pattern is to remove the method call.
we got one false reports due to a bug in type inference in java generics and it was resolved by updating java version.
illegal.start .similar to expected illegal.start is related to syntax violations and often occurs simultaneously with expected .
its fix patterns are almost the same to expected except that it has a pattern that adds the generic type in constructor or method invocations.
actually generic types can be omitted in java and beyond.
this error occurs because of a lower java version in ci build environment.
incompatible.types .this error type usually occurs in assignments where the right hand side can be a literal a variable a method invocation etc.
among broken builds the most common fix pattern is to change the assignee s declared type to match the previouslychanged type of the right hand side.
correspondingly some fix patterns are to change the type of right hand side e.g.
change method s return type and its implementation assign a new value and convert the type of a method call s return value through a chained call e.g.
a chained call to tostring .
other fix pattern are to add a generic type when the generic type inference fails to work or to simply remove the assignment code resulted from incomplete code changes.
similar to cant.apply.symbol s we got two false reports due to the same bug in type inference in java generics.
does.not.override.abstract .analyzing broken builds we derived three fix patterns for does.not.override.abstract .
the most common one is to implement the abstract method in the subclass.
such errors are mostly caused by the new features added in the superclass.
because of incomplete refactoring or code changes the method signature in the superclass is changed without timely changing the 182esec fse august tallinn estonia chen zhang bihuan chen linlin chen xin peng and wenyun zhao table fix patterns of the common compiler error types error type error description fix patterneclipse intellij ideaimprecisesug.?
aut.?
sug.?
aut.?
cant.resolve symbol e.g.
class variable or method is not foundcorrect mistype 0remove relevant code add class add import add dependency library add method add variable update dependency library move class cast object type doesnt.exist package does not existadd dependency library 1change imported package add imported package and class remove package import expected token is expected but not foundremove illegal tokens 29change add or remove token change keyword move code method.does.not.override.superclass method has override annotation but does not override or implement method from superclassremove override and method 0change method signature in subclass add superclass update dependency library remove override import superclass add dependency library cant.apply.symbol s method is called with incorrect argument listadd argument 1remove argument change argument type add method change method name change argument order remove method call illegal.start start of expression type or statement is illegalremove illegal code 0change add or remove token add generic type move code incompatible.types types are incompatible in assignmentchange assignee s type 2assign new value remove relevant code convert return value s type change method s return type add generic type does.not.override.abstract method is not abstract and does not override abstract method from superclassimplement method in subclass change method signature in subclass remove method in superclass duplicate.class two classes have the same fully qualified nameremove class change package name change class name method signature in the subclass.
therefore the corresponding fix is to accordingly change the method signature in the subclass.
another common pattern is to remove the method in the superclass which occurs due to the redesign of interfaces.
duplicate.class .we analyzed broken builds of duplicate.class .
the most common fix pattern is to remove the duplicated class.
such errors are usually caused by branch merges or a lack of coordination among developers.
other patterns are to change the class name or package name to resolve naming conflicts among developers.
from this manual analysis we found that while fix patterns often exist for most of the common error types the root causes of the errors are often hard to derive simply from build logs or commits due to the lack of context when developers make such errors.
moreover most of the fix patterns were simple only involving lines of code changes or code removals.
such simple fix patterns indicate the potential feasibility of automatically fixing common compiler errors.
for example add dependency library can be implemented by locating the jar file containing the specific class from the mavenrepository.
however the main challenge is to automatically identify the root cause such that we can know which fix pattern should be applied.
on the other hand such fix patterns and the potential root causes can be useful for developers to troubleshoot compiler errors or avoid some compiler errors during collaborative development.
modern ides already provide the capability of fix suggestion and automated fix to compiler errors.
therefore we reproduced the compiler errors in broken builds in the two most widely adopted ides eclipse and intellij idea to i determine whether they provide our derived fix patterns as fix suggestions and ii apply suggested fixes to see whether they automatically fix compiler errors without any human intervention.
the results are reported in the fourth to seventh columns of table respectively under column sug.?
andaut.?
.
of the fix patterns eclipse and intellij idea respectively do not support and fix patterns.
specifically they have poor supports for syntax violation errors e.g.
expected andillegal.start .
among the supported and patterns eclipse and intellij idea only support automated fix for and fix patterns.
therefore our derived 183a large scale empirical study of compiler errors in continuous integration esec fse august tallinn estonia patterns can be used to enrich fix suggestions in ides and more importantly automated techniques are needed to automatically fix compiler errors so as to improve ides.
simple fix patterns did exist for most of the ten common compiler error types but root causes were hard to analyze due to the lack of development context.
ides provided very limited supports to automatically fix compiler errors.
discussion in this section we discuss the threats to the validity of our empirical study and the practical implications of our findings.
.
threats to validity construct.
we are interested in compiler errors that break ci builds of open source projects.
hence we designed four research questions to analyze the frequency common types fix efforts and fix patterns of compiler errors.
we believe these questions have the potential to provide implications to different audiences see sec.
.
.
besides we broke down the results of frequency and common types across three aspects that capture the properties of projects and how the projects are developed and use ci.
we selected several factors for each aspect.
while not to be exhaustive the factors capture key characteristics of each aspect.
our purpose is to identify the opportunities to improve development discipline and ci usage to reduce compiler errors.
internal.
this study is mostly focused on the ten most common compiler error types.
they accounted for more than of compiler errors.
such a high coverage indicates the representation of our results.
more specifically in rq2 we focused on the error types in compiler properties files of java and .
while we cannot guarantee that all projects do not use lower java versions we believe this choice is representative as the public updates of java ended in november and most error types across java versions are the same.
in rq3 the computed fix time for each error type might not precisely reflect the time developers spent in fixing errors as developers often tangle multiple development tasks and switch between tasks.
to mitigate this threat we excluded build sequences whose fix time was greater than hours.
besides the identified sample data for each error type varied by an order of magnitude e.g.
ranging from to .
this is due to the unbalance distribution across error types and our constraints on identifying the sample data for a relatively precise computation of fix time.
we believe this trade off is reasonable and at least sample data can provide representative results.
in rq4 we analyzed broken builds to manually summarize fix patterns for each common error type.
we cannot guarantee that the derived fix patterns are complete but we believe they can have a good coverage because we performed several rounds of data selection investigation and discussion until no new fix pattern was discovered.
external.
we analyzed a large number of java projects with a total of ci builds.
while believing that our findings can be generalized for java projects we cannot guarantee that our results can still hold for projects in different programming languages e.g.
c and c .
this is due to the specific compilers designed for different languages.
further studies are needed to investigate such differences.
besides we only used java projects that adopted travis ci.as travis ci is widely used in more than of github projects using ci we believe our findings are representative.
.
implications developers.
this study identifies the common compiler error types where developers should be pay attention to and need the most help.
moreover our findings provide some development suggestions.
developers should know the trade off when changing compilation configurations developers should analyze whether test code needs coevolution when changing production code developers should guarantee the integrity of committed changes to avoid missing some files developers should resolve merge conflicts timely developers should strength the discipline of team coordination to avoid dependency issues e.g.
some developers included dependencies in their local classpath but did not put them in configuration files which might cause errors in ci builds due to the missing dependencies and developers should be aware of the differences between local development environments and ci build environments e.g.
the differences in jdk versions and the accessibility of dependencies .
our fix patterns can be useful for developers to troubleshoot compiler errors.
tool builders.
our findings in studying common compiler error types and their fix time shed light on the areas where tool builders can provide the most benefit for developers.
for ci community we found projects that incorrectly configured ci but never fixed the configuration problem and projects that configured ci to perform compilation at later phases at a cost of a longer build time.
this shows that travis ci s configuration flexibility may have negative effects.
hence training or automated configuration tools are needed to lower the entry barrier of ci or take the full advantage of ci.
besides tools are needed to automatically predict and suggest when to build projects to ensure fast integration and low time overhead and to parse build logs to automatically locate compiler errors in failed or even passed builds.
for compiler community we found that some compiler errors were falsely reported and some error messages failed to report precise error positions or hints.
based on such cases designers can find hints to build more powerful compilers.
besides ide developers can use our fix patterns to enrich their fix suggestions.
researchers.
this study highlights the needs for researchers to propose new techniques to automatically debug locate or fix common compiler errors which can be helpful to developers.
considering the recent advances in automatic program repairing we believe there is a high potential of fixing compiler errors.
along this line santos et al.
have attempted to fix single token syntax errors i.e.
some of the errors in expected andillegal.start .
our summarized fix patterns can provide them with hints on automatic fixing while our dataset of compiler errors can serve as a benchmark to evaluate fixing techniques.
moreover a systematic study of the root causes of compiler errors can be helpful.
experiences from our manual analysis suggest that interviews with developers or analyzing developers programming activities might provide good insights.
besides pro active alerting techniques should be proposed to inform developers about potential compiler errors before committing.
related work ci studies.
vasilescu et al.
analyzed the popularity of ci using github projects and found that pull requests are much more 184esec fse august tallinn estonia chen zhang bihuan chen linlin chen xin peng and wenyun zhao likely to result in successful builds than pushes.
vasilescu et al.
also studied the productivity and quality for github projects using ci and found that ci helps to merge pull requests from core members more effectively and detect more bugs by core developers.
hilton et al.
conducted a large scale quantitative study of the usage costs and benefits of ci in open source projects.
they found that ci is widely used by the most popular projects the lack of familiarity is the most common reason of not using ci and ci helps projects to release twice as often and accept pull requests faster.
hilton et al.
further studied the barriers and needs when adopting ci.
they derived three trade offs developers faced i.e.
testing speed and certainty access to the ci system and information security and more configuration options and greater ease of use.
gautam et al.
adopted clustering analysis to classify projects that follow ci practices and have distinct characteristics with respect to activity popularity size testing and stability using the travistorrent dataset from projects.
besides industrial case studies e.g.
were reported with respect to the adoption of ci and corresponding lessons learned.
recently vassallo et al.
analyzed whether and how the adoption of ci has changed the way developers perceive and adopt refactoring and bernardo et al.
studied how ci has affected the time to deliver merged pull requests.
these studies discuss the overall relationships between ci and software development but are not designed to look into the details of ci builds.
instead our study is focused on one of the most frequent types of build failures i.e.
compiler errors.
ci build failures.
miller s seminal work on ci build failures in microsoft products categorized build failures into compilation unit tests static analysis and server failures .
rausch et al.
studied ci build failures in github java projects and found failure types.
they reported that testing code quality and compilation are the most frequent types.
vassallo et al.
compared ci build failures in java open source projects and projects in an industrial organization.
their results showed that testing compilation and dependency are the most frequent failure types for open source projects and testing release preparation and static analysis are the most frequent failure types for industrial projects.
these studies inspired us to specifically focus on compiler errors as they showed the significance of compiler errors in ci.
instead of classifying failure types kerzazi et al.
investigated the impacts circumstances and factors of build failures by analyzing builds in a large software company in a period of six months.
they showed that build failures cost more than .
man hours are mostly caused by missing files accidental commits and missing transitive dependencies.
gallaba et al.
analyzed the noise in build data.
they found that of passing builds had an actively ignored failure while of builds had a misleading or incorrect outcome.
instead of analyzing all build failure types together we focus on one specific failure type in this study.
hassan et al.
studied the feasibility of automatic building using github projects and analyzed the root causes of build failures.
another similar work was studied by tufano et al.
.
however they both targeted traditional build environments but not ci.
thus they run default build commands of build tools to generate build logs but we collect real life build logs from travis ci servers.
compilation in ci.
our work falls in the compilation step of ci and the closest study is by seo et al.
.
they investigated failurefrequency error types and fixing efforts of compilation using .
million builds produced in nine months by thousands of java and c developers in google.
different from industrial projects opensource java projects are used in our study.
moreover we analyze the frequency and error types across three aspects and summarize the fixing patterns of common compiler errors but they only analyzed fix patterns for cant.resolve errors.
static analysis in ci.
zampetti et al.
studied how static analysis tools are used in ci pipelines using github projects.
in these projects seven static analysis tools are used build failures caused by static analysis are mainly related to adherence to coding standards and build failures related to detected potential bugs or vulnerabilities occur less frequently.
usage of static analysis tools in open source projects has been widely studied e.g.
whose results may not hold in ci.
these studies are focused on the static analysis step in ci but we focus on the compilation step.
testing in ci.
beller et al.
studied the testing adoption in ci using github projects.
they reported that only around of projects never include testing in ci failing tests are the dominant reason for build failures programming language has a strong impact on the number of tests and test failures and multiple integration environments help to uncover more test failures.
labuschagne et al.
investigated the cost and benefits of regression testing in ci using github projects.
among the non flaky test failures are caused by bugs which can be seen as the benefits and are due to incorrect or obsolete tests which represent the maintenance cost.
moreover several advances have been made on studying ways to improve testing in ci .
these studies target the testing step in ci and we study the compilation step.
failure build repair.
recently researcher have studied automatic methods to repair build failures.
hassan and wang proposed to repair build scripts using fix patterns extracted from existing build script fixes using predefined fix pattern templates.
vassallo et al.
provided repair hints by summarizing failed build logs and linking stackoverflow discussions.
macho et al.
targeted dependency related build failures and summarized three strategies i.e.
update version delete dependency and add repository to repair them.
santos et al.
applied n gram and lstm models to fix single token syntax errors which is useful especially for novice programmers .
gallaba et al.
studied how ci features in configuration files are used and misused and derived four anti patterns.
they also developed tools to detect and remove these anti patterns in ci configuration files.
we believe our study can shed light on automatic repairing of compiler errors.
conclusions in this paper we present a large scale empirical study to characterize and understand the compiler errors that break ci builds of opensource projects.
our findings provided practical for developers tool builders and researchers.
in future we plan to investigate how to automatically fix compiler errors.
our dataset with the more complete analysis results are released at acknowledgment this work was supported in part by the national key research and development program of china 2016yfb1000801 .
185a large scale empirical study of compiler errors in continuous integration esec fse august tallinn estonia