impact of developer turnover on quality in open source software matthieu foucault u. of bordeaux labri france mfoucaul labri.frmarc palyart ubc canada mpalyart cs.ubc.caxavier blanc u. of bordeaux labri france xblanc labri.fr gail c. murphy ubc canada murphy cs.ubc.cajean r my falleri u. of bordeaux labri france falleri labri.fr abstract turnover is the phenomenon of continuous in ux and retreat of human resources in a team.
despite being well studied in many settings turnover has not been characterized for opensource software projects.
we study the source code repositories of ve open source projects to characterize patterns of turnover and to determine the e ects of turnover on software quality.
we de ne the base concepts of both external and internal turnover which are the mobility of developers in and out of a project and the mobility of developers inside a project respectively.
we provide a qualitative analysis of turnover patterns.
we also found in a quantitative analysis that the activity of external newcomers negatively impact software quality.
categories and subject descriptors d. software engineering d. .
software engineering metrics process metrics keywords mining software repositories qualitative analysis software metrics .
introduction throughout the evolution of a project the team contributing to it evolves with collaborators joining leaving or changing their role in the project.
this phenomenon of continuous in ux and retreat of human resources is called turnover .
turnover has been studied in managerial science and human computer interaction research with several theories regarding its impact.
the most common theory holds that turnover has a negative impact on performance and on the quality of the work due to a loss of experience .
other theories suggest that turnover has a positive impact since the most dissatis ed members leave the team andthat only the most motivated ones stay in it helps renew experience and knowledge on the team and increases social interactions .
in the software development context developer turnover has been analyzed by mockus on one industrial project.
he found that developers leaving the project had a negative impact on quality but that new members had no e ect on it.
our work extends these ndings made on an industrial software project by looking at ve large open source software projects.
these projects are interesting to study given their extensive use and low barriers to entry and exit for collaborators .
to study turnover in open source we introduce activity metrics that measure external and internal turnover.
by splitting a software project into di erent modules we are able to measure not only the arrivals and departures of developers from the project i.e.
external turnover but also the movement of developers within the project i.e.
internal turnover .
based on the concepts we de ne in this paper we quantify the level of turnover both external and internal in opensource software projects.
we quantify turnover by measuring the amount of changes performed in the source code by newcomers or leavers instead of measuring the actual number of developers joining or leaving as there is a great disparity between developers in open source projects.
we then perform an empirical study on large open source projects angular.js ansible jenkins jquery and rails to provide insights on the relationship among developer turnover and software quality where quality was measured based on the density of bug xing commits.
the extraction process for bug xing commits is performed manually to reduce the risk of errors produced by automatic approaches thus limiting the number of projects that can be considered in this paper.
we provide the following contributions for the ve opensource projects mentioned above we provide a curated set of bugs.
we provide metrics to measure turnover.
we show the importance of the turnover phenomenon in open source projects.
we observe several trends of internal and external turnover.
we show that there is a relationship between turnover and quality of software modules.
this paper is structured as follows section presents the theory and related work.
turnover metrics are de ned in this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... 829section .
our research questions are detailed in section and the methodology we used to build our dataset in section .
our results are then presented in section .
section presents an overview of the main threats to the validity of these results and nally section concludes and presents trails for future work.
we produced a replication package which allows to reproduce and extend the results presented in this study.
this package which has been successfully evaluated by the replication packages evaluation committee and found to meet expectations is presented section .
.
theory related work as the literature contains di erent and sometimes contradictory opinions on turnover we rst describe all its possible interpretations.
we then present existing work on turnover in collaborative communities and nally research speci c to software development.
.
turnover perception member turnover initially de ned as the rate at which individuals leave a project can be extended to all the changes made to the development team of a project.
these modi cations of the team can be either external i.e.
a member leaves or joins the team or internal i.e.
a member changes her role in the team .
distinct theories regarding the impact of turnover whether it is external or internal suggest that it has both positive and negative aspects on a team.
.
.
external turnover the most common vision holds that external turnover negatively impacts employee performance .
departures lead to a loss of experience and knowledge but also disrupt the social network and environment of those who remain .
moreover it induces devoting resources and time to recruit and train new employees.
a second vision considers turnover as a good opportunity for organizations as leavers are those most dissatis ed with the current organization and those who remain enjoy better conditions and performance .
a last perspective sees moderate levels of turnover as the best organizational performance .
when there is no turnover experience and knowledge are not renewed and become obsolete and parochial .
introduction of new people is a solution to overcome this situation as their vision is less established and less redundant with respect to the knowledge possessed by the current team.
.
.
internal turnover internal turnover was de ned in traditional organizations as the number of employees who changed function within an organization .
motivations behind such actions are opportunities for career moves to increase income and autonomy as well as getting new responsibilities and expressing new skills .
kanter et al.
pointed out that members had lower aspirations and involvements in their work when mobility was blocked .
thus internal mobility is commonly supported to maintain members commitment to the organization.
.
turnover in collaborative platforms turnover has been studied in online communities and collaborative platforms where participants are free to enter or leave at any moment without any cost.
in the englishwikipedia high turnover is even the norm with sixty percent of editors contributing only for a single day .
ransbotham et al.
suggested that collaboration success can be reached thanks to moderate levels of turnover provided that the level of novel knowledge exceeds the loss of existing knowledge held by departing people.
similarly dabbish et al.
discovered that membership turnover might bring fresh levels of activity and liveliness in a community which leads to increased participation .
inversely qin et al.
observed that departures of wikiprojects contributors has a negative e ect on the community and causes social capital losses .
.
turnover in software development developer turnover in open source software projects was studied mainly to understand developers motivations to contribute.
yu et al.
suggested that personal expectation plays a role in project retention and that turnover is partially explained by dissatisfaction .
hynninen et al.
conducted a survey with developers and suggested that their departures from a project can be a manifestation of low organizational commitment .
a study from schilling et al.
unveiled that the level of development experience and knowledge is strongly associated with retention .
according to sharma et al.
past activity age and size of a project as well as developer tenures are important predictors of turnover .
these observations are consistent with other classical theoretical models related to job satisfaction .
measures of knowledge loss were suggested by izquierdocortazar et al .
these measures include the evolution of orphan lines of code lastly edited by a developer who left the team.
they showed that while in some projects developers devote e orts to maintain code introduced by former developers in others they seek to eliminate such code.
robles et al.
designed a methodology to compute generations of joining and leaving developers .
finally fronza et al.
propose a wordle to visualize the level of cooperation of a team and mitigate the knowledge loss due to turnover .
hall et al.
conducted a survey with practitioners to unveil that turnover may be related to project success but however did not de ne turnover metrics computable by analyzing the history of the project .
mockus found that while departures of members impact the software quality because of the loss of knowledge and experience newcomers are not responsible for an increase of defects possibly because they are not assigned to important changes .
mockus also found a relationship between turnover and productivity in commercial projects .
mens et al.
explored developer turnover in the gnome ecosystem with concepts and metrics similar as the ones we use in this paper .
they looked at developer turnover at a coarser grain in their study internal turnover refers to the mobility of developers between projects of the gnome ecosystem while external turnover in their case was associated to developers entering or leaving the gnome ecosystem.
our study di ers from theirs as it we look at a ner granularity we measure mobility of developer between modules of a project and in and out of a project.
in their study they sought for possible patterns of developer turnover with the conclusion that this is a highly project speci c phenomenon.
they did not seek for a relationship between turnover and code quality.
830alice bob jane alan m1 m1 m2 m2 p2 p1s0 s s 1figure example of ctive software project containing two modules.
.
turnover metrics a software project can have many kinds of turnover.
to be able to study di erent aspects of turnover we introduce ve metrics that can be computed from the source code history of a software project.
.
setup and requirements in order to compute turnover metrics we need to de ne the periods over which turnover will be computed as well as how contributors are identi ed.
.
.
period selection we compute developer turnover by comparing the contributors of software modules in two consecutive time periods p1andp2.
these two periods are therefore delimited by three snapshots of the project history s0 s 1ands such that p1is delimited by s 2ands 1and that p2is delimited by s 1ands0 see figure .
in practice s0is the snapshot for which we want to compute turnover metrics.
the selection of the two other snapshots can be based on di erent approaches.
one could consider either the prior releases of the software snapshots such that periods p1andp2have the same duration or snapshots such that periods p1andp2have the same overall activity in the repository.
we study in section the impact of these choices on turnover computation.
.
.
software modules and contributors developer turnover is relative to the software project s structure.
a developer who has only worked on a few modules in the system that suddenly contributes to more should be considered as new or inexperienced as she moves to new parts of the code base.
we therefore consider that a software project is composed of a nite set mof software modules developed by a nite set of developers who submit their code modi cations by sending commits to a shared code repository.
each module is de ned by a nite set of source code les.
when a developer modi es one of the les of a software module by committing her work she is contributing to that module.
a developer contributes to the software project as soon as she contributes once to any module of the software.
to illustrate all our de nitions we rely on the ctitious software depicted in figure which is composed of two modules developed over two periods p1andp2.
a total of four developers participated to this software between the s 2ands0snapshots.
given a module m dm p is the set of developers who made at least one contribution to mduring the period p.we obtain with our example dm2 p1 fbob janegand dm2 p2 fbob alang.
dtis the set of developers who made at least one contribution to the software during the period t i.e.
dp ms mdm p. from our example we have dp1 falice bob janegand dp2 fbob jane alang.
.
turnover actors and metrics we now provide formal de nitions for the sets of developers involved in turnover and the metrics associated to them.
we consider two kinds of developer turnover external and internal turnover.
the developers involved in each kind of turnover are considered to be either newcomers or leavers.
finally we de ne stayers i.e.
the developers contributing to both studied periods.
we consider as newcomers the developers who joined the team of a module in the period p2 whereas leavers are the developers who left the team of a module within the period p1.
this di erence between the periods is due to the fact that the intent of our metrics is to evaluate the impact of turnover on the quality of the software at the s0snapshot.
thus newcomers of the p2period may in uence its quality as their rst contributions on a module were between s ands0 and leavers of the p1period may in uence its quality as the loss of knowledge their departure induce will be perceptible after they left i.e.
after the s 1snapshot.
.
.
external turnover external turnover refers to the movement of developer in and out of a project.
external newcomers of a module mare the developers who contributed to the module between s 1ands0 but did not contribute to any module of the project between s 2ands i.e.
during the p1period .
the set of external newcomers is noted enm p p2and is computed as follows enm p p2 dm p dp1 in figure we observe that alan is a newcomer in m2 and that he did not work on any module during p1.
he is therefore an external newcomer and thus enm2 p1 p2 falang.
external leavers of a module mrefer to developers who worked on the module during p1but did not contribute to the project at all in p2.
the set of external leavers is noted elm p p2and is computed as follows elm p p2 dm p dp2 we observe that only alice contributed to m1 during p1 but was inactive on the project in p2.
consequently elm1 p1 p2 faliceg.
.
.
internal turnover internal turnover refers to movements of developers inside a project.
even though some developers contribute to a project in both periods p1andp2 they may not work on the same modules in the two periods.
internal newcomers are the developers who contributed tominp2 but not in p1.
however they contributed to at least one other module than min this period.
they are noted inm p p2and are computed as follows inm p p2 dm p dm p dp1 831following the previous illustrations we obtain here inm1 p1 p2 fjanegandinm2 p1 p2 .
internal leavers refer to developers who ceased to contribute to a module mbut are still active in the project.
this set is noted ilm p p2and is computed as follows ilm p p2 dm p dm p dp2 we observe that only jane modi ed m1 during p2but not in p1 while working on m2 during p1.
consequently ilm2 p1 p2 fjaneg.
.
.
stayers finally stayers are the developers who contributed to a module min both p1andp2.
we de ne the set of stayers for a given module as stm p p2 dm p dm p .
.
metric definitions the intention of our metrics is to quantify the impact that the di erent turnover actors may have on a module s quality at the snapshot s0of the project.
due to the large inequalities in the involvement of developers in open source projects we cannot quantify turnover by counting the number or ratio of developer in each of the categories de ned above.
filtering the developers by considering only core or paid contributors is not a viable alternative either.
indeed peripheral developers as a group still produce a signi cant amount of contributions and ignoring these contributions may signi cantly impact our measurements.
therefore to measure the impact that each category of turnover actors have on the source code we use the activity of developers i.e.
the amount of source code they produce.
for a given module m developer dand period t we de ne am d t as the activity of the developer which we measure using the code churn i.e.
the number of lines of code added or deleted by can be measured with the number of le modi cations she performed on the module or the code churn i.e.
the total number of lines added or deleted of such modi cations.
in this paper we only present results obtained using the code churn as an activity measure.
however results obtained with the number of modi cations are similar and are available online see section .
the ve metrics we de ne are the internal and external leavers activity ila and ela resp.
the internal and external newcomers ratio ina and ena resp.
and the stayers activity sa ila m p p2 x d2ilm p p2am d p ela m p p2 x d2elm p p2am d p ina m p p2 x d2inm p p2am d p ena m p p2 x d2enm p p2am d p stam p p2 x d2stm p p2avg am d p am d p .
research questions to the best of our knowledge we found no previous study that looked at trends of developer turnover in open sourcesoftware projects.
hence the rst objective of our study is to seek for such trends starting with a global view of turnover at the project level and then focusing on developer turnover on module thanks to the metrics previously de ned.
more formally we seek to answer the following two research questions rq1 using the concepts of external newcomers and leavers at the project level is turnover an important phenomenon in terms of number of developers involved in open source software projects?
rq2 looking deeply into the project at the module level is there any patterns regarding the contributions of persistent internal and external developers?
by answering the aforementioned research questions we provide an overview of developer turnover both at the project and at the module levels.
we then go further by exploring the relationship between developer turnover at the module level and software quality which we measure based on bugx information.
we then answer the following research question rq3 using the turnover metrics at the module level is there any relationship with the quality of the software modules?
.
dataset construction although many automatic techniques are often used to build large datasets they are all imprecise to a certain extent.
instead of having a dataset with dozens of project containing approximate measures we chose to focus on the reliability of the information extracted from the dataset.
in particular to answer our research questions our dataset must meet several requirements the author of each contribution must be clearly identi ed.
the source code of the project must be organized into modules.
a measure of quality must be available for each module.
each of these criteria is addressed in current research and software engineering researchers are still developing techniques to extract reliable information from software repositories as we detail below.
.
authors identification centralized vcs.
the rst issue regarding the identi cation of authors is related to the version control system vcs used by the project.
in centralized vcss such as subversion a developer must enter her credentials to commit her code to the central repository.
given the large number of contributors to opensource projects assigning credentials to each of them would be unwieldy and contributions are therefore submitted via patches and applied by core developers who have credentials for the repository.
this issue is xed by the use of decentralized vcss such as git which are able to distinguish the original author of a commit and the developer who added it to the main repository i.e.
the committer .
however automatically selecting a large number of git repositories from hosting 832platforms such as github would not be a suitable process in our case as a non negligible amount of large git repositories are simply mirrors of subversion repositories.
well known examples of such repositories include the gcccompiler project or most of the projects hosted by the apache software foundation eg.
the httpd server .
moreover even if a project currently uses git as a vcs it may not have been so for all its development history.
it is not uncommon for a project especially older projects to migrate its code base from one vcs to another throughout its history.
this is the case of two projects selected in our dataset rails and jenkins which originally used subversion and then migrated to git.
we manually searched commit messages for contents such as patch sent by alice to determine if at one point these projects were still using subversion or if they did migrate to git and only include the history subsequent to this migration in our analyses.
identity merging.
even when the identity of each contribution s author is reliable it is possible that a single developer has several identities in the vcs because of typos changes in the conguration of the git client or a change of email address for instance.
this issue is addressed by identity merging for which goeminne and mens address a comprehensive review .
following their recommendations we use a semiautomatic process which is based on their simple algorithm which has a very high recall.
to counter the low precision of the algorithm we manually review the results of the identity merge algorithm and remove false positive merges.
.
quality measurement our study aims to evaluate the quality of project modules for a given snapshot.
in most software engineering studies the quality of software projects is assessed by looking at the number of bugs xed by the developers.
bug fix identification.
in order to measure the amount of these bugs the stateof the art technique used in studies mining software repositories consists in parsing the commit messages looking for the identi er of a bug stored in the project s bugtracker e.g.
bug .
however recent work raised concerns regarding the precision and recall of this automatic process due to the misclassi cation of issues in the bugtrackers or imprecision of algorithms linking bugs to source code .
some approaches remove these concerns by only considering information stored in the vcs and assume that the number of bug xing commits is a fair representation of the actual number of bugs within a software module.
unfortunately to the best of our knowledge no automatic approach has a satisfactory precision to produce reliable statistics.
for instance among the best automatic approaches the ones developed by tian et al.
and mockus et al.
have a precision of only and respectively in the evaluated benchmarks which in our case would have unpredictable effect on the number of bug xing commits identi ed and would be a non negligible bias to our study.
as we did not nd a suitable automatic approach we chose to manually analyze commits to constitute our dataset to the detriment of the number of projects that we were ableto include in it.
our manual approach therefore aims to identify commits that are true bug xes.
maintenance branches.
to have measures which are representative of the quality of the code at a given snapshot or release we need to isolate post release bug xes from development bug xes.
postrelease bug xes for a snapshot s0are commits that x a bug which was in the project s code at the snapshot s0 while development bug xes performed after the snapshot s0may have been introduced between the snapshot s0and the time of the bug x. if the development history of a project is linear i.e.
if all the commits are performed on a single branch isolating one category of commits from the other may be cumbersome and imprecise.
therefore another constraint is added to the projects to include in our dataset the release s0must have a dedicated maintenance branch sometimes called long time support or lts branch where the only commits performed in it aim to improve the code quality of the release s0.
these maintenance branches di er from development branches.
they usually do not contain new features.
the operations performed in such branches are mainly bug xing documentation optimizations or compatibility updates related to third party dependencies e.g.
the xmaintenance branch of rails contains updates related to new versions of the ruby programming language .
moreover we restrict our search to maintenance branches where no commit was performed for the past six months in order to have branches where most of the bugs were had time to get xed.
bug fix classification.
our de nition of a bug xing commit includes any semantic changes to the source code which xes an unwanted behavior.
the type of bugs considered includes any arithmetic or logic bug e.g.
division by zero in nite loops etc.
resource bugs e.g.
null pointer exceptions bu er over ows etc.
multi threading issues such as deadlocks or race conditions interfacing bugs e.g.
wrong usage of a particular api incorrect protocol implementation or assumptions of a particular platform etc security vulnerabilities as well as misunderstood requirements and design aws.
we identi ed bug xing commits manually discarding commits where new features are implemented.
we choose to ignore commits where performance optimizations are performed as we consider performance issues as a di erent aspect of code quality.
moreover we also ignore commits that resolve compatibility issues due to the evolution of a thirdparty dependency as these bug xes are not due to the lack of quality of the changed code but to the modi cation of an external requirement.
finally it occurs that bug xing commits are lated discarded by the developers due to a regression introduced by the bug x. in such cases the developers perform a revert operation of such commits and we ignore both the revert and the reverted commits.
we consider that bug xing commits are atomic in the way that we do not consider the possibility that a bug xing commit may in fact include two bug xes.
moreover if a bug xing commits a ects two modules the number of bugxing commits will be incremented in both modules.
.
code modularization in this study we use metrics that target software modules.
breaking a software system into modules is known to be a hard task that requires some subjective choices .
we consider two heuristics for determining software modules such as its organization within les and directories or the co change activity.
we present here the di erent sets of modules based on these heuristics.
.
.
using the directory structure the rst modularization approach we consider is based on the directory structure of the system in which software modules are de ned to be either a le or a directory with the possibility to include or not its subdirectories.
we chose not to simply extract a modularization based on the directory structure instead we manually inspected the directory structure of each project to select a suitable level of granularity so that a module includes similar features based on le and directories names and on the information found in projects con guration les.
to overcome the bias of having a single judge for the module decomposition we asked three members of our research group three phd students in software engineering to provide for each of the ve projects in the corpus a list of software modules.
the three judges then met to merge their results.
they agreed on the granularity of most of the modules of projects such as jquery angular.js and ansible while agreement on jenkins and rails was initially reached by only two judges the third one having chosen a coarser granularity.
as the decisions made by the judges may be di erent than the developers of the projects we tried to contact their core developers to con rm our decompositions using the o cial mailing lists and or irc channels of each project.
unfortunately we did not obtained any answers.
.
.
using the co change activity the second modularization technique we use considers that source code les that are changed together i.e.
in the same commit belong to the same module regardless of the directory structure of the project.
we use an automated process that consists in building the co change graph of the project which is a weighted undirected graph where each vertex is a source code le of the project and the weight of an edge is equal to the number on commits where both les were modi ed together.
to determine the modules we used two algorithms aiming at building communities in a graph .
both algorithms produced a relatively low number of modules less than ten in the projects developed in javascript angular.js and jquery which is due to the fact that javascript projects tend to have fewer larger les compared to projects in languages such as java.
therefore these decomposition allow to produce statistical results on only three projects.
as the results obtained with this modularization algorithms are similar to the ones obtained with the manual decomposition based on directories structure they are not presented in this paper.
however they are available in our additional results online see section .
.
periods selection the computation of turnover metrics for a snapshot s0 relies on the choice of two periods p1andp2 figure .
to choose a suitable size for the periods p1andp2 we measured the impact of these periods on the sets of turnoveractors i.e.
internal and external leavers and newcomers .
the length of the periods p1andp2may impact the resulting sets of actors especially if the periods are too short in which case we may consider as newcomers or leavers developers who stopped contributing to the project for a period of time before re starting.
to assess the impact of this choice we have tested four con gurations for the lengths of the periods one release based con guration where s0 s 1and s 2are three following releases of the project and three time based con gurations where p1andp2both last for and months.
usingjp1j jp2jmay limit our vision in the past.
this may for example result in considering some developers as newcomers because they were inactive for sometime but the length of p1is not su cient to see their previous contributions.
on the other hand if we looked at the whole history of the project to check whether developers are newcomers or leavers we may consider as stayers developers who did not contribute to the project for several years.
to quantify the impact of the length of p1andp2 we compute two versions of each turnover set a version with limited visibility wherejp1j jp2j.
a version with full visibility where s is the beginning of the git repository when computing the sets of newcomers.
s0is the most recent release available in the project when computing the sets of leavers.
to decide which period size is suitable for our analyses we chose to measure the similarity between sets of turnover actors computed with limited and full visibility using the sorensen dice quotient of similarity which is equal to when two sets are identical and when they are disjoint .
the selected period size is the rst period size where the median dice coe cient is for all projects and actors sets above a threshold of .
the distributions of dice coe cients obtained for each project are available online see section .
for each period sizejpj project and category of turnover actors e.g.
external newcomers we have a distribution of dice coe cient as we computed one dice coe cient for each module.
these distribution show that with a period of one month several sets of developers have large di erences between limited and full visibility the worst case being with angular.js where sets of external newcomers computed with limited visibility have no intersection with sets computed with full visibility.
withjpj months the distributions are closer to a dice coe cient of but there are still cases where the median dice coe cient is below the threshold of especially with internal turnover.
with jpj months most of the sets of turnover actors are identical whether we use limited or full visibility.
only few modules have a dice coe cient of zero and the median dice coe cient for all projects and categories of turnover actors is above the threshold of the release period con guration is not stable as the length of time between two releases depends on the roadmap of the project and on the features that are developed.
therefore we chose to use the months period for the remainder of our analysis all the results presented in this paper consider that jp1j jp2j months.
.
resulting dataset our dataset listed in table includes ve projects written in four di erent programming languages.
the selected 834table the projects included in our dataset.
project language release bug xes loc modules s0 angular.js javascript .
.
ansible python .
.
jenkins java .
jquery javascript .
.
rails ruby .
.
releases are minor releases i.e.
no breaking changes have been performed in the selected development period in ansible jquery and rails.
they are major release in angular.js and jenkins.
the selected releases are with the exception of the one in ansible considered to be long term supported lts releases.
for these lts releases bug xing commits are backported from the main development branch even after subsequent releases are available.
in ansible although the maintenance of the .
.x releases stopped a couple of week before the availability of the .
.
release it was performed simultaneously with the development of the .
.
release.
this dataset is available online see section and can be reused for future studies.
.
results .
turnover at the project level rq1 in order to characterize developer turnover at the project level we look at the number of external newcomers external leavers and stayers during the life of each project.
developers volatility.
since we de ned jp1j jp2j months we compute the di erent sets of actors by starting with s0 months after the earliest version of the project when we know that git was used as a vcs and move s0toward the end of the project by steps of two weeks.
the resulting numbers are presented in figure .
we can observe two types of phases during the life of a project.
the rst phase that we call the enthusiastic phase can only be seen in angular.js and ansible since we are missing the beginning of the other projects as we excluded from the study the period when they were using svn.
during the enthusiastic phase for angular.js and for ansible the number of newcomers is constantly superior to the number of leavers.
at some point projects switch to the second phase that we call the alternating phase where either the number of newcomers or leavers is higher than the other one.
in all projects the number of newcomers and leavers is quite high.
throughout the histories of these projects at least of developers are either newcomers or leavers.
overall this con rms that turnover in open source software projects is an important phenomenon.
stayers conversion and motivations.
the number of stayers increase mainly during the enthusiastic phase and stay fairly stable during the alternating phase.
to further understand the evolution of the population of stayers we use the notion of conversion rate that is usually found in marketing.
in our case the conversion raterepresents the proportion of newcomers that the project was able to keep long enough so they could become stayers.
it is equal to the number of developers who were at least once stayer divided by the number of developers in the whole history of the project we look at.
the conversion rates for each project are between ansible and jenkins and jquery .
even if it is not in the same proportion for each project we observed that only a low ratio of newcomers become stayers.
to better understand what make developers stay in their project we looked at the top stayers of each projects developers who were in the stayers set the highest number of times over the project history.
we searched their github and linkedin pro les as well as their personal web pages to understand their motivation.
we found four categories developers who are paid by the company that develops the project.
for example out of the top stayers of angular.js work at google which maintains the framework.
developers who are paid by a company that use the project for their business.
it is the case times in the top stayers of ansible.
developers who are consultants on the technology developed within the project.
for example out of the top stayers of rails are consultants.
developers who contribute on their spare time without direct or indirect nancial interest.
out of the top stayers we looked at only t that category.
in conjunction to these categories developers were sometimes also the initial creators of the project developers out of .
.
patterns of contributions rq2 the visualizations in figure represents the turnover metrics1computed withjp1j jp2j months and where the s0snapshots are the releases mentioned in table these releases are also indicated in figure via vertical lines .
we use these visualizations to observe the di erent patterns of contributions.
in angular.js most of the activity is due to stayer or external leavers.
the high amount of external leavers activity is in fact due to the contributions of a single developer a major contributor who was inactive in the six months prior to the release of angular.js .
in ansible all categories of developers have similar levels of activity and all contributed to a wide range of modules.
this di ers from other projects especially for external newcomers all but one module has external newcomers and these developers often have an important activity.
we looked more closely at the module where external newcomers were the most active which is the module containing cloud plugins for ansible.
among the newcomers making the most contributions one was hired at ansible inc. and two worked at rackspace a managed cloud computing company and developed an ansible plugin for the rackspace cloud storage.
these developers were most probably paid to do their contributions which explains this high level of activity not present with most of the newcomers.
the last three projects jenkins jquery and rails exhibit the same patterns.
in these three projects internal newcomers are active in most of the modules while exter1figure also contains information related to bug xes which are discussed in the next research question.
700angular.js 700ansible 120jenkins 80jquery 800railsfigure evolution of developer turnover.
the plain blue line on top represents the total number of developers the plain purple line on the bottom the number of stayers the green dotted line the number of external newcomers and the red dashed line the number of external leavers.
total a ina ena ila ela sta bugfixesangular.js total a ina ena ila ela sta bugfixesansible total a ina ena ila ela sta bugfixesjenkins total a ina ena ila ela sta bugfixesjquery total a ina ena ila ela sta bugfixesrails figure visualization of developers activity and the quantity of bug xes for each module.
each horizontal line of blocks represents a module.
the darker the color the higher the metric value.
nal newcomers and leavers are more focused and do not contribute to more than half of the modules.
overall there is no module that was changed exclusively by external newcomers.
in all the projects of our corpus the external newcomers always contributed to modules with either internal internal or permanent developers.
.
developer turnover and software module quality rq3 to answer our third research question related to the relationship between module turnover and software quality we use the bug related information extracted from our dataset same con guration as rq2 for p1andp2 .
we perform spearman correlation tests between each turnover metric and our quality metric.
the quality metric we use is the density of bug xes per module i.e.
the number of commits that xed bugs divided by the size of the module .
these bug xes are extracted from the maintenance branch associated to s0 meaning that there is a high probability that they indeed x defects that occur in s0.table presents the results of these correlation tests for each project and metric.
correlation coe cients vary from to which corresponds to a perfect negative and positive correlation respectively.
also a correlation coe cient of reveals an absence of correlation.
we used bootstrap with thebca statistic to compute con dence intervals of the correlation coe cients .
if both ends of a con dence interval are either positive or negative results highlighted in bold this means that there is a strong probability that there is a positive or negative correlation respectively between the turnover metric and the density of bug xing commits.
to have a deeper understanding of the observed correlations figure presents a graphical visualization of the turnover metrics and the number of bug xes.
in that figure each project is presented by a matrix where each column represents a metric and each line represents a component of the project.
the cell of the matrix then represents the value of the corresponding metrics and darker colors represent higher values.
836table spearman correlation coe cients between turnover metrics and the density of bug xing commits per module.
con dence intervals are computed using bootstrap.
project ina ila ena ela sta overall activity angular.js ansible jenkins jquery rails the most important information in the results presented in table is that there is a positive correlation between the external newcomer activity and the density of bug xes.
almost all of the projects exhibit a quite strong correlation.
only ansible exhibits a weak correlation but looking at figure this is certainly due to the fact that external newcomers contributed to almost all of the components even to the ones that were not the target of bug xes.
this is consistent with the theories exposed in section which suggest that external turnover has a negative e ect on the quality of a team s work.
external leavers activity on the other hand do not show any statistically signi cant correlation with bug x density in table and the two columns seem completely independent in figure .
although table shows three statistically signi cant correlations between the internal leaver and newcomer activity and bug xes their interpretation when looking at figure is unclear.
as discussed with the previous research question internal newcomers contribute to the majority of the modules even the ones without any bug x. finally as expected there is a correlation between the activity of persistent developers and the density of bug xes.
this then raises the question of the relative importance of the turnover metrics regarding the software quality and especially for the external newcomer activity ena metrics as there is no correlation of the internal turnover metrics.
to measure how important is ena we therefore built multiple linear regression models including other metrics such as the size of modules or the number of developers who contributed to it.
unfortunately it did not produce exploitable results due to the low r squared of the resulting models and multicollinearity issues exposed by high variance in ation factors of the predictors.
we therefore cannot provide sound answer to that point.
.
threats to v alidity the validity of the results presented above is exposed to several threats that we present here.
.
external validity the generalization of the results is our rst concern.
on one hand we selected projects that use di erent programming languages and that have hundreds of developers.
on the other hand the study was performed on only ve projects that were manually selected.
to overcome this threat further studies have to be performed to con rm and improve the ndings presented in this paper.
a barrier to achieve these studies is to build curated datasets following the requirements presented in section .
.
internal validity our metrics assume that the only way developers contribute to a project is by modifying its source code.
this is an approximation as developers can modify other les such as build and documentation les.
a project is not con ned to its version control system other types of repositories such as bug tracking system or mailing lists might reveal that some developers considered as newcomers or leavers might be in fact persistent contributors of the project.
turnover metrics based on multiple kinds of repositories are left for future work.
it should be noted that our results should not be interpreted as if external leavers and newcomers developers introduced more bugs than internal.
we do not provide or have any information on who introduce bugs because there is to the best of our knowledge no reliable algorithm that can identify the author of a bug.
we did not nd a reliable way to identify developers with push rights to the repositories.
hence we could not determine the impact of this feature on the di erent patterns of turnover.
however it should be noted that the projects in our dataset mainly follow a pull request work ow a popular approach on github .
with this work ow even if a developer has push rights she will create a pull request in the project when making a contribution to bene t from the review mechanism.
thus except for the developers in charge of merging the pull requests the other core members do not need to have push rights.
.
construct validity in addition we identify several threats to construct validity from the previous study.
on github developers can submit pull requests so that the project leaders who have write permission on the repository can add their contributions to the project.
as the identity of the initial author is maintained through the pulloperation she is identi able even though she does not have access to the main repository.
however as shown in it may happen that a developer discussed with a pull request author to agree on its acceptance.
even though this developer spent time to x or improve the pull request content all the credits will go to the pull request author.
this may also introduce a bias in the results.
identifying software modules in a project is not a straightforward task and might be subject to interpretation.
since we could not get the con rmation from the di erent development teams some modules in our decomposition might be split or merged in comparison to what the development teams would have de ned.
related to the same threat the quality of the software architecture can have an impact on the metrics.
retention 837could appear higher in well modularized systems than poorly designed systems where one x might require changes to many modules.
the fact that the results produced with the decomposition based on co change activity overlaps strongly with the manual decomposition based on directories shows that the impact is negligible for this dataset.
we deliberatively did not rely on the information provided by bugtrackers as several studies showed that their use can introduce an important bias .
the drawback of our technique is that the number of bug xing commits may not reveal the actual number of bugs that appeared in the software modules.
there may exists bugs that are tedious to x and remain to be resolved.
in addition the manual analysis has some limits due to the subjective evaluation to decide whether or not a commit is a bug xing commit.
we only went through a maintenance branch to collect such commits for each project although it potentially exists bug xing commits from the main development branch that have not been backported to the maintenance branch.
finally some bug xing commits may x bugs that were not introduced in the current release but in one of the older releases.
.
conclusion and future work in this paper we propose and investigate metrics to measure turnover in open source software projects.
our metrics measure how the structure of a group of developers is changing both internally and externally for a given period of a software project.
we used these metrics on ve opensource projects with two objectives to observe the turnover phenomenon and to evaluate its relationship with software quality.
we observed that the ve open source projects in our corpus chosen because of their popularity and success have a high turnover.
this observation disagrees with the conclusions of hall et al.
that recommend to control turnover to improve the success of industrial projects .
our results then suggest that turnover and success may have a di erent relationship in open source projects.
looking at the module level we show some very interesting turnover patterns.
these patterns reveal that the projects of our corpus act di erently regarding turnover.
for instance in some projects modules receive contributions only by internal developers with no contribution from stayers.
these patterns also show that in all projects external newcomers always work with either permanent or internal developers who hopefully supervise them.
such an observation opens the room for rules or guidelines that will de ne how newcomers should be supervised and how they should contribute to modules of a project .
we also found that external turnover has a negative impact on the quality of the modules.
this result is consistent with theories that suggest that external turnover has a negative e ect on the quality of a team s work.
however it di ers from the ones of mockus as in our case newcomers have a relationship with quality and leavers do not have such relationship while it was the opposite in mockus study.
on the other hand internal turnover has almost no e ect.
our observations therefore do not con rm the theories that suggest that internal turnover is bene cial.
these ndings can be reused by researchers when using software metrics based on the activity of developers on the source code as the activity of external newcomers has a stronger relationship withquality than the activity of other categories of developers this may be the only activity worth considering.
finally our study and ndings lead the way for many kinds of future work our ndings are based on observations made on software modules with manual observation of patterns and using correlation between the density of bug xing commits and the activity of the di erent categories of turnover actors.
as there are no related work that performed such observations on open source projects our study needs to be replicated on more projects which is facilitated by our replication package section .
the main limitation of our metrics is the fact that they require a selection of periods.
in particular we shown that the length of the chosen periods has a major impact on the measures and we therefore provide some insights showing that a time period is adequate in the case of opensource project with good results with months periods.
we then plan to overcome this limitation by developing continuous metrics for turnover where the discretization of the history is not necessary.
our results regarding turnover patterns suggest that the observed patterns are impacted by the motivation of developers which mainly depends on the fact that they are paid or not.
this hypothesis can be evaluated only if it is possible to distinguish paid contributors from volunteers.
we then plan to identify the employee of the developers and then to analyze its relationship with turnover metrics.
independently of whether developers are paid or volunteers they may be core member of the projects and thus have a higher retention level than other developers as well as a higher level of activity in the project.
identifying core members of a project may help us understanding the impact of developer turnover on software quality.
.
auxiliary material due to the space constraint of this paper part of our results are available online .
this page includes results regarding the period selection as well as more detailed versions of figure and figure .
.
replication package the dataset built using the methodology presented in section the code necessary to extract the metrics as well as additional results are available online in a replication package that has been successfully evaluated by the replication packages evaluation committee and found to meet expectations .
we describe here the technical aspects of this package the data produced by the executed software and the installation process of the replication package.
.
the diggit tool the software of our replication package relies on the diggit tool which supports analysis of git repositories and which helps manage the analysis process .
diggit manages a set of git repositories.
on each repository diggit applies several user speci ed analyses .
when all user speci ed analyses have been applied diggit applies global analyses called joins in the tool that use the results of all the previously applied analyses to produce nal results.
diggit is used within adiggit folder which contains various con guration les including the list of git repositories to clone and analyse the 838list of analyses and joins to perform and additional information that may be used by analyses.
this tool is developed in ruby by two of the authors of this paper we used version .
.
.
.
package installation and usage the replication package is distributed as a virtualbox virtual machine image.
this image is based on a minimal version of a linux ubuntu on which only the requirements to replicate the study were installed.
the list of commands required to install our replication package from a fresh install of a minimal ubuntu is also available online.
the package consists of a set of diggit analyses that are all loaded in a diggit folder in the vm image this folder can also be generated with a script .
the rst step of the replication is to clone the ve git repositories to be analyzed using the dgit clone command.
then the dgit analyses perform command allows to run for each of the cloned repositories the following analyses extraction of the number of lines of code of each le at release s0 which is used to compute bug xing commits density.
computation of the number of lines of code and the number of bug xing commits of each module the list of modules is stored in a con guration le .
computation of the activity of each developer on each module.
computation of the activity of developers at the project level.
the data produced for each repository is then aggregated by a global analysis that uses the r programming language and produces all the results presented in this paper and in the additional results available online.
.
replication data our replication package also provides data that can be reused for future studies.
it includes the information described in section which is given as input to the analyses described above and activity information which can be reused to compute other metrics than developer turnover such as code ownership for instance .
for each repository the data provided as input of the analyses is the following the author renaming information.
the lists of modules extracted with the di erent modularization techniques.
the commit id of the s0release.
the commit ids of the bug xing commits performed ins0release s maintenance branch.
this data is stored in a single json le and thus can be easily reused.
besides the nal results provided by the global analysis that are presented in this paper each analysis produces intermediary results that are stored in a mongodb database.
the data stored in this database consist in a monthly measure of activity code churn for each developer and module and each month prior to the s0release up to the start of the git history of the repository.
.