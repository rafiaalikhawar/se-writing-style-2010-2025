starts static regression test selection owolabi legunsen august shi darko marinov department of computer science university of illinois at urbana champaign usa legunse2 awshi2 marinov illinois.edu abstract regression testing is an important part of software development but it can be very time consuming.
regression test selection rts aims to speed up regression testing by running only impacted tests the subset of tests that can changebehavior due to code changes.
we present starts a tool for static regression test selection.
unlike dynamic rts starts requires no code instrumentation or runtime information to find impacted tests instead starts uses only compile time information.
specifically starts builds a dependency graph of program types and finds as impacted tests that can reach some changed type in the transitive closure of the dependency graph.
starts is a maven plugin that can be easily integratedinto any maven based java project.
we find that starts selects on average .
of tests leading to an end to end runtime that is on average .
of running all the tests.
a video demo ofstarts can be found at i. i ntroduction regression testing is an important part of software development.
after every code change a developer runs the tests in the regression test suite to ensure that the changes do not breakany existing functionality.
however when a regression testsuite contains many tests running all tests after every change often called retestall is very time consuming and slows down the software development process.
companies such as googleand microsoft have reported how expensive it is for them toperform regression testing .
regression test selection rts is a way to reduce the cost of regression testing byselecting to run only the tests impacted by the changes .
an rts technique works by finding the dependencies of each test and selecting tests that depend on the changes.
runningfewer but necessary tests speeds up regression testing while aiming not to miss any test failures.
in our prior work we used a prototype static rts tool to compare with dynamic rts which computes test depen dencies dynamically.
the results showed that static rts withdependencies computed at the class level is comparable withthe state of the art dynamic rts tool ekstazi .
theresults are encouraging showing that static rts is feasible and worthy of further research.
performing rts staticallycould be particularly useful in contexts where dynamic rtsis not feasible such as when dynamic instrumentation tocollect test dependencies breaks time sensitive tests or whennon determinism causes dynamic rts to collect wrong orincomplete test dependencies.
we present starts static regression test selection a robust tool for performing static rts.
starts constructs a dependency graph relating all types including classes interfaces and enums in an application and computes a transitive closure for each test to find its dependencies.
starts determines the types that changed by computing the checksum of each type s corresponding compiled classfile and comparingthe computed checksum with the one computed in the priorrun.
starts selects to run impacted tests which are testswhose transitive dependencies include some changed type.we made several changes to our initial prototype to make starts robust and usable on real large software projects weadded support for multi module maven projects and improvedthe speed including parsing constant pools instead of entireclassfiles saving dependencies as type to tests instead of testto types using a faster graph library yasgl instead ofjgrapht and incrementally caching dependencies.
we evaluated starts on maven based projects from github.
we find that starts selects on average .
of all tests leading to an end to end runtime consisting of thetime to select what tests to run plus time to run those tests thatis .
of the retestall time to run all tests.
starts scales well and for projects with longer running tests that take over one minute to run starts selects on average .
ofall tests leading to an end to end runtime that is only .
ofthe retestall time.
starts source code is publicly availableon github at binary code is released on maven central.
ii.
u sage starts is a maven plugin and can be easily integrated with any maven based java project.
integrating starts the easiest way to integrate starts with a project is to add the latest version of the starts plugin from maven central to the project s pom.xml file plugin groupid edu.illinois groupid artifactid starts maven plugin artifactid version latest st arts version version plugin using starts developers can use starts to perform several rts related tasks i finding the types that changed semantically at the bytecode level ii finding the types notjust tests that are impacted by the changes i.e.
changeimpact analysis iii finding the tests that are impacted bythe changes without running those tests and iv finding andrunning the tests that are impacted by the changes.
to achieve these tasks starts provides several goals .
c circlecopyrt2017 ieeease urbana champaign il usa t ool demonstrations949 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
mvn starts help list all goals mvn starts diff find types that changed semantically mvn starts impacted find types impacted by changes mvn starts select find but not run impacted tests mvn starts starts find and run impacted tests mvn starts clean delete st arts artifacts the first goal starts help lists all the goals in starts and what they can be used for.
the other five goals are related to rts.
starts diff displays all the java types including classes interfaces and enums that changed since the last timestarts was run.
starts impacted displays all types not just test classes that are impacted by the changes thereby providing a means for change impact analysis.
starts select displays but does not run the test classes that are impacted bythe changes since the last time starts was run allowing de velopers more flexibility to first select impacted tests and thenrun those tests later.
starts starts runs the impacted tests it performs the functions of the previous rts related goals plus executing the impacted tests.
finally starts clean removes all artifacts that starts stored from a previous run in a .starts directory resetting starts so that in the next run all types are considered changed and all tests are selected to be run if using starts starts .
starts provides several options that give some flexibility to the user.
the most important option is whether ornot to update the starts artifacts after invoking a goal.as described in section iii b starts keeps track of thechecksums of all types from the previous run storing them todisk and using them in the new run to find impacted tests.
allrts related goals in starts provide an update checksums option which when true updates the stored checksums after a run.
this option is set to true by default for the goal starts starts but is by default false for all other goals.
iii.
t echnique and implementation we describe the starts technique implemented in starts and the starts maven plugin.
a. t echnique starts performs static rts srts at the class level tests are selected at the test class not test method level and the dependencies of these tests are also computed at the class type level.
our recent work showed that such class levelsrts outperformed method level srts and was comparablewith the state of the art class level dynamic rts techniqueekstazi .
thus we implemented starts to perform class level srts based on the idea of a class firewall which encloses the types that need to be retested because they may be impacted by a code change.
the class firewall is computed on a type dependency graph tdg where each node is a type in the application and there is a directededge from one type to another type primeif has a direct use or inheritance dependency on prime.
test class nodes are also included in the tdg.
if cis a type that changed then is impacted by the change to ciff angbracketleft c angbracketright e whereeis the set of all edges in the tdg and denotesthe reflexive and transitive closure.
the class firewall is theset of all types that can transitively reach any of the typesthat changed in the tdg and can therefore be defined asfirewall t c t c e where tcis the set of all types that changed 1denotes the inverse relation and denotes relation composition.
given classfiles for all types obtained from compiling a new revision in an application and checksums of classfiles from a prior revision startscan output the set of changed types t c the class firewall firewall tc andti the set of impacted tests.
tiis computed as the set difference between the set of all tests in thenew revision and the set of tests that are not in firewall t c which is computed from the old revision .
we compute ti this way so that it includes any newly added tests while stillusing the tdg computed on the old revision.
b. implementation figure shows the starts architecture which comprises components to i find dependencies among types in the application ii construct the tdg iii find the changed typesbetween two revisions of the application iv store checksumsof all types from the current revision v select the tests impacted by the changed types and vi run the impacted tests.
finding dependencies among types starts needs to compute the dependencies among all types in the application.
the prototype in our prior work used asm to parse allthe bytecode in the compiled classfile of a given type in order to compute its dependencies.
however parsing entire classfiles just to find dependencies is rather slow because it requiresto recursively visit each type s fields methods signatures and annotations to collect all the types that are referenced.
starts improves on computing dependencies among types by only reading the constant pool in each classfile to determineall types that the type in the classfile may depend on.
we usethe recent oracle jdeps tool now part of the standard java library to read the constant pools.
after the new revision of anapplication has been compiled to produce classfiles startsmakes a single jdeps invocation via the jdeps api to parseall classfiles in the application at once and then processes thejdeps output in memory to find the dependencies for each type.
constructing the dependency graph the tdg contains an edge from one type to each of its dependencies.
we use a custom graph library called yasgl to construct graphsand to find tests that can transitively reach some changedtype.
we add each type as a node in a yasgl graph and adddependencies computed by jdeps as edges between nodes inthe graph.
with a yasgl graph starts computes the transitiveclosure of each test class to find all types that each test dependson.
our initial prototype used jgrapht but yasgl isfaster for computing the transitive closure.
for example yasgltakes .
sec to compute the transitive closure for a graphwith nodes and edges coming from a single module of a project with test classes .
jgrapht takes .
sec to compute the same transitive closure a differencethat accumulates when considering all the modules in theproject.
note that the yasgl tdg that starts uses does authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
starts architecture not distinguish between use edges and inheritance edges as done in the intertype relation graph irg used in our initial prototype and in prior work .
finding changed types starts finds the types that changed since the last time it was run.
starts uses the same checksum function from ekstazi to computea checksum that ignores debug related information for eachclassfile and stores that checksum to a file.
starts trackschanges in classfiles because the corresponding source filecan be different yet result in the same classfile that is actuallyexecuted so tracking classfiles is more precise.
also startsuses checksums for checking whether a classfile is modifiedinstead of seemingly faster methods like timestamps whichcan be unreliable e.g.
maven s incremental build system isbroken and often recompiles every type on each run soone cannot rely on the timestamps of the classfiles .
oncecompilation is complete in the new revision starts com putes the checksums of all compiled classfiles and comparesagainst the stored checksums computed from the previousrevision for each file.
if the old and new checksums differ starts considers that type to have changed.
if the typehad no previously computed checksum i.e.
a new type wasadded its checksum is stored for future runs.
finally if a typefor which starts previously computed a checksum cannotbe found in the new revision i.e.
an old type was deleted then that type is no longer stored in the checksum file forfuture runs.
if there is no checksum file on disk e.g.
on thevery first run or after running mvn starts clean starts considers all types as changed.
computing and storing checksums in our initial prototype as well as in ekstazi the transitive closure of each test class in the graph was stored as a mapping from each test class to its dependencies i.e.
a test to types mapping.
further there was one dependency file per test.
once a toolcomputed the set of types that changed it then checked the dependency file of each test to see if the test depends on anyof the changed types.
however we observed that startsdiscovers many more test dependencies than ekstazi due toinherent imprecision of static analysis and that many testsshared a lot of these dependencies.
as a result we reversed thedependency storage format in starts to reduce the amountof repetitive checking of test dependencies by storing a type totests mapping.
starts stores in a single file a mapping from each type in the application to the set of tests that depend onthat type.
this file is stored in a directory called .starts under the root directory of the application.
more precisely if the application is a multi module maven based project starts creates multiple .starts directories each with its own typeto tests mapping file under each module and the types mayspan across modules if that is where the dependencies lead.
updating the checksums that are stored on disk after invoking a starts goal on a new revision can be turned on or off asdescribed in section ii.
the type to tests storage format that starts uses together with processing only one file on disk greatly improves theperformance of selecting impacted tests.
for example inone project starts takes .
sec to check if any of thedependencies changed when using the type to tests single file format but the same check takes .
sec with ekstazi stest to types multiple files format.
one possible modificationof the test to types format could be to first read all the filesand then reverse the mapping in memory to be from type totests before comparing checksums.
however this modificationwould still incur the cost of reading potentially many filesfrom disk and it would put the mapping reversal process onthe critical path from when testing is initiated until developersobtain test results mapping reversal in starts can happenin a separate offline phase that is not on the critical path.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
selecting impacted tests starts uses the type to tests dependency mapping from the previous revision and the set of all changed types to find the tests that are not impacted by changes.
starts then computes the impacted tests as the difference between the set of all tests in the currentrevision and the set of non impacted tests.
thus newly addedtests are always in the set of impacted tests.
dependency graph construction on the new revision is not required to find impacted tests allowing quicker computation of impacted tests .
rather starts reads the type to tests dependencyfile which was computed based on the dependency graphconstructed in the previous revision.
the fact that startsrequires only compile time information to find impacted tests can allow a clean separation of phases an analysis phase a finds changes and impacted tests an execution phase e runs the impacted tests and a graph computation phase g builds the dependency graph and uses it to create a type to tests mapping for the next revision .
this separation can enable the choice to run starts in an online mode the a e and gphases are run together or an offline mode the aand e phases can run separately from or in parallel with the gphase .
we did not yet implement goals to toggle the online offlinemodes but report times for offline mode as the time for onlinemode minus the time for the gphase.
starts select displays the impacted tests but does not run them.
running impacted tests starts computes the set of selected tests to run as previously described it excludes nonimpacted tests from the set of all tests in the application.
specifically starts dynamically adds the non impacted teststo the set of tests that surefire plugin is already configured tonot run.
as a result when starts invokes the maven surefireplugin to run the tests surefire will run only the tests thatare impacted by the changes.
the goal starts starts will perform all the previous steps to find changed types select impacted tests and run those selected tests.
c. important starts options starts provides a number of other options in addition to turning on off the checksum file updates section ii .
caching jdeps output one consideration in the design of starts is how to handle the output of running jdeps on third party libraries jars .
many projects do not frequentlychange their library versions and using jdeps to parse thelibrary code on each revision would needlessly repeat work.starts therefore provides options to i use a preprocessedcache ii incrementally build the cache on each revision and iii parse the third party libraries on each revision.
the defaultis to incrementally build the cache on each revision.
whenstarts encounters a jar in the application s classpath itfirst checks whether a corresponding jdeps output file existsin the jdeps cache directory which is found in each module of the application.
if there is one starts reads it otherwise starts runs jdeps on the jar uses the jdeps output for its 1the gphase in starts is analogous to the coverage collection c phase in ekstazi and other dynamic rts techniques where separation of cand e phases is harder to achieve in practice.current processing and stores the jdeps output for that jar in afile in the jdeps cache directory.
the names of the files in the jdeps cache directory match the group artifactid revision convention of naming maven based projects and havea .graph extension.
if there is a cache possibly computed elsewhere or even from different applications starts can be configured tospecify the location of this cache.
the following commandshows using an rts related goal with a preprocessed cache where graph cache is the directory containing the preprocessed jdeps output for each third party library and the jdepsoutput files are organized as described for the default option mvn starts starts dgcache graph cache if no cache is input or the cache is empty starts runs jdeps on all libraries on each revision.
file formats for checksums and dependencies starts supports two formats for storing the checksums of all types in the application and the tests that transitively depend on them the new type to tests zlc format and the old test to types clz format proposed in ekstazi .
section iii b describes these formats and their tradeoffs.
zlc is the default file format that starts uses.
to run starts using the clz file format mvn starts starts ddepformat clz controlling starts artifact storage configuring different logging levels can control the amount of information thatstarts stores between runs where the logging levels arethe same as in the java.util.logging api.
when running at the default logging level.info starts stores only the checksum and dependency file .starts deps.zlc between runs.
at level.finest starts will store all its files the lists of all impacted non impacted tests the dependencies that jdepscomputed the classpath that starts used the yasgl graphthat starts constructed internally and the set of changedtypes.
running at logging level level.finer will store only .starts deps.zlc the set of impacted tests and the set of all tests.
to run starts while storing all its files mvn starts starts dstartslogging finest iv .
e v aluation we ran all experiments on a .
ghz intel xeon e31240 v2 machine with 16gb of ram running ubuntu linux .
.
lts and oracle java bit server version .
.0 144.we evaluated starts on maven projects.
these projectsinclude single module maven projects we used in our previous study and multi module maven projects thatwe did not evaluate before showing that starts can be integrated into larger maven projects.
we ran starts oneach project over a number of revisions and measured thenumber of impacted tests that starts selected to run relative to the number of all tests.
we also measured the percentage ofend to end time taken by starts relative to the end to endtime for running all tests i.e.
retestall.
the starts endto end time includes the time to compile perform selection authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i statistics about selected tests and end to end time of starts compared to retest all project shas all selected selected rta offline online breakdown time time a e g comp.
headius invokebinder .
.
.
.
.
.
.
.
.
.
google compile testing .
.
.
.
.
.
.
.
.
.
apache commons cli .
.
.
.
.
.
.
.
.
.
logstash logstash logback encoder .
.
.
.
.
.
.
.
.
.
apache commons dbutils .
.
.
.
.
.
.
.
.
.
apache commons validator .
.
.
.
.
.
.
.
.
.
apache commons fileupload .
.
.
.
.
.
.
.
.
.
apache commons codec .
.
.
.
.
.
.
.
.
.
srt asterisk java .
.
.
.
.
.
.
.
.
.
apache commons functor .
.
.
.
.
.
.
.
.
.
apache commons compress .
.
.
.
.
.
.
.
.
.
apache commons email .
.
.
.
.
.
.
.
.
.
square retrofit .
.
.
.
.
.
.
.
.
.
apache commons lang .
.
.
.
.
.
.
.
.
.
apache commons collections .
.
.
.
.
.
.
.
.
.
adoptopenjdk jitwatch .
.
.
.
.
.
.
.
.
.
graphhopper graphhopper .
.
.
.
.
.
.
.
.
.
apache commons imaging .
.
.
.
.
.
.
.
.
.
cloudera oryx .
.
.
.
.
.
.
.
.
.
robovm robovm .
.
.
.
.
.
.
.
.
.
ninjaframework ninja .
.
.
.
.
.
.
.
.
.
average short .
.
.
.
.
.
.
.
.
.
.
apache commons math .
.
.
.
.
.
.
.
.
.
addthis stream lib .
.
.
.
.
.
.
.
.
.
apache commons io .
.
.
.
.
.
.
.
.
.
brettwooldridge hikaricp .
.
.
.
.
.
.
.
.
.
opentripplanner opentripplanner .
.
.
.
.
.
.
.
.
.
undertow io undertow .
.
.
.
.
.
.
.
.
.
graylog2 graylog2 server .
.
.
.
.
.
.
.
.
.
apache commons pool .
.
.
.
.
.
.
.
.
.
openmrs openmrs .
.
.
.
.
.
.
.
.
.
aws aws sdk java .
.
.
.
.
.
.
.
.
.
jankotek mapdb .
.
.
.
.
.
.
.
.
.
average long .
.
.
.
.
.
.
.
.
.
.
average overall .
.
.
.
.
.
.
.
.
.
.
run the impacted tests and update dependencies for the next run while the retestall time is compile time plus time to runall tests.
we include compile time because after a change acontinuous integration system e.g.
travis typically alsocompiles the application.
we wanted to evaluate any savings inthe overall build time when using starts.
table i shows foreach project sorted by increasing retestall time the numberof revisions evaluated shas average number of all testsacross all revisions all average number of tests selectedby starts selected average percentage of all tests selected by starts selected retestall time rta and average percentage of retestall time that starts takes for both the online mode online time section iii b that includes time for the a e and gphases and the offline mode offline time that excludes time for the gphase.
the last columns break down starts time into a e gand compilation comp.
times.
in the offline mode a developer can get test results faster by not having to wait until startsfinishes the computation of dependencies before seeing thosetest results dependency and transitive closure computationcan be removed from the developer s critical path.
we divide the projects in table i into short running if retestall takes less than one minute upper part and long average time to run retestall 020406080100120st arts time retestall time fig.
.
correlation between project end to end test time vs. percentage of time to run starts running if retestall takes more than one minute lower part .
table i shows that starts runs fewer tests compared with retestall starts selects between .
apache commons collections and .
brettwooldridge hikaricp of all tests with an average of .
of all tests across all projects.table i shows that starts also provides time savings with authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
an average end to end time of .
of retestall time in the offline mode and .
of retestall time in the on line mode.
starts provides greater time savings for long running projects .
in the offline mode and .
inthe online mode than for short running projects .
inthe offline mode and .
in the online mode .
startsismore expensive than retestall i.e.
the offline percentage of retestall time is greater than in six of shortrunning projects and only one of long running project.
asexpected starts is better suited for long running projects.figure plots the correlation between the average retestalltime per project x axis and the percentage time savings fromthe starts offline mode y axis the kendall bvalue is .
andp .
a weak negative correlation.
finally the breakdown of the end to end time shows that starts spendsmost of its non compilation time in the ephase .
of endto end time on average while aand gtake up much smaller percentages.
the time for short running projects is dominatedby compilation and these projects likely cannot benefit muchfrom any rts including starts v. l imitations and future work we discuss some limitations of starts as well as future research and development directions.
limitations of starts in our previous study we found that srts performed comparably with dynamic rts we evaluated against ekstazi in terms of time.
however we alsofound that srts is as expected less precise than dynamicrts and can be unsafe.
an rts technique is precise if it selects to run only the impacted tests and safe if it does not miss to select an impacted test.
we also found that reflectionwas the only cause of unsafety of srts when comparedwith ekstazi.
starts does not yet address these safety andprecision limitations of srts.
starts can be unsafe whenthe path between tests and changed types can only be reachedvia reflection and is inherently imprecise because the static dependencies it finds among the types in the application may not be runtime dependencies.
starts also assumes that thereis no test order dependence .
future work open research directions are how to make srts more precise how to make srts safer with respect to other potential sources of unsafety such as dependency oftests on external files or native code and how to apply srtsto other programming languages.
future development plans in clude i developing faster checksum and dependency storageformats ii supporting other build systems such as bazel orgradle iii making starts usable in continuous integrationsystems e.g.
jenkins or travis and iv evaluating startson even larger applications than those we have evaluated sofar and further improving the scalability of starts.
vi.
c onclusion we presented starts a publicly available purely static class level rts tool.
starts is motivated by the need in the research community to further investigate static rtsapproaches because its counterpart dynamic rts is gainingsome adoption in practice.
we discussed the firewall technique on which starts is based and we presented the usage design and implementation of starts.
our evaluation on32 open source projects showed that starts can save timecompared to retestall and we highlighted some future re search and development directions.
we believe that startscan help to facilitate collaboration and contribute greatly tofurther static rts research.
a cknowledgments we thank felicia chandra alex gyori milica hadzitanovic farah hariri hanjie wang xin wei lingmingzhang and peiyuan zhao for their contributions to starts.deniz arsan and david craig provided valuable feedback ona draft of this paper.
this work was partially supported bynational science foundation grants ccf and ccf .
we gratefully acknowledge support for regressiontesting from google microsoft and qualcomm.
r eferences s. yoo and m. harman regression testing minimization selection and prioritization a survey stvr vol.
no.
.
s. elbaum g. rothermel and j. penix techniques for improving regression testing in continuous integration development environments infse .
p. gupta m. ivey and j. penix testing at the speed and scale of google n. york tools for continuous integration at google scale jan h. esfahani j. fietz q. ke a. kolomiets e. lan e. mavrinac w. schulte n. sanches and s. kandula cloudbuild microsoft sdistributed and caching build service in icse seip .
a. srivastava and j. thiagarajan effectively prioritizing tests in development environment in issta .
k. herzig and n. nagappan empirically detecting false test alarms using association rules in icse .
o. legunsen f. hariri a. shi y .
lu l. zhang and d. marinov an extensive study of static regression test selection in modern software evolution in fse .
m. gligoric l. eloussi and d. marinov practical regression test selection with dynamic file dependencies in issta .
ekstazi lightweight test selection in icse demo .
yet another simple graph library testingresearchillinois yasgl.
jgrapht introduction to maven .
plugin development org guides introduction introduction to plugins.html.
h. k. leung and l. white a study of integration testing and software regression at the integration level in icsm .
d. c. kung j. gao p. hsia j. lin and y .
toyoshima class firewall test order and regression testing of object oriented programs joop vol.
no.
.
a. orso n. shi and m. j. harrold scaling regression testing to large software systems in fse .
jdeps jdeps.html.
maven is broken by design maven is broken by design .
guide to naming conventions guide naming conventions.html.
travis ci a. gyori a. shi f. hariri and d. marinov reliable testing detecting state polluting tests to prevent test dependency in issta .
s. zhang d. jalali j. wuttke k. mucslu w. lam m. d. ernst and d. notkin empirically revisiting the test independence assumption inissta .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.