risk driven revision of requirements models dalal alrajeh axel van lamsweerdeyjeff kramer alessandra russo sebastian uchitel z department of computing imperial college london uk da04 jk ar3 su2 doc.ic.ac.uk yicteam universit catholique de louvain belgium avl info.ucl.ac.be ydepartamento de computaci n universidad de buenos aires and conicet argentina abstract requirements incompleteness is often the result of unanticipated adverse conditions which prevent the software and its environment from behaving as expected.
these conditions represent risks that can cause severe software failures.
the identi cation and resolution of such risks is therefore a crucial step towards requirements completeness.
obstacle analysis is a goal driven form of risk analysis that aims at detecting missing conditions that can obstruct goals from being satis ed in a given domain and resolving them.
this paper proposes an approach for automatically revising goals that may be under speci ed or partially wrong to resolve obstructions in a given domain.
the approach deploys a learning based revision methodology in which obstructed goals in a goal model are iteratively revised from traces exemplifying obstruction and non obstruction occurrences.
our revision methodology computes domain consistent obstruction free revisions that are automatically propagated to other goals in the model in order to preserve the correctness of goal models whilst guaranteeing minimal change to the original model.
we present the formal foundations of our learning based approach and show that it preserves the properties of our formal framework.
we validate it against the benchmarking case study of the london ambulance service.
categories and subject descriptors h. .
.
software creation and management designing software requirements analysis keywords requirements completeness obstacle analysis goal oriented requirements engineering inductive learning theory revision.
.
introduction acm acknowledges that this contribution was authored or co authored by an employee contractor or affiliate of a national government.
as such the government retains a nonexclusive royalty free right to publish or reproduce this article or to allow others to do so for government purposes only.
icse may austin tx usa c acm.
isbn .
.
.
.
completeness is a major concern in requirements engineering.
incompleteness commonly arises from a lack of anticipation of adverse conditions which prevent the software and its environment from behaving as expected no speci c requirements are engineered for such cases.
these unanticipated conditions represent risk and may be the cause of severe software failures .
risks may cover a wide range of undesirable situations such as safety hazards security threats and data inaccuracies amongst others.
the elicitation and analysis of these risks is at the heart of the requirements engineering process .
obstacle analysis is a model based goal oriented form of analysis that focuses on a particular type of domainspeci c risk the non satisfaction of desired goals due to events or conditions present within a domain and obstructing them.
in this context an obstacle to a goal is de ned as a precondition for the non satisfaction of that goal.
obstacle analysis comprises three steps identi cation of obstacles to goals from previously elicited goals and domain properties quantitative assessment of the likelihood and criticality of those obstacles in terms of severity of their consequences and resolution of likely and critical obstacles through countermeasures to be integrated in the goal re nement graph hereafter referred to as the system s goal model from which the software requirements are derived.
a number of approaches have been proposed to handle the identi cation e.g.
and the assessment e.g.
steps of obstacle analysis.
however the systematic resolution of the identi ed and assessed obstacles towards a complete and robust goal model remains an open challenge.
goal revision is a particular class of strategies for obstacle resolution others include obstacle prevention and obstacle reduction.
goal revision typically involves modifying a goal model in order to eliminate obstructions.
it covers the goal substitution and goal weakening strategies .
given a goal model a set of domain properties and an obstacle to the goal in the goal model a goal revision strategy consists of nding safe revisions of the obstructed goal along with a set of propagated changes in the goal model such that a the obstruction caused by the obstacle is eliminated and b the resulting goal model remains complete and consistent.
in this paper we propose a formal approach to obstacle resolution.
our approach automatically and iteratively revises goals that may be under speci ed or partially wrong to eliminate obstructions in a given domain from traces exemplifying obstruction and non obstruction occurrences.
we de ne a goal revision problem as a learning based revi2016 ieee acm 38th ieee international conference on software engineering sion task .
the approach generates obstruction free goal revisions and automatically propagates them to other goals in the model to make the obstruction disappear while preserving model correctness and guaranteeing minimal change on the original model.
if alternative revisions are found the approach produces alternative goal models each of which is guaranteed to be satis able within the given domain.
it makes use of a recently developed constraint driven learning technique .
this technique allows us to specify syntactic and semantic constraints over the search space of possible goal revisions.
we use this feature to ensure the correctness of the revised goal model.
our approach terminates once all identi ed obstructions have been removed within a given set of domain properties or when no revision can be found for this set.
the latter case calls for eliciting further domain properties from which a new cycle of obstacle analysis should be applied .
in this paper we assume that a set of obstructed goals is given and that the identi ed obstacles to these goals have been prioritized in terms of criticality in the preceding assessment phase e.g.
through cost bene t analysis of obstacle analysis.
we do not consider obstructions arising for instance from uncertainty about stakeholders their priorities or implementation costs as in .
our contribution is summarized as follows a formal underpinning of the notion of safe goal revision for obstacle resolution an automated approach for computing safe revision of a goal from obstruction and non obstruction traces an automated technique for minimally propagating changes throughout a goal model while ensuring that the resulting model is correct a new application of learning based revision and constraint driven learning to requirements engineering.
to the best of our knowledge this paper is the rst to automatically execute and propagate goal revisions in formal goal models.
the rest of the paper is organized as follows.
sec.
ii introduces background on goal modelling obstacle analysis and revision based learning.
sec.
iii motivates our approach on a small example.
sec.
iv presents the formal underpinning of our approach.
sec.
v and vi de ne the learning based revision technique used for computing goal revisions and summarizes our evaluation on an ambulance dispatching system respectively.
related work is discussed in sec.
vii.
.
background we recall some basics on behavioural goal modelling obstacle analysis and learning based revision.
.
goal oriented system modelling agoal is a prescriptive statement of intent to be satised by cooperating agents forming the considered system.
agents may include devices like sensors and actuators people pre existing software and the software to be developed.
unlike goals domain properties are descriptive statements about the problem space e.g.
physical laws.
a behavioural goal captures a maximal set of intended system behaviour unlike soft goals it is satis able in a clear cut sense .a behavioural goal is of type achieve ormaintain.
to enable formal analysis behavioural goals may be speci ed in fluent linear temporal logic fltl .
a goal has the general form c t wherecandtare conjunctions of uent expressions de ned hereafter is one of the classical logical connectives !and and is a real time temporal operator such as next sometimes in the future d sometimes in the future before deadline d always and u always in the future unless .
the expressionc tis a shorthand for c!
t .
a uent fis de ned by a set ifof initiating events a set tfof terminating events and an initial truth value either true orfalse.
given a set of event labels a called alphabet a uent de nition takes the form f hif tf initi where if a tf aandif tf and init2ftrue falseg.
a negative uent literal is a uent preceded with .
otherwise it is called a positive literal.
the notation f is a shorthand for either for f. a uent expression is a uent literal preceded by a temporal operator.
fltl expressions are interpreted over sequences of state and events called traces .
events may occur simultaneously in a trace.
we write s0fa bg0s1fcg1s2 to represent a trace in which the events aandboccur simultaneously from states0followed by the event cfroms1.
we sometimes write traces as fa bg fcg .
given a trace and a set of uent de nitions fd a uent is said to be true resp.
false in a trace at position i denoted ij f if and only if either of the following conditions holds a the uent is initially true and no terminating event has occurred since or b some initiating event has occurred before iwith no terminating event occurring since then.
the notation j fis a shorthand for 0j f. the semantics of uent expression are de ned inductively.
given two fltl expressions and f gj holds if all traces satisfying also satisfy .
given a trace and alphabet a the projection of over a denoted as ja is the trace obtained by eliminating from all elements that are not in a. we use the notation resp.
a to denote all traces resp.
projections satisfying .
agoal model is a re nement graph in which each goal is represented as a node and associated with a unique label.
an and re nement of a goal pginto a set of sub goals fsg sgngiscomplete when the sub goals fsgig possibly with domain properties in d are together su cient for satisfying pg and it is consistent if the sub goals are all together consistent with the domain properties.
these properties are more precisely stated as follows for all i n fsg sgn dgj pg complete re nement fsg sgn dg6j false consistent re nement a goal model is said to be correct if every and re nement relation in the model is complete and consistent.
in this paper we de ne a goal model as a tuple h iwhere is the set of goals appearing in the model and is the set of and re nement relations between goals in .
we will sometimes write fsg sgng gto denote the notion that the setfsg sgngis a re nement of g. obstacle analysis is a goal oriented form of risk analysis.
anobstacle to a goal is a domain satis able precondition for the non satisfaction of this goal fo dgj g obstruction fo dg6j false domain consistency 856we call any trace such that j d oanobstruction trace for goal gwith respect to obstacle oind.
similarly we refer to a trace where j d oas a non obstruction trace forgwith respect to oind.
.
inductive learning and theory revision inductive logic programming ilp is a logic based inductive learning technique that is concerned with learning generalizations hthat together with a given background knowledge bexplain a given set eof examples where h b eare represented as logic programs .
typically ilp algorithms generate minimal hypotheses i.e.
ones that are minimal both in terms of their size and number.
most recent state of the art inductive learning systems referred to as non monotonic ilp systems are capable of not only learning generalizations of given examples but also revisions of existing knowledge.
assuming kto represent possibly incorrect knowledge referred to as the revisable knowledge a learning based revision task is a computational task that consists of learning changes cto be applied to the revisable knowledge k to generate a revised knowledge k0 k c that entails the examples.
the function denotes the application of revisions cto the revisable knowledge k. the search for revisions is performed within the scope of a search space sde ned by a set of mode declarations md a form of language bias that speci es the syntactic form of acceptable changes to be learned for a given revision task.
we use s md to denote this space.
in general such search space is very large as it potentially includes all possible additions and deletions that could be applied to the revisable knowledge within the scope of a given language some of which may be irrelevant for particular domains.
inductive learning through constraint driven bias is a technique recently proposed to tackle this problem .
acceptable changes are the set of possible additions and deletion to the revisable knowledge that conform to a given set of domain speci c constraints.
this is formally de ned as follow wherepdenotes the operator of power set p s md denote the set of possible changes and p s md icthe set of changes compatible with a given set of constraints ic.
definition constraint driven revision .
a learning based revision task through constraint driven bias is a tuplehb k e md icmdi where b denotes the background knowledge krepresents the revisable knowledge e is the set of examples md is the language bias and ic md is the set of constraints over the search space p s md induced by md.
his an acceptable learned revision for this task if and only if h2 icand the revised knowledgek0 k h satis es the condition b k0j v e2ee.
minimality in the constraint driven revision case is determined by the number of of additions and deletions applied tokto satisfy the conditions above.
.
motivating example consider a simpli ed version of a car automatic handbrake control system in which a car driver the car s engine and the handbrake must interact to achieve safe brake control.
a high level goal for this system requires the handbrake to be released within three seconds of the driver s wanting to start the car expressed in fltl asgr driverwantstostart 3handbrakereleased fig.
.a shows a goal model for this root goal.
in brief the goal labelled gris re ned into three sub goals a child goal labelled g1stating that the driver presses the acceleration pedal whenever he she wants to drive the car a child goal labelled g2prescribing that the motor revs increase after the pedal is pressed and a child g3requiring that once the motor revs increase i.e.
revving the handbrake is to be released .
each of these are then re ned into two leaf goals capturing the if and only if part of .
suppose the domain properties dcontain the following uent de nitions and a property that states that the motor revs increase whenever the air conditioning in the car starts airconditioningstarts hstartac stopac falsei motorrevving hincrevmotor decrevmotor falsei driverwantstostart hinsertkeys removekeys falsei handbrakereleased hreleasehandbrake engagehandbrake falsei throttlepedalpressed hpresspedal releasepedal falsei airconditioningstarts motorrevving the goal model in fig.
fails to consider situations in which the motor revs increase due to other reasons namely the air conditioning starting a possible behaviour within the domain that would obstruct the goal g7stating that the acceleration pedal is pressed if the motor is revving motorrevving throttlepedalpressed .
using the following obstacle condition is generated og7 airconditioningstarts throttlepedalpressed although approaches such as provide a list of strategies that may be deployed to resolve obstacles like this they do not discuss when these strategies are applicable and in which cases nor how such strategies can be applied individually or in tandem.
furthermore they do not provide support for ensuring that resolutions are propagated correctly within the entire goal model.
consider for instance the substitution strategy in which the obstructed goal g7may be replaced with a new one which no longer relies on the acceleration pedal being pressed.
one choice would be to weaken the goal to become motorrevving airconditioningstarts throttlepedalpressed another possibility is to extend the domain description dwith new uents and properties that may allow alternative resolutions.
for example suppose dis extended to model a car with an electronic handbrake that has an electronic handbrake button and a handbrake controller that adds tension to the brake cables manualbrakebuttono hswitchbuttono switchbuttono falsei handbrakectrlo hswitchctrlo switchctrlon falsei.
in this extended domain it is possible to consider a revised goal in which an electronic handbrake disables the handbrake controller.
handbrakectrlo manualbrakebuttono whichever choice is made simply replacing the obstructed goal g7is clearly insu cient since the resulting re nements in the goal model may no longer be complete.
hence the changes to the goal need to be correctly propagated to other goals in the model that were dependent on the previous goal 857driverwantst ostart 3handbrakereleased driverwantst ostart throttlepedalpressed thr ottlepedalpressed motorrevving motorr evving handbrakereleased thr ottlepedalpressed motorrevving driverwantst ostart throttlepedalpressed thr ottlepedalpressed driverwantstostartmotorr evving handbrakereleased handbr akereleased motorrevving motorr evving throttlepedalpressedmotorr evving handbrakereleased a gr g1 g2 g3 g4 g5g6 g7g8 g9 driverwantst ostart manualbrakebuttono manualbr akebuttono handbrakectrlo handbr akectrlo handbrakereleased driverwantst ostart manualbrakebuttono manualbr akebuttono driverwantstostartdriverwantst ostart 3handbrakereleased handbr akectrlo manualbrakebuttono manualbr akebuttono handbrakectrlo handbr akectrlo handbrakereleased handbr akereleased handbrakectrlo b gr g0 g0 g0 g0 g0 5g0 g0 7g0 g0 9f igure goal model for automatic handbrake control system a original b revised.
being satis ed.
as a result of the propagation the handbrake controller will release or apply the handbrake rather than the motor revving.
we present a learning based revision technique that automatically produces the revised goal model in fig.
.b by substituting the obstructed goal g7and propagating the necessary changes to the rest of the model to guarantee it to be obstruction free consistent within the domain and preserve the correctness of the re nements in the goal model.
.
goal revision setting as mentioned in sec.
di erent revision strategies may be deployed to resolve an obstacle for a given goal each of which involves a series of strategy speci c manipulations to the domain properties and or goal model.
in spite of the speci c strategy deployed the goal model resulting from the resolution must satisfy a number of requirements to ensure that the obstacle is eliminated.
in this section we discuss common requirements goal revision strategies should meet.
in what follows we use d0to represent the domain properties resulting from updates to the domain properties d g0a revision to the goal g m0the goal model resulting from integrating g0in the model mand propagating changes through the original goal model m. finally denotes a function that returns a user de ned distance metric that measures the di erence between two goals i.e.
g g0 or sets of goals i.e.
fgig fg0 ig .
the rst requirement is concerned with domain consistency.
since goals are expected to be achieved within speci c domains any revision strategy must ensure that it produces satis able revisions within that domain.
req1 if goal g is obstructed by obstacle o in domain d then any goal revision g0should be consistent with d0 i.e.
fd0 g0g6j false.
the second requirement is concerned with obstacle elimination.
obstacle elimination may be achieved in two ways either by ensuring the obstruction disappears i.e.
violating the obstruction condition in subsection.
.
or making the obstacle inconsistent with the domain i.e.
violating the domain consistency condition in subsection.
.
.
in the rst case a minimum requirement for the resolution strategy is to ensure that the revised goal is no longer violated by the obstacle s occurrence.req2 if goal g is obstructed by obstacle o in d then any goal revision g0should no longer be obstructed by o in d0 i.e.fd0 og6j g0.
furthermore the goal changes to be propagated throughout the model should not cause other changed goals to be obstructed by the obstacle o. req3 the propagation of changes to g through m should not reintroduce new obstructions by obstacle o to any changed goal g0 iof m0in d0 i.e.
fd0 og6j g0 i. in addition such change propagation should preserve the goal model s correctness.
req4 the propagation of changes to g through m must ensure that every goal re nement in the model m0is a consistent and complete re nement.
we call a goal revision safe if it satis es req1 .
in addition two other requirements appear desirable.
any behaviour that was permissible in the domain and in which the obstacle did not occur should be permissible after the revision in the updated domain.
assuming addenotes the alphabet of the domain d prior to any update.
this requirement is more precisely stated below.
req5 the revised goal model m0should preserve those behaviour from g in which the obstacle does not occur i.e.
d o g ad d0 g0 .
finally the revised goal model m0should be as close as possible to the original model m. req6 the propagation of the goal revisiong0through m should be minimal i.e.
m m0 is minimal.
.
obstacle driven goal revision this section presents our approach for learning based revision for computing safe goal revisions.
.
approach overview the input is a goal model m updated domain properties d which include uent de nitions and a set of detected obstaclesfoigto goals in m. we assume a set of obstacles have already been detected for instance using the procedure presented in and assessed against their likelihood and criticality using the method in .
then for each ob858stacle otogofmind a nite set of obstruction traces o are obtained from a model satisfying dando.
we generate these by verifying fd ogj c t in the spirit of .
to achieve the behaviour preservation requirement expressed in sec.
the approach further considers a nite set of non obstruction traces othat satisfy the domain and negation of the obstacle.
these are generated by verifying a model of dand oagainst the obstructed goal s antitarget i.e.
fd ogj c t as explained in .
we use the model checking approach described in for automatically generating the traces.
however the approach is not bound to a speci c veri cation method and assumes that domain consistent traces are given.
then a learning based revision task is constructed which aims at automatically nding revisions g0to the obstructed goal gsuch that the revised goal is satis ed in traces by all in o o and is consistent with d. the revisions are automatically propagated to other goals in m. where alternative revisions exist alternative goal models are generated.
the output is a set of alternative goal models fm0 jgthat are guaranteed to be satis ed in the traces generated.
the revision procedure is repeated with respect to the revised goal until no traces in d o obstruct the revised goal or until no revision can be found within the given domain properties indicating that the domain needs to be updated.
in the latter case new obstacles if any need to be identi ed and assessed within the updated domain in order to start a new revision cycle.
the revision process is iteratively applied on every input obstacle in foig.
the approach terminates once a goal model is reached that meets the req1 of sec.
for every oi.
the order in which obstacles are eliminated are assumed to be determined by the engineer depending on their assessed criticality.
in our illustrations we assume that the structure of the goal model is maintained i.e.
the number of children and re nements for a parent goal does not change.
we illustrate the proposed approach by considering a goal substitution strategy.
weakening is discussed in sec.
.
to enable the learning based revision in the context of obstacle resolution the task of nding a safe goal revisions must be de ned in in terms of the ilp framework introduced in sec.
.
.
the goal model domain properties and traces are therefore automatically translated into a logic program and together with appropriate constraints over the solution space learning based revision computes acceptable revisions as shown in the next subsection.
though the details are provided the encoding and procedure for generating revisions are black box computations from the engineer s perspective.
.
encoding for obstacle elimination we rst introduce some terminologies used in our description.
we assume that every goal gis associated with a label that uniquely identi es it denoted .
we refer to a goal sgin a re nement set of a parent goal pgas a left child if a uent literal that appears in sg s current condition also appears in pg s current condition.
similarly we call it a right child if a uent literal that appears in sg s target condition also appears in pg s target condition.
in addition we say that the child goal sg1isleft resp.
right ofanother child sg2if a uent literal that appears in sg1 s target condition resp.
current condition also appears in the current resp.
target condition of sg2.
we describe below the en coding of goals the structure of the goal model the traces and the setting for revision task.
the encoding of domain properties is similar to that described in .
the formalism used for encoding the input is based on the event calculus ec .
in addition to the standard ec predicates e.g.
holds at and happens we extend the language to include auxiliary predicates that capture the formulation of goals current and target conditions together with their interpretation over traces.
for a given goal model m h i the encoding mis de ned in terms of the encoding of the goal expressions in it denoted tr and the re nement relations it contains denoted tr .
the tr makes use of predicates like c holds meaning the current condition holds t holds for the target condition holds t holds next meaning the target condition holds at the next time point and the predicate t holds eventually meaning the target condition holds eventually etc.
the current condition cof a goal labelledlgis automatically translated into the expression c holds lg i s neg predb neg predb where jis a uent expression in g s current condition predb is the ec literal corresponding to the uent expression jas given in table and the variables iand s are of type time points and traces respectively.
the encoding of target conditions results in rules of the form predh predb neg predb neg predb where predb is the literal corresponding to in table andpred h is the literal corresponding to t. table encoding of goals.
fluent expression ec encoding predb neg holds at f i s predb f i s neg holds at next f i s predb neg holds at eventually f i s predb neg holds at eventually by f d i s predb i i2 predb i next i i2 predb eventually i i2 predb eventually by i d i2 predh t holds lg i2 s predh t l g i2 s t holds next lg i2 s predh t holds eventually lg i2 s predh t holds eventually by lg d i2 s the following is an extract of the encoding obtained for the goals labelled grand g7of fig.
.
c holds gr i s holds at driverwantstostart i s t holds eventually by gr i s holds at eventually by handbrakereleased i s t holds eventually by gr i s holds at eventually by handbrakereleased i s c holds g7 i s holds at next motorrevving i s t holds g7 i s holds at throttlepedalpressed i s 1for details see da04 icse16 .
859in addition to the above tr contains rules that capture notions of vacuous and non vacuous satisfactions of goals in traces using predicates holds vacuously and holds nonvacuously .
this is to preserve the semantics of the goal expressions over traces in the semantics of the logic programs i.e.
both when the goal condition holds and does not hold .
furthermore since our logic programs have nite models we extend the satisfaction notion of goals in nite traces to handle cases where the current condition of a goal holds and the bound on traces is reached before the goal s target condition is satis ed.
this is formalized using the predicate holds at end time .
below is the encoding generated from the goals grand g7.
holds non vacuously gr i s c holds gr i s t holds eventually by gr i s holds vacuously gr i s not c holds gr i s not t holds eventually by gr i s holds at end time gr i s c holds gr i s eot e i e e i not t holds eventually by gr e i s holds non vacuously g7 i s c holds g7 i s t holds gr i s holds vacuously g7 i s not c holds g7 i s the encoding of re nement relations tr makes use of the predicates root left child right child and left of to formulate the re nement relation between goals in the goal model.
for example the following facts are generated for our running example.
root gr .
left child gr g1 .
child of gr g2 .
right child gr g3 .
our encoding also captures domain independent axioms denoted ax that de ne laws of persistency of uents over time in traces and of goal satisfaction including holds g i s holds non vacuously g i s holds g i s holds vacuously g i s holds g i s holds at end time g i s to enable the revision the encoding formulates the notion of obstruction and obstacle elimination in ax obstacle holds g i s not holds g i s obstructed obstacle holds g i s entailed not obstructed the rst rule says that an obstacle for a goal gholds at some time point in a trace if the goal does not hold at that time point.
the second says that an obstruction occurs if there is a goal for which an obstacle holds.
no obstruction gives entailment of all goal.
the encoding of traces tr on the other hand generates a set of happens facts.
for instance from the obstruction trace og7 fstartcarg fstartac switchbuttono g fincrevmotorg freleasehandbrake g and the nonobstruc tion trace og7 fstartcarg fpresspedal switchbuttono g fincrevmotorg freleasehandbrake g we have the following facts tr fhappens startcar s1 happens startac s1 happens switchbuttonoff s1 happens increvmotor s1 happens switchbuttonoff s1 happens releasehandbrake s1 happens startcar s2 happens switchbuttonoff s2 happens presspedal s2 happens increvmotor s2 happens switchbuttonoff s2 happens releasehandbrake s2 g where s1and s2are unique identi ers for encoded traces.
.
computing goal revisions to compute revisions to the obstructed goal the set of examples emust be speci ed.
for the learner the example are facts that should follow from the background knowledge and revisable theory but as such do not.
in the revision problem we consider our examples to represent the fact that all encoded goals including the obstructed one should hold at all time points and in all the traces including the obstruction traces.
given the rules de ning entailment in sec.
.
ein its simplest form includes the single fact entailed .
the mode declaration md is de ned to cover all uents expressions that may be constructed using the language of the domain and the predicates in table .
as these are typically domain speci c the engineer may specify which uents may be considered in the revision process thus limiting the solution space to goals expressible using these.
to ensure the re nement correctness requirement req4 we de ne a set of the constraints icmdover the solution space requiring that any change to the obstructed goal forces where necessary the revision to be applied to other goals within the model.
the constraints specify which changes to goals current and target conditions are acceptable to ensure the completeness and consistency of re nements.
for instance it is required that any changes to the current condition of a left child are re ected correctly in the current condition of its parent.
this is captured in the following constraints in icmd.
in r1 current pg l left child pg sg not in r2 current sg l in r1 current sg l left child pg sg not in r2 current pg l where the variable riis a unique identi er used by the learner for a rule within the solution space and lcorresponds to an ec encoding of a uent expression.
the literal in r1 current pg l for instance means the rule with identi er r1representing pg s current condition i.e.
c holds in the head has the ec encoding of the uent expression lin its body.
although these constraints are pre speci ed the approach provides a language for users to specify other forms of constraints that are best suited for the domain.
the revision task can now be de ned as follows.
definition goal revision task .
a goal revision task is a learning based revision task hb k e md icmdi where k tr b tr ax e fentailedg.
the encoding of the problem preserves the obstruction to goals prior to the revision computation.
for instance given the trace tr the current target of the goal g7 holds at time point holds at next motorrevving s1 860and consequently c holds g7 s1 also holds.
however holds at throttlepe dalpressed s1 is not true at time point and thus g7 s target condition does not hold at time point i.e.
t holds g7 s1 is not true .
it follows from this that holds g7 s1 is not true and therefore obstructed is also true.
hence entailed is not covered.
theorem correctness of encoding .
let g be a goal d the domain properties and obe an obstruction trace to g in d. let b and e be the background knowledge and example obtained from def.
.
then oj g i b tr 6j entailed the revision procedure operates by exploring the search space for goal revisions obtainable by deleting and adding uent expressions to the current or target conditions of the obstructed goal tr c .
the choice of operations to apply and of goals to which these are applied is determined by the traces in band the constraints icmd.
for instance to satisfy entailed in our running example the literal holds at throttlepedalpressed s1 is deleted from the body of the rule t holds g7 i s .
its substitution is identi ed by traversing the trace for literals that if added to the body t holds g7 i s would result in the derivation of holds g7 s1 .
to satisfy the constraints icmd further deletions and additions are applied to other goals.
the distance metric is de ned by the learning algorithm as a function that calculates the number of addition and deletion operations applied on the original model as a whole to obtain the revised model.
each application of an operation is given the score of .
in our example above the distance between m m0 capturing the number of uent expressions that are deleted e.g.
throttlepedalpressed from g1 g2 g4 g5 g6and g7 and added .
where multiple revision candidates of similar distance exist these are provided as alternative revisions.
the learning produces the following set k0of revised rules.
t holds g1 i s holds at manualbrakebuttonoff i s t holds g4 i s holds at manualbrakebuttonoff i s c holds g5 i s holds at manualbrakebuttonoff i s c holds g2 i s holds at manualbrakebuttonoff i s c holds g6 i s holds at manualbrakebuttonoff i s t holds g7 i s holds at manualbrakebuttonoff i s the output indicates that changes are required to goals in fig.
.a in total.
for instance from the last rule above the obstructed goal g0 7is substituted by its revised version motorrevving manualbrakebuttono .
the goals shown in fig.
.b are computed following a second iteration of the approach to resolve the obstacle manualbrakebuttono motorrevving by substituting the dependency on the motor s revving with a hand brake controller.
.
theoretical results we report here on some of the results that follow from the approach.
we do not provide full proofs owing to limited space.2the rst of these is that the approach guarantees that any revision computed is consistent with the domain.
theorem domain consistency .
let g be a goal and d the domain properties.
let obe an obstruction trace 2see da04 icse16 for proofs.to g in d. then for any computed goal revision g0 we have fg0 dg6j false.
the proof is is a consequence of theorem and the soundness of the learning .
since obstruction traces form part of the background knowledge the approach also ensures that every revision computed is satis ed in the obstruction trace thus eliminating the obstacle from at least the encoded traces.
theorem obstruction elimination .
let g be a goal and d the domain properties.
let obe an obstruction trace to g in d. then for any computed goal revision g0 we have oj g0.
in addition as the example requires that all considered goals to be satis ed in the obstruction traces the approach meets the req3 with respect to those traces.
theorem non obstruction sustainability .
let m h ibe a goal model and oa set of obstruction traces for g2 in d o and oa set of non obstruction traces for g in d o .
let m0 h ibe a revised goal model computed form d m oand o. then 8g0 i2 o o j g0 i. another consequence of the proposed approach is that every re nement relation in the revised goal model is guaranteed to be consistent and complete.
consistency is preserved since the re nements are at the least satis ed in the traces provided as input.
completeness with respect to the traces provided is maintained since every trace satisfying the encoding of a goal s children satis es the encoding of the goal.
full correctness may be guaranteed if the traces provided capture a complete characterization of the traces in d. theorem refinement correctness .
let m h ibe a goal model and oa set of obstruction traces for g2 in dand oa set of non obstruction traces for g in d. then every re nement in a revised goal model m0 h icomputed form d m oand ois a consistent and complete re nement with respect to o o i.e.
8fsg sg ng g o o if j v isgithen j g o o j v isgi furthermore since non obstruction traces in which the original goal is satis ed are encoded in the background knowledge the learning guarantees that the revised goal is satis ed in these traces too thus meeting req5.
theorem behaviour preservation .
let oa set of obstruction traces for g in d and oa set of nonobstruction traces for g in d. then for any computed goal revision g0to g from d oand othe following condition holds o. if j g then j g0.
in our context minimality of the revision is determined by the number of uent expressions that need to be added or deleted to meet req1 with respect to the given traces.
the approach guarantees that all the computed revisions are minimally di erent from the model prior to the revision for the given traces.
theorem minimal change .
let m h ibe a goal model oa set of obstruction traces for g in d o .
let m0 h ibe a computed goal model revision.
then is minimal with respect to o.
861our approach also guarantees progress towards fewer obstructions in the goal model that are caused by the detected obstacles.
this is easy to show since each revised goal is satis able in at least one more trace i.e.
the obstruction trace.
the proof is based on the assumption that the revision process is performed iteratively and that obstruction traces from previous steps are used in subsequent iterations.
theorem progress .
let obe a set of obstruction traces for g in d. then for any computed goal revision g0to g from d oand g j d o g0 j j d o g j. .
validation we apply our approach to a benchmark case study the london ambulance service originally reported in .
we demonstrate its ability to apply both weakening and substitution strategies for goal revisions expressed in rst order fltl.
to facilitate comparison with other approaches we consider goals and obstacles that have been discussed in .
a partial goal model is outlined below.
the root goal ambulanceinterventionwhenincidentreported states that an ambulance must intervene within minutes of an incident being reported .
re nements of this goal are represented by the level of indentation.
the notation left reps. right indicates that the goal is a left reps. right child goal to the goal one re nement level above.
ambulanceinterventionwhenincidentreported leftambulanceallocatedwhenincidentreported rightambulanceinterventionwhenallocated leftambulancemobilizedwhenallocated leftambulancemobilizedwhenonroad right ambulancemobilizedwhenatstation leftmobilizationorderissuedatstation right ambulancemobilizedfrommoborder right ambulanceinterventionwhenmobilized the domain properties dcontains the following uent definitions.
resolved inc incident hresolve inc happens inc false i intervention a ambulance inc incident hintervene a inc not intervene a inc falsei allocated a ambulance inc incident hallocate a inc deallocate a inc false i mobilized a ambulance inc incident hmobilize a inc demobilize a inc false i available a ambulance hassign a free a true i atstation a ambulance harriveatstation a leavestation a true i moborderissued a ambulance inc incident hissuemoborder a inc retractmoborder a inc true i brokendown a ambulance hbreakdown a repair a false i .
goal revision by weakening consider the goal ambulanceinterventionwhenmobilized 8a ambulance inc incident mobilized a inc 3intervention a inc for which the obstacle below is identi ed in .
9a ambulance inc incident mobilized a inc intervention a inc ubrokendown a the obstacle captures the situation in which an ambulance does not intervene in an incident after mobilization becauseit broke down.
a domain consistent obstruction trace exemplifying this is as follows.
freport inc g fallocate a inc1 assign a1 g fmobilize a1 inc1 breakdown a g fallocate a inc1 assign a2 demobilize a inc1 g fmobilize a2 inc1 g fintervene a2 inc1 g this illustrates a scenario where an ambulance is allocated to a reported incident.
when mobilized it breaks down.
another ambulance is allocated to the same incident and intervenes.
the obstacle is satis ed at time point .
a domain consistent non obstruction trace may be one in which the original ambulance does not break down and successfully mobilizes and intervenes.
freport inc g fallocate a inc1 assign a1 g fmobilize a1 inc1 g fintervene a1 inc1 g fresolve inc g our approach generates alternative revisions to the goal ambulanceinterventionwhenmobilized in which a uent expression is added to ambulanceinterventionwhenmobilized s current condition.
8a ambulance inc incident mobilized a inc brokendown a 3intervention a inc 8a ambulance inc incident mobilized a inc brokendown a 3intervention a inc 8a ambulance inc incident mobilized a inc brokendown a uintervention a inc 3intervention a inc the rst revision requires intervention whenever the ambulance is mobilized and not broken down.
the second is restricted to cases when the ambulance is mobilized and the ambulance never breaks downs.
the third is conditional on the ambulance being mobilized eventually intervening and not breaking down prior to its intervention.
the disjunction of the last two correspond to the weakened version obtained in whilst the rst is not obtainable using existing approaches.
we argue that the rst goal is preferable since the second is not realizable and the third is conditional on the occurrence of intervention which overlooks cases in which intervention never occurs.
with each solution the learning automatically propagates the changes to the rest of the goal model where necessary resulting in three alternative goal models.
for instance the revised goal model containing the rst goal revision also includes revisions to the goal ambulancemobilizedwhenallocated 8a ambulance inc incident allocated a inc free a time dist inc loc a loc 9a0 ambulance mobilized a0 inc brokendown a0 and to four other goals in the model with a m m0 .
.
goal revision by substitution consider the goal ambulancemobilizedfrommoborder .
8a ambulance inc incident moborderissued a inc 2mobilized a inc suppose d0includes 8a ambulance inc incident allocated a inc 9inc0 incident inc06 inc allocated a inc0 8a ambulance inc incident mobilized a inc ambmobilized inc 8628a ambulance inc incident allocated a inc amballocated inc 8a ambulance inc incident intervention a inc ambintervention inc where amballocated reps. ambintervention is a uent initiated when an ambulance is allocated to resp.
intervened in incident incand terminated when no ambulance is allocated to resp.
intervening in incident inc. an obstacle to the goal ambulancemobilizedfrommoborder is o 9a ambulance inc incident moborderissued a inc mobilized a inc an obstruction trace in o d0 is as follows.
freport inc g fallocate a inc1 assign a1 issuemoborder a1 inc1 g fdeallocate a inc1 allocate a inc1 assign a2 g fmobilize a inc1 g fintervene a2 inc1 g in this trace an ambulance is deallocated soon after it was allocated to an incident thus not only obstructing the goal ambulancemobilizedfrommoborder but also its ancestors mobilizationorderissuedatstation and ambulancemobilizedwhenallocated and ambulanceinterventionwhenallocated .
the non obstruction trace not shown here owing to space limit exempli es a scenario in which the ambulance for which the mobilization order was issued mobilizes towards the incident.
the learning system identi es the problem in the goal requiring the ambulance for which the mobilization order was issued to mobilize.
the impact of this obstruction a ects the satisfaction of others goals in the model.
a resolution is automatically generated in which the mobilized a inc literal in ambulancemobilizedfrommoborder is replaced with ambmobilized inc which is true if there is an ambulance that mobilizes to the incident.
8a ambulance inc incident moborderissued a inc ambmobilized inc the change is automatically propagated to other goals in the model in this case requiring for instance the goal ambulanceinterventionwhenallocated 8a ambulance inc incident allocated a inc intervention a inc to be substituted by 8a ambulance inc incident allocated a inc ambintervention inc the propagation resulted in changes to seven other goals in the model with a m m0 .
.
discussion and related work risk analysis is central to the requirements engineering process e.g.
.
in this context riskis the e ect of uncertainty on the achievement of system goals for which software is to be developed.
the term obstacle was introduced in to support informal scenario based reasoning about goal obstruction.
they were then used to drive requirements elaboration de idealizing the environment in which the software is to run.
the problem of obstacle identi cation has been addressed in di erent degrees of formality by many e.g.
among others .
obstacle identi cation is also inspired by and strongly related to techniques from the domain of system safety such as with hazard analysis fault trees and threat trees .
risk assessment is grounded in probabilistic or quantitative analysis for which muchautomated reasoning support exists.
in requirements engineering risk assessment has been developed extensively e.g.
.
obstacle likelihood and criticality may be determined quantitatively over obstacle re nement trees and goal re nement trees respectively .
obstacle resolution is a complex task not only because of the multiple strategies that can be used but also because resolution strategies cannot be applied locally to the obstructed goal resolution requires revising the goal model modifying higher level goals and possibly changing the structure of the goal graph.
operators encoding risk control strategies such as obstacle elimination e.g.
avoid the obstacle or substitute the obstructed goal and obstacle tolerance e.g.
mitigate consequences restore the goal but do not provide solutions for how to integrate the resolution patterns into a goal graph.
recently discussed the properties that the introduction of countermeasures should satisfy such as progress towards completeness.
however a major problem remains how to introduce and propagate countermeasures in a goal model while guaranteeing these properties are satis ed.
our approach presents a new dimension to the framework described in the integration of model checking with constraint driven learning.
various instantiations of this framework have been developed e.g.
but all have been concerned with local repairs they do not address the problem of propagating repairs through a speci cation.
.
conclusion this paper introduces an automated learning based revision approach for resolving obstacles in goal models.
the method takes as input a goal model m domain properties dand obstaclesfoigto goalsfgjginm.
it computes traces exemplifying obstruction occurrences and non occurrences indusing an o the shelf model checker.
from these traces it automatically generates revisions to the obstructed goals and propagate the changes through the goal model.
the output is a set of alternative revised goal models that guarantee the elimination of the obstacle the correctness of the revised goal model and the preservation of non obstruction behaviour with minimal change to the original model.
our approach provides a systematic solution to the problem of which resolution strategy to deploy and how by supporting the automatic exploration of all possible acceptable resolutions at once.
it is generic in the sense that it may be used with di erent trace generation methods.
although the paper does the revision and propagation within the context of obstacle resolution the results indicate that the approach can also be used to compute propagation of local changes globally over a goal model.
it could therefore be applied to support other goal oriented requirements engineering tasks.
following on from this we will extend this work to handle other strategies such as obstacle tolerance and reduction and other forms of revisions that may a ect the structure of the goal model.
we also plan to integrate techniques for handling preferences amongst alternative revisions.
.