zenids introspective intrusion detection for php applications byron hawkins brian demsky university of california irvine byronh bdemsky uci.edu abstract since its first appearance more than years ago php has steadily increased in popularity and has become the foundation of the internet s most popular content management systems cms .
of the world s million most visited websites nearly half use a cms and wordpress alone claims market share of all websites.
while their easy to use templates and components have greatly simplified the work of developing high quality websites it comes at the cost of software vulnerabilities that are inevitable in such large and rapidly evolving frameworks.
intrusion detection systems ids are often used to protect internet facing applications but conventional techniques struggle to keep up with the fast pace of development in today s web applications.
rapid changes to application interfaces increase the workload of maintaining an ids whitelist yet the broad attack surface of a web application makes for a similarly verbose blacklist.
we developed z enids to dynamically learn the trusted execution paths of an application during a short online training period and report execution anomalies as potential intrusions.
we implement z enids as a php extension supported by hooks instrumented in the php interpreter.
our experiments demonstrate its effectiveness monitoring live web traffic for one year to large php applications detecting malicious requests with a false positive rate of less than .
after training on fewer than requests.
z enids excludes the vast majority of deployed php code from the whitelist because it is never used for valid requests yet could potentially be exploited by a remote adversary.
we observe performance overhead or less for our applications vs. an optimized vanilla lamp stack.
i. i ntroduction content management systems cms have taken a leading role in web application development largely because they provide a vast assortment of powerful components that are easily composed into a polished presentation with a convenient user interface.
but for the same reason even a sophisticated application may use only a small fraction of the framework code that it deploys and vulnerabilities in the remaining code can expose the website to attacks.
table i shows that three websites hosted by our group use just .
.
of the underlying framework.
compounding this is the highly dynamic construction of php applications in which code is dynamically loaded from plain text files and even user input strings and fundamental program elements such as function call targets are often specified by string variables.
from this perspective the diverse and flexible functionality provided by the framework represents an important trade off it provides convenience for development of the website yet creates a needless security liability for deployment of the site.table i application size vs. the fraction of application code that is trusted by z enids.
most of the untrusted code cannot be reached by normal execution of the application in any configuration yet can be reached by attackers as a faux entry point or via branch manipulation.
source lines source files original trusted original trusted wordpress gitlist doku instead of settling for a compromise between convenience and security we developed z enids1to accurately and efficiently detect malicious intrusions.
users retain the freedom to install configure customize and even extend any php application.
during a short online training period z enids learns the set of execution paths that the deployed application is using.
the z enids monitor raises an intrusion alert when the execution of a request in an unprivileged session diverges from the set of trusted execution paths.
since z enids is extremely sensitive to variations in execution site changes of any kind could result in a high rate of false positives for example if a blogger writes a post having as yet unused formatting such as a table the php code that renders the post in html may take different paths than for any previous post.
to accommodate natural evolution in an application s usage of its underlying framework z enids selectively trusts new control flow paths that are directly associated with data changes made by privileged users.
this allows developers and administrators to use any part of the framework s rich feature set yet prevents abuse of both deployed code and dynamic control flow branches that the site is not presently using.
a. overview to protect a website with z enids the administrator installs the instrumented php interpreter with the z enids extension in an otherwise standard lamp or wimp stack.
for applications that implement user privileges a hook must be added in the application s php code to notify z enids of login and logout events.
z enids learns the set of features that site visitors are currently using by recording execution traces to a trusted profile for a short period of time.
in monitoring mode zenids raises an intrusion alert when the execution of an unprivileged http request diverges from the trusted profile.
1the source code of the php interpreter uses the prefix zend in honor of authors zeev and a ndi.
since our approach applies to interpreted languages in general we use the more common web .
moniker zen for our tool.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
our experiments in section vii demonstrate that z enids detects recent attacks against vulnerable applications yet rarely raises a false alert when deployed on the same applications receiving live internet traffic.
after configuring a wordpress site with vulnerable plugins and a vulnerable theme z enids detected attempts to exploit all vulnerabilities only raising false alerts on invalid form entries.
we recorded http traffic to live deployments of wordpress the gitlist repository viewer and dokuwiki for days then replayed the traffic to replica sites monitored by z enids.
the false positive rate was less than .
yet z enids raised true alerts among more than .
million requests.
privileged users made changes to these sites during the experiment that would have resulted in false alerts on every request but z enids safely expanded the trusted profile meanwhile continuing to raise true alerts on malicious requests.
a trivial implementation of z enids has overhead vs. a lamp stack having typical optimizations.
in section vi we employ redundancy elimination and caching techniques to reduce overhead below without compromising security.
b. intended usage scenario we envision z enids being deployed both by web site administrators and by cloud providers who wish to provide an extra service to their users.
although our false positive rate is extremely small in many scenarios automatically blocking traffic is unacceptable due to the small risk of blocking legitimate visitor requests.
thus we have designed z enids to provide users with alerts of potential attacks.
users can then manually review the alerts and either write rules to drop the malicious requests or whitelist the control flow as benevolent.
our experiments show that the vast majority of z enids alerts correspond to real attacks.
for higher risk deployments where training z enids on live web traffic is less practical our results show it is feasible to begin training with artificial or trusted traffic then complete the trusted profile by manually reviewing alerts during an initial segment of live traffic.
c. contributions this paper makes the following contributions a technique for recording a trusted profile of application features that are currently used by unprivileged visitors.
a taint tracking technique to safely expand the trusted profile according to changes made by trusted users meanwhile continuing to detect anomalous requests.
an implementation of z enids that supports all features of php and performs at low overhead on large web frameworks such as wordpress and symfony.
an evaluation of the performance usability and security of z enids in popular web applications facing live internet traffic and recently reported exploits.
ii.
t hrea t model zenids is designed to defend a php web application against a typical remote adversary who does not have login credentials but may attempt to open a connection on the webserver using any port and protocol available to the general public.
the adversary can determine the exact version of the protected php application and the php interpreter including zenids and has obtained the complete source code.
a binary attack on the php interpreter cannot change the execution of the script other than to crash the process.
the adversary does not know when the z enids training period occurs and is not able to access the trusted profile without first compromising the protected application.
web server authentication prevents untrusted uploads except as permitted by the protected application itself.
at the time of installation the adversary had no opportunity to modify any files of the protected application i.e.
we assume the original installation is free of any backdoors that were specifically deployed by the adversary as part of the attack.
there may however be backdoors in the application that are discoverable by the adversary at the time of its public source code release.
iii.
s ystem overview zenids protects a php application by raising an intrusion alert when execution of an untrusted user s request diverges from known safe behavior as recorded in the trusted profile.
fig.
depicts the workflow of a basic implementation of zenids.
during an initial training period of configurable duration z enids records the control flow graph cfg of each request which is just the union of all edges in the opcode trace including the authentication level at each edge.
at first there may be a high degree of variation among the cfgs indicating that training is not yet sufficient and should continue.
when the rate of unfamiliar control flow among untrusted requests tapers off the cfgs are merged into the trusted profile by union without path or context sensitivity preserving the lowest observed authentication level at each edge.
after the profile is deployed to the webserver z enids consults it to evaluate the safety of requests from untrusted users raising an alert for edges that are not known to be safe.
fig.
deployment of z enids begins by recording the cfg of each request during an initial training period.
these are merged offline into the trusted profile which is then deployed to z enids for monitoring.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a. profiling php interprets a script by first compiling it into opcode sequences e.g.
one per function and then interpreting the sequences.
fig.
illustrates this starting from a the source code which is compiled into b an opcode sequence then recorded by z enids during execution to c the trusted profile.
any opcode may jump within its sequence or enter another sequence.
from the source code perspective a transition between opcode sequences represents an entry into any php script segment not necessarily a function call but for simplicity z enids models them all as ordinary calls a importing script files when execution reaches an include orrequire statement the php interpreter executes the body of the imported script which encompasses any code outside of class and function declarations and then adds any classes and functions to the appropriate namespaces.
zenids models all forms of the include statement as a function call to the script body of the imported file.
b callbacks built in functions may implicitly invoke script functions for example if the script tries to set an undefined object property the php built in accessor calls the object s set method as a fallback.
z enids models such callbacks with an edge from the call site directly to the callback to avoid a nexus effect that would weaken the trusted profile.
for example in an exploit of the wordpress download manager plugin the adversary creates a new privileged user by manipulating the target of the php built in call user func .
if we allowed the built in to become a nexus z enids would not know which call site normally safely reaches which callee making the exploit undetectable.
c object management structural methods like classloaders and destructors are invoked under complex conditions that may vary across executions of the same http request.
for consistency z enids creates an edge from a symbolic system node to the corresponding script method e.g.
destruct .
if the application should directly invoke one of these methods perhaps under adversarial influence zenids will distinguish it as a conventional call edge.
d dynamic code the php language provides two methods for dynamically evaluating a string as php code eval andcreate function .
since the interpreter compiles them as anonymous functions z enids models them as function calls having dynamic targets see section iv b .
b. monitoring granularity to detect the rce exploits that are being reported against php applications today it is only necessary to monitor the call graph.
this is largely because there are no reported techniques for manipulating intra procedural control flow into crossing procedural boundaries as is possible on other platforms.
furthermore the known compositional attacks at the interprocedural level always involve calls that do not occur in normal execution see section iv a .
while it may be feasible to craft more subtle exploits there is presently no such threat to the php ecosystem and as we have shown there are many reasons to believe that such attacks may in fact be infeasible.
public function compile twig compiler compiler if count this getnode names compiler write list a php code sample from the symfony template compiler twig.
line result opcode operand operand zend recv compiler zend init fcall count zend init method call getnode zend send val ex names 48tmp zend do fcall zend send var tmp 48tmp zend do fcall 48tmp zend issmaller tmp zend jmpz tmp zend init method call compiler write b the sample a compiled by php into an opcode sequence.
c the trusted profile cfg of the opcode sequence b .
at opcode the callee count is a built in function that either counts builtin collections such as arrays or calls back to the object s count method if it has one.
z enids models the callback as an edge connecting opcode directly to twig node count to avoid having hundreds of edges from a nexus count node.
fig.
execution of a php code snippet under z enids profiling.
c. dynamic vs. static analysis on many platforms such as c c it is possible to construct a substantially accurate control flow graph on the basis of static analysis avoiding the administrative overhead and potential inaccuracy of dynamic profiling.
this approach is not viable for rce exploits against php because even though the source code is always available there is a common idiom of calling functions by string name which defies static analysis.
since a call by name has no structural properties to limit the set of potential target functions static analysis falls back to an over approximation that is multiple orders of magnitude too coarse for security purposes.
these call by name sites are quite common for example more than occur in the wordpress core alone.
section viii c discusses the limitations of several web defenses that rely on static analysis.
d. monitoring ubiquity a common weakness among intrusion detectors is that an informed adversary can mimic trusted input or mask those aspects of the attack that the ids is capable of observing.
for example kbouncer and ropecker use the last branch record register to detect a return oriented programming rop attack within the last nbranches asserting that evidence of rop can always be found within that window.
but evades this line of defense by composing the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
attack with deliberately long rop chains.
other na ve defense techniques have been similarly defeated by simple tricks in and .
in the context of z enids a vulnerability leveraged by a given exploit is either present in or absent from the trusted profile.
if the vulnerability is absent the vulnerable code cannot be executed without triggering an alert.
for an exploit to go undetected it must fully conform to trusted control flow paths including the execution of the malicious payload.
this approach potentially makes z enids significantly more robust to new threats than prior art.
iv .
s ystem design zenids is implemented as a php extension supported by callback hooks instrumented in the interpreter.
fig.
shows the main components of the web server as configured for our experiments with the hooks labeled h1 h5 the other hooks serve trivial initialization purposes .
a basic implementation of z enids only requires the first two hooks h1 correlates each compiled opcode sequence with its trusted profile if the sequence is trusted at all and h2validates each invocation of an opcode sequence by matching it to an edge in the trusted profile.
listings h1andh2present the essential functionality of these hooks in pseudo code.
a php deployment is not limited to the typical configuration that we use for our experiments it may incorporate numerous extensions interact with external data sources and services and be distributed across multiple servers having various architectures and operating systems.
but these factors do not interfere with the z enids detection mechanism.
at its core the php interpreter is simply a recursive iterator over opcode sequences and to our knowledge there is no configuration that substitutes or modifies the central opcode execution loop.
for this reason we expect the fundamental approach of z enids to be compatible with php deployments of all varieties.
php interpreter hook h1 compile php code into opseq key canonical name opseq ifkey trustedseqs.keys then trustedseq trustedseqs.get key ifis identical opseq trusted seq then opseq.trusted seq trustedseq else alert untrusted opsequence end if end if php interpreter hook h2entertargetseq fromopseq ifopseq .targetseq.trusted seq nil then alert untrusted appentrypoint else key canonical name opseq .targetseq ifkey opseq .trusted targets then alert untrusted call end if end if fig.
components of a typical php deployment along with z enids hooks h1 h5and fundamental rce attack vectors a1 a5.
a. attacks fig.
also labels five important attack vectors taken by today s corpus of rce exploits a1 a5 .
the pivotal role of the opcode execution loop in the php interpreter makes it possible for z enids to detect all five vectors in hook h2 a1 call by name when a function callee is specified as a string constant or variable php resolves the callee using the set of functions defined dynamically during execution.
an exploit of the popular wordpress download manager plugin creates a new user with administrator privileges by manipulating the target of just one php call by name .
zenids raises an alert at h2on any untrusted call edge even if the call site and the callee are in the trusted profile.
a2 object injection the format of serialized objects in php specifies both the type and content of each field making it possible for the adversary to compose arbitrary serialized instances.
dozens of object injection attacks have been reported such as cve against joomla in which the adversary executes arbitrary code by fabricating a serialized session.
in this scenario z enids will detect untrusted edges in the payload at h2.
a3 magic methods php implicitly invokes specially named magic methods in certain situations for example a call to an undefined method a foo is forwarded to a call with the name of the missing callee and the arguments as a fallback .
esser and dahse combine object injection with magic methods to create propertyoriented programming attacks that can execute arbitrary code.
while the approach is more complex than a2 the z enids defense at h2remains the same.
a4 dynamically included code the php include and require statements can take a string variable argument allowing an intruder to import any file.
since z enids models these as calls h2will detect untrusted targets.
a5 dynamically interpreted code php can execute a plain text string as code making the input string vulnerable to attack.
z enids models these dynamic opcode sequences as dynamic imports and monitors them at h2.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. canonical names forh1 andh2 to be reliable c anonical name must be consistent across executions since z enids uses it to find trusted profile entries.
while it might be trivial in many languages php raises several complications.
to begin with theinclude andrequire keywords are compiled as statements and executed in the opcode sequence not pre processed like in c c making it possible for conditional branches to govern the set of imported source files.
function declarations similarly allow for conditional compilation at runtime.
combining these factors with namespaces it is possible and very typical for a php application to define the same function identifier multiple times often among many different files e.g.
to implement a plugin interface .
z enids avoids ambiguity in the canonical name using the following schemes angbracketleftfilename angbracketright.
angbracketleftfunction name angbracketright.
angbracketleftline number angbracketright angbracketleftfilename angbracketright.
angbracketleftclassname angbracketright.
angbracketleftmethod name angbracketright.
angbracketleftline number angbracketright dynamic code such as from an eval statement is correlated to the trusted profile by comparing opcode content since the origin of the code string can be difficult to determine.
c. goals of the basic implementation to focus our evaluation of z enids section vii the three technical sections conclude with an enumeration of their security and usability goals notated sg andug as follows sg1 detect a broad variety of attacks including known exploits and live internet exploits.
ug1 minimize false alerts especially in large programs facing live internet traffic for a long period of time.
v. s upporting website evolution changes to the content or configuration of the application may occasionally cause a few new execution paths to be taken which would cause the basic implementation of z enids to begin raising false alerts.
instead z enids responds to trusted changes by expanding the trusted profile to enable relevant new code paths.
when z enids detects that a privileged user has changed application state for example in the database it initiates a data expansion event to add corresponding new control flow to the trusted profile.
similarly if the application generates or modifies php source files in a way that conforms to a trusted code generator z enids initiates a code expansion event .
the duration of an expansion is limited to a configurable number of requests in our experiments to minimize an adversary s opportunity to manipulate the expansion into trusting unsafe code.
hook h3initiates expansions on the basis of the sets taintedvalues andsafenewsources which are maintained by system call monitors h4andh5.
listing h3 shows how z enids adds edges to the trusted profile when the expansion conditions are met.
the first condition initiates a data expansion lines at an untrusted branch decision line when at least one value in the branch predicate carries taint from an administrator s recent data change line .
the second condition initiates a codephp interpreter hook h3 executeithopcode of opseq ifmode monitoring then ifis branch opseq branch opseq .trusted targets then ifbranch.predicate taintedvalues then mode expanding trustto control flow join branch else if is call branch then ifcall.target seq safenewsources then mode expanding trustto i else alert untrusted call end if end if end if else m o d e expanding ifis branch prevop then prevop.trusted targets opseq end if ifi trusttothen mode monitoring else if is assignment opseq then taintedvalues opseq .predicate end if end if propagate taint opseq i i expansion lines when an untrusted call lines and is made to a safe new source file line .
if neither expansion condition is met and the branch is any kind of call then an untrusted call alert is raised line .
during an expansion new branches are added to the trusted profile line and taint is propagated across all assignments line and uses of tainted operands line .
the expansion ends line where the initiating branch joins trusted control flow line .
a. code expansion events since php applications often have repetitive source code many php libraries provide an api to generate new source files at runtime on the basis of application defined templates.
php interpreter hook h4 store application state ifis trusted code genera tor then safenewsources newsource else if is admin user then statetaint storedstate user.admin level end if php interpreter hook h5 load application state if!is admin user loadedstate statetaint then taintedvalues loadedstate end if authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for example gitlist uses the symfony component twig to define the html page layout for each type of repository page file list commit list blame etc.
at runtime twig generates corresponding php files on demand.
incorporating this kind of dynamic code into the trusted profile is easy for z enids if the code generator runs during the training period.
but a demandbased code generator may run at any time for example in our gitlist experiment section vii b crawlers found unvisited views several weeks after the hour training period.
to continue trusting these known safe code generators each time the application persists a state change to the database or the filesystem i s trusted code genera tor inh4 determines whether the application has just written a safe new source file.
this function examines the following criteria call stack at the api call to update the database or write to a file does the call stack match any of the code generator call stacks recorded during the training period?
user input taint if during training the application never generated source code using values influenced by user input then z enids checks whether the data for this state change carries taint from user input.
this criterion tracks both directly and indirectly tainted values and may be disabled to avoid continuous taint tracking overhead .
generator visibility hook h4 additionally preserves a snapshot of the persisted data if during training the application only generated source code via the php persistence api then a new source file will only be trusted if it matches the last snapshot taken at h4.
b. taint tracking the expansion events rely on propagation of taint from user input and authorized state changes.
user input is tainted at http input parameters and session values while data loaded by the application is tainted in h5 on the basis of statetaint .
function p ropagate taint inh3 line transfers both colors of taint across assignments compositional operations such as arithmetic and comparisons arguments to function calls and return values from functions.
hook h3 also implicitly taints all assignments that occur during an expansion line since those assignments have as much of a causal relationship to the taint source as the branch itself.
but z enids does not implicitly taint assignments within trusted code even if it occurs under a tainted branch because those assignments must have already been made at some time prior to the expansion event before taint was present on the predicate indicating that the influence represented by the taint is not pivotal to that already trusted branch decision.
c. evolution goals this enhancement to z enids aims to improve usability while maintaining the security goals of the basic implementation.
in our evaluation we explore the following use cases ug2 incorporate complex changes to control flow into the trusted profile without raising false alerts.
sg2 continue to raise legitimate untrusted call alerts both during and after an expansion event.vi.
p erformance optimiza tion the overhead of branch evaluation in h2and taint tracking inh3 line could make a na ve implementation of z enids unusable in a high traffic deployment.
even checking for the presence of taint in h3 line can increase overhead by an order of magnitude.
but since these expensive operations are only necessary in certain scenarios it is safe for z enids to elide them when conditions indicate that the operations will always nop.
for maximum efficiency z enids implements three flavors of opcode execution loop each taking only the actions necessary for its designated context monitorall propagates taint evaluates all branch targets.
reserved for profile expansion events requests .
monitorcalls only evaluates call targets.
this is the default for monitoring untrusted requests.
monitoroff ignores everything.
reserved for trusted users negligible overhead .
since php invokes the opcode execution loop via function pointer switching is simply a matter of replacing the pointer.
the two monitoring modes are further optimized as follows monitorcalls the first lines of h2 are elided by lazily grafting the set of safe call targets onto each php opcode.
zenids cannot extend the byte opcode struct because interpreter performance relies on byte alignment so instead it borrows the upper bits of a pointer field which are unused in bit linux where the user mode address space is much smaller than .
specifically a pointer into the trusted profile is copied into a cache friendly array whose index is packed into the spare bits of the opcode.
line of h2 is further optimized for call sites having only one trusted target instead of a trusted profile pointer the array entry is a direct encoding of the singleton target allowing for bitwise evaluation.
to avoid expensive string comparisons target opcode sequences are identified by a hashcode of the canonical name.
monitorall since z enids maintains taint in a hashtable the accesses required for taint propagation could become expensive under rapid iteration of hook h3 .
in addition some php opcodes might require a costly callback from the interpreter because they affect complex data structures or are implemented using inline assembly.
both sources of overhead are alleviated by lazy taint propagation using a queue that is locally maintained by simple pointer arithmetic.
when the interpreter copies internal data structures e.g.
to expand a hashtable taint must be tediously transferred to the new instance.
z enids flags each data structure that contains taint and elides this expensive transfer for untainted structures.
a. synchronizing evolution for applications that store state in a database the persisted statetaint listing h4 is updated by database triggers since it is non trivial to determine from an sql string what database values may change we assume instrumenting the database engine is undesirable .
but the query for statetaint can be expensive relative to the total turnaround time of a very simple authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
http request even when our query uses a trivial prepared statement.
instead z enids stores the request id of the last privileged state change in a flat file and updates it from the database every requests.
while this delay makes it possible to raise up to false alerts immediately after a state change it is unlikely because a significant state change often involves multiple http requests.
for example although the wordpress permalinks feature can be enabled with just one radio button selection it takes at least asynchronous http requests to process that change and only the last one enables the feature.
b. performance goals the goals of these optimizations are straight forward.
since this significantly increases the complexity of z enids we add a usability goal to limit development and maintenance costs ug3 reduce overhead to less than on our benchmark applications as measured on real http traffic.
ug4 minimize the cost of developing and maintaining a usable implementation of z enids.
sg3 maintain the existing security.
vii.
e xperimental ev alua tion we conduct several controlled and real world experiments to demonstrate the ability of z enids to meet our three security goals sg1 sg3 and four usability goals ug1 ug4 .
we begin with a controlled experiment to detect known exploits sg1 without raising false positives ug1 .
section vii b demonstrates similar results in the context of real php applications facing live internet traffic.
in section vii c the same experiments additionally show the accuracy ug2 and safety sg2 of the evolution feature.
performance optimizations were enabled for the experiments to show that those improvements do not compromise security sg3 .
section vii d concludes with an evaluation of the z enids runtime overhead ug3 and a discussion of development cost ug4 .
a. monitoring a vulnerable application we demonstrate that z enids detects publicly reported exploits by configuring a wordpress site with vulnerabilities targeted by the most recent wordpress exploits published onexploit db.com as of june excluding dataonly attacks and unavailable modules.
this medley shown in table ii shows that z enids can detect a broad variety of exploit strategies sg1 .
for authenticity we configured and exercised at least of each module s high level features.
to train the trusted profile we invited common crawlers and manually browsed the site for just a few minutes using a range of mobile and desktop browsers.
for modules having forms we entered a variety of valid and invalid data and uploaded valid and invalid files.
then we enabled the z enids monitor and continued using the site to evaluate our goals sg1 we invoked each exploit and observed that a z enids raised the expected alert and b the poc succeeded.
ug1 false positives only occurred when entering invalid form data all other requests were trusted by z enids.table ii z enids raises an alert during attempts to exploit vulnerable plugins and themes in a wordpress site.
these were the most recent wordpress exploits from exploit db.com as of june excluding data only attacks and unavailable modules.
edb id wordpress module exploit detected ab test plugin check beauty clean theme check candidate application form plugin check ghost plugin check gravity forms plugin check gwolle guestbook plugin check imdb profile widget check simple backup plugin check simple image manipulator plugin check wp mobile detector plugin check b. monitoring live applications to demonstrate the effectiveness and usability of z enids in the real world we recorded all public http traffic for one year to three php applications hosted by our research lab wordpress our lab website which has pages and uses the attitude theme with no posts or comments .
gitlist the public repository viewer for software developed in our lab based on the symfony framework.
dokuwiki a computer science class website containing wiki text markup document previews and file downloads.
we conducted this experiment offline by replaying the recorded http traffic to a copy of the web server and also crawling the site with utility wget .
table iii shows the results in terms of unique false positives and total false negatives.
to further substantiate the usability of z enids table iv shows these accuracy statistics under a range of training durations.
exploit detection sg1 z enids raised true alerts on a diverse array of attacks targeting dozens of applications and using a broad range of exploit techniques.
the majority of alerts were raised in wordpress because every unrecognized url is directed to the wordpress permalink resolver.
the false negatives represent two kinds of failed attacks typical threats that were safely handled by application code e.g.
invalid logins or unauthorized admin requests.
exploits that a target applications that we did not have installed and b did nothing to affect the control flow.
one especially interesting attack abused the wordpress xmlrpc api to amplify brute force password guessing.
not only was it a real threat to our installation it is also an example of a legitimate api that z enids does not trust and rightly so because rpc tools are irrelevant for our simple lab website.
table iii alerts raised by z enids while monitoring our lab web server for days.
false negatives represent safely handled attacks such as invalid logins or attacks on applications that we do not host.
intrusion alerts requeststotalfalse positives false negatives total training unique rate rate wordpress .
.
gitlist .
dokuw iki .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
these experiments not only show that z enids detects a broad range of attacks but also that it integrates effectively into a diverse set of applications representing an important cross section of today s php landscape.
these frameworks serve a large percentage of the world s http traffic and support millions of websites ranging in significance from personal homepages to household names in the alexa top .
minimize false alerts ug1 z enids only raised false alerts unique against wordpress in the entire year.
a broken link triggered of them unique at the guess permalink function one might argue that these are true alerts since they do reflect an error in the site.
improvements to z enids could potentially eliminate all the false positives in dokuwiki.
half were caused by the addition of a tarball download to the wiki which does not trigger an expansion event because new control flow occurs before the tainted tarball is loaded from the filesystem.
z enids could enable this expansion by tainting operands at untrusted branches and after the request completes checking backwards for privileged user influence.
the remaining false positives were caused by crawlers reaching new pages which could be avoided by blocking suspicious requests from crawlers.
we experienced just one false positive in over .
million gitlist requests despite training the trusted profile in just hours a total of requests highlighting the simplicity of our dynamic approach vs. a traditional static analysis.
our trusted profile for gitlist covers closures and several dynamically generated php files along with distinct magic methods reached from call sites excluding constructors and destructors and callbacks from php built in functions.
there were callbacks to closures which are especially challenging for static analysis yet easily identified at runtime.
our first two goals imply that ideally the duration of the training period should not significantly increase false positives ug1 or false negatives sg1 .
table iv shows that although zenids can be trained for a very short period of time the results are similar for much longer training periods.
c. evolution each of our three applications experienced one expansion event during the experiment.
the largest event occurred in wordpress when the site administrator enabled permalinks at request which has the following effects on the site visitors may request any page by name.
for example the original ugly url is now also reachable as page .
requests for the original url forms p or page id are rewritten by wordpress to the permalink url.
visitors subscribing to a comment feed can use the permalink form of the feed url which was requested by crawlers even though comments were disabled .
a smaller data expansion occurred in dokuwiki after a change to the layout of the start page and the wiki menu bar.
in gitlist a code expansion incorporated new view templates into the trusted profile as they were dynamically generated.table iv the duration of the training period has minimal impact on the accuracy of z enids alerts.
false positives in dokuwiki could potentially be avoided by improvements to z enids.
false negatives represent attacks that failed to have any effect on control flow.
intrusion alerts trainingtotalfalse positives unique false negatives requests rate ratewordpress595 .
.
.
.
.
.
.
.
.
.
.
.
gitlist298 .
.
.
.
0dokuw iki1 .
.
.
.
.
.
.
.
safe profile expansion sg2 learning to trust the new wordpress permalinks feature was the most risky of the three expansion events because the feature involves directing all unrecognized urls to wordpress for pattern matching.
since this includes any exploit attempts a weak implementation of zenids might mistakenly trust malicious control flow as part of the expansion event.
but manual analysis confirms that all newly trusted calls were strictly necessary to support the permalinks feature.
in fact z enids raised intrusion alerts during the expansion including attempts at known wordpress plugin exploits cve and invalid login attempts attempts to register new users requests for disabled features and unauthorized requests for administrator pages.
following the expansion z enids continued to raise alerts on thousands of malicious requests many of which used a valid wordpress permalink url form.
the gitlist expansion incorporated several new views into the trusted profile each having more than sloc.
in dokuwiki the expansion added new sloc.
we did not experience enough attacks targeting gitlist or dokuwiki to make an empirical case for the safety of those expansions but manual analysis confirms that every added call was strictly necessary for z enids to trust the newly enabled features.
the twig template engine in gitlist conforms to all three characteristics of a disciplined code generator indicating that zenids successfully detected the three corresponding criteria in hook h4when the new views were generated.
sufficient profile expansion ug2 no false positives occurred in any of the three features that initiated expansion of the trusted profile.
the wordpress permalinks feature supports many url variations and a complex resolution mechanism and although it was heavily exercised for the months during which permalinks were enabled z enids trusted all the new code paths on the basis of the request expansion period.
the new gitlist views and dokuwiki menu layout also activated new url forms with additional url resolution and these were fully enabled after the expansions completed.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d. performance ug3 we evaluated the performance of z enids by replaying a contiguous segment of the recorded http traffic from the experiment in section vii b. to avoid bias we selected a segment having a representative frequency of expansion events though none incorporated new control flow .
the web server is an intel xeon e3 v3 with 32gb ram and a solid state drive configured with a lamp stack running on ubuntu .
apache .
.
mysql .
.
and php .
.
alpha .
to show that z enids performs well in a real deployment scenario we configured optimizations that would typically be used for high traffic php websites.
for example our deployment uses the popular opcache extension which alleviates compilation overhead by caching the opcode sequences.
we also chose the latest stable build of php which includes significant core optimizations such as global register allocation for the script instruction pointer and frame pointer.
we enable all optimizations in opcache and use gcc optimization flags o3 march native to obtain peak performance for the baseline vanilla configuration of the php interpreter.
after configuring z enids with the same trusted profile that we reported in section vii b we replayed the http requests synchronously to isolate the php interpreter s execution time from process and thread scheduling factors.
table v shows the overhead is less than for all our applications.
instrumentation overheads ug4 the cost of developing and maintaining z enids is an important factor in its overall performance as a practical security tool.
although there is significant effort involved this burden becomes progressively lighter as the user base grows since the work only needs to be done once for each version of the php interpreter.
the z enids php extension consists of 20kloc of code and we additionally instrumented hooks for a total of lines of code in the php interpreter source.
for applications that store state in a database z enids requires a database schema to contain the statetaint that is used by hooks h4 andh5 to support data expansions.
the schema consists of two small tables plus one trigger per application table.
for php applications having an authentication scheme the login function must be instrumented with callbacks to set user level level which is provided by the zenids extension as a php built in function.
the level argument is an integer indicating the new authentication level for example in wordpress we use the application s role id .
placing the callbacks was simple in both wordpress and doku for each application we inserted three callbacks in one source file immediately following a log statement indicating successful login or logout gitlist has no authentication .
e. v erifiability the z enids prototype is open source and can be found at since the data used in our experiments contains private user information we are not able to publicly release it.
however our repository provides instructions for conducting similar experiments in z enids.table v runtime overhead of z enids vs. an optimized vanilla lamp stack measured as the geometric mean of runs.
wordpress gitlist dokuwiki runtime overhead .
.
.
viii.
r ela ted work many recent approaches to the problem of intrusion detection are successful against specific categories of vulnerabilities such as cross site scripting xss or sql injection sqli but none of them has proven effective against remote code execution rce exploits.
for example the wordpress plugin mutescreamer was once commonly used to protect wordpress sites but it only supports a manual blacklist of request patterns making it vulnerable to mimicry and incapable of defeating a zero day attack.
the comprehensive coverage of the trusted profile makes it possible for z enids to surpass some limitations of these otherwise successful techniques.
a input filtering for applications having a relatively systematic public interface exploits can be detected with high accuracy by observing patterns in user input.
commonly deployed tools are snort and apache modsecurity which block known attacks based on a manually maintained blacklist.
but for today s complex and highly dynamic php applications this approach performs poorly because a a single vulnerability can be compromised using distinct crafted inputs b the frequency of blacklist updates would increase by several orders of magnitude for example wordpress.org currently offers over plugins most of which are continually in development and c blacklist approaches cannot defeat zero day attacks yet new exploits against wordpress alone are reported almost daily.
a variant known as anomaly detection relies instead on a whitelist of normal application behaviors but the whitelist can be difficult to construct.
one approach requires an expert to manually define a set of policies which also must be maintained to accommodate ongoing customization configuration changes and even application state changes.
several alternative techniques formulate the whitelist in simpler terms for example n grams of packet bytes or properties of http request attributes such as string length characters sets token sets and learn the whitelist by observing a set of known normal requests obtained by manual analysis .
many of these approaches are subject to mimicry or evasion tactics because the whitelist is only indirectly related to program semantics.
another weakness is that the training time is typically quite long from up to of the experiment s reported request set in successful techniques.
recent investigation into these approaches no longer mentions web applications suggesting that the increasingly dynamic interaction between browser and server inhibits convergence of the whitelist.
pure machine learning approaches have mediocre results on artificial benchmarks such as the darpa datasets and have rarely been used in practice where they typically perform much worse .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b introspective anomaly detection a different n gram approach observes the internal execution of the application on the server and learns a whitelist of short system call sequences .
this approach turns out to be highly susceptible to mimicry isolating the sequence of system calls by name only yields a vague representation of the application that allows the attacker far too much flexibility.
similar approaches based on finite state automata were difficult to apply in practice no experiments were reported .
c static analysis instead of attempting to detect exploits at runtime several techniques focus on finding vulnerabilities offline so the application can be secured by simply patching.
conventional static analysis has been unable to find many important attack vectors in stateful session based applications so uses an smt solver along with advanced formulation of constraints on string dataflow and program logic to find several new rce exploits in large php applications.
while this approach has some success the authors admit many vulnerabilities cannot be found this way.
for example the implementation has limitations at dynamic constructs such as variable array indices which are very common in php in the version of phpmyadmin reported in the experiment of all array accesses use a variable index.
other approaches are primarily effective against xss and or sqli vulnerabilities.
to improve coverage of the static analysis partitions it into levels of granularity intra block intra procedural and inter procedural.
both webssari and saner combine static and dynamic analysis to detect missing authentication checks webssari automatically patches the code while saner verifies each result by dynamically generating an exploit.
pixy employs taint tracking to find vulnerable handling of string variables.
the authors of all these techniques suggest their approaches may also work well for other kinds of exploits including rce but they also admit limitations at dynamic statements such as include with a variable operand which are a primary targets of rce exploits.
another limitation of these approaches is that they disregard client side javascript making it difficult for them to find all the application entry points.
d dynamic analysis exploit detection techniques that share our dynamic approach are highly specialized to particular kinds of vulnerabilities other than rce.
scriptgard instruments both the client and server to dynamically patch faulty authentication code.
noncespaces randomizes sensitive values to prevent client side tampering.
diglossia and sqlcheck employ efficient taint tracking to detect sqli.
to our knowledge z enids is the first such dynamic instrumentation approach to focus specifically on rce exploits.
a. defenses for other platforms some important defenses that have been developed for other platforms cannot be directly applied to rce exploits in php yet are still relevant to the z enids approach.
a large body of cfi research has focused on reducing overheads through minimizing dynamic checks.
unfortunately researchers found these simplificationsopen the application to attacks .
in response researchers have developed newer more restrictive approaches with higher overheads.
some compilerbased approaches achieve low overhead by protecting only forward control flow edges .
opaquecfi combines randomization with simple range checks which weakens the constraints to improve runtime efficiency but in a way the adversary cannot easily reason about.
several other cfi approaches target specific attacks such as rop but may not be robust to new types of attacks.
recent work has shown that many of these approaches are vulnerable to attack variants .
z enids is able to maintain a usable level of performance while comprehensively monitoring interprocedural control flow at runtime against the trusted profile.
software diversification introduces uncertainty for the attacker by generating a physically distinct yet functionally identical version of a compiled binary for each user but is not able to deter exploits that manipulate source level semantics.
the logging framework blackbox employs learning to isolate potential exploits of cots binaries building a whitelist by observing real executions.
z enids is similarly able to isolate anomalies in the execution of dynamically specified branch targets dynamically generated code strings and php files that did not exist at the time of initial deployment.
the android permission model is coarse grained making it possible for adversaries to access resources that are allowed by the permissions but are irrelevant to the application.
in an offline dynamic analysis mines the application for normal resource usage and a runtime sandbox limits the application to those refined permissions.
this approach differs from z enids in that it focuses on constraining resource abuse.
clearview uses learning to patch software errors.
a key difference is that clearview focuses on generating repairs relying on external mechanisms for error detection whereas zenids focuses directly on detecting attacks.
ix.
c onclusion we presented z enids a tool for identifying malicious activity in php applications.
during a short learning phase zenids observes a set of normal executions and encodes those application behaviors in a trusted profile.
z enids then raises an intrusion alert when it observes untrusted application behaviors.
z enids employs taint tracking to enable new application behaviors that result from trusted state changes including privileged user activity and application code generators.
our results show that z enids can protect real world php applications from known exploits and can detect a number of real world attacks initiated by actual adversaries.
x. a cknowledgments we thank prateek saxena per larsen konrad jamrozik ulfar erlingsson fabian gruber cyril six the pldi student research competition committee and the anonymous reviewers for their helpful comments.
this work was supported by the national science foundation under grants ccf ccf cns and ccf .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.