refbot intelligent software refactoring bot vahid alizadeh mohamed amine ouali marouane kessentini and meriem chater software engineering intelligence lab cis department university of michigan usa alizadeh mouali marouane meriemchater umich.edu abstract the adoption of refactoring techniques for continuous integration received much less attention from the research community comparing to root canal refactoring to fix the quality issues in the whole system.
several recent empirical studiesshow that developers in practice are applying refactoringincrementally when they are fixing bugs or adding new features.there is an urgent need for refactoring tools that can support continuous integration and some recent development processes such as devops that are based on rapid releases.
furthermore several studies show that manual refactoring is expensive and existing automated refactoring tools are challenging to configure and integrate into the development pipelines with significantdisruption cost.
in this paper we propose for the first time an intelligent software refactoring bot called refbot.
integrated into the version control system e.g.
github our bot continuously monitors thesoftware repository and it is triggered by any open or merge action on pull requests.
the bot analyzes the files changed during that pull request to identify refactoring opportunities using a set of quality attributes then it will find the best sequence ofrefactorings to fix the quality issues if any.
the bot recommends all these refactorings through an automatically generated pullrequest.
the developer can review the recommendations and their impacts in a detailed report and select the code changes that he wants to keep or ignore.
after this review the developer can closeand approve the merge of the bot s pull request.
we quantitatively and qualitatively evaluated the performance and effectiveness of refbot by a survey conducted with experienced developers who used the bot on both open source and industry projects.
index terms software bot refactoring quality i. i ntroduction refactoring defined as a set of program transformations intended to improve the system design while preserving thedesired behaviour is becoming a critical software maintenanceactivity especially with the growing complexity of software systems .
a recent study by the us air force software technology support center stsc shows that restructuringthe code of a large project reduced developers time by over when introducing new features.
however refactoring is expensive.
developers take an average of weeks to refactorthe design of medium size projects around 30k loc .there has been much work done on various techniques andtools for software refactoring and these approaches can be classified into three main categories manual semiautomated and fully automated approaches.
in manual refactoring the developers refactor with no tool support except the execution part identifying the parts of theprogram that require attention and performing all aspects of thecode transformation by hand.
it may seem surprising that a de veloper would eschew the use of tools in this way but murphyhill et al.
found in their empirical study of the developers usage of the eclipse refactoring tooling that in almost ofcases the developers performed refactorings manually and did not use automated refactoring tools.
kim et al.
confirmed this observation finding that the interviewed developers frommicrosoft preferred to perform refactoring manually in of cases.
despite its apparent popularity manual refactoring is very limited.
however several studies have shown that manual refactoring is error prone time consuming not scalable and not practical for extensive application of refactorings to fix major quality issues .
although developers are refactorings manually the surveys confirmed that they are not frequently refactoring their code because of the above limitations.
in fully automated refactoring developers provide their code as input and the tool will provide refactoring recommendations automatically .
the majority of existing automated refactoring tools assume that developers want to fix code smells .
this approach is appealing in that it is a complete solution and requires little developer effort but it suffers from several serious drawbacks as well.
first therecommended refactoring sequence may change the program design radically and this is likely to cause the developer to struggle to understand the refactored program and they loseany control of the introduced code changes.
second it lacksflexibility since the developer has to either accept or reject the entire refactoring solution.
in fact developers intentions may not be most of the time fixing code smells or themajority of them.
third it fails to consider the developer perspective as the developer has no opportunity to provide feedback on the refactoring solution as it is being created.
furthermore as development must halt while the refactoring process executes fully automated refactoring methods are not useful for floss refactoring where the goal is to maintain good design quality while modifying existing functionality.the developers have to accept the entire refactoring solutioneven though they prefer in general step wise approacheswhere the process is interactive and they have control of therefactorings being applied .
finally one of the significantlimitations of existing automated refactoring tools is the highconfiguration effort required to integrate them into the current development pipeline of the team company.
in fact several companies are now using continuous integration and devops which make the adoption of current automated refactoring tools very challenging.
ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxb sf ohjoffsjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
recently few interactive refactoring techniques were proposed .
they provide to the developers the flexibilityto approve or reject the recommended refactoring that canimprove the quality.
however this interaction process is time consuming and developers get frustrated from providing feed back on files that are out of their interests ownership or nav igating through many refactoring recommendations strategiesto improve several quality metrics.
to address all the above challenges we propose the first attempt to design and build an intelligent refactoring bot asa github app that can be easily integrated into any project repository on github.
the bot can be customized to monitor the quality in the repository after some pull requests repeatedly or automatically executed when the quality analysis showsa significant decrease.
the bot analyzes the files changed during that pull request s to identify refactoring opportunities using a set of quality attributes then it will find the bestsequence of refactorings to fix the quality issues if any.
the botrecommends all these refactorings through an automaticallygenerated pull request.
the developer whenever availablewithout interrupting the development pipeline can review therecommendations and their impacts in a detailed report and select the code changes that he wants to keep or ignore.
after this review the developer can close and approve the mergeof the bot s pull request.
we quantitatively and qualitativelyevaluated the performance and effectiveness of refbot by asurvey conducted with experienced developers who used thebot on both open source and industry projects.
the primary contributions of this paper can be summarized as follows the paper introduces a novel way to refactor software systems using autonomous intelligent software bots butstill considering developers interaction to review thegenerated pull request.
we propose an implementation of the refactoring bot as a git app that can be quickly adopted in a continuous integration environment or devops process.
the paper reports the results of an empirical study on an implementation of our approach.
the obtained resultsprovide evidence to support the claim that on average our bot is more efficient than existing automated refac toring techniques based on a benchmark of six open source systems and one industrial project.
the paper also evaluates the relevance and usefulness of the suggestedrefactorings for software developers in improving thequality of the modified files in several pull request.
the remainder of this paper is structured as follows.
section presents the relevant related work.
section describes our intelligent refactoring bot while the results obtained from our experiments are presented and discussed in section .
threatsto validity are discussed in section .
finally in section wesummarize our conclusions and present some ideas for futurework.ii.
r elated work our work is mainly related to refactoring recommendations empirical studies on refactoring mostly the onesinvestigating its relationship with fault proneness and soft ware bots.
a. refactoring recommendation much effort has been devoted to the definition of approaches supporting refactoring.
one representative example is jdeodorant the tool proposed by tsantalis and chatzigeorgiou .our paper is mostly related to approaches exploitingsearch based techniques to identify refactoring opportunities and our discussion focuses on them since the bot is basedon multi objective refactoring.
we point the interested readerto the survey by bavota for an overview of approachessupporting code refactoring.
o keeffe and cinn eide presented the idea of formulating the refactoring task as a search problem in the space ofalternative designs generated by applying a set of refactoring operations.
such a search is guided by a quality evaluation function based on eleven object oriented design metrics thatreflect refactoring goals.
harman and tratt were the firstto introduce the concept of pareto optimality to search based refactoring.
they used it to combine two metrics namely cbo coupling between objects and sdmpc standard deviationof methods per class into a fitness function and showed its superior performance as compared to a mono objective technique .
the two aforementioned works paved the way to several search based approaches aimed at recommending refactoring operations .
several other studies proposed refactorings at the model level as well .
a representative example of these techniques isthe recent work by alizadeh et al.
who proposed aninteractive multi criteria code refactoring approach to improve the qmood quality metrics while minimizing the number ofrefactorings.
in our approach we decided to rely on a simpler optimization algorithm by only considering the refactoring ofrecently changed files in other pull requests rather than theroot canal refactoring approach of alizadeh et al.
.
b. empirical studies on refactoring empirical studies on software refactoring mainly aim at investigating the refactoring habits of software developers and the relationship between refactoring and code quality.we only discuss studies reporting findings relevant to ourwork.
murphy hill investigated how developers performrefactorings.
examples of the exploited datasets are usagedata from developers using the eclipse environment andinformation extracted from versioning systems.
among their several findings they show that developers often perform floss refactoring namely they interleave refactoring with other programming activities confirming that refactoring is rarely performed in isolation.
kim present a survey of software refactoring with microsoft engineers.
they show that the major obstacle of adopting many existing refactoring authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tools is their configuration and painful integration within their pipelines without disturbing developers with their currentfocus in terms of meeting deadlines and making regular codechanges.
those findings stress out the need for refactoringbots that can be adopted for continuous integration withoutconsiderable configuration effort.
c. software bots the design and implementation of software bots are still in its infancy with a significant focus on chatbots.
for instance lebeuf et al.
discussed the potential of using chat bots in software engineering and how they can be helpful to increase collaborations between programmers.
the authorsalso proposed a possible classification of potential benefits ofusing software bots in various domains especially to improvethe productivity of developers.
an extensive empirical study of over software bots was performed by wessel et al.
to provide a classification and taxonomy for them.
they found that around bots were actually tried on github repositories and the dominant majority are around testing but without providing any code actions or recommendations to developers.
the authors foundthat none of these bots provides explanations of their analysiswhich reduced the adoption by developers.
some examples of regression testing bots include travis ci and the bot designed by urli et al.
to repair bugs.these tools did not open a new pull request but they are executed manually by the developers where they can check the recommended patches.
another bot related to qualityassessment but not refactoring is fix it .
it is mainly limited to a few types of code changes mainly targeting dynamic analysis metrics.
finally wyrich et al.
proposed a vision paper to emphasize the importance of refactoring bots and motivatestheir potential use in practice.
they proposed a prototype nota complete bot by running sonarqube to detect code smells.however the work is still in its initial stage where refactoringsare not recommended yet.
iii.
a pproach we developed the refactoring bot refbot as a github app using which the workflow can be automated and thedevelopers can integrate the bot easily to any repository of their interest.
the overview of the refactoring bot is shown in figure .
a. refbot installation the first step of utilizing the refactoring bot is to install its github application on organizations or user accounts and toset up the appropriate permissions.
as the installation page in figure shows the user can select the repositories.
therefore refbot is granted access to the specific repositories via the github api.
refbot has read and write permissions to pull requests and webhook and also is subscribed to pull requests and its related reviews and comments events.after this step refbot automatically sets up a web hook for the developer s profile which means the permitted activitieson the selected repositories will be posted as json formattedpayloads to the designated external server.
b. processing a pull request refbot continuously monitors the actions performed on the repository by checking the subscribed payloads delivered toits server.
in our current configuration opening a new pull request action triggers the refbot s workflow.
first the commits in the pull request are compared to the commit at the point where the branch is created to extract the list of all files changed by the pull request.
then two versions of the files before and after the pull request are downloadedto the external server for further processing and modifications.
by processing only the changed files by the pull request we ensure that the developers are provided with the reports and refactorings limited to the codes they recently modified.
this feature facilitates the evaluation of recommended refactorings and is aligned with the idea of maintaining improving thecode quality in the continuous development process.
calculating quality changes the refbot analyses the code quality of the extracted files.
for this purpose weadopted qmood quality assessment methodology which isa hierarchical model for object oriented designs .
qmood model comprises of four levels from which we utilized the first level design quality attributes to mea sure code quality changes of the pull request.
this quality attributes set is defined based on iso and consists of reusability flexibility understandability functional ity extendibility and effectiveness .
table i describes the qmood metrics definitions.
it is shown that qmood metrics model is highly effective in predicting software defects in both traditional and iterative like agile software development processes .
since the qmood metrics are not limited to a specific range it is difficult for the user to interpret their values.therefore we built a software quality benchmark datasetconsisting of the quality metrics calculated for over opensource and industrial software projects.
then to summarize all six quality attributes we defined a super metric called total quality index tqi as the linear summation of the metrics.
finally we compared the quality metrics and tqi of a new project file with the range of the benchmark and assigned aquality label a b c and d based on the quartile of a value.
this method facilitates the analysis of quality reports and gives meaning to the metrics in terms of the quality level low high of software compared to other standard projects.
optimization using refactoring finding a refactoring solution can be a challenging task since a huge search space requires to be explored.
this search space is the outcomeof the number of refactoring operations and the importanceof their order and combination.
to search this space weemployed an adaptation of the non dominated sorting genetic authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the overview of refbot pipeline fig.
.
installing refbot on a repository algorithm nsga ii to discover a trade off between multiple quality attributes.
nsga ii is a multi objective evolutionary algorithm operating on a population of candidate solutions that are evolved toward the pareto optimal solution set.
nsga ii uses an explicit diversity preserving strategy together with an elite preservation strategy.
.
a refactoring solution is designed as a vector that consists of an ordered sequence of multiple refactoring operations.each refactoring operation includes a refactoring action andits specific controlling parameters.
the refactoring operationstable i quality attributes and their computation equations .
quality attributesdefinition computation reusabilitya design with low coupling and high cohesion is easily reused by other designs.
.
coupling .
cohesion .
messaging .
designsize flexibilitythe degree of allowance of changes in the design.
.
encapsulation .
coupling .
composition .
p olymorphism understandabilitythe degree of understanding and the easiness of learning the design implementation details.
.
abstraction .
encapsulation .
coupling .
cohesion .
p olymorphism .
complexity .
designsize functionalityclasses with given functions that are publicly stated in interfaces to be used by others.
.
cohesion .
p olymorphism .
messaging .
designsize .
hierarchies extendibilitymeasurement of design s allowance to incorporate new functional requirements.
.
abstraction .
coupling .
inheritance .
p olymorphism effectivenessdesign efficiency in fulfilling the required functionality.
.
abstraction .
encapsulation .
composition .
inheritance .
p olymorphism authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii list of refactoring operations included in refbot.
refactoring controlling parameter moving features between objects move method source target method move field source target attribute extract class source target attributes methods organizing data encapsulate field source attribute simplifying method calls decrease field security source attribute decrease method security source method increase field security source attribute increase method security source method dealing with generalization pull up field source target attribute pull up method source target method push down field source target attribute push down method source target method extract subclass source target attributes methods extract superclass source target attributes methods considered in refbot cover the most used operations selected from different categories moving features data organizers method calls simplifiers and generalizationmodifiers .
these refactorings are listed in table ii.
refac toring operations are created or modified randomly during the population initialization or mutation.
also the size of a solution vector which is the number of included refactoring operation is randomly selected between lower and upper bound values.
therefore it is crucial to examine the feasibility of asolution using related pre conditions and post conditions .these conditions ensure that the program will not break whilethe behaviour is preserved by the refactoring.
to evaluate a candidate refactoring solution a fitness function is defined to estimate its goodness.
in order to measure the impact of a refactoring solution on the software project we utilized six qmood quality attributes.
the relative change ofeach quality attribute after applying the refactoring solution to the software system is considered as the fitness function and is expressed as f itnessf unction i aqmafter i cc aqmbefore i cc aqmbefore i cc where aqmbefore i andaqmafter i are the averages of the quality metric ibefore and after applying a refactoring solution over all changed classes cc respectively.
by defining the fitness function in this way we aim to find the solutions capable of improving the quality attributes of thepull request.
additionally we constraint the search process to the solutions in which at least a class controlling parameter is in theset of changed files in the pull request.
for this purpose we modified a variation operator of the search algorithm called selection operator .
variation operators help to navigatethrough the search space and to maintain a good diversityin the population.
parent selection is a crucial step thatdirectly affects the convergence rate.
we added the controllingparameter constraint to the selection process.
after the execution of the refactoring search algorithm is finished the instruction of applying each refactoring operationis added to the related files as a distinctive marker formatsimilar to the git conflict marker.
finally refbot creates a new pull request to introduce the changes to the repository.
c. developer s interaction one of the main advantages of refbot is to include the developer in the refactoring process loop.
when the internalworkflow of refbot on a pull request is completed the developer is notified by email and also via github checks api in the same page of the pull request.
these notificationscontain a link to the report page of the pull request wherethe users can analyze the results and give feedback to the recommended refactorings.
there are three levels of reports generated for each pull request and provided for the user solution report contains the quality history of the pull request and the impact of the recommended solution onthe changed files.
file report includes the list of refactorings applied to the selected file and the detailed quality history and impactof refactoring.
refactoring report represents the instruction of a single refactoring and the high level code abstraction of sourceand target classes which are transformed by the operation.
analyzing these simple yet effective reports give the ability of swift detection of required improvements based on individ ual preferences.
the developer can interact with the refactoring results of refbot with three actions.
each refactoring can be rejected applied with a code marker or applied automatically .
by rejecting a refactoring it is not considered in the pull request.
applying with a code marker adds the refactoringinstruction as a marker inside the related files.
therefore thedeveloper can manually implement the required changes.
last applying automatically gives permission to refbot to changeand apply the refactorings to the source code itself.
the reason we have both manual and automated refactoring is that sometimes the developers prefer to take control of the refactoring process and the changes in the structure of their code either for the whole software or a specific set of importantclasses files.
when the developer is satisfied with the feedback he she can update the previously created refbot s pull request.
refbot can be combined with continuous integration tools like travisci jenkins or circleci to identify the problems authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that may occur during the automated refactoring by running integration tests.
d. configuration and customization refbot is highly customizable in terms of setting its internal workflow parameters and execution management.
sometimes a developer is not willing to be disturbed for every new pull request.
therefore refbot can be configured to monitor the repository at a specific time interval or evencan be triggered manually for a specific pull request.
furthermore users can enable disable different refactoring types and quality attributes.
in this way they can control theoptimization process and limit the search to the refactoringoperations they are willing to apply and to the quality attributesthey prefer to improve.
additional materials such as the default parameter settings for nsga ii and video demo of refbot can be found at thispublication s web page .
e. running example in this section to illustrate the process of refbot and its performance in refactoring a pull request we provide a running example on a real open source software system.
we considered a pull request from atomix software repository and manually triggered refbot to process it.
figure represents part of the file quality table in the solution report page which is generated for the selected pull request.it shows the tqi grade for the changed files before andafter creating the pull request alongside with the impact of the recommended refactoring solution on the quality.
as an example the quality of the second file is degraded from .
b to .
c .
the solution which refbot found for the pull request contains seven refactoring operations applied to this file.
these refactorings could improve the file quality to .
b .
the user can view the detailed report page for each file.
the bar charts in the file report page are provided in figure .
it shows the quality changes after the pull request and the refactoring solution impact for each of the six quality attributes individually.
we can observe that the recommended refactoring solution improves out of quality attributes for the file compared to the pull request quality.
another section in the file report page is shown in figure .
it lists the refactoring operations from the recommendedsolution which have a controlling parameter applied to the selected file.
the developer can interact with this list and rejector apply code mark auto options are as a popup window eachof the refactorings.
additionally the developer can further investigate each of the refactorings by viewing the refactoring report page.
figure represents the abstract code changes after applying the selected refactoring on the source and target classes.
thisreport can facilitate the decision making of users and help them to understand the changes in the structure introduced by a specific refactoring.
a developer completes the interaction and analysis the pull request is updated in the software repository includingthe feedbacks on the refactorings.
for any refactoring thatapplied as a code marker the instructions are added to thetop of the related files.
figure depicts an example of theformat of these markers.
iv .
v alidation we define three categories of research questions to evaluate refbot and compare it to state of the art techniques forautomated refactoring rq1 quality improvement.
to what extent can our refactoring bot improve the quality of software systems ascompared to existing automated refactoring techniques?
in rq1 we use the internal quality attributes andcode smells as proxies to assess the quality improvementbrought by the refactoring operations generated by therefbot for a set of selected pull requests on different sys tems.
we compare the performance of our approach momfo with two state of the art refactoring techniques ouni and jdeodorant .
ouni proposed an automated multi objective refactoring formulation based on nsga ii using an aggregation of quality metrics while reducing the number of refactorings.
jdeodorant is an eclipse plugin able to detect code smellsand automatically recommend refactorings to fix them.jdeodorant is not based on the use of heuristics search.
as jdeodorant supports a lower number of refactoring types with respect to the ones we considered we restrictour comparison with it to these refactorings.
we have also limited the comparison to the changed files in the pull requests.
rq2 refactoring meaningfulness.
are the refactoring recommendations produced by the refbot meaningful from a developer s point of view?
how do they compare with those generated by existing automated refactoringtechniques?
using antipatterns or internal quality indicators as proxies for code quality as we do in rq1 hassubstantial limitations.
for this reason in rq1 we survey25 developers asking for their opinion about the meaning fulness of the refactorings recommended by our technique and by the automated refactoring competitive technique .
in rq2 we do not compare with jdeodorant since we preferred to focus on the most similar competitive technique in the literature to better study the advantagesbrought by the refactoring bot.
the main substantial difference between refbot and the approach by ouni is indeed the interactive and incremental approach of the refactoring bot to focus on pull requests.
rq3 industrial validation.
to what extent can refbot support of refactoring in a real world continuous integration setting?
we integrated a beta version of refbot into a previously licensed refactoring tool and asked oneof our industrial partners to use it for a limited periodof business days with six developers involved on their regular pull request after installing the bot on their authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the quality table in solution report page fig.
.
the quality bar charts in file report page for all six quality attributes.
fig.
.
the list of refactoring operations recommended for a single file.
repository.
during this period we checked the ability of refbot to select relevant refactorings for the recent pull requests introduced by the programmers during their dailyactivities.
the context of our study is represented by the seven systems in table iii.
we selected these seven systems for our validationbecause they range from medium to large size projects and fig.
.
the code abstraction of source and target classes after applying a specific refactoring.
fig.
.
the refactoring instructions related to a single file are added to thesource code as a marker style.
table iii s tatistics of the studied systems .
system release classes smells kloc xerces j v2.
.
jhotdraw v7.
.
21jfreechart v1.
.
170ganttproject v1.
.
41jdi v5.
247apache ant v1.
.
rhino v1.
.
have been actively developed over the past years.
jdi2is an industrial project for which of the developers involved inthe jdi maintenance agreed to take part in our experiments.
table iii provides information about the size of the subject 2company anonymized for double blind.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
systems in terms of the number of classes and kloc and the number of code smells affecting them as detected with therules defined in .
a. data collection we present the data collection and analysis process grouped by research question category.
to address rq1 we calculated nfas the percentage of code smells fixed by the refactoring solutions generated bythe three considered approaches over the total number of code smells which are affecting recent pull requests of the subjectsystems.
we selected the latest ten pull requests for each of the open source systems while a total of pull requests wereopened during the three business days of the refbot trial byour industrial partner.
the detection of code smells before afterapplying a refactoring solution was performed with the rulesdefined in .
the considered code smells are blob feature envy fe data class dc spaghetti code sc functional decomposition fd and shotgun surgery ss .
since the concept of code smell is very subjective different developers may have different opinions on whether a codecomponent is smelly or not we also use more objectivemetrics to assess the quality of the refactorings generated by the experimental approaches.
we adopted the gmetric based onqmood that estimates the quality improvement of the system by comparing the quality before and after refactoring independently from the number of fixed design defects.
six quality factors are considered by qmood reusability flexibility extendibility functionality understandability and effectiveness.
all of them are formalized using a set of quality metrics.
hence the total gain in quality gfor each of the considered qmood quality attributes q ibefore and after refactoring can be estimated as g summationtext6 i 1gqi 6where gqi q prime i qi where q prime iandqirepresent the value of the quality attribute i respectively after and before refactoring.
to answer rq2 we asked developers to evaluate the meaningfulness of the refactorings recommended by refbot and by the approach of ouni for pull requests on theseven subject systems.
before explaining the study design for rq2 it is important to remember that both the experimental techniques generate output sequences of refactoring operationsthat make sense when considered together rather than when looking at them in isolation.
however it is not an option to aska developer to assess the meaningfulness of all the refactoring operations generated for a given system.
for this reason westarted by filtering for each system the sequences of refactoring operations impacting the files of a set of pull requests to make a fair comparison between both tools.
then the developersmanually evaluated the outcomes of both tools for each pullrequest.
each participant was then asked to assess the meaningfulness of the sequences of refactoring operations.
since on sixof the seven systems all but jdi we involved external developers professional developers who did not take part in thedevelopment of the subject system we made sure that eachparticipant only evaluated refactoring sequences recommendedby the two competitive techniques on one specific system jhotdraw .
the rationale for such a choice is that an externaldeveloper would need time to acquire a system s knowledgeby inspecting its code and we did not want participants tocomprehend the code from four different systems since thiswould introduce a strong tiring effect in our study.
to answer rq3 the six developers of the jdi project evaluated the refactoring sequences generated for that system since here we wanted to exploit their experience as originaldevelopers of the system.
they used refbot as a beta versiontool during a period of days instead of a refactoring tool thatwe licensed to their company in the past.
our industrial partnerwas motivated to try out refbot since they are interestedin upgrading their current quality assessment tool to anotherone that can support devops like our refbot.
they alsoexpressed a concern about the lack of customization and highconfiguration effort training required by existing automatedrefactoring tools.
to support such a complex experimental design we built a java web app that automatically assigns the refactoredpull requests to be evaluated to the developers.
the web app showed each participant one sequence of refactoringoperations on a single page providing the developer with i the list of refactorings move method m ito class cj then push down field fkto subclass cj ii the code of the classes impacted by the sequence of refactorings and iii thecomplete code of the system subject of the refactoring with the description of the opened pull request and the generated refactoring pull request by the refactoring bot.
the web pageshowing the refactoring sequence asked participants the question would you apply the proposed refactorings?
with a choice between no the refactoring sequence is not meaningful maybe the refactoring sequence is meaningful but the quality improvement it brings does not justify changing the code oryes the refactoring sequence is meaningful and should be implemented .
moreover participants were allowed to leave a comment justifying their assessment this was optional .
the web app was also in charge of balancing the evaluations per system.
we made sure that each system received roughly the same number of participantsevaluating the different refactored pull requests files associ ated modified by these pull requests by the two approaches.
keeping track of the time spent by participants in the evaluation of each refactoring sequence refactoring pull request.the time spent by participants was counted in seconds since the moment the web app showed the refactoring on the screen to the moment in which the participant submitted theirassessment.
this feature was done to remove participantsfrom our data set who did not spend a reasonable amount of time in evaluating the refactorings.
we consider less than authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv participants involved in rq2.
system partic.
avg.
prog.
avg.
java avg.
refact.
experience experience exp.
xerces j .
high jhotdraw .
medium jfreechart .
medium ganttproject .
high jdi .
very high apache ant .
high seconds a reasonable threshold to remove noise we removed all evaluation sessions in which the participant spent less than60 seconds in analyzing a single refactoring sequence .
collecting demographic information about the participants.
we asked their programming experience in years overall and in java and a self assessment of their refactoring experience from very low to very high .
table iv shows the participants involved in our study and how they were distributed in the evaluation of the refactoringsequences generated on the seven systems.
for the three days industrial validation we integrated a routine in our refbot to record all the actions of the developers including the number of applied and rejected refactorings number of selected test cases the introduced code changes and commit messages.
b. experimental setting and data analysis for each algorithm and each system we performed a set of experiments using several population sizes and300.
then we specified the maximum chromosome length maximum number of operations test cases per solution .the resulting vector length is proportional to the number ofrefactorings that are considered and the size of the program to refactor.
based on those considerations the upper andlower bounds on the chromosome length were set to and respectively.
the stopping criterion was set to fitness evaluations for all algorithms to ensure fairness.
in order to have significant results for each couple algorithm system we use the trial and error method for parameterconfiguration.
concerning rq2 we report the percentage of refactoring sequences assessed with a no maybe o r yesby developers for each treatment refbot and ouni system .
then we discuss interesting comments left by developers whenjustifying their assessment.
c. results rq1 quality improvement.
figures and provide the percentage of fixed code smells nf and the quality gain g based on the qmood model respectively.
the average nfon the seven systems is with peaks of for jhotdraw and ganttproject.
the recommended refactorings also improved the gmetric values figure of the seven systems.
the average quality gain for the rhino system was the highest among the seven systems with .
.
the improvement in the quality gain shows that the recommended refactorings help to optimize different fig.
.
median percentage of fixed code smells nf on the different pullrequests of the seven systems.
fig.
.
median quality gain g on the different pull requests of the seven systems.
table v rq2 w ould you apply the proposed refactorings of the generated refactoring pull request ?
approach no maybe yes refbot ouni quality metrics.
besides the performance of refbot is superior as compared to the competitive refactoring techniques even though the difference in terms of fixed code smellsis not that marked figure .
this latter result is also dueto the fact that refbot does not only recommend refactoringoperations aimed at removing code smells it also focuseson refactoring classes not affected by code smells but werechanged during recent pull requests.
for example in a manual investigation of the refactorings recommended by refbot for jfreechart we found that of the impacted classes do notexhibit any criticality as indicated by code smells and theywere still improved in terms of quality attributes.
rq2 refactoring meaningfulness.
table v summarizes the manual refactoring evaluation results obtained from the 25participants.
note that there is a slight deviation between thetotal number of refactorings evaluated by the two approaches vs83 since as explained in section iv we did not consider for the data analysis the evaluations in which participants spent less than seconds to assess the meaningfulness of the refactoring sequence under analysis and also the approach of ouni et al.
tends to generate much more refactorings on the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
analyzed files from the pull requests.
the analysis of the quality by the refactoring bot improved the relevance of the recommended refactorings compared to the fully automated multi objective approach.
indeed thepercentage of meaningful recommendations the sum of the maybe and yesanswers is much better for refbot comparing to ouni et al.
for refbot and for ouni .
thepercentage of refactorings that participants believe must be applied yesanswers is significantly higher for refbot as well vs15 .
by looking at the comments left by participants when justifying their assessment four out of the six original developersof the jdi system highlighted in their comments for three refactoring sequences that they found the refactorings relevant because it is improving the modularity of a class that theyfrequently modify in all the most recent pull requests.
forexample one of the developers wrote in a comment that is a very good recommendation i spent days working on thisclass recently there so i like this move method very muchand extract sub class.
it will improve the reusability a lot ashighlighted by the explanations of the bot .
we found this comment as important qualitative evidence of the value of ourrefactoring bot in terms of analyzing the recently closed pullrequests to identify changed files and fix the identified quality issues in these files.
rq3 industry validation.
figures and summarize the results of deploying our refbot during business days to our industrial partner on the jdi repository.
the six developers used the bot as part of their daily programming activitiesinstead of a previously licensed refactoring tool.
the tool was deployed as a git app that connects automatically to aprivate github repository whenever some code changes areintroduced by the developers to check for refactorings andgenerate a new pull request for the review of developers.
overall the achieved results confirm the effectiveness of our bot to generate efficient refactoring pull requests.
we foundthat the developers approved out of refactoring pullrequests generated by the bot during the three days.
for the two remaining pull requests we found that a total of out of11 refactorings were approved.
the achieved results confirmthe basic intuition behind this work showing that developersare more motivated to apply refactorings when the tool iseasy to integrate within their development pipeline.
the six developers also confirmed that they feel more comfortable in applying refactorings due to the high level of control proposed by the bot to review the generated pull request which gives them more confidence and trust to the tool.
this may explain the reason why a good number of recommended refactorings were applied.
v. t hreats to validity our refactoring bot mainly focuses on the recent pullrequests but developers may have different priorities based on their current context.
however the developers can modifythe configuration of our bot to focus on commits branches specific files or developers contributions.
another internalthreat is related to the used quality attributes since developers may want to express different preferences than qmood orthey want to tune them based on their needs or how criticalis the code.
construct validity is concerned with the relationship between theory and what is observed.
to evaluate the resultsof our approach we selected a set of pull requests whencomparing with other techniques but may perform better onother pull requests where the quality of them are different.
external validity refers to the generalize ability of our findings.
we performed our experiments on open source systems belonging to different domains and one industrial project by involving participants in the evaluations of the refactoringoperations.
however we cannot assert that our results canbe generalized to other applications and other developers.
future replications of this study are necessary to confirm our findings.
vi.
c onclusion we presented a first attempt to propose an intelligent software refactoring bot as github app that can submit a pull request to refactor recent code changes.
the salient feature ofthe proposed bot is that it incorporates interaction support via our web app hence allowing developers to approve ormodify or reject the applied code refactoring.
the refactoring bot also provides support to explain why the refactorings are applied by quantifying the quality improvements.
to evaluatethe effectiveness of our technique we applied it to four open source and one industrial projects comparing it with state ofthe art approaches.
our results show promising evidence onthe usefulness of the proposed interactive refactoring bot.
the participants highlighted the high usability of the bot in terms of easy integration with their development environments with the least configuration effort.
future work will involve validating our technique with additional refactoring types programming languages quality issues and participation from practitioners to investigate the general applicability of the proposed methodology.
r eferences s. a. bohner and r. s. arnold software change impact analysis .
ieee computer society press los alamitos vol.
.
y .
lin x. peng y .
cai d. dig d. zheng and w. zhao interactive and guided architectural refactoring with search based recommendation in acm sigsoft international symposium on f oundations of software engineering .
acm pp.
.
t. mens and t. tourw e a survey of software refactoring ieee transactions on software engineering vol.
no.
pp.
.
e. mealy d. carrington p. strooper and p. wyeth improving usability of software refactoring tools in australian software engineering conference aswec .
ieee pp.
.
m. w. mkaouer m. kessentini s. bechikh k. deb and m. o cinn eide high dimensional search based software engineering finding tradeoffs among objectives for automating software refactoring using nsga iii in proceedings of the annual conference on genetic and evolutionary computation .
acm pp.
.
m. okeeffe and m. o. cinn eide search based refactoring for software maintenance journal of systems and software vol.
no.
pp.
.
j. simmonds and t. mens a comparison of software refactoring tools programming technology lab .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
e. murphy hill c. parnin and a. p. black how we refactor and how we know it ieee transactions on software engineering tse vol.
no.
pp.
.
m. kim t. zimmermann and n. nagappan an empirical study of refactoringchallenges and benefits at microsoft software engineering ieee transactions on vol.
no.
pp.
july .
s. negara n. chen m. vakilian r. e. johnson and d. dig a comparative study of manual and automated refactorings in european conference on object oriented programming .
springer pp.
.
x. ge q. l. dubose and e. murphy hill reconciling manual and automatic refactoring in proceedings of the 34th international conference on software engineering .
ieee press pp.
.
t. mens and t. tourw e a survey of software refactoring ieee trans.
software eng.
vol.
no.
pp.
.
m. vakilian n. chen s. negara b. a. rajkumar b. p. bailey and r. e. johnson use disuse and misuse of automated refactorings in proceedings of the 34th international conference on software engineering .
ieee press pp.
.
g. sz oke c. nagy l. j. f ul op r. ferenc and t. gyim othy faultbuster an automatic code smell refactoring toolset in ieee 15th international working conference on source code analysis and manipulation scam .
ieee pp.
.
f. palomba g. bavota m. d. penta f. fasano r. oliveto and a. de lucia on the diffuseness and the impact on maintainability of code smells a large scale empirical investigation empirical software engineering .
n. tsantalis and a. chatzigeorgiou identification of move method refactoring opportunities ieee transactions on software engineering vol.
no.
pp.
.
m. w. mkaouer m. kessentini s. bechikh k. deb and m. o cinn eide recommendation system for software refactoring using innovization and interactive dynamic optimization in proceedings of the 29th acm ieee international conference on automated software engineering ase pp.
.
w. mkaouer m. kessentini a. shaout p. koligheu s. bechikh k. deb and a. ouni many objective software remodularization using nsga iii acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
v .
alizadeh and m. kessentini reducing interactive refactoring effort via clustering based multi objective search in proceedings of the 33rd acm ieee international conference on automated software engineering ser.
ase .
new york ny usa acm pp.
.
.
available v .
alizadeh m. kessentini w. mkaouer m. ocinneide a. ouni and y .
cai an interactive and dynamic search based approach to software refactoring recommendations ieee transactions on software engineering .
g. bavota a. de lucia a. marcus and r. oliveto recommending refactoring operations in large software systems in recommendation systems in software engineering m. p. robillard w. maalej r. j. walker and t. zimmermann eds.
springer berlin heidelberg pp.
.
m. o keeffe and m. o cinn eide a stochastic approach to automated design improvement in international conference on principles and practice of programming in java .
computer science press inc. pp.
.
m. harman and l. tratt pareto optimal search based refactoring at the design level in 9th annual conference on genetic and evolutionary computation pp.
.
o. seng j. stammel and d. burkhart search based determination of refactorings for improving the class structure of object orientedsystems in international conference on genetic and evolutionary computation .
acm pp.
.
m. kessentini w. kessentini h. sahraoui m. boukadoum and a. ouni design defects detection and correction by example in international conference on program comprehension icpc .
ieee pp.
.
a. ouni m. kessentini and h. sahraoui search based refactoring using recorded code changes in proceedings of the 17th european conference on software maintenance and reengineering csmr pp.
.
a. ouni m. kessentini h. sahraoui k. inoue and k. deb multicriteria code refactoring using search based software engineering anindustrial case study acm transactions on software engineering and methodology tosem vol.
no.
p. .
m. fleck j. troya m. kessentini m. wimmer and b. alkhazi model transformation modularization as a many objective optimization problem ieee transactions on software engineering vol.
no.
pp.
.
a. ouni r. g. kula m. kessentini t. ishio d. m. german and k. inoue search based software library recommendation using multiobjective optimization information and software technology vol.
pp.
.
a. ouni r. gaikovina kula m. kessentini and k. inoue web service antipatterns detection using genetic programming in proceedings of the annual conference on genetic and evolutionary computation .
acm pp.
.
a. ouni m. kessentini s. bechikh and h. sahraoui prioritizing codesmells correction tasks using chemical reaction optimization software quality journal vol.
no.
pp.
.
m. kessentini m. wimmer h. sahraoui and m. boukadoum generating transformation rules from examples for behavioral models inproceedings of the second international workshop on behaviour modelling f oundation and applications .
acm p. .
a. ben fadhel m. kessentini p. langer and m. wimmer search based detection of high level model changes in 28th ieee international conference on software maintenance icsm .
ieee pp.
.
m. kessentini h. sahraoui m. boukadoum and m. wimmer searchbased design defects detection by example in international conference on fundamental approaches to software engineering .
springer berlin heidelberg pp.
.
m. kessentini a. bouchoucha h. sahraoui and m. boukadoum example based sequence diagrams to colored petri nets transformation using heuristic search in european conference on modelling f oundations and applications .
springer berlin heidelberg pp.
.
c. lebeuf m. a. storey and a. zagalsky software bots ieee software vol.
no.
pp.
.
how software developers mitigate collaboration friction with chatbots arxiv preprint arxiv .
.
m. wessel b. m. de souza i. steinmacher i. s. wiese i. polato a. p. cha ves and m. a. gerosa the power of bots understanding bots in oss projects proceedings of the acm on humancomputer interaction vol.
pp.
.
s. urli z. yu l. seinturier and m. monperrus how to design a program repair bot?
insights from the repairnator project in proceedings of the 40th international conference on software engineering software engineering in practice .
acm pp.
.
v .
balachandran fix it an extensible code auto fix component in review bot in ieee 13th international working conference on source code analysis and manipulation scam .
ieee pp.
.
m. wyrich and j. bogner towards an autonomous bot for automatic source code refactoring.
j. bansiya and c. g. davis a hierarchical model for object oriented design quality assessment ieee transactions on software engineering vol.
no.
pp.
.
h. m. olague l. h. etzkorn s. gholston and s. quattlebaum empirical validation of three software metrics suites to predict fault proneness of object oriented classes developed using highly iterative or agile software development processes ieee transactions on software engineering vol.
no.
pp.
.
k. deb a. pratap s. agarwal and t. meyarivan a fast and elitist multiobjective genetic algorithm nsga ii ieee transactions on evolutionary computation vol.
no.
pp.
.
w. f. opdyke refactoring object oriented frameworks ph.d. dissertation university of illinois at urbana champaign .
m. fokaefs n. tsantalis e. stroulia and a. chatzigeorgiou jdeodorant identification and application of extract class refactorings in 33rd international conference on software engineering icse pp.
.
w. kessentini m. kessentini h. sahraoui s. bechikh and a. ouni a cooperative parallel search based software engineering approach for code smells detection ieee transactions on software engineering vol.
no.
pp.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
f. palomba g. bavota m. d. penta r. oliveto and a. d. lucia do they really smell bad?
a study on developers perception of bad code smells in 30th ieee international conference on software maintenance and evolution pp.
.
a. arcuri and l. briand a practical guide for using statistical tests to assess randomized algorithms in software engineering in 33rd international conference on software engineering icse .
ieee pp.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.