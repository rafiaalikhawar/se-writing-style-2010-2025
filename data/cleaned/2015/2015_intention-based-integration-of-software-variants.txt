intention based integration of software variants max lillack s tefan st anciulescu wilhelm hedman thorsten berger andrzej w asowski leipzig university germany abb corporate research switzerland chalmers university of gothenburg sweden it university of copenhagen denmark abstract cloning is a simple way to create new variants of a system.
while cheap at first it increases maintenance cost in the long term.
eventually the cloned variants need to be integrated into a configurable platform.
such an integration is challenging it involves merging the usual code improvements between the variants and also integrating the variable code features into the platform.
thus variant integration differs from traditional software merging which does not produce or organize configurable code but creates a single system that cannot be configured into variants.
in practice variant integration requires fine grained code edits performed in an exploratory manner in multiple iterations.
unfortunately little tool support exists for integrating cloned variants.
in this work we show that fine grained code edits needed for integration can be alleviated by a small set of integration intentions domain specific actions declared over code snippets controlling the integration.
developers can interactively explore the integration space by declaring or revoking intentions on code elements.
we contribute the intentions e.g.
keep functionality or keep as a configurable feature and the ide tool incline which implements the intentions and five editable views that visualize the integration process and allow declaring intentions producing a configurable integrated platform.
in a series of experiments we evaluated the completeness of the proposed intentions the correctness and performance of incline and the benefits of using intentions for variant integration.
the experiments show that incline can handle complex integration tasks that views help to navigate the code and that it consistently reduces mistakes made by developers during variant integration.
i. i ntroduction software variants emerge when architects experiment with new ideas or customize systems towards new market segments new hardware platforms runtime environments or non functional properties.
variants are often created by cloning copying existing code and adapting it to new requirements by implementing new or modifying existing features .
cloning is easy and cheap .
however the long term effort of maintaining and evolving cloned variants outweighs the benefits as soon as a few variants exist.
when the challenges of maintenance and further evolution accumulate architects often choose to re integrate forked variants to benefit from code reuse techniques.
one popular way is to build a configurable platform or a software product line that shares the variants common code and allows to configure the variable features.
the latter are typically represented by configuration options features that control variation points e.g.
preprocessor directives such as ifor ifdef .
most work completed while at it university of copenhageneven though re engineering variants is the most common way to create integrated platforms in software industry concerningly few methods and tools exist for the problem of transforming existing variants into a configurable platform much less than for creating product lines from scratch.
prior work has mainly focused on understanding the commonalities and differences among variants largely sidestepping the actual integration.
integration research appears necessary to bring software product line results to a broader practice.
not only is integrating cloned variants challenging but it also consumes the most valuable resources in software teams.
one of our industrial project partners states developers tend to be specialized in one variant.
they have difficulties to switch from one variant to another .
due to these difficulties merges are done by the most experienced developers who we would want to use on more useful tasks.
a developer performing the task needs to understand the richness of the variants and their differences.
she also needs to consistently distinguish and integrate evolution changes common code and variable code injecting variation points.
our main contribution is to help this second challenge of integrating variants into a configurable platform.
we use a running example to illustrate the difficulties of integrating variants through an integration task .
the two code excerpts on the left in fig.
are simplified variants of a file adapted from the mainline and a fork of the 3d printer firmware marlin .
to integrate them the rightmost excerpt developers need to comprehend the code understand the differences and how they are aligned make design decisions e.g.
what to keep what to remove and do low level edits.
this can be done in many ways.
developers apparently need to explore different possibilities and undo frequently.
specifically they need to obtain a single consistent ifhierarchy guarded by correct if expressions.
this is especially cumbersome and error prone when multiple variations in forks overlap.
we show in sec.
ii that it is difficult for integrators to align changes and obtain an overview on the variants even when using a modern diff tool.
developers sometimes even give up to integrate larger and conflicting variants especially when variants have intricate and undisciplined ifstructures typical in configurable c projects including our evaluation subjects .
to overcome some of the difficulties of integrating variants we show how to partially automate the process and how to make it more flexible by centering it around recording and revoking mostly independent higher level decisions.
these decisions called integration intentions are programming8312019 ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ifdef ultipanel uint8 t lastencoderbits uint32 t encoderposition if pin exists uint32 t blocking enc endif uint8 t lcd sd status endif ultipanel menu t cm lcd status scrn bool ignor click false mainline ifdef ultipanel uint8 t lastencoderbits int8 t encoderdi g1 uint32 t encoderposition if sdcarddetect uint32 t blocking enc endif bool lcd oldcardstatus endif ultipanel menu t cm lcd status scrn bool ignore click false 11fork ifdef ultipanel uint8 t lastencoderbits ifdef newpanel int8 t encoderdi g1 endif uint32 t encoderposition if pin exists uint32 t blocking enc endif ifdef newpanel bool lcd oldcardstatus else uint8 t lcd sd status endif endif ultipanel menu t cm lcd status scrn bool ignore click false result edit operationscomprehension comparison and code alignment copy paste variant speci g1c code create valid ifdef hierarchy further code editsiterate and explore fig.
running example.
left mainline and fork variants to be integrated.
right integration goal.
middle necessary activities.
language independent actions declared over code.
intentions define how variants should be integrated whether to keep functionality declare variants as exclusive or extract a configurable feature.
consider the intentions in our running example .
the first difference is just one line of code that was added in the fork shown in the gray boxes .
the keepasfeature intention declared on this code element specifies that this code should be kept and a variation point should be added to make this line of code configurable.
next the keep intention specifies that the code from the mainline should be kept.
in the next difference the type of the variable has been changed and the variable receives a new name.
the fork s changes and the original code shall be kept and be mutually exclusive.
this is achieved by specifying the exclusive intention which adds the corresponding if else endif structure around the mainline and fork code.
finally the last line of the code contains a typo and thus the keep intention is applied on the fork s code and remove intention is applied on the mainline .
while intentions do not replace domain knowledge they support exploring different integrations much more flexibly than an undo system.
users can immediately observe results and revoke some of the recorded intentions with no undo stack discipline .
intentions can be nested.
even though intentions are intuitively simple their resolutions on code can be complex e.g.
when intentions interact automatically creating variation points i.e.
ifstructure and the created ifstructures are correct by construction.
we propose and define the integration intentions and implement a prototype ide tool incline intention based clone integration .
incline works with c preprocessor but it is otherwise language independent.
it offers five editable views on the variant code.
unlike the views of diff tools designed for code merging our views take integration of variants with configuration options as a first class concept.
we evaluate the feasibility effectiveness and efficiency of intention integration with incline using five popular open source systems with forks marlin a 3d printer firmware vim a unix text editor busybox a suite of shell tools libuv an io library and php an interpreter.
we perform a set of realistic variant integration simulations with file variants up to 4k lines and a controlled experiment with participants.
we find that intentions are sufficiently rich to integrate real variants and their resolutions if ultipanel uint8 t lastencoderbits preview if ultipanel uint8 t lastencoderbits fork view if ultipanel uint8 t lastencoderbits mainline view side by side view if ultipanel uint8 t lastencoderbits uint32 t encoderposition mainline fork if pin exists uint32 t blocking enc endif if sdcarddetect uint32 t blocking enc endifmainline fork int8 t encoderdiff mainline fork bool lcd oldcardstatus uint8 t lcd sd status endif menu t cm lcd status scrn mainline fork bool ignore click false bool ignor click false remove intention automaticall y added exclusive intentionnewpanel!newpanelkeep intentionkeepasfeature intention keep intentionnewpanel fig.
the integration of our example with incline.
developers add intentions on the code within different views.
are correct.
most importantly developers make less mistakes when integrating with incline and find declaring intentions simple and intuitive compared to manual integration.
we hope that incline can further advance the integration practice and can be used as a device to obtain more data from industrial partners and open source developers about this process with a further improvement in view.
ii.
m otiv ation and background we now discuss variant integration challenges.
these originate from our running example our own action research experiences with industrial partners and open source variant rich systems as well as a think aloud exercise.
in the latter we let three developers execute two integration tasks respectively from marlin and busybox using eclipse s diff tool.
the participants received three files one with the mainline code one with the related fork code and the target solution.
the marlin files had over lines of code and over ifdef blocks the busybox files lines of code and only two ifdef blocks.
during the integration the participants were asked to speak aloud about what they are we recorded this process and reviewed the spoken comments used to illustrate and confirm challenges in this section.
in the following we refer to our running example and the think aloud participants.
challenge variant integration is not code merging .
variant integration differs from traditional code merging authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
our running example in a traditional diff tool which combines changes performed in isolation into asingle system .
merging does not directly support realizing variants or building a configurable platform.
traditional merge algorithms combine as much code as possible and delegate conflicts they cannot resolve to the developer.
in contrast our focus is on efficiently transforming system variants that were developed in parallel and that can realize conflicting i.e.
mutually exclusive functionality into a platform where they can co exist.
deciding whether a change should be shared by all variants or be specific to some variants has to be done regardless whether a merge conflict occurs or not.
even smoothly merging changes might need to become optional.
research on variant integration is found under the broader area of re engineering legacy products into a software product line .
however works in this area almost solely focus on discovering commonalities and variabilities between codebases to gain an understanding of how similar or far apart they are together with research on identifying and locating features or synthesizing so called feature models .
challenge domain knowledge .
integration requires domain knowledge of the developer which we cannot alleviate.
yet even with such knowledge the comprehension of what changed in the variants is a challenge.
consider viewing the excerpts from our example in a traditional diff tool which highlights the differences but does not help with the integration.
working with a diff tool the developer needs to comprehend such diffs while editing the text to create an appropriate ifstructure.
in fact all our think aloud participants confirmed this challenge and demanded better views to explore the variants and to observe how changes influence the result.
challenge code alignment .
a closely related challenge is code alignment confirmed by all think aloud participants.
diff tries to align text and changes but often fails leading to mismatching.
furthermore using a single view where variants are explored and also modified is problematic since edits change the diff.
using a new file where changes are copied into increases effort also cognitive effort unfortunately.
one think aloud participant stated the need to create a new file where all the changes should be stored such that the two variant views can be used to understand the differences.
another one was overwhelmed by the diff tool highlighting every line.
challenge create a valid variation point structure .
developers need to create a target ifstructure edit the code to include respective changes and create presence conditions boolean expressions over features determining when the respective code is included in a variant derived from the platform .
in our running example the fork s line added variable encoderdiff could be either made mandatory1 ifdef ultipanel uint8 t lastencoderbits ifndef fork uint32 t encoderposition if pin exists else fork int8 t encoderdiff uint32 t encoderposition if sdcarddetect endif fork fig.
an invalid ifstructure created by diff d for our example .
grey lines show the added structure red lines violations due to existing variant ifs.
or optional the latter by adding an ifdef newpanel.
furthermore the fork s lines could also belong to this feature or another one depending on domain knowledge the most trivial solution would be to create a new feature that represents the variant we will call such a feature fork in the remainder and wrap the complete files in an ifdef else block.
this fails to recognize any commonalities and creates much redundancy not providing any benefit.
another strategy could be wrapping all differences in ifdef blocks.
gnu s diff tool using diff w d fork file1 file2 actually supports that where fork would be the feature name.
however this can easily lead to an invalid ifstructure since the added directives interfere with existing ones in the variants.
this happens for our example as seen in fig.
.
figure shows a correct structure.
challenge low level editing .
traditional integration amounts to many low level editing tasks many of which need to be explored by developers.
for our running example a developer could perform the following edit operations bottom right based on her domain knowledge that the fork realizes a feature called newpanel take mainline as a base copy fork s line and add ifdef newpanel to make it optional.
copy line from fork above line in mainline wrap by a new ifdef newpanel move mainline s previous line to the respective else branch to preserve mainline s functionality.
fix typo on mainline s line as already done in the fork line .
essentially this amounts to line level based editing operations e.g.
highlight a line copy it write an ifdef newpanel .
challenge introduce features .
the strategy of pairwise diffing and wrapping changes in ifdef s is relatively common.
ifdef ultipanel uint8 t lastencoderbits ifdef fork int8 t encoderdiff endif defined fork uint32 t encoderposition if defined fork pin exists !defined fork sdcarddetect uint32 t blocking enc endif ifdef fork bool lcd oldcardstatus else uint8 tl c d sd status endif defined fork endif defined ultipanel menu tc m l c d status scrn ifdef fork bool ignore click false else bool ignor click false endif defined fork fig.
the default integration for our running example authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for instance the company danfoss used it to integrate forks creating features representing individual variants.
while this integration was quick months for a system with .5m lines of code it took four years to achieve the desired platform.
the process was mostly manual with minimal tool support during it the platform was iteratively verified.
it was especially challenging to refactor the variant based features into around variant cross cutting intuitive features e.g.
a feature representing a specific motor instead of product a .
challenge iterative exploration of the integration .
recall that many different edit sequences can lead to the desired integration.
developers need to explore their edits including refactoring ifstructures and backtracking undo changes which can be cumbersome and error prone for lowlevel editing.
for instance consider lines in the mainline and lines in the fork .
in our example the order of these blocks when integrated does not matter since they have no side effects.
but if these were statements it might be necessary to move them to the right order an insight developers could just obtain after a first integration.
all our think aloud participants confirmed the need for an iterative exploration with the ability to easily undo changes.
challenge cognitive load of variability .
there is also the cognitive load of the c preprocessor whose ifdirectives clutter source code and challenge comprehension .
this can easily lead to code ending up in the wrong variant the wrong ifblock .
graphical representation of the preprocessor using dedicated tools have been proposed in the literature but not for variant integration.
iii.
i ntegration with incline incline addresses the challenges described above as follows.
challenge variant integration is not code merging .
instead of merging incline creates an integrated platform with a valid variation point if hierarchy.
incline s input are pairs of file variants mainline and fork .
the variants written in any programming language may already contain features and variation points using ifdirectives which incline reads and manipulates.
incline shows differences in multiple editable views explained shortly including a view providing a default integration.
for the latter incline adds the feature fork and wraps variant specific code with the presence condition !fork mainline or fork fork conjoined with presence conditions of already existing variation points in the variants.
figure shows the default integration for our example .
challenge domain knowledge .
to foster comprehension the developer can navigate and comprehend the default integrated platform the variants and their differences using five views .
figure displays four of the views.
the mainline view and the fork view top left and top right of fig.
show the previous variants internally realized as a partial configuration of the default integrated platform .
the green bar represents a keep intention explained shortly .
the integrated side by side view bottom left of fig.
shows the integrated platform but with the differences between mainline and fork arranged next toeach other without ifdef directives.
the fifth view illustrated in fig.
called integrated view would display the integrated platform like the integrated side by side view but using if annotations.
the result view bottom right of fig.
previews the final result with all intentions resolved.
on a side note we implemented incline using the language workbench mps .
it relies on projectional editing a.k.a.
syntax directed or structural editing where a user s editing gestures directly change the underlying ast without using any parser.
the ast is still rendered into concrete syntax program code .
projectional editing is well suited for creating editable views.
the variant views rely on a partial configuration of the variational ast for which we use z3 to reason about presence conditions and calculate the projections.
challenge code alignment .
the integrated side by side view arranges the differences between mainline and fork differently than an ordinary diff tool would do.
within the source code the view aligns chunks of code that are common and shows chunks of code that differ in horizontal boxes which can be nested just like preprocessor directives can be nested .
showing the boxes and even nesting them is possible through the technology projectional editing.
this helps to represent the code that differs together side by side.
challenge create a valid variation point structure .
incline implements a simplified version of the c preprocessor language ifdef else if elif endif directives .
the actual program code is stored as an unstructured uninterpreted text string of characters .
so incline is independent of the host language and would work on say c programs the same as on c programs without modification.
to enhance editing the target language e.g.
code completion syntax highlighting our preprocessor language could also be composed with a language available in mps such as c99 .
to import existing source files into incline we buil t a c preprocessor parser upon clang .
to create the integrated variational ast we use the input files parse results to create xml based representations of their asts and then use jndiff to obtain a valid variation point hierarchy which is then transformed into our variational ast explained shortly in sec.
v .
challenge low level editing .
as the main contribution incline aims at alleviating low level editing operations to improve the efficiency of developers and to reduce mistakes e.g.
writing incorrect presence conditions or creating a wrong ifstructure where code ends up in the wrong variants .
intentions specify the goal of integrating a change that is how the integrated ast should be customized with respect to the input variants.
for instance a developer could ask should the change be made common to all variants?
or only to some of them?
or should it remain variant specific?
is the change standalone or is it intended to belong to a feature implementation?
in the views the developer defines intentions and if necessary can also manually edit the code.
challenge introduce features .
incline provides intentions keepasfeature assignfeature that are parametrized to allow specifying features.
when adding such an intention on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
screenshot of incline views mainline view top left fork view top right integrated side by side view bottom left and result view bottom right the code in incline the user is asked about the feature.
note that an effective management of an integrated platform also needs mechanisms for modeling and managing features and their dependencies.
these are however orthogonal concerns to variant integration and therefore beyond the scope of this work.
yet an integration would be valuable future work.
challenge iterative exploration .
when declaring intentions in the views the developer explores their effects in the views especially the result view .
since all views rely on one variational ast they are updated synchronized immediately.
intentions can be easily removed the same way they are added with just one keystroke.
furthermore since the integrated variational ast is always syntactically correct developers can at any time derive individual variants e.g.
to run a test suite .
challenge cognitive load of variability .
incline provides different views which allow developers to focus on specific variants or to focus on the differences between variants.
iv .
r esearch methodology definition of intentions .
to conceive our primary contribution the integration intentions we relied on three sources.
first we reflected on the variability mechanisms that appear in integrated platforms which include code that can be mandatory or optional controlled by presence conditions.
second we relied on experiences from the think aloud exercise.
third we inspected diffs of the marlin ecosystem.
marlin kloc of c code has over forks many of which evolve separately and independently add new functionality.
given this richness and the existing re integration efforts of the community marlin is an ideal subject for conceiving intentions.
since most forks contain no or just minimal changes we specifically looked at forks that implement new features and how they were either already integrated into the mainline or what challenges anintegration would entail.
we also inspected merge commits that involved preprocessor directives pull requests and conflicting commits all examples of developers performing integrations while dealing with variability.
in the remainder we formally present the intentions and their deterministic resolutions.
we will later show that these intentions are sufficient for integrations in five open source systems including marlin.
tool design .
conceiving an end user tool is intrinsically difficult especially given the resources of researchers.
to obtain a usable tool the design followed an iterative process with a prototyping and evaluation feedback loop.
in our first prototype of incline we implemented the basic functionality source file import user interface to declare intentions and back end to resolve intentions.
after that we have executed a pilot user study to detect and resolve inefficiencies in the tool.
to check the usability of the first prototype we recruited msc students to execute two integration tasks.
we compared the performance of incline against eclipse s diff merge tools.
we extracted two tasks from the histories of busybox and vim.
each task concerned the integration of code from a fork for vim one that adds support for command line completion for busybox one that is tailored for android to the mainline.
the participants were given a correct target integration and a brief description of the integration goal.
showing a target solution was a pragmatic way to reduce the influence of lack of domain knowledge for this first usability check.
the subjects solved the task in controlled time.
we observed how they worked using screen recordings.
the tasks used are available in the online appendix .
improvement cycle .
based on the results we improved the prototype and customized the default configuration.
specifically we i added keyboard shortcuts for intention declaration actions as we could see in the screencasts that mouse input and menus were inefficient ii by default arrange views as in fig.
and use integrated side by side view instead of integrated view by default iii for convenience added heuristic proposals for further intentions to the user e.g.
when keep declared for all nodes in an ifbranch incline proposes a corresponding remove intention for the nodes in the else branch and iv improved the highlighting of the applied intentions so it is easier to see for which nodes intentions have been declared and reduced the observed trial and error.
evaluation .
we replayed real edits mined from the history of five variant rich open source systems and conducted a controlled experiment.
see sec.
vi for details.
v. t heintegration intentions we propose the following intentions to be used for highlevel control of the integration process keep keepasfeature exclusive remove assignfeature and order .
a. v ariational ast and views a variational ast is a syntax tree with embedded ifs.
to simplify the discussion we often see it just as a set of nodes nodes .
for each node n we identify a sequence of conditions cn cn cn k used in the ifs on the path from the ast s authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
root cn t on cn k .
a node that is not wrapped by any ifdef non variable node has an empty sequence of conditions.
we define the presence condition pc n to be the conjunction of all conditions used by the ifs the node n nodes is contained in.
for a non variable node it is true.
pc n logicalanddisplay i ..kcn i we define a block as a set of nodes in the ast block p nodes .
we also introduce an order of nodes which describes the syntactic order of the c c program.
if a node n1 exists before node n2in the syntactic order we write n1 n .
aview is a projection of the ast showing only a specific set of variants specified by a view constraint over features.
for the views mainline and fork fork and fork respectively.
for the integrated views true.
of course can be a more complex expression not just a literal to filter out more variability not relevant for the integration.
in the remainder we limit ourselves to simple view constraints though.
note that the view through which an intention is declared forms the context for the intention and as such influences its resolution.
to determine how conditions are shown in a view we substitute every occurrence of the view constraint in the conditions with true n nodescn cn wherecn denotes the conditions shown in the view.
in the variant views we render the ast as follows we hide nodes where pc n false we show nodes without the surrounding ififcn k true for the remaining nodes we simplify presence conditions with respect to the view constraint using an smt solver special care needs to be taken for blocks containing nodes with complex presence conditions.
complex conditions contain both the view constraint and some unrelated terms.
when using views a complex presence condition is shown as a non complex condition since the view constraint is simplified.
still the hidden view constraint is part of the context that the intentions are declared in just as if the node was implicitly wrapped in an ifwith the view constraint as its condition.
formally we say a condition is complex iffcn negationslash cn .
for an ifnodenwith a complex condition we rewrite the sequence of conditions so that it ends with the view constraint.
we use the notation pc n to denote the presence condition of nodenin a view with constraint pc n logicalanddisplay i ..kcn i b. semantics of intentions we now define the individual intentions and illustrate them with examples.
intentions are partial functions transforming asts.
we formalize their semantics as effects they have on the presence conditions and ordering of nodes.
in sec.
v c we show how the intentions are resolved implemented on the ifndef fork block not fork int servo e1 se int servo e2 sea else block fork int16 t servo e1 se int16 t servo e2 sea endifint servo e1 se int servo e2 sea ifdef fork int16 t servo e1 se int16 t servo e2 sea endif fig.
keep intention left and result right ifdef fork block fork card.pausesdprint endif ifdef sdsupport card.pausesdprint endif fig.
keepasfeature intention left and result right ast.
the figures for instance fig.
show the integrated ast on the left selected nodes on which an intention is declared in gray and the desired result on the right.
the examples use the integrated view which shows all variants at once.
the verbosity of this view makes it most suitable to explain how intentions work.
for each intention we use the notation pc prime n to illustrate the resulting presence condition of the node n andpc n for the presence condition before the intention resolution.
keep .
the keep intention includes a block as it appears in mainline or fork in an unconditional manner without guarding it with any additional feature.
consider the example in fig.
where we define block not fork to represent the set of nodes in the fork branch highlighted with gray and the block fork represents the set of nodes in the fork branch.
the fork changes the type of the servo variables to be bit signed integers because different hardware and compiler are used for this variant.
during the integration process it is decided that the hardware used in the fork should no longer be supported and only the code from mainline is kept.
we apply the keep intention on the block not fork set of nodes.
the right side shows the result of applying keep on the selected block not fork .
note that the integration is not completed as there is still a block from the forked variant which should be resolved later.
the effect of keep block on the presence conditions is pc prime n braceleftbigg cn ... cn k ifn block pc n otherwise the nodes for which keep was declared should no longer be under the constraint created by the ifdef that directly wraps those nodes.
their new presence condition is the conjunction of all but the last constraint that directly wrapped the nodes.
all nodes that are not part of the intention are unchanged.
keepasfeature .
the keepasfeature intention preserves a block from one of the variants but makes it conditionally present only linked to a certain feature or combination of features.
it wraps the block with a new presence condition given with the intention.
in the example of fig.
a fork developer added functionality to pause a 3d print from an sd card.
not concerned with other devices than the one for which the fork was developed she included the new behavior unconditionally.
however in the integration process it became clear that this functionality only makes sense in variants supporting sd cards thus it needs to be included conditionally.
the desired result is shown on the right side of the figure.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
keepasfeature block f replaces the last constraint from the sequence of constraints with the new presence condition pc prime n braceleftbigg cn ... cn k f ifn block pc n otherwise exclusive .
this intention declares that two code blocks should be mutually exclusive enforcing the separation of conflicting functionality controlled by a choice condition.
in fig.
the fork introduces a new optional feature fil display and keeps the line that prints a message on the lcd display under a specific condition.
the integration requires keeping the optional feature and ensuring that when this feature is not selected a message is shown on the lcd to not break the mainline variant .
therefore we keep both blocks as a mutually exclusive implementation using the exclusive intention.
we introduce the helper function common block which returns the longest common subsequence of conditions of nodes in the block semantically akin to the prime implicate of the set of presence conditions of the block s nodes common block c1 ... cssuch that n block logicalanddisplay i ..kcn i logicalanddisplay i ..sciandsis maximal such .
then the exclusive block1 block2 f has the effect as follows pc prime n common block block f ifn block common block block f ifn block pc n otherwise we use the common conditions of the nodes in block 1and block 2as the basis and then include the feature condition f or its negation to control the selection of the variant.
remove .
this intention deletes the selected nodes from the ast.
by definition it ensures that the selected nodes do not exist in the updated ast n block n ast prime assignfeature .
this intention is used when code was already integrated but its presence condition should be changed.
this intention can only be declared for complete if else endif blocks.
fig.
shows the renaming of feature sd left to sdsupport right .
the effect of assignfeature n f is that the last constraint of nodes from both branches ifand else of the ifdef block is replaced with the given feature and ifndef fork block lcd.print msg else ifdef fil display block if condition lcd.print msg else lcd.print trnsf data endif endif ifndef fil display lcd.print msg else if condition lcd.print msg else lcd.print trnsf data endif fig.
exclusive intention with the three parameters block block fil display left and result right ifdef sd card.pausesdprint endif ifdef sdsupport card.pausesdprint endif fig.
assignfeature intention left and result right respectively the negated feature pc prime n cn ... cn k f ifn if branch of n cn ... cn k f ifn else branch of n pc n otherwise .
order .
this intention prescribes an order of blocks from the variants for the integrated ast with respect to the concrete syntax .
as a notation we resort to the operators and which declare that the first block be put before the second block and vice versa.
this intention re orders blocks or ensures their correct order during integration especially when further intentions are applied.
for example we apply the intention keep on a mainline and a fork block but we want the mainline code to be executed first we declare order block fork block main which then yields the correct order.
c. intention resolution we conceived a deterministic ast in place transformation to resolve intentions which needs to consider alldeclared intentions at once since intentions can interact.
although intentions are declared on blocks of nodes their resolution will affect other nodes.
we resolve intentions in a specific order based on our own defined intention priority andon the ast structure top down from outermost to innermost node .
the intention priorities are descending from resolved first to resolved last keep keepasfeature exclusive order assignfeature remove .
this priority aims to minimize unexpected interactions of intentions.
for example when resolving a keep a node might be moved out of its parent for which a remove intention could be declared.
the priority ensures the node is actually kept in the result and not overruled by the remove intention.
each intention resolution will use the result from the previous intention resolution as its base therefore the resolution of one intention will likely influence the resolution of intentions that are declared for descendant nodes.
the idea is that intentions for descendant nodes do not influence parent nodes.
each intention is resolved as following keep .
to resolve keep block any nodes before and after block that are in same ifasblock are wrapped in newly created ifstatements and the nodes in block are moved out of their current if.
recall that the view determines the context for intentions cf.
sec.
v a and that in the variant views the ifconditions shown are simplified feature fork is enabled or disabled .
if a keep intention is declared on such an ifwith a simplified condition in the view then the simplified condition is propagated to the ast.
keepasfeature .keepasfeature block feature is resolved like keep except that the nodes unwrapped during the keep step are now wrapped in a new ifwith the condition feature .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
exclusive .
we resolve exclusive block block feature using keep onblock 1andblock .
the results are wrapped in an e w ifwhere the nodes of block 1are moved to the true branch and the nodes from block 2are used in the else branch.
the condition of the new ifis given by the parameter feature .
order .f o r order block block we assume the nodes of block 1andblock 2have the same parent.
if all nodes in block are before the nodes of block based on their position in the parent s list of child nodes we switch their position.
we perform this action similarly with reversed parameters for operator .
remove .f o r remove block we remove all nodes in block from the ast.
nothing happens when a node was already removed e.g.
remove was declared for an ancestor of the node .
a generic cleanup step after intention resolution removes empty ifnodes which do no longer contain any nodes.
vi.
e v aluation to establish how well incline supports developers during variant integration we formulated the following questions.
heir evaluation methods are detailed in the following subsections.
rq1 what is the coverage of the proposed set of intentions with respect to real world integration needs?
rq2 is the implementation of intention resolution correct with respect to their semantics even for large files?
rq3 what is the benefit of incline over manual variant integration from users perspective?
subject systems .
we chose open source systems that use preprocessor directives to implement variability and for which real forks are available.
we used active projects from different domains to minimize the bias towards a particular usage of the preprocessor.
links to the projects are in our online appendix .
it is key to identify files for which alternative or new functionality has been added in a fork so a realistic case for integration with variability can be made as opposed to simple merging without variability used for development branches .
marlin kloc of c code is a 3d printer firmware.
busybox kloc of c code is a collection of common shell commands e.g.
grep cut for embedded linux applications.
vim kloc of c code is a popular terminal based text editor extending the unix vi standard.
libuv kloc of c code is a popular io library.
php kloc of c code is the interpreter for the php scripting language.
a. rq1 coverage of intentions method .
to show that the defined set of intentions is complete enough to handle real world integration tasks we replay nontrivial merges from the history of marlin libuv and php.
for marlin we retrieved all merge commits of the mainline repositories.
to identify complex merge tasks we extracted those that had conflicts yielding merges.
we discarded two merges that conflict only in documentation files two conflicted in whitespace and three conflicted in user configuration files.
another three merges were discarded because the pertinent artifacts had syntax errors and could not be compiled.
additionally four merges were discarded because they simply accepted the mainline changes as evolution emptychangeset .
in addition to the resulting merges we selected commits from two more projects libuv and php in the same way.
from over merge commit with conflicts we sampled commits from each project.
we used the remaining merge commits as tasks.
we manually integrated these cases selecting intentions and performing the integration so that the result was identical to the original historical merge.
results .
using intentions for integration is successful in all cases.
in two of these cases additional code was added during the merge which we needed to add in addition to the intentions as well.
we observed neither obviously missing intentions nor cases requiring awkward sequences of intention applications.
conclusion the proposed set of intentions suffices for realworld variant integration.
b. rq2 correctness scalability of incline method .
we validated that incline produces correct results when correct intentions are assigned and that we can use it on large files without scalability problems.
we simulated ten marlin integrations in total.
the first group of seven commits was selected randomly from the merge commits of the previous experiment.
the second group are three integration tasks selected from marlin forks see appendix to avoid focusing on merge conflict commits only in this group we merge parallel lines of development that have not been merged before .
the selected forks contain significant changes to the mainline covering both evolution and new features.
most tasks comprised only a single file some two or three but each file can be very large up to nearly loc and ifdef blocks to be handled during the task .
three authors served as evaluators among whom we randomly distributed the ten tasks to execute with incline.
we then manually peer reviewed the integration results to detect any discrepancies from the specifications of semantics in sec.
v b. results .
we only found minor errors in the implementation of incline.
these errors have been fixed before proceeding to the next experiment.
we also analyzed mistakes done by the authors to improve the usability of incline.
furthermore the broad range of file sizes from tens up to thousands of lines of code witnesses the scalability of the tool.
the intention resolution is instantaneous for smaller files and for the largest file loc it took about 2s on a regular office laptop.
conclusion incline produces semantically correct output and it scales to files up to 4k lines of code without difficulties.
c. rq3 benefits of incline method .
we conducted a controlled experiment with developers experienced phd students using incline and eclipse to solve realistic tasks from vim and busybox those from the improvement cycle cf.
sec.
iv .
in reality a developer has some domain knowledge about the variants to be integrated.
we captured this in the experiment setup by providing a detailed explanation of the purpose of the variants parts and how they should be integrated but unlike in the improvement cycle authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
busybox vim eclipse incline eclipse incline255075 a edit operations intentionsbusybox vim eclipse incline eclipse incline50010001500 b task completion times seconds busybox vim eclipse incline eclipse incline012345 c errors fig.
effort completion times and errors we did not present the expected final result .
we used a 2x2 within subjects counterbalanced latin square design incline vim eclipse busybox incline busybox eclipse vim eclipse vim incline busybox eclipse busybox incline vim each participant performed two tasks using two treatments eclipse and incline in a random order to reduce learning effects.
using a within subjects design we lower the number of participants while every subject participates in each task.
furthermore we mitigated learning effects by randomizing the order of the tasks counterbalanced part of the design .
participants were trained through a video tutorial on how to use both tools as well as being instructed on preprocessor usage they only needed to use ifdef else and endif .
each participant first solved a training task extracted from marlin to get familiar with the tools.
the training task performance is not included in the experiment results.
during the actual experiment we recorded the screen and log keystrokes in eclipse and intentions in incline .
we measured the performance of subjects using proxies number of mistakes per task the time to complete each task and the number of edit operations and number of intentions applied per task.
we counted mistakes made by the subjects as follows.
for eclipse a mistake can be a missing preprocessor annotation missing code or extra code this is because eclipse merge tools are text editing oriented.
for incline we check for wrong intentions or no intentions applied by the participant that leads to errors in the resulting file.
for both tools errors concerning comments were counted as a half mistake errors in formatting of code are ignored.
results .
the subjects using incline made less mistakes than those using eclipse mistakes vs .
.
only four participants made integration errors working with incline compared to eleven with eclipse.
this is no surprise incline has better support for keeping or removing code without using clipboard and the syntax of ifdef structures created by incline is correct by construction.
the mistakes with incline included missing relevant nodes in the declared intentions mistakes declared incorrect intentions or declared different intentions for the same node with an unexpected result for the user .
common mistakes with eclipse included lines guarded by incorrect presence conditions leaving code that should be removed removing too much and a broken ifdef structure .
in four cases subjects integrated code in wrong order which we accountwith a half error each.
incline required less decisions to be executed during integration .
the busybox task involved intentions on average while almost edit operations were used in eclipse on average to achieve the same goal.
this effect is not so pronounced for the vim task where the performance is similar for incline .
for eclipse .
the most commonly used intentions were keep keepasfeature and remove .
exclusive was not used often although ten users used exclusive at least once.
assignfeature and order were not used at all.
assignfeature is an escape intention that allows to handle unanticipated changes and order is rather intricate these two not being used speaks well for the expressiveness of the core intentions.
subjects performing incline integrations were almost as fast as the eclipse users .
it appears that the tasks are relatively small so substantial influence comes from understanding the variants.
second participants spend a lot of time which we count in the result reading back and forth through the descriptions to understand the integration goal.
third some participants always verify the preview after applying an intention.
this likely happens as the users are not very familiar with the tool and intentions and thus either do not trust the tool or are not sure if they applied the right intention.
the efficiency of incline would likely improve greatly should the tool be used professionally.
for new users though incline shines already as it facilitates learning and exploration with quick undo and multiple views for manipulating the different variants and the integration result.
one of the subjects mentions that it was really useful to declare all the intentions while still having the original files in sight and previewing the result.
.
note that the times reported in fig.
11b do not include the cost of correcting the mistakes introduced by subjects.
since eclipse integrations contained more than twice the number of mistakes the actual cost of completing the integration with eclipse is likely much higher.
conclusion incline supports integration with lower error rate than eclipse merge tools with less edit operations at no significant increase in cost time .
we complemented the controlled experiment with a survey to gain qualitative insights on the benefits of incline.
method .
the survey was designed as a mix of closed and open questions.
the closed questions using the likert scale strongly disagree strongly agree target the intuitiveness of intentions and gauging how participants feel about their mistakes and integration difficulties with incline.
the open questions aim at gathering concrete evidence of the advantages and challenges of using incline suggestions for improvements and tool preference for integration tasks.
we sent the participants the survey via email after performing the integration tasks and received answers.
the questionnaire design and results are available in our online appendix .
results .
participants strongly agree mean .
standard deviation .
that the keep and remove intentions are intuitive.
however the exclusive intention seems more authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
confusing because the user cannot directly select it.
of the subjects agree and strongly agree that integration with incline is faster than with eclipse but none of the participants disagrees despite the actual time measurements saying the opposite even if not very strongly see fig.
11b .
one potential reason is that by not many clipboard operations or editing text incline appears faster through the usage of intentions.
similarly of the participants agree and strongly agree that intention based integration is not complex suggesting that there is potential for intention based integrations.
finally when asked what are the advantages of using intention based over manual integration some participants mentioned that less effort and reduction in human error due to either typing or copying and pasting or intentions are much more intuitive and user friendly.
saves you some typing and copy pasting.
the synchronized views were also very useful because you can choose either the mainline the combined view or the fork to make updates whatever is more convenient for the task at hand.
there is a consensus that incline is much more intuitive and less error prone.
d. threats to v alidity external validity .
we mitigated selection bias as the main threat in our evaluation by using multiple open source projects that have been actively developed and many variants have emerged.
we used both mainline source files as well as forks to create realistic integration tasks.
results from these projects are also valid for other systems since the c preprocessor is used similarly in open source and industrial systems .
for the controlled experiment we recruited experienced phd students.
only basic program understanding was required and we recapped the preprocessor use to mitigate any potential difference in programming experience.
finally recall that graduate students perform similarly to professional developers in software experiments like this one .
internal validity .
simple bugs in the tool chain can hide or distract from evaluating the intention concept.
we used an iterative design methodology even conducting a pre study as an experiment with msc students just to validate the prototype and to find usability issues to be fixed.
the experiment participants using incline have disadvantages compared to plain merge tools mostly due to the lacking experience and the ui of a research prototype.
it is very likely that this negatively biased the performance so our results regarding the benefits of incline can be seen as lower bounds.
still we mitigated this threat by training users through a tutorial and a warmup task for incline.
we also randomly assigned the tasks to the participants minimizing the learning effects.
vii.
r elated work many works focus on re engineering a single system into a product line typically proposing refactoring techniques for creating configurable platforms.
the main difference is that we focus on integrating multiple system variants into a product line systematically guiding the process with intentions and views.
others provide support for evolving existingproduct lines .
for instance liebig et al.
provide three refactorings rename identifier extract function inline function that preserve the variants.
instead we support obtaining product lines .
our intentions are explicitly not variant preserving.
a recent mapping study on re engineering variants into product lines shows that the majority of papers on this topic focuses on detecting and analyzing commonalities and variabilities of the variant systems .
only the following few support the actual variant integration.
rubin et al.
present a conceptual framework with seven operators to reengineer cloned variants into product lines.
the operators are abstract and some are related to our intentions but none is implemented.
we provide full tool support instead.
fischer et al.
propose a method to detect reusable features among variants allowing to compose them to derive a new system.
martinez et al.
present a framework for re engineering a set of assets into a product line .
all these works lack support for handling variability using preprocessor directives as the most common technique for variation points.
case studies of manual re engineering also exist.
hetrick et al.
re engineer cloned variants into a product line creating variation points and switching to product line engineering .
jepsen et al.
compute pairwise differences of two products and wrap differences using ifdef to create the initial integrated platform.
the platform was iteratively refined deciding to keep remove or introduce a new feature .
recall that variant integration is different from traditional merging.
still we are inspired by techniques known from it.
our technique for creating the initial integrated platform works on asts and as such is related to structural merge and diff merge for models beyond asts .
viii.
c onclusion we presented a method and a tool to integrate forked variants into a configurable integrated platform.
the core idea is to offer a set of intuitive integration intentions resembling domain specific actions to execute integration tasks.
instead of focusing on low level ifdirectives developers can express the integration goal using intentions declared on code blocks of the original variants make edits to the code and immediately observe the result.
the experimental evaluation shows that the method reduces the number of required editing operations and the number of integration errors against a baseline of a merge tool.
we also showed that it can handle complex integration tasks and merges with conflicts.
declaring intentions was easy and only rarely direct editing was required.
although understanding the integration goal is sometimes difficult the different views help to explore and navigate the code.
applying intentions and revoking them is particularly useful to explore the result before committing the changes.