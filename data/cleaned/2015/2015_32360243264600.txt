sketchfix a tool for automated program repair approach using lazy candidate generation jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid the university of texas at austin usa lisahua mengshi.zhang kaiyuanw khurshid utexas.edu abstract manually locating and removing bugs in faulty program is often tedious and error prone.
a common automated program repair approach called generate and validate g v iteratively creates candidate fixes compiles them and runs these candidates against the given tests.
this approach can be costly due to a large number of re compilations and re executions of the program.
to tackle this limitation recent work introduced the sketchfix that tightly integrates the generation and validation phases and utilizes runtime behaviors to substantially prune a large amount of repair candidates.
this tool paper describes our java implementation of sketchfix which is an open source library that we released on github.
our experimental evaluation using defects4j benchmark shows that sketchfix can significantly reduce the number of re compilations and re executions compared to other approaches and work well in repairing expression manipulation at the ast node level granularity.
the demo video is at ccs concepts software and its engineering software testing and debugging keywords program repair program synthesis program sketching acm reference format jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid.
.
sketchfix a tool for automated program repair approach using lazy candidate generation.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction automated program repair apr has shown much promise to reduce human effort in debugging.
a common repair approach is generate and validate g v where candidate fixes are iteratively generated and validated against the given tests.
however traditional g v techniques require many candidates to be re compiled and re executed until a candidate permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
passes all tests is found.
the times for re compilation and reexecution are non trivial especially for open source projects.
our recent work introduced sketchfix that enhances the traditional g v approach.
the novelty of sketchfix is that it reduces the compilation and execution overhead by tightly integrating the generation and validation phases and using lazy candidate generation.
intuitively sketchfix utilizes precise runtime information to create candidates as needed.
to illustrate consider trying to fix a faulty while loop condition and the body of the loop if a test execution raises an exception when evaluating the condition candidate of the loop sketchfix does not consider any candidate in the while loop body because the body is never executed.
different from traditional g v approaches that generate thousands of concrete candidates sketchfix does not create any concrete candidates for the parts of the program that are not reached by the test executions.
this lazy candidate generation approach leverages runtime behavior to substantially prune a large part of the search space.
another common repair approach is based on constraint solving which uses off the shelf solvers to synthesize repairs based on the constraints created from faulty programs and tests.
such techniques generally reason about boolean orinteger type and can hardly handle non primitive type expressions in presence of complex libraries e.g.
angelix cannot repair subjects from python and lighttpd .
without translation to sat sketchfix explores the actual runtime behavior to synthesize repairs in presence of libraries.
moreover sketchfix can be applied to projects with unconventional structures whereas many tools e.g.
astor and acs cannot repair defects from the closure project due to its non standard test cases.
this paper describes the java implementation of sketchfix .
it performs fine grained repairs at the ast node level.
given a faulty java program and a test suite as input sketchfix first uses an existing spectrum based fault localization technique called ochiai to rank suspicious statements based on the suspiciousness value.
for each suspicious statement sketchfix introduces holes at this location based on ast node level transformation schemas.
sketchfix provides apis to specify holes using java syntax that can be directly compiled and executed against the test suite.
sketchfix employs a sketch engine called edsketch to fill in the holes with backtracking search.
when a test fails due to either a runtime exception or an assertion failure the parts of the candidate program that were executed determine the generation of the future candidates.
sketchfix backtracks when it encounters exceptions or test failures and selects the next candidate until it finds a repair candidate that satisfies all tests.
sketchfix defines transformation schemas at a fine granularity and prioritizes schemas that introduce smaller perturbations to the original programs.
recent studies propose the insight esec fse november lake buena vista fl usa jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid input the path for source code and tests d4j .
dir .
src .
classes src d4j .
dir .
src .
tests test human written patch public vector2d intersection ... vector2d v2d line1 .
intersection line2 throw nullpointerexception if v2d is null if v2d null return null ... a sketch automatically generated by sketchfix public vector2d intersection ... vector2d v2d line1 .
intersection line2 if sketchfix .
cond ... return vector2d sketchfix .
exp ... ... output synthesized repair sketchfix .
cond v2d null sketchfix .
exp v2d figure the input and output of sketchfix that patches that are semantically closer to the original programs are more likely to be correct.
our ranking strategy is consistent with this insight which aims to mitigate the overfitting issue .
sketchfix is available at we evaluated sketchfix using defects4j benchmark.
with the default setting sketchfix correctly fixes out of bugs in minutes on average.
with lazy candidate generation sketchfix requires only .
of re compilations compiled sketches candidates and of re executions out of all repair candidates when it finds the first repair.
even if sketchfix exhaustively explores the entire search space it only compiles of all candidates sketches candidates whereas without lazy candidate generation all of candidates must be compiled.
example we describe sketchfix through a defect from the apache math project.
figure presents the input and output of sketchfix a human written patch and a sketch generated by sketchfix that leads to a correct fix.
note that the end user is not aware of the intermediate results sketches .
we list the sketch to illustrate the notion of lazy candidate generation.
given the path of source code and tests sketchfix uses the ochiai fault localization approach to identify a list of suspicious statement.
for each returned suspicious statement sketchfix applies ast node level transformations to generate sketches.
for each sketch sketchfix replaces the original source file with the sketch compiles it and executes the sketch against the given tests.
this process is automated and no other human effort is required.
in figure sketchfix transforms the faulty program to a sketch based on two ast node level transformation schemas a condition schema that introduces a new if condition and a return schema that inserts a return statement.
different from other repair techniques that generate a list of concrete candidates and compile them iteratively sketchfix uses a sketch with holes to encode all candidates of the if return repair template.
thus the sketch is compiled only once yet it represents hundreds of concrete candidates.
sketchfix executes the given test suite against the compiled sketch.
when the test execution reaches the hole sketchfix.cond ... instead of considering hundreds of concrete candidates such asv2d !
null and line1 !
line2 sketchfix only considers two boolean values true and false and selects either true orfalse to figure workflow of sketchfix fill in the condition hole.
if sketchfix selects false for the if condition it does not initialize any candidate in the return expression because the test execution does not reach the hole sketchfix.exp ... inside the if condition body.
in contrast traditional g v repair techniques can hardly utilize the runtime information that the condition is evaluated to be false.
as a result they must compile and execute all candidates for the body of the if condition that are not reached by the test execution.
in this example selecting false leads to a test failure.
sketchfix backtracks and selects the next candidate which sets the if condition to true.
when the test execution reaches the hole sketchfix.exp ... sketchfix lazily generates candidates for this hole and selects a candidate to fill in the expression hole.
in this example sketchfix selects the visible variable v2dto fill in the hole and this candidate passes all tests.
implementation figure shows the workflow of sketchfix .
given a faulty program and a test suite sketchfix first identifies a list of suspicious statements sorted by the suspiciousness value based on ochiai fault localization technique.
for each suspicious location sketchfix applies pre defined ast node level transformation schemas section .
to create sketches.
these sketches are directly compiled and executed against the test suite.
once the execution triggers test failures or runtime exceptions sketchfix backtracks selects the next candidate to fill the hole and executes the new candidate section .
against the tests.
.
ast node level transformation sketchfix performs a systematic reduction of program repair to program synthesis by translating faulty programs to sketches at a fine granularity.
the api provided by sketchfix mainly take three parameters an object list that contains all visible variables and default values null or a hole id to distinguish different holes for the same type and the target type of the generated candidates.
for instance the expression hole in figure is specified assketchfix.exp new object v2d line1 ... null vector2d.
class .
the target type of the hole is derived from the return type of the method based on java syntax.
different types of holes can have the same id yet this id must be unique across the same type of holes.
for example the condition hole in figure is sketchfix.cond new object v2d line1 ... null and sketchfix will not use the hole id to specify another condition hole.
if the target type of hole is unknown sketchfix takes the first two parameters and treats the target type as another hole to synthesize.
889sketchfix a tool for automated program repair approach using ... esec fse november lake buena vista fl usa we use javaparser to automatically transform the faulty program to sketches.
to handle defects that require multiple holes to fix such as the null pointer checking sketchfix applies transformation schemas incrementally at the same suspicious location.
due to the large search space of repair candidates sketchfix creates no more than two schemas at the same location by default.
transformation schema.
we define six ast node level transformation schemas that take a suspicious location as input and produce sketches with holes.
expression transformer exp if the faulty statement contains any ast node of variables constant values or field dereferences the node is transformed to a hole sketchfix.exp ... which returns an object.
this object is casted to the corresponding type.
operator transformer aop if the faulty line contains a binary expression with arithmetic operator this binary expression is transformed to a hole sketchfix.aop ... .
overloading transformer par if the faulty statement contains a method invocation that has an overloading method sketchfix maps parameter types and generates expression holes to represent parameters in different types.
condition transformer cond this schema appends a new clause to the faulty condition e.g.
if cond sketchfix.
cond ... .
the new clause is represented as left and right hand side expressions combined with a relational operator.
if the expressions are of nonprimitive types sketchfix applies relational operators and !
to construct the clause while for primitive types it applies all operators !
.
the new clause is appended to the existing condition cond with logical operators and .
if condition transformer if sketchfix introduces an if condition before the faulty statement with a condition hole.
return statement transformer rtn sketchfix inserts a return statement before the faulty statement.
if the return type of the current method is void sketchfix simply inserts an empty return statement otherwise sketchfix inserts an expression hole based on the method s return type.
ranking strategies.
intuitively the synthesis cost increases if more holes are introduced to the sketch.
we define the cost of transformation schemas as the number of atomic holes expression holes and operator holes introduced by the schemas.
we prioritize the schemas with lower synthesis cost.
for instance we favor expression exp and operator aop schemas over the condition schema cond because the condition schema inserts a relational operator hole and two expression holes at the left and right hand side of the relational operator.
this strategy is consistent with the heuristic from the existing literature repair candidates that semantically closer to the original programs are relatively easier to comprehend by the developers.
with the intuition that variables declared closer to the hole are more likely to be used we rank variables based on their proximity to the hole location i.e.
the number of statements between the hole and the variable declaration.
for conditional holes whose target types are unknown we explore target types based on the types of variables declarations in descending order of their closeness to the hole location.
for instance sketchfix prioritizes the target type vector2d for the condition hole in figure because the closest defined variable v2d is of this type.junitcore core new junitcore result result null class target class .
forname defects4j .
triggertest do try result core .
run target if result .
wassuccessful system .
out .
println solution sketchfix .
getstring break catch exception e while sketchexecutor .
incrementcounter figure test driver used by sketchfix .
lazy candidate generation when the test execution first reaches a hole sketchfix initializes candidates of the hole based on the given visible variables and default values.
each candidate is assigned a unique identifier which is its index in the list.
each hole s candidate identifier is initialized as indicating that this hole has not been initialized.
when the execution first reaches a hole whose identifier is sketchfix selects an identifier starting from to represent the candidate used to fill in the hole.
in figure the identifier maps to the value false for the condition hole.
the execution continues with this choice of candidates until the execution encounters a runtime exception or a test failure leading to a backtrack with an increment of the candidate identifier figure incrementcounter which dynamically selects the next candidate.
in figure the identifier maps to the value true for the condition hole.
if there exist multiple holes the method incrementcounter will increment a hole identifier at a time.
the process terminates when a repair that passes all tests is found or the space of candidate programs is exhausted i.e.
all candidate identifiers have reaches their maximum values the sizes of the candidate lists.
in this case the method incrementcounter returns false and the program exits the while loop.
note that checking the test result result.wassuccessful can be generalized to other frameworks apart from junit e.g.
testng.
therefore sketchfix can perform repair for the subjects that do not use junit tests.
experiments we evaluate sketchfix on the defects4j benchmark which consists of defects from open source java projects.
to identify suspicious statements for the defects we use the asm bytecode analysis framework to capture the coverage of failing and passing test executions.
sketchfix uses an existing spectrum based fault localization technique called ochiai to rank suspicious statements.
existing empirical study illustrates that ochiai is effective on localizing defects in object oriented programs.
it has been applied to all four repair techniques that we use in the comparison.
if multiple statements have the same suspiciousness score we order them randomly.
we first compare sketchfix s repair efficacy with other repair techniques astor nopol acs and hdrepair that have been evaluated against the defects4j benchmark.
due to the space limit figure only presents part of the repair result through manual inspection that contains the defects fixed by sketchfix .
a full comparison can be found at .
we check three conditions to identify if the repair is semantically equivalent to the 890esec fse november lake buena vista fl usa jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid no.
sf a n c h no.
sf a n c h ch1 ?
l6 ch8 l51 ?
?
ch9 l55 ?
ch11 l59 ch13 ?
?
?
t4 ?
?
ch20 m5 ch24 m33 ?
ch26 ?
?
?
m50 c14 m59 c62 m70 c70 ?
m73 ?
?
c73 ?
m82 ?
?
c126 m85 ?
?
figure manual assessment result of patches generated by sketchfix and other repair approaches.
sf represents sketchfix a represents astor n represents nopol c represents acs and h represents hdrepair .
represents correct fix ?
represents plausible fix and represents not generating fix.
human written patch the repair is at the same location the repair is with the same type of repair i.e.
expression or operator manipulation the runtime value of the candidate for the hole is the same as the value of the expression developer used to fix the defect.
for example in figure we treat return v2d as semantically equivalent to return null in the null pointer checking.
sketchfix generates correct repairs and plausible ones i.e.
repairs that pass all tests but fail in manual inspection.
this result compares well with other four repair techniques.
compared to other repair techniques sketchfix works particularly well in manipulating expressions and variable types.
for instance figure presents a human written patch that uses different parameters with different types integer vs.double .sketchfix correctly fixes this bug with the overloading transformation schema.
in contrast the constraint solving based repair techniques in general only modify expressions in conditions or the right hand side of assignments with boolean orinteger types.
these techniques can hardly fix defects that require manipulations of expression and variable types.
shown as figure the constraint based tool nopol generates a plausible repair by inserting a new if statement.
this example also illustrates that compared to nopol sketchfix introduces smaller ast node level change to the original program and this repair is more likely to be accepted by the user.
with lazy candidate generation every sketch will be compiled once which may represent thousands of candidates.
when sketchfixfinds the first repair it compiles .
avg.
compiled sketches space .
even if sketchfix exhaustively searches the entire space of repair candidates it only compiles avg.
sketches space of all candidates which must all be compiled without lazy candidate generation.
the experiment shows that sketchfix only executes of candidates avg.
gen space when it finds the first patch that passes all tests.
on average sketchfix spends minutes to locating faults and generating sketches and minutes to generating the first repairs that satisfy all test assertions.
the performance of our tool compares well with other repair techniques.
conclusion this paper described sketchfix an automated program repair tool with lazy candidate generation.
the key insight of sketchfix is to utilize runtime information to substantially prune the space of candidates.
it transforms the faulty program to sketches with holes human written patch for simplextableau .
java private final int maxulps private final double epsilon protected void dropphase1objective if precision .
compareto entry 0d maxulps ... if precision .
compareto entry 0d epsilon ... simplextableau .
java as sketch protected void dropphase1objective if precision .
compareto entry 0d double sketchfix .
exp double .
class new object .. epsilon maxulps .. ... synthesized solution sketchfix .
exp epsilon a plausible repair generated by nopol protected void dropphase1objective if precision .
compareto entry 0d maxulps if numslackvariables constraints .
size ... figure patches generated by sketchfix andnopol at the fine grained granularity.
sketchfix can be applied to a wide class of programs with various code structures in presence of libraries.
with a tight integration of the generation and validation phase sketchfix substantially pruned a large amount of candidate fixes based on our experiments.
our result also indicates that sketchfix works well in repairing defects with non primitive type expression manipulation at the ast node level.