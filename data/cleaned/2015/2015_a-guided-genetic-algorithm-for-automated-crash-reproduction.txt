a guided genetic algorithm for automated crash reproduction mozhan soltani delft university of technology the netherlands m.soltani tudelft.nlannibale panichella snt centre university of luxembourg luxembourg annibale.panichella uni.luarie van deursen delft university of technology the netherlands arie.vandeursen tudelft.nl abstract to reduce the effort developers have to make for crash debugging researchers have proposed several solutions for automatic failure reproduction.
recent advances proposed the use of symbolic execution mutation analysis and directed model checking as underling techniques for post failure analysis of crash stack traces.
however existing approaches still cannot reproduce many real world crashes due to such limitations as environment dependencies path explosion and time complexity.
to address these challenges we present evocrash a post failure approach which uses a novel guided genetic algorithm gga to cope with the large search space characterizing real world software programs.
our empirical study on three open source systems shows that evocrash can replicate of realworld crashes of which are useful reproductions for debugging purposes outperforming the state of the art in crash replication.
keywords search based software testing genetic algorithms automated crash reproduction i. i ntroduction manual crash replication is a labor intensive task.
developers faced with this task need to reproduce failures reported in issue tracking systems which all too often contain insufficient data to determine the root cause of a failure.
hence to reduce developer effort many different automated crash replication techniques have been proposed in the literature.
such techniques typically aim at generating tests triggering the target failure.
for example record replay approaches monitor software behavior via software hardware instrumentation to collect the observed objects and method calls when failures occur.
unfortunately such techniques suffer from well known practical limitations such as performance overhead and privacy issues .
as opposed to these costly techniques post failure approaches try to replicate crashes by exploiting data that is available after the failure typically stored in log files or external bug tracking systems.
most of these techniques require specific input data in addition to crash stack traces such as core dumps or models of the software like input grammars or class invariants .
since such additional information is usually not available to developers recent advances in the field have focused on crash stack traces as the only source of information for debugging .
for example chen and kim developedstar an approach based on backward symbolic execution.
star outperforms earlier crash replication techniques such as randoop and bugredux .
xuan et al.
presented mucrash a tool that updates existing test cases using specific mutation operators thus creating a new pool of tests to run against the software under test.
nayrolle et al.
proposed jcharming based on directed model checking combined with program slicing .
unfortunately the state of the art tools suffer from several limitations.
for example star cannot handle cases with external environment dependencies e.g.
file or network inputs non trivial string constraints or complex logic potentially leading to a path explosion.
mucrash is limited by the ability of existing tests in covering method call sequences of interest and it may lead to a large number of unnecessary mutated test cases .
jcharming applies model checking which can be computationally expensive.
moreover similar to star jcharming does not handle crash cases with environmental dependencies.
in our previous preliminary study we have suggested to re use existing unit test generation tools such as evosuite for crash replication.
to that end we developed afitness function to assess the capability of candidate test cases in replicating the target failure.
although this simple solution could help to replicate one crash not handled by star and mucrash our preliminary study showed that this simple solution still leaves other crashes as non reproducible.
these negative results are due to the large search space for real world programs where the probability to generate test data satisfying desired failure conditions is low.
in fact the classic genetic operators from existing test frameworks are aimed at maximizing specific coverage criteria instead of exploiting single execution paths and object states that characterize software failures.
to address this challenge this paper presents an evolutionary search based approach named evocrash for crash reproduction.
evocrash is built on top of evosuite the well known automatic test suite generation tool for java.
for evocrash we developed a novel guided genetic algorithm gga .
it lets the stack trace guide the search thus reducing the search space.
in particular gga uses a novel generative routine to build an initial population of tests exercising at least one of the methods reported in the crash stack frames.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
furthermore gga uses new crossover and mutation operators to avoid the generation of futile tests that lack calls to failing methods.
to further guide the search process we developed a novel fitness function that improves the calculation of stack trace distance previously defined in to assess candidate test cases.
the contributions of our paper are a novel guided genetic algorithm gga for crash reproduction that generates and evolves only tests that exercise at least one of the methods involved in the failure evocrash a java tool implementing gga that generates junit tests that developers can directly use for debugging purposes an empirical study on real world software crashes involving different versions of three open source projects showing that evocrash can replicate cases of which are useful for debugging a comparison of evocrash with three state of the art approaches based on crash stack traces star mucrash and jcharming .
furthermore we provide a publicly available replication package1that includes i an executable jar of evocrash ii all bug reports used in our study and iii the test cases generated by our tool.
ii.
r ela ted work since our approach aims at crash reproduction using test generation we start out by summarizing related work in the areas of automated crash replication and coverage based unit test generation.
a. automated approaches to crash replication previous approaches in the field of crash replication can be grouped into three main categories i record play approaches ii post failure approaches using various data sources and iii stack trace based post failure techniques.
the first category includes the earliest works in this field such as recrash adda bugnet and jrapture .
the aforementioned techniques rely on program run time data for automated crash replication.
thus they record the program execution data in order to use it for identifying the program states and execution path that led to the program failure.
however monitoring program execution may lead to i substantial performance overhead due to software hardware instrumentation and ii severe privacy issues since the collected execution data may contain sensitive information .
on the other hand post failure approaches analyze software data e.g.
core dumps only after crashes occur thus not requiring any form of instrumentation.
rossler et al.
developed an evolutionary search based approach named recore that leverages from core dumps taken at the time of a failure to generate input data.
recore combines the search based input generation with a coverage based technique to generate method sequences.
weeratunge et al.
core dumps and directed search for replicating crashes related to concurrent programs in multi core platforms.
leitner et al.
used a failure state extraction technique to create tests from core dumps to derive input data and stack traces to derive method calls .
kifetew et al.
used genetic programming requiring as input i a grammar describing the program input and ii a partial call sequence.
boyapati et al.
developed another technique requiring manually written specifications containing method preconditions postconditions and class invariants.
however all these post failure approaches need various types of information that are often not available to developers thus decreasing their feasibility.
to increase the practical usefulness of automated approaches researchers have focused on crash stack traces as the only source of information for debugging.
for instance esd uses forward symbolic execution that leverages commonly reported elements in bug reports.
bugredux also uses forward symbolic execution but it can analyze different types of execution data such as crash stack traces.
as highlighted by chen and kim both esd and bugredux rely on forward symbolic execution thus inheriting its problems due to path explosion and object creation .
to address these two issues chen and kim introduced star a tool that applies backward symbolic execution to compute crash preconditions and generates a test using a method sequence composition approach.
different from star jcharming uses a combination of crash traces and model checking to automatically reproduce bugs that caused field failure.
to address the state explosion problem in model checking jcharming applies program slicing to direct the model checking process by reduction of the search space.
instead mucrash uses mutation analysis as the underlying technique for crash replication.
first mucrash selects the test cases that include the classes in the crash stack trace.
next it applies predefined mutation operators on the tests to produce mutant tests that can reproduce the target crash.
in our earlier study we showed that even coveragebased tools like evosuite can replicate some target crashes if relying on a proper fitness function specialized for crash replication.
however our preliminary results also indicated that this simple solution could not replicate some cases for two main reasons i limitations of the developed fitness function and ii the large search space in complex real world software.
the evocrash approach presented in this paper resumes this line of research because it used evolutionary search to synthesize a crash reproducible test case.
however it is novel because it utilizes a smarter fitness function and it applies an guided genetic algorithm gga instead of coverageoriented genetic algorithms.
section iii presents full details regarding the novel fitness function and gga in evocrash.
b. unit test generation tools a number of techniques and tools have been proposed in the literature to automatically generate tests maximizing specific code coverage criteria .
the main authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
difference among them is represented by the core search algorithm used for generating tests.
for example evosuite and jtexpert use genetic algorithms to create test suites optimizing branch coverage randoop and t3 apply random testing while dart and pex are based on dynamic symbolic execution.
as reported in the related literature such tools can be used to discover bugs affecting software code.
indeed they can generate test triggering crashes when trying to generate tests exercising the uncovered parts of the code.
for example fraser and arcuri successfully used evosuite to discover undeclared exceptions and bugs in open source projects.
recently moran et al.
used coverage based tools to discover android application crashes.
however as also pointed out by chen and kim coverage based tools are not specifically defined for crash replication.
in fact these tools are aimed at covering all methods and their code elements in the class under test.
thus already covered methods are not taken into account for search even if none of the already generated tests synthesizes the target crash.
therefore the probability of generating tests satisfying desired crash triggering object states is particularly low for coverage based tools .
on the other hand for crash replication not all methods should be exploited for generating a crash we are interested in covering only the few lines in those methods involved in failure while other methods or classes might be useful only for instantiating the necessary objects e.g.
input parameters .
moreover among all possible method sequences we are interested only on those that can potentially lead to the target crash stack trace.
therefore in this paper we developed a tool named evocrash which is specialized for stack trace based crash replication.
iii.
t he evocrash approach according to harman et al.
there are two key ingredients for a successful application of search based techniques.
the first is the formulation of a proper fitness function to guide the search toward reaching the target which in our case is a way to trigger a crash.
the second ingredient consists of applying a proper search algorithm to promote tests closer to mimicking the crash while penalizing tests with poor fitness values.
the next sub sections detail the fitness function as well as the genetic algorithms we designed in evocrash.
a. crash stack trace processing an optimal test case for crash reproduction has to crash at the same location as the original crash and produce a stack trace as close to the original one as possible.
therefore in evocrash we first parse the log file given as input in order to extract the crash stack frames of interest.
a standard java stack trace contains i the type of the exception thrown and ii the list of stack frames generated at the time of the crash.
each stack frame corresponds to one method involved in the failure hence it contains all information required for its identification i the method name ii the class name and iii line numbers where the exception was generated.
the last frame is wherethe exception has been thrown whereas the root cause could be in any of the frames or even outside the stack trace.
from a practical point of view any class or method in the stack trace can be selected as code unit to use as input for existing test case generation tools such as evosuite.
however since our goal is to synthesize a test case generating a stack trace as close to the original trace as possible we always target the class where the exception is thrown last stack frame in the crash stack trace as the main class under test cut .
b. fitness function as described in our previous study our fitness function is formulated to consider three main conditions that must hold so that a test case would be evaluated as optimal and have zero distance i the line statement where the exception is thrown has to be covered ii the target exception has to be thrown and iii the generated stack trace must be as similar to the original one as possible.
more formally we use the following fitness formulation definition .
the fitness function value of a given test tis f t ds t dexcept t dtrace t whereds t denotes how far tis to executing the target statement i.e.
the location of the crash dexcept t is a binary value indicating whether the target exception is thrown or not and dtrace t measures the distance between the generated stack trace if any and the expected trace.
for the line distance ds t we use the two well known heuristics approach level and branch distance to guide the search for branch and statement coverage .
the approach level measures the distance i.e.
minimum number of control dependencies between the path of the code executed by tand the target statement.
the branch distance uses a set of wellestablished rules to score how close tis to satisfying the branch condition for the branch on which the target statement is directly control dependent.
if the target exception is thrown dexcept t then we proceed by calculating the trace distance dtrace t otherwise the trace distance remains equal to the maximum value it can have .
.
to calculate the trace distance dtrace t i no u r preliminary study we used the distance function defined as follows.
let s e ... e n be the target stack trace to replicate where e i c m l is thei the element in the trace composed by class name c i method name m i and line numberl i. lets e1 ... e k be the stack trace if any generated when executing the test t. the distance between the expected trace s and the actual trace sis defined as d s s min k n summationdisplay i 1 diff e i ei n k where diff e i ei measures the distance between the two trace elements e iandeiin the traces s andsrespectively finally x is the widely used normalizing function x x x .
however such a distance definition authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
has one critical limitation it strictly requires that the expected traces and the actual trace sshare the same prefix i.e.
the firstmin k n trace elements.
for example assume that the triggered stack trace sand target trace s have one stack trace elementeshared in common i.e.
one element with the same class name method name and source code line number but that is located at two different positions e.g.
e iis the second element in s eshared e2ins while it is the third one ins eshared e 3ins .
in this scenario equation will compare the element e 3ins with the element in sat the same position i i.e.
with e3 instead of considering the closest elementeshared e2for the comparison.
to overcome this critical limitation in this paper we use the following new definition of stack trace distance definition .
lets be the expected trace and let sbe the actual stack trace triggered by a given test t. the stack trace distance between s andsis defined as d s s n summationdisplay i 1min diff e i ej ej s wherediff e i ej measures the distance between the two trace elements e iins and its closest element ejins.
we say that two trace elements are equal if and only if they share the same trace components.
therefore we define diff e i ej as follows diff e i ei c i negationslash ci c i ciandm i negationslash mi l i li otherwise the score diff e i ei is equal to zero if and only if the two trace elements e iandeishare the same class name method name and line number.
similarly d s s in equation is zero if and only if the two traces s andsare equal i.e.
they share the same trace elements.
starting from the function in equation we define the trace distance dtrace t as the normalized d s s function dtrace t d s s d s s d s s consequently d s s in equation is zero if and only ifs shares the same trace elements with s. in addition our fitness function f t assumes values within the interval reaching a zero value if and only if the evaluated test t replicates the target crash.
c. guided genetic algorithm in evocrash we use a novel genetic algorithm named gga guided genetic algorithm suitably defined for the crash replication problem.
while traditional search algorithms in coverage based unit test tools target all methods in the cut gga gives higher priority to those methods involved in the target failure.
to accomplish this gga uses three novel genetic operators that create and evolve test cases that always exercise at least one method contained in the crash stack trace increasing the overall probability of triggering thealgorithm guided genetic algorithm input class under test c target call from the crash stack trace tc population size n search time out maxtime result test case t 1begin initialization 3mcrash identify public methods based on tc 4k 5pk make initial popula tion c mcrash n ev alua te pk main loop while best fitness value and time spent max time do k k generate offsprings o while o n do p1 p2 select two parents for reproduction ifcrossover probability then o1 o2 guided crossover p1 p2 else o1 p1 o2 p2 o o uniontextguided muta tion o1 o o uniontextguided muta tion o2 fitness evaluation ev alua te o pk pk uniontexto pk select the nfittest individuals in pk 25tbest fittest individual in pk 26tbest post processing tbest target crash.
as shown in algorithm gga contains all main steps of a standard genetic algorithm i it starts with creation of an initial population of random tests line ii it evolves such tests over subsequent generations using crossover and mutation lines and iii at each generation it selects the fittest tests according to the fitness function lines .
the main difference is represented by the fact that it uses i a novel routine for generating the initial population line ii a new crossover operator line iii a new mutation operator lines .
finally the fittest test obtained at the end of the search is optimized by post processing in line .
initial population.
the routine used to generate the initial population plays a paramount role since it performs sampling of the search space.
in traditional coverage based tools e.g.
evosuite or jtexpert such a routine is designed to generate a well distributed population set of tests calling as many methods in the target class as possible which is not the main goal for crash replication.
for this reason in this paper we use the novel routine highlghted in algorithm for generating the initial sample for random tests.
in particular our routine gives higher importance to methods contained in crash stack frames.
subsequently if a target call selected by the developer is public or protected algorithm guarantees that this call is inserted in each test at least once.
otherwise if the target call is private the algorithm guarantees that each test contains at least one call to a public caller method which invokes the target private call.
algorithm generates random tests using the loop in lines and requires as input i the set of public target method s authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm make initial popula tion input class under test c set of failing methods mcrash population size n result an initial population p0 1begin 2p0 while p0 n do t empty test case size random integer probability of inserting a method involved in the failure insert probability size while number of statements in t size do ifrandom number lessorequalslantinsert probability then method call pick one element from mcrash reset the probability of inserting a failing method insert probability size else method call pick one public method in c length number of statements in t increase the probability of inserting a failing method insert probability size length insert method call method call t p0 p0 uniontextt mcrash ii the population size n and iii the class under testc.
in each iteration we create an empty test t line to fill with a random number of statements lines .
then statements are randomly inserted in tusing the iterative routine in lines at each iteration we insert a call to one public method either taken from mcrash or member classes of c. in the first iteration crash methods in mcrash methods of interest are inserted in twith a low probability p size line where size is the total number of statements to add int.
in the subsequent iterations such a probability is automatically increased when no methods from mcrash is inserted in t line .
therefore algorithm ensures that at least one method of the crash is inserted in each initial test2.
the process of inserting a specific method call in a test trequires several additional operations .
for example before inserting a method call mintit is necessary to instantiate an object of the class containing m e.g.
calling one of the public constructors .
creating a proper method call also requires the generation of proper input parameters such as other objects or primitive variables.
for all these additional operations algorithm uses the routine insert methodcall line .
for each method call in t it sets the input parameters values by re using objects and variables already defined in t setting some input values to null only for objects used as input parameters or randomly generating new objects and primitive values.
guided crossover.
even if all tests in the initial population exercise one or more methods contained in the crash stack trace during the evolution process i.e.
across different generations tests can lose the inserted target calls.
one possible cause for this scenario is represented by the traditional single point crossover which generates two offsprings by 2in the worst case a failing method will be inserted at position size int since the probability insert probability will be size size 1algorithm guided crossover input parent tests p1andp2 set of failing methods mcrash result two offsprings o1 o2 1begin 2size p1 3size p2 select a cut point 5 k random number first offspring 7o1 first size 1statements from p1 8o1 append size 2statements from p2 correct o1 ifo1does not contain methods from mcrashthen o1 clone ofp1 second offspring 13o2 first size 2statements from p2 14o2 append size 1statements from p1 correct o2 ifo2does not contain methods from mcrashthen o2 clone ofp2 randomly exchanging statements between two parent tests p1 andp2.
given a random cut point the first offspring o1 inherits the first statements from parent p1 followed by p2 statements from parent p2.
vice versa the second offspring o2will contain statements from parent p2and p1 statements from the parent p1.
even if both parents exercise one or more failing methods from the crash stack trace after crossover is performed the calls may be moved into one offspring only.
therefore the traditional single point crossover can hamper the overall algorithm.
to avoid this scenario gga leverages a novel guided single point crossover operator whose main steps are highlighted in algorithm .
the first steps in this crossover are identical to the standard single point crossover i it selects a random cut point line ii it recombines statements from the two parents around the cut point lines and of algorithm .
after this recombination if o1 oro2 loses the target method calls a call to one of the methods reported in the crash stack trace we reverse the changes and re define o1 oro2 as pure copy of its parent p1 p2for offspring o2 if conditions in lines and .
in this case the mutation operator will be in charge of applying changes to o1 oro2 .
moving method calls from one test to another may result in non well formed tests.
for example an offspring may not contain proper class constructors before calling some methods or some input parameters either primitive variables or objects are not inherited from the original parent.
for this reason algorithm applies a correction procedure lines and that inserts all required objects and primitive variables into non well formed offspring.
guided mutation.
after crossover new tests are usually mutated with a low probability by adding changing and removing some statements.
while adding statements will not affect the type of method calls contained in a test the statement deletion change procedures may remove relevant calls to methods in the crash stack frame.
therefore gga also uses an e w guided mutation operator described in algorithm .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm guided muta tion input testt angbracketlefts1 ... s n angbracketrightto mutate set of failing methods mcrash result mutated test t 1begin 2n t 3applymutation true whileapplymutation true do for i 1t on do random number if lessorequalslant1 nthen ifdelete probability then delete statement si ifchange probability then change statement si ifinsert probability then insert a new method call at line i iftcontains method from mcrash then applymutation false lett angbracketlefts1 ... s n angbracketrightbe a test case to mutate the guidedmutation iterates over the test tand mutates each statement with probability n main loop in lines .
inserting statements consists of adding a new method call at a random pointi in the current test t lines in algorithm .
this procedure also requires to instantiate objects or declare initialize primitive variables e.g.
integers that will be used as input parameters.
when changing a statement at position i in lines the mutation operator has to handle two different cases i if the statement siis the declaration of a primitive variable e.g.
an integer then its primitive value is changed with another random value e.g.
another random integer ii if sicontains a method or a constructor call m then the mutation is applied by replacing mwith another public method constructor having the same return type while its input parameters objects or primitive values are taken from the previous i 1statements int set to null for objects only or randomly generated.
finally removing a method call lines in algorithm requires to delete the corresponding variables and objects used as input parameters if such variables and objects are not used by any other method call in t .
if the test tloses the target method calls i.e.
methods in mcrash because of the mutation then the loop in lines is repeated until one or more target method calls are re inserted in t otherwise the mutation process terminates.
post processing.
at the end of the search process gga returns the fittest test case according to our fitness function.
the resulting test tbest can be directly used by developer as starting point for crash replication and debugging.
since method calls are randomly inserted changed during the search process the final test tbest can contain statements not useful to replicate the crash.
for this reason gga postprocesses tbest to make it more concise and understandable.
for this post processing we reused the test optimization routines available in evosuite namely test minimization andtable i real world bugs used in our study .
project bug ids versions exception priority ref.
acc4 .
.
nullpointer major unsupportedoperation minor indexoutofbounds illegalargument arrayindexoutofbounds concurrentmodification illegalstate ant28820 .
.
.
.
arrayindexoutofbounds critical nullpointer medium arrayindexoutofbounds medium stringindexoutofbounds log29 .
.
.
nullpointer critical ininitializererror major medium enhanc.
blocker values minimization .test minimization applies a simple greedy algorithm it iteratively removes all statements that do not affect the final fitness value.
finally randomly generated input values can be hard to interpret for developers .
therefore the values minimization from evosuite shortens the identified numbers and simplifies the randomly generated strings .
iv .
e mpirical study this section describes the empirical study we conducted to benchmark the effectiveness of the evocrash approach.
a. definition and context the context of this study consists of bugs from three real world open source projects apache commons collections3 acc apache ant4 ant apache log4j5 log .
acc is a popular java library with lines of code loc which provides utilities to extend the java collection framework.
for this library we selected bug reports publicly available on jira6submitted between october and june thus involving five different acc versions.
ant is a large java build tool with more than loc which supports different built in tasks including compiling running and executing tests for java applications.
for ant we selected bug reports submitted onbugzilla7between april and august and that concern different versions and sub modules.
finally log is a widely used java library with loc that implements logging utilities for java applications.
for this library we selected bug reports reported within the time windows between june and october and that are related to three different log versions.
the characteristics of the selected bugs including type of exception and priority are summarized in table i. we selected these bugs as they have been used in the previous study on automatic crash reproduction when evaluating symbolic execution mutation analysis and directed model checking and other tools .
this authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
selection covers crashes that involve the most common java exceptions such as nullpointerexception arrayindexoutofboundsexception illegalstateexception andillegalargumentexception .
furthermore the severity of these realworld bugs varies between medium major and critical as judged by the original developers.
b. research questions to evaluate the effectiveness of evocrash we formulate the following research questions rq in which cases can evocrash successfully reproduce the targeted crashes and under what circumstances does it fail to do so?
with this preliminary research question we aim at evaluating the capability of our tool to generate test cases i that can replicate the target crashes and ii that are useful for debugging.
rq how does evocrash perform compared to state ofthe art reproduction approaches based on stack traces?
in this second research question we investigate the advantages of evocrash as compared to the best known stack trace approaches previously proposed in the literature.
c. experimental procedure we run evocrash on each target crash to try to generate a test case able to reproduce the corresponding stack trace.
given the randomized nature of genetic algorithms the search for each target bug crash was repeated times in order to verify that the target crashes are replicated the majority of the time.
in our experiment we configured gga by using standard parameter values widely used in evolutionary testing population size for gga we initially use a population size of test cases.
if the search reaches the timeout minutes we increment the population size by and run evocrash once again until the population size reaches .
if with population size of evocrash cannot create a test case with fitness .
in minutes we specify the crash case as non reproducible.
crossover we use the novel guided single point crossover with crossover probability set to .
.
mutation as mutation operator we use our guided uniform mutation which mutates test cases by randomly adding deleting or changing statements.
we set the mutation probability equal to1 n wherenis the length of the test case taken as input .
search timeout the search stops when a zero fitness function value is detected or when the timeout of minutes is reached .
to address rq we apply the two criteria proposed by chen and kim for evaluating the effectiveness of crash replication tools crash coverage and test case usefulness .
according to the crash coverage criterion a crash is covered when the test generated by evocrash results in the generation of the same type of exception at the same crash line asreported in the crash stack trace.
therefore for this criterion we classified as covered only those crashes for which evosuite reached a fitness value equal to .
i.e.
when the generated crash stack trace is identical to the target one.
in these cases we also re executed the generated tests against the cut to ensure that the crash stack frame was correctly replicated.
for the test case usefulness criterion a generated test case by evocrash is considered useful if it can reveal the actual bug that causes the original crash.
therefore we manually examined each crash classified as covered using the coverage criterion to investigate if it can reveal the actual bug following the guidelines in .
a test case reveals a bug if the generated crash trace includes the buggy frame i.e.
the stack element which the buggy method lies in or the frame the execution of which covers the buggy component.
to assess usefulness of the tests we carefully inspected the original developers fixes to identify the bug fixing locations.
finally useful tests have to reveal the origin of the corrupted input values e.g.
null values passed to the buggy methods that trigger the crash .
this manual validation has been performed by two authors independently and cases of disagreement were discussed.
to address rq we selected three state of the art techniques namely star mucrash and jcharming .
these three techniques are modern approaches to crash replication for java programs and they are based on three different categories of algorithms symbolic execution mutation analysis and model checking .
at the time of this submission these three tools either as executable jars or source code were not available.
therefore to compare our approach we rely on their published data.
since the studies use different data sets we cannot report data points for all subject systems.
thus we compared evocrash with mucrash for the bugs selected from acc that have also been used by xuan et al.
to evaluate their tool.
we compared evocrash with jcharming for the bug reports that have been also used by nayrolles et al.
.
finally we compare evocrash with star for the bugs in our sample that are in common with the study by chen and kim .
v. e xperimental results this section presents the results of the empirical study we conducted to evaluate the effectiveness of evocrash in terms of crash coverage and test case usefulness.
moreover we provide the first comparison results between the effectiveness of evocrash star mucrash and jcharming as the state of the art approaches based on crash stack traces.
evocrash results rq1 as table ii illustrates evocrash can successfully replicate the majority of the crashes in our dataset.
of the replicated cases log had the lowest rate of replications out of and cases could be replicated times out of .
evocrash reproduces crashes out of for acc out of for ant and out of for log.
overall it can replicate out of the crashes.
to assess the usefulness of the generated test cases we used the same criterion that was used for star .
based on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii detailed crash reproduction results where y y es indica tes the capability to genera te a useful test case n n o indica tes lack of ability to reproduce a crash nu n otuseful shows tha t a test case could be genera ted but it w as not useful and indica tes tha t da ta regarding the capability of the approach in reproducing the identified crash is missing .
project bug id evocrash star mucrash jcharming acc4y yy y y y y y y y y y y y n n n n y n n nu nu n n yy y n y377 y n y411 y y y ant28820 nn nu nu y n nu n nu nu y y nu y y y n n y y nu y y n n n n n n y nu y y y y y nu n n y n log29 yy n n y n y n y n y y y y y y nu y y y y y n y n y nu n y n nu y y y n y y y nu y nu y n this of the replications were useful as they included buggy frame.
the remaining non useful replications were mainly due to having dependency on data from external files which were not available during replication.
for acc there were two cases acc and acc which were not reproducible by evocrash.
for acc the class under test includes three nested classes and the innermost one was where the crash occurs.
currently evosuite does not support instrumentation of multiple inner classes.
for acc evocrash could replicate the case times out of .
this low ratio was due to the fact that calls to the input object and target method had to be made in a certain order to trigger the crash.
for ant of the cases are currently not supported by evocrash.
for these cases the major hindering factor was the dependency on a missing external build.xml file which is used by ant for setting up the project configu java.lang.nullpointerexception at org.apache.tools.ant.util.symboliclinkutils.
issymboliclink symboliclinkutils.java at org.apache.tools.ant.util.symboliclinkutils.
issymboliclink symboliclinkutils.java at org.apache.tools.ant.util.symboliclinkutils.
deletesymboliclink symboliclinkutils.java at org.apache.tools.ant.taskdefs.optional.unix.
symlink.delete symlink.java listing .
crash stack trace for ant .
public void test0 throws throwable symlink symlink0 new symlink symlink0.setlink symlink0.delete listing .
generated test by evocrash for ant .
rations.
however build.xml was not supplied for many of the crash reports.
in addition the use of java reflection made it more challenging to reproduce these ant cases since the specific values for class and method names are not known from the crash stack trace.
for log of the cases is not supported by evocrash.
in this case the target call is made to a static class initializer which is not supported by evocrash yet.
comparison to the state of the art rq2 table ii shows the comparisons of evocrash to star mucrash and jcharming.
bold entries represent bugs which can be triggered by evocrash yet one of the other techniques is not underlined entries represent bugs that evocrash cannot reproduce while there is another technique that can.
as can be seen there are bold cases in which evocrash outperforms the state of the art and there are underlined cases that evocrash cannot handle.
below we discuss these cases in more detail.
evocrash vs. star.
as table ii presents for acc evocrash covers all the cases that star covers except for acc that was reflected on previously .
in addition evocrash covers cases which were not covered by star due to the path explosion problem.
for instance in acc the defect exists in a private method least inside a for loop inside the third if condition which was too complicated for star.
the case was complex to evocrash too since this was one of the cases where we had to increase the population size from to .
for ant evocrash supports cases which are not covered by star.
out of the there are cases for which only evocrash can generate a useful test case.
listing shows the crash stack trace for of these cases ant .
as reported in the issue tracking system of the project8 i n this case the defect exists in the 4th stack frame.
thus a useful test case should i make a call to the method delete ii trigger a java.lang.nullpointerexception and iii yield a crash trace which includes the first stack frame which is where the exception was thrown.
as listing depicts bug.cgi?id authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
public void test0 throws throwable java.io.file v1 java.io.file null org.apache.tools.ant.util.symboliclinkutils v2 org.apache.tools.ant.util.symboliclinkutils .getsymboliclinkutils v2.issymboliclink java.io.file v1 java.lang.
string null listing .
generated test by star for ant .
java.lang.nullpointerexception at org.apache.tools.ant.util.symboliclinkutils.
issymboliclink symboliclinkutils.java listing .
generated crash stack trace by star for ant .
the test case by evocrash creates an instance of symlink symlink0 adapts the state in symlink0 and ultimately makes a call to delete which will result in generating the target crash stack trace with fitness equal to .
.
on the other hand as listing shows the test case by star makes an instance of symboliclinkutils which comes before the defective frame in the crash stack and makes a call to the root method issymboliclink .
consequently only part of the target crash stack is generated by this test which is shown in listing .
since the defective frame is not revealed in the resulting crash trace even though the root frame is covered the test by star does not evaluate to useful according to the criteria set by star .
other than acc ant is the other case that is only reproducible by star.
the main reason for this lies in an inheritance related problem and how the current fitness function compares stack frames.
in this case the target method mapfilename is defined in filtermapper which extends filenamemapper .
however the search can find better fitness values using other subclasses of filenamemapper such as flatfilenamemapper because the implementation of mapfilename in these subclasses has lower complexity.
to improve this case in the future we plan to increase the strictness of the fitness function when it comes to distinguishing among subclasses and their inherited methods.
for log evocrash covers all the cases that were covered by star.
of the log cases are only covered by evocrash.
as an example log is among the cases which are only covered by evocrash.
in this case there is a need to interact with the file system and in order to handle the interaction with the environment evocrash benefits from the mocking mechanisms implemented in evosuite.
evocrash vs.mucrash.
as table ii shows evaluation data for mucrash is only available for acc.9except for acc104 evocrash covers all the acc cases that are covered by mucrash.
in addition cases are only covered by evocrash though one of them is not marked as useful.
an example of a covered case is acc depicted in listing .
it requires that an object is added to an instance 9since mucrash is not publicly available we could not reproduce the data or add additional cases by ourselves.java.lang.arrayindexoutofboundsexception at org.apache.commons.collections.buffer.
unboundedfifobuffer .remove unboundedfifobuffer.java listing .
crash stack trace for acc object object0 new object unboundedfifobuffer unboundedfifobuffer0 new unboundedfifobuffer unboundedfifobuffer0.add object0 unboundedfifobuffer0.tail unboundedfifobuffer0.remove object null listing .
evocrash test for acc ofunboundedfifobuffer the tail index is set to a number larger than the buffer size and then that the method remove is invoked.
in addition the order in which the methods are invoked matters.
so if the tail index would be set after remove is called the target crash would not be replicated.
as shown in listing evocrash synthetized the right method sequence and reproduced acc .
evocrash vs.jcharming.
as table ii shows only few cases from ant and log were shared with the cases used to evaluate jcharming.
while of the shared cases are covered both by evocrash and jcharming there is substantial difference in the efficiency of the two approaches.
on average evocrash takes less than minutes to cover the target crashes whereas jcharming may take from to minutes to generate tests for the same cases.
for log log cases out of are only supported by evocrash.
as an example listing shows the crash stack trace for log which is one of the two cases covered only by evocrash.
to generate a useful test for log as depicted in listing evocrash sets the ht state in ndc tonull and then makes a call to the static method remove which is the buggy frame method.
vi.
d iscussion we identify two possible directions for future work.
interactive search.
it should be noted that since gga strives for finding the fittest test case thus discarding the ones with fitness negationslash .
the crash coverage and usefulness evaluation was performed on a set of evocrash tests with fitness equal to .
.
however considering the crash exploitability and usefulness criteria adopted from star it could be possible that evocrash discarded tests with fitness between .
and .
java.lang.nullpointerexception at org.apache.log4jb.ndc.remove ndc.java listing .
crash stack trace for log .
public void test0 throws throwable ndc.ht null ndc.remove listing .
the evocrash test for log .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
which would actually conform to the aforementioned criteria.
considering the fitness function range fitness values could be from .
to .
where .
means a test case that does not reach the target line therefore does not invoke the target method and in turn does not trigger the target exception.
in contrast fitness .
means that the test covers the target line and method and triggers the target exception.
according to the definition of the fitness function presented in section iii when the fitness value is between .
and .
the target line and exception are covered however the stack trace similarity is not ideal yet.
in this case even though the target stack similarity is not achieved crash coverage and test usefulness criteria could be covered.
as the result future work can provide interactive mechanisms through which the precision of the fitness function could be adjusted so tests with fitness between .
and .
could also be accepted.
in addition dependency on external files was a major factor that prevented evocrash from covering more cases.
as described earlier for some of the cases with environmental dependency we increased the population size which in turn led to successful generation of tests for some of the cases.
thus if external files were to be provided by the bug reporters then enabling developers to specify the external files or adjust the population size through interactive mechanisms could be another possible direction for the future work.
extending comparisons.
while to make the comparison among evocrash star mucrash and jcharming we had to identify a subset of cases shared in the empirical evaluations of the techniques we realize the need to extend the comparison between i evocrash and jcharming and ii evocrash and mucrash.
to improve the comparison with jcharming we would adopt the other projects that were targeted by jcharming and evaluate evocrash against the identified cases for them.
considering the substantial performance difference between evocrash and jcharming we also wish to statistically compare the efficiency of the tools.
to do so we would rely on availability of jcharming for experimentation.
to improve the comparison with mucrash if additional evaluation data is published for the tool or mucrash becomes publicly available we would extend the empirical study to increase the validity of the comparison results.
vii.
t hrea ts to validity with respect to external validity the main threats arise from the focus on java and open source.
the use of java is needed for our experiments due to the dependency on evosuite yet we expect our approach to behave similarly on other languages such as ruby or c .
to maximize reproducibility and to enable comparison with the state of the art we rely on open source java systems.
we see no reason why closed source stack traces would be substantially different.
as part of our future work we will engage with one of our industrial partners mining their log files for frequent stack traces.
this will help them create test cases that they can add to their test suite to reproduce and fix errors their software suffers from.in order to facilitate comparison with earlier approaches we selected bugs and system versions that have been used in earlier studies and hence are several years old.
we anticipate that our approach works equally well on more recent bugs or versions as well but have not conducted such experiments yet.
a finding of our experiments is that a key limiting factor for any stack trace based approach is the unavailability of external data that may be needed for the reproduction.
further research is needed to mitigate this limitation and identify a different data set of crashes focusing on such missing data in order to further narrow down this problem.
with respect to internal validity a key threat is in the evaluation of the crash coverage and usefulness of the generated test cases.
in case evocrash generated a test with fitness .
we double checked the generated crash stack trace to ensure that the corresponding test correctly replicated the crash stack frame.
despite having taken the above procedures it is still possible that we made errors in the inspections and evaluations.
to mitigate the chances of introducing errors we peer reviewed the tests and crashes.
in addition we make the evocrash tool and the generated test cases publicly available 1for further evaluations.
viii.
c onclusion to increase developers productivity while debugging several approaches to automated crash replication have been proposed.
however the existing solutions have certain limitations that adversely affect their capability in covering more crash cases for real world software projects.
this paper presents evocrash which is a search based approach to crash replication based on using data from crash stack traces.
evocrash applies a novel guided genetic algorithm gga as well as a smart fitness function to search for a test case that can trigger the target crash and reveal the buggy frame in the crash stack trace.
our empirical evaluation shows that evocrash addresses the major challenges that were faced by three cutting edge approaches and thereby outperforms them in automated crash reproduction.
the future work may take several directions including i enhancing the fitness function implemented in evocrash ii extending the comparison between evocrash and the other techniques which considerably would depend on the availability of the tools and iii evaluating evocrash for industrial projects.
the implementation of evocrash as well as the experimental data are publicly available1.
acknowledgment this research was partially funded by the eu project stamp ict no.
the dutch 4tu project big software on the run and national research fund luxembourg fnr p10 .