access path abstraction scaling field sensitive data flow analysis with unbounded access paths johannes lerch johannes sp ath eric bodden and mira mezini technische universit at darmstadt fraunhofer sit lancaster university darmstadt germany lancaster united kingdom flastname g cs.tu darmstadt.de ffirstname.lastname g sit.fraunhofer.de abstract precise data flow analyses frequently model field accesses through access paths with varying length.
while using longer access paths increases precision their size must be bounded to assure termination and should anyway be small to enable a scalable analysis.
we present access path abstraction which for the first time combines efficiency with maximal precision.
at control flow merge points access path abstraction represents all those access paths that are rooted at the same base variable through this base variable only.
the full access paths are reconstructed on demand where required.
this makes it unnecessary to bound access paths to a fixed maximal length.
experiments with stanford securibench and the java class library compare our open source implementation against a field based approach and against a field sensitive approach that uses bounded access paths.
the results show that the proposed approach scales as well as a field based approach whereas the approach using bounded access paths runs out of memory.
i. i ntroduction static program analyses and especially data flow analyses usually have to consider values being assigned to and read from local variables and fields.
while local variables are often simple to track the systematic handling of fields can be complex.
techniques for modeling fields can be distinguished into fieldbased and field sensitive approaches.
field based techniques model a field access a.f simply by the field s name f plus potentially its declaring type a coarse grain approach that ignores the base object a s identity.
field sensitive techniques on the other hand include the base variable ain the static abstraction potentially increasing analysis precision as fields belonging to different base objects can be distinguished.
while many existing analyses restrict their field sensitivity to a single level more precise analyses represent static information through entire access paths a base variable followed by a finite sequence of field accesses .
for instance assume a taint analysis determining whether and where the example shown in figure 1a might print the password.
here the analysis must distinguish access paths of length k kis the maximal length of the finite sequence to determine that a leak can occur only at the first print statement.
while the use of access paths can increase precision one must generally bound kto a finite maximum as otherwise loops or recursive data structures such as linked lists might cause abstractions such as l.next.prev.next... to grow indefinitely which would cause the analysis not to terminate.
a common approach to deal with infinite chains of field accesses is k limiting which includes in the abstractiononly the first knested field accesses abstracting from all others.
if fields are read the analyses frequently assume that any field accessible beyond the first kfields may relate to the tracked information.
hence k limiting introduces an overapproximation that becomes less precise for smaller values of k. in contrast a high kvalue means the analysis will distinguish more states.
in this work we present experiments which show that analyses can run out of gigabytes of main memory when analyzing real world programs even with small kvalues.
to address the problems raised above we present accesspath abstraction a novel and generic approach for handling field sensitive analysis abstractions without the need for klimiting .
to keep access paths finite and small at controlflow merge points access path abstraction represents all those access paths that are rooted at the same base variable through this base variable only.
in a summary based inter procedural analysis this leads to fewer and yet highly reusable summaries which can speed up the analysis significantly a procedure summary for a base object acan represent information for all access paths rooted in a. to maintain the precision of fieldsensitive analyses access path abstraction reconstructs the full access paths on demand where required.
we present access path abstraction as a novel extension to the ifds framework for inter procedural finite distributive subset problems and hereafter use ifds apa as an acronym for this extension.
we provide an open source implementation on top of the ifds ide solver heros .
in experiments using stanford securibench and the java class library as benchmarks we compare ifds apa against a field based approach and against a field sensitive approach usingk limiting both in terms of scalability and analysis time.
the results show that ifds apa scales as well as a field based approach whereas a field sensitive approach using k limiting runs out of memory.
to recap this work presents the following original contributions a novel extension to the ifds framework enabling scalable and precise field sensitive analysis without the need fork limiting a full open source implementation and extensive experiments comparing the performance of the proposed approach to a field based and a fieldsensitive approach with k limiting.
1heros is hosted on github our implementation is available there.a.g password b.f a print b.f.g print b.f.h a x source a a1 new a a a2 new a a1.f x y a2.f sink y b fig.
precision of field based and field sensitive models the remainder of this paper is structured as follows.
in section ii we give a short summary of the ifds framework while section iii explains common ways to model field accesses.
in section iv we describe our changes and extensions to the ifds framework.
section v covers the evaluation while we discuss related work in section vi and conclude in section vii.
ii.
b ackground on ifds due to its efficiency many data flow analyses are implemented as instantiations of the ifds framework .
we next briefly summarize important background information on ifds necessary to understand our extension ifds apa .
the ifds framework is capable of solving inter procedural finite distributive subset problems.
at every call the framework computes callee summaries on the fly.
these summaries are highly reusable as they are independent of the calling context and due to the distributivity of the analysis problem can be reused on an element by element basis.
internally ifds transforms the original analysis problem into a reachability problem over the so called exploded super graph .
a definition of an ifds problem consists of a data flow domaindand a set of flow functions .
the data flow domain is a set of data flow facts .
a solution to the ifds problem provides information whether a given fact holds at a certain statement.
one special fact is the fact a tautological fact that always holds.
other facts can be generated unconditionally by deriving them from this fact.
to guarantee termination ifds requires the data flow domain to be a finite set.
to express an ifds problem one defines the flow functions which describe how data flow facts are transferred from one statement to its intra and inter procedural successors.
a requirement for ifds is that each flow function say f needs to be distributive w.r.t.
set union thusf a b f a f b fora b d. this allows the framework to define flow functions on single elements of d. the evaluation of the flow function for any such element yields a subset s d. a. path edges ifds computes a callee s procedure summary incrementally through so called path edges .
a path edge is written as uni27e8s d1 uni27e9 uni27e8t d2 uni27e9 wheretis an arbitrary target statement and sis the start statement of the method of t. this makes a path edge always local to one method.
the elements d1andd2are data flow facts d2is the target fact andd1thestart fact of the edge.
semantically a path edge expresses if d1is reachable and therefore holds at statement s so isd2at statement t. the purpose of the flow functions is to successively deduce new path edges to bridge longer and longer paths.
the appropriate flow function for the target statement t sayft receives thedata flow fact d2as arguments.
the result of the application of the flow function is a set of data flow facts s ft d2 .
for each element d3of the setsand each statement t succeeding ta path edge is derived uni27e8s d1 uni27e9 uni27e8t d3 uni27e9.
b. incoming set and summaries an important part of the ifds framework is its incoming set .
for each method and data flow fact which enters the method through a call site the incoming set stores the information through which call site s the method is entered and which path edges reach those call site s .
consider a method mis called at a call site cand the path edge p uni27e8s d0 uni27e9 uni27e8c d1 uni27e9 reachesc.
further assume that the call s flow function maps factd1tod2on the side of the callee m. once entering the method the path edge pis added to the incoming set id2mfor the callee method mand factd2 sop id2m.
ifds seeks to construct procedure summaries that are independent of any particular calling context.
it thus bootstraps the analysis of any callee mby propagating an initial self loop edge uni27e8v d2 uni27e9 uni27e8v d2 uni27e9from the start statement vofm.
this expresses that d2holds atvifd2holds atv i.e.
without any further condition.
from this edge new path edges are successively derived via the application of the flow functions.
the flow functions maintain the start statement and start node of the derived edges.
whenever a derived path edge say uni27e8v d2 uni27e9 uni27e8t d3 uni27e9 reaches an exit statement tof the method m this path edge becomes a partial procedure summary.
the framework must now apply this summary s effect to all callers ofm.
it traverses the incoming set id2mto extract all call sites at which path edges inside callers have to be continued.
a return flow function maps d3back to a fact d4in the caller scope.
here assuming the path edge pis in the incoming set ifds continues with the path edge uni27e8s d0 uni27e9 uni27e8c d4 uni27e9for any successor statement c ofc.
the path edge uni27e8v d2 uni27e9 uni27e8t d3 uni27e9is stored as a intraprocedural summary for method m. the summary can be reapplied for any other call site which is interested in analyzing the method mwith the same input fact d2.
iii.
m odeling fields in data flow analysis in this section we discuss two alternatives for modeling field accesses in data flow analyses.
we use taint analysis as an example client however the described techniques are applicable to data flow analyses in general.
a taint analysis reasons about possible data flows from a given source to a given sink and can decide privacy as well as integrity problems .
a. field based models field based analyses treat fields independently of the objects they belong to.
they track a field as soon as a tracked value is assigned to it independent of the object instance the field belongs to.
thus any subsequent read from the field must be tracked no matter which object the field belongs to.
a possible analysis domain dfor a field based analysis comprises all local variables lof all program s methods and all fields fdeclared in the program so d l f. while a field based analysis can be sound not considering the base object will often lead to imprecision as illustrated by the following example.foo a a new a a.f source a b id a bar a a new a a.g source a b id a id a p return p a multiple summariesfoo a a while unknown a b new a if unknown b.f a else b.g a a b b null return a b state explosion fig.
examples of threats to scalability example in figure 1b field a1.f is assigned the tainted value of x. field a2.f never gets tainted.
nevertheless the analysis will report it as tainted because it models both field accesses as a.f resulting in a false positive.
b. field sensitive models a more precise alternative is to model field accesses as access paths .
an access path consists of a base variable a local variable visible in the current method s scope including its parameters and the receiver this followed by a sequence of field accesses.
in a taint analysis an access path typically models an access path through which a tainted memory location can be reached.
field sensitive models are more precise than field based ones.
in figure 1b a field sensitive analysis would taint the access path a1.f but not a2.f .
when processing the read y a2.f no taint will be reported for y avoiding a false warning.
unfortunately the described data flow domain is unbounded.
assume a further assignment a3.g a1 somewhere in the code in figure 1b.
to maintain precision the analysis must propagate the taint from a1.f toa3.g.f resulting in an access path of length .
if proper care is not taken loops can yield access paths of an unbounded length.
also analyzing recursive data structures e.g.
doubly linked lists may yield unbounded access paths such as l.next.prev.next... .
although l.next andl.next.prev.next statically refer to the same object most analyses are unable to identify this equivalence.
formally for a field sensitive taint analysis the data flow domain is identifiable as the set d x1 xk divides.alt0k n x1 l xi f i this domain of infinite size contradicts the requirements of ifds and other data flow analysis frameworks that guarantee termination only for finite data flow domains.
to obtain a finite domain it is common practice to artificially bind the sequence of field accesses to a fixed length by limiting kin the domain definition to a given natural number.
this is known as k limiting .
analyses then have to suitably alter the processing of bounded access paths to retain soundness.
limiting kobviously introduces an overapproximation.
decreasing the selected kvalue increases theover approximation and lowers the precision.
increasing the k value enables the analysis to distinguish more states however at the cost of defeating its scalability due to state explosion.
our experiments presented in section v show that even for smallkvalues analyses can run out of gigabytes of main memory when analyzing real world programs.
there are two main root causes for the scalability problems a due to the way applicability of method summaries is defined even methods that represent an identity function w.r.t.
an input tainted value must be re analyzed for each access path rooted at that tainted value b due to an explosion of different states to be considered.
the following two examples illustrate the root causes.
example methods that represent an identity function w.r.t.
the tainted value must be re analyzed for each possible call site.
for illustration consider the code in figure 2a.
assume a classawith two fields fandg.
method foo taints a.f which a field sensitive analysis will model by the access path a.f.
next this access path flows as a parameter into method id.
typical summary based analyses will translate the abstraction a.f to the scope of the callee yielding p.f.
next the analysis will create a procedure summary for id indicating that it taints retval .fifp.f was tainted.
now consider the second calling context for idwithin bar which passes a tainted value a.g. again this value is translated into p.g.
since the computed summary for p.f is not applicable to p.g the analysis will process the id procedure again although id returns the parameter unchanged.
while the analysis effort is trivial in this example the method idcould in reality have many more statements and may call many other methods while remaining an identity function i.e.
opaque w.r.t.
the tainted value.
such methods can be quite frequent in an application.
example each unique access path must be propagated resulting in an explosion of the propagated facts.
for illustration consider the code in figure 2b.
assume that the parameter aof method foo is tainted and that we cannot statically decide the values to which the while andifconditions will evaluate i.e.
both branches are possible for each condition.
each loop iteration thus propagates from atob.f andb.g.
hence foo may return tainted access paths a no loop iteration a.f anda.g one iteration a.f.f a.f.g a.g.f and a.g.g two iterations and so on.
given a maximum access path length ofkandathe set of fields written inside the loop this yields k n divides.alt0a divides.alt0ndifferent access paths.
in ifds the merge operator at control flow merge points is restricted to set union.
thus the analysis cannot merge facts and must propagate each unique access path.
in our experiments we observed that constructs similar to those illustrated by this example defeated the scalability of our field sensitive client analyses.
the most common construct was actually not a loop but methods invoked on an interface type with many concrete implementations.
if it is undecidable to which concrete implementation the method call must be resolved analyses typically assume that any of them may be called.
if one of them recursively invokes the same interface method we observe the same effect as in the example the loop manifests itself at an inter procedural level through recursion.iv.
a pproach we propose access path abstraction a sound and scalable framework for field sensitive data flow analysis.
access path abstraction obviates the need for over approximations like klimiting for keeping the domain finite and hence also the need to tradeoff between precision and scalability.
the key ideas underlying access path abstraction are abstract summaries are constructed that abstract over a whole set of access paths e.g.
if a method is invoked with an access path a.f access path abstraction creates a summary for a. instead.
abstract summaries such as a. are reused for all callers invoking the respective method with any access path covered by the abstraction e.g.
a.g or any other access path sharing the common prefix a. yet the application of summaries is designed such that the result reflects specific access paths of specific callers.
access path abstraction ensures that only those parts of the application are analyzed that would be analyzed if concrete access paths were used instead of abstract summaries.
for example a taint analysis processing an assignment b a.g should continue for bif and only if a.g is tainted but not because any other tainted field of a e.g.
a.f was abstracted to a. .
next we describe the changes and extensions to the ifds framework that are required to achieve and then we elaborate on changes for .
subsequently we discuss how the extensions can be adapted to loops and return sites to solve the state explosion problem described in example and why access path abstraction obviates the need for overapproximations like k limiting keeping the domain finite.
ifdsapa the variant of access path abstraction we describe here extends the ifds framework .
a. the analysis domain ifds apa uses an efficient abstraction that encodes sets ofaccess paths in a concise symbolic representation.
access path given the set of all local program variables land the set of all field declarations f an access path is a sequence of a local variable followed by a sequence of field accesses n with land i ffor i nandn divides.alt0 divides.alt0.
access path bundles to realize the idea of constructing abstract summaries we formulate an analysis domain that implicitly encodes sets of access paths.2in this domain a fact is called an access path bundle and consists of an access path and a set of exclusions e e f. exclusions are the key to avoid unnecessary analysis steps due to over approximation as we explain later.
the tuple uni27ea e uni27ebrepresents a whole set of access paths formally defined as uni27ea e uni27eb uni27ea divides.alt0 divides.alt0 e uni27eb x1 xm divides.alt0xi i i divides.alt0 divides.alt0 m divides.alt0 divides.alt0 x divides.alt0 divides.alt0 e 2a client analysis may include specific information into facts.
our implementation anticipates this.
however to ease the exposition throughout this paper we restrict facts to just a pair of an access path and the set of exclusions.hence the bundle uni27ea e uni27ebrepresents all access paths of length greater or equal to divides.alt0 divides.alt0 which start with the sequence and whose field x divides.alt0 divides.alt0 1is not ine if the length of the path is greater than divides.alt0 divides.alt0.
we say that a bundle uni27ea e uni27ebbelongs to the locall l iff l. for brevity we write to denote a bundle uni27ea e uni27eb.
in the following we define some operations on access path bundles which are used in the process of constructing and applying summaries.
partial order on the set of all bundles the relation uni27ea e uni27eb uni27ea e uni27ebholds iff the following conditions given k and l are fulfilled divides.alt0 divides.alt0 divides.alt0 divides.alt0 i i i divides.alt0 divides.alt0 braceleft.alt4 divides.alt0 divides.alt0 e if divides.alt0 divides.alt0 divides.alt0 divides.alt0 e e if divides.alt0 divides.alt0 divides.alt0 divides.alt0 intuitively is a prefix of and is not excluded through the exclusion set e if the length of is greater than if they have the same length e excludes at least the fields excluded bye .
if two access path bundles only differ in their exclusions we write uni27ea e uni27eb uni27ea e uni27eb formally defined as divides.alt0 divides.alt0 divides.alt0 divides.alt0 i i i divides.alt0 divides.alt0 divides.alt0 divides.alt0.
for two access path bundles and such that or we define their delta denoted by f 2f as braceleft.alt4 divides.alt0 divides.alt0 divides.alt0 divides.alt0 e if divides.alt0 divides.alt0 divides.alt0 divides.alt0 e e if divides.alt0 divides.alt0 divides.alt0 divides.alt0 here refers to the empty sequence.
note that a delta is not an access path bundle and never contains a local variable.
concatenation of an access path bundle and a delta given a bundle and an arbitrary delta e we define the concatenation which yields a new bundle as follows braceleft.alt4 uni27ea divides.alt0 divides.alt0 divides.alt0 divides.alt0 e uni27eb if uni27ea divides.alt0 divides.alt0 e e uni27eb if if is non empty then its elements are used to refine the access path by extension .
as exclusions always refer to the position after the end of the access path in this case one retains only the exclusions e .
in the other case both sets of exclusions are retained.
b. abstract summaries at specific statements called abstraction points ifds apa abstracts over a given access path bundle to compute an abstract summary.
abstraction points are all merge points of intra or inter procedural control flows a start points of methods b entries to loops and c return sites.
in the following we will focus first on a as the most intuitive of those cases.
the key to the efficiency of ifds apa is that in cases where an access path bundle uni27ea n e uni27ebis passed to a calleec ifds apa will bootstrap c s analysis with aninitial self loop path edge not of but of an abstracted version of that represents all access paths rooted in the same local variable as i.e.
uni27ea uni2205 uni27eb.
for instance in a situation where a callee would normally be analyzed for uni27eaa.f.g uni2205 uni27eb ifdsapa initiates an analysis for uni27eaa uni2205 uni27ebinstead.
if a summary for the abstracted bundle already exists ifds apa applies this summary without further computation.
while the application of summaries to avoid computations is equal to ifds ifds apa requires a different definition of both i when a summary is applicable and ii how it is applied.
in line with ifds terminology summaries are of the form uni27e8spcallee d3 uni27e9 uni27e8epcallee d4 uni27e9 d4holds at end point epcallee in any context in which d3holds at the start point spcallee .
a summary uni27e8spcallee d3 uni27e9 uni27e8epcallee d4 uni27e9is applicable to an incoming fact d2 uni27ea ea uni27ebiffd3 d2.
the summary is applied by computing the delta between d3andd2and concatenating it tod4.
thus for a start point spcaller at the caller for which the factd1resulted ind2being propagated to the callee we generate the path edge uni27e8spcaller d1 uni27e9 uni27e8rs d d3 d2 uni27e9to the return site rs.
example referring back to example and figure 2a ifds apa analyzes method idonly once for the accesspath bundle uni27eap uni2205 uni27eb.
method foo callsidwith an incoming fact uni27eap f uni2205 uni27eband method bar with uni27eap g uni2205 uni27eb.
the summary foridmaps uni27eap uni2205 uni27ebto uni27earetval uni2205 uni27eband is applicable to both incoming facts.
the application computes the deltas f uni2205 and g uni2205 and their concatenation to the returned value yields the facts uni27eab f uni2205 uni27ebfor method foo and uni27eab g uni2205 uni27ebfor method bar.
in other words concatenating the deltas restores the calling context that was abstracted away before the callee was analyzed.
c. field read and field write statements next we explain how ifds apa handles cases where callee procedures read from or write to access paths that were abstracted on entry to the callee.
field read statements assume that we are analyzing a calleecwith a taint represented by an abstracted access path bundle uni27eax uni2205 uni27eb.
ifcreads x.f the analysis cannot know which of x x.f orx.g etc.
are tainted as uni27eax uni2205 uni27ebeffectively represents all access paths x. .
ifds apa addresses this problem by computing the required information on the fly.
it checks c s incoming set for callers that explicitly requested the analysis with respect tox.f before the abstraction occurred for a path edge uni27e8sp uni27ea n e uni27eb uni27e9 uni27e8b x.f uni27eax e uni27eb uni27e9ifds apa checks whether the incoming set contains a fact such that uni27ea n f uni2205 uni27eb .
if this is the case the analysis continues with a path edge to each successor t of the statement b x.f with a refined start fact uni27e8sp uni27ea n f uni2205 uni27eb uni27e9 uni27e8t uni27eab uni2205 uni27eb uni27e9.
the intuition for this refinement is iff any access path starting with n f flows into statement sp it will flow to an access path starting with bat statement t .
note thatifds apa proceeds as just described only iff fwas not excluded i.e.
f e andf e .
3we omitted mapping the actual parameter to the formal parameter and the return value of the callee to the assigned value at the caller to keep the explanation brief.
mappings of local variables through call and return edges are actually performed as in the original ifds framework.main a a new a a.f source z wrapper a wrapper a b y bar b return y bar a c x c.f return x fig.
callbacks created for a field read statementpath edge call edge generated by uni27eaa.f uni2205 uni27eb uni27eab uni2205 uni27eb uni27eab uni2205 uni27eb uni27eac uni2205 uni27eb uni27eac uni2205 uni27eb uni27eab.f uni2205 uni27eb uni27eac uni2205 uni27eb ifds uni27eab.f uni2205 uni27eb uni27eac.f uni2205 uni27eb uni27eax uni2205 uni27eb uni27eac.f uni2205 uni27eb callbacks if no caller requested the analysis with respect to x.f yet the analysis must soundly cater for the fact that this could happen in later rounds of the fixed point iteration.
to handle this ifds apa creates a callback that creates the path edge s upon future invocation.
the callback is registered with the incoming set and is invoked if a caller provides an incoming factx.f.
technically we always create the callback but this callback is invoked immediately if the condition is already fulfilled.
section iv d discusses callbacks in more detail.
field write statements assume that we are analyzing a calleecwith access paths represented by the bundle uni27eax uni2205 uni27eb and coverwrites x.f with an un tainted value e.g.
x.f null .
this assignment kills flows to x.f.
therefore the analysis should only continue if a caller exists that calls cwith an access path rooted in xbutdifferent from x.f.
field exclusions are used to express this.
for a path edge uni27e8sp uni27ea e uni27eb uni27e9 uni27e8x.f null uni27eax e uni27eb uni27e9the framework refines the start fact by adding the field fto the exclusion set yielding the refined fact uni27ea e f uni27eb.
if the incoming set of ccontains a fact such that uni27ea e f uni27eb the analysis will continue with a path edge uni27e8sp uni27ea e f uni27eb uni27e9 uni27e8t uni27eax e f uni27eb uni27e9to each successort of statement x.f null .
if there is no incoming fact satisfying the constraint the framework creates a callback that will create the path edge s on invocation.
this is analogue to field reads.
d. callbacks callbacks can be registered with abstraction points e.g.
the start point of a method together with trigger conditions that guard their invocation.
a trigger condition specifies a predicate on an access path bundle .
for example the trigger condition for the callback registered with the method s starting point of the example in the sub section about field read statements required an incoming fact for which uni27ea i f uni2205 uni27eb holds.
in this case the access path bundle associated with the callback condition is uni27ea i f uni2205 uni27eb.
the callback is then invoked if a fact for which holds is passed to the abstraction point with which the callback is registered.
example consider the method bar in the example infigure while ignoring the methods main andwrapper for now.
the method bar will be analyzed with an accesspath bundle uni27eac uni2205 uni27ebat the start point.
field fis read at statement x c.f .
this causes a callback cbto be registered with the start point spbarofbar that will create the path edge uni27e8spbar uni27eac.f uni2205 uni27eb uni27e9 uni27e8return x uni27eax uni2205 uni27eb uni27e9upon invocation.
the access path bundle associated with cbas the trigger condition is uni27eac.f uni2205 uni27eb.
the incoming fact uni27eac uni2205 uni27eb is checked against this condition does not hold hence no path edge is created.
if the analysis processes another call that passes a taint uni27eac.f uni2205 uni27ebto the start point spbar the callback is triggered because holds.
the trigger condition also holds for uni27eac.f.g uni2205 uni27eb but not for uni27eac.g uni2205 uni27eb.
the semantics of callback registration and invocation defined so far is simplistic.
it ignores the fact that several abstractions can happen along different invocation chains callback trigger conditions so far only consider the local view on access paths of methods that contain field reads or writes.
this may cause unsoundness of the analysis as illustrated by the example below.
example consider the methods main andwrapper in in figure .
the method main generates a taint uni27eaa.f uni2205 uni27eb and passes it to wrapper .
onwrapper s entry this taint is abstracted to uni27eab uni2205 uni27eband then passed to bar which reads the fieldc.f.
this field read results in the callback installation with the trigger uni27eac.f uni2205 uni27ebas discussed before.
the callback s condition cannot be fulfilled as it is registered for the start point of bar which was only passed the abstracted access pathc notc.f.
as a result the analysis will miss a tainted edge hence be unsound.
the example not only illustrates how unsoundness can occur if we leave things as described.
it also suggests what needs to be done to avoid unsoundness ifds apa must reiterate the registration and evaluation of callbacks in callers.
to ensure that callbacks are also triggered transitively the framework replicates callbacks along the incoming sets.
when the framework attaches a callback to a method start point it iterates over the incoming edges the path edges within the incoming set and checks whether any of the edge s target facts potentially satisfies the condition of the callback.
assume an incoming edge uni27e8spcaller uni27e9 uni27e8t uni27e9for a callee start point spcallee .
the incoming fact potentially satisfies the callback condition in two cases a if or b if .
in any of the two cases the framework performs the following steps a it computes the delta between the incoming fact and the condition b the delta is concatenated to the start fact of the incoming edge c the result is installed as the trigger condition for the replicated callback and d the latter is registered with the start point spcaller of the incoming edge.
on invocation of the replicated callback the framework registers a new incoming fact to the start point spcallee constructed by concatenating the original incoming fact and the computed delta .
this new incoming fact satisfies the trigger condition of the original callback at spcallee which therefore will be executed.
note that when the framework registers the replicated callback with the start point of the incoming edge this may result in other replicated callbacks being created as the same steps are performed recursively for callers of callers.
thisrecursion may happen until the analysis reaches an initial seed fact .
this process may seem expensive at first sight but it is not.
consider that the framework only needs to traverse path edges.
each path edge skips over all the internal nodes of the respective methods such that in the worst case one needs to traverse only as many path edges as there are frames on the current abstract call stack.
the following example illustrates how the transitive registering of callbacks avoids the unsoundness that would occur otherwise.
example reconsider example and figure .
the field read statement in method bar will generate a callback.
this callback creates the path edge uni27e8spbar uni27eac f uni2205 uni27eb uni27e9 uni27e8return x uni27eax uni2205 uni27eb uni27e9.
the trigger condition of the callback is not satisfied by the incoming fact uni27eac uni2205 uni27eb because uni27eac f uni2205 uni27eb uni2289 uni27eac uni2205 uni27eb.
but this incoming fact potentially satisfies the condition transitively because uni27eac uni2205 uni27eb uni27eac f uni2205 uni27eb.
consequently the framework replicates a transitive callback for the incoming edge reflecting the call edge from wrapper tobar.
using the path edge into the call site the framework can retrieve the start point statement and the start fact at that statement.
the transitive callback is registered with this startpoint statement using as condition the start fact concatenated with the delta uni27eac uni2205 uni27eb uni27eac f uni2205 uni27eb .
therefore the condition is uni27eab uni2205 uni27eb uni27eac uni2205 uni27eb uni27eac f uni2205 uni27eb uni27eab f uni2205 uni27eb.
this condition is immediately satisfied by the incoming fact uni27eab f uni2205 uni27ebthat is passed from main towrapper .
hence the transitive callback is invoked immediately and creates the call edge which registers uni27eac f uni2205 uni27ebas incoming fact to bar.
this new incoming fact triggers the first callback which in turn creates the path edge uni27e8spbar uni27eac f uni2205 uni27eb uni27e9 uni27e8return x uni27eax uni2205 uni27eb uni27e9 with which the analysis will continue.
e. loops to solve the termination problem caused by recursive constructs such as loops and recursive data structures without bounding the size of access paths access path abstraction introduces additional abstraction points beyond method calls.
here we explain the handling of other control flow merge points.
this includes in particular entries to loops.
first we illustrate by an example how the termination problem is solved by introducing loops as abstraction points.
subsequently we discuss the algorithmic changes required to accommodate additional abstraction points.
example for the loop shown in figure 2b the framework will proceed as follows.
it first creates an initial self loop at the start point of foo with the access path bundle uni27eaa uni2205 uni27eb.
then it passes this bundle to the beginning of the loop i.e.
the abstraction point.
the framework abstracts the bundle which in this case has no effect yielding the same bundle again.
the loop causes the bundle uni27eab.f uni2205 uni27ebto be created along one branch and uni27eab.g uni2205 uni27ebalong the other.
then bis assigned to a such that uni27eaa.f uni2205 uni27eband uni27eaa.g uni2205 uni27ebare passed back to the entry of the loop i.e.
back to the abstraction point.
at the loop abstraction point the framework proceeds just as it does at the entry to a called procedure.
it stores both bundles as incoming facts and continues the next iteration with abstracted accesspath bundles.
in this example no additional iteration will be computed because both access path bundles are abstracted to uni27eaa uni2205 uni27eb i.e.
to a fact that the analysis already processed.sp c a b.g a c.f b ap d c.f e d.f .
.
.
uni27eaa uni2205 uni27eb uni27e8 uni27eaa uni2205 uni27eb uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27eaa uni2205 uni27eb uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27eaa uni2205 uni27eb uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27eab.g uni2205 uni27eb uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27eac uni2205 uni27eb uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27eac.f.g uni2205 uni27eb uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27eac uni2205 uni27eb ap uni2205 uni27e9 uni27eaa.f uni2205 uni27eb uni27e8 uni27ead uni2205 uni27eb ap f uni2205 uni27e9 uni27eaa uni2205 uni27eb uni27e8 uni27ead uni2205 uni27eb ap f uni2205 uni27e9 uni27eaa.f.f uni2205 uni27eb uni27e8 uni27eae uni2205 uni27eb ap f.f uni2205 uni27e9 fig.
handling of arbitrary nodes as abstraction points uni27ea uni2205 uni27eb uni27e8 uni27ea uni2205 uni27eb ap uni2205 uni27e9is used here as abbreviation for a path edge uni27e8sp uni27ea uni2205 uni27eb uni27e9 uni27e8s uni27ea uni2205 uni27eb ap uni2205 uni27e9 wherebysis the respective cfg node at which the path edge is drawn.
to summarize the additional abstraction points solve the termination problem without the need to restrict the size of access paths.
however the additional abstraction points require an algorithmic change to correctly handle callbacks.
when a field read or field write statement is processed the framework must register a callback with the latest abstraction point it passed.
if that abstraction point is a method entry it is easily identified because every path edge starts at a method start point by definition.
to identify the latest abstraction point in other situations we modify the definition of path edges to also use a reference to the latest non start point abstraction point if such an abstraction point has been passed.
in addition we include a sequence of fields to reflect which field accesses have been resolved via the abstraction point already and a set of exclusions.
we will explain their need in the next example.
from now on we will write path edges as uni27e8sp uni27e9 uni27e8t ap e uni27e9 whereby sp t and are as before the start point access path bundle at the start point a target statement and an accesspath bundle at the target respectively.
new are ap ande representing an abstraction point a sequence of field accesses n i f and a set of excluded fields e f. example for this example consider figure .
the figure shows a control flow graph supplemented by artificial nodes for the start point spand an abstraction point ap.
each node is annotated with the path edge targeting that node whereby we use an abbreviated form that omits the statements as they are easily inferred from the graph.
we show only those path edges that are of interest for the example.
note that path edges are aligned at the left side of the figure if a path edge results from the left branch taken aligned at the right side if the right branch is taken respectively.
the path edge is drawn close to the node if the path edge results from both branches.
the path edges in the upper part of the figure drawn inblue are straightforward.
the analysis propagates through both branches resulting in facts uni27eac uni2205 uni27eband uni27eac.f.g uni2205 uni27ebpassed to the abstraction point ap.
both are registered as incoming facts together with their respective path edges.
after the abstraction point the analysis continues with an abstracted access path bundle uni27eac uni2205 uni27ebonly and stores in the path edge succeeding apa reference to ap.
now at statement d c.f the field fis read resulting in a callback being generated.
the callback is not registered with the start point sp but with the abstraction pointap because in the path edge an abstraction point was referenced i.e.
the start point is not the latest passed abstraction point.
the callback s condition is checked against the incoming facts atap.
the condition can be immediately fulfilled via the right branch providing uni27eac.f.g uni2205 uni27eb.
this yields the path edge uni27e8sp uni27eaa uni2205 uni27eb uni27e9 uni27e8e d.f uni27ead uni2205 uni27eb ap f uni2205 uni27e9.
note that the framework includes the field fin the path edge reflecting that a condition was fulfilled consuming a field access fof some incoming edge at ap.
this is because the analysis satisfied the callback s condition via the incoming fact uni27eac.f.g uni2205 uni27eb consuming f such that for succeeding fieldread statements the analysis must take into account that fhas been read already and the incoming fact can now only be used to read field g. proceeding in the example ifds apa uses this information to know at statement e d.f that the callback generated here cannot be fulfilled by apvia the right branch.
to store information about which fields have already been excluded the set e of the new path edge is used analogously.
so far we have ignored that the callback generated at statement d c.f could be potentially satisfied transitively through the start point sp.
this is the case because the incoming fact via the left branch potentially satisfies the condition.
as discussed in section iv d ifds apa therefore replicates the callback for transitively preceding abstraction points i.e.
for the start point sp.
when this replicated callback can be fulfilled which in this case depends on the incoming facts provided by callers ifds apa registers an incoming fact uni27eac.f uni2205 uni27ebat ap which triggers the creation of path edge uni27e8sp uni27eaa.f uni2205 uni27eb uni27e9 uni27e8e d.f uni27ead uni2205 uni27eb ap f uni2205 uni27e9.
f .
return sites by introducing loops as additional abstraction points we solve the state explosion problem for the intra procedural case.
but state explosion may still occur inter procedurally.
for illustration consider the example in figure .
assume foo to be an interface declaring a method foo with a parameter xto be tainted.
classes aandbboth implement this interface and provide similar implementations of foo both recursively callfoo.
assume that the precise type of fis statically undecidable therefore the call is resolved to a.foo and b.foo .
in addition both wrap the tainted value in another object s field and return the object awrites to field aandb to field b. assume the analysis is computing a summary for a tainted parameter x. without the recursive call the summary of foo yields a mapping from xtoy.a respectively y.b.
for the branch performing the recursive call the analysis applies the summaries for both a.foo andb.foo which will in turn generate the additional summaries from xtoy.a.a and y.a.b fora.foo and from xtoy.b.a and y.b.b for b.foo .
this results in a similar state explosion as for loops.class a impl.
foo foo f aorb foo x x if unknown x f.foo x y.a x return y class b impl.
foo foo f aorb foo x x if unknown x f.foo x y.b x return y fig.
state explosion through access paths note that an analog case in which the taint is wrapped in a field before passing it as parameter to the recursive call is already solved.
as ifds apa abstracts at method start points the analysis encounters the previously seen fact uni27eax uni2205 uni27eband stops.
by also applying abstraction at return sites in the same way as in the treatments for loops the state explosion problem can be solved here as well.
hence at the return sites of call foo the framework does abstract that the returned facts are uni27eax.a uni2205 uni27eband uni27eax.b uni2205 uni27eband continues with the fact uni27eax uni2205 uni27eb.
uni27eax.a uni2205 uni27eband uni27eax.b uni2205 uni27ebare registered as incoming facts with the return site.
as before a reference to the return site as last passed abstraction point is included in subsequent path edges allowing to reconstruct the abstracted field accesses.
g. termination in presence of an unbounded domain in theory the analysis domain consisting of access path bundles has an infinite size.
one thus might wonder why ifds apa guarantees termination.
termination would be threatened in cases where the framework would create accesspath bundles of ever growing size.
but this is impossible as such unlimited growth can only occur due to loops or recursion.
since ifds apa abstracts access path bundles at every entry into a procedure or loop the length of the access path portion of an access path bundle is thus bounded by the maximal length of the access paths used within a single procedure or loop iteration.
this guarantees termination.
v. e valuation we performed experiments to compare the proposed approach against two baseline approaches a field based approach denoted fb and a classic field sensitive approach that uses klimiting as described in section iii denoted fsk.
specifically the experiments address the following two research questions rq1 given a fixed heap size which analyses can successfully analyze our benchmark subjects?
rq2 how fast is ifds apa compared to the baseline approaches?
a. setup our implementation of ifds apa is based on heros an open source implementation of an ifds ide solver we contributed our adaptations back to the heros project.
the two baseline approaches also use the ifds implementation provided by heros.
the experiments carry out taint analyses for which we use the implementation of flowtwist .
flowtwist uses heros and is based on the soot code analysis framework .
originally designed to address confused deputy problems inthe java class library flowtwist can be used to conduct general purpose data flow analysis .
we use flowtwist for three different experimental setups.
in the first two setups we use an adaptation of flowtwist to detect sql injection command injection path traversal and unchecked redirection vulnerabilities.
we apply the analysis to the stanford securibench dataset consisting of seven web applications.
in the first setup we use only the bare web applications while we include their dependencies and the java class library in the second setup.
for the first two setups a pure forward analysis is conducted.
in a third setup we use the original flowtwist implementation which conducts a synchronized forward and backward taint analysis to detect confused deputy vulnerabilities within the java class library jcl .
.
e.g.
any call to the method class.forname string cls where the string cls is user controlled and the return value flows back to the user.
these flows are problematic and are commonly used in exploits .
this setup uses a call graph starting at all of the jcl s public methods leading to a much larger coverage of the jcl s methods than with securibench.
the applications within the securibench suite vary from to classes and to lines of code per project.
we found it much more relevant though to characterize the projects by the number of edges of their respective inter procedural control flow graphs icfgs which are shown in the second column of table i. the icfgs are relatively small if the web applications are considered in isolation but their size grows significantly if all dependencies are also considered.
we counted only those control flow edges that are contained in methods that are transitively reachable from within the web applications.
all experiments were conducted on a machine running os x .
with a core intel xeon e5 .
ghz processor and gb memory.
as java runtime environment we used the oracle java .
.0u40 release with a heap size set to a maximum of gb.
b. results rq1 seeks to answer the questions which approaches can at all analyze which benchmarks within the allotted gb of maximum heap size.
to address this question we ran all approaches on all benchmarks.
table ii shows those configurations that ran out of memory as oom.
results for all three setups are shown separated by horizontal lines.
as long as the dependencies were excluded all approaches were able to analyze all of securibench.
if dependencies are considered however only ifds apa and fbwere able to analyze all securibench applications.
fskwas only able to analyze all of securibench when kis set to zero.
blueblog andwebgoat could be analyzed for k limiting with fsk 1orfsk but no application could be analyzed with any higher value for k. none of the configurations was able to successfully complete the flowtwist analysis of java .
.
with the available memory.
to gain a better understanding of the relative scalability we measured two metrics while running all subject analyses on the web applications of securibench.
first we measured the fraction of the statements each analysis must traverse i.e.
how many icfg edges it traverses.
we also measured how many times flow functions are being evaluated.
the results of these measurements are shown in table i. the fraction oftable i measures of efforts spent by each analyses vis.
icfg edges visited during the analysis eval.
number of flow function evaluations oom out of memory projecticfg edgesifds apa fbfsk k k k k vis.
eval.
vis.
eval.
vis.
eval.
vis.
eval.
vis.
eval.
vis.
eval.
blueblog jboard pebble personalblog roller snipsnap 249excl.
dependencieswebgoat blueblog oom oom jboard oom oom oom oom oom oom pebble oom oom oom oom oom oom personalblog oom oom oom oom oom oom roller oom oom oom oom oom oom snipsnap oom oom oom oom oom oomincl.
dependencieswebgoat oom oom jcl .
.
oom oom oom oom oom oom oom oom oom oom oom oom table ii run times of the ifds framework in seconds project ifds apa fbfsk k 0k 1k 2k blueblog .
.
.
.
.
.
jboard .
.
.
.
.
.
pebble .
.
.
.
.
.
personalblog .
.
.
.
.
.
roller .
.
.
.
.
.
snipsnap .
.
.
.
.
.22excl.
dependencieswebgoat .
.
.
.
.
.
blueblog .
.
.
.
.
oom jboard .
.
.
oom oom oom pebble .
.
.
oom oom oom personalblog .
.
.
oom oom oom roller .
.
.
oom oom oom snipsnap .
.
.
oom oom oomincl.
dependencieswebgoat .
.
.
.
.
oom jcl .
.
oom oom oom oom oom oom icfg edges each analysis traverses is shown as a percentage of all the application s icfg edges in columns denoted as vis.
the frequency of evaluating flow functions is shown as an absolute number in columns denoted as eval.
while the percentage of visited icfg edges is similar for all approaches when analyzing the web applications in isolation we can clearly see a trend when dependencies are considered ifds apa visits fewer icfg edges than the other approaches.
the same trend is visible for the number of flow function evaluations.
forfsk with increasing kthe analysis must compute more flow functions for more contexts but can sometimes restrict itself to a slightly smaller fraction of the icfg due to the added precision.
to address the second research question we measured the execution time of the ifds framework excluding the time taken to load and pre process the bytecode as well as to compute a call graph.
this pre computation time is shared by all three approaches.
the results are shown in table ii.
all approaches are able to analyze the web applications in isolation in less than a second.
when dependencies are considered we can observe differences in execution times ranging from one second up to minutes for a single approach depending on the benchmark.
we can see that the fbis faster than ifds apa .fsk 0is faster than ifds apa on some applications and slower on others.
fork fskis slower than ifds apa.c.
discussion regarding rq1 we conclude that memory wise ifds apa scales clearly better than fskand as well as fb.fskfails for higherkvalues when analyzing securibench with dependencies.
all approaches are not able to terminate successfully within the given memory when analyzing the java class library.
the answer to rq2 is not as clear.
especially when including dependencies ifds apa is faster than fskfor some benchmarks but slower for others.
it is also worth noting that ifds apa is always slower than fb although fb typically computes more flow functions and traverses larger portions of the icfg due to its rather imprecise abstraction that leads to over tainting.
however while fbcan traverse the entire application in a single fixed point iteration ifds apa must reconstruct abstracted access paths on demand and must proactively register callbacks to allow for incoming access paths computed in later phases of the fixed point iteration.
our experiments indicate that the cost of these operations seem to outweigh savings due to the more precise abstraction.
before concluding this section we briefly consider precision.
by nature a field sensitive approach can yield more precise results than a field based approach see figure 1b .
in k limiting over approximation is controlled by the value for k. in theory k limiting would achieve the same precision as ifds apa ifkis chosen to be at least the length of the longest access path in the application to be analyzed.
this is considering an application which does not generate access paths of infinite length through loops or recursion as shown in example .
note that in contrast ifds apa terminates and achieves optimal precision with respect to field sensitivity even for such programs.
as our experiments further show choosing a high value for kwill severly degrade scalability of a k limiting based approach in practice.
on the other hand selecting small k values not only degrades precision but may as well be a threat to the scalability as more data flows have to be considered that are caused by the over approximation.
this is indicated by the results shown in table i. for example the application snipsnap excluding dependencies has more flow function evaluations for fsk 0than forfsk .
in addition the number of flow function evaluations increases again for kvalues set to two or three.
further a toosmallk value can even give up soundness.
using ifds apa relieves analysis designers of all those considerations.
we conclude that ifds apa implements an analysis that in terms of precision is at least as precise as fskand scales better than fs kfor all values of k .
vi.
r elated work despite the existence of many data flow frameworks we are not aware of any other framework explicitly handling fieldsensitivity and bounding the data flow domain.
both is usually left to the clients of the framework.
therefore we here relate to field sensitive data flow analyses and how they model data flow domains and to existing work on abstract summaries .
a. field sensitive data flow models the access path model is broadly used within analyses such as alias analyses or taint analyses .
one attempt by deutsch to circumvent the limit of the access path model was to use a symbolic representation of an access path in which reoccurring field accesses are grouped into a single symbolic one.
the symbolic notation is close to a regular expression over the fields.
for example if two aliased values are both repeatedly written to a field fin the same loop deutsch s approach is able to learn that a.fnand b.fnmay be aliased whereas nis some arbitrary number of times the aliased values are nested.
the advantage of the approach is that it is known that the nesting has happened the same times for both values and that only the n th nesting is aliased with each other.
while this is a solution to overcome k limiting in this special case it does not solve the general case.
if only one value is considered nhas no more meaning.
this results in a simple over approximation comparable to a variant ofk limiting as it is applied in flowdroid.
flowdroid is a taint analysis for android applications.
in addition to limiting the access path to be at most of size k flowdroid collapses sub paths between two equal field accesses in an access path.
if a sub path is collapsed flowdroid flags that this sub path may be repeatedly read.
this is an overapproximation and may result in fields being read for which a taint has never been written.
geffken et al.
propose an inter procedural side effect analysis.
to ensure field sensitivity they extend deutsch s symbolic access path to a generalized access graph which models field accesses as a directed graph reappearing field accesses by the same statement correspond to cycles in the graph.
this ensures termination without requiring overapproximations like k limiting.
so far they only tested their analysis on a small benchmark.
they do not completely solve the state explosion problem shown in figure which is why we expect scalability issues on benchmarks that include similar program constructs.
in alias analyses it is also common to express the alias relation within a context free language cfl and therefore solve a reachability problem over that language.
fields are part of the language and recursive field accesses are grouped into arbitrary accesses using a wildcard leading to an overapproximation.b.
abstract summaries in chandra et al.
introduce a technique of generalization to produce summaries which are applicable to many data flow facts.
as the proposed tool snugglebug reasons about weakest preconditions along the control flow to reach a certain statement their data flow domain consists of conditions.
hence their generalization technique differs from ours.
the framework proposed by yorsh et al.
is a more theoretical approach on how to gain more concise summaries by composing the flow functions and their preconditions.
as examples they conduct a typestate analysis and constant propagation.
within their typestate analysis they reason about fields by using limiting within constant propagation they do not handle fields.
landi and ryder used in their alias analysis an approach for which they abstracted access paths as non visible inside callees.
using this technique the analysis results for the procedure become reusable across multiple calling contexts.
when evaluating returns they restore access paths according to the respective calling contexts.
our approach was independently developed but the abstraction at method start points is very similar to their approach.
yet the previous work lacks general support for arbitrary abstraction points which is why it still requires over approximations to limit the size of access paths and does not address the state explosion problem.
jensen et al.
represent in their abstraction the whole state of the heap.
as they point out this makes summaries nearly impossible to be reused.
to obtain more reusable summaries they therefore represent properties of the heap as unknown and recover properties as soon as they are accessed.
they call this concept lazy propagation as properties are propagated into callees on demand.
when applying summaries they replace unknown properties by the values available in the calling context.
the idea of abstracting at calls and recovering abstracted state is very similar to ours.
yet we are the first to show that if applying it at loops and return edges as well one can remove the need of over approximations through k limiting thus solving the state explosion problem.
vii.
c onclusion within this work we have presented access path abstraction our extension to the ifds framework to support fieldsensitivity within an arbitrary data flow analysis.
without much effort any analysis using ifds apa can easily yet precisely reason about fields.
as our experiments have shown the analysis will largely gain in terms of efficiency through the precise and abstract summaries ifds apa uses internally for the first time we managed to scale the tough flowtwist analysis on the whole java class library with field sensitivity so far even the field based approach did not scale.
finally introducing the more abstract summaries we also managed to abandon any need fork limiting within the access path model herein we see a huge profit for existing and future analyses.