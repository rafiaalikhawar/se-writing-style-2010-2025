how to break an api cost negotiation and community values in three software ecosystems christopher bogart 1christian k stner 1james herbsleb 1ferdian thung2 1carnegie mellon university usa2singapore management university singapore abstract change introduces con ict into software ecosystems breaking changes may ripple through the ecosystem and trigger rework for users of a package but often developers can invest additional e ort or accept opportunity costs to alleviate or delay downstream costs.
we performed a multiple case study of three software ecosystems with di erent tooling and philosophies toward change eclipse r cran and node.js npm to understand how developers make decisions about change and change related costs and what practices tooling and policies are used.
we found that all three ecosystems differ substantially in their practices and expectations toward change and that those di erences can be explained largely by di erent community values in each ecosystem.
our results illustrate that there is a large design space in how to build an ecosystem its policies and its supporting infrastructure and there is value in making community values and accepted tradeo s explicit and transparent in order to resolve con icts and negotiate change related costs.
ccs concepts software and its engineering !collaboration in software development keywords software ecosystems dependency management semantic versioning collaboration qualitative research .
introduction central planning in software engineering is increasingly giving way to decentralized development in software ecosystems in which developers build on a rich set of third party contributions from libraries to community documentation.
developers can reuse and build upon others contributions often aided by package management tools that support nding installing and publishing third party packages within the ecosystem.
development in such a decentralized environment can be challenging and can expose friction among loosely organized parties.
change introduces con ict into software ecosystems.
breaking changes in one package may ripple through the ecosystemand may trigger rework in many dependent packages.
avoiding changes however may result in stale software projects in dependencies with known defects and in growing incompatibility with other tools and standards.
the burden of change can be borne by di erent participants a package maintainer can decide how to make a change may invest additional e ort to make it easier to adopt the change or may decide to accept opportunity costs for not making a change.
developers depending on other packages may regularly monitor change in their dependencies and try to in uence their development or may rework their own packages.
core ecosystem developers might take on responsibility for vetting or testing packages in some way.
end users may encounter defects if changes are not made or may encounter installation di culties if packages in the repository have become incompatible.
how when and by whom changes are performed in an ecosystem with interdependent packages is subject to often implicit negotiation among diverse participants within the ecosystem.
each participant has their own priorities habits and rhythms often guided by community speci c values and policies or even enforced or encouraged by tools.
ecosystems di er in for example to what degree they require consistency among packages how they handle versioning and whether there are central gatekeepers.
policies and tools are in part designed explicitly but in part emerge from ad hoc decisions or from values shared by community members.
as a result community practices may assign burdens of work in ways that create unanticipated con icts or bottlenecks.
to understand current practices and how developers might design or redesign their ecosystems we have performed a case study of three open source software ecosystems with di erent philosophies toward change eclipse r cran and node.js npm .
we studied how developers plan manage and negotiate change within each ecosystem how change related costs are allocated and how developers are in uenced by and in uence change related expectations policies and tools in the ecosystem.
in each ecosystem we studied public policies and policy discussions and interviewed developers about their expectations communication and decision making regarding changes.
our research questions were therefore how do developers make decisions about whether and when to perform breaking changes and how do they mitigate or delay costs for other developers?
section how do developers react to and manage change in their dependencies?
section how do policies tooling and community values in uence decision making?
sections .
.
and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
we found that developers have a great deal of freedom when assigning or delaying costs of changes within an ecosystem.
at the same time expectations about how to handle change di er signi cantly among the three ecosystems and in uence cost bene t tradeo decisions among developers and users.
these di erences are rooted in community values and are reinforced through peer pressure policies and tooling as we will describe.
for example long term stability is a key value of the eclipse community this shifts costs to the developers making the change who may go to great length to accept opportunity costs and technical debt to avoid breaking client code.
in contrast the node.js npm community values ease for developers and has a technical infrastructure in which developers are less concerned about breaking changes as long as they are signaled clearly through version numbering.
we hypothesize that clarifying how policies serve core community values can facilitate decision making and focused deliberation over policies and values.
in summary we contribute a case study of three software ecosystems contrasting their change related practices values policies and tools.
our results have implications for understanding how stakeholders can in uence change negotiation and design or change software ecosystems.
.
state of the art in this paper we study breaking changes between packages in software ecosystems .
while all changes may incur costs to a downstream maintainer for vetting the updates we consider as breaking changes those changes that trigger rework for downstream users.
changes to a package s api are especially likely to break clients that rely on the api.
note that breaking changes include also changes regarding behavior and performance expectations not just changes to an interface s method signatures.
a software ecosystem is a set of actors functioning as a unit and interacting with a shared market for software and services together with the relationships among them ... frequently underpinned by a common technological platform or market .
software ecosystems enable supply chains on a shared technology platform often including an online repository and a local package management system.
from the perspective of an individual developer working on a package we distinguish upstream packages on which the package depends and downstream packages that use the package as illustrated in figure .
in practice breaking changes are common.
change in software systems has been studied measured and modeled intensively for many decades .
throughout a large body of research all studied real world systems evolved in unanticipated ways with rippling consequences across modules .
for example cossette et al.
have shown that java libraries frequently and seriously change over time .
decan et al.
found that about in every updates to a cran package was a backward incompatible change accounting for of the errors in released packages that depended on them .
complicated and changing dependencies are a pain point for many developers and have led to common expressions like dll hell and dependency hell .
although package managers are designed to structure the problem by making dependencies and versions explicit they themselves are complicated and cannot prevent the problem of rippling consequences of breaking changes.
preplanning to shield anticipated change behind a stable upstream downstreamplatform communityvalues tools policies practicesselect dependencies bug reports pull requests monitoringchanges notifications figure conceptual overview upstream vs.downstream and in uence of platform and community.
interface information hiding is a key design principle but cannot always protect against unanticipated change at scale in practice .
traditional centralized change control or change management approaches such as change control boards and roadmapping break down with the dynamic and distributed nature of software ecosystems.
tools for change impact analysis face challenges with the scale openness and distributed nature of software ecosystems.
change in software ecosystems can therefore be unexpected and disruptive but practices and tools have emerged for upstream developers to alert users and help them adapt.
developers use social media such as twitter blogs mailing lists and chat to directly communicate relevant recent or upcoming changes .
semantic versioning is a popular versioning strategy to signal the compatibility of a change through version numbers changes in the major version indicate breaking api changes whereas changes to minor and patch version are intended as backward compatible .
transparent environments such as github enable users to follow and comment on changes.
tools like yoohoo needfeed gemnasium and greenkeeper use different strategies to automatically lter what is relevant to a particular downstream project out of voluminous upstream activity streams.
once downstream users are aware of relevant changes they may collaborate directly with upstream developers to get help with changes .
tools have been proposed to make breaking changes less disruptive by making it easy to apply patches to downstream products .
among di erent developer communities di erent values can lead to di erent policies and practices.
for example murphy hill et al.
found that creativity and communication with non engineers is valued more by game developers than by application developers resulting in less testing and architecture focus in game development .
in the broader context of business platforms boudreau and hagiu show ways that the rules and mechanisms of business platforms enable di erent interactions among participants and a ect the platform s business value .
overall though little is known about how the policies and tools of a software ecosystem re ects or in uences the values of the developers in the ecosystem s domain.
tiwana et al.
describe the problem abstractly and call for more work on how governance architecture and other factors cause ecosystems to evolve .
izquierdo and cabot have begun mapping the design space for governance in open source communities for managing change and o mahony investigated the evolution of software ecosystem governance but neither address how a community s values and policies allocate cost among participants.
in this paper we investigate the decisions developers make with respect to breaking changes to see how the di erent values play out at the smallest scale and relate to ecosystem wide policies and values.
110table interviewees.
r2 and n4 were pairs of close collaborators identi ed as r2a r2b n4a and n4b.
code case field occupation e1 eclipse programming tools hci university e2 eclipse soft.
eng.
cs education university e3 eclipse soft.
eng.
research university e4 eclipse cs education university e5 eclipse software engineering retired e6 eclipse software engineering industry e7 eclipse eclipse infrastructure industry e8 eclipse software engineering industry e9 eclipse software engineering industry r1 cran soil science government r2a b cran statistics university r3 cran medical imaging university r4 cran genetics university r5 cran soil science university r6 cran web apps industry r7 cran data analysis industry r8 cran r infrastructure industry r9 cran r infrastructure industry r10 cran r infrastructure university n1 npm telephony industry n2 npm tools for api dev.
industry n3 npm web framework startup n4a b npm web framework startup n5 npm cognitive science university n6 npm database node infrastr.
startup n7 npm database node infrastr.
industry .
methodology we performed a multiple case study interviewing developers in the three ecosystems.
case studies are appropriate for investigating how and why questions about current phenomena .
we selected three contrasting cases to aim for theoretical replication a means to investigate the proposition that phenomena will di er across contrasting cases for predictable reasons.
eclipse and node.js npm serve as cases that contrast sharply in their approach to change eclipse has interfaces that have not changed for over a decade while node.js npm is a relatively new and fast moving platform.
we expected that eclipse s policies and tools might impose costs on developers in a way that encouraged them to act consistently with the ecosystem s values of stability.
the r cran ecosystem serves as a useful third theoretical replication since its policy favors compatibility among the latest versions of packages over eclipse s long term compatibility with past versions.
in addition cran acts as a gatekeeper for a centralized repository in contrast to npm s intentionally low hurdles for contributions.
we pursued two complementary recruitment strategies for our interviews.
first to nd individuals with recent relevant experiences we mined repositories to identify packages with multiple upstream and downstream dependencies and many changes in or .
our interviews focused on their personal practices and experiences negotiating upstream and downstream dependencies.
then to gain additional insights into the origins and impacts of ecosystem policies we recruited additional developers with some role current or historical in the development of the ecosystem s tools or policies adding interview questions about the ecosystem s history policy and values.
all interviewees were active software developers with multiple years of experience but their background ranged from university research to startupcompanies table gives an overview.
we conducted semistructured phone interviews that lasted minutes.
we generally followed an interview script shown in supplement a but tailored our questions toward the interviewees personal experiences.
with the interviewees consent we recorded all interviews.
we then transcribed them and used a grounded iterative approach to coding.
in our analysis we distinguish between decisions made as upstream and downstream developer as depicted in figure where an interviewee often held both roles.
we tentatively coded the transcripts looking for interesting themes then iteratively discussed rede ned and recoded.
once we settled on a set of codes we recoded all transcripts from scratch with at least two researchers coding each transcript.
to complement our interviews we explored policies public discussions meeting minutes and tools in each ecosystem.
several interviewees pointed us to additional documents and tools.
validity check.
to validate our ndings we adapted dagenais and robillard s methodology to check t and applicability as de ned by corbin and strauss .
we presented interviewees with both a summary and a full draft of sections along with questions prompting them to look for correctness and areas of agreement or disagreement i.e.
t and any insights gained from reading about experiences of other developers and platforms i.e.
applicability .
six of our interviewees responded with comments on the results all six indicated general agreement e.g.
it brings a structure and coherence to issues that i was loosely aware of but that are too rarely the centre of focus in my everyday work.
some corrected small factual errors e.g.
the number of cran packages had passed since we initially wrote section and a few found ways to sharpen our analysis e.g.
r7 noted that cran s policy to contact downstream developers does not apply to the majority of users outside cran .
we incorporated their feedback when it was consistent with a recheck of our data and added clari cations otherwise.
threats to validity.
our study exhibits the threats to validity that are typical and expected of qualitative case studies.
the three cases may be atypical and so one needs to be careful when generalizing beyond the three cases.
our results may be a ected by a selection bias in that developers who did not want to be interviewed may have had di erent experiences.
finally the di erences we found among cases may be confounded with the reasons we selected them such as their popularity or the availability of data about them.
.
case overview to understand the identi ed di erent practices and policies it is important to understand the purpose and history of each ecosystem.
in the following we provide a brief description of all three ecosystems and their values informed by both public documentation and our interviews.
.
eclipse the eclipse foundation publishes more than open source projects.
its agship project is the eclipse ide created in .
the ide is built from the ground up around a plugin architecture which can be used as a general purpose gui platform and in which plugins can depend on and extend other plugins.
projects can apply to join the eclipse foundation through an incubation process in which their project and practices come under the eclipse management umbrella.
111it is also common practice to develop both commercial and open source packages separately from the foundation and publish them in a common format on a third party server.
in addition the eclipse marketplace is a popular registry listing over external eclipse packages that can be installed from third party servers through a gui dialog.
the eclipse foundation coordinates a simultaneous release of the eclipse ide once a year and as of three update releases for new features in between.
many external developers align with those dates as well.
the eclipse foundation is backed by corporate members such as ibm sap and oracle.
its policies are biased toward backward compatibility packages e.g.
commercial business solutions developed years ago will often still work in a current eclipse revision without modi cation.
a core value of the eclipse community is backward compatibility.
this value is evident in many policies such as api prime directive when evolving the component api from release to release do not break existing clients .
although not entirely uncontroversial as we will explain this value was con rmed by many interviewees.
.
r cran the comprehensive r archive network cran has managed and distributed packages written in the r language since .
r is an interpreted language designed for statistics.
the r language itself is updated approximately every six months but new development snapshots are available daily.
r has multiple repositories with di erent policies and expectations including bioconductor and r forge we focus on cran the largest one.
cran formally exists under the umbrella of the r foundation but sets its own policies.
cran contains over packages.
of these are either required or recommended and are bundled in binary installs.
about more are cataloged as useful for different specializations such as nance and medical imaging.
distributing r software as a cran package gives it high visibility since installation from cran is automated in the command line version of r and the popular ide rstudio .
r and cran are used by many developers without a formal computer science or programming background.
cran pursues snapshot consistency in which the newest version of every package should be compatible with the newest version of every other package in the repository.
older versions are archived available in the repository but harder to install.
when a new package version is submitted to cran it is evaluated by the cran team s partly automated process.
the package must pass its own tests and must not break the tests of any downstream packages in cran that depend on it without rst alerting those package s authors so they can make corresponding xes.
package owners need to react to changes in the platform or in upstream packages within a few weeks otherwise their package may be archived.
a core value of the r cran community is to make it easy for end users to install and update packages.
although not explicitly represented in policy documents this value was apparent from many interviews for example r10 said cran primarily has the academic users in mind who want timely access to current research.
.
node.js npm node.js is a runtime environment for server side javascript applications released initially in and npm is its defaultpackage manager.
npm provides tools for managing packages of javascript code and an online registry for those packages and their revisions.
the npm repository contains over packages with rapid growth rates.
the node.js npm platform has the somewhat unusual characteristic that multiple revisions of a package can coexist within the same project.
that is a user can use two packages that each require a di erent revision of a third package.
in that case npm will install both revisions in distinct places and each package will use a di erent implementation.
a core value of the node.js npm community is to make it easy and fast for developers to publish and use packages.
in addition the community is open to rapid change.
ease for developers was one of the principles motivating the designer of npm .
therefore npm explicitly does not act as a gatekeeper it does not have review or testing requirements in fact the npm repository contains a large number of test or stub packages.
the focus on convenience for developers instead of end users was apparent in our interviews.
.
planning changes we rst discuss negotiating change from the perspective of a developer planning to perform changes that may a ect downstream users.
while we observed similar forces and concerns regarding change across all three ecosystems we observed differences in how the community values a ect the ways package maintainers mitigate or delay costs for downstream users.
.
breaking changes reasons and opportunity costs although breaking changes to apis are costly to downstream users in terms of interruptions and rework our interviewees gave many reasons why they had to perform such changes there are corresponding opportunity costs that arise when deciding notto perform the change such as the cost of maintaining obsolete code working around known bugs or postponing desirable new features.
obvious and expected reasons for breaking changes included requirements and context changes and rippling e ects from upstream changes.
beyond that we found surprisingly frequent mentions of stylistic and performance reasons as well as di cult bug xes.
technical debt.
surprisingly many interviewees e3 e9 r1 r3 r4 r5 r6 r7 r8 n1 n7 mentioned concerns about technical debt rather than bugs new features or rippling upstream changes as the trigger for breaking changes.
by technical debt we refer to code that is functionally su cient but has outstanding stylistic issues developers want to x such as poorly chosen object models or method names lack of extensibility or maintainability or little used or longdeprecated methods.
we conjecture that the reason these changes came up so often in discussion was because our interviewees had thought about them in depth.
technical debt often arises from the tension between tools and practices that encourage developers to preserve backward compatibility e.g.
eclipse s prime directive versus general pressure for evolution and improvement.
developers often postpone breaking changes until the technical debt becomes intolerable for example e3 mentioned as the reason for planning to nally remove some deprecated code what we did there was to provide old methods as deprecated.
but that gets quite messy.
at one point almost half of the methods were deprecated.
e9 similarly told 112us about an upcoming long postponed major version change since we don t do it often probably once every ve years let s take advantage of that opportunity to do some of the things that would be good that we couldn t do before.
old interfaces can come to seem old fashioned and unattractive in a swiftly changing community.
several interviewees said they made breaking changes to harmonize syntax r1 or improve weird or bad names r3 r4 in their interfaces.
several interviewees e1 e5 e6 r6 felt that having to preserve old interfaces over long periods caused opportunity costs since it hindered attracting new developers lured by cutting edge things.
e6 discussed this at some length if you have hip things then you get people who create new apis on top of that in order to create the next graphical editing framework or to build more e cient text editors.
these things don t happen on the eclipse platform anymore.
e ciency.
several interviewees e6 r1 r4 n1 reported cases in which e ciency improvements required breaking changes.
for example n1 s package o ered an api for requesting paged data that the server could not provide e ciently they deprecated and eventually removed that function rather than spending money on hardware.
bugs.
bug xes were another reason for breaking changes e4 e7 n7 r9 .
bug xes can break downstream packages if those packages depend on the actual broken behavior instead of the intended behavior.
a lack of well de ned contracts in most implementations makes assigning blame and responsibilities di cult in practice.
as e5 told us if someone likes the broken semantics then they re not going to like the xed semantics.
thus even xing an obvious mistake in code under the control of a single person can require signi cant coordination among many people.
throughout our interviews we heard many examples of how bug xes e ectively broke downstream packages and the di culty of knowing in advance which xes would cause such problems.
for example r7 told us about reimplementing a standard string processing function and nding that it broke the code of some downstream users that depended on bugs that his tests had not caught.
r9 commented on the opportunity cost of not xing a bug in deference to downstream users workarounds for it if the is implemented on the workaround for your bug and then your x actually breaks the workaround then you sort of have to have a fallback... it gets nasty.
.
dividing and delaying change costs our previous discussion already hinted that there is exibility regarding who bears the costs of a breaking change.
for instance a package s developer can decide between making a breaking change pushing costs for rework to maintainers of downstream packages or notmaking the change accepting opportunity costs such as technical debt.
even when deciding to make the change the developer faces strategic choices about whether to invest more e ort when making the change to reduce the interruption and rework costs for downstream users as well as to a ect timing of when those costs are paid.
for example by documenting how to upgrade the developer invests more e ort to reduce e ort for downstream maintainers.
di erent developers and di erent communities have di erent attitudes toward whoshould pay the costs of a change and when as we will show.
.
.
awareness of costs to downstream users most interviewees stated that they avoid breaking changes that would a ect downstream users when they could avoid it.
reasons included looking out for their users best interests and knowing that costs to a ected users would come back to them as users ask for help adapting to the change ask for the change to be reverted or seek alternative packages.
two interviewees e1 and r4 speci cally mentioned concern for downstream users scienti c research r4 we re improving the method but results might change so that s also worrying it makes it hard to do reproducible research .
interviewees concern for impacts on users was tied to the size and visibility of the user base and the perceived importance and appropriateness of their usage.
many interviewees across all ecosystems e4 e5 e6 r1 r4 r6 r7 r9 n7 were aware of their users and were concerned specifically about the number of users a ected and the quantity of complaints that a change would imply e.g.
r9 sometimes you want to rename a function or class ... however because this would break scripts or packages assuming the old name you often end up supporting both names.
some interviewees e1 r4 r8 noted that their sensitivity toward avoiding breaking changes grew with experience and with a growing user base as they learned from feedback received about earlier breaking changes.
only a few developers were not particularly worried about breaking changes.
some e6 n1 n5 had strong ties to their users and felt they could help them individually n5 we try to avoid breaking their code but it s easy to update their code .
interviewee n6 expressed an out of sight out of mind attitude unfortunately if someone su ers and then silently does not know how to reach me or contact me or something yeah that s bad but that su ering person is sort of in the woods that falls and doesn t make a sound.
finally there was some debate about bug xing changes see above .
some developers aimed to support downstream users who relied on incorrect behavior while others were less concerned when they considered usage as inappropriate r9 after upgrading the parser some people complained that their script was no longer working.
but the problem was that their syntax was invalid to begin with.
it s obviously their fault.
.
.
techniques to mitigate or delay costs despite a strong general preference for avoiding breaking changes there are many cases where the opportunity costs of not making a change are too high.
our interviewees identi ed several di erent strategies for how they as package maintainers routinely invest e ort to reduce or delay the impact from their changes for downstream users.
maintaining old interfaces.
across all ecosystems preserving the old interface alongside a new one is a very common approach to mitigate an immediate impact of a change on downstream users.
while speci cs depend on the language and tools common strategies to avoid breaking downstream implementations include documenting methods as deprecated and providing default implementations for new extension points or parameters.
in these strategies the package developer invests additional e ort now to preserve backward compatibility accepting technical debt in the form of extra code to maintain for some time in exchange for preventing an immediate downstream impact of the change.
the developer may at some later time clean up the code a ecting down113stream users that have not updated in the meantime .
similarly many interviewees e2 e3 e5 e8 r1 r6 r9 n1 n7 told us about various techniques to perform changes without breaking binary compatibility.
they prevent rework costs for existing users by accepting more complicated implementations and harder maintenance in the changed package while possibly also creating costs for new downstream users who have to deal with more complicated mechanisms.
parallel releases.
several developers e5 e6 r1 r2 r4 r7 r8 reported strategies to maintain multiple parallel releases such that downstream developers can incorporate minor nonbreaking changes e.g.
bug xes without having to adopt major revisions.
node.js npm o ers speci c mechanisms to support parallel releases with di erent version numbers it is a common practice to provide security patches also for older releases.
in contrast cran only supports sequential version numbering causing some developers to fork their own packages e.g.
reshape to reshape2 .
in each case developers invest signi cant additional e ort in maintaining old releases to reduce the immediate impact on downstream users.
a variant of this strategy is to maintain separate interfaces for di erent user groups with di erent stability commitments within the same package see the fa cade pattern .
for example interviewee e5 provided in parallel both a detailed and frequently changing api for expert users and a simpler and stable api that insulated less sophisticated users from most changes.
similarly interviewee r1 has split packages into smaller packages with the intention that each user could depend only on parts relevant to them and would be exposed to less change.
in both cases the developer accepts the higher design and maintenance costs of multiple apis for reduced impact on speci c groups of users with distinct needs.
release planning.
some individual developers and some communities are considerate of downstream users when planning when to release changes.
some developers report deliberately delaying changes to batch multiple changes together.
for example r1 keeps versions of his package with a quicklychanging api in a separate repository and updates cran less frequently when he wants to release a version to a broader audience.
while in r cran and node.js npm packages are usually released individually large parts of the eclipse community coordinate around synchronized yearly releases a strategy also common in other package systems as debian andbioconductor .
delaying releases may incur coordination overhead and opportunity costs in slowing down development for the changer but reduces the frequency though not necessarily the severity with which downstream users are exposed to changes and gives downstream users a planning horizon.
communication with users.
finally developers communicate in various ways with users to reduce the impact of a breaking change.
several interviewees e6 r4 r7 r8 r9 n6 n7 made early announcements to create awareness and receive feedback.
r7 explained that two weeks or a month before the actual release i do sort of a pre release announcement on twitter tell people to use the readme.
he told us during the validation phase that he has since written a script to email all downstream maintainers before a release.
another reason for communicating with downstream users was to help them deal with the aftermath of change.
in the simplest case a developer could invest e ort in documenting how to upgrade.
several interviewees e7 r2 r3 r7 r9 n1 n4 n5 were aware of their users and reached out tothem individually for example n1 contacted users using an old api to help them migrate and n5 had most users present on site and could therefore help them migrate their code.
e7 went so far as to create individual patches for downstream packages to get them to adopt a new interface and move away from an old deprecated one.
in all cases package maintainers invest e ort to reduce costs for downstream users.
.
the influence of community values the previously discussed techniques are mechanisms that developers can use for tweaking who pays for the costs of a change and when.
individual developers often adopt patterns and in fact some interviewees e1 r3 r4 r5 r8 n6 described gradual adoption of more formal processes over time as they learned their value through experience.
at the same time we could clearly observe that attitudes and practices di er signi cantly among the three ecosystems and are heavily in uenced by ecosystem values tools and policies.
eclipse.
developers are willing to accept high costs and opportunity costs to further eclipse s value of backward compatibility especially for core packages.
the community has developed educational material explaining java s binary compatibility and giving recommendations for backward compatible api design .
with api tools the community has developed sophisticated tool support to detect even subtle breaking changes and enforce change related policies such as adding since tags to api documentation.
breaking changes in core packages are in fact very rare .
even though they arguably make the platform harder to learn and maintain eclipse developers have identi ed and documented several workarounds how to extend an interface while maintaining old interfaces such as creating additional interfaces to avoid modifying existing ones e.g.
idetailpane2 idetailpane3 ihandler2 and runtime weaving.
deprecating interfaces and methods is common but actually removing them is not for example like many other methods org.eclipse.core.runtime.plugin.startup is still included despite being deprecated for over years.
e6 noted that this backward compatibility prevents modernizing apis such as replacing arrays with collections.
the eclipse community invests signi cant e ort into release planning at the cost of some resulting friction as reported by multiple interviewees.
the required coordination is invested toward ensuring stability and smooth transitions at few plannable times for downstream users.
documenting compatibility issues with prior releases is a mandatory step of that process.
in contrast maintenance releases for old major revisions are not common presumably because with backward compatibility users can simply be told to update to the latest release.
r cran.
as the r cran community values making it easy for users to get a consistent and up to date installation developers invest signi cant e ort to achieve consistency.
there is no policy against cran packages making changes that a ect the larger body of code outside of cran.
however when changes a ect other cran packages upstream developers are asked to bear the signi cant extra cost of reaching out to and coordinating with maintainers of a ected packages termed forward impact management by de souza and redmiles .
downstream maintainers then may also bear the cost of pressure to update their packages rst before the upstream developer can make a breaking change to 114ensure that all cran packages are consistent.
this culture leads to constant synchronization and a greater likelihood to reach out to downstream developers to mitigate change costs than observed in the other ecosystems.
synchronization is thus continuous but more decentralized and localized than with eclipse s simultaneous releases.
many interviewees e6 n1 r4 r7 r8 told us that they reach out individually to downstream maintainers and users for this reason.
among our interviewees developers of specialized r packages target small and close communities and tend to know their users.
consistency is enforced by manual and automated checks throughout the ecosystem on each package update.
the change management process is collaborative but also demanding of a maintainers time r7 said the timeline to adapt to an upstream change might be a relatively short timeline of two weeks or a month.
and that s di cult for me to deal with because i try to sort of focus one project for a couple weeks at a time just so i can remain productive .
the platform is not conducive to multiple parallel releases on cran a package revision must have a higher version number than the one it supersedes so an old major version cannot be updated policies also discourage forking a project and submitting it with a separate name.
there is no central release planning because it is perceived to slow down access to cutting edge research.
overall we observed much more communication and coordination with downstream users about individual changes than in eclipse but also more exibility with regard to performing breaking changes.
node.js npm.
the node.js npm community values ease for upstream developers and the possibility to move fast.
it is much less demanding of developers making a breaking change in carrying the costs of that change.
many interviewees focused strongly on signaling change through semantic versioning .
that is developers would be free to make breaking changes as long as they clearly indicate their intentions.
because the technical platform allows downstream developers to still easily use the old version without fearing version inconsistencies breaking changes do not cause rippling e ects or immediate costs for downstream users.
while they still avoid breaking changes and employ various strategies to maintain old interfaces in our interviews node.js npm developers were more willing than developers of other platforms to perform breaking changes in the name of progress and in ghting technical debt including experimenting with apis until they are right.
as mitigation strategy maintenance releases for old versions are common made easy by the platform and associated tools.
analyzing the npm repository we found that of the most starred packages did this at least once.
there is no central release planning as this would be incompatible with the values of simplifying developers lives and moving fast.
key section insights there are many reasons for breaking changes including less obvious ones like technical debt and performance.
it is very di cult and potentially expensive to keep code stable.
still developers generally prefer stability and are aware of the costs their changes cause for others.
there are many means to invest more e ort in order to mitigate and delay costs for downstream users.
community values in uence how costs are shifted and explain most di erences in techniques and practices that we observed among the ecosystems in practice.
.
coping with upstream change just as package developers have some exibility in planning changes that may a ect downstream users developers have exibilities regarding whether when and how to react to upstream change again in uenced by values policies and technologies.
having to monitor and react to upstream change can be a signi cant burden on developers e.g.
mismatch between schedules has been shown to be a barrier to collaboration .
the urgency of reacting to change can depend signi cantly on the development context and platform mechanisms.
when discussing how frequently they react to upstream change our interviewees described a spectrum ranging from never updating e.g.
e3 to closely monitoring all changes in upstream packages n1 n2 r9 .
some interviewees explicitly ignored certain upstream changes n3 n7 others upgraded dependencies only at the time of their own releases n3 n5 or during deliberate house cleaning sweeps n7 e2 .
even when the platform does not require updates developers often prefer to update their dependencies to incorporate new xes and features e3 n2 or to avoid accumulating technical debt r6 n5 .
but they avoid updating when updates require too much e ort e.g.
by causing complicated con icts n5 e3 or cause too much disruption downstream n7 .
.
monitoring change when developers have to or want to react in a timely fashion to upstream changes they need to monitor the upstream projects in some way.
the platform itself e.g.
node.js r core and the cran infrastructure is often an additional source of changes that developers need to keep up with.
in our interviews we discovered many di erent strategies for monitoring including technical and social strategies.
their strategies varied along with the urgency of their needs from active monitoring of upstream activity to general social awareness of upstream activities to a purely reactive stance where developers wait for some kind of noti cations.
burden of active monitoring.
only a few interviewees e5 r9 n1 n4 reported actively monitoring upstream changes by regularly looking at all changes of their upstream dependencies.
r9 n1 and n2 said they used github s noti cation feed with some regularity.
several interviewees indicated that such raw noti cation feeds in their current form are a signi cant burden with a low signal to noise ratio as stated for example by r7 the quantity of noti cations i get on github already is to the point of overwhelming.
so i don t even mostly read them unless i m actually working on the project at that moment.
he later told us that after our interview he tried scaling back to watching just the projects he is actively working on.
only one interviewee r9 did not feel overwhelmed saying that occasional casual skimming of github feeds was useful way to get a casual overview of activity.
in several cases developers monitored upstream changes not as outsiders following a stream of data but as active participants in those projects collaborating to in uence them toward their own needs e5 n4 n7 r6 or providing direct contributions to those packages e7 e9 r7 .
for example in describing the challenge of getting upstream projects to prioritize changes that he needed an eclipse developer said i touch everything that i care about because it s really hard to convince other people to do things that i need to do.
i nd it much easier to just learn all the projects and when i need 115something to do it myself.
this aligns with de souza and redmiles observation of exchange of personnel as a common strategy for cooperation among dependent projects .
others like e5 actively compiled and tested their project with development versions of upstream dependencies emphasizing the importance of giving timely reactions if you report it within a week there s a better chance the developer might remember what they did which provides a good chance that they can revert their change before they hit their milestone.
social awareness.
many interviewees tried to maintain a broad awareness of change through various social means.
the most frequently mentioned mechanism especially in the node.js community was twitter e9 r7 r9 n2 n3 n4a n4b n6 n7 .
for example n4a commented the people who write the actual software are fairly well connected on twitter like water cooler type of thing.
so we tend to know what s going on elsewhere.
in each ecosystem several interviewees e5 r9 n4 n6 mentioned the importance of face to face interactions at conferences for awareness about important changes in the ecosystem.
other mentioned social mechanisms to learn about change were personal networks r6 r8 blogs e1 r4 r7 r8 n4 n7 and curated mailing lists n1 .
though these mechanisms are rarely speci c to individual packages several developers mentioned them as their main monitoring strategies.
reactive monitoring.
although our research questions led us to probe interviewees about the aforementioned active and social monitoring practices in fact most interviewed developers adopted a reactive strategy for most of their dependencies.
they wait to hear about problems from others in advance or after things had broken upstream developers contacting them about breaking changes failing tests after dependency updates or platform maintainers warning of changes that would a ect them.
there are also tools that enable this reactive stance that generate targeted noti cations on certain kinds of changes.
the speci c tools di er among the platforms and support di erent practices or policies.
policies and common practices e.g.
testing practices in the platform strongly in turn a ect the reliability of a reactive strategy and corresponding tools.
some eclipse and node.js npm developers use continuous integration to detect compile time issues caused by breaking changes in upstream packages early.
for node.js npm some developers use the tools gemnasium and greenkeeper to get noti cations about new releases of upstream packages.
gemnasium alerts developers of package releases that x known vulnerabilities whereas greenkeeper submits pull requests to automate a continuous integration run against the new release.
in either case developers can react to notications by email or pull requests.
cran is interesting because by asking upstream developers to notify their users it encourages downstream developers across the ecosystem to take a reactive stance in contrast to eclipse and node.js npm where individual downstream developers need to employ optional monitoring tools .
some interviewees like r7 defended the practice of waiting to be told about breaking changes as a principled attentionpreserving choice consistent with ecosystem norms others however like r2 were apologetic about being reactive i guess i ll sound crass about this and say it.
for things like that i would wait to hear from cran when something broke.
because i don t think i can keep up with all of it.
cranenforces this policy with manual and automated checking on each package update running the package s tests and the test of all downstream packages in the repository as well as some static checks.
the cran team may then warn an a ected downstream developer of an upcoming change by email.
.
reducing the exposure to change many developers have developed strategies to reduce their exposure to change from upstream modules and thus reduce their monitoring and rework e orts.
the degree to which developers adopt such mitigation strategies again depends on the technology policies and values as we will discuss.
limiting dependencies.
most of the cran and eclipse interviewees that we asked r1 r2 r3 r4 r6 r7 e1 e2 e4 e5 e9 felt that it was better to have fewer dependencies.
reasons for limiting dependencies included limiting one s exposure to upstream changes and not burdening one s users with a lot of modules to install and potential version con icts dependency hell .
interviewee e5 represents a common view i only depend on things that are really worthwhile.
because basically everything that you depend on is going to give you pain every so often.
and that s inevitable.
apart from removing no longer needed dependencies tooling provided in eclipse some developers took more aggressive actions to avoid dependencies including copying r4 or recreating r1 r6 r7 n6 the functionality of another package.
in contrast due to node.js npm s ability to use old versions and eclipse s stability some developers e3 n1 n5 specifically said that they didn t see dependencies as a burden.
selecting appropriate dependencies.
when limiting themselves to appropriate dependencies interviewees mentioned a variety of di erent signals they looked for these fell into several categories trust of developers several interviewees e4 r1 r5 r7 n4 n6 based decisions on personal trust of package maintainers.
criteria included being a large organization e4 having a reputation for high quality code r6 n6 and being consistent with maintenance r6 .
one interviewee r7 deliberately sent bug reports to a package to test whether the developer would be responsive before depending on it.
activity level some interviewees e4 n6 n2 r1 r6 considered the activity level of the community of developers for example distinguishing a real ongoing project from an abandoned research prototype.
both high and low activity levels can be a positive indicator depending on the state of the project as stated by n2 ones with activity are mostly better maintained they have lots of people contributing like express.
it s likely the community will have eyes on the ball consider backward compatibility rami cations .
ones with little activity are small projects that don t change often so change isn t an issue either.
size and identity of user base some considered how large the user base was using signals as daily download counts e2 n3 n5 whether projects of trusted developers use it n6 or as e2 said how i perceive other software projects are using it.
project history some interviewees assumed that past stable behavior of a package would predict future stability r1 r4 r6 e2 .
signals included their own experience with the package n4 e5 its status as part 116of the platform s core set of packages e4 or its visible version history such as lack of recent updates and a version number above .
e3 n1 n4 .
project artifacts finally some developers considered signals from the project artifacts including coding style r1 r6 documentation r1 good maintenance n6 perceived ease of adoption r1 code size e2 n4 n7 and con icts with other dependencies n5 .
encapsulating from change.
interestingly there was almost no mention of traditional encapsulation strategies to isolate the impact of changes to upstream modules contra to our expectations and typical software engineering teaching .
only n6 mentioned developing an abstraction layer between his package and an upstream dependency.
.
platform values and developer values because policies tools and practices support di erent values in each ecosystem they impose di erent costs on developers depending on whether their attitude towards some particular dependency aligned or con icted with the community s broader values.
in some situations developers will treat a dependency as a xed resource to draw functionality from also termed api as contract but in other situations they treat the interface as open to negotiation and change also api as communication mechanism .
eclipse s value on backward compatibility and predictable release planning is convenient for developers and corporate stakeholders who wish to rely on the released core platform code as as xed resources.
stability ensures that most developers relying on the platform packages do not need to monitor upstream changes reacting at most to the yearly releases.
signals about whether to trust an upstream package are primarily social in the sense they can trust the packages that are part of the core supported by corporations known to be invested in the stability of the platform.
developers working within more volatile parts of the eclipse ecosystem such as using code outside the stable core or indevelopment features of the core have a greater need for monitoring and may be exposed to more change sometimes encountering friction associated with that.
e6 told us that there is a very di erent understanding of how important compatibility is and what it means if you start from the platform and then to the outer circles of eclipse.
e5 talked about recompiling upstream code often in order to report bugs to them within a week.
thus although eclipse deeply values stability there is necessarily a sphere of activity with active collaboration and change where that value is appropriately set aside.
cran s emphasis on consistency and timely access to research seems to encourage the collaborative rather than resource view of dependencies.
cran s snapshot consistency approach creates some urgency in that maintainers need to react to breaking upstream changes quickly typically a few weeks .
this causes some apparent friction with researchers who might otherwise wish to publish their software and move on to other things.
many of the interviewees limited their dependencies sometimes quite aggressively by replicating code and reacting to noti cations about change rather than actively following a community of upstream developers.
however an active and socially connected subset of developers r7 r10 seemed to welcome collaboration.
although r7 advocated reacting to upstream changes rather than trying to anticipate them r7 r8 and r9 emphasized twitter and conferences to maintain an upstream awareness.node.js npm s emphasis on convenience for developers has led to infrastructure that decouples upstream and downstream developers from having to collaborate since the downstream can depend on old versions of the upstream for as long as they like.
that means there is usually no urgency to monitor upstream changes except for patching security vulnerabilities.
developers do nonetheless often choose to take a collaborative approach to development using tools like continuous integration and greenkeeper to force themselves to stay up to date despite the platform s permissiveness.
key section insights monitoring change is important for some users but burdensome due to too much noise.
social mechanisms for monitoring are frequently used in practice.
investments in tooling and practices in all communities enable reactive monitoring.
platform design decisions can lead to strong aversions against dependencies leading to e ciency losses.
lots of signals for stability of packages are used to decide on which packages to depend.
the opportunities and strategies to avoid costs from upstream changes di er signi cantly based on platform design.
platforms tend to either support collaboration or support a view of xed resources but rarely both thus not tting all users.
.
choices politics and conflict as we have shown choices about practices policies and tools have a major impact on allocating burdens among di erent groups of developers and users.
while technical considerations certainly play a role choices about allocating costs and bene ts are fundamentally political decisions.
in our three ecosystems each community places a particular constituency in a favored position.
the design of npm was driven by one individual developer who set goals and made technology and policy decisions to primarily serve developers in that ecosystem impetus for change seems to come from peer advocacy and tool building among developers.
in contrast cran was designed and adjusted over a long period by a team of volunteers who were primarily concerned about end users.
as gatekeepers to cran this group has a lot of power to enforce policies such as the discussed mandate to react to upstream change in a timely fashion that get developers to take on costs that end users would otherwise bear.
this power is signi cant due to cran s popularity its importance for academic reputation and its integration with major development tools.
in contrast the policies of the eclipse ecosystem are clearly driven in part by business needs of corporate sponsors of the project who provide signi cant funding and exert signi cant power by sponsoring development e ort.
as policies are put into practice we observed several ways in which they were adjusted or augmented to accommodate the di culties they encountered including carving out exceptions tools to help enforce policies and tools to reduce the cost of complying.
nevertheless not all policies translated fully into practices and some degree of con ict persisted.
policy vs. practice.
policies and practices are not always aligned.
practice may diverge from policy when policies are perceived to be misaligned with the community values and the platform mechanisms.
for example there is a tension in eclipse between the policy and practice of semantic versioning.
eclipse has a long standing versioning policy similar to semantic versioning and the platform s stability is re ected in the fact that many packages have not changed their major 117version number in over years.
however even for the few cases of breaking changes that are clearly documented in the release notes such as removing deprecated functions major versions are often not increased because as e8 told us updating a major version number can ripple version updates to downstream packages and can entail signi cant work for the downstream projects.
the opposite dynamic is evident in cran the o cial policy only requires that version numbers increase with each submission but a permissive form of semantic versioning is used and recommended by many developers .
tools sometimes are used to help enforce policies or to make it easier to comply.
cran enforces many policies through automated checks whenever a package is updated.
tools like greenkeeper in node.js npm help to identify breaking changes in upstream packages especially those that are not correctly signaled by semantic versioning.
tools can also be used to reduce the costs of compliance.
for example in eclipse introduced api tools that provides sophisticated compatibility checks regarding whether a change is breaking a previously released api in a way consistent with the version numbering they are proposing.
since then the tool has become ubiquitous enough that e5 claimed it was notable for a package to not use this tool.
the tool reduces the chance of accidental breaking changes that violate eclipse s value of stability or its versioning policies.
value tensions and evolution.
ecosystem policies may not resolve all tensions between competing goals and we found evidence of con icts in all three ecosystems.
for example in eclipse several interviewees complained about stagnant development and the political nature of making changes which can drive away developers and users.
one eclipse developer complained that you have to be very patient and know who to talk with and whatnot you really have to know how to play that game in order to get your patches accepted and i think it s very intimidating for some new people to come on.
in r cran the goal of timely access to current research conicts with many researchers goal to ensure reproducibility of their studies .
similarly in node.js npm the rapid rate of changes and automatic integration of patches can raise concerns about reproducibility in commercial deployments.
in many cases the community then builds tools to work around some of the issues such as providing tools that take a speci c snapshot of an installation including all transitive package dependencies e.g.
npm shrinkwrap or r cran s packrat .
such value con icts led to policy evolution in all three ecosystems.
many changes especially in node.js npm start through grassroots activities and are again often supported by tool building.
for example facilities exploiting semantic versioning were built into npm from the beginning but semantic versioning was only later accepted broadly.
as acceptance and conformance increased the community started ling bug reports against changes that did not comply with semantic versioning rules1and started developing tools to enforce or exploit semantic versioning such as semantic release a package that will automatically increase the version number depending on detected changes.
also npm itself changed and now by default automatically updates both minor and patch releases instead of only patch releases since both should be 1for example n4a and e8 talked about reporting incorrect version numbers choices as bugs to upstream authors in order to improve the reliability of these numbers in the community.backward compatible.
in the extreme value con ict can lead to schism.
in the node.js community at one point the dissatisfaction with change governance of the platform not necessarily the ecosystem led to a community revolt in which node.js was forked into io.js for about a year when many of the platform s core developers felt that node.js was too slow in updating the javascript engine and slow in transitioning to a promised open governance model.
the two projects were remerged after the project s owners relented demonstrating that node.js community exercises de facto power.
key section insights policies are often explicitly designed for certain values but they also evolve over time.
investment in tools can enforce policies or reduce costs of compliance.
peer pressure is common to enforce policies that align with values.
con icts exists as di erent users and stakeholders have di erent values.
tooling sometimes help to address isolated needs.
.
concluding remarks we found that the three ecosystems di er signi cantly in their practices policies and tools.
these di erences align well with the community values of stability timely access to current research and ease of contribution.
our results indicate that there is a large design space in how to build an ecosystem and how to allocate costs among the various stakeholders which can be shaped by policies and supporting tools.
yet we believe that most developers are not aware of the design space and potential alternatives.
only few of our interviewees could compare multiple ecosystems or were aware of practices and tools in other ecosystems.
in our validation phase several interviewees reported value in understanding other ecosystems.
we argue that community values play an essential role in shaping a software ecosystem yet they can be somewhat di cult to distill from the outside we had a general notion but were not aware of the actual values going into the study .
making community values and the involved tradeo s explicit and transparent can help to ensure that all stakeholders understand the tradeo s of decisions made by the platform and the accepted consequences such as higher costs for certain stakeholders or reduced attractiveness to newcomers.
such political transparency can help to understand and resolve con icts and to guide design discussions.
how to break an api in eclipse you don t. in r cran you reach out to a ected downstream developers.
in node.js npm you increase the major version number.
.