clone refactoring with lambda expressions nikolaos tsantalis davood mazinanian shahriar rostami computer science and software engineering concordia university montreal canada tsantalis d mazina s rostam encs.concordia.ca abstract lambda expressions have been introduced in java to support functional programming and enable behavior parameterization by passing functions as parameters to methods.
the majority of software clones duplicated code are known to have behavioral differences i.e.
type and type clones .
however to the best of our knowledge there is no previous work to investigate the utility of lambda expressions for parameterizing such behavioral differences in clones.
in this paper we propose a technique that examines the applicability of lambda expressions for the refactoring of clones with behavioral differences.
moreover we empirically investigate the applicability and characteristics of the lambda expressions introduced to refactor a large dataset of clones.
our findings show that lambda expressions enable the refactoring of a significant portion of clones that could not be refactored by any other means.
keywords refactoring code duplication lambda expressions i. introduction the refactoring of software clones can help to reduce the size of the code base avoid software defects due to inconsistent clone updates and minimize the negative effect of duplicated code on maintenance effort and cost .
a recent study involving github contributors has shown that they are seriously concerned about code duplication .
among the top reasons they applied extract method refactorings was to reuse existing code i.e.
avoid duplication and remove already existing duplication .
however clone refactoring is not trivial because the majority of clones are not identical code fragments i.e.
developers tend to modify the copied code fragments to adjust them to another context or to different requirements.
as a matter of fact there are more copy pasted fragments in which minor to significant editing activities took place than identical clones in repositories .
motivation the current state of the art clone refactoring techniques merge clones by introducing parameters in the extracted method for the expressions being different among the merged clone fragments .
after the refactoring the parameterized expressions are passed as arguments to the extracted method calls and thus these expressions are evaluated before the execution of the extracted duplicated code.
however this parameterization approach could cause a change in the program behavior especially when the parameterized expressions are method calls and object creations due to sideeffects on the state of the objects involved in these expressions.
in a previous work we developed a refactorability analysis approach that can automatically determine whether the parameterization of the expressions being different between two clones could change the program behavior.
theproposed technique performs a sophisticated static source code analysis to extract intra and inter procedural data dependencies between the statements inside the clone fragments to be merged and examines whether these data dependencies would be preserved after the refactoring of the clones.
if the parameterization of the clone differences breaks at least one of the originally existing dependencies then the refactoring is not behavior preserving and thus the clones are assessed as non refactorable .
using this refactorability analysis tool we performed a large scale empirical study on clones detected by four different clone detectors in nine open source projects where we found out that around of the detected clones belong to either type i.e.
structurally syntactically identical code fragments with variations in identifier names literal values and types or type i.e.
copied fragments with statements changed added or removed in addition to type2 differences categories.
only of these type and type clones were assessed as safely refactorable using the standard parameterization approach.
among the top reasons preventing these clones from being refactorable are the presence of different expressions within matched statements whose parameterization would change the program behavior the presence of unmapped statements within the clone fragments also known as clone gaps and the presence of different method calls having a void return type java does not allow parameters of void type .
java introduced lambda expressions as a means to support functional programming.
a lambda expression in java is an anonymous function containing either a block of statements or a single expression that can be passed as a parameter to a method thus achieving behavior parameterization .
one of the most important features of a lambda expression is that it executes in the context of its invocation i.e.
inside the method in which it is passed as an argument and thus it can use the values of the variables that are defined in that context.
this makes lambda expressions ideal for the parameterization of the three behavioral differences discussed in the previous paragraph preventing the refactoring of type and type clones since with lambda expressions we can parameterize behavior that is different among the clone fragments without changing the original execution order.
contributions in this paper we propose a technique and a tool that utilizes lambda expressions to enable the refactoring of type and type clones having behavioral differences that cannot be parameterized with regular parameters.
in ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
particular we developed an algorithm to examine whether it is possible to introduce lambda expressions for the unmapped statements i.e.
clone gaps and expressions assessed as nonparameterizable by our previously proposed refactorability analysis approach .
to the best of our knowledge this is the first work to investigate the use of lambda expressions as a means to refactor software clones with behavioral differences.
to evaluate the efficacy of the proposed technique we first assess its correctness by refactoring and testing clone pairs covered by unit tests and reporting the compilation errors and test failures that occurred.
next we apply the proposed technique on a dataset of type and type clone pairs and report the percentage of the clone pairs whose refactoring was enabled using lambda expressions and the characteristics of the introduced lambda expressions.
finally we make publicly available the dataset of the examined clones to facilitate future research on clone refactoring .
ii.
m otivating examples in this section we use two examples of clones from opensource projects to motivate the reader about the usefulness of lambda expressions in the refactoring of clones.
example figure 1a shows two duplicated methods found in the test code of the jfreechart project version .
.
that create a mock object of day andhour type respectively to test its method getfirstmillisecond .
both test methods initially save the current locale andtimezone of the system into temporary variables saved andsavedzone respectively and set the locale toukand the timezone to europe london before instantiating the mock object.
after testing an assertion with assertequals the locale and timezone of the system is reset to the original values saved in the temporary variables.
the reset of the locale and timezone is necessary to avoid affecting other unit tests whose execution follows.
the duplicated test methods are type clones and have only two differences highlighted in yellow namely the type of the mock object being instantiated and the literal of long type passed as the first argument in assertequals .
it should be emphasized that the same test method is duplicated times in the jfreechart test code base each time testing a different subclass type of theregulartimeperiod superclass type namely day hour millisecond minute month quarter second week andyear with exactly the same differences.
if we assume that the developers of these test methods decide to test the mock objects with another locale and or timezone they would have to apply the same changes times which requires significant effort and time.
therefore we can argue that this is an interesting case for refactoring assuming that future test maintenance activities are probable.
in fact there is evidence that developers read write and maintain test code and thus clone refactoring could facilitate test code reuse understandability and maintainability.
to refactor these test methods there are two alternative approaches.
the first approach is to extract the identical functionality i.e.
the first four statements constitute the commonset up logic of the tests while the last two statements constitute the common tear down logic of the tests into separate methods.
however this approach might not be always feasible e.g.
the set up logic of the tests should return two variables namely saved andsavedzone and java allows methods to return at most one value and does not eliminate completely the duplication e.g.
the two statements initializing the mock objects and testing the assertion will remain duplicated .
the second approach is to parameterize the differences in the test methods.
figure 1b shows the parameterization of the test methods using two regular parameters.
note that in the extracted method the types of the mock objects have been generalized to the common superclass type regulartimeperiod and method getfirstmillisecond is polymorphically called.
this parameterization is changing the program behavior and makes the refactored tests fail.
the reason is that the mock objects are instantiated before the execution of the extracted method when they are passed as arguments to the extracted method and thus their instantiation is not using the appropriate locale and timezone configured in the set up logic of the tests.
through inter procedural program dependence analysis we can see that dayandhour constructors are using the static variables locale.defaultlocale and timezone.defaulttimezone defined by statements locale.setdefault andtimezone.setdefault respectively in the set up logic and thus there are interprocedural data dependencies from these statements to the constructor invocations.
figure 1c shows the parameterization of the test methods using lambda expressions to pass the two different class instantiations as arguments to the extracted method.
note that the type of the first parameter in the extracted method is the java.util.function.supplier functional interface more details about functional interfaces will be given in section iii b and the lambda expressions passed as arguments are executed by calling the get method over the supplier parameter arg0 .
this parameterization is preserving the program behavior and makes the refactored tests pass because the mock objects are instantiated in exactly the same execution point as before the refactoring.
example figure 2a shows two duplicated methods found in the apache ant project version .
.
that belong to classes linecontains andlinecontainsregexp respectively.
both methods implement a similar logic i.e.
they read a stream line by line the current line is saved in the line field and the first method left side of figure 2a examines if line contains one of the words inside the contains vector while the second method right side of figure 2a examines if line matches with one of the regular expressions inside the regexps vector.
the duplicated methods are type clones and have two main differences namely the types of the elements inside the vectors contains is a vector of string objects while regexps is a vector of regularexpression objects and the logic behind the matching of line as indicated by the unmapped statements highlighted in red inside the inner forloop.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
public void testgetfirstmillisecond locale saved locale.getdefault locale.setdefault locale.uk timezone savedzone timezone.getdefault timezone.setdefault timezone.gettimezone europe london hour h new hour assertequals 1143900000000l h.getfirstmillisecond locale.setdefault saved timezone.setdefault savedzone public void testgetfirstmillisecond locale saved locale.getdefault locale.setdefault locale.uk timezone savedzone timezone.getdefault timezone.setdefault timezone.gettimezone europe london day d new day assertequals 5094000000l d.getfirstmillisecond locale.setdefault saved timezone.setdefault savedzone difference between mapped statementsdata dependence a a pair of clones found in the tests of the jfreechart open source project public void testgetfirstmillisecond extracted new day 5094000000l public void extracted regulartimeperiod arg0 long arg1 locale saved locale.getdefault locale.setdefault locale.uk timezone savedzone timezone.getdefault timezone.setdefault timezone.gettimezone europe london regulartimeperiod d arg0 assertequals arg1 d.getfirstmillisecond locale.setdefault saved timezone.setdefault savedzone public void testgetfirstmillisecond extracted new hour 1143900000000l b parameterization with regular parameters changing the program behavior public void extracted supplier regulartimeperiod arg0 long arg1 locale saved locale.getdefault locale.setdefault locale.uk timezone savedzone timezone.getdefault timezone.setdefault timezone.gettimezone europe london regulartimeperiod d arg0.get assertequals arg1 d.getfirstmillisecond locale.setdefault saved timezone.setdefault savedzone public void testgetfirstmillisecond extracted new day 5094000000l public void testgetfirstmillisecond extracted new hour 1143900000000l c parameterization with lambda expressions preserving the program behavior fig.
.
using lambda expressions to enable the refactoring of type clones.
public int read throws ioexception if !getinitialized initialize setinitialized true int ch if line !
null ch line.charat if line.length line null else line line.substring else final int containssize contains.size for line readline line !
null line r e a d l i n e boolean matches true for int i matches i containssize i string containsstr string contains.elementat i matches line.indexof containsstr if matches isnegated break if line !
null return read return ch public int read throws ioexception if !getinitialized initialize setinitialized true int ch if line !
null ch line.charat if line.length line null else line line.substring else final int regexpssize regexps.size for line readline line !
null line r e a d l i n e boolean matches true for int i matches i regexpssize i regularexpression regexp regularexpression regexps.elementat i regexp re regexp.getregexp getproject matches re.matches line if matches isnegated break if line !
null return read return ch unmapped statement difference between mapped statementsdata dependence1243567891011121314151617181920124356789101112131416171819202115 a a pair of clones found in the apache ant open source project protected int extracted vector vector function integer boolean matcher throws ioexception if !getinitialized initialize setinitialized true int ch if line !
null ch line.charat if line.length line null else line line.substring else final int containssize vector.size for line readline line !
null line readline boolean matches true for int i matches i containssize i if matches isnegated break if line !
null return read return ch matches boolean matcher.apply i b extracted method after refactoring public int read throws ioexception return extracted contains integer i string containsstr string contains.elementat i return line.indexof containsstr public int read throws ioexception return extracted regexps integer i regularexpression regexp regularexpression regexps.elementat i regexp re regexp.getregexp getproject return re.matches line c clones after refactoring with lambda expressions fig.
.
using lambda expressions to enable the refactoring of type clones.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to refactor these methods one could first try to convert them into type clones by moving the unmapped statements before or after the common code.
in our previous work we observed some typical patterns of type clones that can be easily converted into type clones by inlining temporary variables that appear in only one of the clones or by moving statements declaring a variable at a different nesting level.
however in the example of figure 2a it is not possible to move the unmapped statements because they depend on the value of variable ithat increments after each iteration of the inner forloop i.e.
there is a data dependence from the for loop which declares and increments variable ito the first unmapped statement that uses ito retrieve the next element from the vector .
in turn the statements that follow inside the inner for depend on the variable declared by the first unmapped statement i.e.
containsstr andregexp respectively as shown by the data dependencies.
therefore we need a parameterization approach that preserves the execution of the unmapped statements inside the inner forloop.
figure 2c shows the parameterization of the methods using lambda expressions to pass the two different line matching behaviors as arguments to the extracted method figure 2b .
the lambda expressions figure 2c take as input parameter iand return the matching result as a boolean .
the type of the second parameter in the extracted method is the java predefined java.util.function.function functional interface and the lambda expressions passed as arguments are executed by calling the apply i method through the function parameter matcher .
this example demonstrates that lambda expressions are executed in the context of their invocation and thus they can use the values of the variables that are defined in that context i.e.
variable i .
alternatively these methods could be parameterized by applying the template method design pattern i.e.
introducing a new abstract method in the common superclass where the extracted code i.e.
template will be pulled up replacing the uncommon code with a call to the abstract method and finally overriding the abstract method in the subclasses containing the original clones with the corresponding behavior.
however it is not always possible to apply the form template method refactoring because a the clones might exist in the same class or in classes not having a common superclass b it might not be always possible to make the common superclass abstract if the project contains objects instantiated from the common superclass c the common superclass might have other subclasses that must provide an implementation for the newly introduced abstract method without necessarily needing its functionality and d it might not be always possible to introduce a new intermediate common superclass i.e.
extract superclass to host the template method if the subclasses containing the original clones belong to different levels of the inheritance hierarchy.
on the other hand there are no such restrictions for the application of lambda expressions.
with these examples it becomes clear that lambda expressions can enable the refactoring of clones whose parameterization is not feasible or behavior preserving by other means .iii.
a pproacha.
input the input of our approach is the output of the clone refactorability analysis tool from our prior research which takes as input a pair of clone fragments and returns a mapping between the statements of the clone fragments along with the differences i.e.
pairs of expressions being different inside the mapped statements and a list of unmapped statements i.e.
statements that could not be matched with any statement from the other clone fragment due to incompatible ast structure for each clone fragment.
in a nutshell the solution proposed in our prior research applies a maximum common subgraph algorithm on the program dependence graphs of the clones in a divide and conquer fashion by breaking the initial statement mapping problem to smaller subproblems based on the control dependence structure of the clones.
in this way it explores the search space of alternative mapping solutions in order to maximize the number of mapped statements and minimize the number of differences between them.
additionally it can properly handle clones in which matching statements have been reordered in contrast to tokenbased differencing approaches such as mcidiff that do not consider the syntactic structure of the program.
a visual representation of the extracted information is shown in figure 2a where the differences between the mapped statements are highlighted in yellow and the unmapped statements are highlighted in red.
in the final phase a list of preconditions is examined to determine whether the detected differences can be safely parameterized with regular parameters and whether the unmapped statements can be safely moved before or after the common code.
if the examined preconditions fail the corresponding differences or unmapped statements are associated with a precondition violation and the clones are assessed as non refactorable.
our current work focuses on the differences and unmapped statements associated with precondition violations and proposes a method to examine whether their parameterization with lambda expressions is feasible.
b. lambda unification since lambda expressions are anonymous functions the unification of two code fragments into a common function or a functional interface following the java terminology requires that these code fragments can be abstracted to two functions with an identical signature.
more specifically there are three conditions that should be met regarding the signature the code fragments should return at most one variable of the same type or different types that can be generalized to a common type.
the code fragments should require the same input parameter types from the extracted duplicated code.
the code fragments should throw the same exception types.
our approach can be divided into parts .
handling of statement gaps a statement gap consists of two sets of consecutive unmapped statements siandsj which are nested at the same authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
level.
to determine whether a statement gap can be parameterized in the form of lambda expressions we propose algorithm .
in a nutshell the proposed algorithm is a recursive function that can expand backwards and or forwards the original sets of statements if necessary so that the final sets of statements require the same input parameters and produce the same output.
additionally when the aforementioned conditions are finally met it also examines a list of preconditions to ensure that the introduction of the lambda expressions is feasible and behavior preserving.
algorithm recursive function determining if a statement gap can be parameterized in the form of lambda expressions input a statement level gap output true if lambda refactoring is feasible false otherwise updated sets s0 i s0 j if expansion occurred function lambda refactorable si sj uv i usedvariables si uv j usedvariables sj ifcommonparameters uv i uv j then rvi returnedvariables si rvj returnedvariables sj ifvalidreturntype rv i r v j then ifcheckpreconditions si sj then return true end if else if s0 i s0 j forward si sj then return lambda refactorable s0 i s0 j end if else if s0 i s0 j backward si sj then return lambda refactorable s0 i s0 j end if return false end function function usedvariables lines takes as input a set of statements and returns the set of variables that are collectively used in the input statements.
function returnedvariables lines takes as input a set of statements and returns the set of variables that are modified in the input statements and are used by code executed after the input statements.
function commonparameters line takes as input two sets of variables and examines if the types of the corresponding variables are the same.
it should be noted that the input sets do not need to have the same cardinality as long as one of them is a proper orstrict subset of the other and the additional variables of the superset are declared before the clone fragment to be extracted e.g.
parameters of the method containing the clone fragment .
this relaxation was necessary in order to deal with overloaded method calls accepting a different number of arguments.
function validreturntype line takes as input two sets of variables and examines if the cardinality of both sets is equal to zero or one i.e.
one variable can be returned at most .
when the cardinality of both sets is equal to one it additionally examines if the types of the variables are the same or if they are sub types of a common superclass.function checkpreconditions line takes as input two sets of statements and examines the following list of preconditions the statements contained in siandsjshould collectively throw the same exception types.
setssiandsjshould not include branching statements break continue without including the corresponding target switch or loop statement.
setssiandsjshould not include conditional return statements i.e.
return without an expression causing a direct exit from the method containing the clone .
if sets siandsjcontain return statements with an expression returning a value then all possible execution flows should end with a return statement.
if sets siandsjcontain statements using variables declared in the code remaining in the original methods after refactoring then these variables should be final or effectively final i.e.
a variable or parameter whose value is never changed after it is initialized .
this condition applies only to local variables and parameters of the methods containing the clone fragments but not to accessed fields and it is required because java handles lambda expressions as single method anonymous classes .
setssiandsjshould not include all statements of the original clone fragments.
this condition is necessary to avoid cases where the expansion might cover the entire clone fragments.
finally function backward line adds the statement executed right before the first statement in siandsj respectively as long as this statement is nested at the same level.
function forward line adds the statement executed right after the last statement in siandsj respectively as long as this statement is nested at the same level and contains differences which cannot be parameterized with regular parameters.
.
handling of expression differences an expression difference consists of two expressions found in two mapped statements of the clone fragments which may have a different syntactic structure i.e.
different types of ast nodes but are evaluated to the same type or types having a common superclass.
for example in the clones shown in figure 2a mapped statements and from each clone contain an expression difference highlighted in yellow.
the expressions have a different ast type on the left clone fragment we have an infix expression line.indexof containsstr while on the right one we have a method invocation expression re.matches line but both of them are evaluated to type boolean .
as a result the condition validreturntype is met by default and the only remaining conditions that should be examined to determine if the two expressions can be parameterized as lambdas is commonparameters andcheckpreconditions only preconditions and are applicable .
.
merging of overlapping gaps and expression differences after all statement gaps and expression differences are processed we apply a post processing step to determine if some of them can be merged in order to minimize the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
number of lambda expressions that should be introduced.
more specifically we apply three merging operations if the statements corresponding to an expression difference are included inside an expanded statement gap then only the statement gap is parameterized.
if a statement gap is subsumed by another one i.e.
all its statements are included within a larger statement gap then only the larger one is parameterized.
if two statement gaps have an overlap i.e.
they share some common statements but do not subsume one another then they are merged into a single statement gap.
if the merged statement gap is refactorable according to algorithm then the original overlapping statement gaps are not parameterized and only the merged one is parameterized.
.
creating appropriate functional interfaces for each one of the final statement gaps and expression differences an appropriate functional interface should be added as a parameter to the extracted method.
java provides a list of predefined functional interfaces in the java.util.function package which are used whenever it is possible function t r the lambda expressions take as input one argument t and return a result r .
supplier t the lambda expressions take no input arguments and return a result t .
consumer t the lambda expressions take as input one argument t and return no result.
all aforementioned functional interface types do not support exception throwing.
therefore when the lambda expressions take as input two or more arguments and or throw one or more exceptions a custom functional interface needs to be introduced within the same class that the extracted method will be placed in functionalinterfaceinterface custominterface t0 apply t1 arg1 t2 arg2 ... throws e1 e2 ... c. running example in this subsection we will demonstrate the application of algorithm on the motivating example we used in section ii shown in figure 2a.
the initial input to the algorithm is the sets of statements si andsj .
both sets of statements are nested at the same level under the mapped for loops with ids and respectively .
the sets of used variables are uv i int i and uv j int i and thus the function commonparameters returns true and there is no need for a backward expansion of the sets siandsj.
however the sets of returned variables are rv i string containsstr and rv j regexp re and thus the function validreturntype returns false because the types of the variables differ and cannot be generalized to a common super type.
therefore the function forward is executed and updates the original input statements to s0 i and s0 j .
after the forward expansion the sets of used variables uv iand uv jremain the same while the sets of returned variables are becoming rv i booleanmatches and rv j boolean matches .
as a result now the sets s0 iands0 jcontain statements that require the same input parameters and produce the same output and thus no further expansion is needed.
iv.
e val uat i on to assess the correctness and applicability of the proposed technique for enabling the refactoring of clones with nontrivial behavioral differences we designed a study aiming to answer the following research questions rq1 does the proposed approach refactor clones without introducing compile errors or changing program behavior?
rq2 what portion of the clones that cannot be parameterized with regular parameters becomes refactorable with lambda expressions?
rq3 what are the characteristics of the introduced lambda expressions?
a. experiment setup to investigate our research questions we created a large and diverse dataset of clones extracted from open source projects using different clone detectors consisting of clone pairs having statement gaps type and or expression differences type that were assessed as non refactorable using the standard parameterization approach .
subject selection to avoid bias in the selection of projects and enable the comparison of our results with previous studies we adopted the systems used in the studies conducted by tairas and gray and tsantalis et al.
shown in table i. table i examined projects project domain age kloc apache ant .
.
java application build tool columba .
email client emf .
.
modeling framework jmeter .
.
server performance testing jedit .
text editor jfreechart .
.
chart library jruby .
.
programming language hibernate .
.
java persistence framework squirrel sql .
.
universal sql client years of development from the initial release to the examined release the dataset includes projects from different application domains having a different development history ranging from to years.
we assume that these two variation points affect the variability of the clones present in these systems and thus the generalizability of our findings.
clone detector selection we used popular clone detection tools namely ccfinder deckard clonedr and nicad .
the selection criteria tool descriptions and configuration settings are detailed in .
we also kept in the dataset only one instance of the clones reported by multiple tools to avoid having duplicate data points.
data collection figure shows the process we followed for collecting the data required to investigate our questions.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
html reportspreconditionviolations?ccfinderdeckardclonedrnicad clones systeminfo processor nicad3 system granularity locks blind threshold minlines maxlines cloneinfo npcs npairs runinfo ncompares cputime classinfo nclasses class classid nclones nlines similarity source file weblogicdeploymenttool.java startline endline pcid source source file webspheredeploymenttool.java startline endline pcid source class class classid nclones nlines similarity source file cbzip2outputstream.java startline endline pcid source source file cbzip2outputstream.java startline endline pcid source class class classid nclones nlines similarity source file tarfilesettest.java startline endline pcid source source file zipfilesettest.java startline endline pcid source class class classid nclones nlines similarity source file cbzip2inputstream.java startline endline pcid source source file cbzip2inputstream.java startline endline pcid source class clone detectorresults preconditionviolationsspreadsheetparsing2lambdaanalysis3 refactoring4nocompileerrors?covered byunit tests?yes building5mappinginformation csv filesclone pairs compileerrorsnoyestest resultsrun tests67undorefactoringcoveragereportcomputetest coverage1 yesclone instancesinformation nofig.
.
the workflow applied for the collection of the experimental data.
we have fully automated the data collection process by developing an eclipse command line application that computes the unit test code coverage for the project under analysis using the jacoco library .
parses the output of clone detection tools and determines if the clones are fully partially or not covered by unit tests.
executes the proposed technique implemented as part of the jdeodorant eclipse plug in in headless mode for each pair of clones reported by a clone detection tool.
applies the appropriate refactoring for each pair of clones assessed as lambda parameterizable by the proposed technique based on the relative location of the clones.
builds the project after each refactoring and reports any compilation errors.
executes the test suite of the project for each refactored pair of clones that is covered by unit tests compares the test results after refactoring with those before refactoring and reports any differences.
restores the project in its original state after each refactoring by un the applied refactoring and rebuilding the project.
stores the collected information in csv files used for statistical analysis html reports containing statement mapping information and precondition violations for a pair of clones and a spreadsheet containing information about all clones examined in the project and links to the reports .
b. correctness of lambda refactorings rq1 motivation the goal of rq1 is to ensure that the proposed approach can safely refactor clones using lambda expressions without introducing compilation errors and changing program behavior.
this kind of evaluation is essential to strengthen the validity of the collected empirical data that will be used to answer rq2 and rq3.
our hypothesis is that if our approach assesses the behavioral differences appearing between a pair of clone fragments as lambda parameterizable then it shouldbe possible to refactor these clones without causing any compilation errors and all tests of the project should pass after the application of the refactoring assuming the clones are covered by unit tests.
approach the execution of the entire test suite of a project after each refactoring is rather time consuming.
therefore for the investigation of rq1 we narrowed down our analysis on a single project namely jfreechart .
the reason we selected this project is that it has one of the highest unit test source code coverage e.g.
.
coverage for the src directory and .
including tests and the fastest test suite execution time less than seconds among the examined projects.
moreover jfreechart contains clones with diverse relative locations allowing to test all clone refactoring scenarios supported by our refactoring engine i.e.
extract method extract and pull up method form template method extract utility method .
we collected clone pairs that were assessed as lambda parameterizable by our approach and were covered by unit tests out of which .
are located in the same method .
are located in the same class are located in different classes having a common superclass and .
are located in unrelated classes.
each clone pair was refactored and tested by executing the entire test suite of the project after each refactoring.
to the best of our knowledge this is one of the most extensive evaluations of a clone refactoring engine even comparable to the evaluation of tools specialized in the testing of refactoring engines such as saferefactor and astgen .
results none of the applied refactorings caused a compilation error and only one refactoring led to a test failure.
the clones involved in the test failure are the methods writeobject in classes xyshapeannotation and dialvalueindicator respectively.
the problem is actually caused from the way that the statements of these methods are matched by and the special role of these methods in the serialization of objects.
more specifically the methods include statements calling special functions e.g.
serialutilities.writepaint serialutilities.writestroke that write the field values of the classes into a stream.
for the deserialization phase the methods readobject located in the same classes are used to restore the serialized field values by reading them in a specific order from the stream.
however the statement mapping algorithm matches the statements of the methods in a different order than their original order in an attempt to maximize the number of mapped statements.
this is causing the field values to be inserted in a different order into the stream after the refactoring and thus the deserialization fails.
we consider that this issue can be fixed by improving the mapping algorithm to assume the presence of data dependencies between statements reading writing from to a stream.
conclusion we found that the proposed clone refactoring approach is very reliable by testing it on pairs of clones.
our clone refactoring engine did not introduce any compilation errors and caused only one test failure.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
c. applicability of lambda expressions rq2 motivation the goal of rq2 is to assess the applicability of lambda expressions for the refactoring of type and type3 clones.
answering this question will help us understand how useful are lambda expressions for parameterizing the behavioral differences existing in typical type and type3 clones detected by clone detection tools.
moreover we break down the collected results taking into account three dimensions the source code type clones in production vs. test code the relative location clones within the same method same class same inheritance hierarchy or unrelated classes and the clone type type vs. type .
this will help us understand if lambda expressions are more useful for a particular category of clones.
finally we investigate the percentage of the clone pairs for which the template method design pattern can be safely applied as an alternative solution to lambda expressions.
table ii relative clone location and lambda applicability source type clone location pairs applicable allsame method .
.
same class .
.
same java file .
.
same hierarchy .
.
unrelated classes .
.
total .
productionsame method .
.
same class .
.
same java file .
.
same hierarchy .
.
unrelated classes .
.
total .
testsame method .
.
same class .
.
same java file .
same hierarchy .
.
unrelated classes .
.
total .
approach our analysis focused on clone pairs having statement gaps type and or expression differences type2 that were assessed as non refactorable by .
this means that it is not possible to move the statement gaps before or after the common code and introduce regular parameters for the expression differences due to data dependencies between the code in the gaps differences and the common code to be extracted.
the third column of table ii shows the number and percentage of clone pairs in different categories of relative location for all clone pairs those detected in production code and those detected in test code respectively.
two thirds of the examined clone pairs belong to production code while one third of them to test code.
we can also observe that most of the clone pairs are located in different subclasses of the same inheritance hierarchy especially for clones in test code while the second most frequent relative clone location is within the same class declaration.
there is also a significant number of clone pairs located in unrelated classes of the production code.
regarding the types of the examined clone pairs as shown in the second column of table iii of them are type clones while the remaining are type clones.all clone pairs went through lambda analysis step in figure and those without precondition violations were refactored and compiled but not tested .
we consider that a clone pair refactored with lambda expressions can be safely refactored using the template method design pattern in two cases when the clone is extracted to a new superclass because it can be declared abstract and thus we can add abstract methods for the behavioral differences that will be overridden by its subclasses containing the original clone fragments and when the clone is extracted to an existing superclass that is already abstract and is only inherited by the two subclasses containing the original clone fragments.
table iii clone type and lambda applicability clone type pairs applicable type ii .
.
type iii .
.
results as we can observe in the last column of table ii the parameterization with lambda expressions is feasible in .
of the examined clone pairs.
moreover lambda expressions tend to be more applicable to clones detected in test code than clones detected in production code .
vs. .
.
we believe this is due to the nature of the differences appearing in test clones which are mostly related to the instantiation of the objects being tested and the assertions being examined.
we also found that the clones located in the same class or different subclasses in the same inheritance hierarchy tend to be more refactorable with lambda expressions than clones located in unrelated classes.
this result shows that the behavioral differences found in more distant clones i.e.
located in unrelated classes are more difficult to be abstracted into lambdas possibly because the implemented requirements are different.
regarding the applicability of lambdas with respect to clone types as we can observe in the last column of table iii the percentage of type and type clones that can be parameterized using lambda expressions is very similar vs. .
finally out of the clone pairs refactored with lambda expressions we found that the template method design pattern could be applied in only .
of them.
conclusion we found that lambda expressions is a promising java feature for the refactoring of clones with behavioral differences especially for those located in test code.
in addition lambda expressions tend to be more beneficial for clones located in the same class or subclasses in the same inheritance hierarchy.
moreover lambda expressions can equally benefit both type and type clones.
finally the template method design pattern can be used as an alternative approach to lambdas in only one third of the refactored clone pairs.
d. characteristics of lambda expressions rq3 motivation in the previous research question we saw that lambda expressions can be very effective in the refactoring of clones with behavioral differences.
however this refactoring tends to disperse the duplicated code from two locations originally to three locations after refactoring i.e.
the code authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
corresponding to behavioral differences remains in the original locations and is passed as lambdas to the extracted method while the common code is extracted to another method in the same class a superclass or a utility class.
the goal of rq3 is to assess the effect of lambda expressions on the dispersion of the original code.
according to best practice guidelines lambda expressions should be short and developers should prefer the standard functional interfaces .
when the clone fragments have a small number of behavioral differences with a small size that can be parameterized using the predefined functional interface types provided by java the resulting refactored code will be less dispersed.
the smaller the number and size of the differences the more the code is concentrated to a single location after refactoring.
the more predefined functional interface types are applicable the less new custom types will be introduced after refactoring.
approach our analysis focused on the clone pairs refactored with lambda expressions.
we used the following indirect measures for code dispersion the number of lambda expressions required to parameterize the behavioral differences of the clone fragments.
the relative size of the lambda expressions to the size of the clone fragments.
the functional interface types used to parameterize the behavioral differences of the clone fragments.
for each clone pair we count the number of lambda expressions required to parameterize its behavioral differences figure 4a .
for each lambda expression we compute the ratio of its size i.e.
number of statements over the size of the clone fragment figure 4b .
in particular for expression differences we approximate their size to one statement although an expression is always part of a statement.
finally for each lambda expression we record the functional interface type function supplier consumer or custom used to parameterize the corresponding behavioral difference figure 5a .
moreover since the java predefined functional interface types do not support exception throwing our refactoring implementation introduces a new custom type whenever the code inside the lambda expressions is throwing an exception even if the number of arguments meets the requirements of a predefined type.
therefore we investigate the percentage of the custom types that could be potentially converted to the java predefined types if they supported exception throwing figure 5b .
a number of lambda expressions0.
.
.
.
expression diffs statement gaps b size of lambda expressions fig.
.
characteristics of the lambda expressions in refactored clone pairs.
.
.
.
.
consumer custom function supplier a actual functional interface types0.
.
.
.
consumer custom function supplier b break down of custom types fig.
.
distribution of functional interface types.
results as we can observe in the box plot shown in figure 4a the median value for the number of lambda expression per clone pair is equal to while the third upper quartile is equal to .
this means that of the refactored clone pairs require only one lambda expression while of them require two or less.
regarding the size of the lambdas for expression differences the median value is equal to of the clone fragment size box plot on the left side of figure 4b while for statement gaps the median value is equal to of the clone fragment size box plot on the right side of figure 4b .
finally as we can observe in figure 5a almost of the lambda expressions can be parameterized using the java predefined functional interface types i.e.
function supplier consumer and thus there is no need to create custom types.
as we can observe in figure 5b an additional of the custom types could be converted to the java predefined types if they supported exception throwing increasing the lambdas that could be potentially covered by the predefined types to .
conclusion the majority of the refactored clone pairs require a small number two or less of lambda expressions to parameterize their behavioral differences.
on average the size of the lambda expressions is relatively small covering of the clone fragment for expression differences and of the clone fragment for statement gaps.
of the lambda expressions can be parameterized with the java predefined functional interface types.
this could increase to if the java predefined types supported exception throwing.
e. threats to validity internal how reliable is the used statement mapping algorithm?
the algorithm used for the mapping of the statements within the clone fragments definitely affects the results of this study since it produces the expression differences and statement gaps used as input by the proposed lambda refactoring approach.
this algorithm maximizes the number of matched statements and handles the matching of reordered statements between the clone fragments.
despite the fact that it is using data dependence information coming from interprocedural data flow analysis as well as type binding information coming from the compiler to guide the matching of the statements there might be some cases where the statement mapping returned by the algorithm is not the most accurate due to missing dependencies resulting from an incomplete analysis.
however the extensive testing we performed on clone pairs section iv b gives us the confidence that the used statement mapping algorithm is reliable and accurate.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
how does the clone pair granularity affect the results?
the results of this study are reported at clone pair level because the used statement mapping algorithm does not support the analysis of clone groups also known as clone classes containing more than two clone fragments but only pairs of clones.
whenever a clone group is analyzed we apply our technique on every possible combination of clone pairs i.e.
n for a group with nclone fragments .
the majority of the clone groups analyzed in this study contain or clone instances the median is equal to the third quartile is equal to and the mean size is .
.
this means that for most clone groups the number of clone pair combinations is either or and thus reporting the results at clone group level would not significantly affect our findings.
external how representative are the examined clones?
the clone detectors used in the study have several configuration options related to the size and similarity of the clones.
even minor changes in the settings can affect significantly the characteristics of the detected clones .
wang et al.
introduced a search based approach to determine the configurations from the space of all configuration choices that maximizes tool agreement .
however in our study it is important to get as more diverse clones as possible from each clone detector.
therefore we used the default or recommended configuration options for each tool.
these settings have been consistently used in a large number of empirical studies and can be considered as standards.
how representative are the examined projects?
we included in our study projects coming from different application domains but also having a different java version compatibility.
for example the projects emf and jruby are using the newer language features such as generics and varargs but other projects like ant are compatible with previous java versions.
this diversity in the domain and the language features used by each project makes possible to generalize our findings to several other open source projects with similar characteristics.
moreover we adopted the exact same systems used in previous studies to avoid bias in the selection of subjects.
verifiability to make the results of this study reproducible we provide online all the artifacts required to reproduce and replicate the experiments including the source code of our tools the results of the clone detection tools used in the experiment and the r scripts we developed to obtain the results of the experiments .
v. r elated work clone refactoring meng et al.
proposed a technique for automated clone refactoring based on systematic edits i.e.
similar edits to different locations in the source code .
one major difference is that meng et al.
rely on systematic edits while our approach takes as input the results of clone detection tools.
relying on systematic edits for clone refactoring is a rather intuitive solution since it is believed that clones being frequently and consistently modified during the evolution of a software system should have a higher priorityfor refactoring .
however systematic edits cannot capture clones that are not consistently updated mainly because the developers are not aware of their existence or clones that are never updated.
on the other hand an approach based on the input of clone detectors is more generic and universal since existing tools can detect both consistently and inconsistently modified clones depending on their configuration i.e.
similarity threshold as well as stable clones.
other clone refactoring techniques have a more restricted scope.
for instance tairas and gray focus only on type clones having expression differences whose parameterization is free of side effects.
hotta et al.
and juillerat et al.
focus only on clones that can be refactored by applying the template method design pattern.
our technique has a much broader scope being able to handle clones with diverse relative locations and behavioral differences.
finally there are works based on machine learning that recommend clones for refactoring .
lambda refactoring gyori et al.
developed a tool named l ambda ficator which automates two refactorings introducing lambda expressions.
the first refactoring converts anonymous inner classes to lambda expressions.
the second one converts for loops that iterate over collections to functional operations that use lambda expressions.
the goal of this work is to make the code more succinct by eliminating anonymous classes and enable unobtrusive parallelism by applying functional operations like maporfilter to iterations.
however our goal is to leverage lambda expressions in order to eliminate code duplication.
lambda related studies there is a very limited number of studies investigating the effect of lambda expressions on development debugging and testing effort.
a recent controlled experiment comparing the use of c lambdas with iterators has shown that participants spent more time with compiler errors and had more errors when using lambdas as compared to iterators suggesting difficulty with the syntax chosen for c .
however the experience level of the participants had a large effect on the experiment results since professionals were more likely to complete tasks with or without lambdas and could do so more quickly than students.
therefore the experience of the developers the language syntax and tool support e.g.
for debugging lambda expressions play a significant role on the understandability of the code.
vi.
c onclusions in summary the main conclusions and lessons learned are lambdas are effective for parameterizing behavioral differences applicability especially for test clones .
lambdas are equally beneficial for parameterizing type and type clones vs. applicability .
the majority of clones require one or two lambdas.
of the lambdas can be parameterized using just three of the java predefined functional interface types.
extending these functional interface types to support exception throwing would increase the aforementioned percentage to .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.