dynamically testing guis using ant colony optimization santo carino and james h. andrews department of computer science google inc. university of western ontario amphitheatre parkway london ontario canada mountain view ca usa email scarino andrews csd.uwo.ca abstract in this paper we introduce a dynamic gui test generator that incorporates ant colony optimization.
we created two ant systems for generating tests.
our first ant system im plements the normal ant colony optimization algorithm in orderto traverse the gui and find good event sequences.
our secondant system called antq implements the antq algorithm thatincorporates q learning which is a behavioral reinforcementlearning technique.
both systems use the same fitness functionin order to determine good paths through the gui.
our fitnessfunction looks at the amount of change in the gui state thateach event causes.
events that have a larger impact on the guistate will be favored in future tests.
we compared our two antsystems to random selection.
we ran experiments on six subjectapplications and report on the code coverage and fault findingabilities of all three algorithms.
i. i ntroduction software testing is a large and expensive part of the development life cycle .
a lot of research has gone into traditional black and white box testing.
such methods includeusing dynamic symbolic execution using mu tants random testing and search based software testing .
with graphical user interfaces gui being commonplace in most modern software rangingfrom the web to mobile and desktop the need for gui testshas arisen which further increases the cost.
as with automatedblack box test generation there is a need for automated testgenerators for guis.
while traditional test generators are ableto generate tests similar to tests a programmer would write that is a series of methods calls and variable declarations gui tests typically consist of a series of events to be run onthe system for example clicking buttons or entering data intotext boxes.
currently gui tests can be written manually orcreated using a record and playback system .
manuallywritten tests consist of methods to locate a specific gui widgetand executing its event.
record and playback systems recordthe user s interaction with the application and can then playback the test script at a later time.
both methods are time consuming.
in this paper we introduce a test sequence generator for guis.
the system uses ant colony optimization in orderto generate tests that have an impact on the state of the gui.ant systems have been shown to be useful for finding pathsthrough a graph.
since guis are best represented by graphs where each vertex is an event and each edge an action itfollows that ant colony optimization may be a good methodto explore the gui graph.
furthermore we can represent thegui test generation problem as an optimization problem suchas trying to generate tests that maximize code coverage.
oursystem s goal is to find sequences of events that have a largeimpact on the gui state.
there are generally two types of architectures for testing gui systems model based systems and dynamic systems .model based systems will first try to discover the structureof the gui hierarchy and generate a model.
the models aregenerally represented as event flow graphs or state machines.test cases are then generated offline based on the model sstructure.
model based systems can generate infeasible testcases due to the fact that some events can only be selectedif the system is in a specific state.
a dynamic testing systemwill explore the gui as it generates tests and create a model asevents are discovered.
since the system can determine whichevents are available at each state the tests are always feasible.due to the benefits of the dynamic architecture we opted to useit and therefore all tests generated in our system are feasible.
the contributions of this paper are as follows.
we adapt the concept of using the gui state change ratio to ant colony systems and show how it can beused as an effective fitness function.
we apply two ant colony systems to gui testing the ant system and antq and show how they cangenerate effective test cases.
we evaluate both ant systems and compare themagainst random search.
the paper is organized as follows.
section ii discusses related work and other gui testing systems.
section iii showshow we calculate our state change values which we use asa fitness function.
section iv looks at the two ant systemswe implemented a traditional ant system and antq whichcombines ant colony optimization and q learning.
section vis where we evaluate our system by testing the two algorithmson six subject applications and comparing their results againstone another as well we compare against random selection.finally we conclude in section vi.
ii.
b ackground and related work here we describe ant colony optimization in general as well as other systems designed for automated gui test 30th ieee acm international conference on automated software engineering .
ieee sequence generation.
a. ant colony optimization an ant colony optmization algorithm is a swarm intelligence system typically used to solve problems that can be represented as a graph such as the travelling salesmanproblem.
the ant system s main components are positivefeedback and distributed computation.
furthermore the antsystem makes use of a greedy heuristic when traversing agraph.
the system uses a set of agents called ants to explorethe graph in order to find an optimal path.
once a generationof ants has completed its search the edges of the graph areupdated.
the edges are updated by having a value calledpheromones deposited on them.
the amount of pheromonedeposited on an edge depends on the fitness of the ants thattraversed it.
the fitness function used for many problems isthe inverse of the tour length for each ant.
the more antsthat traverse an edge the more pheromone it will receive.furthermore each edge s pheromones reduce over time dueto evaporation.
another component of the ant system is thegreedy heuristic.
the heuristic is used during the selectionprocess in order to determine the next vertex to visit.
theheuristic value is combined with the pheromone value whichdetermines the vertex s desirability.
the heuristic is generallythe inverse of the edge s distance so that shorter edges willbe favored.
ant systems have been combined with q learning to further improve their results.
q learning is a behav ioral reinforcement algorithm that teaches agents how to actin controlled markovian domains.
it works by continuouslyimproving evaluations of specific actions in specific states.
ourant system incorporates q learning into each ant s exploration.in the traditional ant system the pheromone values are onlyupdated after each ant has successfully completed its run.
inantq the edges are updated at two points.
first when an anttraverses an edge it immediately updates the edge s pheromoneusing the q learning technique.
second once each ant hascompleted its run the edges are updated again as in the classicant system.
another difference between the two systems is thatin the ant system all edges are updated after each generation whereas in antq only edges that were traversed by an ant areupdated.
b. gui testing methods a popular and well researched model based testing system is guitar .
guitar works by ripping the gui into a gui hierarchy file which can then be translated toan event flow graph efg .
efgs represent all possibleevent interactions that can occur.
the graph can be traversedand tests generated that consist of a list of events to execute.various techniques can be used to generate tests such as usingcovering arrays or using automated planning to coverdefined goals .
the major flaw with guitar is that it cangenerate infeasible tests.
these broken tests can be repaired however the process can be expensive.
bauersfeld et al.
developed a system that incorporates ant colony optimization in order to test guis.
the goal oftheir system is to generate test sequences that result in alarge maximum call tree mct .
mcts are trees that representmethod calls in a system.
a large mct is a tree with many leafnodes.
the idea behind generating large mcts is that methodscan be called in different contexts such as from other methods and by generating large mcts the context in which a method iscalled is likely to change.
for example a method m1 can be called by both methods m2 andm3 .
it would be beneficial to havem1 called in both contexts to ensure it is properly tested as either one of the calling methods can change variablesor objects that m1 relies on.
the authors were successful in generating test sequences that generated large mcts.
gross et al.
developed exsyst which is a dynamic test sequence generator that uses a genetic algorithm to evolvean entire test suite.
the authors begin by showing that using aunit test generator such as randoop can result in manyfalse failures as the implicit contraints of the aut imposed bythe gui are ignored.
exsyst works by generating randomtest suites and determining their fitness based on branchdistance.
however the system takes into account multipletarget branches instead of just a single branch.
the systemperforms genetic manipulation in the form of crossover andmutation.
crossover happens at the test suite level by havingtest suites exchange a number of test cases.
furthermore both test suites and test cases can be mutated.
test suitesare mutated by adding test cases or modifing an existing testcase.
test cases are mutated by deleting changing or insertingoperations.
the mutation phase can cause tests to break.
inorder to fix infeasible test cases a model of the gui is stored.the model contains sequences of actions and states that thoseactions lead to.
the model can be used to repair broken testcases.
mariani et al.
developed autoblacktest which is built on top of ibm rational tester to automate gui testsequence generation.
autoblacktest uses q learning to findgood sequences of events.
the system works by exploring thegui and assigning values to edges based on a reward and a qfunction.
the reward is the amount of change that occurs in thegui when an event is executed.
the q value is assigned basedon the event s reward and the q value of its best successorevent.
the system is also able to start testing from any foundstate.
as a result autoblacktest stores the states found andthe steps required to enter that state.
when a new test isbeing generated it will attempt to start the test at a previouslyfound state however if this is not possible it starts testingfrom its current state.
the authors incorporate heuristic actionsfor different event types where the action can encompassmany different events for example for handling file open andsave dialogs .
the authors compared autoblacktest againstguitar and show that it is able to achieve higher levels ofcode coverage and find more faults.
iii.
gui s tate change as a fitness the goal of ant colony optimization algorithms is to try to find an optimal path through a graph for example theshortest path to solve the travelling salesman problem.
in guitesting systems the value to optimize can differ.
in the caseof the authors try to maximize maximum call trees.
inother meta heuristic search systems such as exsyst theauthors try to maximize code coverage.
our system attemptsto maximize the amount of change in the gui state for eachtest case.
that is it will prefer interacting with widgets that 139have a large impact on the gui such as events that enable new widgets or open windows.
this concept is borrowed directlyfrom autoblacktest .
we can measure the amount of change on a system s gui by inspecting the gui s state before an event is run runningthe event and inspecting the resulting gui state.
the statechange value is then calculated as the difference betweenthe two states.
the system takes into account two factorswhen calculating the state change value first it compares theproperties of the widgets that exist in both states second itlooks for any new widgets that exist in the new state.
a gui s state can be broken down into its individual widgets such as buttons sliders and panels.
each widgetcontains a set of properties that describe it.
for example abutton s properties will contain its text whether or not it isenabled its position and so on.
furthermore some properties which we call traits can be used to identify a widget.
this is needed because when we compare states we want to ensurewe are comparing the same widgets.
formally we say a state s contains a set of widgets w w2 ... wn where each widget wcontains a set of properties p1 p2 ... pn we say that a propertypis a trait if it can be used to identify the widget.
when comparing two widgets w1andw2 w es a yw t w2iff w1 w2 ti w1 tj w2s.t.ti tj wheret is a trait in w. that is two widgets are equivalent if all of their traits are equal.
if one widget has a different number of traitsthan the other the two widgets are considered to be different.
when comparing two states we only look at a subset of the widgets and their properties which we call an abstract state.
an abstract state as contains a set of of abstract widgets where each abstract widget contains a subset of a real widget sproperties.
we only use a subset of a widget s propertiesfor state comparison as not all properties are relevant.
forexample an abstracttextbox will contain the text box s text gui hierarchy position class and whether or not it isenabled and editable.
if we have two abstract states as w ...wn andas prime w prime ...w prime n we define the restriction operator as tas prime wi wi as wk as primes.t.wi twk .
this restriction operator is used in our calculation of statechange ratios.
equation is used to calculate the ratio of change between two widgets if w tw2.
the equation determines the ratio of change based on each widget s properties.
diffw w1 w2 p1 p2 p2 p1 p1 p2 wherepiis a property in wi.
we use to compare two states and determine the ratio of change.
the equation takes into account the ratio of changebetween widgets that appear in both states as well as newwidgets that appear in the new state.
it does not includewidgets that may have been removed from the first state suchas when a window is closed.
this is done to favor widgets thatallow access to more events.diff as as1 as as2 tas1 summationtext w1 as w2 as w1 tw2diffw w1 w2 as2 the final change ratio is used as the fitness to our ant system.
the benefit of using the state change ratio as a fitnessis that it only relies on the information within the gui and itdoes not require any code instrumentation.
iv .
a ntsystems a. architecture the architecture of our system is shown in fig.
.
here we describe each component in detail.
application under test the application under test aut is the program being tested.
in our case it is a java swing application but it can be generalized to any gui system.
window listener the window listener implements the windowlistener interface provided with the jdk.
it is able to listen for window events such as when a window opens closes or is activated.every time a window update event happens the windowlistener captures the affected window and scrapes it.
thewindow listener determines if the window is modal or notby checking the window s properties.
a modal window is awindow that has control over the application.
no events outsideof that window are able to be executed until the windowhas closed.
an example modal window is the the save dialogwindow used in many applications.
if a window is modal onlyits events will be scraped otherwise all windows are scraped.
gui scraper the gui scraper accepts inputs from the window listener.
the window listener passes the scraper the set of windows to be scraped.
for each window the scraper extracts the window swidgets and determines if the widget is executable such as abutton or if it is a container such as a panel.
widgets thatare executable are stored in a widget list whereas containersare scraped further.
a window can contain many layers ofcontainers.
the scraper recursively scrapes each container untilit reaches the bottom of the gui hierarchy.
the scraper can work in two modes full state extraction or executable widgets only.
the full state mode will extract allavailable widgets and containers and return them.
this data isused to calculate the state change ratio for the ant algorithms.the second mode executable widgets only extracts andreturns widgets that can be executed and are valid.
by validwe mean enabled and visible.
140application under testwindowlistenergui scraper ant system ant ants runtrail updatergui state fitness calculatorexception reporter event selectorevent executorexceptions antq q learning reinforcement attach fig.
ant system architecture.
ant system the ant system is the controller for the set of ants that will test the aut.
the ant system deploys each ant and sets the ants tour length based on the configuration set bythe test engineer.
when an ant has completed its tour theedges traversed by the ant and the cumulative state changeratio are stored in an ant database called ants run .
after thegeneration of ants has completed its run the edges of the graphare updated using the trail updater and the ant database.
trail updater the trail updater is the component responsible for updating the edges traversed by the set of ants in the ant database.
the updater only uses the ants from the current generation toupdate the trails and not the ants from any previous generation.the trail updater looks at the edges traversed by each ant anddeposits pheromones.
if an edge was not traversed by an ant its pheromone is reduced.
the amount of pheromone depositeddepends on the algorithm being used ant system or antq and the pheromone evaporation rate.
ant the ant represents the actual test case.
after being spawned by the ant system the ant receives input from the scraper about the available executable events.
before executingan event the ant generates an abstract state by retrieving theaut s state data from the scraper module and passing it to thegui state fitness calculator.
the ant then passes the availableevents to the event executor.
after execution is complete theant captures the resulting state and retrieves the abstract statefrom the fitness calculator.
the two abstract states are passedto the calculator module in order to determine the ratio ofchange.
the resulting difference is added to the cumulativestate change of the test case which is to be used by the trailupdater.
the ant continues this process until it reaches its tourlength.gui state fitness calculator the gui state fitness calculator takes as input the raw widget data provided by the gui scraper module.
the calcula tor extracts the necessary properties and creates an abtract staterepresentation of the state and returns it to the ant module.the calculator can also compare two abstract states and returnthe difference.
the return value is in the range .
event selector the event selector takes as input the list of available events that can be executed.
it applies the pseudo random proportional rule to the list of events and selects an event to execute.
theselected event is sent to the event executor.
event executor the event executor takes as input an event to execute.
the event is compared against a list of possible event types such as buttons sliders and text boxes.
depending on thetype of the event a different action is taken.
some events canhave multiple actions for example a table can have a singlecell filled an entire row or column filled or the entire tablecan be filled with data.
for complex events we use a randomselection in order to determine the type of action to take.
inthe case of the table each action would have a chance ofbeing selected.
the data used to fill in text boxes and tablesis selected at random from a predefined list of inputs.
table ishows the list of events and their respective actions.
the event executor has heuristics in place to deal with two specific scenarios file dialogs and color choosers.
whenthe system detects either type of window it executes a set ofdefined actions.
for file dialogs the executor sets the directoryto home types in a random file name selects a random filetype and clicks the confirm save open button.
for the colorchooser window the executor simply clicks the ok button.the first heuristic is in place so that the test does not pollute 141table i event actions event action button spinner toggle button click text area password field type input table type cell row column table list select row rows tab panel selecttab tabindex slider setselection value combo box setselection index the host environment.
without the heuristic it is possible that important files or directories will be overwritten or renamed which would interfere with the testing.
the color chooserheuristic is used to avoid waisting time in the dialog window since the color chooser has little affect on the test if any.
q learning reinforcement the q learning reinforcement module is called only by the antq algorithm.
during the run of the antq algorithm when an event is executed the edge traversed is immediatelyupdated.
the module updates the specific edge and returns tothe ant module.
exception reporter the exception reporter implements the uncaughtexceptionhandler interface provided with the jdk.
any exception thrown during the execution of an event is caught.
the reporter logs the exception message stack trace and the list of eventsthat lead up to the event being thrown.
the data is then storedin a database.
b. event selection events are selected by using the pseudo random proportional rule shown in .
we use the pseudo random proportional rule as it has been shown to be more effective than using the random proportional rule alone .
y braceleftbigg max y allowed x xy xy ifq q0 y otherwise whereallowed xis the set of events that can follow event x is the pheromone value is the heuristic value qis a random value where q andq0is a value determined by the engineer beforehand.
this rule states that we select the bestedge with probability q or we select an edge using the random proportional rule using probability q. the equation for the random proportional rule is .
the rule states that an eventis selected randomly based on its proportion determined by itspheromone and heuristic values.
p xy xy xy summationtext u allowed x xu xu ify allowed x otherwise our system does not implement a hueristic so only the edge s pheromone values are taken into account when selectingevents.
we used a default pheromone value of .
for every edge in the graph.
over time the value will increase or decreasedepending on the fitness function.
c. updating pheromones the main difference between the ant system and the antq system is in how they update their pheromone values.
the ant system updates its pheromones using .
aq x y aq x y aq x y where is the pheromone evaporation rate.
when all ants of the current generation have finished their run the system updates allof the edges in the graph found so far.
the edges are updated using which states that edgesappearing in least one run of the kbest ants where k n and where nis the number of ants in a generation receives pheromones.
the amount of pheromones received is equal tothe average fitness of the ant runs that the edge appears in.for example if an ant appears in three of the k best ant runs it will receive pheromone equal to the average fitness of thosethree runs.
edges not appearing in any of the k best runs have their pheromones reduced based on the evaporation rate .
aq x y k summationtext i 1sc i kif x y cov.
by any ant kbest otherwise wherekbest is the set of the best kants in the current generation.
the antq system updates its pheromones using .
as the ant traverses the graph it updates each edge it touches.
this is the reinforcement learning borrowed from q learning.
duringthis stage the aq x y is for all edges.
once all ants in the generation have completed their run the system updatesonly those edges that were traversed by an ant all other edgeskeep their current pheromone value.
the traversed edges areupdated using where max u allowed yaq y u is for all edges.
aq x y aq x y parenleftbigg aq x y max u allowed yaq y u parenrightbigg where is the cooling factor which is a part of the q learning model.
for both the ant system and antq system the amount of pheromone deposited is calculated using .
sc anti statechange anti tourlength anti uniqueevents anti 142function antcolony generations ants length fori generations do statediffs forj ants do cudiff startaut fork length do event selectevent curstate getstate execute event newstate getstate diff getdiff curstate newstate cudiff cudiff diff curstate newstate end for shutdownaut statediffs.add cudiff end forupdatealltrails statediffs eq.
.
ant collaboration end for end function fig.
ant system algorithm whereant iis the index of the i th best ant run in the current generation statechange is the cumulative state change of the entire ant s run tourlength is the length of the ant s run and uniqueevents is the number of unique events executed during the ant s run where uniqueevents tourlength .
when calculating the state change using thestatechange method the system only counts the amount of change once for each event in an ant s run regardless if theevent is executed multiple times.
this is to discourage testsrepeating the same high state changing events.
furthermore we further favor unique events by dividing by the length ofthe tour and multiplying by the number of unique events.
thiswill favor tests with more unique events.
algorithms and highlight the differences between the two ant systems.
during the antq algorithm the q learningreinforcement is updated using after each edge is traversed where the aq x y value is .
at the end of each generation the same equation is used to update the ant trails however the max u allowed yaq y u values are for all edges.
v. e v aluation a. applications under test we evaluated both ant systems as well as random selection on six subject applications.
the details of the applications canbe seen in table ii.
the line and branch information was foundusing cobertura which we used to measure the codecoverage.
cobertura counts the executable lines of code andignores the rest.
the six applications chosen have all appearedin the literature previously.
they are of moderate size andrepresent real world applications.
b. parameter tuning in order to determine which values to set for the available tuning parameters we ran a small set of experiments onfunction a ntq generations ants length fori generations do statediffs forj ants do cudiff startaut fork length do event selectevent curstate getstate execute event newstate getstate diff getdiff curstate newstate cudiff cudiff diff curstate newstate updatetrail k k eq.
.
q learning reinforcement aq x y is end forshutdownaut statediffs.add cudiff end forupdatetouchedtrails statediffs eq.
.
ant collaboration max u allowed yaq y u is end for end function fig.
antq algorithm table ii application summary application classes statements branches argouml buddi gantt project terpspreadsheet terpword timeslottracker total terpspreadsheet terpword and argouml.
we ran test suitesof size that consisted of tests of length .
we used 10ants per generation and we used the best ants to update theedges.
we repeated the process five times and took the averagenumber of statements covered.
the tuning parameters for theant system are the pheromone evaporation rate and the pseudo random proportional selection value q .
both values are in the range .
for the antq algorithm an additionalparameter is required which is the cooling factor .
for all three parameters we chose the values .
.
and .
.since we do not know the effects of these parameters in thiscontext we chose a spread of values ranging from low tohigh.
for the ant system we combined each value against eachq 0value which resulted in nine combinations.
for the antq system we used a way combinatorial system to find allpairs between the three parameters.
this too resulted in ninecombinations.
we chose to use a way combinatorial selectionfor the factors as the number of experiments is too large tofully test in a reasonable amount of time.
it is possible thatvalues or combinations of values not chosen would perform 143table iii ant system parameter tuning statements q0 terps terpw argo .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table iv antq parameter tuning statements q0 terps terpw argo .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
better however we are only looking for guidance and not for the optimal values for each application.
the results for the ant system are shown in table iii.
the parameter values that resulted in the most coverage are .
and q0 .
for both terpspreadsheet and terpword and .
and q0 .
for argouml.
we performed a factorial anov a and tukey test to determine if the factorshad a significant impact on the results as well as to determineif any value of each factor was significant.
the results of theanov a showed that in all three applications both the and q 0factors had a significant impact on the statements covered but that their interactions did not.
parameter values for of .
and .
and a q0of .
were found to have a significant impact for terpspreadsheet.
for terpword an value of .
and aq0value of .
were significant.
finally for argouml values of .
and .
and a q0value of .
had significant impacts on the coverage.
the results for the antq algorithm are shown in table iv.
the parameter values that resulted in the most statementscovered were .
.
and q .
for both terpspreadsheet and terpword and .
.
and q0 .
for argouml.
again we performed a factorial anov a and tukey test.
the anov a showed that no single factor had a significantimpact on the results for all three applications.
the tukeytest results for both terpspreadsheet and terpword showedthat no value for each parameter resulted in significantly morecoverage.
the tukey test results for argouml showed that an value of .
and a value of .
were significantly better.table v test suite algorithm q0 ants k best length tests random ant system .
.
antq .
.
.
table vi statement coverage loc application random ant system antq argouml buddi gantt project terpspreadsheet terpword timeslottracker total c. random testing the random search algorithm in which the two ant algorithms are compared is built on top of the same dynamicsystem.
the random module is given the available validcomponents to execute selects one at random and passes itto the event executor.
we chose to compare against randomselection as the evaluation criteria for meta heuristic search state that any proposed algorithm should perform betterthan random search.
d. test suites table v shows the data regarding the test suites and parameters chosen.
each algorithm was run using tests of length and each suite contained test cases.
for thetwo ant algorithms we used ants per generation and usedthe best ants when updating the trail values.
we repeatedthe process six times for each aut to account for the randomnature of each algorithm.
we did not limit the running time but rather allowed each algorithm to run the same number ofevents.
this was done to ensure fairness.
e. coverage metrics the statement coverage results are shown in table vi.
in five out of six applications antq performed better than random selection.
random selection performed better thanboth ant algorithms for terpspreadsheet.
we performed atukey test comparing each algorithm and found that antqwas significantly better than random selection and the antsystem for both argouml and buddi.
random selection wasnot significantly better than antq for any aut however itdid perform significantly better than the ant system for bothterpspreadsheet and timeslottracker.
in five out of the six applications under test antq coversmore statements than random selection.
figs.
to show the increase in coverage over time for all three algorithms.
in the case of argouml buddi gantt 144table vii statement coverage comparison aut rand ant antq guitar exsyst abtest argo.
terps.
terpw.
times.
table viii exceptions found average total application random ant system antq argouml .
.
.
buddi gantt project terpspreadsheet .
terpword .
.
.
timeslottracker .
.
.
average total .
.
.
project terpword and timeslottracker the antq system is consistently better than random selection.
in the case ofterpspreadsheet the antq and random algorithms grow at asimilar pace.
in five out of the six applications under test antq scoverage growth dominates random selection s coveragegrowth.
we compare our statement coverage results with those published in .
the results can be seen in tablevii.
in the case of guitar and exsyst our three algorithmsoutperform them in all cases.
in the case of autoblacktest our system finds the same level of coverage.
f .
unhandled exceptions table viii shows the number of uncaught exceptions found.
neither buddi nor gantt project threw any uncaught exceptions.
the ant algorithms found on average an equal or greaternumber of exceptions compared to random selection.
antq found a greater number of uncaught exceptions thanboth the ant system and random selection.
again we performed a tukey test and found that antq found a significantly higher number of exceptions than theant system for timeslottracker.
no other pairs of algorithmsfor any aut were found to have significant differences.
g. cost table ix shows the average running time for each test suite on each application.
the random selection algorithm outperforms both the ant system and antq algorithms in alltable ix average time to run hours application random ant system antq argouml .
.
.
buddi .
.
ganttproject .
.
terpspreadsheet .
.
.
terpword .
.
.
timeslottracker .
.
.
total .
.
.
table x fitness function evaluation application pearson value argouml .
buddi .
gantt project .
terpspreadsheet .
terpword .
timeslottracker .
cases.
the results are not surprising as both ant algorithmsmust maintain a trail graph.
furthermore the ant algorithmshave more complex selection procedures.
h. evaluating the fitness function in order to determine if our fitness function is effective we measured the correlation of the cumulative state change ratio with the statement coverage for every test case for eachapplication using antq.
we compared the values using thepearson test with .
.
table x shows the results.
in the cases of argouml gantt project terpword and timeslottracker there is a weak to strong positive correlationbetween the state change ratio and the statement coverage.in the case of buddi and terpspreadsheet there is a weaknegative correlation between the two values.
figs.
to 15show the scatter plots comparing the state change ratio valuesto the number of statements covered for the antq algorithm.there is evidence that the fitness function provides positiveresults however the effectiveness of the function depends onthe application under test.
i. the effectiveness of random testing this evaluation shows that random selection for dynamic gui testing can be effective in finding faults.
little to no research has been conducted on the viability of random selectionfor guis.
many of the systems discussed in the literature donot compare against random selection.
autoblacktest iscompared against guitar exsyst is compared againstguitar randoop and evosuite bauersfeld et al.
compare their ant system to random selection but they onlyreport on the size of the maximum call tree and not on thecode coverage or faults found guitar does implementa random algorithm but when compared to dynamic systems it has been shown to perform worse .
our results show thatrandom selection is a viable option for dynamic gui testing.
30010000110001200013000140001500016000170001800019000200002100022000argouml coverage over time test numberstatements random antcolonyantq fig.
argouml0 3005000600070008000900010000110001200013000140001500016000buddi coverage over time test numberstatements random antcolony antq fig.
buddi0 30070008000900010000110001200013000140001500016000170001800019000ganttproject coverage over time test numberstatements random antcolonyantq fig.
gantt project 300200022002400260028003000320034003600380040004200terpspreadsheet coverage over time test numberstatements random antcolonyantq fig.
terpspreadsheet0 300200025003000350040004500500055006000650070007500terpword coverage over time test numberstatements random antcolony antq fig.
terpword0 300350040004500500055006000650070007500timeslot coverage over time test numberstatements random antcolony antq fig.
timeslot 0129000100001100012000130001400015000argouml state ratio vs. coverage state change ratiostatements fig.
argouml012344000500060007000800090001000011000buddi state ratio vs. coverage state change ratiostatements fig.
buddi01234600070008000900010000110001200013000ganttproject state ratio vs. coverage state change ratiostatements fig.
gantt project 0123100020003000terpspreadsheet state ratio vs. coverage state change ratiostatements fig.
terpspreadsheet012310002000300040005000terpword state ratio vs. coverage state change ratiostatements fig.
terpword0123300040005000timeslot state ratio vs. coverage state change ratiostatements fig.
timeslot 146j.
threats to v alidity internal validity which refers to our ability to determine a causal relationship in our observations in this case the algorithm used and the code coverage and exceptions found is held by the fact that only the algorithms used could haveaffected the coverage metrics and exceptions.
furthermore theapplications under test have all been used in the literatureand are therefore less prone to selection bias.
terpword andterpspreadsheet were used in gantt project in argouml in and buddi and timeslottrackerwere used to evaluate autoblacktest .
when testing eachof the auts we used the default settings provided as well we cleared any changes to the properties after the completionof each test case.
external validity which refers to our ability to generalize our results is also held.
guis are a general concept that canbe implemented in any programming language.
the widgetsused in most guis buttons text boxes etc.
can be expectedto work the same as the widgets provided by java swing.
fur thermore the concept of a gui heirarchy that can be traveresedcan also be expected to exist in other gui implementations.there exist guis with a rich array of input types such asfor mobile applications that deal with touch input.
thesetypes of inputs can usually be programatically executed andso methods such as ours should still be applicable.
therefore the methods presented in this paper should be generalizable toother systems.
construct validity which refers to how we measured the results is also upheld.
the code coverage was measured usingcobertura an open source application that is well main tained.
we counted uncaught exceptions by implementing ourown exception listener which extends the exception listenerthat is a part of the jdk.
vi.
c onclusion and future work in this paper we introduced a new method of testing guis based on ant colony optimization.
we created two ant systems.the first system implements the normal ant colony optimiza tion algorithm in which ants explore a graph and pheromonesare deposited after each generation.
our second algorithmimplements the antq algorithm which uses q learning toupdate the paths as ants explore the graph.
our fitness functionis based on the amount of change that occurs in the gui asevents are executed.
both ant systems use the same fitnessfunction.
we compared our two ant systems against random selection and found that the antq system was able to achieve thehighest levels of code coverage.
when comparing the numberof uncaught exceptions we found that the three algorithmsfound a similar number of errors on average and that the antqalgorithm found the most in total.
our results merit furtherstudy into the ant system and random selection in general.
in the future we would like to incorporate the ability to evaluate correct gui states such as those presented in asour system currently only looks at uncaught exceptions.
wewould also like to investigate an algorithm for finding goodinputs to the gui widgets such as the method presented in where the authors extract the widget data based on textualdescriptions either from the widget itself or surroundingwidgets.
this information can be used to determine what typeof data to input during a test s execution such as a digit string or date.
a cknowledgment we would like to thank leonardo mariani and oliviero riganelli for their input regarding the fitness function calcula tion.
r eferences seleniumhq web application testing system.
online.
accessed feb. andrews j.h.
briand l.c.
labiche y .
is mutation an appropriate tool for testing experiments?
in proceedings of the 27th international conference on software engineering icse .
st. louis missouri .
arcuri a. iqbal m.z.
briand l. formal analysis of the effectiveness and predictability of random testing.
in acm international conferenceon software testing and analysis issta pp.
arcuri a. iqbal m.z.
briand l. random testing theoretical results and practical implications.
software engineering ieee transactionson38 bae g. rothermel g. bae d.h. on the relative strengths of modelbased and dynamic event extraction based gui testing techniques anempirical study.
in software reliability engineering issre 2012ieee 23rd international symposium on pp.
.
ieee bauersfeld s. wappler s. wegener j. a metaheuristic approach to test sequence generation for applications with a gui.
in search basedsoftware engineering pp.
.
springer becce g. mariani l. riganelli o. santoro m. extracting widget descriptions from guis.
in fundamental approaches to softwareengineering pp.
.
springer brooks p.a.
memon a.m. introducing a test suite similarity metric for event sequence based test cases.
in software maintenance .icsm .
ieee international conference on pp.
.
ieee bryce r.c.
sampath s. memon a.m. developing a single model and test prioritization strategies for event driven software.
softwareengineering ieee transactions on cobertura development team cobertura web site .
cobertura.sourceforge.net csallner c. tillmann n. smaragdakis y .
dysy dynamic symbolic execution for invariant inference.
in proceedings of the 30th interna tional conference on software engineering pp.
.
acm dorigo m. gambardella l. ant q a reinforcement learning approach to the traveling salesman problem.
in proceedings of ml twelfthintern.
conf.
on machine learning pp.
dorigo m. maniezzo v .
colorni a. ant system optimization by a colony of cooperating agents.
systems man and cybernetics part b cybernetics ieee transactions on fraser g. arcuri a. evosuite automatic test suite generation for object oriented software.
in proceedings of the 19th acm sigsoftsymposium and the 13th european conference on foundations ofsoftware engineering pp.
.
acm fraser g. zeller a. mutation driven generation of unit tests and oracles.
in intl.
symp.
on software testing and analysis issta pp.
godefroid p. klarlund n. sen k. dart directed automated random testing.
in proceedings of the acm sigplan conferenceon programming language design and implementation pldi pp.
.
chicago gross f. fraser g. zeller a. exsyst search based gui testing.
in intl.
conf.
on software eng.
icse pp.
gross f. fraser g. zeller a. search based system testing high coverage no false alarms.
in proceedings of the internationalsymposium on software testing and analysis pp.
.
acm harman m. jones b. search based software engineering.
journal of information and software technology huang s. cohen m.b.
memon a.m. repairing gui test suites using a genetic algorithm.
in software testing verification and validation icst third international conference on pp.
.
ieee jia y .
harman m. an analysis and survey of the development of mutation testing.
software engineering ieee transactions on mariani l. pezz e m. riganelli o. santoro m. autoblacktest a tool for automatic black box testing.
in software engineering icse 33rd international conference on pp.
.
ieee mcmaster s. memon a.m. call stack coverage for gui test suite reduction.
software engineering ieee transactions on mcminn p. search based software test data generation a survey.
software testing verification and reliability memon a.m. an event flow model of gui based applications for testing.
software testing verification and reliability memon a.m. banerjee i. nagarajan a. gui ripping reverse engineering of graphical user interfaces for testing.
in working conf.on reverse eng.
wcre pp.
memon a.m. pollack m.e.
soffa m.l.
hierarchical gui test case generation using automated planning.
software engineering ieeetransactions on myers g.j.
the art of software testing.
wiley new york nguyen b. robbins b. banerjee i. memon a. guitar an inno vative tool for automated testing of gui driven software.
automated software engineering pp.
pacheco c. lahiri s.k.
ernst m.d.
ball t. feedback directed random test generation.
in in proceedings of the 29th internationalconference on software engineering icse pp.
.
min neapolis mn ruiz a. price y .w.
test driven gui development with testng and abbot.
software ieee tillmann n. de halleux j. pex white box test generation for.
net.
in tests and proofs pp.
.
springer van rompaey b. du bois b. demeyer s. rieger m. on the detection of test smells a metrics based approach for general fixtureand eager test.
software engineering ieee transactions on watkins c.j.
dayan p. q learning.
machine learning xie q. memon a. designing and comparing automated test oracles for gui based software applications.
acm trans.
softw.
eng.methodol.
xie q. memon a.m. using a pilot study to derive a gui model for automated testing.
acm transactions on software engineering andmethodology tosem xie t. tillmann n. de halleux j. schulte w. fitness guided path exploration in dynamic symbolic execution.
in dependable systems networks .
dsn .
ieee ifip international conference on pp.
.
ieee yuan x. cohen m. memon a.m. covering array sampling of input event sequences for automated gui testing.
in automated softwareeng.
ase pp.