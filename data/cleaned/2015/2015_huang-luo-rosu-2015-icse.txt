gpredict generic predictive concurrency analysis jeff huang parasol laboratory texas a m university email jeff cse.tamu.eduqingzhou luo and grigore rosu deparment of computer science university of illinois at urbana champaign email fqluo2 grosug illinois.edu abstract predictive trace analysis pta is an effective approach for detecting subtle bugs in concurrent programs.
existing pta techniques however are typically based on adhoc algorithms tailored to low level errors such as data races or atomicity violations and are not applicable to high level properties such as a resource must be authenticated before use and a collection cannot be modified when being iterated over .
in addition most techniques assume as input a globally ordered trace of events which is expensive to collect in practice as it requires synchronizing all threads.
in this paper we present gpredict a new technique that realizes pta for generic concurrency properties.
moreover gpredict does not require a global trace but only the local traces of each thread which incurs much less runtime overhead than existing techniques.
our key idea is to uniformly model violations of concurrency properties and the thread causality as constraints over events.
with an existing smt solver gpredict is able to precisely predict property violations allowed by the causal model.
through our evaluation using both benchmarks and real world applications we show thatgpredict is effective in expressing and predicting generic property violations.
moreover it reduces the runtime overhead of existing techniques by on dacapo benchmarks on average.
i. i ntroduction the difficulty of concurrent programming has inspired a wide range of fault detection and diagnosis tools.
among them predictive trace analysis pta has drawn a significant attention .
generally speaking a pta technique has two steps it first records a trace of execution events at runtime then offline it generates other often exhaustive permutations of these events under certain causal model of scheduling constraints and predicts concurrency faults unseen in the recorded execution.
pta is powerful as compared to dynamic analysis it is capable of exposing bugs in unexercised executions and compared to static analysis it incurs much fewer false positives.
moreover recent pta techniques such as penelope pecan and can not only predict faults but also produce witnesses i.e.
buggy schedules or even concrete executions that manifest the faults which can significantly speed up the debugging process.
we observe that existing pta techniques are generally limited to detecting low level memory access errors such as data races atomicity violations atomicset serialization violations or deadlocks .
while these errors are common they only capture a small portion of concurrency faults in real world programs.
for example consider a resource authenticate before useproperty which requires a method authenticate to be always called before a method use that uses the resource.
any violation of this property is an indication of a serious security bug.
however it cannot be characterized by conventional data races because in a violation of this property there may not even exist conflicting reads and writes to shared data.
as another example in java a collection is not allowed to be modified when an iterator is accessing its elements.
this property again is neither a data race nor an atomicity violation but a more generic contract on the use of java iterators.
existing techniques do not directly target these properties.
moreover while existing techniques are effective in detecting the targeted race or atomicity errors their algorithms are usually adhoc and are not applicable to such more general properties.
for instance the cut point based algorithm of penelope is specialized for predicting atomicity violations and the pattern directed graph search algorithm in pecan detects concurrency access anomalies only.
furthermore for building the causal model existing algorithms generally assume as input a linearized trace of events which contains all the necessary causal ordering information e.g.
happensbefore between critical events i.e.
shared data accesses and synchronizations .
however this relies on the ability to track a globally ordered sequence of events by all threads at runtime which often incurs hundreds or even thousands of times of program slowdown making these techniques less useful in practice.
in this paper we present a new pta technique gpredict that is able to predict violations of high level more generic properties .
our central observation is that a vast category of concurrency faults together with the causal model can be modeled uniformly as first order logical constraints between events.
for example for the authenticate before use property suppose we model the calls of these two methods as two events auth anduse and give each of them a corresponding order variable oauth andouse respectively.
a violation of this property can be simply modeled by the constraintouse o auth stating that the property is violated if there exists any feasible schedule in which the order of theuse event is smaller than the order of the auth event.
similarly violations of the collection iterator property can be modeled as ocreate o update o next specifying that the property is violated if a collection update event comes between the iterator create event and an iterator next event.
meanwhile inspired by our prior work we canalso soundly encode the causal model as constraints over the order of critical events.
by solving a conjunction of these constraints we can determine if a property can be violated in other feasible executions hence to predict faults defined by the properties.
based on the observation above we first design a specification language for users to specify generic concurrency property violations.
our language is adapted from mop a runtime verification system for parametric properties.
similar to mop users of gpredict can declare the property events which are parametric with aspectj pointcuts and specify the property with a formalism over the declared events.
differently in our formalism we explicitly support concurrency properties by associating events with thread attributes and atomic regions and allowing parallelism between events.
to instantiate our design we implemented an initial specification formalism for properties written in the form of regular expressions.
we present our specification language and the constraint encoding algorithm for the property violations in section ii.
another main contribution of this work is a new and sound causal model that is based on only the local traces of each individual thread rather than a global trace.
this new model not only ensures that gpredict never reports any false positive i.e.
every property violation reported by gpredict is real but also enables gpredict to be synchronization free for collecting the execution traces at runtime incurring much less runtime overhead than existing techniques.
the main challenge we address is how to extract from the thread local traces the synchronization constraints e.g.
causal orderings caused by the signal wait notify events .
we present a formal constraint modeling in section iii and prove its soundness.
we have implemented gpredict for java programs and evaluated it on a set of real world applications with high level generic properties as well as conventional data races atomicity violations and deadlocks written in our specification language.
we show gpredict is both expressive and effective in predicting generic property violations.
moreover comparing to the state of art techniques that log a global trace gpredict has significantly better runtime performance due to the use of thread local traces incurring less overhead on dacapo benchmarks .
we present the implementation and evaluation of gpredict in sections iv and v respectively.
in summary we make the following contributions we present a new predictive trace analysis pta technique gpredict that is able to predict generic concurrency property violations based on constraint solving.
we present a specification language for generic concurrency properties and the corresponding constraint encoding algorithm for the property violations.
we present a sound constraint modeling of the predictive causal model with only the thread local traces as input which frees predictive analysis from expensive runtime synchronizations in order to obtain a global trace.
we evaluate gpredict with real world applications and demonstrate its effectiveness and runtime performance for predicting generic property violations.
t1t2collection item c item a b iterator i1 i2 c.add a start t2 i1 c.iterator i1.next c.add b i2 c.iterator i2.next fig.
.
a collection iterating example ii.
g eneric predictive analysis the idea behind pta is that computations of a concurrent program may be scheduled in different orders due to scheduling non determinism and that from one observed execution a causal model can be constructed to infer a set of similar feasible executions of the same program which can be used to predict behaviours not seen in the observed execution.
gpredict provides a general technique for the pta of generic property violations based on constraint solving.
the main idea is that both the causal model and the property violations can be modeled uniformly by first order logical constraints.
by solving the constraints we can predict property violations in all the feasible executions captured by the causal model.
there are two categories of events in our model property events declared in the property specification.
model events critical events that determine the causal model i.e.
all the reads and writes to shared data and thread synchronizations.
we next present the specification and constraint modeling of property events.
model events are addressed in section iii.
a. overview we first give an overview of gpredict using a simple example.
we then discuss the challenges and explain how we address them.
in fig.
there are two threads t1andt2 accessing a shared collection.
t1first initializes the collection with an item a then it forks t2and iterates over the collection.
int2 it first adds item bto the collection then iterates over the collection.
this program although intuitive may throw aconcurrentmodificationexception because when t1is iterating over the collection t2might simultaneously update the collection which breaks the contract of java iterators.
suppose our problem here is to detect this error.
a classic solution is through runtime verification such as mop that allows the users to specify the safe iterator property using specification formalisms and automatically generates monitors to detect violations of the property at runtime.
however since the error depends on the thread schedule to manifest which is non deterministic conventional runtime monitoring approaches may not detect it.
from a high level view gpredict addresses this problem by analyzing the causal ordering relation between events observed at runtime with a constraint model.
we give each event including both property events and model events an order variable representing its order in the schedule of a possible feasible execution and use these order variables to gpredict specification property name parameters f event pattern g event event id aspectj advicespec aspectj pointcut pattern pattern regexp regexp property name identifier parameters type identifier id identifier aspectj advicespec aspectj advicespec syntax aspectj pointcut aspectj pointcut syntax thread identifier atomregion identifier identifier java identifier syntax begin atomregion end atomregion regexp regular expression over f id id thread begin j end g fig.
.
gpredict property specification language.
the new syntax introduced for concurrency properties is highlighted in gray color.
formulate the property violation.
for example let oidenote the order of the event at line i. a violation of the safe iterator property can be formulated as o3 o o .
similarly the causal ordering constraints between events can be modeled aso1 o o o o5 o o to respect the program order e.g.
o1 o 2means line must happen before line ando2 o to respect the synchronization semantics e.g.
line can only happen after line because t2is forked at line .
conjuncting all these constraints gpredict invokes an smt solver e.g.
z3 to solve them.
if the solver returns a solution it means that there exists a schedule that violates the property.
moreover such a schedule represents a witness to the property violation and can be deterministically replayed to manifest the error.
back to our example the solver may returno1 o2 o3 o4 o5 o6 o7 which corresponds to the property violating schedule .
although our technique can be easily illustrated there are several challenges we must tackle property specification.
how to specify the properties?
what type of formalisms can we support?
how to specify conventional concurrency errors as well such as races atomicity violations deadlocks etc?
property encoding.
how to encode the constraints for parametric properties?
for example in figure both line and line access an iterator of the collection but on different instances if we ignore this difference we might formulate the property as o3 o o 7instead of o3 o o which would result in missing the real property violation.
soundness1 i.e.
no false positive .
how to guarantee that every property violation we detect is real?
for example if there exists certain causal order not modeled by our constraints the detected property violation might be false.
in the rest of this section we focus on discussing the first two issues.
we present a formal constraint modeling of our sound causal model to address the third issue in section iii.
1bysoundness we mean no false positive in this paper.
unsafeiterator collection c iterator i event create after collection c returning iterator i call iterator collection .iterator target c event update after collection c call collection .remove .. call collection .add .. target c event next before iterator i call iterator.next target i pattern create next update next fig.
.
unsafeiterator property specification b. generic property specification gpredict allows specifying properties using regular expressions regexp .
we choose regexps as they are natural and convenient to reflect the ordering relation between property events.
nevertheless our technique should work with any formalism whose properties formulae can be monitored using finite state machine monitors e.g.
linear temporal logic .
fig.
shows the syntax of our property specification language.
it is an extension of the mop specification consisting of the property declaration name and parameters a list of event definitions and a formula specifying the property.
the event syntax makes use of aspectj containing an identifier an advice with no body and a pointcut.
the property is then defined in terms of the event identifiers using regexp.
fig.
shows an example of the unsafeiterator property in our specification.
the property is parameterized by a collection and an iterator.
there are three types of events defined in the specification create creating an iterator i of the collection c update adding or removing an item to from the collection next iterating over the collection via calling next on the iterator .
the formula of the property violation pattern is written as create next update next meaning that the property is violated if an update event can happen after create and before a next .
events in this pattern are parameterized by candias defined in the specification.atomicityviolation object o event begin before object o execution m event read before object o get s target o event write before object o set s target o event end after object o execution m pattern begin t1 r1 read t1 write t2 write t1 end t1 r1 fig.
.
atomicity violation property specification t1t2 m r1 s r2 r1 s r2 m m m fig.
.
an example of atomicity violations to explicitly support concurrency related properties a major difference of our specification from mop is that in the property formula the event identifiers are also allowed to bind with thread attributes and begin end of atomic regions in the form of id thread begin j end .
the thread attribute denotes a meta id of the thread performing the corresponding event such that events bound with different thread attributes are by different threads.
the begin and end attributes are written as atomregion and atomregion denoting the begin and end of an atomic region identified by atomregion .
fig.
shows an example of the read write write atomicity violation written in our specification language that uses these attributes.
the atomicity violation is concerned with three accesses to a shared variable sby two threads which can be declared as read andwrite events using the get andset pointcuts.
the begin andend events mark the beginning and ending of the execution of a method m which is considered to be atomic.
in the formula to distinguish events by different threads we bind each event with a thread attribute e.g.
read t1 andwrite t2 .
to match begin withend they are written as begin t1 r1 and end t1 r1 ensuring that these two events are marking the same atomic region denoted by a meta id r1 .
the whole formula is then written as begin t1 r1 read t1 write t2 write t1 end t1 r1 denoting that the violation occurs if the two read andwrite events inside an atomic region marked by the begin andend events of any thread t1 can be interleaved by a write event from a different thread t2.
fig.
shows a simple program with such atomicity violations.
note that the specification of atomic regions in our language is general and can be specified by arbitrary events and their orders which is much more expressive than conventional atomic regions that are limited to synchronization methods or blocks.
in addition we introduce a new notation in our specification language which is used to denote the parallelism between events.
for example id1 id2 means that the two events id1 and id2 can be executed in parallel with no causal ordering between each other.
this notation is useful for specifying a range of interesting properties e.g.
data datarace object o event read before object o get s target o event write before object o set s target o pattern read t1 write t2 fig.
.
data race property specification races.
fig.
shows the specification of a read write data race property on a shared variable s. the property is parametrized by the object instance of sto distinguish different memory locations.
the read event is declared as a get pointcut and the write event as set.
the formula is then written as read t1 write t2 meaning that the two events by two different threads can happen in parallel.
c. property encoding recall fig.
that properties are written as regexp patterns over the alphabet of the declared event identifiers.
since the events are defined with pointcuts which can be triggered multiple times in the execution each declared event may correspond to multiple event instances in the execution.
we shall refer to such event instances as property events.
consider the order of each event identifier in the regexp patterns.
for the pattern to be satisfied there must exist a corresponding ordered sequence of property events such that each event matches with the corresponding event identifier.
in other words the pattern actually specifies the ordering constraints between property events which can be directly modeled by their corresponding order variables.
to model the constraints specified in the pattern however we must address the following important problems property events must be parametric how to handle the parametricity?
an event identifier may have multiple matching property events how to encode the constraints for all?
our pattern allows the regexp quantifiers ?
as well as negation !
boolean logics and and grouping parentheses and supports the bindings of thread attributes atomic regions and the parallel notation how to handle all these features?
parametricity for parametric property events the key is to bind the property parameters to concrete object instances.
each binding corresponds to a different property instance and we construct a separate constraint.
constraints of all property instances can then be combined together by disjunction .
to create the bindings for each instance we enumerate the set of object instances corresponding to each parameter associated with the property events.
for each object instance we create a separate binding to the corresponding parameter.
by joining the bindings for all parameters in the property we can create the bindings for all property instances.
the total number of bindings is a multiplication of the number of object instances for each parameter.
back to our example in fig.
there is only one binding to the collection parameter c and two to theiterator parameter i1andi2 hence there are two parametric bindings in total c i1 and c i2 .
multiple event instances for each event identifier in the pattern since the existence of one such property event is sufficient to witness the property violation if there are multiple events corresponding to an identifier it seems intuitive to pick any one to build the constraint.
however this naive approach may miss predictable property violations because the constraint with respect to the chosen event might not be satisfied while there might exist other events that are not chosen that can manifest the property violation.
to address this issue similar to parametric bindings we enumerate the corresponding events per property instance that match with the event identifier in the pattern.
for each property event we create a separate ordering constraint and disjoin them.
in this way no property violation will be missed.
back to our example for the property instance c i1 there exist two update events at lines and respectively so we construct the disjunction o3 o o 4 o3 o o .
although o3 o o 4cannot be satisfied because line must happen before line o3 o o 4can so the property violation can still be detected.
regexp pattern constructs taking the regexp pattern as input we first preprocess it to handle quantifiers ?
.
for ?
we replace it by meaning that one or zero of its preceding event identifier may appear in the pattern.
for and because both of them can denote an infinite number of events to avoid exploding the constraints we remove and its associated event identifier or identifiers from the pattern because can denote zero event and remove from the pattern because can denote one event .
for example the unsafeiterator pattern in fig.
create next update next is processed to create update next .
this treatment however may result in missing certain violations.
we expect this is acceptable since gpredict is used for predicting if a property can be violated or not.
the number of violations is less important.
in fact we may simply exclude and from the specification.
we choose not to so that existing mop properties can be supported without any change.
in constructing the constraints we handle !
and as follows.
for !
we add a negation i.e.
a logicalnot to the corresponding constraint.
note that !
may conflict with our treatment to and which results in over approximation when !
and or are used together in the pattern.
to avoid this issue we disallow such patterns in our specification.
for and we take them as disjunction and conjunction respectively between the corresponding constraints.
for we create an equality constraint between the order variables of the two events2.
for example for the data race specification in fig.
for any pair of such property events eijjej we add the equality constraint oi oj.
for parentheses that embrace thread attributes and atomic regions we handle them as follows.
2currently we only support for two parallel events.for thread attributes similar to the treatment of parametric bindings we first group the corresponding events by their thread id and then enumerate each group.
during enumeration the only condition is that events with different thread attributes must be bound to different groups of events.
for example consider the example in fig.
with the data race pattern read t1 write t2 we can bind both t1 andt2to either t1ort2 but they cannot be simultaneously bound to the same thread.
the constraints of different groups are then combined together by disjunction.
for atomic region attributes note that we must match each begin event with its corresponding end event otherwise it might lead to false alarms.
taking fig.
as an example.
suppose we change the method mto be synchronized then there is no atomicity violation.
however since m is called twice by thread t1 there are two begin and two end events by t1 if the first begin is matched with the second end then the ordering of events can still be satisfied when t2calls mbetween the two calls of mbyt1 which is not a real atomicity violation.
hence to maintain a correct match we preprocess all events with atomic region attributes.
because all such events are always nested we can simply use a stack to keep track of the current active atomic region and match each begin with the correct end .
we assume the specified regexp pattern is consistent and currently we do not perform any static checking for it.
otherwise if the pattern is inconsistent no violation will be predicted.
iii.
c onstraint modeling several previous work have used firstorder logical smt formulae to model the ordering constraints between events.
our constraint modeling of the causal model extends our prior work with the main improvement that it is built upon the thread local traces instead of a global trace.
we consider the following types of model events begin t end t the first last event of thread t read t x v write t x v read write a value von a shared variable x lock t l unlock t l acquire release a lock l fork t t0 join t t0 fork a new thread t0 block until threadt0terminates wait t l g a composition of three consecutive events3 unlock w t l wait t g lock w t l first release lock l then block until receiving signal g finally acquire l notify t g notifyall t g send a signal gto wake up a waiting thread all waiting threads.
from a high level view taking the model events by each thread as input we encode all the necessary ordering constraints between model events as a set of first order logic formulae.
the whole formula is a conjunction of three sub formulae over the order variables of the model events mhb sync rw 3in this work we do not model spurious wakeups which happen rarely in practice and are typically handled by enclosing wait in loops.a.
must happens before constraints mhb the must happens before mhb constraints capture the causal order between events that any execution of the program must obey.
let denote the smallest transitively closed relation over the events in the observed execution such that for any two events eiandej ei ejholds if one of the following holds program order eiandejare by the same thread and ei occurs before ej.
fork order ei fork t t0 andej begin t0 .
join order ei end t andej join t0 t .
for each mhb relation ei ej we add a conjunction of the constraint oi ojto mhb.
the size of mhbis linear in the total number of model events.
b. synchronization constraints sync the synchronization constraints capture the locking and wait notify semantics introduced by synchronization events lock unlock wait notify and notifyall .
recall the semantics that a wait t l g event can be split into three events unlock w t l wait t g lock w t l .
hence we divide each lock region enclosing wait into two smaller lock regions.
sync is constructed as a conjunction of two constraints locking constraints lock for each lock l we first extract a setsof all the lock unlock pairs onl including unlock w andlock wfrom the wait events following the program order locking semantics i.e.
anunlock event is paired with the most recent lock event on the same lock by the same thread.
we then add the following constraint to lock a b a0 b0 2s ob oa0 ob0 oa the size of lockis quadratic in the number of lock regions.
wait notify notifyall constraints signal the core problem of constructing signal is to find for each wait event a matching notify ornotifyall event that can send the correct signal to wake it up.
in previous predictive trace analysis work this task is easy because a global trace is available and each wait can be simply matched with the most recent notify ornotifyall event with the same signal.
however this problem becomes challenging when we have only the thread local traces where there is no causal ordering information between wait notify notifyall events across different threads.
for example we cannot match await with an arbitrary notify because the notify might happen after the wait or it might have been matched with another wait.
we develop a sound constraint model that addresses this issue.
our key observation is that wait and notify notifyall events are always executed inside a lock region.
for a wait t1 l g to match with a notify t2 g suppose the enclosing lock regions of wait t l g and notify t2 g are marked by lock t1 l unlock t1 l and lock t2 l unlock t2 l respectively it must hold that the unlock w t1 l event must happen before lock t2 l .
otherwise notify t2 g would happen before unlockw t l and the signal would be lost.
meanwhile for all the other wait events they must be either before lock t2 l or after unlock w t1 l .
otherwise notify t2 g might be matched with more than one wait event.
specifically let xandydenote the set of wait andnotify events on the same signal.
for each wait t l g eventw let oul w ow andol wdenote the corresponding order variables ofunlock w t l wait t g andlock w t l respectively and letole ouledenote the order variables of the lock unlock events of the enclosing lock region of a wait ornotify event e. signal forwis written as follows w2x n2y oul w oln on ow w6 w02x oulw ol w0 oulw0 oln the constraint model for wait notifyall is similar except that the conjunction over the other wait events inxis not needed because a notifyall event can be matched with multiple wait events.
the total size of signal is2jxj2jyj which is cubic in the number of wait notify notifyall events.
c. read write constraints rw the read write constraints ensure the data validity of events a read must read the same value as that in the observed execution though it may be written by a different write.
specifically for each property event p we add a constraint rw p to rw.
rw p is constructed over a set r containing all the read events that must happen before it.
for each read t x v inr letwdenote the set of write x events in the trace here means any value and wvthe set of write x v events.
rw p is written as 8w2wv rw w ow or 8w02wow0 ow ow0 or the constraints above state that the read event r may read the valuevonxwritten by any write event w write x v inwv which is a disjunction with the constraint that the order ofwmust be smaller than the order of r and there is no other write x event that is between them.
moreover thiswrite x v event itself must be feasible so we add a conjunction of the constraint rw w .
the size of rwis cubic in the number of read andwrite events.
nevertheless in practice rwcan be significantly reduced by considering the mhb relation .
for example consider two write eventsw1andw2inwv.
ifw1 w2 r we can exclude w1fromwvbecause it is impossible for r to read the value written by w1due to mhb.
similarly for anyw02w ifr w0 thenw0can be excluded from w. also when constructing the constraints for matching an event w2wvtor ifw0 w thenw0can be skipped.
d. soundness the next theorem states that our constraint modeling based on the thread local traces is sound theorem .
captures a sound causal model i.e.
any solution to represents a feasible schedule.
proof.
sketch it s clear that mhband rwcapture the data and control dependencies for every event in the trace.
thet1t2lock l ...unlock w l wait g lock w l ...unlock l x1 x2 x3 x4 x5 t3lock l ...unlock w l wait g lock w l ...unlock l y1 y2 y3 y4 y5 lock l ...notify g ...unlock l z1 z2 z3 x2 z1 z2 x3 x5 y4 y5 z1 y2 z1 z2 y3 y5 x4 x5 z1 x1 x2 x3 x4 x5 y1 y2 y3 y4 y5 z1 z2 z3 x1 y2 x2 y1 x1 y5 x2 y4 x1 z3 x2 z1 x3 y2 x4 y1 x3 y5 x4 y4 x3 z3 x4 z1 y1 x5 y2 x4 y1 z3 y2 z1 y4 x5 y5 x4 y4 z3 y5 z1 mhbconstraintlockingconstraintswait notifyconstraintsfig.
.
example of synchronization constraints only less obvious part is the thread synchronization constraints captured by sync.
let s use an example in fig.
to show the soundness of sync.
for simplicity we use the label to the left of each event to refer to both the event and its order variable.
in the example program both threads t1andt2perform a wait within a lock region x1 x5andy1 y5respectively on lock l andt3performs a notify z2 within a lock region z1 z3 on the same lock.
following the semantics of wait the wait events oft1andt2are split into six events denoted by x2 x3 x4 andy2 y3 y4 respectively .
hence there are five lock unlock pairs in the trace.
our locking constraints shown in the figure enforces that every two lock unlock pairs by different threads cannot overlap.
clearly mutual exclusion is ensured.
for waitnotify note that there is only one notify event but two wait events either the wait event of t1or of t2can be matched with the notify event but not both.
following our construction of signal our constraints for the two wait events are written asx2 z1 z2 x3 x5 y4 y5 z1 and y2 z1 z2 y3 y5 x4 x5 z1 .
by analyzing the conjunction of these two constraints we can see that it contradicts with the locking constraints.
hence signal cannot be satisfied which ensures the semantics that a notify cannot be matched with more than one wait event.
iv.
i mplementation we have implemented gpredict for java programs based on javamop and soot .
fig.
shows an overview of the gpredict infrastructure.
taking the target program java bytecode and the property specification as input gpredict first adds necessary instrumentation into the program for logging the model events during execution and uses javamop s frontend parser to produce a corresponding aspectj file for the property.
during program execution the aspectj file is weaved into the instrumented program to emit the property events.
all events are logged and grouped by their thread id and saved into database together with the property pattern.
then taking the logged information as input the offline analyzer constructs the necessary constraints and invokes an smt solver to solve them.
a property violation is reported if the solver returns a solution.
we next present each of the components in detail.
propertiesjavamopprograminstrumentort racecollector.ajconstraintbuildersmtsolverviolationsfig.
.
overview of gpredict architecture instrumentation this phase consists of two parts.
the first part takes in the target program and performs the instrumentation on jimple an intermediate representation of java bytecode in the three address form .
the instrumented events include read and write accesses to shared data such as instance fields and class variables entry and exit to monitors and synchronized methods wait and notify notifyall method calls and thread fork and join.
the second part is parsing the property specification.
since our specification language is adapted from mop we make use of javamop parser to produce an aspectj file with each declared event converted into a corresponding pointcut.
the aspects are then weaved into the instrumented program dynamically to emit both the model events and property events at runtime.
trace collection for each model event we log the runtime data as described in section iii such as the thread id the memory address the read or write value etc.
the logging of property events is slightly different.
recall section ii c1 that for parametric properties we need to group events into different property instances according to the runtime object of the event.
instead of performing this grouping task offline we do it online by reusing the monitoring mechanism of javamop.
specifically javamop internally creates a separate monitor for each property instance and matches each event to all the related monitors.
hence we simply insert a logging method call in each monitor function and save the property event associated with the monitor id which is equivalent to the property instance into database.
during constraint construction we can directly use the monitor id to identify each property instance without grouping the events again.
in order to reduce the runtime overhead remember that our technique does not collect a global trace but the events for each thread separately.
we maintain for each thread a threadlocal buffer for storing the events performed by itself.
once a new event is created by a thread we add it to the thread s local buffer.
at the end of the logging phase all events are saved into database indexed by the thread id.
constraint construction and solving the constraint construction follows the algorithms in section ii c for property constraints and section iii for model constraints .
it is worth noting that our constraint model is very extensible.
it is not limited to a single property but multiple properties can be encoded simultaneously.
for instance the unsafeiterator property can be encoded together with the data race patterns by a disjunction.
for solving the constraint we use z3 in our implementation and set the timeout to five minutes.
note that almost all of our constraints are ordering constraints i.e.
comparing two integer variables by which can be effi public void addchangelistener serieschangelistener listener this.listeners.add listener public void fireserieschanged notifylisteners new serieschangeevent this protected void notifylisteners serieschangeevent event iterator iterator listeners.iterator while iterator.hasnext serieschangelistener listener serieschangelistener iterator.next listener.serieschanged event fig.
.
jfreechart bug ciently solved by the integer difference logic idl .
the only exception is the equality constraints i.e.
oi oj encoded for in the property specification.
for such constraints we simply filter them out by replacing all occurences of oi in the constraints by oj.
v. e valuation we have evaluated gpredict on a set of real concurrent programs with both generic properties and conventional concurrency errors written in our specification language.
moreover to assess the improved runtime performance of gpredict over previous techniques by using thread local traces we have rungpredict with a set of dacapo benchmarks and compared its performance with the approach of logging global traces.
this section presents our results.
all experiments were conducted on a core .50ghz intel i7 linux machine.
a. effectiveness we have applied gpredict to six programs derby h2 jfreechart jigsaw and two jdk libraries and examined properties including unsafeiterator nullpointer dereference unsafedatabaseaccess check then act as well as data races atomicity violations and deadlocks.
the results shown table demonstrate that gpredict is effective in expressing properties and predicting violations.
unsafeiterator fig.
shows a real bug violating the unsafeiterator property as explained in section ii b in jfreechart .
when the two methods addchangelistener and fireserieschanged are called concurrently by different threads a concurrentmodificationexception may be thrown.
the reason is that in fireserieschanged an arraylist of listeners are iterated to notify the serieschangedevent while new listeners can be added to the arraylist from addchangelistener concurrently.
this error is common in concurrent programs however as it is neither a data race nor an atomicity violation it cannot be detected by conventional race or atomicity violation detectors.
with gpredict it is fairly easy to specify the unsafeiterator property as shown in fig.
and to predict violations.
based on a normal run of the test driver class tabledescriptorpublic string getobjectname if referencedcolumnmap null ... else if referencedcolumnmap.isset ... ... public void setreferencecolumnmap .. referencedcolumnmap null nullpointerdereference object o event deref before object o get tabledescriptor.referencecolumnmap target o event setnull before object o object value set tabledescriptor.referencecolumnmap target o args value if value null pattern deref t1 setnull t2 derby bug 2861fig.
.
null pointer dereference specification provided in the bug repository which does not manifest the bug gpredict captured property events and model events and predicted violations within a second.
we manually inspected all these violations and empirically confirmed that these violations were all real.
note that each violation is unique with respect to the event sequences defined in the property.
we did not further prune redundant violations with the same event signature.
null pointer dereferences null pointer dereference errors are common in multithreaded programs.
though they are not unique to concurrency they are much harder to detect in multithreaded programs.
fig.
shows the concurrency bug in apache derby .
this bug is concerned with a thread safety issue in the tabledescriptor class.
the shared data referencedcolumnmap is checked for null at the beginning of the getobjectname method and later dereferenced if it is not null .
due to an erroneous interleaving another thread can set referencedcolumnmap tonull in the setobjectname method and causes the program to crash by throwing a nullpointerexception .
this bug is in fact an atomicity violation but it can be specified more intuitively as a null pointer dereference.
users need only to declare two events deref andsetnull on the variable referencedcolumnmap and specify the pattern as deref t1 setnull t2 meaning that the two events are from different threads and can be run in parallel.
because deref is declared as an event on dereferencing referencedcolumnmap and setnull an event setting referencedcolumnmap tonull on the same tabledescriptor object represented by the property parametero a null pointer dereference can happen if the pattern is satisfied.
we ran gpredict on derby with this property.
gpredict collected a trace with around 12k model events and property events and found violations in 5s.
note that although our specification in this example fig.
bottom only concerns about the field referencedcolumnmap it could be written for arbitrarytable i experimental results program loc property threads model events property events violations time jfreechart 51k unsafeiterator .85s h2 136k unsafedatabaseaccess .67s derby1 302k nullpointerdereference .7s derby2 368k check then act .5s jigsaw 101k data race .6s stringbuffer atomicity violation .4s jdk logger deadlock .6s unsafedatabaseaccess connection conn string table event open after returning connection conn call connection drivermanager.getconnection string event close before connection conn call void connection.close target conn event create before connection conn string table call createtable connection conn string table args conn table event delete before connection conn string table call deletetable connection conn string table args conn table event update before string table string sql call boolean statement.execute string args sql if sql.contains table pattern !
open create update delete close fig.
.
unsafe database access specification orallreference fields.
if the user wants to detect allnullpointer dereferences she can simply replace the parameter of the get set pointcuts with a wild card .
in that case our algorithm will enumerate all fields.
unsafedatabaseaccess database applications typically follow some safe patterns to access data.
for example an authenticated connection must be established first before any other operation a table must be created before any update or query accesses on the table all operations must finish before closing the database connection etc.
there is likely a bug if the application violates such patterns.
fig.
shows the specification of an unsafedatabaseaccess property which defines five property events open connection create table update table delete table and close connection over two parameters the connection and the table name .
the pattern !
open create update delete close specifies that the property is violated when these events happen in an order different from the written one.
the negation symbol !
is interpreted as a logical not in the property constraints.
theunsafedatabaseaccess property cannot be handled by existing techniques such as serializability violation detectors even with event abstraction or typestatebased detectors because any violation instance of this property contains events over multiple objects.
in our experiment we wrote a simple multithreaded client program for testing the h2 database server with gpredict .gpredict found violations in less than a second based on a trace of the client program with model events and property events4.
check then act collections are frequently used following the check then act idiom the code first checks 4as h2 was run in the server model we did not log its model events.
class genericlanguageconnectioncontextpublic void removestatement ... cacheable cacheditem statementcache.findcached statement if cacheditem !
null statementcache.remove cacheditem checkthenact map m object key event check after map m object key call map .get object target m args key event act before map m object key call map .remove object .. target m args key .. pattern check t1 act t2 act t1 derby bug 3786fig.
.
check then act specification a condition and then acts based on the result of the condition.
however in concurrent programs misuse of this idiom can easily lead to bugs .
fig.
shows another bug in derby .
the method removestatement first checks if the statementcache contains a statement and if yes it removes the statement by calling the method remove .
to support concurrent accesses the data structure for maintaining the statementcache is implemented as aconcurrenthashmap .
however due to some bad interleaving more than one thread might still execute the remove method concurrently causing an assertion failure eventually.
fig.
bottom shows the check then act property in our specification language.
in the pattern the check event and the second act event are bound to thread t1 and the firstact event to t2.
the pattern means that a violation happens if two check andact events consecutive in a certain thread can bracket another act event from a different thread.
gpredict collected a trace of 20k model events and .3k property events and found violations in around 8s.
races atomicity violations and deadlocks our technique also works seamlessly for predicting conventional errors such as data races atomicity violations and deadlocks without anything specific for them.
moreover these errors can be specified more intuitively with our specification language by high level events than previous techniques that rely on checking low level shared data accesses.
we have also applied gpredict to predict data races in jigsaw and a deadlock bug in jdk logging package.
due to space limit we omittable ii runtime performance comparison program threads base global gpredict avrora .8s 2m20s 2m6s batik .1s 2m28s 1m2s xalan .7s 6m14s 1m9s lusearch .4s 15m17s 3m16s sunflow 1s 19m48s 11m28s the discussions.
all details and more examples can be found at jeff gpredict .
b. runtime performance to understand the performance improvement of our technique i.e.
enabling the use of thread local traces instead of a global trace we quantify gpredict using a set of widely used third party concurrency benchmarks from dacapo shown in table .
all these benchmarks are real world applications containing intensive shared data accesses and synchronizations by concurrent threads.
previous pta techniques can incur significant runtime slowdown on these benchmarks because logging a global trace requires synchronizing every model event with a global lock protecting the logging data structure.
however logging thread local traces allows the recording computation by different threads to be done in parallel which is much cheaper as no extra synchronization is required.
to perform an unbiased comparison we also implemented ingpredict the ability of logging global traces to ensure the same events are logged at runtime.
in our experiment we configure gpredict to run each benchmark with three different modes for logging the model events no loggging logging per thread traces and logging a global trace.
table shows the results.
all data were averaged over five runs.
compared with logging a global trace recording the threadlocal traces incurs significantly less runtime overhead with respect to the base execution.
on average gpredict reduces the runtime overhead by for the evaluated benchmarks ranging between and .
for xalan gpredict is even more than four times faster.
although the overhead of gpredict is still large because there is a myriad of model events to log in these benchmarks compared to previous techniques that require logging a global trace gpredict significantly improves the runtime performance of predictive trace analysis.
to further reduce the overhead we can use static analysis techniques to eliminate redundant events during instrumentation.
vi.
r elated work as discussed in section i although a large body of predictive analysis work has been developed a common difference between these work and gpredict is that their algorithms are typically tailored to low level memory access errors such as data races and atomicity violations and do not work for the generic concurrency properties we address in this work.
with gpredict developers are able to specify high level properties usingaspects and regular expressions and to predict bugs related to specified code regions that are suspected to be buggy.
besides the specification language another important contribution of this work is our sound causal model based on thread local traces which is realized with constraints.
a few different causal models have been proposed before however all based on global traces rather than local traces.
our own prior work clap also uses thread local reasoning to help reproducing bugs.
however the thread local concept there is different.
in the thread local control flow is captured to reconstruct a buggy schedule whereas our thread local tracing in this work is concerned with the model events not control flow for building the causal model.
typestate based concurrency bug detectors can also detect high level program semantics bugs as typestate allows event abstraction.
a key limitation is that typestate is nonparametric and only characterizes single type or single object properties.
for example the unsafedatabaseaccess property in fig.
cannot be expressed with typestate.
moreover existing detectors can often produce false alarms because they do not have a sound causal model.
2ndstrike prunes false alarms via re execution.
however it may miss real bugs due to the scheduling non determinism.
many runtime verification frameworks have been developed to detect program errors dynamically such as javamop pql tracematches etc.
users of these frameworks can specify events and patterns to monitor.
when a pattern is satisfied or violated at runtime users can provide extra handlers to perform additional function e.g.
to recover from bad states.
our technique is complimentary to runtime verification as it can predict errors by inferring other feasible schedules.
different from predicting property violations a few techniques have also been proposed to enforce properties at runtime.
vaziri et al.
develop a language for defining datacentric synchronizations over high level data race patterns and generate code to obey the properties at runtime.
in our prior work enforcemop we have also developed a language and runtime system that allows the users to define and enforce general properties for multithreaded programs.
vii.
c onclusion we have presented gpredict a new predictive trace analysis technique that works for high level more generic concurrency properties.
our technique advances the state of the art in three aspects .
we develop a general constraint model that enables uniformly reasoning about the causal ordering between high level declarable events in concurrent program executions.
.
we provide an expressive language to specify and to predict generic property violations based on existing constraint solvers.
.
our technique does not require a global trace of events as input but only the set of local traces by each thread.
with gpredict users can specify concurrency errors more expressively and at the same time predict these errors with much smaller runtime overhead.
our evaluation with gpredict on real world applications demonstrates the effectiveness and the performance of our technique.